### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\services\review ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\services\review =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\review\hostel_response_service.py ---
# app/services/review/hostel_response_service.py
from __future__ import annotations

from datetime import datetime, date
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Protocol
from uuid import UUID, uuid4

from sqlalchemy.orm import Session

from app.repositories.content import ReviewRepository
from app.repositories.core import HostelRepository, UserRepository
from app.schemas.review.review_response_schema import (
    HostelResponseCreate,
    OwnerResponse,
    ResponseUpdate,
    ResponseGuidelines,
    ResponseStats,
)
from app.services.common import UnitOfWork, errors


class HostelResponseStore(Protocol):
    """
    Storage for hostel responses to reviews.

    Expected record shape:

        {
            "id": UUID,
            "review_id": UUID,
            "hostel_id": UUID,
            "response_text": str,
            "responded_by": UUID,
            "responded_by_name": str,
            "responded_by_role": str,
            "responded_at": datetime,
            "created_at": datetime,
            "updated_at": datetime,
        }
    """

    def save_response(self, record: dict) -> dict: ...
    def get_response_by_review(self, review_id: UUID) -> Optional[dict]: ...
    def get_response(self, response_id: UUID) -> Optional[dict]: ...
    def update_response(self, response_id: UUID, data: dict) -> dict: ...
    def list_responses_for_hostel(self, hostel_id: UUID) -> List[dict]: ...


class HostelResponseService:
    """
    Hostel/owner responses to reviews:

    - Create/update responses
    - Guidelines
    - Response statistics
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: HostelResponseStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Guidelines
    # ------------------------------------------------------------------ #
    def get_guidelines(self) -> ResponseGuidelines:
        return ResponseGuidelines()

    # ------------------------------------------------------------------ #
    # Responses
    # ------------------------------------------------------------------ #
    def create_response(
        self,
        data: HostelResponseCreate,
        *,
        responded_by_role: str,
    ) -> OwnerResponse:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            user_repo = self._get_user_repo(uow)

            r = review_repo.get(data.review_id)
            if r is None:
                raise errors.NotFoundError(f"Review {data.review_id} not found")

            user = user_repo.get(data.responded_by)
            responded_by_name = user.full_name if user else ""

            now = self._now()
            record = {
                "id": uuid4(),
                "review_id": data.review_id,
                "hostel_id": r.hostel_id,
                "response_text": data.response_text,
                "responded_by": data.responded_by,
                "responded_by_name": responded_by_name,
                "responded_by_role": responded_by_role,
                "responded_at": now,
                "created_at": now,
                "updated_at": now,
            }
            saved = self._store.save_response(record)

        return OwnerResponse(
            id=saved["id"],
            created_at=saved["created_at"],
            updated_at=saved["updated_at"],
            review_id=saved["review_id"],
            response_text=saved["response_text"],
            responded_by=saved["responded_by"],
            responded_by_name=saved["responded_by_name"],
            responded_by_role=saved["responded_by_role"],
            responded_at=saved["responded_at"],
        )

    def update_response(self, data: ResponseUpdate) -> OwnerResponse:
        record = self._store.get_response(data.response_id)
        if not record:
            raise errors.NotFoundError(f"Response {data.response_id} not found")

        record["response_text"] = data.response_text
        record["updated_at"] = self._now()
        updated = self._store.update_response(data.response_id, record)

        return OwnerResponse(
            id=updated["id"],
            created_at=updated["created_at"],
            updated_at=updated["updated_at"],
            review_id=updated["review_id"],
            response_text=updated["response_text"],
            responded_by=updated["responded_by"],
            responded_by_name=updated["responded_by_name"],
            responded_by_role=updated["responded_by_role"],
            responded_at=updated["responded_at"],
        )

    def get_response_for_review(self, review_id: UUID) -> Optional[OwnerResponse]:
        record = self._store.get_response_by_review(review_id)
        if not record:
            return None
        return OwnerResponse(
            id=record["id"],
            created_at=record["created_at"],
            updated_at=record["updated_at"],
            review_id=record["review_id"],
            response_text=record["response_text"],
            responded_by=record["responded_by"],
            responded_by_name=record["responded_by_name"],
            responded_by_role=record["responded_by_role"],
            responded_at=record["responded_at"],
        )

    # ------------------------------------------------------------------ #
    # Stats
    # ------------------------------------------------------------------ #
    def get_stats(
        self,
        hostel_id: UUID,
        *,
        period_start: date,
        period_end: date,
    ) -> ResponseStats:
        """
        Compute ResponseStats using ReviewRepository + HostelResponseStore.
        """
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)

            reviews = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

        total_reviews = len(reviews)
        if total_reviews == 0:
            return ResponseStats(
                hostel_id=hostel_id,
                total_reviews=0,
                total_responses=0,
                response_rate=Decimal("0"),
                average_response_time_hours=Decimal("0"),
                response_rate_5_star=Decimal("0"),
                response_rate_4_star=Decimal("0"),
                response_rate_3_star=Decimal("0"),
                response_rate_2_star=Decimal("0"),
                response_rate_1_star=Decimal("0"),
            )

        responses = self._store.list_responses_for_hostel(hostel_id)
        total_responses = len(responses)

        def _pct(num: int, denom: int) -> Decimal:
            return (
                Decimal(str(num)) / Decimal(str(denom)) * Decimal("100")
                if denom > 0
                else Decimal("0")
            )

        # Average response time
        response_times: List[float] = []
        resp_by_review: Dict[UUID, dict] = {
            r["review_id"]: r for r in responses
        }

        by_rating_responses = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}
        by_rating_total = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}

        for rv in reviews:
            d = rv.created_at.date()
            if not (period_start <= d <= period_end):
                continue

            val = int(round(float(rv.overall_rating)))
            val = min(5, max(1, val))
            by_rating_total[val] += 1

            resp = resp_by_review.get(rv.id)
            if resp:
                delta = resp["responded_at"] - rv.created_at
                response_times.append(delta.total_seconds() / 3600.0)
                by_rating_responses[val] += 1

        avg_hours = (
            Decimal(str(sum(response_times) / len(response_times)))
            if response_times
            else Decimal("0")
        )

        return ResponseStats(
            hostel_id=hostel_id,
            total_reviews=total_reviews,
            total_responses=total_responses,
            response_rate=_pct(total_responses, total_reviews),
            average_response_time_hours=avg_hours,
            response_rate_5_star=_pct(by_rating_responses[5], by_rating_total[5]),
            response_rate_4_star=_pct(by_rating_responses[4], by_rating_total[4]),
            response_rate_3_star=_pct(by_rating_responses[3], by_rating_total[3]),
            response_rate_2_star=_pct(by_rating_responses[2], by_rating_total[2]),
            response_rate_1_star=_pct(by_rating_responses[1], by_rating_total[1]),
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\review\public_review_service.py ---
# app/services/review/public_review_service.py
from __future__ import annotations

from datetime import datetime
from typing import Callable, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import ReviewRepository
from app.repositories.core import HostelRepository, UserRepository, StudentRepository
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.review.review_submission import (
    ReviewSubmissionRequest,
    DetailedRatings,
    ReviewGuidelines,
    ReviewEligibility,
)
from app.schemas.review import ReviewDetail, ReviewListItem
from app.schemas.review.review_filters import ReviewFilterParams, SortOptions
from app.services.common import UnitOfWork, errors
from .review_service import ReviewService


class PublicReviewService:
    """
    Public-facing wrapper for internal reviews:

    - Submit review (ReviewSubmissionRequest) as an internal Review
    - Check simple review eligibility
    - Provide guidelines
    - List public reviews for hostel (approved + sorted)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory
        self._review_service = ReviewService(session_factory)

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Eligibility & guidelines
    # ------------------------------------------------------------------ #
    def get_guidelines(self) -> ReviewGuidelines:
        return ReviewGuidelines()

    def check_eligibility(self, user_id: UUID, hostel_id: UUID) -> ReviewEligibility:
        """
        Very simple eligibility:

        - can_review if the user has not already reviewed this hostel.
        - has_booking/has_stayed are not checked (no booking linkage here).
        """
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)

            existing = review_repo.get_multi(
                skip=0,
                limit=1,
                filters={"hostel_id": hostel_id, "reviewer_id": user_id},
            )

        already = bool(existing)
        can_review = not already
        reason = "Eligible to review" if can_review else "You have already reviewed this hostel"

        return ReviewEligibility(
            user_id=user_id,
            hostel_id=hostel_id,
            can_review=can_review,
            reason=reason,
            has_stayed=False,
            has_booking=False,
            already_reviewed=already,
            existing_review_id=existing[0].id if already else None,
            can_edit=already,
        )

    # ------------------------------------------------------------------ #
    # Submission
    # ------------------------------------------------------------------ #
    def submit_review(
        self,
        reviewer_id: UUID,
        data: ReviewSubmissionRequest,
    ) -> ReviewDetail:
        """
        Map ReviewSubmissionRequest to internal ReviewCreate and delegate to ReviewService.
        """
        # The ReviewCreate schema is similar to ReviewSubmissionRequest; we map manually.
        from app.schemas.review import ReviewCreate

        # Approximate mapping from DetailedRatings
        dr: DetailedRatings = data.detailed_ratings

        create = ReviewCreate(
            hostel_id=data.hostel_id,
            reviewer_id=reviewer_id,
            student_id=data.student_id,
            booking_id=data.booking_id,
            overall_rating=data.overall_rating,
            title=data.title,
            review_text=data.review_text,
            cleanliness_rating=dr.cleanliness,
            food_quality_rating=dr.food_quality,
            staff_behavior_rating=dr.staff_behavior,
            security_rating=dr.security,
            value_for_money_rating=dr.value_for_money,
            amenities_rating=dr.amenities,
            photos=data.photos,
        )
        return self._review_service.create_review(create)

    # ------------------------------------------------------------------ #
    # Public listing
    # ------------------------------------------------------------------ #
    def list_public_reviews(
        self,
        hostel_id: UUID,
        params: PaginationParams,
        *,
        min_rating: Optional[float] = None,
    ) -> PaginatedResponse[ReviewListItem]:
        """
        Convenience wrapper: show only approved reviews for hostel,
        optionally filtered by minimum rating.
        """
        filters = ReviewFilterParams(
            hostel_id=hostel_id,
            min_rating=min_rating,
            approved_only=True,
        )
        sort = SortOptions(sort_by="helpful", verified_first=True, with_photos_first=True)
        return self._review_service.list_reviews(params, filters=filters, sort=sort)

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\review\review_analytics_service.py ---
# app/services/review/review_analytics_service.py
from __future__ import annotations

from collections import defaultdict
from datetime import datetime, date, timedelta
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import ReviewRepository
from app.repositories.core import HostelRepository
from app.schemas.common.filters import DateRangeFilter
from app.schemas.review.review_analytics import (
    ReviewAnalytics,
    RatingDistribution,
    TrendAnalysis,
    MonthlyRating,
    SentimentAnalysis,
)
from app.services.common import UnitOfWork, errors


class ReviewAnalyticsService:
    """
    Review analytics per hostel:

    - Rating distribution
    - Detailed aspect averages
    - TrendAnalysis over time
    - Simple engagement metrics (helpful votes, verification rate)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_hostel_review_analytics(
        self,
        hostel_id: UUID,
        period: Optional[DateRangeFilter] = None,
    ) -> ReviewAnalytics:
        """
        Build ReviewAnalytics for a hostel over optional period.
        If period is None or missing dates, considers all time.
        """
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            recs = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

        if not period or (not period.start_date and not period.end_date):
            start = date.min
            end = date.max
        else:
            start = period.start_date or date.min
            end = period.end_date or date.max

        # Filter by created_at date
        reviews = [
            r for r in recs
            if start <= r.created_at.date() <= end
        ]

        total = len(reviews)
        if total == 0:
            return ReviewAnalytics(
                hostel_id=hostel_id,
                hostel_name=hostel.name,
                analysis_period=period,
                generated_at=self._now(),
                total_reviews=0,
                average_rating=Decimal("0"),
                rating_distribution=RatingDistribution(
                    rating_5_count=0,
                    rating_4_count=0,
                    rating_3_count=0,
                    rating_2_count=0,
                    rating_1_count=0,
                    rating_5_percentage=Decimal("0"),
                    rating_4_percentage=Decimal("0"),
                    rating_3_percentage=Decimal("0"),
                    rating_2_percentage=Decimal("0"),
                    rating_1_percentage=Decimal("0"),
                    positive_reviews=0,
                    neutral_reviews=0,
                    negative_reviews=0,
                    positive_percentage=Decimal("0"),
                    neutral_percentage=Decimal("0"),
                    negative_percentage=Decimal("0"),
                ),
                detailed_ratings_average={},
                rating_trend=TrendAnalysis(
                    trend_direction="stable",
                    trend_percentage=None,
                    monthly_ratings=[],
                    last_30_days_rating=Decimal("0"),
                    last_90_days_rating=Decimal("0"),
                    all_time_rating=Decimal("0"),
                ),
                sentiment_analysis=None,
                verified_reviews_count=0,
                verification_rate=Decimal("0"),
                average_helpful_votes=Decimal("0"),
                response_rate=Decimal("0"),
            )

        # Overall average
        total_rating = sum((r.overall_rating for r in reviews), Decimal("0"))
        avg_rating = total_rating / Decimal(str(total))

        # Rating distribution
        rating_counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}
        for r in reviews:
            val = int(round(float(r.overall_rating)))
            val = min(5, max(1, val))
            rating_counts[val] += 1

        def _pct(num: int, denom: int) -> Decimal:
            return (
                Decimal(str(num)) / Decimal(str(denom)) * Decimal("100")
                if denom > 0
                else Decimal("0")
            )

        dist = RatingDistribution(
            rating_5_count=rating_counts[5],
            rating_4_count=rating_counts[4],
            rating_3_count=rating_counts[3],
            rating_2_count=rating_counts[2],
            rating_1_count=rating_counts[1],
            rating_5_percentage=_pct(rating_counts[5], total),
            rating_4_percentage=_pct(rating_counts[4], total),
            rating_3_percentage=_pct(rating_counts[3], total),
            rating_2_percentage=_pct(rating_counts[2], total),
            rating_1_percentage=_pct(rating_counts[1], total),
            positive_reviews=rating_counts[5] + rating_counts[4],
            neutral_reviews=rating_counts[3],
            negative_reviews=rating_counts[1] + rating_counts[2],
            positive_percentage=_pct(rating_counts[5] + rating_counts[4], total),
            neutral_percentage=_pct(rating_counts[3], total),
            negative_percentage=_pct(rating_counts[1] + rating_counts[2], total),
        )

        # Detailed aspect averages
        aspects = [
            "cleanliness_rating",
            "food_quality_rating",
            "staff_behavior_rating",
            "security_rating",
            "value_for_money_rating",
            "amenities_rating",
        ]
        detailed: Dict[str, Decimal] = {}
        for field in aspects:
            vals = [
                Decimal(str(getattr(r, field)))
                for r in reviews
                if getattr(r, field) is not None
            ]
            if vals:
                detailed[field] = sum(vals) / Decimal(str(len(vals)))

        # Trend: monthly
        monthly_map: Dict[str, Dict[str, object]] = {}
        for r in reviews:
            key = r.created_at.strftime("%Y-%m")
            bucket = monthly_map.setdefault(
                key, {"sum": Decimal("0"), "count": 0}
            )
            bucket["sum"] = bucket["sum"] + r.overall_rating  # type: ignore[operator]
            bucket["count"] = bucket["count"] + 1  # type: ignore[operator]

        monthly_ratings: List[MonthlyRating] = []
        for month, vals in sorted(monthly_map.items()):
            avg_m = (
                vals["sum"] / Decimal(str(vals["count"]))  # type: ignore[index]
                if vals["count"]  # type: ignore[index]
                else Decimal("0")
            )
            monthly_ratings.append(
                MonthlyRating(
                    month=month,
                    average_rating=avg_m,
                    review_count=vals["count"],  # type: ignore[index]
                )
            )

        # Trend direction based on first vs last month
        trend_direction = "stable"
        trend_pct: Optional[Decimal] = None
        if len(monthly_ratings) >= 2:
            first = monthly_ratings[0].average_rating
            last = monthly_ratings[-1].average_rating
            if first > 0:
                change = (last - first) / first * Decimal("100")
                trend_pct = change
                if change > Decimal("5"):
                    trend_direction = "improving"
                elif change < Decimal("-5"):
                    trend_direction = "declining"
                else:
                    trend_direction = "stable"

        # Last 30/90 days vs all-time
        today = date.today()
        last_30 = [
            r for r in reviews if r.created_at.date() >= today - timedelta(days=30)
        ]
        last_90 = [
            r for r in reviews if r.created_at.date() >= today - timedelta(days=90)
        ]
        def _avg(lst) -> Decimal:
            if not lst:
                return Decimal("0")
            s = sum((x.overall_rating for x in lst), Decimal("0"))
            return s / Decimal(str(len(lst)))

        trend = TrendAnalysis(
            trend_direction=trend_direction,
            trend_percentage=trend_pct,
            monthly_ratings=monthly_ratings,
            last_30_days_rating=_avg(last_30),
            last_90_days_rating=_avg(last_90),
            all_time_rating=avg_rating,
        )

        # Sentiment placeholder
        sentiment: Optional[SentimentAnalysis] = None

        # Verification & engagement
        verified_count = sum(1 for r in reviews if r.is_verified_stay)
        verification_rate = _pct(verified_count, total)

        avg_helpful = (
            Decimal(
                str(sum(int(r.helpful_count) for r in reviews))
            )
            / Decimal(str(total))
        )

        # Response rate not tracked here -> 0
        response_rate = Decimal("0")

        return ReviewAnalytics(
            hostel_id=hostel_id,
            hostel_name=hostel.name,
            analysis_period=period,
            generated_at=self._now(),
            total_reviews=total,
            average_rating=avg_rating,
            rating_distribution=dist,
            detailed_ratings_average=detailed,
            rating_trend=trend,
            sentiment_analysis=sentiment,
            verified_reviews_count=verified_count,
            verification_rate=verification_rate,
            average_helpful_votes=avg_helpful,
            response_rate=response_rate,
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\review\review_moderation_service.py ---
# app/services/review/review_moderation_service.py
from __future__ import annotations

from datetime import datetime, date
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import ReviewRepository
from app.repositories.core import HostelRepository, UserRepository
from app.schemas.review.review_moderation import (
    ModerationRequest,
    ModerationResponse,
    ModerationQueue,
    PendingReview,
    BulkModeration,
    ModerationStats,
)
from app.services.common import UnitOfWork, errors


class ModerationStore(Protocol):
    """
    Storage for review moderation metadata not present in the Review model.

    Expected record keys (example):
        {
            "review_id": UUID,
            "moderation_status": "pending|approved|rejected|flagged",
            "rejection_reason": str | None,
            "flag_reason": str | None,
            "flag_details": str | None,
            "moderator_notes": str | None,
            "flag_count": int,
            "spam_score": Decimal | None,
            "sentiment_score": Decimal | None,
            "submitted_at": datetime,
            "moderated_at": datetime | None,
            "moderated_by": UUID | None,
            "moderated_by_name": str | None,
        }
    """

    def get_metadata(self, review_id: UUID) -> Optional[dict]: ...
    def save_metadata(self, review_id: UUID, data: dict) -> None: ...


class ReviewModerationService:
    """
    Review moderation:

    - Approve/reject/flag/unflag reviews
    - Build moderation queue
    - Moderation statistics
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: ModerationStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    def _ensure_meta(self, review_id: UUID) -> dict:
        meta = self._store.get_metadata(review_id)
        if meta:
            return meta
        now = self._now()
        meta = {
            "review_id": review_id,
            "moderation_status": "pending",
            "rejection_reason": None,
            "flag_reason": None,
            "flag_details": None,
            "moderator_notes": None,
            "flag_count": 0,
            "spam_score": None,
            "sentiment_score": None,
            "submitted_at": now,
            "moderated_at": None,
            "moderated_by": None,
            "moderated_by_name": None,
        }
        self._store.save_metadata(review_id, meta)
        return meta

    # ------------------------------------------------------------------ #
    # Moderate
    # ------------------------------------------------------------------ #
    def moderate(
        self,
        data: ModerationRequest,
        *,
        moderator_id: UUID,
    ) -> ModerationResponse:
        """
        Apply a moderation action to a review.
        """
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            user_repo = self._get_user_repo(uow)

            r = review_repo.get(data.review_id)
            if r is None:
                raise errors.NotFoundError(f"Review {data.review_id} not found")

            moderator = user_repo.get(moderator_id)
            moderator_name = moderator.full_name if moderator else ""

            meta = self._ensure_meta(r.id)
            now = self._now()

            action = data.action
            if action == "approve":
                r.is_approved = True  # type: ignore[attr-defined]
                r.is_flagged = False  # type: ignore[attr-defined]
                meta["moderation_status"] = "approved"
                meta["rejection_reason"] = None
            elif action == "reject":
                r.is_approved = False  # type: ignore[attr-defined]
                meta["moderation_status"] = "rejected"
                meta["rejection_reason"] = data.rejection_reason
            elif action == "flag":
                r.is_flagged = True  # type: ignore[attr-defined]
                meta["moderation_status"] = "flagged"
                meta["flag_reason"] = data.flag_reason
                meta["flag_details"] = data.flag_details
                meta["flag_count"] = int(meta.get("flag_count", 0)) + 1
            elif action == "unflag":
                r.is_flagged = False  # type: ignore[attr-defined]
                meta["moderation_status"] = "approved" if r.is_approved else "pending"
                meta["flag_reason"] = None
                meta["flag_details"] = None
            else:
                raise errors.ValidationError("Unknown moderation action")

            meta["moderated_at"] = now
            meta["moderated_by"] = moderator_id
            meta["moderated_by_name"] = moderator_name
            meta["moderator_notes"] = data.moderator_notes

            self._store.save_metadata(r.id, meta)
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return ModerationResponse(
            review_id=r.id,
            action_taken=action,
            moderated_by=moderator_id,
            moderated_by_name=moderator_name,
            moderated_at=now,
            reviewer_notified=False,
            message=f"Review {action}d successfully",
        )

    def bulk_moderate(
        self,
        data: BulkModeration,
        *,
        moderator_id: UUID,
    ) -> List[ModerationResponse]:
        responses: List[ModerationResponse] = []
        for rid in data.review_ids:
            req = ModerationRequest(
                review_id=rid,
                action=data.action,
                rejection_reason=data.reason,
                flag_reason=None,
                flag_details=None,
                moderator_notes=data.reason,
            )
            responses.append(self.moderate(req, moderator_id=moderator_id))
        return responses

    # ------------------------------------------------------------------ #
    # Queue
    # ------------------------------------------------------------------ #
    def get_moderation_queue(
        self,
        *,
        hostel_id: Optional[UUID] = None,
        limit: int = 50,
    ) -> ModerationQueue:
        """
        Build a simple moderation queue:

        - Pending or flagged reviews.
        """
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            filters: Dict[str, object] = {}
            if hostel_id:
                filters["hostel_id"] = hostel_id

            recs = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

            pending: List[PendingReview] = []
            total_pending = flagged = auto_approved = 0

            for r in recs:
                meta = self._ensure_meta(r.id)
                status = meta.get("moderation_status", "pending")
                if status == "pending" or status == "flagged":
                    total_pending += 1
                if status == "flagged":
                    flagged += 1
                if status == "approved" and meta.get("moderated_by") is None:
                    auto_approved += 1

                if len(pending) >= limit:
                    continue

                hostel = hostel_repo.get(r.hostel_id)
                hostel_name = hostel.name if hostel else ""

                reviewer = user_repo.get(r.reviewer_id)
                reviewer_name = reviewer.full_name if reviewer else ""

                excerpt = (r.review_text or "")[:200]
                pending.append(
                    PendingReview(
                        review_id=r.id,
                        hostel_id=r.hostel_id,
                        hostel_name=hostel_name,
                        reviewer_name=reviewer_name,
                        overall_rating=r.overall_rating,
                        title=r.title,
                        review_excerpt=excerpt,
                        is_verified_stay=r.is_verified_stay,
                        is_flagged=r.is_flagged,
                        flag_count=int(meta.get("flag_count", 0)),
                        submitted_at=r.created_at,
                        spam_score=meta.get("spam_score"),
                        sentiment_score=meta.get("sentiment_score"),
                    )
                )

        return ModerationQueue(
            hostel_id=hostel_id,
            total_pending=total_pending,
            flagged_reviews=flagged,
            auto_approved=auto_approved,
            pending_reviews=pending,
        )

    # ------------------------------------------------------------------ #
    # Stats
    # ------------------------------------------------------------------ #
    def get_moderation_stats(
        self,
        *,
        hostel_id: Optional[UUID],
        period_start: date,
        period_end: date,
    ) -> ModerationStats:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)

            filters: Dict[str, object] = {}
            if hostel_id:
                filters["hostel_id"] = hostel_id

            recs = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

        total = auto_approved = manually_approved = rejected = flagged = 0
        moderation_times: List[float] = []
        moderations_by_user: Dict[str, int] = {}

        for r in recs:
            if not (period_start <= r.created_at.date() <= period_end):
                continue
            total += 1
            meta = self._ensure_meta(r.id)
            status = meta.get("moderation_status", "pending")
            mod_at = meta.get("moderated_at")
            mod_by = meta.get("moderated_by")
            sub_at = meta.get("submitted_at", r.created_at)

            if status == "approved":
                if mod_by is None:
                    auto_approved += 1
                else:
                    manually_approved += 1
            elif status == "rejected":
                rejected += 1
            elif status == "flagged":
                flagged += 1

            if mod_at:
                hours = (mod_at - sub_at).total_seconds() / 3600.0
                moderation_times.append(hours)
            if mod_by:
                key = str(mod_by)
                moderations_by_user[key] = moderations_by_user.get(key, 0) + 1

        avg_time = (
            Decimal(str(sum(moderation_times) / len(moderation_times)))
            if moderation_times
            else Decimal("0")
        )

        return ModerationStats(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
            total_reviews=total,
            auto_approved=auto_approved,
            manually_approved=manually_approved,
            rejected=rejected,
            flagged=flagged,
            average_moderation_time_hours=avg_time,
            moderations_by_user=moderations_by_user,
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\review\review_service.py ---
# app/services/review/review_service.py
from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import ReviewRepository
from app.repositories.core import HostelRepository, UserRepository, StudentRepository
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.review import (
    ReviewCreate,
    ReviewUpdate,
    ReviewResponse,
    ReviewDetail,
    ReviewListItem,
    ReviewFilterParams,
    SearchRequest,
    SortOptions,
)
from app.schemas.review.review_response import ReviewSummary
from app.services.common import UnitOfWork, errors


class ReviewService:
    """
    Core internal review service (content_review):

    - Create/update reviews
    - Get review detail
    - List & search reviews with filters + sorting
    - Summary per hostel
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_response(
        self,
        r,
        *,
        hostel_name: str,
        reviewer_name: str,
    ) -> ReviewResponse:
        return ReviewResponse(
            id=r.id,
            created_at=r.created_at,
            updated_at=r.updated_at,
            hostel_id=r.hostel_id,
            hostel_name=hostel_name,
            reviewer_id=r.reviewer_id,
            reviewer_name=reviewer_name,
            overall_rating=r.overall_rating,
            title=r.title,
            review_text=r.review_text,
            is_verified_stay=r.is_verified_stay,
            verified_at=r.verified_at,
            is_approved=r.is_approved,
            helpful_count=r.helpful_count,
            not_helpful_count=r.not_helpful_count,
        )

    def _to_detail(
        self,
        r,
        *,
        hostel_name: str,
        reviewer_name: str,
        reviewer_profile_image: Optional[str],
        student_name: Optional[str],
    ) -> ReviewDetail:
        # Model does not hold moderation metadata / hostel response;
        # we return safe defaults here.
        is_published = bool(r.is_approved and not r.is_flagged)

        return ReviewDetail(
            id=r.id,
            created_at=r.created_at,
            updated_at=r.updated_at,
            hostel_id=r.hostel_id,
            hostel_name=hostel_name,
            reviewer_id=r.reviewer_id,
            reviewer_name=reviewer_name,
            reviewer_profile_image=reviewer_profile_image,
            student_id=r.student_id,
            booking_id=r.booking_id,
            overall_rating=r.overall_rating,
            cleanliness_rating=r.cleanliness_rating,
            food_quality_rating=r.food_quality_rating,
            staff_behavior_rating=r.staff_behavior_rating,
            security_rating=r.security_rating,
            value_for_money_rating=r.value_for_money_rating,
            amenities_rating=r.amenities_rating,
            title=r.title,
            review_text=r.review_text,
            photos=r.photos or [],
            is_verified_stay=r.is_verified_stay,
            verified_at=r.verified_at,
            is_approved=r.is_approved,
            approved_by=None,
            approved_at=None,
            is_flagged=r.is_flagged,
            flag_reason=None,
            flagged_by=None,
            flagged_at=None,
            helpful_count=r.helpful_count,
            not_helpful_count=r.not_helpful_count,
            report_count=0,
            hostel_response=None,
            is_published=is_published,
        )

    def _to_list_item(
        self,
        r,
        *,
        reviewer_name: str,
    ) -> ReviewListItem:
        excerpt = (r.review_text or "")[:150]
        return ReviewListItem(
            id=r.id,
            reviewer_name=reviewer_name,
            overall_rating=r.overall_rating,
            title=r.title,
            review_excerpt=excerpt,
            is_verified_stay=r.is_verified_stay,
            helpful_count=r.helpful_count,
            created_at=r.created_at,
            has_hostel_response=False,
        )

    # ------------------------------------------------------------------ #
    # Core read
    # ------------------------------------------------------------------ #
    def get_review(self, review_id: UUID) -> ReviewDetail:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            r = review_repo.get(review_id)
            if r is None:
                raise errors.NotFoundError(f"Review {review_id} not found")

            hostel = hostel_repo.get(r.hostel_id)
            hostel_name = hostel.name if hostel else ""

            reviewer = user_repo.get(r.reviewer_id)
            reviewer_name = reviewer.full_name if reviewer else ""
            reviewer_img = getattr(reviewer, "profile_image_url", None) if reviewer else None

            student_name = None
            if r.student_id:
                st = self._get_student_repo(uow).get(r.student_id)
                if st and getattr(st, "user", None):
                    student_name = st.user.full_name

            return self._to_detail(
                r,
                hostel_name=hostel_name,
                reviewer_name=reviewer_name,
                reviewer_profile_image=reviewer_img,
                student_name=student_name,
            )

    # ------------------------------------------------------------------ #
    # Create / update
    # ------------------------------------------------------------------ #
    def create_review(self, data: ReviewCreate) -> ReviewDetail:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            reviewer = user_repo.get(data.reviewer_id)
            if reviewer is None:
                raise errors.NotFoundError(f"User {data.reviewer_id} not found")

            payload = data.model_dump(exclude_unset=True)
            r = review_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            student_name = None
            if r.student_id:
                st = self._get_student_repo(uow).get(r.student_id)
                if st and getattr(st, "user", None):
                    student_name = st.user.full_name

            return self._to_detail(
                r,
                hostel_name=hostel.name,
                reviewer_name=reviewer.full_name,
                reviewer_profile_image=getattr(reviewer, "profile_image_url", None),
                student_name=student_name,
            )

    def update_review(self, review_id: UUID, data: ReviewUpdate) -> ReviewDetail:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)

            r = review_repo.get(review_id)
            if r is None:
                raise errors.NotFoundError(f"Review {review_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(r, field) and field != "id":
                    setattr(r, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return self.get_review(review_id)

    # ------------------------------------------------------------------ #
    # Listing with filters/sorting
    # ------------------------------------------------------------------ #
    def list_reviews(
        self,
        params: PaginationParams,
        filters: Optional[ReviewFilterParams] = None,
        sort: Optional[SortOptions] = None,
    ) -> PaginatedResponse[ReviewListItem]:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            user_repo = self._get_user_repo(uow)

            raw_filters: Dict[str, object] = {}
            if filters:
                if filters.hostel_id:
                    raw_filters["hostel_id"] = filters.hostel_id
                elif filters.hostel_ids:
                    raw_filters["hostel_id"] = filters.hostel_ids
                if filters.approved_only:
                    raw_filters["is_approved"] = True

            records: Sequence = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=raw_filters or None,
            )

            def _matches(r) -> bool:
                if not filters:
                    return True

                if filters.min_rating is not None and r.overall_rating < filters.min_rating:
                    return False
                if filters.max_rating is not None and r.overall_rating > filters.max_rating:
                    return False
                if filters.rating is not None and int(round(float(r.overall_rating))) != filters.rating:
                    return False

                if filters.verified_only and not r.is_verified_stay:
                    return False

                if filters.posted_date_from or filters.posted_date_to:
                    d = r.created_at.date()
                    if filters.posted_date_from and d < filters.posted_date_from:
                        return False
                    if filters.posted_date_to and d > filters.posted_date_to:
                        return False

                if filters.flagged_only is True and not r.is_flagged:
                    return False

                if filters.min_helpful_count is not None and r.helpful_count < filters.min_helpful_count:
                    return False

                if filters.with_photos_only and not r.photos:
                    return False

                return True

            filtered = [r for r in records if _matches(r)]

            # Sorting
            sort = sort or SortOptions()
            def _sort_key(r):
                base = []
                if sort.sort_by == "helpful":
                    base.append(-r.helpful_count)
                elif sort.sort_by == "recent":
                    base.append(-(r.created_at.timestamp()))
                elif sort.sort_by == "rating_high":
                    base.append(-float(r.overall_rating))
                elif sort.sort_by == "rating_low":
                    base.append(float(r.overall_rating))
                elif sort.sort_by == "verified":
                    base.append(0 if r.is_verified_stay else 1)

                # Secondary modifiers
                if sort.verified_first:
                    base.append(0 if r.is_verified_stay else 1)
                if sort.with_photos_first:
                    base.append(0 if r.photos else 1)

                # Always add created_at desc as tie breaker
                base.append(-r.created_at.timestamp())
                return tuple(base)

            sorted_records = sorted(filtered, key=_sort_key)

            # Pagination
            start = params.offset
            end = start + params.limit
            page_records = sorted_records[start:end]

            # Map to list items
            user_cache: Dict[UUID, str] = {}
            items: List[ReviewListItem] = []
            for r in page_records:
                if r.reviewer_id not in user_cache:
                    u = user_repo.get(r.reviewer_id)
                    user_cache[r.reviewer_id] = u.full_name if u else ""
                reviewer_name = user_cache[r.reviewer_id]
                items.append(self._to_list_item(r, reviewer_name=reviewer_name))

            return PaginatedResponse[ReviewListItem].create(
                items=items,
                total_items=len(sorted_records),
                page=params.page,
                page_size=params.page_size,
            )

    def search_reviews(
        self,
        params: PaginationParams,
        req: SearchRequest,
    ) -> PaginatedResponse[ReviewListItem]:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            user_repo = self._get_user_repo(uow)

            filters: Dict[str, object] = {}
            if req.hostel_id:
                filters["hostel_id"] = req.hostel_id

            records: Sequence = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

            q = req.query.lower()
            user_cache: Dict[UUID, str] = {}

            def _matches(r) -> bool:
                if req.min_rating is not None and r.overall_rating < req.min_rating:
                    return False

                if r.reviewer_id not in user_cache:
                    u = user_repo.get(r.reviewer_id)
                    user_cache[r.reviewer_id] = u.full_name if u else ""
                reviewer_name = user_cache[r.reviewer_id]

                text_parts: List[str] = []
                if req.search_in_title:
                    text_parts.append(r.title or "")
                if req.search_in_content:
                    text_parts.append(r.review_text or "")
                text_parts.append(reviewer_name)

                haystack = " ".join(text_parts).lower()
                return q in haystack

            matched = [r for r in records if _matches(r)]

            matched_sorted = sorted(matched, key=lambda r: r.created_at, reverse=True)
            start = params.offset
            end = start + params.limit
            page_records = matched_sorted[start:end]

            items: List[ReviewListItem] = []
            for r in page_records:
                reviewer_name = user_cache[r.reviewer_id]
                items.append(self._to_list_item(r, reviewer_name=reviewer_name))

            return PaginatedResponse[ReviewListItem].create(
                items=items,
                total_items=len(matched_sorted),
                page=params.page,
                page_size=params.page_size,
            )

    # ------------------------------------------------------------------ #
    # Summary
    # ------------------------------------------------------------------ #
    def get_summary_for_hostel(self, hostel_id: UUID) -> ReviewSummary:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            reviews = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

            total_reviews = len(reviews)
            if total_reviews == 0:
                return ReviewSummary(
                    hostel_id=hostel_id,
                    hostel_name=hostel.name,
                    total_reviews=0,
                    average_rating=Decimal("0"),
                    rating_5_count=0,
                    rating_4_count=0,
                    rating_3_count=0,
                    rating_2_count=0,
                    rating_1_count=0,
                    verified_reviews_count=0,
                    verified_reviews_percentage=Decimal("0"),
                    recent_reviews=[],
                    would_recommend_percentage=Decimal("0"),
                )

            rating_counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}
            total_rating = Decimal("0")
            verified_count = 0

            for r in reviews:
                val = int(round(float(r.overall_rating)))
                val = min(5, max(1, val))
                rating_counts[val] += 1
                total_rating += r.overall_rating
                if r.is_verified_stay:
                    verified_count += 1

            avg_rating = total_rating / Decimal(str(total_reviews))

            verified_pct = (
                Decimal(str(verified_count)) / Decimal(str(total_reviews)) * Decimal("100")
            )

            # Recent reviews (up to 5)
            user_cache: Dict[UUID, str] = {}
            sorted_reviews = sorted(reviews, key=lambda r: r.created_at, reverse=True)
            recent_items: List[ReviewListItem] = []
            for r in sorted_reviews[:5]:
                if r.reviewer_id not in user_cache:
                    u = user_repo.get(r.reviewer_id)
                    user_cache[r.reviewer_id] = u.full_name if u else ""
                reviewer_name = user_cache[r.reviewer_id]
                recent_items.append(self._to_list_item(r, reviewer_name=reviewer_name))

            # would_recommend_percentage not tracked -> 0
            return ReviewSummary(
                hostel_id=hostel_id,
                hostel_name=hostel.name,
                total_reviews=total_reviews,
                average_rating=avg_rating,
                rating_5_count=rating_counts[5],
                rating_4_count=rating_counts[4],
                rating_3_count=rating_counts[3],
                rating_2_count=rating_counts[2],
                rating_1_count=rating_counts[1],
                verified_reviews_count=verified_count,
                verified_reviews_percentage=verified_pct,
                recent_reviews=recent_items,
                would_recommend_percentage=Decimal("0"),
            )

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\review\review_voting_service.py ---
# app/services/review/review_voting_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from math import sqrt
from typing import Callable, Dict, List, Optional, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import ReviewRepository
from app.repositories.core import HostelRepository
from app.schemas.common.enums import VoteType
from app.schemas.review.review_voting import (
    VoteRequest,
    VoteResponse,
    HelpfulnessScore,
    VoteHistory,
    VoteHistoryItem,
    RemoveVote,
)
from app.services.common import UnitOfWork, errors


class VoteStore(Protocol):
    """
    Storage for per-user votes on reviews.

    Expected record shape:

        {
            "review_id": UUID,
            "voter_id": UUID,
            "vote_type": "helpful" | "not_helpful",
            "voted_at": datetime,
        }
    """

    def get_vote(self, review_id: UUID, voter_id: UUID) -> Optional[dict]: ...
    def save_vote(self, record: dict) -> None: ...
    def delete_vote(self, review_id: UUID, voter_id: UUID) -> None: ...
    def list_votes_for_review(self, review_id: UUID) -> List[dict]: ...
    def list_votes_for_user(self, user_id: UUID) -> List[dict]: ...


class ReviewVotingService:
    """
    Review helpfulness voting:

    - Cast/modify votes (helpful / not_helpful)
    - Remove vote
    - Compute HelpfulnessScore with Wilson score
    - User voting history
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: VoteStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Voting
    # ------------------------------------------------------------------ #
    def vote(self, data: VoteRequest) -> VoteResponse:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)

            r = review_repo.get(data.review_id)
            if r is None:
                raise errors.NotFoundError(f"Review {data.review_id} not found")

            existing = self._store.get_vote(data.review_id, data.voter_id)
            vote_type_str = data.vote_type.value if hasattr(data.vote_type, "value") else str(data.vote_type)

            # Adjust counts
            if existing:
                old_type = existing["vote_type"]
                if old_type == vote_type_str:
                    # No-op
                    return VoteResponse(
                        review_id=data.review_id,
                        vote_type=data.vote_type,
                        helpful_count=r.helpful_count,
                        not_helpful_count=r.not_helpful_count,
                        message="Vote unchanged",
                    )
                # Switch vote
                if old_type == "helpful":
                    r.helpful_count = max(0, r.helpful_count - 1)  # type: ignore[attr-defined]
                else:
                    r.not_helpful_count = max(0, r.not_helpful_count - 1)  # type: ignore[attr-defined]
            # Apply new vote
            if vote_type_str == "helpful":
                r.helpful_count = r.helpful_count + 1  # type: ignore[attr-defined]
            else:
                r.not_helpful_count = r.not_helpful_count + 1  # type: ignore[attr-defined]

            record = {
                "review_id": data.review_id,
                "voter_id": data.voter_id,
                "vote_type": vote_type_str,
                "voted_at": self._now(),
            }
            self._store.save_vote(record)
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return VoteResponse(
            review_id=data.review_id,
            vote_type=data.vote_type,
            helpful_count=r.helpful_count,
            not_helpful_count=r.not_helpful_count,
            message="Vote recorded",
        )

    def remove_vote(self, data: RemoveVote) -> VoteResponse:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)

            r = review_repo.get(data.review_id)
            if r is None:
                raise errors.NotFoundError(f"Review {data.review_id} not found")

            existing = self._store.get_vote(data.review_id, data.voter_id)
            if not existing:
                raise errors.NotFoundError("Vote not found")

            if existing["vote_type"] == "helpful":
                r.helpful_count = max(0, r.helpful_count - 1)  # type: ignore[attr-defined]
            else:
                r.not_helpful_count = max(0, r.not_helpful_count - 1)  # type: ignore[attr-defined]

            self._store.delete_vote(data.review_id, data.voter_id)
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        # Return current counts (vote_type not really relevant here)
        return VoteResponse(
            review_id=data.review_id,
            vote_type=VoteType.HELPFUL,  # placeholder
            helpful_count=r.helpful_count,
            not_helpful_count=r.not_helpful_count,
            message="Vote removed",
        )

    # ------------------------------------------------------------------ #
    # Scores
    # ------------------------------------------------------------------ #
    def get_helpfulness_score(self, review_id: UUID) -> HelpfulnessScore:
        votes = self._store.list_votes_for_review(review_id)
        helpful = sum(1 for v in votes if v.get("vote_type") == "helpful")
        not_helpful = sum(1 for v in votes if v.get("vote_type") == "not_helpful")
        total = helpful + not_helpful

        if total == 0:
            return HelpfulnessScore(
                review_id=review_id,
                helpful_count=0,
                not_helpful_count=0,
                total_votes=0,
                helpfulness_percentage=Decimal("0"),
                helpfulness_score=Decimal("0"),
            )

        pct = Decimal(str(helpful)) / Decimal(str(total)) * Decimal("100")

        # Wilson score for lower bound of helpfulness
        phat = helpful / total
        z = 1.96
        wilson = (
            phat
            + z * z / (2 * total)
            - z * sqrt(
                phat * (1 - phat) / total + z * z / (4 * total * total)
            )
        ) / (1 + z * z / total)
        score = Decimal(str(wilson))

        return HelpfulnessScore(
            review_id=review_id,
            helpful_count=helpful,
            not_helpful_count=not_helpful,
            total_votes=total,
            helpfulness_percentage=pct,
            helpfulness_score=score,
        )

    # ------------------------------------------------------------------ #
    # History
    # ------------------------------------------------------------------ #
    def get_vote_history(self, user_id: UUID, *, limit: int = 10) -> VoteHistory:
        with UnitOfWork(self._session_factory) as uow:
            votes = self._store.list_votes_for_user(user_id)
            review_repo = self._get_review_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            votes_sorted = sorted(votes, key=lambda v: v.get("voted_at"), reverse=True)
            votes_subset = votes_sorted[:limit]

            items: List[VoteHistoryItem] = []
            helpful_votes = not_helpful_votes = 0

            cache_hostel: Dict[UUID, str] = {}

            for v in votes_subset:
                rid = v["review_id"]
                r = review_repo.get(rid)
                if not r:
                    continue
                hid = r.hostel_id
                if hid not in cache_hostel:
                    h = hostel_repo.get(hid)
                    cache_hostel[hid] = h.name if h else ""
                hostel_name = cache_hostel[hid]

                vt = v["vote_type"]
                if vt == "helpful":
                    helpful_votes += 1
                else:
                    not_helpful_votes += 1

                items.append(
                    VoteHistoryItem(
                        review_id=rid,
                        hostel_name=hostel_name,
                        vote_type=VoteType.HELPFUL if vt == "helpful" else VoteType.NOT_HELPFUL,
                        voted_at=v["voted_at"],
                    )
                )

        total_votes = len(votes)
        return VoteHistory(
            user_id=user_id,
            total_votes=total_votes,
            helpful_votes=helpful_votes,
            not_helpful_votes=not_helpful_votes,
            recent_votes=items,
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\review\__init__.py ---
# app/services/review/__init__.py
"""
Review-related services.

- ReviewService:
    Core CRUD, listing, summary for internal reviews (content_review).

- PublicReviewService:
    Public-facing submission flow mapped onto the internal review model.

- ReviewModerationService:
    Moderation queue, approve/reject/flag, and moderation stats.

- ReviewAnalyticsService:
    Aggregated review analytics per hostel.

- ReviewVotingService:
    Helpfulness voting (helpful / not helpful) with Wilson score.

- HostelResponseService:
    Hostel/owner responses to reviews and response stats.
"""

from .review_service import ReviewService
from .public_review_service import PublicReviewService
from .review_moderation_service import ReviewModerationService, ModerationStore
from .review_analytics_service import ReviewAnalyticsService
from .review_voting_service import ReviewVotingService, VoteStore
from .hostel_response_service import HostelResponseService, HostelResponseStore

__all__ = [
    "ReviewService",
    "PublicReviewService",
    "ReviewModerationService",
    "ModerationStore",
    "ReviewAnalyticsService",
    "ReviewVotingService",
    "VoteStore",
    "HostelResponseService",
    "HostelResponseStore",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\services\review\__pycache__ =====
