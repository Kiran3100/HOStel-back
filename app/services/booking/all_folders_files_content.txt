### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\booking ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\booking =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\booking\booking_analytics_service.py ---
# app/services/booking/booking_analytics_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, List, Dict, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import BookingRepository
from app.schemas.analytics.booking_analytics import (
    BookingAnalyticsSummary,
    BookingKPI,
    BookingTrendPoint,
    BookingFunnel,
    CancellationAnalytics,
)
from app.schemas.common.enums import BookingStatus, BookingSource
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class BookingAnalyticsService:
    """
    Booking analytics based on txn_booking.

    - KPI (counts, rates)
    - Trend by day
    - Funnel approximation
    - Cancellation analytics
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    def get_analytics_for_hostel(
        self,
        hostel_id: Optional[UUID],
        period: DateRangeFilter,
    ) -> BookingAnalyticsSummary:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            filters: dict = {}
            if hostel_id:
                filters["hostel_id"] = hostel_id
            bookings = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

        start = period.start_date or date.min
        end = period.end_date or date.max

        filtered = []
        for b in bookings:
            d = b.booking_date.date()
            if d < start or d > end:
                continue
            filtered.append(b)

        total = len(filtered)
        confirmed = 0
        cancelled = 0
        rejected = 0
        total_revenue = Decimal("0")

        trend_by_date: Dict[str, Dict[str, Decimal | int]] = {}
        cancellations_by_reason: Dict[str, int] = {}
        cancellations_by_status: Dict[BookingStatus, int] = {}
        bookings_by_source: Dict[BookingSource, int] = {}

        for b in filtered:
            if b.booking_status == BookingStatus.CONFIRMED:
                confirmed += 1
            if b.booking_status == BookingStatus.CANCELLED:
                cancelled += 1
            if b.booking_status == BookingStatus.REJECTED:
                rejected += 1

            total_revenue += b.total_amount or Decimal("0")

            day = b.booking_date.date().isoformat()
            bucket = trend_by_date.setdefault(
                day,
                {"total": 0, "confirmed": 0, "cancelled": 0, "rejected": 0, "revenue": Decimal("0")},
            )
            bucket["total"] = int(bucket["total"]) + 1
            if b.booking_status == BookingStatus.CONFIRMED:
                bucket["confirmed"] = int(bucket["confirmed"]) + 1
            if b.booking_status == BookingStatus.CANCELLED:
                bucket["cancelled"] = int(bucket["cancelled"]) + 1
            if b.booking_status == BookingStatus.REJECTED:
                bucket["rejected"] = int(bucket["rejected"]) + 1
            bucket["revenue"] = bucket["revenue"] + b.total_amount

            bookings_by_source[b.source] = bookings_by_source.get(b.source, 0) + 1

        trend_points: List[BookingTrendPoint] = []
        for d, vals in sorted(trend_by_date.items()):
            trend_points.append(
                BookingTrendPoint(
                    date=date.fromisoformat(d),
                    total_bookings=int(vals["total"]),
                    confirmed=int(vals["confirmed"]),
                    cancelled=int(vals["cancelled"]),
                    rejected=int(vals["rejected"]),
                    revenue_for_day=vals["revenue"],
                )
            )

        kpi = BookingKPI(
            hostel_id=hostel_id,
            hostel_name=None,
            total_bookings=total,
            confirmed_bookings=confirmed,
            cancelled_bookings=cancelled,
            rejected_bookings=rejected,
            booking_conversion_rate=Decimal(str(confirmed / total * 100)) if total > 0 else Decimal("0"),
            cancellation_rate=Decimal(str(cancelled / total * 100)) if total > 0 else Decimal("0"),
            average_lead_time_days=Decimal("0"),
        )

        funnel = BookingFunnel(
            period=period,
            generated_at=None,
            hostel_page_views=0,
            booking_form_starts=0,
            booking_submissions=total,
            bookings_confirmed=confirmed,
            view_to_start_rate=Decimal("0"),
            start_to_submit_rate=Decimal("0"),
            submit_to_confirm_rate=Decimal(str(confirmed / total * 100)) if total > 0 else Decimal("0"),
            view_to_confirm_rate=Decimal("0"),
        )

        cancellations = CancellationAnalytics(
            period=period,
            total_cancellations=cancelled,
            cancellation_rate=Decimal(str(cancelled / total * 100)) if total > 0 else Decimal("0"),
            cancellations_by_reason=cancellations_by_reason,
            cancellations_by_status=cancellations_by_status,
            average_time_before_check_in_cancelled_days=Decimal("0"),
        )

        conversion_rate_by_source: Dict[BookingSource, Decimal] = {}
        for src, count in bookings_by_source.items():
            if count > 0:
                src_confirmed = sum(
                    1 for b in filtered if b.source == src and b.booking_status == BookingStatus.CONFIRMED
                )
                conversion_rate_by_source[src] = Decimal(str(src_confirmed / count * 100))
            else:
                conversion_rate_by_source[src] = Decimal("0")

        return BookingAnalyticsSummary(
            hostel_id=hostel_id,
            hostel_name=None,
            period=period,
            generated_at=None,
            kpi=kpi,
            trend=trend_points,
            funnel=funnel,
            cancellations=cancellations,
            bookings_by_source=bookings_by_source,
            conversion_rate_by_source=conversion_rate_by_source,
        )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\booking\booking_calendar_service.py ---
# app/services/booking/booking_calendar_service.py
from __future__ import annotations

from datetime import date, timedelta
from typing import Callable, List, Dict, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import BookingRepository
from app.repositories.core import RoomRepository
from app.schemas.booking import (
    CalendarView,
    DayBookings,
    BookingEvent,
    AvailabilityCalendar,
    DayAvailability,
)
from app.schemas.common.enums import BookingStatus
from app.services.common import UnitOfWork, errors


class BookingCalendarService:
    """
    Generate calendar views and availability for bookings.

    NOTE:
    - This is a read-only service over txn_booking and rooms.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_booking_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    # ------------------------------------------------------------------ #
    # Calendar view for a month
    # ------------------------------------------------------------------ #
    def get_calendar_view(
        self,
        hostel_id: UUID,
        year: int,
        month: int,
    ) -> CalendarView:
        from calendar import monthrange

        first_day = date(year, month, 1)
        last_day = date(year, month, monthrange(year, month)[1])

        with UnitOfWork(self._session_factory) as uow:
            booking_repo = self._get_booking_repo(uow)

            bookings = booking_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

        # Filter bookings that intersect with the month
        relevant = []
        for b in bookings:
            ci = b.preferred_check_in_date
            co = ci + timedelta(days=30 * b.stay_duration_months)
            if co < first_day or ci > last_day:
                continue
            relevant.append(b)

        days_map: Dict[str, DayBookings] = {}
        available_rooms_by_date: Dict[str, int] = {}

        for offset in range((last_day - first_day).days + 1):
            d = first_day + timedelta(days=offset)
            key = d.isoformat()
            days_map[key] = DayBookings(
                day_date=d,
                check_ins=[],
                check_outs=[],
                pending_bookings=[],
                available_beds=0,
                total_beds=0,
            )
            available_rooms_by_date[key] = 0

        for b in relevant:
            ci = b.preferred_check_in_date
            co = ci + timedelta(days=30 * b.stay_duration_months)

            # Check-ins
            ci_key = ci.isoformat()
            if ci_key in days_map:
                days_map[ci_key].check_ins.append(
                    BookingEvent(
                        booking_id=b.id,
                        booking_reference=f"BKG-{str(b.id)[:8].upper()}",
                        guest_name=b.guest_name,
                        room_number=None,
                        room_type=b.room_type_requested.value if hasattr(b.room_type_requested, "value") else str(b.room_type_requested),
                        status=b.booking_status,
                        is_check_in=True,
                        is_check_out=False,
                    )
                )

            # Check-outs
            co_key = co.isoformat()
            if co_key in days_map:
                days_map[co_key].check_outs.append(
                    BookingEvent(
                        booking_id=b.id,
                        booking_reference=f"BKG-{str(b.id)[:8].upper()}",
                        guest_name=b.guest_name,
                        room_number=None,
                        room_type=b.room_type_requested.value if hasattr(b.room_type_requested, "value") else str(b.room_type_requested),
                        status=b.booking_status,
                        is_check_in=False,
                        is_check_out=True,
                    )
                )

            # Pending bookings
            if b.booking_status == BookingStatus.PENDING:
                key = b.preferred_check_in_date.isoformat()
                if key in days_map:
                    days_map[key].pending_bookings.append(
                        BookingEvent(
                            booking_id=b.id,
                            booking_reference=f"BKG-{str(b.id)[:8].upper()}",
                            guest_name=b.guest_name,
                            room_number=None,
                            room_type=b.room_type_requested.value if hasattr(b.room_type_requested, "value") else str(b.room_type_requested),
                            status=b.booking_status,
                            is_check_in=False,
                            is_check_out=False,
                        )
                    )

        # available_rooms_by_date is left 0; you can enrich it using room occupancy if needed
        return CalendarView(
            hostel_id=hostel_id,
            month=f"{year:04d}-{month:02d}",
            days=days_map,
            total_check_ins=sum(len(d.check_ins) for d in days_map.values()),
            total_check_outs=sum(len(d.check_outs) for d in days_map.values()),
            peak_occupancy_date=None,
            available_rooms_by_date=available_rooms_by_date,
        )

    # ------------------------------------------------------------------ #
    # Availability calendar (per room)
    # ------------------------------------------------------------------ #
    def get_availability_calendar(
        self,
        room_id: UUID,
        year: int,
        month: int,
    ) -> AvailabilityCalendar:
        from calendar import monthrange

        first_day = date(year, month, 1)
        last_day = date(year, month, monthrange(year, month)[1])

        with UnitOfWork(self._session_factory) as uow:
            booking_repo = self._get_booking_repo(uow)
            room_repo = self._get_room_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            bookings = booking_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"room_id": room_id},
            )

        availability: Dict[str, DayAvailability] = {}
        for offset in range((last_day - first_day).days + 1):
            d = first_day + timedelta(days=offset)
            key = d.isoformat()
            availability[key] = DayAvailability(
                day_date=d,
                total_beds=room.total_beds,
                available_beds=room.total_beds,
                booked_beds=0,
                is_fully_booked=False,
                active_bookings=[],
            )

        from app.schemas.booking.booking_calendar import BookingInfo  # avoid circular imports

        for b in bookings:
            ci = b.preferred_check_in_date
            co = ci + timedelta(days=30 * b.stay_duration_months)
            for offset in range((co - ci).days):
                d = ci + timedelta(days=offset)
                if d < first_day or d > last_day:
                    continue
                key = d.isoformat()
                if key not in availability:
                    continue
                day_avail = availability[key]
                day_avail.available_beds = max(0, day_avail.available_beds - 1)
                day_avail.booked_beds = day_avail.total_beds - day_avail.available_beds
                day_avail.is_fully_booked = day_avail.available_beds == 0
                day_avail.active_bookings.append(b.id)

        return AvailabilityCalendar(
            room_id=room_id,
            room_number=room.room_number,
            month=f"{year:04d}-{month:02d}",
            availability=availability,
        )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\booking\booking_cancellation_service.py ---
# app/services/booking/booking_cancellation_service.py
from __future__ import annotations

from datetime import datetime, timezone, date
from decimal import Decimal
from typing import Callable, Optional, List, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import BookingRepository, PaymentRepository
from app.schemas.common.enums import BookingStatus, PaymentStatus, PaymentType
from app.schemas.booking import (
    CancellationRequest,
    CancellationResponse,
    RefundCalculation,
    CancellationPolicy,
    CancellationCharge,
    BulkCancellation,
)
from app.services.common import UnitOfWork, errors


class RefundExecutor(Protocol):
    """
    Optional abstraction for actually issuing refunds via payment gateway.
    """

    def execute_refund(
        self,
        *,
        payment_id: UUID,
        amount: Decimal,
        reason: str,
    ) -> str: ...
    # returns refund reference/transaction id


class BookingCancellationService:
    """
    Booking cancellation and refund calculation:

    - Cancel bookings
    - Compute refund amounts based on CancellationPolicy
    - Optionally execute refunds via a RefundExecutor
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        refund_executor: Optional[RefundExecutor] = None,
    ) -> None:
        self._session_factory = session_factory
        self._refund_executor = refund_executor

    def _get_booking_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Policy evaluation
    # ------------------------------------------------------------------ #
    def _find_applicable_charge(
        self,
        policy: CancellationPolicy,
        days_before_checkin: int,
    ) -> CancellationCharge:
        """
        Given days_before_checkin, find the matching charge tier:

        Assumes policy.cancellation_before_days is sorted ascending by days_before_checkin.
        """
        # Simple approach: choose the highest days_before_checkin <= actual days_before
        best: Optional[CancellationCharge] = None
        for tier in policy.cancellation_before_days:
            if days_before_checkin >= tier.days_before_checkin:
                if best is None or tier.days_before_checkin > best.days_before_checkin:
                    best = tier
        # If none matched, choose the strictest (e.g. highest charge)
        if best is None and policy.cancellation_before_days:
            best = policy.cancellation_before_days[-1]
        if best is None:
            # default: no charge
            return CancellationCharge(
                days_before_checkin=0,
                charge_percentage=Decimal("0"),
                description="No policy; full refund",
            )
        return best

    def _calculate_refund(
        self,
        booking,
        payment_amount: Decimal,
        policy: CancellationPolicy,
        cancel_date: date,
    ) -> RefundCalculation:
        check_in = booking.preferred_check_in_date
        days_before = (check_in - cancel_date).days if check_in > cancel_date else 0
        tier = self._find_applicable_charge(policy, days_before)

        cancellation_charge = (payment_amount * tier.charge_percentage) / 100
        refundable = max(Decimal("0"), payment_amount - cancellation_charge)

        return RefundCalculation(
            advance_paid=payment_amount,
            cancellation_charge=cancellation_charge,
            cancellation_charge_percentage=tier.charge_percentage,
            refundable_amount=refundable,
            refund_processing_time_days=policy.refund_processing_days,
            refund_method="original_source",
            breakdown={
                "days_before_checkin": days_before,
                "applied_tier": tier.description,
            },
        )

    # ------------------------------------------------------------------ #
    # Cancel a booking
    # ------------------------------------------------------------------ #
    def cancel(
        self,
        data: CancellationRequest,
        *,
        policy: CancellationPolicy,
    ) -> CancellationResponse:
        with UnitOfWork(self._session_factory) as uow:
            booking_repo = self._get_booking_repo(uow)
            payment_repo = self._get_payment_repo(uow)

            b = booking_repo.get(data.booking_id)
            if b is None:
                raise errors.NotFoundError(f"Booking {data.booking_id} not found")

            # Only pending/confirmed/checked_in bookings are cancellable here
            if b.booking_status not in (
                BookingStatus.PENDING,
                BookingStatus.CONFIRMED,
                BookingStatus.CHECKED_IN,
            ):
                raise errors.ValidationError(f"Booking {data.booking_id} cannot be cancelled in status {b.booking_status}")

            # For simplicity, look for a single booking_advance payment
            payments = payment_repo.list_for_booking(b.id)
            advance_payment = None
            for p in payments:
                if p.payment_type == PaymentType.BOOKING_ADVANCE:
                    advance_payment = p
                    break

            payment_amount = advance_payment.amount if advance_payment else Decimal("0")
            refund = self._calculate_refund(
                booking=b,
                payment_amount=payment_amount,
                policy=policy,
                cancel_date=date.today(),
            )

            # Optionally execute refund via gateway
            if data.request_refund and self._refund_executor and advance_payment:
                refund_ref = self._refund_executor.execute_refund(
                    payment_id=advance_payment.id,
                    amount=refund.refundable_amount,
                    reason=data.cancellation_reason,
                )
                refund.breakdown["refund_reference"] = refund_ref

            # Update booking status
            b.booking_status = BookingStatus.CANCELLED  # type: ignore[attr-defined]
            # For full semantics, you'd also set cancelled_by/at fields via another store.

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return CancellationResponse(
            booking_id=b.id,
            booking_reference=f"BKG-{str(b.id)[:8].upper()}",
            cancelled=True,
            cancelled_at=self._now(),
            refund=refund,
            message="Booking cancelled successfully",
            confirmation_sent=False,
        )

    def bulk_cancel(
        self,
        data: BulkCancellation,
        *,
        policy: CancellationPolicy,
    ) -> List[CancellationResponse]:
        responses: List[CancellationResponse] = []
        for bid in data.booking_ids:
            req = CancellationRequest(
                booking_id=bid,
                cancelled_by_role="admin",
                cancellation_reason=data.reason,
                request_refund=data.process_refunds,
                additional_comments=None,
            )
            responses.append(self.cancel(req, policy=policy))
        return responses

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\booking\booking_conversion_service.py ---
# app/services/booking/booking_conversion_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import BookingRepository
from app.repositories.core import StudentRepository, HostelRepository, RoomRepository, BedRepository
from app.schemas.booking import (
    ConvertToStudentRequest,
    ConversionResponse,
    ConversionChecklist,
    ChecklistItem,
)
from app.schemas.common.enums import BookingStatus, StudentStatus
from app.services.common import UnitOfWork, errors


class BookingConversionService:
    """
    Convert confirmed bookings into Student profiles.

    - Validates that booking is confirmed
    - Checks financial confirmations
    - Creates Student record
    - Assigns room/bed
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_booking_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    # ------------------------------------------------------------------ #
    # Checklist / eligibility
    # ------------------------------------------------------------------ #
    def build_checklist(self, booking_id: UUID) -> ConversionChecklist:
        """
        Build a simple pre-conversion checklist. Here we only stub it;
        you can enrich with actual checks.
        """
        checks: List[ChecklistItem] = [
            ChecklistItem(
                item_name="Security deposit received",
                description="Verify security deposit payment",
                is_completed=False,
                is_required=True,
                completed_at=None,
                notes=None,
            ),
            ChecklistItem(
                item_name="First month rent received",
                description="Verify first month rent payment",
                is_completed=False,
                is_required=True,
                completed_at=None,
                notes=None,
            ),
            ChecklistItem(
                item_name="ID proof uploaded",
                description="Check that a valid ID proof document is uploaded",
                is_completed=False,
                is_required=True,
                completed_at=None,
                notes=None,
            ),
        ]
        return ConversionChecklist(
            booking_id=booking_id,
            booking_reference=f"BKG-{str(booking_id)[:8].upper()}",
            checks=checks,
            all_checks_passed=False,
            can_convert=False,
            missing_items=[c.item_name for c in checks],
        )

    # ------------------------------------------------------------------ #
    # Conversion
    # ------------------------------------------------------------------ #
    def convert(
        self,
        data: ConvertToStudentRequest,
        *,
        user_id: UUID,
        hostel_id: UUID,
        room_id: UUID,
        bed_id: UUID,
        monthly_rent: Decimal,
        security_deposit: Decimal,
        next_payment_due_date: date,
    ) -> ConversionResponse:
        with UnitOfWork(self._session_factory) as uow:
            booking_repo = self._get_booking_repo(uow)
            student_repo = self._get_student_repo(uow)
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)

            b = booking_repo.get(data.booking_id)
            if b is None:
                raise errors.NotFoundError(f"Booking {data.booking_id} not found")

            if b.booking_status not in (BookingStatus.CONFIRMED, BookingStatus.CHECKED_IN):
                raise errors.ValidationError("Booking must be confirmed before conversion")

            # Create student record
            student_payload = {
                "user_id": user_id,
                "hostel_id": hostel_id,
                "room_id": room_id,
                "bed_id": bed_id,
                "guardian_name": "",
                "guardian_phone": "",
                "guardian_email": None,
                "guardian_relation": None,
                "guardian_address": None,
                "institution_name": None,
                "course": None,
                "year_of_study": None,
                "company_name": None,
                "designation": None,
                "check_in_date": data.actual_check_in_date,
                "expected_checkout_date": None,
                "actual_checkout_date": None,
                "security_deposit_amount": security_deposit,
                "monthly_rent_amount": monthly_rent,
                "mess_subscribed": False,
                "dietary_preference": None,
                "food_allergies": None,
                "student_status": StudentStatus.ACTIVE,
            }
            student = student_repo.create(student_payload)  # type: ignore[arg-type]

            # Assign bed's current_student_id
            bed = bed_repo.get(bed_id)
            if bed:
                bed.current_student_id = student.id  # type: ignore[attr-defined]

            # Optionally mark booking as converted
            b.booking_status = BookingStatus.COMPLETED  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        room = room_repo.get(room_id)
        bed_obj = bed_repo.get(bed_id)

        return ConversionResponse(
            booking_id=data.booking_id,
            student_profile_id=student.id,
            converted=True,
            conversion_date=data.actual_check_in_date,
            room_number=room.room_number if room else "",
            bed_number=bed_obj.bed_number if bed_obj else "",
            monthly_rent=monthly_rent,
            security_deposit=security_deposit,
            next_payment_due_date=next_payment_due_date,
            message="Booking converted to student successfully",
            next_steps=[
                "Complete hostel onboarding form",
                "Collect room keys",
            ],
        )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\booking\booking_modification_service.py ---
# app/services/booking/booking_modification_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import BookingRepository
from app.schemas.booking import (
    ModificationRequest,
    ModificationResponse,
    DateChangeRequest,
    DurationChangeRequest,
    RoomTypeChangeRequest,
    ModificationApproval,
)
from app.schemas.common.enums import BookingStatus, RoomType
from app.services.common import UnitOfWork, errors


class BookingModificationService:
    """
    Handle booking modification requests (date/duration/room_type):

    - Calculate price impact
    - Optionally require admin approval
    - Apply changes
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_booking_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    # ------------------------------------------------------------------ #
    # Core modification
    # ------------------------------------------------------------------ #
    def modify(self, data: ModificationRequest) -> ModificationResponse:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)
            b = repo.get(data.booking_id)
            if b is None:
                raise errors.NotFoundError(f"Booking {data.booking_id} not found")

            original_total = b.total_amount
            new_total = b.total_amount
            modifications_applied: List[str] = []

            if data.modify_check_in_date and data.new_check_in_date:
                modifications_applied.append("check_in_date")
                b.preferred_check_in_date = data.new_check_in_date  # type: ignore[attr-defined]

            if data.modify_duration and data.new_duration_months:
                modifications_applied.append("duration")
                b.stay_duration_months = data.new_duration_months  # type: ignore[attr-defined]
                # Recompute total as a stub; real implementation uses FeeStructure
                new_total = b.quoted_rent_monthly * data.new_duration_months  # type: ignore[attr-defined]

            if data.modify_room_type and data.new_room_type:
                modifications_applied.append("room_type")
                b.room_type_requested = data.new_room_type  # type: ignore[attr-defined]
                # Price change may occur; left as-is unless you integrate FeeStructure

            price_difference = new_total - original_total
            additional_payment_required = price_difference > 0
            additional_amount = price_difference if price_difference > 0 else Decimal("0")

            requires_admin_approval = additional_payment_required and not data.accept_price_change
            auto_approved = not requires_admin_approval

            if auto_approved:
                b.total_amount = new_total  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return ModificationResponse(
            booking_id=data.booking_id,
            booking_reference=f"BKG-{str(data.booking_id)[:8].upper()}",
            modifications_applied=modifications_applied,
            original_total=original_total,
            new_total=new_total,
            price_difference=price_difference,
            additional_payment_required=additional_payment_required,
            additional_amount=additional_amount,
            requires_admin_approval=requires_admin_approval,
            auto_approved=auto_approved,
            message="Booking modification processed",
        )

    # Convenience wrappers
    def change_date(self, data: DateChangeRequest) -> ModificationResponse:
        req = ModificationRequest(
            booking_id=data.booking_id,
            modify_check_in_date=True,
            new_check_in_date=data.new_check_in_date,
            modify_duration=False,
            new_duration_months=None,
            modify_room_type=False,
            new_room_type=None,
            modification_reason=data.reason,
            accept_price_change=True,
        )
        return self.modify(req)

    def change_duration(self, data: DurationChangeRequest) -> ModificationResponse:
        req = ModificationRequest(
            booking_id=data.booking_id,
            modify_check_in_date=False,
            new_check_in_date=None,
            modify_duration=True,
            new_duration_months=data.new_duration_months,
            modify_room_type=False,
            new_room_type=None,
            modification_reason=data.reason,
            accept_price_change=True,
        )
        return self.modify(req)

    def change_room_type(self, data: RoomTypeChangeRequest) -> ModificationResponse:
        req = ModificationRequest(
            booking_id=data.booking_id,
            modify_check_in_date=False,
            new_check_in_date=None,
            modify_duration=False,
            new_duration_months=None,
            modify_room_type=True,
            new_room_type=data.new_room_type,
            modification_reason=data.reason,
            accept_price_change=data.accept_price_difference,
        )
        return self.modify(req)

    # Admin approval payload handling
    def approve_modification(self, data: ModificationApproval) -> None:
        # In a fuller implementation, you'd look up a stored modification request,
        # apply adjusted_price, and record admin decision. Left as a stub here.
        pass

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\booking\booking_service.py ---
# app/services/booking/booking_service.py
from __future__ import annotations

from datetime import datetime, timezone, timedelta, date
from decimal import Decimal
from typing import Callable, Optional, Sequence, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import BookingRepository
from app.repositories.core import HostelRepository, RoomRepository, BedRepository
from app.schemas.common.enums import BookingStatus, BookingSource, RoomType
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.booking import (
    BookingCreate,
    BookingUpdate,
    BookingRequest,
    QuickBookingRequest,
    BookingFilterParams,
    BookingSortOptions,
    BookingSearchRequest,
    BookingResponse,
    BookingDetail,
    BookingListItem,
    BookingConfirmation,
)
from app.services.common import UnitOfWork, pagination, errors


class BookingService:
    """
    Core booking service (internal txn_booking model):

    - Create booking from internal BookingCreate or public BookingRequest/QuickBookingRequest
    - Get single booking (detail)
    - List / search bookings with filters & sorting
    - Update booking & booking status
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_booking_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def _expected_checkout_date(self, check_in: date, months: int) -> date:
        # Very simple monthâ†’days approximation; customize as needed
        return check_in + timedelta(days=30 * months)

    def _booking_reference(self, booking_id: UUID) -> str:
        return f"BKG-{str(booking_id)[:8].upper()}"

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_response(self, b) -> BookingResponse:
        hostel = getattr(b, "hostel", None)
        advance_paid = any((p.payment_status.name == "COMPLETED" and p.payment_type.name == "BOOKING_ADVANCE")
                           for p in getattr(b, "payments", []) or [])

        return BookingResponse(
            id=b.id,
            created_at=b.created_at,
            updated_at=b.updated_at,
            booking_reference=self._booking_reference(b.id),
            visitor_id=b.visitor_id,
            hostel_id=b.hostel_id,
            hostel_name=hostel.name if hostel else "",
            room_type_requested=b.room_type_requested,
            preferred_check_in_date=b.preferred_check_in_date,
            stay_duration_months=b.stay_duration_months,
            expected_check_out_date=self._expected_checkout_date(
                b.preferred_check_in_date, b.stay_duration_months
            ),
            guest_name=b.guest_name,
            guest_email=b.guest_email,
            guest_phone=b.guest_phone,
            quoted_rent_monthly=b.quoted_rent_monthly,
            total_amount=b.total_amount,
            security_deposit=b.security_deposit,
            advance_amount=b.advance_amount,
            advance_paid=advance_paid,
            booking_status=b.booking_status,
            booking_date=b.booking_date,
            expires_at=b.expires_at,
        )

    def _to_detail(self, b, hostel_name: str, hostel_city: str, hostel_address: str, hostel_phone: str,
                   room_number: Optional[str], bed_number: Optional[str]) -> BookingDetail:
        advance_payment = None
        for p in getattr(b, "payments", []) or []:
            if p.payment_type.name == "BOOKING_ADVANCE":
                advance_payment = p
                break

        advance_paid = advance_payment is not None and advance_payment.payment_status.name == "COMPLETED"
        advance_payment_id = advance_payment.id if advance_payment else None

        approved_by = None
        approved_by_name = None
        # You can later wire this to a workflow/approval store

        rejected_by = None
        rejected_at = None
        rejection_reason = None

        cancelled_by = None
        cancelled_at = None
        cancellation_reason = None

        converted_to_student = False
        student_profile_id = None
        conversion_date = None

        return BookingDetail(
            id=b.id,
            created_at=b.created_at,
            updated_at=b.updated_at,
            booking_reference=self._booking_reference(b.id),
            visitor_id=b.visitor_id,
            visitor_name=b.guest_name,
            hostel_id=b.hostel_id,
            hostel_name=hostel_name,
            hostel_city=hostel_city,
            hostel_address=hostel_address,
            hostel_phone=hostel_phone,
            room_type_requested=b.room_type_requested,
            preferred_check_in_date=b.preferred_check_in_date,
            stay_duration_months=b.stay_duration_months,
            expected_check_out_date=self._expected_checkout_date(
                b.preferred_check_in_date, b.stay_duration_months
            ),
            room_id=b.room_id,
            room_number=room_number,
            bed_id=b.bed_id,
            bed_number=bed_number,
            guest_name=b.guest_name,
            guest_email=b.guest_email,
            guest_phone=b.guest_phone,
            guest_id_proof_type=None,
            guest_id_proof_number=None,
            emergency_contact_name=None,
            emergency_contact_phone=None,
            emergency_contact_relation=None,
            institution_or_company=None,
            designation_or_course=None,
            special_requests=None,
            dietary_preferences=None,
            has_vehicle=False,
            vehicle_details=None,
            quoted_rent_monthly=b.quoted_rent_monthly,
            total_amount=b.total_amount,
            security_deposit=b.security_deposit,
            advance_amount=b.advance_amount,
            advance_paid=advance_paid,
            advance_payment_id=advance_payment_id,
            booking_status=b.booking_status,
            approved_by=approved_by,
            approved_by_name=approved_by_name,
            approved_at=None,
            rejected_by=rejected_by,
            rejected_at=rejected_at,
            rejection_reason=rejection_reason,
            cancelled_by=cancelled_by,
            cancelled_at=cancelled_at,
            cancellation_reason=cancellation_reason,
            converted_to_student=converted_to_student,
            student_profile_id=student_profile_id,
            conversion_date=conversion_date,
            source=b.source,
            referral_code=b.referral_code,
            booking_date=b.booking_date,
            expires_at=b.expires_at,
        )

    def _to_list_item(self, b, hostel_name: str, is_urgent: bool, days_until_checkin: Optional[int]) -> BookingListItem:
        expected_checkout = self._expected_checkout_date(b.preferred_check_in_date, b.stay_duration_months)
        return BookingListItem(
            id=b.id,
            booking_reference=self._booking_reference(b.id),
            guest_name=b.guest_name,
            guest_phone=b.guest_phone,
            hostel_name=hostel_name,
            room_type_requested=b.room_type_requested.value if hasattr(b.room_type_requested, "value") else str(b.room_type_requested),
            preferred_check_in_date=b.preferred_check_in_date,
            stay_duration_months=b.stay_duration_months,
            total_amount=b.total_amount,
            advance_paid=False,  # you can enrich like in _to_response if needed
            booking_status=b.booking_status,
            booking_date=b.booking_date,
            is_urgent=is_urgent,
            days_until_checkin=days_until_checkin,
        )

    # ------------------------------------------------------------------ #
    # Read
    # ------------------------------------------------------------------ #
    def get_booking(self, booking_id: UUID) -> BookingDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)

            b = repo.get(booking_id)
            if b is None:
                raise errors.NotFoundError(f"Booking {booking_id} not found")

            hostel = hostel_repo.get(b.hostel_id)
            room = room_repo.get(b.room_id) if b.room_id else None
            bed = bed_repo.get(b.bed_id) if b.bed_id else None

            hostel_name = hostel.name if hostel else ""
            hostel_city = hostel.city if hostel else ""
            hostel_address = hostel.address_line1 if hostel else ""
            hostel_phone = hostel.contact_phone if hostel else ""
            room_number = room.room_number if room else None
            bed_number = bed.bed_number if bed else None

            return self._to_detail(
                b,
                hostel_name=hostel_name,
                hostel_city=hostel_city,
                hostel_address=hostel_address,
                hostel_phone=hostel_phone,
                room_number=room_number,
                bed_number=bed_number,
            )

    # ------------------------------------------------------------------ #
    # Listing & filtering
    # ------------------------------------------------------------------ #
    def list_bookings(
        self,
        params: PaginationParams,
        filters: Optional[BookingFilterParams] = None,
        sort: Optional[BookingSortOptions] = None,
    ) -> PaginatedResponse[BookingListItem]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            raw_filters: dict = {}
            if filters:
                if filters.hostel_id:
                    raw_filters["hostel_id"] = filters.hostel_id
                if filters.status:
                    raw_filters["booking_status"] = filters.status
                if filters.room_type:
                    raw_filters["room_type_requested"] = filters.room_type
                if filters.source:
                    raw_filters["source"] = filters.source
                if filters.advance_paid is not None:
                    # This requires payment join; here we skip and let higher layer handle.
                    pass
                if filters.converted_to_student is not None:
                    # Requires conversion tracking; skip here.
                    pass

            order_by = None
            if sort:
                col_map = {
                    "booking_date": repo.model.booking_date,          # type: ignore[attr-defined]
                    "check_in_date": repo.model.preferred_check_in_date,  # type: ignore[attr-defined]
                    "guest_name": repo.model.guest_name,             # type: ignore[attr-defined]
                    "status": repo.model.booking_status,             # type: ignore[attr-defined]
                    "total_amount": repo.model.total_amount,         # type: ignore[attr-defined]
                }
                sort_col = col_map.get(sort.sort_by, repo.model.booking_date)  # type: ignore[attr-defined]
                order_by = [sort_col.asc() if sort.sort_order == "asc" else sort_col.desc()]

            records: Sequence = repo.get_multi(
                skip=params.offset,
                limit=params.limit,
                filters=raw_filters or None,
                order_by=order_by,
            )
            total = repo.count(filters=raw_filters or None)

            now = date.today()
            items: List[BookingListItem] = []
            hostel_name_cache: dict[UUID, str] = {}

            for b in records:
                if b.hostel_id not in hostel_name_cache:
                    h = hostel_repo.get(b.hostel_id)
                    hostel_name_cache[b.hostel_id] = h.name if h else ""
                hostel_name = hostel_name_cache[b.hostel_id]

                days_until_checkin: Optional[int] = None
                if b.preferred_check_in_date:
                    days_until_checkin = (b.preferred_check_in_date - now).days
                is_urgent = days_until_checkin is not None and days_until_checkin <= 1 and b.booking_status == BookingStatus.PENDING

                items.append(
                    self._to_list_item(
                        b,
                        hostel_name=hostel_name,
                        is_urgent=is_urgent,
                        days_until_checkin=days_until_checkin,
                    )
                )

            return PaginatedResponse[BookingListItem].create(
                items=items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    def search_bookings(
        self,
        params: PaginationParams,
        req: BookingSearchRequest,
    ) -> PaginatedResponse[BookingListItem]:
        """
        Simple in-memory search on booking_reference, guest name, email, phone.
        For large datasets, replace with dedicated queries.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            filters: dict = {}
            if req.hostel_id:
                filters["hostel_id"] = req.hostel_id
            if req.status:
                filters["booking_status"] = req.status

            records: Sequence = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
                order_by=[repo.model.booking_date.desc()],  # type: ignore[attr-defined]
            )

            q = req.query.lower()
            filtered: List = []
            for b in records:
                ref = self._booking_reference(b.id).lower()
                if req.search_in_reference and q in ref:
                    filtered.append(b)
                    continue
                if req.search_in_guest_name and q in (b.guest_name or "").lower():
                    filtered.append(b)
                    continue
                if req.search_in_email and q in (b.guest_email or "").lower():
                    filtered.append(b)
                    continue
                if req.search_in_phone and q in (b.guest_phone or "").lower():
                    filtered.append(b)

            total = len(filtered)
            start = params.offset
            end = start + params.limit
            page_items = filtered[start:end]

            now = date.today()
            items: List[BookingListItem] = []
            hostel_name_cache: dict[UUID, str] = {}

            for b in page_items:
                if b.hostel_id not in hostel_name_cache:
                    h = hostel_repo.get(b.hostel_id)
                    hostel_name_cache[b.hostel_id] = h.name if h else ""
                hostel_name = hostel_name_cache[b.hostel_id]

                days_until_checkin: Optional[int] = None
                if b.preferred_check_in_date:
                    days_until_checkin = (b.preferred_check_in_date - now).days
                is_urgent = days_until_checkin is not None and days_until_checkin <= 1 and b.booking_status == BookingStatus.PENDING

                items.append(
                    self._to_list_item(
                        b,
                        hostel_name=hostel_name,
                        is_urgent=is_urgent,
                        days_until_checkin=days_until_checkin,
                    )
                )

            return PaginatedResponse[BookingListItem].create(
                items=items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    # ------------------------------------------------------------------ #
    # Create
    # ------------------------------------------------------------------ #
    def create_booking(self, data: BookingCreate) -> BookingDetail:
        """
        Internal creation using BookingCreate schema (admin/dashboard).
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)

            payload = data.model_dump()
            # Ensure default status
            payload.setdefault("booking_status", BookingStatus.PENDING)
            payload.setdefault("source", BookingSource.WEBSITE)
            payload.setdefault("booking_date", self._now())
            booking = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()
            return self.get_booking(booking.id)

    def create_booking_from_request(
        self,
        visitor_id: UUID,
        data: BookingRequest,
        *,
        source: BookingSource = BookingSource.WEBSITE,
    ) -> BookingDetail:
        """
        Public-facing booking request â†’ internal booking.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)

            total_amount = Decimal(str(data.stay_duration_months or 1)) * Decimal("0")
            # A real implementation would consult FeeStructure; here we require client to
            # send correct total_amount via a separate handler, or you can extend this.

            payload = {
                "visitor_id": visitor_id,
                "hostel_id": data.hostel_id,
                "room_type_requested": data.room_type_requested,
                "preferred_check_in_date": data.preferred_check_in_date,
                "stay_duration_months": data.stay_duration_months,
                "quoted_rent_monthly": Decimal("0"),
                "total_amount": total_amount,
                "security_deposit": Decimal("0"),
                "advance_amount": Decimal("0"),
                "booking_status": BookingStatus.PENDING,
                "source": source,
                "referral_code": data.referral_code,
                "booking_date": self._now(),
                "expires_at": None,
                "guest_name": data.guest_info.guest_name,
                "guest_email": data.guest_info.guest_email,
                "guest_phone": data.guest_info.guest_phone,
                "room_id": None,
                "bed_id": None,
            }
            booking = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()
            return self.get_booking(booking.id)

    def quick_booking(
        self,
        visitor_id: UUID,
        data: QuickBookingRequest,
        *,
        source: BookingSource = BookingSource.WEBSITE,
    ) -> BookingDetail:
        """
        Minimal quick-booking endpoint.
        """
        br = BookingRequest(
            hostel_id=data.hostel_id,
            room_type_requested=data.room_type_requested,
            preferred_check_in_date=data.check_in_date,
            stay_duration_months=data.duration_months,
            guest_info={
                "guest_name": data.name,
                "guest_email": data.email,
                "guest_phone": data.phone,
            },
        )  # type: ignore[arg-type]

        return self.create_booking_from_request(visitor_id, br, source=source)

    # ------------------------------------------------------------------ #
    # Update
    # ------------------------------------------------------------------ #
    def update_booking(self, booking_id: UUID, data: BookingUpdate) -> BookingDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)
            b = repo.get(booking_id)
            if b is None:
                raise errors.NotFoundError(f"Booking {booking_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(b, field) and field != "id":
                    setattr(b, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return self.get_booking(booking_id)

    def set_status(self, booking_id: UUID, status: BookingStatus) -> BookingDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)
            b = repo.get(booking_id)
            if b is None:
                raise errors.NotFoundError(f"Booking {booking_id} not found")

            b.booking_status = status  # type: ignore[attr-defined]
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return self.get_booking(booking_id)

    # ------------------------------------------------------------------ #
    # Confirmation
    # ------------------------------------------------------------------ #
    def build_confirmation(self, booking_id: UUID, *, hostel_contact_email: Optional[str]) -> BookingConfirmation:
        """
        Build a BookingConfirmation response from an existing booking.
        """
        detail = self.get_booking(booking_id)
        balance = detail.total_amount - detail.advance_amount
        return BookingConfirmation(
            booking_id=detail.id,
            booking_reference=detail.booking_reference,
            hostel_name=detail.hostel_name,
            room_type=detail.room_type_requested.value if hasattr(detail.room_type_requested, "value") else str(detail.room_type_requested),
            check_in_date=detail.preferred_check_in_date,
            total_amount=detail.total_amount,
            advance_amount=detail.advance_amount,
            balance_amount=balance,
            confirmation_message="Your booking has been confirmed.",
            next_steps=[
                "Complete payment before check-in.",
                "Bring a valid ID proof.",
            ],
            hostel_contact_phone=detail.hostel_phone,
            hostel_contact_email=hostel_contact_email,
        )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\booking\booking_waitlist_service.py ---
# app/services/booking/booking_waitlist_service.py
from __future__ import annotations

from datetime import datetime, timezone, date
from decimal import Decimal
from typing import Protocol, List, Dict
from uuid import UUID

from app.schemas.booking import (
    WaitlistRequest,
    WaitlistResponse,
    WaitlistNotification,
    WaitlistConversion,
    WaitlistCancellation,
    WaitlistManagement,
    WaitlistEntry,
)
from app.schemas.common.enums import WaitlistStatus as WaitlistStatusEnum, RoomType


class WaitlistStore(Protocol):
    """
    Abstract store for waitlist entries.

    Implementations can use a DB table or Redis.
    """

    def create_entry(self, data: dict) -> dict: ...
    def update_entry(self, waitlist_id: UUID, data: dict) -> dict: ...
    def get_entry(self, waitlist_id: UUID) -> dict | None: ...
    def list_for_hostel_roomtype(self, hostel_id: UUID, room_type: RoomType) -> List[dict]: ...


class BookingWaitlistService:
    """
    Manage booking waitlists when hostels are full.
    """

    def __init__(self, store: WaitlistStore) -> None:
        self._store = store

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Waitlist management
    # ------------------------------------------------------------------ #
    def add_to_waitlist(self, data: WaitlistRequest, *, hostel_name: str) -> WaitlistResponse:
        record = {
            "id": None,
            "hostel_id": str(data.hostel_id),
            "hostel_name": hostel_name,
            "visitor_id": str(data.visitor_id),
            "room_type": data.room_type.value if hasattr(data.room_type, "value") else str(data.room_type),
            "preferred_check_in_date": data.preferred_check_in_date.isoformat(),
            "contact_email": data.contact_email,
            "contact_phone": data.contact_phone,
            "notes": data.notes,
            "priority": 0,
            "status": WaitlistStatusEnum.WAITING.value,
            "created_at": self._now(),
            "estimated_availability_date": None,
            "notification_count": 0,
        }
        created = self._store.create_entry(record)

        return WaitlistResponse(
            id=UUID(created["id"]),
            created_at=created["created_at"],
            updated_at=created["created_at"],
            hostel_id=data.hostel_id,
            hostel_name=hostel_name,
            visitor_id=data.visitor_id,
            room_type=data.room_type,
            preferred_check_in_date=data.preferred_check_in_date,
            contact_email=data.contact_email,
            contact_phone=data.contact_phone,
            priority=created.get("priority", 0),
            status=WaitlistStatusEnum.WAITING,
            estimated_availability_date=None,
        )

    def cancel_waitlist(self, data: WaitlistCancellation) -> None:
        entry = self._store.get_entry(data.waitlist_id)
        if not entry:
            return
        entry["status"] = WaitlistStatusEnum.CANCELLED.value
        entry["cancellation_reason"] = data.cancellation_reason
        self._store.update_entry(data.waitlist_id, entry)

    def notify_availability(
        self,
        waitlist_id: UUID,
        *,
        available_room_id: UUID,
        available_bed_id: UUID,
        response_deadline: datetime,
    ) -> WaitlistNotification:
        entry = self._store.get_entry(waitlist_id)
        if not entry:
            raise ValueError(f"Waitlist {waitlist_id} not found")

        entry["status"] = WaitlistStatusEnum.NOTIFIED.value
        entry["notification_count"] = entry.get("notification_count", 0) + 1
        self._store.update_entry(waitlist_id, entry)

        return WaitlistNotification(
            waitlist_id=waitlist_id,
            visitor_id=UUID(entry["visitor_id"]),
            hostel_id=UUID(entry["hostel_id"]),
            message="Room is available for your waitlist request",
            available_room_id=available_room_id,
            available_bed_id=available_bed_id,
            response_deadline=response_deadline,
            booking_link="",
        )

    def list_waitlist_for_hostel(
        self,
        hostel_id: UUID,
        room_type: RoomType,
        *,
        hostel_name: str,
    ) -> WaitlistManagement:
        entries = self._store.list_for_hostel_roomtype(hostel_id, room_type)
        waitlist_entries: List[WaitlistEntry] = []
        for e in entries:
            waitlist_entries.append(
                WaitlistEntry(
                    waitlist_id=UUID(e["id"]),
                    visitor_name="",
                    contact_email=e["contact_email"],
                    contact_phone=e["contact_phone"],
                    preferred_check_in_date=date.fromisoformat(e["preferred_check_in_date"]),
                    priority=e.get("priority", 0),
                    status=WaitlistStatusSchema[e["status"].upper()],
                    days_waiting=(date.today() - e["created_at"].date()).days,
                    created_at=e["created_at"],
                )
            )
        return WaitlistManagement(
            hostel_id=hostel_id,
            room_type=room_type,
            total_in_waitlist=len(waitlist_entries),
            entries=waitlist_entries,
        )

    def convert_waitlist_to_booking(self, data: WaitlistConversion) -> None:
        entry = self._store.get_entry(data.waitlist_id)
        if not entry:
            return

        if data.accept:
            entry["status"] = WaitlistStatusEnum.CONVERTED.value
        else:
            entry["status"] = WaitlistStatusEnum.CANCELLED.value

        self._store.update_entry(data.waitlist_id, entry)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\booking\booking_workflow_service.py ---
# app/services/booking/booking_workflow_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.workflows import BookingWorkflowRepository
from app.services.common import UnitOfWork


class BookingWorkflowService:
    """
    Wrapper over wf_booking table.

    Tracks current_status for a booking (pending, approved, rejected, checked_in, checked_out, etc.).
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> BookingWorkflowRepository:
        return uow.get_repo(BookingWorkflowRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def ensure_workflow(self, booking_id: UUID, initial_status: str) -> None:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_booking_id(booking_id)
            if wf is None:
                payload = {
                    "booking_id": booking_id,
                    "current_status": initial_status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
                uow.commit()

    def set_status(self, booking_id: UUID, status: str) -> None:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_booking_id(booking_id)
            if wf is None:
                payload = {
                    "booking_id": booking_id,
                    "current_status": status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
            else:
                wf.current_status = status  # type: ignore[attr-defined]
                wf.last_updated_at = self._now()  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\booking\__init__.py ---
# app/services/booking/__init__.py
"""
Booking services package.

- BookingService: core booking CRUD, list/search, status, confirmations.
- BookingCalendarService: calendar & availability views.
- BookingCancellationService: cancellation & refund calculation.
- BookingConversionService: convert bookings to Student profiles.
- BookingModificationService: date/duration/room-type modifications.
- BookingWaitlistService: waitlist creation & management (store-based).
- BookingWorkflowService: wrapper over wf_booking.
- BookingAnalyticsService: booking analytics & KPIs.
"""

from .booking_service import BookingService
from .booking_calendar_service import BookingCalendarService
from .booking_cancellation_service import BookingCancellationService
from .booking_conversion_service import BookingConversionService
from .booking_modification_service import BookingModificationService
from .booking_waitlist_service import BookingWaitlistService
from .booking_workflow_service import BookingWorkflowService
from .booking_analytics_service import BookingAnalyticsService

__all__ = [
    "BookingService",
    "BookingCalendarService",
    "BookingCancellationService",
    "BookingConversionService",
    "BookingModificationService",
    "BookingWaitlistService",
    "BookingWorkflowService",
    "BookingAnalyticsService",
]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\booking\__pycache__ =====
