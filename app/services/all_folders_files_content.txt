### Combined Content from Folder: D:\hostel-management-saas\app\services ###



# ===== Folder: D:\hostel-management-saas\app\services =====

# --- File: D:\hostel-management-saas\app\services\__init__.py ---
# app/services/__init__.py
"""
Service layer root package.

Each subpackage implements application use-cases on top of:

- SQLAlchemy models (app.models.*)
- Repositories (app.repositories.*)
- Pydantic schemas (app.schemas.*)
- Common service infrastructure (app.services.common.*)

Typical pattern for a service:

    class SomeService:
        def __init__(self, session_factory: Callable[[], Session]) -> None:
            self._session_factory = session_factory

        def some_use_case(...):
            with UnitOfWork(self._session_factory) as uow:
                repo = uow.get_repo(SomeRepository)
                ...
"""

from app.services.common import UnitOfWork, security, permissions, mapping, pagination

__all__ = [
    "UnitOfWork",
    "security",
    "permissions",
    "mapping",
    "pagination",
]


# ===== Folder: D:\hostel-management-saas\app\services\admin =====

# --- File: D:\hostel-management-saas\app\services\admin\admin_hostel_assignment_service.py ---
# app/services/admin/admin_hostel_assignment_service.py
from __future__ import annotations

from typing import Callable, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.associations import AdminHostelRepository
from app.repositories.core import AdminRepository, HostelRepository, UserRepository
from app.schemas.admin import (
    AdminHostelAssignment,
    AssignmentCreate,
    AssignmentUpdate,
    BulkAssignment,
    AssignmentList,
    HostelAdminList,
    HostelAdminItem,
)
from app.services.common import UnitOfWork, errors


class AdminHostelAssignmentService:
    """
    Manage admin ↔ hostel assignments.

    - Assign an admin to a hostel
    - Update assignment (permissions / primary flag / active flag)
    - Bulk assign an admin to multiple hostels
    - Revoke assignment
    - List assignments for an admin
    - List admins for a hostel
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_admin_hostel_repo(self, uow: UnitOfWork) -> AdminHostelRepository:
        return uow.get_repo(AdminHostelRepository)

    def _get_admin_repo(self, uow: UnitOfWork) -> AdminRepository:
        return uow.get_repo(AdminRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _build_assignment_schema(
        self,
        assoc,
        *,
        admin_name: str,
        admin_email: str,
        hostel_name: str,
        hostel_city: str,
        assigned_by: Optional[UUID] = None,
        assigned_by_name: Optional[str] = None,
    ) -> AdminHostelAssignment:
        return AdminHostelAssignment(
            id=assoc.id,
            created_at=assoc.created_at,
            updated_at=assoc.updated_at,
            admin_id=assoc.admin_id,
            admin_name=admin_name,
            admin_email=admin_email,
            hostel_id=assoc.hostel_id,
            hostel_name=hostel_name,
            hostel_city=hostel_city,
            assigned_by=assigned_by,
            assigned_by_name=assigned_by_name,
            assigned_date=assoc.assigned_date,
            permission_level=assoc.permission_level,
            permissions=assoc.permissions or {},
            is_active=assoc.is_active,
            is_primary=assoc.is_primary,
            revoked_date=assoc.revoked_date,
            revoked_by=None,
            revoke_reason=assoc.revoke_reason,
        )

    # ------------------------------------------------------------------ #
    # Create / update / revoke
    # ------------------------------------------------------------------ #
    def assign_hostel(
        self,
        data: AssignmentCreate,
        *,
        assigned_by: Optional[UUID] = None,
    ) -> AdminHostelAssignment:
        """
        Assign an admin to a hostel.

        NOTE:
        - `data.admin_id` is expected to be the core_admin.id (Admin model PK).
        """
        with UnitOfWork(self._session_factory) as uow:
            admin_hostel_repo = self._get_admin_hostel_repo(uow)
            admin_repo = self._get_admin_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            admin = admin_repo.get(data.admin_id)
            if admin is None:
                raise errors.NotFoundError(f"Admin {data.admin_id} not found")

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            # Prevent duplicate assignment (regardless of active flag)
            existing = admin_hostel_repo.get_multi(
                skip=0,
                limit=1,
                filters={"admin_id": data.admin_id, "hostel_id": data.hostel_id},
            )
            if existing:
                raise errors.ConflictError(
                    "Admin is already assigned to this hostel"
                )

            # If this is primary, clear other primary flags for this admin
            if data.is_primary:
                admin_hostel_repo.bulk_update(
                    filters={"admin_id": data.admin_id},
                    values={"is_primary": False},
                )

            payload = {
                "admin_id": data.admin_id,
                "hostel_id": data.hostel_id,
                "permission_level": data.permission_level,
                "permissions": data.permissions or {},
                "is_primary": data.is_primary,
                "is_active": True,
            }
            assoc = admin_hostel_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            admin_user = admin.user if getattr(admin, "user", None) else None
            admin_name = admin_user.full_name if admin_user else ""
            admin_email = admin_user.email if admin_user else ""

            assigned_by_name = None
            if assigned_by:
                assigned_by_user = user_repo.get(assigned_by)
                assigned_by_name = (
                    assigned_by_user.full_name if assigned_by_user else None
                )

            return self._build_assignment_schema(
                assoc,
                admin_name=admin_name,
                admin_email=admin_email,
                hostel_name=hostel.name,
                hostel_city=hostel.city,
                assigned_by=assigned_by,
                assigned_by_name=assigned_by_name,
            )

    def update_assignment(
        self,
        assignment_id: UUID,
        data: AssignmentUpdate,
    ) -> AdminHostelAssignment:
        """Update permission level / permissions / primary / active flags."""
        with UnitOfWork(self._session_factory) as uow:
            admin_hostel_repo = self._get_admin_hostel_repo(uow)
            admin_repo = self._get_admin_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            assoc = admin_hostel_repo.get(assignment_id)
            if assoc is None:
                raise errors.NotFoundError(f"Assignment {assignment_id} not found")

            if data.permission_level is not None:
                assoc.permission_level = data.permission_level  # type: ignore[attr-defined]
            if data.permissions is not None:
                assoc.permissions = data.permissions  # type: ignore[attr-defined]
            if data.is_active is not None:
                assoc.is_active = data.is_active  # type: ignore[attr-defined]

            if data.is_primary is not None:
                if data.is_primary:
                    # Clear other primary flags for this admin
                    admin_hostel_repo.bulk_update(
                        filters={"admin_id": assoc.admin_id},
                        values={"is_primary": False},
                    )
                assoc.is_primary = data.is_primary  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            admin = admin_repo.get(assoc.admin_id)
            hostel = hostel_repo.get(assoc.hostel_id)
            admin_user = admin.user if admin and getattr(admin, "user", None) else None

            return self._build_assignment_schema(
                assoc,
                admin_name=admin_user.full_name if admin_user else "",
                admin_email=admin_user.email if admin_user else "",
                hostel_name=hostel.name if hostel else "",
                hostel_city=hostel.city if hostel else "",
            )

    def revoke_assignment(
        self,
        assignment_id: UUID,
        *,
        revoke_reason: str,
        revoked_by: Optional[UUID] = None,
    ) -> AdminHostelAssignment:
        """
        Soft-revoke an assignment (set inactive, set revoked_date + reason).
        """
        from datetime import date as _date

        with UnitOfWork(self._session_factory) as uow:
            admin_hostel_repo = self._get_admin_hostel_repo(uow)
            admin_repo = self._get_admin_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            assoc = admin_hostel_repo.get(assignment_id)
            if assoc is None:
                raise errors.NotFoundError(f"Assignment {assignment_id} not found")

            assoc.is_active = False  # type: ignore[attr-defined]
            assoc.revoked_date = _date.today()  # type: ignore[attr-defined]
            assoc.revoke_reason = revoke_reason  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            admin = admin_repo.get(assoc.admin_id)
            hostel = hostel_repo.get(assoc.hostel_id)
            admin_user = admin.user if admin and getattr(admin, "user", None) else None

            return self._build_assignment_schema(
                assoc,
                admin_name=admin_user.full_name if admin_user else "",
                admin_email=admin_user.email if admin_user else "",
                hostel_name=hostel.name if hostel else "",
                hostel_city=hostel.city if hostel else "",
                assigned_by=None,
                assigned_by_name=None,
            )

    def bulk_assign(
        self,
        data: BulkAssignment,
        *,
        assigned_by: Optional[UUID] = None,
    ) -> List[AdminHostelAssignment]:
        """
        Assign the same admin to multiple hostels.
        """
        responses: List[AdminHostelAssignment] = []
        primary_hostel_id = data.primary_hostel_id

        for hid in data.hostel_ids:
            is_primary = primary_hostel_id is not None and hid == primary_hostel_id
            req = AssignmentCreate(
                admin_id=data.admin_id,
                hostel_id=hid,
                permission_level=data.permission_level,
                permissions=data.permissions,
                is_primary=is_primary,
            )
            responses.append(self.assign_hostel(req, assigned_by=assigned_by))
        return responses

    # ------------------------------------------------------------------ #
    # Listing
    # ------------------------------------------------------------------ #
    def list_assignments_for_admin(self, admin_id: UUID) -> AssignmentList:
        """
        List all hostel assignments for a given admin (core_admin.id).
        """
        with UnitOfWork(self._session_factory) as uow:
            admin_hostel_repo = self._get_admin_hostel_repo(uow)
            admin_repo = self._get_admin_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            admin = admin_repo.get(admin_id)
            if admin is None:
                raise errors.NotFoundError(f"Admin {admin_id} not found")

            admin_user = admin.user if getattr(admin, "user", None) else None
            admin_name = admin_user.full_name if admin_user else ""

            records = admin_hostel_repo.get_multi(
                skip=0,
                limit=0,  # no explicit limit
                filters={"admin_id": admin_id},
            )

            total_hostels = len(records)
            active_hostels = sum(1 for r in records if r.is_active)
            primary_hostel_id: Optional[UUID] = None
            items: List[AdminHostelAssignment] = []

            for assoc in records:
                hostel = hostel_repo.get(assoc.hostel_id)
                if assoc.is_primary:
                    primary_hostel_id = assoc.hostel_id
                items.append(
                    self._build_assignment_schema(
                        assoc,
                        admin_name=admin_name,
                        admin_email=admin_user.email if admin_user else "",
                        hostel_name=hostel.name if hostel else "",
                        hostel_city=hostel.city if hostel else "",
                    )
                )

            return AssignmentList(
                admin_id=admin_id,
                admin_name=admin_name,
                total_hostels=total_hostels,
                active_hostels=active_hostels,
                primary_hostel_id=primary_hostel_id,
                assignments=items,
            )

    def list_admins_for_hostel(self, hostel_id: UUID) -> HostelAdminList:
        """
        List all admins assigned to a hostel.
        """
        with UnitOfWork(self._session_factory) as uow:
            admin_hostel_repo = self._get_admin_hostel_repo(uow)
            admin_repo = self._get_admin_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            records = admin_hostel_repo.get_multi(
                skip=0,
                limit=0,
                filters={"hostel_id": hostel_id},
            )

            total_admins = len(records)
            admins: List[HostelAdminItem] = []

            for assoc in records:
                admin = admin_repo.get(assoc.admin_id)
                admin_user = (
                    admin.user if admin and getattr(admin, "user", None) else None
                )
                admins.append(
                    HostelAdminItem(
                        admin_id=assoc.admin_id,
                        admin_name=admin_user.full_name if admin_user else "",
                        admin_email=admin_user.email if admin_user else "",
                        permission_level=assoc.permission_level,
                        is_primary=assoc.is_primary,
                        assigned_date=assoc.assigned_date,
                        last_active=assoc.last_active,
                    )
                )

            return HostelAdminList(
                hostel_id=hostel_id,
                hostel_name=hostel.name,
                total_admins=total_admins,
                admins=admins,
            )

# --- File: D:\hostel-management-saas\app\services\admin\admin_override_service.py ---
# app/services/admin/admin_override_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.audit import AdminOverrideRepository
from app.repositories.core import HostelRepository, SupervisorRepository, UserRepository
from app.schemas.admin import (
    AdminOverrideRequest,
    OverrideLog,
)
from app.schemas.audit import (
    AdminOverrideCreate,
    AdminOverrideLogResponse,
    AdminOverrideDetail,
)
from app.services.common import UnitOfWork, errors


class AdminOverrideService:
    """
    Record and read admin overrides of supervisor decisions.

    - Persist an override into audit_admin_override table
    - Provide admin-facing log entries
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_repo(self, uow: UnitOfWork) -> AdminOverrideRepository:
        return uow.get_repo(AdminOverrideRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Create override
    # ------------------------------------------------------------------ #
    def record_override(
        self,
        *,
        admin_id: UUID,
        request: AdminOverrideRequest,
    ) -> OverrideLog:
        """
        Create an override record.

        NOTE:
        - This service only records metadata; caller is responsible for
          actually applying override effect to the target entity.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            supervisor_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)

            hostel = hostel_repo.get(request.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {request.hostel_id} not found")

            sup_user_name: Optional[str] = None
            if request.supervisor_id:
                sup = supervisor_repo.get(request.supervisor_id)
                if sup and getattr(sup, "user", None):
                    sup_user_name = sup.user.full_name

            admin_user = user_repo.get(admin_id)
            admin_name = admin_user.full_name if admin_user else ""

            payload = AdminOverrideCreate(
                admin_id=admin_id,
                supervisor_id=request.supervisor_id,
                hostel_id=request.hostel_id,
                override_type=request.override_type,
                entity_type=request.entity_type,
                entity_id=request.entity_id,
                reason=request.reason,
                original_action=request.original_action,
                override_action=request.override_action,
            )
            record = repo.create(payload.model_dump())  # type: ignore[arg-type]
            uow.commit()

            return OverrideLog(
                id=record.id,
                created_at=record.created_at,
                updated_at=record.created_at,
                admin_id=admin_id,
                admin_name=admin_name,
                supervisor_id=request.supervisor_id,
                supervisor_name=sup_user_name,
                hostel_id=request.hostel_id,
                hostel_name=hostel.name,
                override_type=request.override_type,
                entity_type=request.entity_type,
                entity_id=request.entity_id,
                reason=request.reason,
                original_action=request.original_action,
                override_action=request.override_action,
                created_at=record.created_at,
            )

    # ------------------------------------------------------------------ #
    # Read logs
    # ------------------------------------------------------------------ #
    def list_overrides_for_entity(
        self,
        *,
        entity_type: str,
        entity_id: UUID,
    ) -> List[AdminOverrideLogResponse]:
        """Low-level audit style listing for a specific entity."""
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            records = repo.list_for_entity(entity_type=entity_type, entity_id=entity_id)

            results: List[AdminOverrideLogResponse] = []
            for r in records:
                results.append(
                    AdminOverrideLogResponse(
                        id=r.id,
                        created_at=r.created_at,
                        updated_at=r.created_at,
                        admin_id=r.admin_id,
                        admin_name=None,
                        supervisor_id=r.supervisor_id,
                        supervisor_name=None,
                        hostel_id=r.hostel_id,
                        hostel_name=None,
                        override_type=r.override_type,
                        entity_type=r.entity_type,
                        entity_id=r.entity_id,
                        reason=r.reason,
                        created_at=r.created_at,
                    )
                )
            return results

    def get_override_detail(self, override_id: UUID) -> AdminOverrideDetail:
        """Fetch a single override record with full details."""
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            supervisor_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)

            r = repo.get(override_id)
            if r is None:
                raise errors.NotFoundError(f"AdminOverride {override_id} not found")

            admin_user = user_repo.get(r.admin_id)
            admin_name = admin_user.full_name if admin_user else None

            sup_user_name = None
            if r.supervisor_id:
                sup = supervisor_repo.get(r.supervisor_id)
                if sup and getattr(sup, "user", None):
                    sup_user_name = sup.user.full_name

            hostel = hostel_repo.get(r.hostel_id)

            return AdminOverrideDetail(
                id=r.id,
                created_at=r.created_at,
                updated_at=r.created_at,
                admin_id=r.admin_id,
                admin_name=admin_name,
                supervisor_id=r.supervisor_id,
                supervisor_name=sup_user_name,
                hostel_id=r.hostel_id,
                hostel_name=hostel.name if hostel else None,
                override_type=r.override_type,
                entity_type=r.entity_type,
                entity_id=r.entity_id,
                reason=r.reason,
                original_action=r.original_action,
                override_action=r.override_action,
                created_at=r.created_at,
            )

# --- File: D:\hostel-management-saas\app\services\admin\multi_hostel_dashboard_service.py ---
# app/services/admin/multi_hostel_dashboard_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.associations import AdminHostelRepository
from app.repositories.core import AdminRepository, HostelRepository, StudentRepository
from app.repositories.transactions import PaymentRepository
from app.repositories.services import ComplaintRepository, MaintenanceRepository
from app.schemas.admin import (
    MultiHostelDashboard,
    AggregatedStats,
    HostelQuickStats,
    CrossHostelComparison,
)
from app.schemas.admin.multi_hostel_dashboard import (
    TopPerformer,
    BottomPerformer,
    HostelMetricComparison,
    HostelTaskSummary,
)
from app.schemas.common.enums import (
    PaymentStatus,
    ComplaintStatus,
    Priority,
    StudentStatus,
)
from app.services.common import UnitOfWork, errors


class MultiHostelDashboardService:
    """
    Build a consolidated dashboard for admins who manage multiple hostels.

    This service uses existing core/transactions/service repositories to
    assemble a high-level view; it focuses on correctness and simplicity,
    not heavy optimization.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_admin_repo(self, uow: UnitOfWork) -> AdminRepository:
        return uow.get_repo(AdminRepository)

    def _get_admin_hostel_repo(self, uow: UnitOfWork) -> AdminHostelRepository:
        return uow.get_repo(AdminHostelRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _get_complaint_repo(self, uow: UnitOfWork) -> ComplaintRepository:
        return uow.get_repo(ComplaintRepository)

    def _get_maintenance_repo(self, uow: UnitOfWork) -> MaintenanceRepository:
        return uow.get_repo(MaintenanceRepository)

    def _today(self) -> date:
        return date.today()

    # ------------------------------------------------------------------ #
    # Main API
    # ------------------------------------------------------------------ #
    def get_dashboard_for_admin(self, admin_user_id: UUID) -> MultiHostelDashboard:
        """
        Build a multi-hostel dashboard for a given admin (by core_user.id).

        Steps:
        - Resolve Admin profile (core_admin) by user_id
        - Get all hostels assigned to that admin via AdminHostel
        - For each hostel, compute quick stats using existing repositories
        - Aggregate overall statistics and comparisons
        """
        today = self._today()

        with UnitOfWork(self._session_factory) as uow:
            admin_repo = self._get_admin_repo(uow)
            admin_hostel_repo = self._get_admin_hostel_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)
            payment_repo = self._get_payment_repo(uow)
            complaint_repo = self._get_complaint_repo(uow)
            maintenance_repo = self._get_maintenance_repo(uow)

            admin_profile = admin_repo.get_by_user_id(admin_user_id)
            if admin_profile is None:
                raise errors.NotFoundError(
                    f"No Admin profile found for user {admin_user_id}"
                )

            admin_user = (
                admin_profile.user
                if getattr(admin_profile, "user", None)
                else None
            )
            admin_name = admin_user.full_name if admin_user else ""

            # All active hostels for this admin
            hostels = admin_hostel_repo.get_hostels_for_admin(
                admin_id=admin_profile.id,
                only_active=True,
            )

            total_hostels_managed = len(hostels)
            hostel_quick_stats: List[HostelQuickStats] = []
            tasks_by_hostel: Dict[UUID, HostelTaskSummary] = {}

            # Aggregation accumulators
            agg_total_beds = 0
            agg_occupied_beds = 0
            agg_total_students = 0
            agg_active_students = 0
            agg_total_revenue_this_month = Decimal("0")
            agg_total_outstanding = Decimal("0")
            agg_total_overdue = Decimal("0")
            agg_pending_bookings = 0  # bookings service not wired; left 0
            agg_open_complaints = 0
            agg_pending_maintenance = 0
            agg_total_reviews = 0
            sum_ratings = Decimal("0")

            # Per-hostel metric caches for comparisons
            occupancy_metrics: Dict[UUID, Decimal] = {}
            revenue_metrics: Dict[UUID, Decimal] = {}
            complaint_metrics: Dict[UUID, Decimal] = {}

            for h in hostels:
                # Capacity
                total_beds = h.total_beds or 0
                occupied_beds = h.occupied_beds or 0
                available_beds = max(0, total_beds - occupied_beds)
                occupancy_pct = (
                    Decimal(str(occupied_beds / total_beds * 100))
                    if total_beds > 0
                    else Decimal("0")
                )

                # Students
                students = student_repo.list_for_hostel(h.id, status=None)
                total_students = len(students)
                active_students = sum(
                    1
                    for s in students
                    if s.student_status == StudentStatus.ACTIVE
                )

                # Payments (very simple hostel-monthly snapshot)
                payments = payment_repo.get_multi(filters={"hostel_id": h.id})
                revenue_this_month = Decimal("0")
                outstanding_amount = Decimal("0")
                overdue_amount = Decimal("0")
                overdue_payments_count = 0

                for p in payments:
                    if (
                        p.payment_status == PaymentStatus.COMPLETED
                        and p.paid_at
                    ):
                        if (
                            p.paid_at.date().year == today.year
                            and p.paid_at.date().month == today.month
                        ):
                            revenue_this_month += p.amount
                    if p.payment_status == PaymentStatus.PENDING:
                        outstanding_amount += p.amount
                        if p.due_date and p.due_date < today:
                            overdue_amount += p.amount
                            overdue_payments_count += 1

                # Complaints / maintenance
                open_complaints_list = complaint_repo.list_open_for_hostel(
                    h.id,
                    category=None,
                    priority=None,
                )
                open_complaints = len(open_complaints_list)

                open_maintenance_list = maintenance_repo.list_open_for_hostel(
                    h.id,
                    category=None,
                    priority=None,
                )
                pending_maintenance = len(open_maintenance_list)

                # Reviews from core_hostel (aggregated)
                avg_rating = Decimal(str(h.average_rating or 0.0))
                total_reviews = h.total_reviews or 0

                # Hostels' quick stats
                hostel_quick_stats.append(
                    HostelQuickStats(
                        hostel_id=h.id,
                        hostel_name=h.name,
                        hostel_city=h.city,
                        occupancy_percentage=occupancy_pct,
                        available_beds=available_beds,
                        revenue_this_month=revenue_this_month,
                        outstanding_amount=outstanding_amount,
                        pending_bookings=0,  # booking service not wired here
                        open_complaints=open_complaints,
                        pending_maintenance=pending_maintenance,
                        overdue_payments_count=overdue_payments_count,
                        status_color="green",  # simple heuristic
                        last_supervisor_activity=None,
                    )
                )

                # Hostels' task summary
                urgent_tasks = sum(
                    1
                    for c in open_complaints_list
                    if c.priority in (Priority.URGENT, Priority.CRITICAL)
                ) + sum(
                    1
                    for m in open_maintenance_list
                    if m.priority in (Priority.URGENT, Priority.CRITICAL)
                )
                high_priority_tasks = sum(
                    1 for c in open_complaints_list if c.priority == Priority.HIGH
                ) + sum(
                    1 for m in open_maintenance_list if m.priority == Priority.HIGH
                )
                medium_priority_tasks = sum(
                    1
                    for c in open_complaints_list
                    if c.priority == Priority.MEDIUM
                ) + sum(
                    1
                    for m in open_maintenance_list
                    if m.priority == Priority.MEDIUM
                )
                low_priority_tasks = sum(
                    1 for c in open_complaints_list if c.priority == Priority.LOW
                ) + sum(
                    1 for m in open_maintenance_list if m.priority == Priority.LOW
                )
                total_tasks = (
                    urgent_tasks
                    + high_priority_tasks
                    + medium_priority_tasks
                    + low_priority_tasks
                )

                tasks_by_hostel[h.id] = HostelTaskSummary(
                    hostel_id=h.id,
                    urgent_tasks=urgent_tasks,
                    high_priority_tasks=high_priority_tasks,
                    medium_priority_tasks=medium_priority_tasks,
                    low_priority_tasks=low_priority_tasks,
                    total_tasks=total_tasks,
                )

                # Aggregation
                agg_total_beds += total_beds
                agg_occupied_beds += occupied_beds
                agg_total_students += total_students
                agg_active_students += active_students
                agg_total_revenue_this_month += revenue_this_month
                agg_total_outstanding += outstanding_amount
                agg_total_overdue += overdue_amount
                agg_pending_bookings += 0
                agg_open_complaints += open_complaints
                agg_pending_maintenance += pending_maintenance
                agg_total_reviews += total_reviews
                sum_ratings += avg_rating

                occupancy_metrics[h.id] = occupancy_pct
                revenue_metrics[h.id] = revenue_this_month
                complaint_metrics[h.id] = Decimal(str(open_complaints))

            average_occupancy_percentage = (
                Decimal(str(agg_occupied_beds / agg_total_beds * 100))
                if agg_total_beds > 0
                else Decimal("0")
            )
            average_rating_across_hostels = (
                (sum_ratings / total_hostels_managed)
                if total_hostels_managed > 0
                else Decimal("0")
            )

            aggregated_stats = AggregatedStats(
                total_beds=agg_total_beds,
                total_occupied=agg_occupied_beds,
                total_available=max(0, agg_total_beds - agg_occupied_beds),
                average_occupancy_percentage=average_occupancy_percentage,
                total_students=agg_total_students,
                active_students=agg_active_students,
                total_revenue_this_month=agg_total_revenue_this_month,
                total_outstanding=agg_total_outstanding,
                total_overdue=agg_total_overdue,
                total_pending_bookings=agg_pending_bookings,
                total_confirmed_bookings=0,
                booking_conversion_rate=Decimal("0"),
                total_open_complaints=agg_open_complaints,
                total_resolved_this_month=Decimal("0"),
                average_resolution_time_hours=Decimal("0"),
                total_pending_maintenance=agg_pending_maintenance,
                total_completed_this_month=0,
                average_rating_across_hostels=average_rating_across_hostels,
                total_reviews=agg_total_reviews,
            )

            # Comparisons
            def _top_id(metric: Dict[UUID, Decimal]) -> Optional[UUID]:
                return max(metric, key=lambda k: metric[k]) if metric else None

            def _bottom_id(metric: Dict[UUID, Decimal]) -> Optional[UUID]:
                return min(metric, key=lambda k: metric[k]) if metric else None

            highest_occ_id = _top_id(occupancy_metrics)
            highest_rev_id = _top_id(revenue_metrics)
            highest_rating_id = _top_id(
                {h.id: Decimal(str(h.average_rating or 0.0)) for h in hostels}
            )
            lowest_occ_id = _bottom_id(occupancy_metrics)
            most_complaints_id = _top_id(complaint_metrics)
            # For "most overdue payments", reuse complaint_metrics as a placeholder
            most_overdue_payments_id = most_complaints_id

            def _get_hostel_name(hid: Optional[UUID]) -> str:
                if hid is None:
                    return ""
                hh = hostel_repo.get(hid)
                return hh.name if hh else ""

            top_occ = (
                TopPerformer(
                    hostel_id=highest_occ_id or UUID(int=0),
                    hostel_name=_get_hostel_name(highest_occ_id),
                    metric_value=occupancy_metrics.get(
                        highest_occ_id, Decimal("0")
                    ),
                    metric_name="occupancy_percentage",
                )
                if highest_occ_id
                else TopPerformer(
                    hostel_id=UUID(int=0),
                    hostel_name="",
                    metric_value=Decimal("0"),
                    metric_name="occupancy_percentage",
                )
            )

            top_rev = (
                TopPerformer(
                    hostel_id=highest_rev_id or UUID(int=0),
                    hostel_name=_get_hostel_name(highest_rev_id),
                    metric_value=revenue_metrics.get(
                        highest_rev_id, Decimal("0")
                    ),
                    metric_name="revenue_this_month",
                )
                if highest_rev_id
                else TopPerformer(
                    hostel_id=UUID(int=0),
                    hostel_name="",
                    metric_value=Decimal("0"),
                    metric_name="revenue_this_month",
                )
            )

            top_rating_val = Decimal("0")
            if highest_rating_id:
                h_rec = hostel_repo.get(highest_rating_id)
                if h_rec:
                    top_rating_val = Decimal(str(h_rec.average_rating or 0.0))

            top_rating = (
                TopPerformer(
                    hostel_id=highest_rating_id or UUID(int=0),
                    hostel_name=_get_hostel_name(highest_rating_id),
                    metric_value=top_rating_val,
                    metric_name="average_rating",
                )
                if highest_rating_id
                else TopPerformer(
                    hostel_id=UUID(int=0),
                    hostel_name="",
                    metric_value=Decimal("0"),
                    metric_name="average_rating",
                )
            )

            bottom_occ = (
                BottomPerformer(
                    hostel_id=lowest_occ_id or UUID(int=0),
                    hostel_name=_get_hostel_name(lowest_occ_id),
                    metric_value=occupancy_metrics.get(
                        lowest_occ_id, Decimal("0")
                    ),
                    metric_name="occupancy_percentage",
                    issue_severity="medium",
                )
                if lowest_occ_id
                else BottomPerformer(
                    hostel_id=UUID(int=0),
                    hostel_name="",
                    metric_value=Decimal("0"),
                    metric_name="occupancy_percentage",
                    issue_severity="low",
                )
            )

            bottom_complaints = (
                BottomPerformer(
                    hostel_id=most_complaints_id or UUID(int=0),
                    hostel_name=_get_hostel_name(most_complaints_id),
                    metric_value=complaint_metrics.get(
                        most_complaints_id, Decimal("0")
                    ),
                    metric_name="open_complaints",
                    issue_severity="high",
                )
                if most_complaints_id
                else BottomPerformer(
                    hostel_id=UUID(int=0),
                    hostel_name="",
                    metric_value=Decimal("0"),
                    metric_name="open_complaints",
                    issue_severity="low",
                )
            )

            bottom_overdue = (
                BottomPerformer(
                    hostel_id=most_overdue_payments_id or UUID(int=0),
                    hostel_name=_get_hostel_name(most_overdue_payments_id),
                    metric_value=complaint_metrics.get(
                        most_overdue_payments_id, Decimal("0")
                    ),
                    metric_name="overdue_payments",
                    issue_severity="high",
                )
                if most_overdue_payments_id
                else BottomPerformer(
                    hostel_id=UUID(int=0),
                    hostel_name="",
                    metric_value=Decimal("0"),
                    metric_name="overdue_payments",
                    issue_severity="low",
                )
            )

            # Simple comparison lists (occupancy, revenue, complaints)
            def _build_metric_list(
                metric: Dict[UUID, Decimal], metric_name: str
            ) -> List[HostelMetricComparison]:
                if not metric:
                    return []
                max_val = max(metric.values())
                if max_val <= 0:
                    max_val = Decimal("1")
                results: List[HostelMetricComparison] = []
                for hid, val in metric.items():
                    results.append(
                        HostelMetricComparison(
                            hostel_id=hid,
                            hostel_name=_get_hostel_name(hid),
                            metric_value=val,
                            percentage_of_best=(val / max_val * 100),
                            trend="stable",
                        )
                    )
                return results

            occupancy_comparison = _build_metric_list(
                occupancy_metrics, "occupancy_percentage"
            )
            revenue_comparison = _build_metric_list(
                revenue_metrics, "revenue_this_month"
            )
            complaint_rate_comparison = _build_metric_list(
                complaint_metrics, "open_complaints"
            )

            comparisons = CrossHostelComparison(
                highest_occupancy_hostel=top_occ,
                highest_revenue_hostel=top_rev,
                highest_rated_hostel=top_rating,
                lowest_occupancy_hostel=bottom_occ,
                most_complaints_hostel=bottom_complaints,
                most_overdue_payments_hostel=bottom_overdue,
                occupancy_comparison=occupancy_comparison,
                revenue_comparison=revenue_comparison,
                complaint_rate_comparison=complaint_rate_comparison,
            )

            # Notifications not yet wired; return zeros
            total_notifications = 0
            notifications_by_hostel: Dict[UUID, int] = {h.id: 0 for h in hostels}

            total_pending_tasks = sum(
                ts.total_tasks for ts in tasks_by_hostel.values()
            )

            return MultiHostelDashboard(
                admin_id=admin_user_id,
                admin_name=admin_name,
                total_hostels_managed=total_hostels_managed,
                aggregated_stats=aggregated_stats,
                hostel_stats=hostel_quick_stats,
                comparisons=comparisons,
                total_notifications=total_notifications,
                notifications_by_hostel=notifications_by_hostel,
                total_pending_tasks=total_pending_tasks,
                tasks_by_hostel=tasks_by_hostel,
            )

# --- File: D:\hostel-management-saas\app\services\admin\permission_matrix_service.py ---
# app/services/admin/permission_matrix_service.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Mapping, Protocol, Set

from app.schemas.admin import PermissionMatrix, RolePermissions
from app.schemas.common.enums import UserRole
from app.services.auth import RBACService


class PermissionMatrixStore(Protocol):
    """
    Abstract storage for role → permissions matrix.

    Implementations may use DB, Redis, or config files.
    """

    def load_matrix(self) -> Mapping[str, List[str]]: ...
    def save_matrix(self, matrix: Mapping[str, List[str]]) -> None: ...


@dataclass
class PermissionMatrixService:
    """
    Manage the global role-based permission matrix.

    - Load/save matrix via a store
    - Expose RolePermissions and PermissionMatrix schemas
    - Bridge into RBACService for permission checking (done elsewhere)
    """

    store: PermissionMatrixStore

    def _load_internal(self) -> Dict[UserRole, Set[str]]:
        raw = self.store.load_matrix()
        matrix: Dict[UserRole, Set[str]] = {}
        for role_str, perms in raw.items():
            try:
                role = UserRole(role_str)
            except ValueError:
                # Ignore unknown roles
                continue
            matrix[role] = set(perms or [])
        return matrix

    def _save_internal(self, matrix: Mapping[UserRole, Set[str]]) -> None:
        raw: Dict[str, List[str]] = {
            role.value: sorted(list(perms)) for role, perms in matrix.items()
        }
        self.store.save_matrix(raw)

    # ------------------------------------------------------------------ #
    # Read APIs
    # ------------------------------------------------------------------ #
    def get_permission_matrix(self) -> PermissionMatrix:
        """
        Return the current matrix as a PermissionMatrix schema.
        """
        internal = self._load_internal()
        rbac = RBACService(permission_matrix=internal)
        return rbac.get_permission_matrix()

    def get_role_permissions(self, role: UserRole) -> RolePermissions:
        """
        Get permissions for a single role.
        """
        internal = self._load_internal()
        rbac = RBACService(permission_matrix=internal)
        return rbac.get_role_permissions(role)

    # ------------------------------------------------------------------ #
    # Write APIs
    # ------------------------------------------------------------------ #
    def set_role_permissions(self, role: UserRole, permissions: List[str]) -> RolePermissions:
        """
        Overwrite the permission list for a given role.
        """
        internal = self._load_internal()
        internal[role] = set(permissions)
        self._save_internal(internal)

        rbac = RBACService(permission_matrix=internal)
        return rbac.get_role_permissions(role)

    def add_permissions(self, role: UserRole, permissions: List[str]) -> RolePermissions:
        """
        Add permissions (idempotent) for a role.
        """
        internal = self._load_internal()
        current = internal.get(role, set())
        current.update(permissions)
        internal[role] = current
        self._save_internal(internal)

        rbac = RBACService(permission_matrix=internal)
        return rbac.get_role_permissions(role)

    def remove_permissions(self, role: UserRole, permissions: List[str]) -> RolePermissions:
        """
        Remove permissions for a role (ignore missing).
        """
        internal = self._load_internal()
        current = internal.get(role, set())
        for p in permissions:
            current.discard(p)
        internal[role] = current
        self._save_internal(internal)

        rbac = RBACService(permission_matrix=internal)
        return rbac.get_role_permissions(role)

# --- File: D:\hostel-management-saas\app\services\admin\super_admin_dashboard_service.py ---
# app/services/admin/super_admin_dashboard_service.py
from __future__ import annotations

from typing import Callable, Optional

from sqlalchemy.orm import Session

from app.repositories.analytics import (
    PlatformMetricsRepository,
    GrowthMetricsRepository,
    PlatformUsageAnalyticsRepository,
)
from app.schemas.analytics import (
    PlatformMetrics as PlatformMetricsSchema,
    GrowthMetrics as GrowthMetricsSchema,
    PlatformUsageAnalytics as PlatformUsageAnalyticsSchema,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork, mapping


class SuperAdminDashboardService:
    """
    High-level platform-wide analytics for super admins.

    This service is a thin facade over the analytics.* repositories and
    corresponding Pydantic schemas.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_platform_repo(self, uow: UnitOfWork) -> PlatformMetricsRepository:
        return uow.get_repo(PlatformMetricsRepository)

    def _get_growth_repo(self, uow: UnitOfWork) -> GrowthMetricsRepository:
        return uow.get_repo(GrowthMetricsRepository)

    def _get_usage_repo(self, uow: UnitOfWork) -> PlatformUsageAnalyticsRepository:
        return uow.get_repo(PlatformUsageAnalyticsRepository)

    # ------------------------------------------------------------------ #
    # Metrics
    # ------------------------------------------------------------------ #
    def get_platform_metrics(self) -> Optional[PlatformMetricsSchema]:
        """
        Get the latest snapshot of platform-wide metrics, if any.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_platform_repo(uow)
            rec = repo.get_latest()
            if not rec:
                return None
            return mapping.to_schema(rec, PlatformMetricsSchema)

    def get_growth_metrics(self, period: DateRangeFilter) -> Optional[GrowthMetricsSchema]:
        """
        Fetch GrowthMetrics for a specific period, if present.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_growth_repo(uow)
            if not (period.start_date and period.end_date):
                return None
            rec = repo.get_for_period(
                period_start=period.start_date,
                period_end=period.end_date,
            )
            if not rec:
                return None
            return mapping.to_schema(rec, GrowthMetricsSchema)

    def get_usage_metrics(self) -> Optional[PlatformUsageAnalyticsSchema]:
        """
        Get latest platform usage & latency metrics.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_usage_repo(uow)
            rec = repo.get_latest()
            if not rec:
                return None
            return mapping.to_schema(rec, PlatformUsageAnalyticsSchema)

# --- File: D:\hostel-management-saas\app\services\admin\__init__.py ---
# app/services/admin/__init__.py
"""
Admin-facing services.

- AdminHostelAssignmentService: manage admin ↔ hostel assignments.
- AdminOverrideService: record and inspect admin overrides of supervisor actions.
- MultiHostelDashboardService: aggregated dashboard for multi-hostel admins.
- PermissionMatrixService: manage global role → permissions matrix.
- SuperAdminDashboardService: platform-wide analytics for super admins.
"""

from .admin_hostel_assignment_service import AdminHostelAssignmentService
from .admin_override_service import AdminOverrideService
from .multi_hostel_dashboard_service import MultiHostelDashboardService
from .permission_matrix_service import PermissionMatrixService
from .super_admin_dashboard_service import SuperAdminDashboardService

__all__ = [
    "AdminHostelAssignmentService",
    "AdminOverrideService",
    "MultiHostelDashboardService",
    "PermissionMatrixService",
    "SuperAdminDashboardService",
]


# ===== Folder: D:\hostel-management-saas\app\services\analytics =====

# --- File: D:\hostel-management-saas\app\services\analytics\attendance_analytics_service.py ---
# app/services/analytics/complaint_analytics_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import ComplaintRepository
from app.repositories.core import HostelRepository
from app.schemas.analytics.complaint_analytics import (
    ComplaintKPI,
    ComplaintTrend,
    ComplaintTrendPoint,
    CategoryBreakdown,
    ComplaintDashboard,
)
from app.schemas.common.enums import ComplaintStatus, Priority
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class ComplaintAnalyticsService:
    """
    Dashboard-level complaint analytics using analytics.complaint_analytics schemas.

    For more detailed per-complaint analytics, see services/complaint.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_complaint_repo(self, uow: UnitOfWork) -> ComplaintRepository:
        return uow.get_repo(ComplaintRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    # ------------------------------------------------------------------ #
    # Dashboard
    # ------------------------------------------------------------------ #
    def get_dashboard_for_hostel(
        self,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> ComplaintDashboard:
        with UnitOfWork(self._session_factory) as uow:
            complaint_repo = self._get_complaint_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            hostel_name = hostel.name if hostel else ""

            complaints = complaint_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

        # Filter by opened_at within period
        start = period.start_date or date.min
        end = period.end_date or date.max

        filtered = []
        for c in complaints:
            opened_date = c.opened_at.date() if c.opened_at else None
            if opened_date is None:
                continue
            if opened_date < start or opened_date > end:
                continue
            filtered.append(c)

        total = len(filtered)
        open_count = resolved_count = closed_count = 0

        total_resolved_hours = 0.0
        resolved_with_time = 0
        sla_breached = 0

        # Category + priority aggregation
        category_counts: Dict[str, int] = {}
        total_resolution_time_by_cat: Dict[str, float] = {}
        priority_counts: Dict[str, int] = {}

        for c in filtered:
            if c.status == ComplaintStatus.OPEN:
                open_count += 1
            if c.status == ComplaintStatus.RESOLVED:
                resolved_count += 1
            if c.status == ComplaintStatus.CLOSED:
                closed_count += 1
            if c.sla_breach:
                sla_breached += 1

            cat_key = c.category.value if hasattr(c.category, "value") else str(c.category)
            category_counts[cat_key] = category_counts.get(cat_key, 0) + 1

            if c.priority in (Priority.URGENT, Priority.CRITICAL):
                prio_key = "urgent"
            else:
                prio_key = (c.priority.value if hasattr(c.priority, "value") else str(c.priority))
            priority_counts[prio_key] = priority_counts.get(prio_key, 0) + 1

            if c.resolved_at and c.opened_at:
                diff_hours = (c.resolved_at - c.opened_at).total_seconds() / 3600.0
                total_resolved_hours += diff_hours
                resolved_with_time += 1
                total_resolution_time_by_cat[cat_key] = total_resolution_time_by_cat.get(cat_key, 0.0) + diff_hours

        avg_resolution = (
            Decimal(str(total_resolved_hours / resolved_with_time))
            if resolved_with_time > 0
            else Decimal("0")
        )

        sla_compliance_rate = (
            Decimal(str((total - sla_breached) / total * 100)) if total > 0 else Decimal("0")
        )
        escalation_rate = Decimal("0")  # not tracked in Complaint model
        reopen_rate = Decimal("0")  # also not tracked here

        kpi = ComplaintKPI(
            hostel_id=hostel_id,
            hostel_name=hostel_name,
            total_complaints=total,
            open_complaints=open_count,
            resolved_complaints=resolved_count,
            closed_complaints=closed_count,
            average_resolution_time_hours=avg_resolution,
            sla_compliance_rate=sla_compliance_rate,
            escalation_rate=escalation_rate,
            reopen_rate=reopen_rate,
        )

        # Trend
        trend_by_date: Dict[str, Dict[str, int]] = {}
        for c in filtered:
            if not c.opened_at:
                continue
            d = c.opened_at.date().isoformat()
            bucket = trend_by_date.setdefault(
                d,
                {
                    "total": 0,
                    "open": 0,
                    "resolved": 0,
                    "escalated": 0,
                    "sla_breached": 0,
                },
            )
            bucket["total"] += 1
            if c.status == ComplaintStatus.OPEN:
                bucket["open"] += 1
            if c.status == ComplaintStatus.RESOLVED:
                bucket["resolved"] += 1
            # escalate / SLA not explicitly modeled; sla_breach used
            if c.sla_breach:
                bucket["sla_breached"] += 1

        points: List[ComplaintTrendPoint] = []
        for d, vals in sorted(trend_by_date.items()):
            points.append(
                ComplaintTrendPoint(
                    date=date.fromisoformat(d),
                    total_complaints=vals["total"],
                    open_complaints=vals["open"],
                    resolved_complaints=vals["resolved"],
                    escalated=vals["escalated"],
                    sla_breached=vals["sla_breached"],
                )
            )

        trend = ComplaintTrend(
            period=period,
            points=points,
        )

        # Category breakdown
        cat_breakdown: List[CategoryBreakdown] = []
        for cat, count in category_counts.items():
            pct = Decimal(str(count / total * 100)) if total > 0 else Decimal("0")
            avg_cat_res = Decimal(
                str(total_resolution_time_by_cat.get(cat, 0.0) / count if count > 0 else 0.0)
            )
            cat_breakdown.append(
                CategoryBreakdown(
                    category=cat,
                    count=count,
                    percentage_of_total=pct,
                    average_resolution_time_hours=avg_cat_res,
                )
            )

        return ComplaintDashboard(
            hostel_id=hostel_id,
            hostel_name=hostel_name,
            period=period,
            generated_at=datetime.utcnow(),
            kpi=kpi,
            trend=trend,
            by_category=cat_breakdown,
            by_priority=priority_counts,
        )

# --- File: D:\hostel-management-saas\app\services\analytics\complaint_analytics_service.py ---
# app/services/analytics/attendance_analytics_service.py
from __future__ import annotations

from datetime import date, datetime, timedelta
from typing import Callable, List, Dict, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import AttendanceRepository
from app.schemas.attendance.attendance_report import (
    AttendanceReport,
    AttendanceSummary,
    DailyAttendanceRecord,
    TrendAnalysis,
    WeeklyAttendance,
    MonthlyComparison,
)
from app.schemas.common.enums import AttendanceStatus
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class AttendanceAnalyticsService:
    """
    Attendance analytics from svc_attendance:

    - Student-level attendance report (summary + daily + trend)
    - Can be extended later for hostel-level analytics
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> AttendanceRepository:
        return uow.get_repo(AttendanceRepository)

    def _today(self) -> date:
        return date.today()

    # ------------------------------------------------------------------ #
    # Student-level report
    # ------------------------------------------------------------------ #
    def get_student_report(
        self,
        student_id: UUID,
        period: DateRangeFilter,
    ) -> AttendanceReport:
        """
        Build an AttendanceReport for a single student over a period.

        If period.start_date / end_date are omitted, defaults to last 30 days.
        """
        # Determine period bounds
        end = period.end_date or self._today()
        start = period.start_date or (end - timedelta(days=29))
        if start > end:
            start, end = end, start

        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            records = repo.list_for_student_range(student_id, start_date=start, end_date=end)

        # Index by date for easy lookup
        by_date: Dict[date, List] = {}
        for r in records:
            by_date.setdefault(r.attendance_date, []).append(r)

        total_days = (end - start).days + 1
        total_present = total_absent = total_late = total_on_leave = total_half_day = 0

        daily_records: List[DailyAttendanceRecord] = []

        cur = start
        while cur <= end:
            recs = by_date.get(cur, [])
            # If multiple records exist for same day (edge cases), pick the one
            # with latest check_in_time; otherwise the first.
            rec = None
            if recs:
                rec = sorted(
                    recs,
                    key=lambda x: (x.check_in_time or datetime.min.time()),
                    reverse=True,
                )[0]

            if rec is None:
                # No record; treat as ABSENT (or leave as None if you prefer)
                status_str = AttendanceStatus.ABSENT.value
                status_enum = AttendanceStatus.ABSENT
                is_late = False
                late_minutes = None
                notes = None
                check_in = None
                check_out = None
            else:
                status_enum = rec.status
                status_str = status_enum.value if hasattr(status_enum, "value") else str(status_enum)
                is_late = rec.is_late
                late_minutes = rec.late_minutes
                notes = rec.notes
                check_in = rec.check_in_time
                check_out = rec.check_out_time

            if status_enum == AttendanceStatus.PRESENT:
                total_present += 1
            elif status_enum == AttendanceStatus.ABSENT:
                total_absent += 1
            elif status_enum == AttendanceStatus.LATE:
                total_late += 1
            elif status_enum == AttendanceStatus.ON_LEAVE:
                total_on_leave += 1
            elif status_enum == AttendanceStatus.HALF_DAY:
                total_half_day += 1

            daily_records.append(
                DailyAttendanceRecord(
                    date=cur,
                    day_of_week=cur.strftime("%A"),
                    status=status_str,
                    check_in_time=check_in,
                    check_out_time=check_out,
                    is_late=is_late,
                    late_minutes=late_minutes,
                    notes=notes,
                )
            )
            cur += timedelta(days=1)

        attendance_percentage = (
            (Decimal(str(total_present + total_half_day * 0.5)) / Decimal(str(total_days)) * 100)
            if total_days > 0
            else Decimal("0")
        )
        late_percentage = (
            (Decimal(str(total_late)) / Decimal(str(total_days)) * 100)
            if total_days > 0
            else Decimal("0")
        )

        # Streaks (simple forward pass using daily_records)
        current_present_streak = 0
        longest_present_streak = 0
        current_absent_streak = 0

        for day in daily_records:
            if day.status in (
                AttendanceStatus.PRESENT.value,
                AttendanceStatus.LATE.value,
                AttendanceStatus.HALF_DAY.value,
            ):
                current_present_streak += 1
                longest_present_streak = max(longest_present_streak, current_present_streak)
                current_absent_streak = 0
            elif day.status == AttendanceStatus.ABSENT.value:
                current_absent_streak += 1
                current_present_streak = 0
            else:
                current_present_streak = 0
                current_absent_streak = 0

        # Attendance status classification
        if attendance_percentage >= Decimal("90"):
            status_label = "excellent"
        elif attendance_percentage >= Decimal("75"):
            status_label = "good"
        elif attendance_percentage >= Decimal("60"):
            status_label = "warning"
        else:
            status_label = "critical"

        summary = AttendanceSummary(
            total_days=total_days,
            total_present=total_present,
            total_absent=total_absent,
            total_late=total_late,
            total_on_leave=total_on_leave,
            total_half_day=total_half_day,
            attendance_percentage=attendance_percentage,
            late_percentage=late_percentage,
            current_present_streak=current_present_streak,
            longest_present_streak=longest_present_streak,
            current_absent_streak=current_absent_streak,
            attendance_status=status_label,
            meets_minimum_requirement=attendance_percentage >= Decimal("75"),
        )

        trend = self._build_trend_analysis(start, end, daily_records)

        return AttendanceReport(
            hostel_id=None,
            student_id=student_id,
            report_period=DateRangeFilter(start_date=start, end_date=end),
            generated_at=datetime.utcnow(),
            summary=summary,
            daily_records=daily_records,
            trend_analysis=trend,
        )

    # ------------------------------------------------------------------ #
    # Trend helpers
    # ------------------------------------------------------------------ #
    def _build_trend_analysis(
        self,
        start: date,
        end: date,
        daily_records: List[DailyAttendanceRecord],
    ) -> TrendAnalysis:
        # Weekly rollup
        weekly_map: Dict[int, Dict[str, int]] = {}
        for rec in daily_records:
            week_num = rec.date.isocalendar()[1]
            bucket = weekly_map.setdefault(
                week_num,
                {"start": rec.date, "end": rec.date, "present": 0, "absent": 0, "total": 0},
            )
            bucket["start"] = min(bucket["start"], rec.date)
            bucket["end"] = max(bucket["end"], rec.date)
            bucket["total"] += 1
            if rec.status in (
                AttendanceStatus.PRESENT.value,
                AttendanceStatus.LATE.value,
                AttendanceStatus.HALF_DAY.value,
            ):
                bucket["present"] += 1
            elif rec.status == AttendanceStatus.ABSENT.value:
                bucket["absent"] += 1

        weekly_attendance: List[WeeklyAttendance] = []
        for week, vals in sorted(weekly_map.items(), key=lambda kv: kv[0]):
            total = vals["total"] or 1
            pct = (Decimal(str(vals["present"])) / Decimal(str(total)) * 100)
            weekly_attendance.append(
                WeeklyAttendance(
                    week_number=week,
                    week_start_date=vals["start"],
                    week_end_date=vals["end"],
                    total_days=vals["total"],
                    present_days=vals["present"],
                    absent_days=vals["absent"],
                    attendance_percentage=pct,
                )
            )

        # Monthly comparison (simple: group by YYYY-MM)
        monthly_map: Dict[str, Dict[str, int]] = {}
        for rec in daily_records:
            key = rec.date.strftime("%Y-%m")
            bucket = monthly_map.setdefault(key, {"present": 0, "absent": 0, "total": 0})
            bucket["total"] += 1
            if rec.status in (
                AttendanceStatus.PRESENT.value,
                AttendanceStatus.LATE.value,
                AttendanceStatus.HALF_DAY.value,
            ):
                bucket["present"] += 1
            elif rec.status == AttendanceStatus.ABSENT.value:
                bucket["absent"] += 1

        monthly_comparison: List[MonthlyComparison] = []
        for month, vals in sorted(monthly_map.items()):
            total = vals["total"] or 1
            pct = Decimal(str(vals["present"])) / Decimal(str(total)) * 100
            monthly_comparison.append(
                MonthlyComparison(
                    month=month,
                    attendance_percentage=pct,
                    total_present=vals["present"],
                    total_absent=vals["absent"],
                )
            )

        # Simple trend direction based on first vs last month
        trend_direction = "stable"
        improvement_rate: Optional[Decimal] = None
        if len(monthly_comparison) >= 2:
            first = monthly_comparison[0].attendance_percentage
            last = monthly_comparison[-1].attendance_percentage
            if first > 0:
                change = (last - first) / first * 100
                improvement_rate = change
                if change > Decimal("5"):
                    trend_direction = "attendance_improving"
                elif change < Decimal("-5"):
                    trend_direction = "attendance_declining"
                else:
                    trend_direction = "attendance_stable"
            else:
                trend_direction = "attendance_stable"

        # Map into expected pattern (improving|declining|stable)
        mapped_trend = "stable"
        if trend_direction == "attendance_improving":
            mapped_trend = "improving"
        elif trend_direction == "attendance_declining":
            mapped_trend = "declining"

        return TrendAnalysis(
            period_start=start,
            period_end=end,
            weekly_attendance=weekly_attendance,
            monthly_comparison=monthly_comparison or None,
            most_absent_day=None,
            attendance_improving=(mapped_trend == "improving"),
            improvement_rate=improvement_rate,
        )

# --- File: D:\hostel-management-saas\app\services\analytics\custom_report_service.py ---
# app/services/analytics/custom_report_service.py
from __future__ import annotations

from datetime import date, datetime
from typing import Any, Callable, Dict, Iterable, List, Optional, Tuple, Type
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.base import BaseRepository
from app.repositories.transactions import PaymentRepository, BookingRepository
from app.repositories.services import ComplaintRepository, AttendanceRepository
from app.schemas.analytics.custom_reports import (
    CustomReportRequest,
    CustomReportDefinition,
    CustomReportResult,
    CustomReportField,
    CustomReportFilter,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class CustomReportService:
    """
    Very lightweight custom report builder.

    Supported modules (initially):
    - 'payments'  -> txn_payment via PaymentRepository
    - 'bookings'  -> txn_booking via BookingRepository
    - 'complaints'-> svc_complaint via ComplaintRepository
    - 'attendance'-> svc_attendance via AttendanceRepository

    NOTE:
    - This is intentionally conservative: it loads rows via repositories and
      applies filters/aggregations in Python. For large datasets, consider a
      dedicated reporting DB / ETL.
    """

    _MODULE_REPOS: Dict[str, Type[BaseRepository]] = {
        "payments": PaymentRepository,
        "bookings": BookingRepository,
        "complaints": ComplaintRepository,
        "attendance": AttendanceRepository,
    }

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def run_report(self, req: CustomReportRequest) -> CustomReportResult:
        """
        Execute a custom report request and return tabular data + summary.
        """
        module = req.module.lower()
        if module not in self._MODULE_REPOS:
            raise ValueError(f"Unsupported module {module!r} for custom reports")

        with UnitOfWork(self._session_factory) as uow:
            repo_cls = self._MODULE_REPOS[module]
            repo: BaseRepository = uow.get_repo(repo_cls)  # type: ignore[type-arg]

            # For simplicity, fetch all rows that match rough period filters via repo,
            # then refine in Python.
            base_filters: Dict[str, Any] = {}
            objs = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=base_filters or None,
            )

        # Apply time period filter (if any) on created_at where available
        objs = list(self._apply_period_filter(objs, req.period))

        # Apply custom filters in Python
        objs = list(self._apply_filters(objs, req.filters or []))

        # Map to rows (dict) according to fields
        rows: List[Dict[str, Any]] = self._build_rows(objs, req.fields)

        # Perform simple aggregations for summary
        summary = self._build_summary(rows, req.fields)

        return CustomReportResult(
            report_id=None,
            report_name=req.report_name,
            generated_at=datetime.utcnow(),
            rows=rows,
            total_rows=len(rows),
            summary=summary if req.include_summary else None,
            charts=None,  # Can be filled by higher-level code if needed
        )

    # ------------------------------------------------------------------ #
    # Internal helpers
    # ------------------------------------------------------------------ #
    def _apply_period_filter(
        self,
        objs: Iterable[Any],
        period: Optional[DateRangeFilter],
    ) -> Iterable[Any]:
        if not period or (not period.start_date and not period.end_date):
            return objs

        start = period.start_date or date.min
        end = period.end_date or date.max

        for obj in objs:
            created = getattr(obj, "created_at", None)
            if not created or not isinstance(created, datetime):
                yield obj  # if no created_at, keep it
                continue
            d = created.date()
            if d < start or d > end:
                continue
            yield obj

    def _apply_filters(
        self,
        objs: Iterable[Any],
        filters: List[CustomReportFilter],
    ) -> Iterable[Any]:
        def matches(obj: Any, f: CustomReportFilter) -> bool:
            val = getattr(obj, f.field_name, None)
            op = f.operator

            if op == "eq":
                return val == f.value
            if op == "ne":
                return val != f.value
            if op == "gt":
                return val is not None and val > f.value
            if op == "lt":
                return val is not None and val < f.value
            if op == "gte":
                return val is not None and val >= f.value
            if op == "lte":
                return val is not None and val <= f.value
            if op == "in":
                return isinstance(f.value, (list, tuple, set)) and val in f.value
            if op == "contains":
                return isinstance(val, str) and isinstance(f.value, str) and f.value.lower() in val.lower()
            if op == "between":
                if f.value is None or f.value_to is None:
                    return True
                return val is not None and f.value <= val <= f.value_to
            # Fallback: no-op
            return True

        for obj in objs:
            ok = True
            for f in filters:
                if not matches(obj, f):
                    ok = False
                    break
            if ok:
                yield obj

    def _build_rows(
        self,
        objs: Iterable[Any],
        fields: List[CustomReportField],
    ) -> List[Dict[str, Any]]:
        rows: List[Dict[str, Any]] = []
        for obj in objs:
            row: Dict[str, Any] = {}
            for field in fields:
                raw_val = getattr(obj, field.field_name, None)
                key = field.display_label or field.field_name
                row[key] = raw_val
            rows.append(row)
        return rows

    def _build_summary(
        self,
        rows: List[Dict[str, Any]],
        fields: List[CustomReportField],
    ) -> Dict[str, Any]:
        """
        Perform basic aggregations for fields that requested them.
        Supported aggregations: sum, avg, min, max, count.
        """
        summary: Dict[str, Any] = {}
        if not rows:
            return summary

        for f in fields:
            if not f.aggregation or f.aggregation == "none":
                continue
            key = f.display_label or f.field_name
            values = [r.get(key) for r in rows if isinstance(r.get(key), (int, float, Decimal))]
            if not values:
                continue

            agg_name = f.aggregation.lower()
            if agg_name == "sum":
                summary[key + "_sum"] = sum(values)
            elif agg_name == "avg":
                summary[key + "_avg"] = sum(values) / len(values)
            elif agg_name == "min":
                summary[key + "_min"] = min(values)
            elif agg_name == "max":
                summary[key + "_max"] = max(values)
            elif agg_name == "count":
                summary[key + "_count"] = len(values)

        return summary

# --- File: D:\hostel-management-saas\app\services\analytics\dashboard_analytics_service.py ---
# app/services/analytics/dashboard_analytics_service.py
from __future__ import annotations

from datetime import datetime
from typing import Callable, List, Optional, Dict
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.analytics import DashboardMetricsRepository
from app.schemas.analytics.dashboard_analytics import (
    DashboardMetrics as DashboardMetricsSchema,
    QuickStats,
    KPIResponse,
    TimeseriesPoint,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class DashboardAnalyticsService:
    """
    DashboardMetrics service backed by analytics_dashboard_metrics table.

    - Fetch dashboard metrics for a scope (hostel|platform|admin)
    - If no exact period match, fall back to latest snapshot for scope
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> DashboardMetricsRepository:
        return uow.get_repo(DashboardMetricsRepository)

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_dashboard_metrics(
        self,
        *,
        scope_type: str,
        scope_id: Optional[UUID],
        period: Optional[DateRangeFilter] = None,
    ) -> Optional[DashboardMetricsSchema]:
        """
        Fetch DashboardMetrics for given scope+period, or latest if period not supplied.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            rec = None
            if period and period.start_date and period.end_date:
                rec = repo.get_for_scope_and_period(
                    scope_type=scope_type,
                    scope_id=scope_id,
                    period_start=period.start_date,
                    period_end=period.end_date,
                )
            if rec is None:
                rec = repo.get_latest_for_scope(scope_type=scope_type, scope_id=scope_id)
            if rec is None:
                return None

        # Map DB row -> QuickStats
        quick = QuickStats(
            total_hostels=rec.total_hostels,
            active_hostels=rec.active_hostels,
            total_students=rec.total_students,
            active_students=rec.active_students,
            total_visitors=rec.total_visitors,
            todays_check_ins=rec.todays_check_ins,
            todays_check_outs=rec.todays_check_outs,
            open_complaints=rec.open_complaints,
            pending_maintenance=rec.pending_maintenance,
            todays_revenue=rec.todays_revenue,
            monthly_revenue=rec.monthly_revenue,
            outstanding_payments=rec.outstanding_payments,
        )

        # Simple example KPIs: you can extend this with more meaningful KPIs
        kpis: List[KPIResponse] = [
            KPIResponse(
                name="Monthly Revenue",
                value=rec.monthly_revenue,
                unit="INR",
                trend_direction=None,
                trend_percentage=None,
                target_value=None,
                good_when="higher_is_better",
            ),
            KPIResponse(
                name="Occupancy (approx)",
                value=rec.active_students,
                unit="students",
                trend_direction=None,
                trend_percentage=None,
                target_value=None,
                good_when="higher_is_better",
            ),
        ]

        # No timeseries is stored in this snapshot table; return empty lists
        period_filter = DateRangeFilter(
            start_date=rec.period_start,
            end_date=rec.period_end,
        )

        return DashboardMetricsSchema(
            scope_type=scope_type,
            scope_id=scope_id,
            period=period_filter,
            generated_at=rec.generated_at,
            kpis=kpis,
            quick_stats=quick,
            revenue_timeseries=[],
            occupancy_timeseries=[],
            booking_timeseries=[],
            complaint_timeseries=[],
        )

# --- File: D:\hostel-management-saas\app\services\analytics\financial_analytics_service.py ---
# app/services/analytics/financial_analytics_service.py
from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import PaymentRepository
from app.repositories.services import MaintenanceRepository
from app.schemas.analytics.financial_analytics import (
    FinancialReport,
    RevenueBreakdown,
    ExpenseBreakdown,
    ProfitAndLossReport,
    CashflowSummary,
    CashflowPoint,
)
from app.schemas.common.enums import PaymentStatus, PaymentType
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class FinancialAnalyticsService:
    """
    Basic financial analytics using txn_payment and svc_maintenance:

    - Revenue breakdown by type/payment_type
    - Maintenance expenses as primary expense category
    - Simple P&L and cashflow summary
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _get_maintenance_repo(self, uow: UnitOfWork) -> MaintenanceRepository:
        return uow.get_repo(MaintenanceRepository)

    def _today(self) -> date:
        return date.today()

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_financial_report(
        self,
        *,
        scope_type: str,          # 'hostel' or 'platform'
        scope_id: Optional[UUID],
        period: DateRangeFilter,
    ) -> FinancialReport:
        """
        Compute a FinancialReport for a hostel or platform over a period.

        For 'platform' scope, aggregates across all hostels.
        """
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            maint_repo = self._get_maintenance_repo(uow)

            pay_filters: Dict[str, object] = {}
            maint_filters: Dict[str, object] = {}
            if scope_type == "hostel" and scope_id:
                pay_filters["hostel_id"] = scope_id
                maint_filters["hostel_id"] = scope_id

            payments = pay_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=pay_filters or None,
            )
            maints = maint_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=maint_filters or None,
            )

        start = period.start_date or date.min
        end = period.end_date or date.max

        # Revenue: COMPLETED payments with paid_at in [start,end]
        payments_in_period = []
        for p in payments:
            if p.payment_status != PaymentStatus.COMPLETED or not p.paid_at:
                continue
            d = p.paid_at.date()
            if d < start or d > end:
                continue
            payments_in_period.append(p)

        # Revenue breakdown by PaymentType
        booking_revenue = rent_revenue = mess_revenue = other_revenue = Decimal("0")
        revenue_by_type: Dict[str, Decimal] = {}

        for p in payments_in_period:
            if p.payment_type == PaymentType.BOOKING_ADVANCE:
                booking_revenue += p.amount
            elif p.payment_type == PaymentType.RENT:
                rent_revenue += p.amount
            elif p.payment_type == PaymentType.MESS_CHARGES:
                mess_revenue += p.amount
            else:
                other_revenue += p.amount

            key = p.payment_type.value if hasattr(p.payment_type, "value") else str(p.payment_type)
            revenue_by_type[key] = revenue_by_type.get(key, Decimal("0")) + p.amount

        total_revenue = booking_revenue + rent_revenue + mess_revenue + other_revenue

        revenue_breakdown = RevenueBreakdown(
            total_revenue=total_revenue,
            booking_revenue=booking_revenue,
            rent_revenue=rent_revenue,
            mess_revenue=mess_revenue,
            other_revenue=other_revenue,
            revenue_by_hostel={},  # not broken down here
            revenue_by_payment_type={k: v for k, v in revenue_by_type.items()},
        )

        # Expenses from Maintenance.actual_cost
        expenses_in_period = []
        for m in maints:
            if not m.actual_completion_date or not m.actual_cost:
                continue
            d = m.actual_completion_date
            if d < start or d > end:
                continue
            expenses_in_period.append(m)

        maintenance_expenses = Decimal("0")
        expenses_by_category: Dict[str, Decimal] = {}
        for m in expenses_in_period:
            maintenance_expenses += m.actual_cost or Decimal("0")
            cat = m.category.value if hasattr(m.category, "value") else str(m.category)
            expenses_by_category[cat] = expenses_by_category.get(cat, Decimal("0")) + (m.actual_cost or Decimal("0"))

        total_expenses = maintenance_expenses  # others set to 0 here

        expense_breakdown = ExpenseBreakdown(
            total_expenses=total_expenses,
            maintenance_expenses=maintenance_expenses,
            staff_expenses=Decimal("0"),
            utility_expenses=Decimal("0"),
            other_expenses=Decimal("0"),
            expenses_by_hostel={},     # not broken down
            expenses_by_category=expenses_by_category,
        )

        gross_profit = total_revenue - total_expenses
        net_profit = gross_profit  # no tax/other adjustments modeled
        profit_margin = (
            (net_profit / total_revenue * 100) if total_revenue > 0 else Decimal("0")
        )

        pnl = ProfitAndLossReport(
            scope_type=scope_type,
            scope_id=scope_id,
            period=period,
            generated_at=datetime.utcnow(),
            revenue=revenue_breakdown,
            expenses=expense_breakdown,
            gross_profit=gross_profit,
            net_profit=net_profit,
            profit_margin_percentage=profit_margin,
        )

        # Cashflow summary: simple inflow(outflow) per day
        inflows = total_revenue
        outflows = total_expenses
        opening_balance = Decimal("0")
        closing_balance = opening_balance + inflows - outflows

        # Daily timeseries
        daily_in: Dict[date, Decimal] = {}
        daily_out: Dict[date, Decimal] = {}

        for p in payments_in_period:
            d = p.paid_at.date()
            daily_in[d] = daily_in.get(d, Decimal("0")) + p.amount

        for m in expenses_in_period:
            d = m.actual_completion_date
            daily_out[d] = daily_out.get(d, Decimal("0")) + (m.actual_cost or Decimal("0"))

        cashflow_points: List[CashflowPoint] = []
        cur = start
        while cur <= end:
            inflow = daily_in.get(cur, Decimal("0"))
            outflow = daily_out.get(cur, Decimal("0"))
            cashflow_points.append(
                CashflowPoint(
                    date=cur,
                    inflow=inflow,
                    outflow=outflow,
                    net_flow=inflow - outflow,
                )
            )
            cur += timedelta(days=1)

        cashflow = CashflowSummary(
            scope_type=scope_type,
            scope_id=scope_id,
            period=period,
            generated_at=datetime.utcnow(),
            opening_balance=opening_balance,
            closing_balance=closing_balance,
            inflows=inflows,
            outflows=outflows,
            inflow_breakdown={"payments": inflows},
            outflow_breakdown={"maintenance": outflows},
            cashflow_timeseries=cashflow_points,
        )

        # Ratios (very basic)
        # For collection_rate we compare completed vs all payments in period (created_at)
        # Re-load payments for the period on created_at
        total_billed = Decimal("0")
        total_billed_completed = Decimal("0")
        for p in payments:
            d = p.created_at.date()
            if d < start or d > end:
                continue
            total_billed += p.amount
            if p.payment_status == PaymentStatus.COMPLETED:
                total_billed_completed += p.amount

        collection_rate = (
            (total_billed_completed / total_billed * 100) if total_billed > 0 else Decimal("0")
        )
        overdue_ratio = Decimal("0")  # could be computed from pending+due_date < today

        financial_report = FinancialReport(
            scope_type=scope_type,
            scope_id=scope_id,
            period=period,
            generated_at=datetime.utcnow(),
            pnl_report=pnl,
            cashflow=cashflow,
            collection_rate=collection_rate,
            overdue_ratio=overdue_ratio,
            avg_revenue_per_student=Decimal("0"),
            avg_revenue_per_bed=Decimal("0"),
        )
        return financial_report

# --- File: D:\hostel-management-saas\app\services\analytics\occupancy_analytics_service.py ---
# app/services/analytics/occupancy_analytics_service.py
from __future__ import annotations

from datetime import date, datetime, timedelta
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository, RoomRepository, StudentRepository
from app.schemas.analytics.occupancy_analytics import (
    OccupancyReport,
    OccupancyKPI,
    OccupancyTrendPoint,
    ForecastData,
    ForecastPoint,
    OccupancyByRoomType,
)
from app.schemas.common.enums import RoomType
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class OccupancyAnalyticsService:
    """
    Occupancy analytics based on core_hostel, core_room, core_student:

    - Daily occupancy trend for a hostel
    - Breakdown by room type
    - Simple KPI metrics
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_occupancy_report(
        self,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> OccupancyReport:
        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            room_repo = self._get_room_repo(uow)
            student_repo = self._get_student_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise ValueError(f"Hostel {hostel_id} not found")

            rooms = room_repo.list_for_hostel(hostel_id=hostel_id, only_available=False, room_type=None)
            students = student_repo.list_for_hostel(hostel_id, status=None)

        start = period.start_date or date.today()
        end = period.end_date or start

        # Current capacity & occupancy from hostel snapshot
        total_beds = hostel.total_beds or 0
        occupied_beds = hostel.occupied_beds or 0
        available_beds = max(0, total_beds - occupied_beds)
        current_occ_pct = (
            Decimal(str(occupied_beds / total_beds * 100)) if total_beds > 0 else Decimal("0")
        )

        # Daily trend: compute occupancy from student stay dates
        daily_trend: List[OccupancyTrendPoint] = []
        agg_occupied = 0
        peak_occ_pct = Decimal("0")
        low_occ_pct = None

        cur = start
        while cur <= end:
            occ = self._occupied_beds_for_day(cur, students)
            pct = Decimal(str(occ / total_beds * 100)) if total_beds > 0 else Decimal("0")

            daily_trend.append(
                OccupancyTrendPoint(
                    date=cur,
                    occupancy_percentage=pct,
                    occupied_beds=occ,
                    total_beds=total_beds,
                )
            )
            agg_occupied += occ
            peak_occ_pct = max(peak_occ_pct, pct)
            if low_occ_pct is None or pct < low_occ_pct:
                low_occ_pct = pct
            cur += timedelta(days=1)

        days = (end - start).days + 1
        avg_occ_pct = (
            Decimal(str(agg_occupied / days / total_beds * 100)) if days > 0 and total_beds > 0 else Decimal("0")
        )
        low_occ_pct = low_occ_pct or Decimal("0")

        kpi = OccupancyKPI(
            hostel_id=hostel_id,
            hostel_name=hostel.name,
            current_occupancy_percentage=current_occ_pct,
            average_occupancy_percentage=avg_occ_pct,
            peak_occupancy_percentage=peak_occ_pct,
            low_occupancy_percentage=low_occ_pct,
            total_beds=total_beds,
            occupied_beds=occupied_beds,
            available_beds=available_beds,
        )

        # By room type
        by_room_type: List[OccupancyByRoomType] = []
        room_type_totals: Dict[RoomType, int] = {}
        room_type_occupied: Dict[RoomType, int] = {}

        # Count beds per room type from Room.total_beds
        for r in rooms:
            rt = r.room_type
            room_type_totals[rt] = room_type_totals.get(rt, 0) + (r.total_beds or 0)

        # Count occupied per room type from current students
        room_id_to_type: Dict[UUID, RoomType] = {r.id: r.room_type for r in rooms}
        for s in students:
            if s.room_id and s.room_id in room_id_to_type:
                rt = room_id_to_type[s.room_id]
                room_type_occupied[rt] = room_type_occupied.get(rt, 0) + 1

        for rt, total_rt_beds in room_type_totals.items():
            occ_rt = room_type_occupied.get(rt, 0)
            pct_rt = (
                Decimal(str(occ_rt / total_rt_beds * 100)) if total_rt_beds > 0 else Decimal("0")
            )
            by_room_type.append(
                OccupancyByRoomType(
                    room_type=rt.value if hasattr(rt, "value") else str(rt),
                    total_beds=total_rt_beds,
                    occupied_beds=occ_rt,
                    occupancy_percentage=pct_rt,
                )
            )

        # By floor is optional; leaving empty dict for now
        report = OccupancyReport(
            hostel_id=hostel_id,
            hostel_name=hostel.name,
            period=DateRangeFilter(start_date=start, end_date=end),
            generated_at=datetime.utcnow(),
            kpi=kpi,
            daily_trend=daily_trend,
            by_room_type=by_room_type,
            by_floor={},
            forecast=None,  # can be added later
        )
        return report

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _occupied_beds_for_day(self, day: date, students: List[Any]) -> int:  # type: ignore[valid-type]
        """
        Count students whose stay includes the given day.
        """
        count = 0
        for s in students:
            # check_in_date <= day <= (actual_checkout_date or expected_checkout_date or "forever")
            cin = s.check_in_date
            if not cin:
                continue
            if cin > day:
                continue
            cout = s.actual_checkout_date or s.expected_checkout_date
            if cout and day > cout:
                continue
            count += 1
        return count

# --- File: D:\hostel-management-saas\app\services\analytics\platform_analytics_service.py ---
# app/services/analytics/platform_analytics_service.py
from __future__ import annotations

from typing import Callable, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.analytics import (
    PlatformMetricsRepository,
    GrowthMetricsRepository,
    PlatformUsageAnalyticsRepository,
)
from app.schemas.analytics.platform_analytics import (
    PlatformMetrics as PlatformMetricsSchema,
    GrowthMetrics as GrowthMetricsSchema,
    PlatformUsageAnalytics as PlatformUsageAnalyticsSchema,
    MonthlyMetric,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class PlatformAnalyticsService:
    """
    Platform-wide analytics facade.

    Wraps analytics_platform_metrics, analytics_growth_metrics,
    and analytics_platform_usage tables into the corresponding schemas.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_platform_repo(self, uow: UnitOfWork) -> PlatformMetricsRepository:
        return uow.get_repo(PlatformMetricsRepository)

    def _get_growth_repo(self, uow: UnitOfWork) -> GrowthMetricsRepository:
        return uow.get_repo(GrowthMetricsRepository)

    def _get_usage_repo(self, uow: UnitOfWork) -> PlatformUsageAnalyticsRepository:
        return uow.get_repo(PlatformUsageAnalyticsRepository)

    # ------------------------------------------------------------------ #
    # Platform metrics
    # ------------------------------------------------------------------ #
    def get_latest_platform_metrics(self) -> Optional[PlatformMetricsSchema]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_platform_repo(uow)
            rec = repo.get_latest()
            if not rec:
                return None

        return PlatformMetricsSchema(
            period=DateRangeFilter(start_date=rec.period_start, end_date=rec.period_end),
            generated_at=rec.generated_at,
            total_hostels=rec.total_hostels,
            active_hostels=rec.active_hostels,
            hostels_on_trial=rec.hostels_on_trial,
            total_users=rec.total_users,
            total_students=rec.total_students,
            total_supervisors=rec.total_supervisors,
            total_admins=rec.total_admins,
            total_visitors=rec.total_visitors,
            avg_daily_active_users=rec.avg_daily_active_users,
            peak_concurrent_sessions=rec.peak_concurrent_sessions,
        )

    def get_growth_metrics(
        self,
        period: DateRangeFilter,
    ) -> Optional[GrowthMetricsSchema]:
        if not (period.start_date and period.end_date):
            return None

        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_growth_repo(uow)
            rec = repo.get_for_period(
                period_start=period.start_date,
                period_end=period.end_date,
            )
            if not rec:
                return None

        # monthly_* lists are not stored in the model; keep them empty for now.
        return GrowthMetricsSchema(
            period=period,
            new_hostels=rec.new_hostels,
            churned_hostels=rec.churned_hostels,
            net_hostel_growth=rec.net_hostel_growth,
            total_revenue=rec.total_revenue,
            revenue_growth_rate=rec.revenue_growth_rate,
            new_users=rec.new_users,
            user_growth_rate=rec.user_growth_rate,
            monthly_revenue=[],
            monthly_new_hostels=[],
            monthly_new_users=[],
        )

    def get_latest_usage_metrics(self) -> Optional[PlatformUsageAnalyticsSchema]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_usage_repo(uow)
            rec = repo.get_latest()
            if not rec:
                return None

        return PlatformUsageAnalyticsSchema(
            period=DateRangeFilter(start_date=rec.period_start, end_date=rec.period_end),
            generated_at=rec.generated_at,
            total_requests=rec.total_requests,
            avg_requests_per_minute=rec.avg_requests_per_minute,
            api_error_rate=rec.api_error_rate,
            requests_by_module={},
            avg_response_time_ms=rec.avg_response_time_ms,
            p95_response_time_ms=rec.p95_response_time_ms,
            p99_response_time_ms=rec.p99_response_time_ms,
            avg_cpu_usage_percent=None,
            avg_memory_usage_percent=None,
        )

# --- File: D:\hostel-management-saas\app\services\analytics\supervisor_analytics_service.py ---
# app/services/analytics/supervisor_analytics_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.analytics import SupervisorPerformanceMetricsRepository
from app.repositories.core import HostelRepository, SupervisorRepository
from app.schemas.analytics.supervisor_analytics import (
    SupervisorKPI,
    SupervisorDashboardAnalytics,
    SupervisorTrendPoint,
    SupervisorComparison,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class SupervisorAnalyticsService:
    """
    Supervisor performance analytics based on analytics_supervisor_performance.

    - Per-supervisor KPI & dashboard
    - Comparison between supervisors in a hostel or platform-wide
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> SupervisorPerformanceMetricsRepository:
        return uow.get_repo(SupervisorPerformanceMetricsRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    # ------------------------------------------------------------------ #
    # Individual dashboard
    # ------------------------------------------------------------------ #
    def get_dashboard(
        self,
        *,
        supervisor_id: UUID,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> Optional[SupervisorDashboardAnalytics]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            metrics = repo.get_for_supervisor_period(
                supervisor_id=supervisor_id,
                hostel_id=hostel_id,
                period_start=period.start_date,
                period_end=period.end_date,
            )
            if not metrics:
                return None

            sup = sup_repo.get(supervisor_id)
            hostel = hostel_repo.get(hostel_id)
            sup_name = sup.user.full_name if sup and getattr(sup, "user", None) else ""
            hostel_name = hostel.name if hostel else ""

            kpi = self._to_kpi(metrics, supervisor_name=sup_name, hostel_name=hostel_name, period=period)

            # Trend: for now, we only return a single point for this period.
            trend = [
                SupervisorTrendPoint(
                    period_label=f"{period.start_date}–{period.end_date}",
                    complaints_resolved=metrics.complaints_resolved,
                    maintenance_completed=metrics.maintenance_requests_completed,
                    performance_score=metrics.overall_performance_score,
                )
            ]

            return SupervisorDashboardAnalytics(
                supervisor_id=supervisor_id,
                supervisor_name=sup_name,
                hostel_id=hostel_id,
                hostel_name=hostel_name,
                period=period,
                generated_at=datetime.utcnow(),
                kpi=kpi,
                trend=trend,
                complaints_by_category={},
                maintenance_by_category={},
            )

    # ------------------------------------------------------------------ #
    # Comparison
    # ------------------------------------------------------------------ #
    def get_comparison(
        self,
        *,
        scope_type: str,    # 'hostel' or 'platform'
        hostel_id: Optional[UUID],
        period: DateRangeFilter,
    ) -> SupervisorComparison:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            # Fetch all metrics for given period & scope
            filters: Dict[str, object] = {}
            if hostel_id:
                filters["hostel_id"] = hostel_id
            # BaseRepository.get_multi will apply equality filters
            metrics_list = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

            # Filter by period_start/end in Python to be safe
            filtered = [
                m
                for m in metrics_list
                if (not period.start_date or m.period_start >= period.start_date)
                and (not period.end_date or m.period_end <= period.end_date)
            ]

            kpis: List[SupervisorKPI] = []
            score_by_supervisor: Dict[UUID, Decimal] = {}
            speed_by_supervisor: Dict[UUID, Decimal] = {}

            for m in filtered:
                sup = sup_repo.get(m.supervisor_id)
                hostel = hostel_repo.get(m.hostel_id)
                sup_name = sup.user.full_name if sup and getattr(sup, "user", None) else ""
                hostel_name = hostel.name if hostel else ""

                kpi = self._to_kpi(m, supervisor_name=sup_name, hostel_name=hostel_name, period=period)
                kpis.append(kpi)
                score_by_supervisor[m.supervisor_id] = kpi.overall_performance_score
                speed_by_supervisor[m.supervisor_id] = kpi.avg_complaint_resolution_time_hours

            # Rankings
            ranked_by_performance = sorted(
                score_by_supervisor, key=lambda sid: score_by_supervisor[sid], reverse=True
            )
            ranked_by_resolution_speed = sorted(
                speed_by_supervisor, key=lambda sid: speed_by_supervisor[sid]
            )
            ranked_by_feedback_score: List[UUID] = []  # feedback not yet wired

            return SupervisorComparison(
                scope_type=scope_type,
                hostel_id=hostel_id,
                period=period,
                generated_at=datetime.utcnow(),
                supervisors=kpis,
                ranked_by_performance=ranked_by_performance,
                ranked_by_resolution_speed=ranked_by_resolution_speed,
                ranked_by_feedback_score=ranked_by_feedback_score,
            )

    # ------------------------------------------------------------------ #
    # Mapping helper
    # ------------------------------------------------------------------ #
    def _to_kpi(
        self,
        m,
        *,
        supervisor_name: str,
        hostel_name: str,
        period: DateRangeFilter,
    ) -> SupervisorKPI:
        return SupervisorKPI(
            supervisor_id=m.supervisor_id,
            supervisor_name=supervisor_name,
            hostel_id=m.hostel_id,
            hostel_name=hostel_name,
            period=period,
            complaints_assigned=m.complaints_assigned,
            complaints_resolved=m.complaints_resolved,
            maintenance_requests_created=m.maintenance_requests_created,
            maintenance_requests_completed=m.maintenance_requests_completed,
            attendance_records_marked=m.attendance_records_marked,
            avg_complaint_resolution_time_hours=m.avg_complaint_resolution_time_hours,
            avg_maintenance_completion_time_hours=m.avg_maintenance_completion_time_hours,
            complaint_sla_compliance_rate=Decimal("0"),
            maintenance_sla_compliance_rate=Decimal("0"),
            student_feedback_score=None,
            overall_performance_score=m.overall_performance_score,
        )

# --- File: D:\hostel-management-saas\app\services\analytics\__init__.py ---
# app/services/analytics/__init__.py
"""
Analytics services package.

High-level analytics and reporting over core/service/transaction models:

- AttendanceAnalyticsService: student attendance reports & trends.
- ComplaintAnalyticsService: complaint KPIs and dashboard metrics.
- CustomReportService: generic, schema-driven custom reports.
- DashboardAnalyticsService: dashboard quick stats (hostel/platform/admin).
- FinancialAnalyticsService: revenue/expense, P&L, and cashflow.
- OccupancyAnalyticsService: hostel bed occupancy & trends.
- PlatformAnalyticsService: platform-wide metrics, growth, usage.
- SupervisorAnalyticsService: supervisor performance and comparisons.
"""

from .attendance_analytics_service import AttendanceAnalyticsService
from .complaint_analytics_service import ComplaintAnalyticsService
from .custom_report_service import CustomReportService
from .dashboard_analytics_service import DashboardAnalyticsService
from .financial_analytics_service import FinancialAnalyticsService
from .occupancy_analytics_service import OccupancyAnalyticsService
from .platform_analytics_service import PlatformAnalyticsService
from .supervisor_analytics_service import SupervisorAnalyticsService

__all__ = [
    "AttendanceAnalyticsService",
    "ComplaintAnalyticsService",
    "CustomReportService",
    "DashboardAnalyticsService",
    "FinancialAnalyticsService",
    "OccupancyAnalyticsService",
    "PlatformAnalyticsService",
    "SupervisorAnalyticsService",
]


# ===== Folder: D:\hostel-management-saas\app\services\announcement =====

# --- File: D:\hostel-management-saas\app\services\announcement\announcement_delivery_service.py ---
# app/services/announcement/announcement_delivery_service.py
from __future__ import annotations

from datetime import datetime, timezone
from decimal import Decimal
from typing import Callable, Dict, Optional, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import AnnouncementRepository
from app.schemas.announcement.announcement_delivery import (
    DeliveryConfig,
    DeliveryChannels,
    DeliveryStatus,
    DeliveryReport,
    ChannelDeliveryStats,
    FailedDelivery,
)
from app.services.common import UnitOfWork, errors


class AnnouncementDeliveryStore(Protocol):
    """
    Abstract storage for announcement delivery configuration and status.

    Implementations can use Redis, dedicated tables, etc.
    """

    # Config
    def get_config(self, announcement_id: UUID) -> Optional[dict]: ...
    def save_config(self, announcement_id: UUID, data: dict) -> None: ...

    # Status
    def get_status(self, announcement_id: UUID) -> Optional[dict]: ...
    def save_status(self, announcement_id: UUID, data: dict) -> None: ...

    # Failed recipients
    def list_failed_recipients(self, announcement_id: UUID) -> list[dict]: ...
    def add_failed_recipient(self, announcement_id: UUID, record: dict) -> None: ...

    # Cached reports
    def get_report(self, announcement_id: UUID) -> Optional[dict]: ...
    def save_report(self, announcement_id: UUID, data: dict) -> None: ...


class AnnouncementDeliveryService:
    """
    Delivery configuration & aggregate status for announcements.

    - Store/load DeliveryConfig
    - Track DeliveryStatus per announcement
    - Record failed recipients (for later retry)
    - Build DeliveryReport
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: AnnouncementDeliveryStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_announcement_repo(self, uow: UnitOfWork) -> AnnouncementRepository:
        return uow.get_repo(AnnouncementRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Config
    # ------------------------------------------------------------------ #
    def set_delivery_config(self, config: DeliveryConfig) -> DeliveryConfig:
        """
        Persist delivery configuration for an announcement.
        """
        self._store.save_config(config.announcement_id, config.model_dump())
        return config

    def get_delivery_config(self, announcement_id: UUID) -> Optional[DeliveryConfig]:
        record = self._store.get_config(announcement_id)
        if not record:
            return None
        return DeliveryConfig.model_validate(record)

    # ------------------------------------------------------------------ #
    # Status
    # ------------------------------------------------------------------ #
    def initialize_status(
        self,
        announcement_id: UUID,
        *,
        total_recipients: int,
    ) -> DeliveryStatus:
        """
        Initialize DeliveryStatus with zero counts for all channels.

        Typically called before starting delivery.
        """
        status = DeliveryStatus(
            announcement_id=announcement_id,
            total_recipients=total_recipients,
            email_sent=0,
            email_delivered=0,
            email_failed=0,
            sms_sent=0,
            sms_delivered=0,
            sms_failed=0,
            push_sent=0,
            push_delivered=0,
            push_failed=0,
            total_delivered=0,
            total_failed=0,
            delivery_rate=Decimal("0"),
            delivery_started_at=None,
            delivery_completed_at=None,
        )
        self._store.save_status(announcement_id, status.model_dump())
        return status

    def get_delivery_status(self, announcement_id: UUID) -> Optional[DeliveryStatus]:
        record = self._store.get_status(announcement_id)
        if not record:
            return None
        return DeliveryStatus.model_validate(record)

    def mark_delivery_started(self, announcement_id: UUID) -> DeliveryStatus:
        status = self.get_delivery_status(announcement_id)
        if not status:
            raise errors.NotFoundError(
                f"DeliveryStatus for announcement {announcement_id} not initialized"
            )
        status.delivery_started_at = self._now()
        self._store.save_status(announcement_id, status.model_dump())
        return status

    def mark_delivery_completed(self, announcement_id: UUID) -> DeliveryStatus:
        status = self.get_delivery_status(announcement_id)
        if not status:
            raise errors.NotFoundError(
                f"DeliveryStatus for announcement {announcement_id} not initialized"
            )
        status.delivery_completed_at = self._now()
        self._store.save_status(announcement_id, status.model_dump())
        return status

    def record_channel_outcome(
        self,
        announcement_id: UUID,
        *,
        channel: str,
        sent: int = 0,
        delivered: int = 0,
        failed: int = 0,
    ) -> DeliveryStatus:
        """
        Increment per-channel counters and recompute overall totals.

        channel: 'email' | 'sms' | 'push'
        """
        status = self.get_delivery_status(announcement_id)
        if not status:
            raise errors.NotFoundError(
                f"DeliveryStatus for announcement {announcement_id} not initialized"
            )

        if channel == "email":
            status.email_sent += sent
            status.email_delivered += delivered
            status.email_failed += failed
        elif channel == "sms":
            status.sms_sent += sent
            status.sms_delivered += delivered
            status.sms_failed += failed
        elif channel == "push":
            status.push_sent += sent
            status.push_delivered += delivered
            status.push_failed += failed
        else:
            # Unknown channel; ignore
            return status

        status.total_delivered = (
            status.email_delivered + status.sms_delivered + status.push_delivered
        )
        status.total_failed = (
            status.email_failed + status.sms_failed + status.push_failed
        )

        if status.total_recipients > 0:
            status.delivery_rate = (
                Decimal(str(status.total_delivered))
                / Decimal(str(status.total_recipients))
                * 100
            )
        else:
            status.delivery_rate = Decimal("0")

        self._store.save_status(announcement_id, status.model_dump())
        return status

    def record_failed_recipient(self, announcement_id: UUID, failed: FailedDelivery) -> None:
        """
        Track a single failed recipient (for retry or analysis).
        """
        self._store.add_failed_recipient(
            announcement_id,
            failed.model_dump(),
        )

    # ------------------------------------------------------------------ #
    # Report
    # ------------------------------------------------------------------ #
    def build_delivery_report(self, announcement_id: UUID) -> DeliveryReport:
        """
        Build a DeliveryReport from DeliveryStatus and failed recipients.
        """
        status = self.get_delivery_status(announcement_id)
        if not status:
            raise errors.NotFoundError(
                f"DeliveryStatus for announcement {announcement_id} not found"
            )

        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_announcement_repo(uow)
            a = repo.get(announcement_id)
            if a is None:
                raise errors.NotFoundError(f"Announcement {announcement_id} not found")
            title = a.title or ""

        duration_minutes: Optional[int] = None
        if status.delivery_started_at and status.delivery_completed_at:
            delta = status.delivery_completed_at - status.delivery_started_at
            duration_minutes = int(delta.total_seconds() // 60)

        # Per-channel stats
        def _channel_stats(
            channel: str, sent: int, delivered: int, failed: int
        ) -> ChannelDeliveryStats:
            pending = max(0, status.total_recipients - (delivered + failed))
            rate = (
                Decimal(str(delivered)) / Decimal(str(status.total_recipients)) * 100
                if status.total_recipients > 0
                else Decimal("0")
            )
            return ChannelDeliveryStats(
                channel=channel,
                sent=sent,
                delivered=delivered,
                failed=failed,
                pending=pending,
                delivery_rate=rate,
                average_delivery_time_seconds=None,
            )

        channel_breakdown: Dict[str, ChannelDeliveryStats] = {
            "email": _channel_stats(
                "email",
                status.email_sent,
                status.email_delivered,
                status.email_failed,
            ),
            "sms": _channel_stats(
                "sms",
                status.sms_sent,
                status.sms_delivered,
                status.sms_failed,
            ),
            "push": _channel_stats(
                "push",
                status.push_sent,
                status.push_delivered,
                status.push_failed,
            ),
        }

        failed_recs_raw = self._store.list_failed_recipients(announcement_id)
        failed_recipients: List[FailedDelivery] = [
            FailedDelivery.model_validate(r) for r in failed_recs_raw
        ]

        report = DeliveryReport(
            announcement_id=announcement_id,
            title=title,
            total_recipients=status.total_recipients,
            channel_breakdown=channel_breakdown,
            delivered_count=status.total_delivered,
            failed_count=status.total_failed,
            pending_count=max(
                0,
                status.total_recipients
                - (status.total_delivered + status.total_failed),
            ),
            failed_recipients=failed_recipients,
            delivery_duration_minutes=duration_minutes,
            generated_at=self._now(),
        )

        self._store.save_report(announcement_id, report.model_dump())
        return report

    def get_delivery_report(self, announcement_id: UUID) -> Optional[DeliveryReport]:
        record = self._store.get_report(announcement_id)
        if not record:
            return None
        return DeliveryReport.model_validate(record)

# --- File: D:\hostel-management-saas\app\services\announcement\announcement_service.py ---
# app/services/announcement/announcement_service.py
from __future__ import annotations

from datetime import datetime, date, timezone
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import AnnouncementRepository
from app.repositories.core import HostelRepository, UserRepository
from app.schemas.announcement.announcement_base import (
    AnnouncementCreate,
    AnnouncementUpdate,
)
from app.schemas.announcement.announcement_filters import (
    AnnouncementFilterParams,
    SearchRequest,
    ArchiveRequest,
)
from app.schemas.announcement.announcement_response import (
    AnnouncementResponse,
    AnnouncementDetail,
    AnnouncementList,
    AnnouncementListItem,
)
from app.schemas.common.enums import TargetAudience
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.services.common import UnitOfWork, errors


class AnnouncementService:
    """
    Core Announcement service:

    - Create / update announcements
    - Publish / unpublish
    - Retrieve single announcement detail
    - List & search announcements (with filters)
    - Archive old announcements (soft-delete via BaseRepository)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_announcement_repo(self, uow: UnitOfWork) -> AnnouncementRepository:
        return uow.get_repo(AnnouncementRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_response(
        self,
        a,
        *,
        hostel_name: str,
        creator_name: str,
    ) -> AnnouncementResponse:
        return AnnouncementResponse(
            id=a.id,
            created_at=a.created_at,
            updated_at=a.updated_at,
            hostel_id=a.hostel_id,
            hostel_name=hostel_name,
            title=a.title,
            content=a.content,
            category=a.category,
            priority=a.priority,
            is_urgent=a.is_urgent,
            is_pinned=a.is_pinned,
            created_by=a.created_by_id,
            created_by_name=creator_name,
            is_published=a.is_published,
            published_at=a.published_at,
            total_recipients=a.total_recipients or 0,
            read_count=a.read_count or 0,
        )

    def _to_detail(
        self,
        a,
        *,
        hostel_name: str,
        creator_name: str,
    ) -> AnnouncementDetail:
        total_recipients = a.total_recipients or 0
        read_count = a.read_count or 0
        engagement_rate = (
            (Decimal(str(read_count)) / Decimal(str(total_recipients)) * 100)
            if total_recipients > 0
            else Decimal("0")
        )

        return AnnouncementDetail(
            id=a.id,
            created_at=a.created_at,
            updated_at=a.updated_at,
            hostel_id=a.hostel_id,
            hostel_name=hostel_name,
            title=a.title,
            content=a.content,
            category=a.category,
            priority=a.priority,
            is_urgent=a.is_urgent,
            is_pinned=a.is_pinned,
            target_audience=a.target_audience.value
            if hasattr(a.target_audience, "value")
            else str(a.target_audience),
            target_room_ids=a.target_room_ids or [],
            target_student_ids=a.target_student_ids or [],
            target_floor_numbers=a.target_floor_numbers or [],
            attachments=a.attachments or [],
            scheduled_publish_at=a.scheduled_publish_at,
            published_at=a.published_at,
            expires_at=a.expires_at,
            is_published=a.is_published,
            created_by=a.created_by_id,
            created_by_name=creator_name,
            created_by_role=a.created_by_role or "",
            approved_by=None,
            approved_by_name=None,
            approved_at=None,
            requires_approval=False,
            send_email=False,
            send_sms=False,
            send_push=True,
            email_sent_at=None,
            sms_sent_at=None,
            push_sent_at=None,
            total_recipients=total_recipients,
            read_count=read_count,
            acknowledged_count=0,
            engagement_rate=engagement_rate,
        )

    def _to_list_item(
        self,
        a,
        *,
        creator_name: str,
    ) -> AnnouncementListItem:
        return AnnouncementListItem(
            id=a.id,
            title=a.title,
            category=a.category.value
            if hasattr(a.category, "value")
            else str(a.category),
            priority=a.priority.value
            if hasattr(a.priority, "value")
            else str(a.priority),
            is_urgent=a.is_urgent,
            is_pinned=a.is_pinned,
            created_by_name=creator_name,
            published_at=a.published_at,
            read_count=a.read_count or 0,
            total_recipients=a.total_recipients or 0,
            is_read=False,
        )

    # ------------------------------------------------------------------ #
    # Read operations
    # ------------------------------------------------------------------ #
    def get_announcement(self, announcement_id: UUID) -> AnnouncementDetail:
        """
        Fetch a single announcement with full detail.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_announcement_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            a = repo.get(announcement_id)
            if a is None:
                raise errors.NotFoundError(f"Announcement {announcement_id} not found")

            hostel = hostel_repo.get(a.hostel_id)
            hostel_name = hostel.name if hostel else ""

            creator = (
                user_repo.get(a.created_by_id)
                if getattr(a, "created_by_id", None)
                else None
            )
            creator_name = creator.full_name if creator else ""

            return self._to_detail(a, hostel_name=hostel_name, creator_name=creator_name)

    def list_for_hostel(
        self,
        hostel_id: UUID,
        *,
        include_unpublished: bool = False,
    ) -> AnnouncementList:
        """
        Non-paginated list of announcements for a hostel (e.g., admin dashboard).

        - Optionally includes unpublished announcements.
        - Pinned announcements first, then most recently published/created.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_announcement_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            hostel_name = hostel.name if hostel else ""

            records: Sequence = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

            if not include_unpublished:
                records = [a for a in records if a.is_published]

            def _sort_key(a) -> tuple:
                published = a.published_at or a.created_at
                return (
                    not a.is_pinned,
                    published or datetime.min.replace(tzinfo=timezone.utc),
                )

            sorted_records = sorted(records, key=_sort_key, reverse=True)

            creator_name_cache: Dict[UUID, str] = {}
            items: List[AnnouncementListItem] = []
            now = self._now()

            for a in sorted_records:
                cid = getattr(a, "created_by_id", None)
                creator_name = ""
                if cid:
                    if cid not in creator_name_cache:
                        u = user_repo.get(cid)
                        creator_name_cache[cid] = u.full_name if u else ""
                    creator_name = creator_name_cache[cid]
                items.append(self._to_list_item(a, creator_name=creator_name))

            total = len(sorted_records)
            active_announcements = 0
            pinned_announcements = 0

            for a in sorted_records:
                is_expired = a.expires_at is not None and a.expires_at <= now
                if a.is_published and not is_expired:
                    active_announcements += 1
                if a.is_pinned:
                    pinned_announcements += 1

            return AnnouncementList(
                hostel_id=hostel_id,
                total_announcements=total,
                active_announcements=active_announcements,
                pinned_announcements=pinned_announcements,
                announcements=items,
            )

    def list_announcements(
        self,
        params: PaginationParams,
        filters: Optional[AnnouncementFilterParams] = None,
    ) -> PaginatedResponse[AnnouncementListItem]:
        """
        Paginated listing of announcements with filter support (admin view).
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_announcement_repo(uow)
            user_repo = self._get_user_repo(uow)

            raw_filters: Dict[str, object] = {}
            if filters:
                if filters.hostel_id:
                    raw_filters["hostel_id"] = filters.hostel_id
                if filters.hostel_ids:
                    raw_filters["hostel_id"] = filters.hostel_ids
                if filters.category:
                    raw_filters["category"] = filters.category
                elif filters.categories:
                    raw_filters["category"] = filters.categories
                if filters.priority:
                    raw_filters["priority"] = filters.priority
                elif filters.priorities:
                    raw_filters["priority"] = filters.priorities
                if filters.is_published is not None:
                    raw_filters["is_published"] = filters.is_published
                if filters.is_urgent is not None:
                    raw_filters["is_urgent"] = filters.is_urgent
                if filters.is_pinned is not None:
                    raw_filters["is_pinned"] = filters.is_pinned
                if filters.created_by:
                    raw_filters["created_by_id"] = filters.created_by
                if filters.created_by_role:
                    raw_filters["created_by_role"] = filters.created_by_role

            # Fetch superset and refine in Python
            records: Sequence = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=raw_filters or None,
            )

            def _matches_advanced_filters(a) -> bool:
                if not filters:
                    return True

                # Text search
                if filters.search:
                    q = filters.search.lower()
                    text = f"{a.title or ''} {a.content or ''}".lower()
                    if q not in text:
                        return False

                # Published date range
                if filters.published_date_from or filters.published_date_to:
                    if not a.published_at:
                        return False
                    d = a.published_at.date()
                    if filters.published_date_from and d < filters.published_date_from:
                        return False
                    if filters.published_date_to and d > filters.published_date_to:
                        return False

                # Created date range
                if filters.created_date_from or filters.created_date_to:
                    d = a.created_at.date()
                    if filters.created_date_from and d < filters.created_date_from:
                        return False
                    if filters.created_date_to and d > filters.created_date_to:
                        return False

                today = date.today()
                # Active / expired
                if filters.active_only:
                    if a.expires_at and a.expires_at.date() <= today:
                        return False
                if filters.expired_only:
                    if not a.expires_at or a.expires_at.date() > today:
                        return False

                # approval_pending cannot be resolved here (no approval table), ignore
                return True

            filtered = [a for a in records if _matches_advanced_filters(a)]

            def _sort_key(a) -> tuple:
                published = a.published_at or a.created_at
                return (
                    not a.is_pinned,
                    published or datetime.min.replace(tzinfo=timezone.utc),
                )

            sorted_records = sorted(filtered, key=_sort_key, reverse=True)

            start = params.offset
            end = start + params.limit
            page_records = sorted_records[start:end]

            creator_name_cache: Dict[UUID, str] = {}
            items: List[AnnouncementListItem] = []
            for a in page_records:
                cid = getattr(a, "created_by_id", None)
                creator_name = ""
                if cid:
                    if cid not in creator_name_cache:
                        u = user_repo.get(cid)
                        creator_name_cache[cid] = u.full_name if u else ""
                    creator_name = creator_name_cache[cid]
                items.append(self._to_list_item(a, creator_name=creator_name))

            return PaginatedResponse[AnnouncementListItem].create(
                items=items,
                total_items=len(sorted_records),
                page=params.page,
                page_size=params.page_size,
            )

    def search_announcements(
        self,
        params: PaginationParams,
        req: SearchRequest,
    ) -> PaginatedResponse[AnnouncementListItem]:
        """
        Simple search on title/content within a hostel.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_announcement_repo(uow)
            user_repo = self._get_user_repo(uow)

            filters: Dict[str, object] = {}
            if req.hostel_id:
                filters["hostel_id"] = req.hostel_id

            records: Sequence = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

            q = req.query.lower()
            def _matches(a) -> bool:
                text_title = (a.title or "").lower()
                text_content = (a.content or "").lower()
                if req.search_in_title and q in text_title:
                    return True
                if req.search_in_content and q in text_content:
                    return True
                return False

            matched = [a for a in records if _matches(a)]

            def _sort_key(a) -> datetime:
                return a.published_at or a.created_at

            matched_sorted = sorted(
                matched,
                key=_sort_key,
                reverse=True,
            )

            start = params.offset
            end = start + params.limit
            page_records = matched_sorted[start:end]

            creator_name_cache: Dict[UUID, str] = {}
            items: List[AnnouncementListItem] = []
            for a in page_records:
                cid = getattr(a, "created_by_id", None)
                creator_name = ""
                if cid:
                    if cid not in creator_name_cache:
                        u = user_repo.get(cid)
                        creator_name_cache[cid] = u.full_name if u else ""
                    creator_name = creator_name_cache[cid]
                items.append(self._to_list_item(a, creator_name=creator_name))

            return PaginatedResponse[AnnouncementListItem].create(
                items=items,
                total_items=len(matched_sorted),
                page=params.page,
                page_size=params.page_size,
            )

    # ------------------------------------------------------------------ #
    # Create / update / publish / archive
    # ------------------------------------------------------------------ #
    def create_announcement(self, data: AnnouncementCreate) -> AnnouncementDetail:
        """
        Create a new announcement.

        - Validates hostel existence.
        - Resolves creator role from User.user_role.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_announcement_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            creator = user_repo.get(data.created_by)
            if creator is None:
                raise errors.NotFoundError(f"User {data.created_by} not found")

            creator_role = (
                creator.user_role.value
                if getattr(creator, "user_role", None)
                else "unknown"
            )

            payload = {
                "hostel_id": data.hostel_id,
                "title": data.title,
                "content": data.content,
                "category": data.category,
                "priority": data.priority,
                "is_urgent": data.is_urgent,
                "is_pinned": data.is_pinned,
                "target_audience": (
                    TargetAudience(data.target_audience)
                    if isinstance(data.target_audience, str)
                    else data.target_audience
                ),
                "target_room_ids": data.target_room_ids or [],
                "target_student_ids": data.target_student_ids or [],
                "target_floor_numbers": data.target_floor_numbers or [],
                "attachments": [str(u) for u in data.attachments] if data.attachments else [],
                "expires_at": data.expires_at,
                "created_by_id": data.created_by,
                "created_by_role": creator_role,
                "is_published": False,
                "scheduled_publish_at": None,
                "published_at": None,
                "total_recipients": 0,
                "read_count": 0,
            }
            a = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            return self._to_detail(
                a,
                hostel_name=hostel.name,
                creator_name=creator.full_name,
            )

    def update_announcement(
        self,
        announcement_id: UUID,
        data: AnnouncementUpdate,
    ) -> AnnouncementDetail:
        """
        Update mutable announcement fields (title, content, priority, flags, expiry).

        Publication state is handled via publish()/unpublish().
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_announcement_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            a = repo.get(announcement_id)
            if a is None:
                raise errors.NotFoundError(f"Announcement {announcement_id} not found")

            update_data = data.model_dump(exclude_unset=True)
            for field, value in update_data.items():
                if field == "is_published":
                    # use publish/unpublish methods instead
                    continue
                if hasattr(a, field):
                    setattr(a, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            hostel = hostel_repo.get(a.hostel_id)
            hostel_name = hostel.name if hostel else ""
            creator = (
                user_repo.get(a.created_by_id)
                if getattr(a, "created_by_id", None)
                else None
            )
            creator_name = creator.full_name if creator else ""

            return self._to_detail(a, hostel_name=hostel_name, creator_name=creator_name)

    def publish(
        self,
        announcement_id: UUID,
        *,
        publish_at: Optional[datetime] = None,
    ) -> AnnouncementDetail:
        """
        Publish an announcement.

        - If publish_at is None, uses current time.
        - Clears scheduled_publish_at.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_announcement_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            a = repo.get(announcement_id)
            if a is None:
                raise errors.NotFoundError(f"Announcement {announcement_id} not found")

            ts = publish_at or self._now()
            a.is_published = True  # type: ignore[attr-defined]
            a.published_at = ts  # type: ignore[attr-defined]
            a.scheduled_publish_at = None  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            hostel = hostel_repo.get(a.hostel_id)
            hostel_name = hostel.name if hostel else ""
            creator = (
                user_repo.get(a.created_by_id)
                if getattr(a, "created_by_id", None)
                else None
            )
            creator_name = creator.full_name if creator else ""

            return self._to_detail(a, hostel_name=hostel_name, creator_name=creator_name)

    def unpublish(self, announcement_id: UUID) -> AnnouncementDetail:
        """
        Unpublish an announcement (soft-unpublish).
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_announcement_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            a = repo.get(announcement_id)
            if a is None:
                raise errors.NotFoundError(f"Announcement {announcement_id} not found")

            a.is_published = False  # type: ignore[attr-defined]
            # Keep published_at as a historical timestamp

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            hostel = hostel_repo.get(a.hostel_id)
            hostel_name = hostel.name if hostel else ""
            creator = (
                user_repo.get(a.created_by_id)
                if getattr(a, "created_by_id", None)
                else None
            )
            creator_name = creator.full_name if creator else ""

            return self._to_detail(a, hostel_name=hostel_name, creator_name=creator_name)

    def archive_announcements(self, req: ArchiveRequest) -> int:
        """
        Archive (soft-delete) announcements before a given date, based on criteria.

        Uses BaseRepository.bulk_delete with soft-delete semantics (is_deleted).
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_announcement_repo(uow)

            # Fetch candidates and filter in Python; then bulk_delete by IDs.
            records: Sequence = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": req.hostel_id},
            )

            def _matches(a) -> bool:
                # Cutoff by created_at
                if a.created_at.date() >= req.archive_before_date:
                    return False

                # Expired only?
                if req.archive_expired_only:
                    if not a.expires_at or a.expires_at.date() >= req.archive_before_date:
                        return False

                # Exclude pinned/important
                if req.exclude_pinned and a.is_pinned:
                    return False
                if req.exclude_important and a.is_urgent:
                    return False

                # read_only / recipients logic would require per-recipient tracking;
                # here we only check read_count == total_recipients when requested.
                if req.archive_read_only:
                    if (
                        a.total_recipients
                        and a.read_count is not None
                        and a.read_count < a.total_recipients
                    ):
                        return False

                return True

            to_archive_ids: List[UUID] = [
                a.id for a in records if _matches(a)
            ]
            if not to_archive_ids:
                return 0

            # Bulk soft-delete by id
            deleted = repo.bulk_delete(
                filters={"id": to_archive_ids},
                hard_delete=False,
            )
            uow.commit()
            return deleted

# --- File: D:\hostel-management-saas\app\services\announcement\announcement_tracking_service.py ---
# app/services/announcement/announcement_tracking_service.py
from __future__ import annotations

from collections import Counter
from datetime import datetime, timezone
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import AnnouncementRepository
from app.repositories.core import StudentRepository, RoomRepository
from app.schemas.announcement.announcement_tracking import (
    ReadReceipt,
    ReadReceiptResponse,
    AcknowledgmentTracking,
    PendingAcknowledgment,
    AcknowledgmentRequest,
    EngagementMetrics,
    ReadingTime,
    AnnouncementAnalytics,
)
from app.schemas.announcement.announcement_delivery import DeliveryStatus
from app.services.common import UnitOfWork, errors


class AnnouncementTrackingStore(Protocol):
    """
    Storage for per-recipient read receipts and acknowledgments.

    Implementations might use dedicated tables or Redis-like stores.
    """

    # Read receipts
    def save_read_receipt(self, record: dict) -> None: ...
    def get_read_receipt(self, announcement_id: UUID, student_id: UUID) -> Optional[dict]: ...
    def list_read_receipts(self, announcement_id: UUID) -> List[dict]: ...

    # Acknowledgments
    def save_acknowledgment(self, record: dict) -> None: ...
    def get_acknowledgment(self, announcement_id: UUID, student_id: UUID) -> Optional[dict]: ...
    def list_acknowledgments(self, announcement_id: UUID) -> List[dict]: ...

    # Recipient metadata for acknowledgments / analytics
    def list_recipients(self, announcement_id: UUID) -> List[dict]: ...
    # Expected recipient record:
    # {
    #   "student_id": str,
    #   "student_name": str,
    #   "room_number": str | None,
    #   "delivered_at": datetime,
    #   "read": bool,
    #   "read_at": datetime | None,
    #   "acknowledged": bool,
    # }


class AnnouncementTrackingService:
    """
    Track read receipts and acknowledgments for announcements, and compute
    engagement analytics.

    - Records ReadReceipt per student/announcement
    - Records acknowledgments
    - Builds AcknowledgmentTracking and EngagementMetrics
    - Can assemble full AnnouncementAnalytics when given DeliveryStatus
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: AnnouncementTrackingStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_announcement_repo(self, uow: UnitOfWork) -> AnnouncementRepository:
        return uow.get_repo(AnnouncementRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Read receipts
    # ------------------------------------------------------------------ #
    def mark_read(self, data: ReadReceipt) -> ReadReceiptResponse:
        """
        Record that a student has read an announcement.

        - Idempotent: if a receipt already exists, Announcement.read_count
          is only incremented once per student.
        """
        read_at = data.read_at or self._now()

        with UnitOfWork(self._session_factory) as uow:
            announcement_repo = self._get_announcement_repo(uow)
            student_repo = self._get_student_repo(uow)

            a = announcement_repo.get(data.announcement_id)
            if a is None:
                raise errors.NotFoundError(
                    f"Announcement {data.announcement_id} not found"
                )

            s = student_repo.get(data.student_id)
            if s is None:
                raise errors.NotFoundError(
                    f"Student {data.student_id} not found"
                )

            existing = self._store.get_read_receipt(
                data.announcement_id, data.student_id
            )

            if not existing:
                record = {
                    "announcement_id": str(data.announcement_id),
                    "student_id": str(data.student_id),
                    "read_at": read_at,
                    "reading_time_seconds": data.reading_time_seconds,
                    "device_type": data.device_type,
                }
                self._store.save_read_receipt(record)

                # Increment read_count once per student
                a.read_count = (a.read_count or 0) + 1  # type: ignore[attr-defined]
                uow.session.flush()  # type: ignore[union-attr]
                uow.commit()

        ack_record = self._store.get_acknowledgment(
            data.announcement_id, data.student_id
        )
        acknowledged = bool(ack_record and ack_record.get("acknowledged"))

        return ReadReceiptResponse(
            id=None,
            created_at=read_at,
            updated_at=read_at,
            announcement_id=data.announcement_id,
            student_id=data.student_id,
            read_at=read_at,
            requires_acknowledgment=False,
            acknowledged=acknowledged,
        )

    # ------------------------------------------------------------------ #
    # Acknowledgments
    # ------------------------------------------------------------------ #
    def submit_acknowledgment(self, data: AcknowledgmentRequest) -> None:
        """
        Store a student's acknowledgment decision.
        """
        record = {
            "announcement_id": str(data.announcement_id),
            "student_id": str(data.student_id),
            "acknowledged": data.acknowledged,
            "acknowledgment_note": data.acknowledgment_note,
            "acknowledged_at": self._now(),
        }
        self._store.save_acknowledgment(record)

    def get_acknowledgment_tracking(
        self,
        announcement_id: UUID,
        *,
        requires_acknowledgment: bool = True,
    ) -> AcknowledgmentTracking:
        """
        Build AcknowledgmentTracking for an announcement.
        """
        with UnitOfWork(self._session_factory) as uow:
            announcement_repo = self._get_announcement_repo(uow)
            a = announcement_repo.get(announcement_id)
            if a is None:
                raise errors.NotFoundError(
                    f"Announcement {announcement_id} not found"
                )
            total_recipients = a.total_recipients or 0

        ack_records = self._store.list_acknowledgments(announcement_id)
        acknowledged_count = sum(
            1 for r in ack_records if r.get("acknowledged", False)
        )

        pending_students_raw = self._store.list_recipients(announcement_id)
        pending_students: List[PendingAcknowledgment] = []
        for r in pending_students_raw:
            if r.get("acknowledged"):
                continue
            pending_students.append(
                PendingAcknowledgment(
                    student_id=UUID(r["student_id"]),
                    student_name=r.get("student_name", ""),
                    room_number=r.get("room_number"),
                    delivered_at=r.get("delivered_at"),
                    read=r.get("read", False),
                    read_at=r.get("read_at"),
                )
            )

        pending_ack = max(0, total_recipients - acknowledged_count)
        acknowledgment_rate = (
            Decimal(str(acknowledged_count)) / Decimal(str(total_recipients)) * 100
            if total_recipients > 0
            else Decimal("0")
        )

        return AcknowledgmentTracking(
            announcement_id=announcement_id,
            requires_acknowledgment=requires_acknowledgment,
            total_recipients=total_recipients,
            acknowledged_count=acknowledged_count,
            pending_acknowledgments=pending_ack,
            acknowledgment_rate=acknowledgment_rate,
            pending_students=pending_students,
        )

    # ------------------------------------------------------------------ #
    # Engagement & reading time
    # ------------------------------------------------------------------ #
    def get_engagement_metrics(self, announcement_id: UUID) -> EngagementMetrics:
        """
        Compute EngagementMetrics based on Announcement + read receipts +
        acknowledgments. Delivery metrics are approximated assuming all
        targeted recipients were delivered.
        """
        with UnitOfWork(self._session_factory) as uow:
            announcement_repo = self._get_announcement_repo(uow)
            a = announcement_repo.get(announcement_id)
            if a is None:
                raise errors.NotFoundError(
                    f"Announcement {announcement_id} not found"
                )
            title = a.title or ""
            total_recipients = a.total_recipients or 0
            read_count = a.read_count or 0

        delivered_count = total_recipients
        delivery_rate = (
            Decimal(str(delivered_count)) / Decimal(str(total_recipients)) * 100
            if total_recipients > 0
            else Decimal("0")
        )
        read_rate = (
            Decimal(str(read_count)) / Decimal(str(total_recipients)) * 100
            if total_recipients > 0
            else Decimal("0")
        )

        read_receipts = self._store.list_read_receipts(announcement_id)
        ack_records = self._store.list_acknowledgments(announcement_id)
        acknowledged_count = sum(
            1 for r in ack_records if r.get("acknowledged", False)
        )
        acknowledgment_rate = (
            Decimal(str(acknowledged_count)) / Decimal(str(total_recipients)) * 100
            if total_recipients > 0
            else Decimal("0")
        )

        times = [
            Decimal(str(r.get("reading_time_seconds")))
            for r in read_receipts
            if r.get("reading_time_seconds") is not None
        ]
        avg_reading_time = (
            sum(times) / Decimal(str(len(times))) if times else None
        )

        avg_time_to_read = None  # delivery→read delta not tracked here

        if total_recipients > 0:
            engagement_score = (read_rate + acknowledgment_rate) / 2
        else:
            engagement_score = Decimal("0")

        return EngagementMetrics(
            announcement_id=announcement_id,
            title=title,
            total_recipients=total_recipients,
            delivered_count=delivered_count,
            delivery_rate=delivery_rate,
            read_count=read_count,
            read_rate=read_rate,
            average_reading_time_seconds=avg_reading_time,
            acknowledged_count=acknowledged_count,
            acknowledgment_rate=acknowledgment_rate,
            average_time_to_read_hours=avg_time_to_read,
            engagement_score=engagement_score,
        )

    def get_reading_time_stats(self, announcement_id: UUID) -> ReadingTime:
        """
        Build ReadingTime statistics from stored read receipts.
        """
        receipts = self._store.list_read_receipts(announcement_id)
        times = [
            int(r.get("reading_time_seconds"))
            for r in receipts
            if r.get("reading_time_seconds") is not None
        ]
        if not times:
            return ReadingTime(
                announcement_id=announcement_id,
                average_reading_time_seconds=Decimal("0"),
                median_reading_time_seconds=Decimal("0"),
                min_reading_time_seconds=0,
                max_reading_time_seconds=0,
                quick_readers=0,
                normal_readers=0,
                thorough_readers=0,
            )

        times_sorted = sorted(times)
        total = len(times)
        avg = Decimal(str(sum(times))) / Decimal(str(total))
        median = Decimal(str(times_sorted[total // 2]))

        quick = sum(1 for t in times if t < 30)
        normal = sum(1 for t in times if 30 <= t <= 120)
        thorough = sum(1 for t in times if t > 120)

        return ReadingTime(
            announcement_id=announcement_id,
            average_reading_time_seconds=avg,
            median_reading_time_seconds=median,
            min_reading_time_seconds=min(times),
            max_reading_time_seconds=max(times),
            quick_readers=quick,
            normal_readers=normal,
            thorough_readers=thorough,
        )

    # ------------------------------------------------------------------ #
    # Combined analytics
    # ------------------------------------------------------------------ #
    def get_announcement_analytics(
        self,
        announcement_id: UUID,
        *,
        delivery_status: DeliveryStatus,
    ) -> AnnouncementAnalytics:
        """
        Build full AnnouncementAnalytics combining:
        - DeliveryStatus (from AnnouncementDeliveryService)
        - EngagementMetrics (from this service)
        - Reading distributions and device breakdown
        """
        engagement = self.get_engagement_metrics(announcement_id)

        with UnitOfWork(self._session_factory) as uow:
            announcement_repo = self._get_announcement_repo(uow)
            a = announcement_repo.get(announcement_id)
            if a is None:
                raise errors.NotFoundError(
                    f"Announcement {announcement_id} not found"
                )
            published_at = a.published_at or a.created_at

        receipts = self._store.list_read_receipts(announcement_id)

        by_hour: Dict[str, int] = {}
        by_day: Dict[str, int] = {}
        for r in receipts:
            ra = r.get("read_at")
            if not isinstance(ra, datetime):
                continue
            h_key = ra.strftime("%Y-%m-%d %H:00")
            d_key = ra.date().isoformat()
            by_hour[h_key] = by_hour.get(h_key, 0) + 1
            by_day[d_key] = by_day.get(d_key, 0) + 1

        device_counts = Counter(
            (r.get("device_type") or "unknown") for r in receipts
        )

        return AnnouncementAnalytics(
            announcement_id=announcement_id,
            title=engagement.title,
            published_at=published_at,
            delivery_metrics=delivery_status,
            engagement_metrics=engagement,
            reading_by_hour=by_hour,
            reading_by_day=by_day,
            reads_by_device=dict(device_counts),
        )

# --- File: D:\hostel-management-saas\app\services\announcement\__init__.py ---
# app/services/announcement/__init__.py
"""
Announcement-related services.

- AnnouncementService: core CRUD, listing, search, publish/unpublish, archive.
- AnnouncementDeliveryService: delivery config and aggregate delivery status.
- AnnouncementTrackingService: read receipts, acknowledgments, engagement analytics.
"""

from .announcement_service import AnnouncementService
from .announcement_delivery_service import (
    AnnouncementDeliveryService,
    AnnouncementDeliveryStore,
)
from .announcement_tracking_service import (
    AnnouncementTrackingService,
    AnnouncementTrackingStore,
)

__all__ = [
    "AnnouncementService",
    "AnnouncementDeliveryService",
    "AnnouncementDeliveryStore",
    "AnnouncementTrackingService",
    "AnnouncementTrackingStore",
]


# ===== Folder: D:\hostel-management-saas\app\services\attendance =====

# --- File: D:\hostel-management-saas\app\services\attendance\attendance_alert_service.py ---
# app/services/attendance/attendance_alert_service.py
from __future__ import annotations

from datetime import date, datetime, timezone
from typing import Callable, Dict, List, Optional, Protocol
from uuid import UUID, uuid4

from sqlalchemy.orm import Session

from app.repositories.core import StudentRepository, HostelRepository
from app.schemas.attendance.attendance_alert import (
    AttendanceAlert,
    AlertConfig,
    AlertTrigger,
    AlertAcknowledgment,
    AlertList,
    AlertSummary,
)
from app.services.common import UnitOfWork, errors


class AlertStore(Protocol):
    """
    Abstract store for attendance alerts and alert configuration.
    """

    def create_alert(self, record: dict) -> dict: ...
    def update_alert(self, alert_id: UUID, data: dict) -> dict: ...
    def get_alert(self, alert_id: UUID) -> Optional[dict]: ...
    def list_alerts_for_hostel(self, hostel_id: UUID) -> List[dict]: ...

    def get_config(self, hostel_id: UUID) -> Optional[dict]: ...
    def save_config(self, hostel_id: UUID, data: dict) -> None: ...


class AttendanceAlertService:
    """
    Attendance alert service:

    - Manage AlertConfig per hostel
    - Trigger manual alerts
    - Acknowledge alerts
    - List alerts and build summary
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: AlertStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Config
    # ------------------------------------------------------------------ #
    def get_config(self, hostel_id: UUID) -> AlertConfig:
        record = self._store.get_config(hostel_id)
        if record:
            return AlertConfig.model_validate(record)
        # Default config if none stored
        cfg = AlertConfig(
            hostel_id=hostel_id,
        )
        self._store.save_config(hostel_id, cfg.model_dump())
        return cfg

    def set_config(self, cfg: AlertConfig) -> None:
        self._store.save_config(cfg.hostel_id, cfg.model_dump())

    # ------------------------------------------------------------------ #
    # Alerts
    # ------------------------------------------------------------------ #
    def trigger_manual_alert(
        self,
        hostel_id: UUID,
        data: AlertTrigger,
    ) -> AttendanceAlert:
        """
        Manually trigger an alert for a student.
        """
        now = self._now()

        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            student = student_repo.get(data.student_id)
            if student is None or not getattr(student, "user", None):
                raise errors.NotFoundError(f"Student {data.student_id} not found")

            student_name = student.user.full_name

        alert_id = uuid4()
        record = {
            "id": alert_id,
            "alert_id": alert_id,
            "hostel_id": hostel_id,
            "student_id": data.student_id,
            "student_name": student_name,
            "alert_type": data.alert_type,
            "severity": data.severity,
            "message": data.custom_message,
            "details": {},
            "triggered_at": now,
            "triggered_by_rule": None,
            "acknowledged": False,
            "acknowledged_by": None,
            "acknowledged_at": None,
            "actions_taken": [],
            "resolved": False,
            "resolved_at": None,
            "created_at": now,
            "updated_at": now,
        }
        created = self._store.create_alert(record)
        return AttendanceAlert.model_validate(created)

    def acknowledge_alert(self, data: AlertAcknowledgment) -> AttendanceAlert:
        """
        Acknowledge an alert and record the action taken.
        """
        now = self._now()
        record = self._store.get_alert(data.alert_id)
        if not record:
            raise errors.NotFoundError(f"Alert {data.alert_id} not found")

        record["acknowledged"] = True
        record["acknowledged_by"] = str(data.acknowledged_by)
        record["acknowledged_at"] = now
        actions = record.get("actions_taken", []) or []
        actions.append(data.action_taken)
        record["actions_taken"] = actions
        record["updated_at"] = now

        updated = self._store.update_alert(data.alert_id, record)
        return AttendanceAlert.model_validate(updated)

    def list_alerts_for_hostel(self, hostel_id: UUID) -> AlertList:
        records = self._store.list_alerts_for_hostel(hostel_id)
        alerts: List[AttendanceAlert] = [
            AttendanceAlert.model_validate(r) for r in records
        ]

        total_alerts = len(alerts)
        unack = sum(1 for a in alerts if not a.acknowledged)
        critical = sum(1 for a in alerts if a.severity == "critical")

        return AlertList(
            hostel_id=hostel_id,
            total_alerts=total_alerts,
            unacknowledged_alerts=unack,
            critical_alerts=critical,
            alerts=alerts,
        )

    def get_alert_summary(
        self,
        hostel_id: UUID,
        *,
        period_start: date,
        period_end: date,
    ) -> AlertSummary:
        records = self._store.list_alerts_for_hostel(hostel_id)
        filtered: List[dict] = []
        for r in records:
            ta: datetime = r.get("triggered_at")
            if not isinstance(ta, datetime):
                continue
            d = ta.date()
            if d < period_start or d > period_end:
                continue
            filtered.append(r)

        total_alerts = len(filtered)

        low_att = cons_abs = late_ent = pattern = 0
        crit = high = med = low_s = 0
        acknowledged = resolved = 0

        for r in filtered:
            atype = r.get("alert_type")
            sev = r.get("severity")

            if atype == "low_attendance":
                low_att += 1
            elif atype == "consecutive_absences":
                cons_abs += 1
            elif atype == "late_entry":
                late_ent += 1
            elif atype == "irregular_pattern":
                pattern += 1

            if sev == "critical":
                crit += 1
            elif sev == "high":
                high += 1
            elif sev == "medium":
                med += 1
            elif sev == "low":
                low_s += 1

            if r.get("acknowledged"):
                acknowledged += 1
            if r.get("resolved"):
                resolved += 1

        pending = total_alerts - resolved

        return AlertSummary(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
            total_alerts=total_alerts,
            low_attendance_alerts=low_att,
            consecutive_absence_alerts=cons_abs,
            late_entry_alerts=late_ent,
            pattern_alerts=pattern,
            critical_count=crit,
            high_count=high,
            medium_count=med,
            low_count=low_s,
            acknowledged_count=acknowledged,
            resolved_count=resolved,
            pending_count=pending,
        )

# --- File: D:\hostel-management-saas\app\services\attendance\attendance_policy_service.py ---
# app/services/attendance/attendance_policy_service.py
from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Callable, List, Optional, Protocol
from uuid import UUID, uuid4

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository, StudentRepository
from app.schemas.attendance.attendance_policy import (
    AttendancePolicy,
    PolicyConfig,
    PolicyUpdate,
    PolicyViolation,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.analytics import AttendanceAnalyticsService
from app.services.common import UnitOfWork, errors


class PolicyStore(Protocol):
    """
    Abstract storage for attendance policy per hostel.
    """

    def get_policy(self, hostel_id: UUID) -> Optional[dict]: ...
    def save_policy(self, hostel_id: UUID, data: dict) -> None: ...


class AttendancePolicyService:
    """
    Attendance policy management:

    - Get/update AttendancePolicy for a hostel
    - Evaluate simple policy violations for a student over a period
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: PolicyStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store
        self._analytics = AttendanceAnalyticsService(session_factory)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Policy CRUD
    # ------------------------------------------------------------------ #
    def get_policy(self, hostel_id: UUID) -> AttendancePolicy:
        """
        Fetch policy for a hostel, creating a default if none exists.
        """
        record = self._store.get_policy(hostel_id)
        if record:
            return AttendancePolicy.model_validate(record)

        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")
            hostel_name = hostel.name

        now = self._now()
        policy = AttendancePolicy(
            id=uuid4(),
            created_at=now,
            updated_at=now,
            hostel_id=hostel_id,
            hostel_name=hostel_name,
            minimum_attendance_percentage=Decimal("75.0"),
            late_entry_threshold_minutes=15,
            grace_days_per_month=3,
            consecutive_absence_alert_days=3,
            notify_guardian_on_absence=True,
            notify_admin_on_low_attendance=True,
            low_attendance_threshold=Decimal("75.0"),
            auto_mark_absent_after_time=None,
            is_active=True,
        )
        self._store.save_policy(hostel_id, policy.model_dump())
        return policy

    def update_policy(self, hostel_id: UUID, data: PolicyUpdate) -> AttendancePolicy:
        """
        Update fields on AttendancePolicy.
        """
        policy = self.get_policy(hostel_id)
        mapping = data.model_dump(exclude_unset=True)
        for field, value in mapping.items():
            if hasattr(policy, field):
                setattr(policy, field, value)
        policy.updated_at = self._now()
        self._store.save_policy(hostel_id, policy.model_dump())
        return policy

    # ------------------------------------------------------------------ #
    # Violations
    # ------------------------------------------------------------------ #
    def evaluate_violations_for_student(
        self,
        hostel_id: UUID,
        student_id: UUID,
        period: DateRangeFilter,
    ) -> List[PolicyViolation]:
        """
        Evaluate basic policy violations:

        - low_attendance
        - consecutive_absences
        - excessive_late_entries
        """
        if not (period.start_date and period.end_date):
            raise errors.ValidationError(
                "Both start_date and end_date are required to evaluate violations"
            )

        policy = self.get_policy(hostel_id)

        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            student = student_repo.get(student_id)
            if student is None or not getattr(student, "user", None):
                raise errors.NotFoundError(f"Student {student_id} not found")
            student_name = student.user.full_name

        # Use analytics service for detailed record
        report = self._analytics.get_student_report(student_id, period)
        summary = report.summary
        daily_records = report.daily_records

        violations: List[PolicyViolation] = []
        violation_date = period.end_date

        # Low attendance
        if summary.attendance_percentage < policy.minimum_attendance_percentage:
            violations.append(
                PolicyViolation(
                    student_id=student_id,
                    student_name=student_name,
                    hostel_id=hostel_id,
                    violation_type="low_attendance",
                    current_attendance_percentage=summary.attendance_percentage,
                    consecutive_absences=None,
                    late_entries_this_month=None,
                    violation_date=violation_date,
                    guardian_notified=False,
                    admin_notified=False,
                    warning_issued=False,
                    notes=None,
                )
            )

        # Consecutive absences
        max_streak = 0
        current = 0
        for rec in sorted(daily_records, key=lambda r: r.date):
            status_str = (rec.status or "").upper()
            if status_str == AttendanceStatus.ABSENT.value:
                current += 1
                if current > max_streak:
                    max_streak = current
            else:
                current = 0

        if max_streak >= policy.consecutive_absence_alert_days:
            violations.append(
                PolicyViolation(
                    student_id=student_id,
                    student_name=student_name,
                    hostel_id=hostel_id,
                    violation_type="consecutive_absences",
                    current_attendance_percentage=summary.attendance_percentage,
                    consecutive_absences=max_streak,
                    late_entries_this_month=None,
                    violation_date=violation_date,
                    guardian_notified=False,
                    admin_notified=False,
                    warning_issued=False,
                    notes=None,
                )
            )

        # Excessive late entries (beyond grace days)
        late_days = summary.total_late
        if late_days > policy.grace_days_per_month:
            violations.append(
                PolicyViolation(
                    student_id=student_id,
                    student_name=student_name,
                    hostel_id=hostel_id,
                    violation_type="excessive_late_entries",
                    current_attendance_percentage=summary.attendance_percentage,
                    consecutive_absences=None,
                    late_entries_this_month=late_days,
                    violation_date=violation_date,
                    guardian_notified=False,
                    admin_notified=False,
                    warning_issued=False,
                    notes=None,
                )
            )

        return violations

# --- File: D:\hostel-management-saas\app\services\attendance\attendance_report_service.py ---
# app/services/attendance/attendance_report_service.py
from __future__ import annotations

from calendar import monthrange
from datetime import date, datetime
from decimal import Decimal
from typing import Callable, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository, StudentRepository, RoomRepository
from app.schemas.attendance.attendance_report import (
    AttendanceReport,
    MonthlyReport,
    StudentMonthlySummary,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.analytics import AttendanceAnalyticsService
from app.services.common import UnitOfWork, errors


class AttendanceReportService:
    """
    Higher-level attendance reporting facade:

    - Student-level report (delegates to AttendanceAnalyticsService)
    - Monthly hostel report (StudentMonthlySummary)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory
        self._analytics = AttendanceAnalyticsService(session_factory)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    # ------------------------------------------------------------------ #
    # Student report
    # ------------------------------------------------------------------ #
    def get_student_report(
        self,
        student_id: UUID,
        period: DateRangeFilter,
    ) -> AttendanceReport:
        return self._analytics.get_student_report(student_id, period)

    # ------------------------------------------------------------------ #
    # Monthly hostel report
    # ------------------------------------------------------------------ #
    def get_monthly_report(self, hostel_id: UUID, month: str) -> MonthlyReport:
        """
        Build a MonthlyReport (per-hostel) for given YYYY-MM.

        Uses AttendanceAnalyticsService per student under that hostel.
        """
        try:
            year, m = map(int, month.split("-"))
        except ValueError:
            raise errors.ValidationError("month must be in 'YYYY-MM' format")

        start = date(year, m, 1)
        end = date(year, m, monthrange(year, m)[1])
        period = DateRangeFilter(start_date=start, end_date=end)

        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)
            room_repo = self._get_room_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            students = student_repo.list_for_hostel(hostel_id, status=None)

            room_cache: dict[UUID, str] = {}
            summaries: List[StudentMonthlySummary] = []
            total_pct = Decimal("0")
            meets_count = 0

            for st in students:
                rep = self._analytics.get_student_report(st.id, period)
                s = rep.summary

                if st.room_id and st.room_id not in room_cache:
                    r = room_repo.get(st.room_id)
                    room_cache[st.room_id] = r.room_number if r else ""

                room_number = (
                    room_cache[st.room_id]
                    if getattr(st, "room_id", None) in room_cache
                    else None
                )
                student_name = st.user.full_name if getattr(st, "user", None) else ""

                summaries.append(
                    StudentMonthlySummary(
                        student_id=st.id,
                        student_name=student_name,
                        room_number=room_number,
                        total_days=s.total_days,
                        present_days=s.total_present,
                        absent_days=s.total_absent,
                        late_days=s.total_late,
                        on_leave_days=s.total_on_leave,
                        attendance_percentage=s.attendance_percentage,
                        meets_requirement=s.meets_minimum_requirement,
                        requires_attention=not s.meets_minimum_requirement,
                        action_required=(
                            "Discuss with student/guardian"
                            if not s.meets_minimum_requirement
                            else None
                        ),
                    )
                )

                total_pct += s.attendance_percentage
                if s.meets_minimum_requirement:
                    meets_count += 1

            total_students = len(students)
            hostel_avg = (
                total_pct / Decimal(str(total_students))
                if total_students > 0
                else Decimal("0")
            )
            below_req = total_students - meets_count

            return MonthlyReport(
                hostel_id=hostel_id,
                month=month,
                student_summaries=summaries,
                hostel_average_attendance=hostel_avg,
                total_students=total_students,
                students_meeting_requirement=meets_count,
                students_below_requirement=below_req,
            )

# --- File: D:\hostel-management-saas\app\services\attendance\attendance_service.py ---
# app/services/attendance/attendance_service.py
from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import AttendanceRepository
from app.repositories.core import (
    StudentRepository,
    HostelRepository,
    RoomRepository,
    UserRepository,
    SupervisorRepository,
)
from app.schemas.attendance.attendance_base import (
    AttendanceCreate,
    AttendanceUpdate,
)
from app.schemas.attendance.attendance_filters import AttendanceFilterParams
from app.schemas.attendance.attendance_record import (
    AttendanceRecordRequest,
    BulkAttendanceRequest,
)
from app.schemas.attendance.attendance_response import (
    AttendanceResponse,
    AttendanceDetail,
    AttendanceListItem,
    DailyAttendanceSummary,
)
from app.schemas.common.enums import AttendanceStatus, AttendanceMode
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.services.common import UnitOfWork, errors


class AttendanceService:
    """
    Core attendance service:

    - Create/update single attendance records
    - Bulk mark attendance for many students
    - Retrieve attendance detail
    - List attendance with filters
    - Daily hostel summary
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_repo(self, uow: UnitOfWork) -> AttendanceRepository:
        return uow.get_repo(AttendanceRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_response(
        self,
        a,
        *,
        hostel_name: str,
        student_name: str,
        room_number: Optional[str],
        marked_by_name: str,
    ) -> AttendanceResponse:
        return AttendanceResponse(
            id=a.id,
            created_at=a.created_at,
            updated_at=a.updated_at,
            hostel_id=a.hostel_id,
            hostel_name=hostel_name,
            student_id=a.student_id,
            student_name=student_name,
            room_number=room_number,
            attendance_date=a.attendance_date,
            check_in_time=a.check_in_time,
            check_out_time=a.check_out_time,
            status=a.status,
            is_late=a.is_late,
            late_minutes=a.late_minutes,
            marked_by=a.marked_by_id,
            marked_by_name=marked_by_name,
        )

    def _to_detail(
        self,
        a,
        *,
        hostel_name: str,
        student_name: str,
        student_email: str,
        student_phone: str,
        room_number: Optional[str],
        marked_by_name: str,
        supervisor_name: Optional[str],
    ) -> AttendanceDetail:
        return AttendanceDetail(
            id=a.id,
            created_at=a.created_at,
            updated_at=a.updated_at,
            hostel_id=a.hostel_id,
            hostel_name=hostel_name,
            student_id=a.student_id,
            student_name=student_name,
            student_email=student_email,
            student_phone=student_phone,
            room_number=room_number,
            attendance_date=a.attendance_date,
            check_in_time=a.check_in_time,
            check_out_time=a.check_out_time,
            status=a.status,
            is_late=a.is_late,
            late_minutes=a.late_minutes,
            attendance_mode=a.attendance_mode,
            marked_by=a.marked_by_id,
            marked_by_name=marked_by_name,
            supervisor_id=a.supervisor_id,
            supervisor_name=supervisor_name,
            notes=a.notes,
            location_lat=None,
            location_lng=None,
            device_info=None,
            created_at=a.created_at,
            updated_at=a.updated_at,
        )

    def _to_list_item(
        self,
        a,
        *,
        student_name: str,
        room_number: Optional[str],
        marked_by_name: str,
    ) -> AttendanceListItem:
        return AttendanceListItem(
            id=a.id,
            student_name=student_name,
            room_number=room_number,
            attendance_date=a.attendance_date,
            status=a.status,
            check_in_time=a.check_in_time,
            is_late=a.is_late,
            marked_by_name=marked_by_name,
        )

    # ------------------------------------------------------------------ #
    # Core read
    # ------------------------------------------------------------------ #
    def get_attendance(self, attendance_id: UUID) -> AttendanceDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)
            room_repo = self._get_room_repo(uow)
            user_repo = self._get_user_repo(uow)
            supervisor_repo = self._get_supervisor_repo(uow)

            a = repo.get(attendance_id)
            if a is None:
                raise errors.NotFoundError(f"Attendance {attendance_id} not found")

            hostel = hostel_repo.get(a.hostel_id)
            hostel_name = hostel.name if hostel else ""

            student = student_repo.get(a.student_id)
            if student is None or not getattr(student, "user", None):
                raise errors.NotFoundError(
                    f"Student {a.student_id} not found for attendance"
                )
            student_user = student.user
            student_name = student_user.full_name
            student_email = student_user.email
            student_phone = getattr(student_user, "phone", "")

            room_number: Optional[str] = None
            if student.room_id:
                room = room_repo.get(student.room_id)
                room_number = room.room_number if room else None

            marked_by_user = user_repo.get(a.marked_by_id)
            marked_by_name = marked_by_user.full_name if marked_by_user else ""

            supervisor_name = None
            if a.supervisor_id:
                sup = supervisor_repo.get(a.supervisor_id)
                if sup and getattr(sup, "user", None):
                    supervisor_name = sup.user.full_name

            return self._to_detail(
                a,
                hostel_name=hostel_name,
                student_name=student_name,
                student_email=student_email,
                student_phone=student_phone,
                room_number=room_number,
                marked_by_name=marked_by_name,
                supervisor_name=supervisor_name,
            )

    # ------------------------------------------------------------------ #
    # Listing
    # ------------------------------------------------------------------ #
    def list_attendance(
        self,
        params: PaginationParams,
        filters: Optional[AttendanceFilterParams] = None,
    ) -> PaginatedResponse[AttendanceListItem]:
        """
        Paginated list of attendance records with filters.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            student_repo = self._get_student_repo(uow)
            room_repo = self._get_room_repo(uow)
            user_repo = self._get_user_repo(uow)

            raw_filters: Dict[str, object] = {}
            if filters:
                if filters.hostel_id:
                    raw_filters["hostel_id"] = filters.hostel_id
                elif filters.hostel_ids:
                    raw_filters["hostel_id"] = filters.hostel_ids
                if filters.student_id:
                    raw_filters["student_id"] = filters.student_id
                elif filters.student_ids:
                    raw_filters["student_id"] = filters.student_ids
                if filters.status:
                    raw_filters["status"] = filters.status
                elif filters.statuses:
                    raw_filters["status"] = filters.statuses
                if filters.marked_by:
                    raw_filters["marked_by_id"] = filters.marked_by
                if filters.supervisor_id:
                    raw_filters["supervisor_id"] = filters.supervisor_id

            records: Sequence = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=raw_filters or None,
                order_by=[repo.model.attendance_date.desc()],  # type: ignore[attr-defined]
            )

            # Advanced filters in Python
            def _match(a) -> bool:
                if not filters:
                    return True

                if filters.date_from and a.attendance_date < filters.date_from:
                    return False
                if filters.date_to and a.attendance_date > filters.date_to:
                    return False
                if filters.late_only and not a.is_late:
                    return False
                if filters.attendance_mode and a.attendance_mode.value != filters.attendance_mode:
                    return False
                return True

            filtered = [a for a in records if _match(a)]

            # Room filter requires looking up students
            if filters and filters.room_id:
                room_id = filters.room_id
                student_room_cache: Dict[UUID, Optional[UUID]] = {}
                tmp: List = []
                for a in filtered:
                    sid = a.student_id
                    if sid not in student_room_cache:
                        st = student_repo.get(sid)
                        student_room_cache[sid] = st.room_id if st else None
                    if student_room_cache[sid] == room_id:
                        tmp.append(a)
                filtered = tmp

            total = len(filtered)
            start = params.offset
            end = start + params.limit
            page_items = filtered[start:end]

            # Map to list items
            student_cache: Dict[UUID, object] = {}
            room_cache: Dict[UUID, Optional[str]] = {}
            user_cache: Dict[UUID, str] = {}

            items: List[AttendanceListItem] = []
            for a in page_items:
                # student
                if a.student_id not in student_cache:
                    st = student_repo.get(a.student_id)
                    student_cache[a.student_id] = st
                st = student_cache[a.student_id]
                if st is not None and getattr(st, "user", None):
                    student_name = st.user.full_name
                else:
                    student_name = ""

                # room
                room_number: Optional[str] = None
                if st is not None and getattr(st, "room_id", None):
                    rid = st.room_id
                    if rid not in room_cache:
                        r = room_repo.get(rid)
                        room_cache[rid] = r.room_number if r else None
                    room_number = room_cache[rid]  # type: ignore[name-defined]

                # marked_by
                if a.marked_by_id not in user_cache:
                    u = user_repo.get(a.marked_by_id)
                    user_cache[a.marked_by_id] = u.full_name if u else ""
                marked_by_name = user_cache[a.marked_by_id]

                items.append(
                    self._to_list_item(
                        a,
                        student_name=student_name,
                        room_number=room_number,
                        marked_by_name=marked_by_name,
                    )
                )

            return PaginatedResponse[AttendanceListItem].create(
                items=items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    # ------------------------------------------------------------------ #
    # Create / update
    # ------------------------------------------------------------------ #
    def create_attendance(self, data: AttendanceCreate) -> AttendanceDetail:
        """
        Create a new attendance record.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)
            user_repo = self._get_user_repo(uow)
            room_repo = self._get_room_repo(uow)
            supervisor_repo = self._get_supervisor_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            student = student_repo.get(data.student_id)
            if student is None or not getattr(student, "user", None):
                raise errors.NotFoundError(f"Student {data.student_id} not found")
            student_user = student.user

            payload = {
                "hostel_id": data.hostel_id,
                "student_id": data.student_id,
                "attendance_date": data.attendance_date,
                "check_in_time": data.check_in_time,
                "check_out_time": data.check_out_time,
                "status": data.status,
                "is_late": data.is_late,
                "late_minutes": data.late_minutes,
                "attendance_mode": data.attendance_mode,
                "marked_by_id": data.marked_by,
                "supervisor_id": data.supervisor_id,
                "notes": data.notes,
            }
            a = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            # Map to detail
            student_name = student_user.full_name
            student_email = student_user.email
            student_phone = getattr(student_user, "phone", "")
            room_number: Optional[str] = None
            if student.room_id:
                room = room_repo.get(student.room_id)
                room_number = room.room_number if room else None

            marked_by_user = user_repo.get(a.marked_by_id)
            marked_by_name = marked_by_user.full_name if marked_by_user else ""

            supervisor_name = None
            if a.supervisor_id:
                sup = supervisor_repo.get(a.supervisor_id)
                if sup and getattr(sup, "user", None):
                    supervisor_name = sup.user.full_name

            return self._to_detail(
                a,
                hostel_name=hostel.name,
                student_name=student_name,
                student_email=student_email,
                student_phone=student_phone,
                room_number=room_number,
                marked_by_name=marked_by_name,
                supervisor_name=supervisor_name,
            )

    def record_attendance(
        self,
        req: AttendanceRecordRequest,
        *,
        marked_by: UUID,
        supervisor_id: Optional[UUID] = None,
        mode: AttendanceMode = AttendanceMode.MANUAL,
    ) -> AttendanceDetail:
        """
        Convenience wrapper to create attendance from AttendanceRecordRequest.
        """
        data = AttendanceCreate(
            hostel_id=req.hostel_id,
            student_id=req.student_id,
            attendance_date=req.attendance_date,
            check_in_time=req.check_in_time,
            check_out_time=req.check_out_time,
            status=req.status,
            is_late=req.is_late,
            late_minutes=None,
            attendance_mode=mode,
            marked_by=marked_by,
            supervisor_id=supervisor_id,
            notes=req.notes,
            location_lat=None,
            location_lng=None,
            device_info=None,
        )
        return self.create_attendance(data)

    def bulk_record_attendance(self, req: BulkAttendanceRequest) -> int:
        """
        Bulk mark attendance for many students.

        - If a record for (hostel_id, student_id, date) exists, it is updated.
        - Otherwise, a new record is created.
        """
        count = 0
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            for rec in req.student_records:
                status = rec.status or req.default_status
                existing = repo.get_multi(
                    skip=0,
                    limit=1,
                    filters={
                        "hostel_id": req.hostel_id,
                        "student_id": rec.student_id,
                        "attendance_date": req.attendance_date,
                    },
                )
                if existing:
                    a = existing[0]
                    a.status = status  # type: ignore[attr-defined]
                    a.check_in_time = rec.check_in_time  # type: ignore[attr-defined]
                    a.is_late = rec.is_late if rec.is_late is not None else a.is_late  # type: ignore[attr-defined]
                    a.marked_by_id = req.marked_by  # type: ignore[attr-defined]
                    uow.session.flush()  # type: ignore[union-attr]
                else:
                    payload = {
                        "hostel_id": req.hostel_id,
                        "student_id": rec.student_id,
                        "attendance_date": req.attendance_date,
                        "check_in_time": rec.check_in_time,
                        "check_out_time": None,
                        "status": status,
                        "is_late": rec.is_late or False,
                        "late_minutes": None,
                        "attendance_mode": AttendanceMode.MANUAL,
                        "marked_by_id": req.marked_by,
                        "supervisor_id": None,
                        "notes": rec.notes,
                    }
                    repo.create(payload)  # type: ignore[arg-type]
                count += 1

            uow.commit()
        return count

    def update_attendance(
        self,
        attendance_id: UUID,
        data: AttendanceUpdate,
    ) -> AttendanceDetail:
        """
        Update an existing attendance record.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            a = repo.get(attendance_id)
            if a is None:
                raise errors.NotFoundError(f"Attendance {attendance_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(a, field) and field != "id":
                    setattr(a, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
        return self.get_attendance(attendance_id)

    # ------------------------------------------------------------------ #
    # Daily summary
    # ------------------------------------------------------------------ #
    def get_daily_summary(self, hostel_id: UUID, day: date) -> DailyAttendanceSummary:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)
            user_repo = self._get_user_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            students = student_repo.list_for_hostel(hostel_id, status=None)
            total_students = len(students)

            records = repo.list_for_hostel_date(hostel_id, day)

            total_present = total_absent = total_late = total_on_leave = 0
            for a in records:
                if a.status == AttendanceStatus.PRESENT:
                    total_present += 1
                elif a.status == AttendanceStatus.ABSENT:
                    total_absent += 1
                elif a.status == AttendanceStatus.LATE:
                    total_late += 1
                    total_present += 1  # count as present
                elif a.status == AttendanceStatus.ON_LEAVE:
                    total_on_leave += 1

            attendance_percentage = (
                Decimal(str(total_present))
                / Decimal(str(total_students or 1))
                * 100
                if total_students > 0
                else Decimal("0")
            )

            # Pick one "marked_by" as representative
            marked_by_id: Optional[UUID] = None
            marked_at: Optional[datetime] = None
            if records:
                first = records[0]
                marked_by_id = first.marked_by_id
                marked_at = first.created_at

            marked_by_name = ""
            if marked_by_id:
                u = user_repo.get(marked_by_id)
                marked_by_name = u.full_name if u else ""

            marking_completed = total_students > 0 and len(records) >= total_students

            return DailyAttendanceSummary(
                hostel_id=hostel_id,
                hostel_name=hostel.name,
                date=day,
                total_students=total_students,
                total_present=total_present,
                total_absent=total_absent,
                total_late=total_late,
                total_on_leave=total_on_leave,
                attendance_percentage=attendance_percentage,
                marked_by=marked_by_id or UUID(int=0),
                marked_by_name=marked_by_name,
                marking_completed=marking_completed,
                marked_at=marked_at,
            )

# --- File: D:\hostel-management-saas\app\services\attendance\__init__.py ---
# app/services/attendance/__init__.py
"""
Attendance-related services.

- AttendanceService: core attendance CRUD, listing, daily summary.
- AttendanceAlertService: alert configuration and alert lifecycle.
- AttendancePolicyService: attendance policy configuration and violation checks.
- AttendanceReportService: higher-level reports (student, monthly hostel).
"""

from .attendance_service import AttendanceService
from .attendance_alert_service import AttendanceAlertService, AlertStore
from .attendance_policy_service import AttendancePolicyService, PolicyStore
from .attendance_report_service import AttendanceReportService

__all__ = [
    "AttendanceService",
    "AttendanceAlertService",
    "AlertStore",
    "AttendancePolicyService",
    "PolicyStore",
    "AttendanceReportService",
]


# ===== Folder: D:\hostel-management-saas\app\services\audit =====

# --- File: D:\hostel-management-saas\app\services\audit\admin_override_service.py ---
# app/services/audit/admin_override_service.py
from __future__ import annotations

from collections import defaultdict
from datetime import datetime
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.audit import AdminOverrideRepository
from app.repositories.core import HostelRepository, SupervisorRepository, UserRepository
from app.schemas.audit import (
    AdminOverrideCreate,
    AdminOverrideLogResponse,
    AdminOverrideDetail,
    AdminOverrideSummary,
    AdminOverrideTimelinePoint,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork, errors


class AdminOverrideAuditService:
    """
    Audit-focused service for admin overrides:

    - Record overrides (low-level)
    - List overrides for an entity
    - Fetch override detail
    - Summarize overrides over a period
    - Generate simple override timeline
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> AdminOverrideRepository:
        return uow.get_repo(AdminOverrideRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Create
    # ------------------------------------------------------------------ #
    def record_override(self, data: AdminOverrideCreate) -> AdminOverrideDetail:
        """
        Persist an AdminOverride record and return full detail.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)

            payload = data.model_dump()
            rec = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            admin_user = user_repo.get(rec.admin_id)
            admin_name = admin_user.full_name if admin_user else None

            sup_name = None
            if rec.supervisor_id:
                sup = sup_repo.get(rec.supervisor_id)
                if sup and getattr(sup, "user", None):
                    sup_name = sup.user.full_name

            hostel = hostel_repo.get(rec.hostel_id)
            hostel_name = hostel.name if hostel else None

            return AdminOverrideDetail(
                id=rec.id,
                created_at=rec.created_at,
                updated_at=rec.created_at,
                admin_id=rec.admin_id,
                admin_name=admin_name,
                supervisor_id=rec.supervisor_id,
                supervisor_name=sup_name,
                hostel_id=rec.hostel_id,
                hostel_name=hostel_name,
                override_type=rec.override_type,
                entity_type=rec.entity_type,
                entity_id=rec.entity_id,
                reason=rec.reason,
                original_action=rec.original_action,
                override_action=rec.override_action,
                created_at=rec.created_at,
            )

    # ------------------------------------------------------------------ #
    # Read
    # ------------------------------------------------------------------ #
    def list_overrides_for_entity(
        self,
        *,
        entity_type: str,
        entity_id: UUID,
    ) -> List[AdminOverrideLogResponse]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            recs = repo.list_for_entity(entity_type=entity_type, entity_id=entity_id)

            return [
                AdminOverrideLogResponse(
                    id=r.id,
                    created_at=r.created_at,
                    updated_at=r.created_at,
                    admin_id=r.admin_id,
                    admin_name=None,
                    supervisor_id=r.supervisor_id,
                    supervisor_name=None,
                    hostel_id=r.hostel_id,
                    hostel_name=None,
                    override_type=r.override_type,
                    entity_type=r.entity_type,
                    entity_id=r.entity_id,
                    reason=r.reason,
                    created_at=r.created_at,
                )
                for r in recs
            ]

    def get_override_detail(self, override_id: UUID) -> AdminOverrideDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)

            r = repo.get(override_id)
            if r is None:
                raise errors.NotFoundError(f"AdminOverride {override_id} not found")

            admin_user = user_repo.get(r.admin_id)
            admin_name = admin_user.full_name if admin_user else None

            sup_name = None
            if r.supervisor_id:
                sup = sup_repo.get(r.supervisor_id)
                if sup and getattr(sup, "user", None):
                    sup_name = sup.user.full_name

            hostel = hostel_repo.get(r.hostel_id)
            hostel_name = hostel.name if hostel else None

            return AdminOverrideDetail(
                id=r.id,
                created_at=r.created_at,
                updated_at=r.created_at,
                admin_id=r.admin_id,
                admin_name=admin_name,
                supervisor_id=r.supervisor_id,
                supervisor_name=sup_name,
                hostel_id=r.hostel_id,
                hostel_name=hostel_name,
                override_type=r.override_type,
                entity_type=r.entity_type,
                entity_id=r.entity_id,
                reason=r.reason,
                original_action=r.original_action,
                override_action=r.override_action,
                created_at=r.created_at,
            )

    # ------------------------------------------------------------------ #
    # Summary & timeline
    # ------------------------------------------------------------------ #
    def get_summary(
        self,
        *,
        period: DateRangeFilter,
        supervisor_id: Optional[UUID] = None,
        hostel_id: Optional[UUID] = None,
    ) -> AdminOverrideSummary:
        """
        Build AdminOverrideSummary for given period & optional scope.
        """
        if not (period.start_date and period.end_date):
            raise errors.ValidationError(
                "Both start_date and end_date are required for override summary"
            )

        start_dt = datetime.combine(period.start_date, datetime.min.time())
        end_dt = datetime.combine(period.end_date, datetime.max.time())

        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            base_filters: Dict[str, object] = {}
            if supervisor_id:
                base_filters["supervisor_id"] = supervisor_id
            if hostel_id:
                base_filters["hostel_id"] = hostel_id

            recs = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=base_filters or None,
            )

            logs = [
                r for r in recs if start_dt <= r.created_at <= end_dt
            ]

            total_overrides = len(logs)
            overrides_by_type: Dict[str, int] = defaultdict(int)
            overrides_by_admin: Dict[UUID, int] = defaultdict(int)

            for r in logs:
                overrides_by_type[r.override_type] += 1
                overrides_by_admin[r.admin_id] += 1

        return AdminOverrideSummary(
            period_start=start_dt,
            period_end=end_dt,
            supervisor_id=supervisor_id,
            hostel_id=hostel_id,
            total_overrides=total_overrides,
            overrides_by_type=dict(overrides_by_type),
            overrides_by_admin=dict(overrides_by_admin),
            override_rate_for_supervisor=None,
        )

    def get_timeline(
        self,
        *,
        period: DateRangeFilter,
        supervisor_id: Optional[UUID] = None,
        hostel_id: Optional[UUID] = None,
    ) -> List[AdminOverrideTimelinePoint]:
        """
        Simple date-bucketed override count timeline.
        """
        if not (period.start_date and period.end_date):
            raise errors.ValidationError(
                "Both start_date and end_date are required for override timeline"
            )

        start_dt = datetime.combine(period.start_date, datetime.min.time())
        end_dt = datetime.combine(period.end_date, datetime.max.time())

        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            base_filters: Dict[str, object] = {}
            if supervisor_id:
                base_filters["supervisor_id"] = supervisor_id
            if hostel_id:
                base_filters["hostel_id"] = hostel_id

            recs = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=base_filters or None,
            )

            buckets: Dict[str, int] = defaultdict(int)
            for r in recs:
                if r.created_at < start_dt or r.created_at > end_dt:
                    continue
                label = r.created_at.date().isoformat()
                buckets[label] += 1

        return [
            AdminOverrideTimelinePoint(
                bucket_label=label,
                override_count=count,
            )
            for label, count in sorted(buckets.items())
        ]

# --- File: D:\hostel-management-saas\app\services\audit\audit_log_service.py ---
# app/services/audit/audit_log_service.py
from __future__ import annotations

from collections import defaultdict
from datetime import datetime
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.audit import AuditLogRepository
from app.repositories.core import UserRepository
from app.schemas.audit import (
    AuditLogCreate,
    AuditLogResponse,
    AuditLogDetail,
    AuditFilterParams,
    AuditReport,
    AuditSummary,
    UserActivitySummary,
    EntityChangeHistory,
)
from app.schemas.audit.audit_reports import EntityChangeSummary
from app.schemas.common.enums import AuditActionCategory, UserRole
from app.schemas.common.filters import DateRangeFilter
from app.schemas.common.pagination import PaginatedResponse
from app.services.common import UnitOfWork, errors


class AuditLogService:
    """
    Generic audit log service:

    - Create audit log entries
    - List logs with filters + pagination
    - Fetch log detail
    - Build high-level AuditReport (summary + per-entity summaries)
    - Build change history for a specific entity
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_repo(self, uow: UnitOfWork) -> AuditLogRepository:
        return uow.get_repo(AuditLogRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_response(self, log) -> AuditLogResponse:
        return AuditLogResponse(
            id=log.id,
            created_at=log.created_at,
            updated_at=log.created_at,
            user_id=log.user_id,
            user_role=log.user_role,
            action_type=log.action_type,
            action_category=log.action_category,
            entity_type=log.entity_type,
            entity_id=log.entity_id,
            hostel_id=log.hostel_id,
            description=log.description,
            ip_address=log.ip_address,
        )

    def _to_detail(self, log) -> AuditLogDetail:
        return AuditLogDetail(
            id=log.id,
            created_at=log.created_at,
            updated_at=log.created_at,
            user_id=log.user_id,
            user_role=log.user_role,
            action_type=log.action_type,
            action_category=log.action_category,
            entity_type=log.entity_type,
            entity_id=log.entity_id,
            hostel_id=log.hostel_id,
            description=log.description,
            old_values=log.old_values,
            new_values=log.new_values,
            ip_address=log.ip_address,
            user_agent=log.user_agent,
            request_id=log.request_id,
            created_at=log.created_at,
        )

    # ------------------------------------------------------------------ #
    # Create / read
    # ------------------------------------------------------------------ #
    def log_action(self, data: AuditLogCreate) -> AuditLogResponse:
        """
        Persist a new audit log entry.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            payload = data.model_dump()
            # created_at has default in model; rely on DB default or pass explicitly
            log = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()
            return self._to_response(log)

    def get_log(self, log_id: UUID) -> AuditLogDetail:
        """
        Fetch a single audit log entry.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            log = repo.get(log_id)
            if log is None:
                raise errors.NotFoundError(f"AuditLog {log_id} not found")
            return self._to_detail(log)

    # ------------------------------------------------------------------ #
    # Listing with filters
    # ------------------------------------------------------------------ #
    def list_logs(
        self,
        filters: AuditFilterParams,
    ) -> PaginatedResponse[AuditLogResponse]:
        """
        List audit logs with filters and pagination.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            raw_filters: Dict[str, object] = {}
            if filters.user_id:
                raw_filters["user_id"] = filters.user_id
            if filters.user_role:
                raw_filters["user_role"] = filters.user_role
            if filters.hostel_id:
                raw_filters["hostel_id"] = filters.hostel_id
            if filters.entity_type:
                raw_filters["entity_type"] = filters.entity_type
            if filters.entity_id:
                raw_filters["entity_id"] = filters.entity_id
            if filters.action_type:
                raw_filters["action_type"] = filters.action_type
            if filters.action_category:
                raw_filters["action_category"] = filters.action_category
            if filters.request_id:
                raw_filters["request_id"] = filters.request_id

            records = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=raw_filters or None,
                order_by=[repo.model.created_at.desc()],  # type: ignore[attr-defined]
            )

            # Advanced datetime_range filter
            def _in_range(log) -> bool:
                if not filters.datetime_range:
                    return True
                rng = filters.datetime_range
                created = log.created_at
                if rng.start and created < rng.start:
                    return False
                if rng.end and created > rng.end:
                    return False
                return True

            filtered = [l for l in records if _in_range(l)]

            # Pagination
            page = filters.page
            page_size = filters.page_size
            offset = (page - 1) * page_size
            page_items = filtered[offset : offset + page_size]

            items = [self._to_response(l) for l in page_items]

            return PaginatedResponse[AuditLogResponse].create(
                items=items,
                total_items=len(filtered),
                page=page,
                page_size=page_size,
            )

    # ------------------------------------------------------------------ #
    # Reporting
    # ------------------------------------------------------------------ #
    def build_report(
        self,
        period: DateRangeFilter,
        *,
        hostel_id: Optional[UUID] = None,
    ) -> AuditReport:
        """
        Build a high-level AuditReport for the given period (and optional hostel).
        """
        if not (period.start_date and period.end_date):
            raise errors.ValidationError(
                "Both start_date and end_date are required for audit report"
            )

        start_dt = datetime.combine(period.start_date, datetime.min.time())
        end_dt = datetime.combine(period.end_date, datetime.max.time())

        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            user_repo = self._get_user_repo(uow)

            base_filters: Dict[str, object] = {}
            if hostel_id:
                base_filters["hostel_id"] = hostel_id

            records = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=base_filters or None,
                order_by=[repo.model.created_at.asc()],  # type: ignore[attr-defined]
            )

            # Filter by period
            logs = [
                l for l in records if start_dt <= l.created_at <= end_dt
            ]

            total_events = len(logs)

            events_by_category: Dict[AuditActionCategory, int] = defaultdict(int)
            events_by_user_role: Dict[UserRole, int] = defaultdict(int)
            user_stats: Dict[UUID, Dict[str, object]] = {}

            entity_summaries_map: Dict[str, EntityChangeSummary] = {}

            for l in logs:
                events_by_category[l.action_category] += 1
                if l.user_role:
                    events_by_user_role[l.user_role] += 1

                # User aggregation
                if l.user_id:
                    if l.user_id not in user_stats:
                        user_stats[l.user_id] = {
                            "role": l.user_role,
                            "total": 0,
                            "by_cat": defaultdict(int),
                        }
                    us = user_stats[l.user_id]
                    us["total"] = int(us["total"]) + 1
                    us["by_cat"][l.action_category] += 1  # type: ignore[index]

                # Entity summaries (by entity_type)
                etype = l.entity_type or "unknown"
                if etype not in entity_summaries_map:
                    entity_summaries_map[etype] = EntityChangeSummary(
                        entity_type=etype,
                        change_count=0,
                        last_change_at=l.created_at,
                    )
                es = entity_summaries_map[etype]
                es.change_count += 1
                if l.created_at > es.last_change_at:
                    es.last_change_at = l.created_at

            # Build UserActivitySummary list
            user_summaries: List[UserActivitySummary] = []
            for uid, data in user_stats.items():
                role = data["role"]
                total = data["total"]
                by_cat = data["by_cat"]  # type: ignore[assignment]

                user = user_repo.get(uid)
                user_name = user.full_name if user else None

                user_summaries.append(
                    UserActivitySummary(
                        user_id=uid,
                        user_name=user_name,
                        user_role=role,
                        total_events=total,
                        events_by_category=dict(by_cat),
                    )
                )

            # Sort top users by total events
            user_summaries.sort(key=lambda s: s.total_events, reverse=True)

            summary = AuditSummary(
                period=period,
                total_events=total_events,
                events_by_category=dict(events_by_category),
                events_by_user_role=dict(events_by_user_role),
                top_users_by_events=user_summaries[:10],
            )

            entity_summaries = list(entity_summaries_map.values())

        return AuditReport(
            generated_at=datetime.utcnow(),
            period=period,
            summary=summary,
            entity_summaries=entity_summaries,
        )

    # ------------------------------------------------------------------ #
    # Entity history
    # ------------------------------------------------------------------ #
    def get_entity_history(
        self,
        *,
        entity_type: str,
        entity_id: UUID,
    ) -> EntityChangeHistory:
        """
        Build an EntityChangeHistory for a specific entity instance.
        """
        from app.schemas.audit.audit_reports import EntityChangeRecord

        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            user_repo = self._get_user_repo(uow)

            logs = repo.list_for_entity(
                entity_type=entity_type,
                entity_id=entity_id,
            )

            changes: List[EntityChangeRecord] = []
            for l in logs:
                user_name = None
                if l.user_id:
                    u = user_repo.get(l.user_id)
                    user_name = u.full_name if u else None

                changes.append(
                    EntityChangeRecord(
                        log_id=l.id,
                        action_type=l.action_type,
                        description=l.description,
                        old_values=l.old_values,
                        new_values=l.new_values,
                        changed_by=l.user_id,
                        changed_by_name=user_name,
                        changed_at=l.created_at,
                    )
                )

        # Ensure chronological order
        changes.sort(key=lambda c: c.changed_at)

        return EntityChangeHistory(
            entity_type=entity_type,
            entity_id=entity_id,
            changes=changes,
        )

# --- File: D:\hostel-management-saas\app\services\audit\entity_history_service.py ---
# app/services/audit/entity_history_service.py
from __future__ import annotations

from typing import Callable, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.audit import AuditLogRepository
from app.schemas.audit.audit_reports import (
    EntityChangeHistory,
    EntityChangeRecord,
)
from app.services.common import UnitOfWork
from app.repositories.core import UserRepository


class EntityHistoryService:
    """
    Thin wrapper around AuditLogRepository focused on per-entity history.

    - Get complete change history for one entity instance.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_audit_repo(self, uow: UnitOfWork) -> AuditLogRepository:
        return uow.get_repo(AuditLogRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def get_history(
        self,
        *,
        entity_type: str,
        entity_id: UUID,
    ) -> EntityChangeHistory:
        with UnitOfWork(self._session_factory) as uow:
            audit_repo = self._get_audit_repo(uow)
            user_repo = self._get_user_repo(uow)

            logs = audit_repo.list_for_entity(
                entity_type=entity_type,
                entity_id=entity_id,
            )

            records: List[EntityChangeRecord] = []
            for l in logs:
                user_name = None
                if l.user_id:
                    u = user_repo.get(l.user_id)
                    user_name = u.full_name if u else None

                records.append(
                    EntityChangeRecord(
                        log_id=l.id,
                        action_type=l.action_type,
                        description=l.description,
                        old_values=l.old_values,
                        new_values=l.new_values,
                        changed_by=l.user_id,
                        changed_by_name=user_name,
                        changed_at=l.created_at,
                    )
                )

        records.sort(key=lambda r: r.changed_at)
        return EntityChangeHistory(
            entity_type=entity_type,
            entity_id=entity_id,
            changes=records,
        )

# --- File: D:\hostel-management-saas\app\services\audit\supervisor_activity_service.py ---
# app/services/audit/supervisor_activity_service.py
from __future__ import annotations

from collections import defaultdict
from datetime import datetime
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.audit import SupervisorActivityRepository
from app.repositories.core import HostelRepository, SupervisorRepository
from app.schemas.audit import (
    SupervisorActivityCreate,
    SupervisorActivityLogResponse,
    SupervisorActivityDetail,
    SupervisorActivityFilter,
    SupervisorActivitySummary,
    SupervisorActivityTimelinePoint,
)
from app.schemas.common.pagination import PaginatedResponse
from app.services.common import UnitOfWork, errors


class SupervisorActivityService:
    """
    Supervisor activity logging and reporting:

    - Log supervisor actions
    - List actions with filters + pagination
    - Fetch detailed entry
    - Summarize actions over a period (per category/type + timeline)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> SupervisorActivityRepository:
        return uow.get_repo(SupervisorActivityRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_log_response(
        self,
        rec,
        *,
        supervisor_name: Optional[str],
        hostel_name: Optional[str],
    ) -> SupervisorActivityLogResponse:
        return SupervisorActivityLogResponse(
            id=rec.id,
            created_at=rec.created_at,
            updated_at=rec.created_at,
            supervisor_id=rec.supervisor_id,
            supervisor_name=supervisor_name,
            hostel_id=rec.hostel_id,
            hostel_name=hostel_name,
            action_type=rec.action_type,
            action_category=rec.action_category,
            entity_type=rec.entity_type,
            entity_id=rec.entity_id,
            action_description=rec.action_description,
            created_at=rec.created_at,
            ip_address=rec.ip_address,
            user_agent=rec.user_agent,
        )

    def _to_detail(
        self,
        rec,
        *,
        supervisor_name: Optional[str],
        hostel_name: Optional[str],
    ) -> SupervisorActivityDetail:
        return SupervisorActivityDetail(
            id=rec.id,
            created_at=rec.created_at,
            updated_at=rec.created_at,
            supervisor_id=rec.supervisor_id,
            supervisor_name=supervisor_name,
            hostel_id=rec.hostel_id,
            hostel_name=hostel_name,
            action_type=rec.action_type,
            action_category=rec.action_category,
            entity_type=rec.entity_type,
            entity_id=rec.entity_id,
            action_description=rec.action_description,
            metadata=rec.metadata or {},
            ip_address=rec.ip_address,
            user_agent=rec.user_agent,
            created_at=rec.created_at,
        )

    # ------------------------------------------------------------------ #
    # Log activity
    # ------------------------------------------------------------------ #
    def log_activity(self, data: SupervisorActivityCreate) -> SupervisorActivityLogResponse:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            payload = data.model_dump()
            rec = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            sup = sup_repo.get(rec.supervisor_id)
            supervisor_name = (
                sup.user.full_name
                if sup and getattr(sup, "user", None)
                else None
            )

            hostel = hostel_repo.get(rec.hostel_id)
            hostel_name = hostel.name if hostel else None

            return self._to_log_response(
                rec,
                supervisor_name=supervisor_name,
                hostel_name=hostel_name,
            )

    # ------------------------------------------------------------------ #
    # Read operations
    # ------------------------------------------------------------------ #
    def get_activity(self, activity_id: UUID) -> SupervisorActivityDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            rec = repo.get(activity_id)
            if rec is None:
                raise errors.NotFoundError(
                    f"SupervisorActivity {activity_id} not found"
                )

            sup = sup_repo.get(rec.supervisor_id)
            supervisor_name = (
                sup.user.full_name
                if sup and getattr(sup, "user", None)
                else None
            )

            hostel = hostel_repo.get(rec.hostel_id)
            hostel_name = hostel.name if hostel else None

            return self._to_detail(
                rec,
                supervisor_name=supervisor_name,
                hostel_name=hostel_name,
            )

    def list_activities(
        self,
        filters: SupervisorActivityFilter,
    ) -> PaginatedResponse[SupervisorActivityLogResponse]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            raw_filters: Dict[str, object] = {}
            if filters.supervisor_id:
                raw_filters["supervisor_id"] = filters.supervisor_id
            if filters.hostel_id:
                raw_filters["hostel_id"] = filters.hostel_id
            if filters.action_type:
                raw_filters["action_type"] = filters.action_type
            if filters.action_category:
                raw_filters["action_category"] = filters.action_category
            if filters.entity_type:
                raw_filters["entity_type"] = filters.entity_type
            if filters.entity_id:
                raw_filters["entity_id"] = filters.entity_id

            records = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=raw_filters or None,
                order_by=[repo.model.created_at.desc()],  # type: ignore[attr-defined]
            )

            # datetime_range filtering
            def _in_range(rec) -> bool:
                if not filters.datetime_range:
                    return True
                dr = filters.datetime_range
                created = rec.created_at
                if dr.start and created < dr.start:
                    return False
                if dr.end and created > dr.end:
                    return False
                return True

            filtered = [r for r in records if _in_range(r)]

            page = filters.page
            page_size = filters.page_size
            offset = (page - 1) * page_size
            page_records = filtered[offset : offset + page_size]

            # Cache names
            sup_cache: Dict[UUID, Optional[str]] = {}
            hostel_cache: Dict[UUID, Optional[str]] = {}

            items: List[SupervisorActivityLogResponse] = []
            for r in page_records:
                if r.supervisor_id not in sup_cache:
                    sup = sup_repo.get(r.supervisor_id)
                    sup_cache[r.supervisor_id] = (
                        sup.user.full_name
                        if sup and getattr(sup, "user", None)
                        else None
                    )
                supervisor_name = sup_cache[r.supervisor_id]

                if r.hostel_id not in hostel_cache:
                    h = hostel_repo.get(r.hostel_id)
                    hostel_cache[r.hostel_id] = h.name if h else None
                hostel_name = hostel_cache[r.hostel_id]

                items.append(
                    self._to_log_response(
                        r,
                        supervisor_name=supervisor_name,
                        hostel_name=hostel_name,
                    )
                )

            return PaginatedResponse[SupervisorActivityLogResponse].create(
                items=items,
                total_items=len(filtered),
                page=page,
                page_size=page_size,
            )

    # ------------------------------------------------------------------ #
    # Summary
    # ------------------------------------------------------------------ #
    def get_summary(
        self,
        filters: SupervisorActivityFilter,
    ) -> SupervisorActivitySummary:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            raw_filters: Dict[str, object] = {}
            if filters.supervisor_id:
                raw_filters["supervisor_id"] = filters.supervisor_id
            if filters.hostel_id:
                raw_filters["hostel_id"] = filters.hostel_id

            records = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=raw_filters or None,
                order_by=[repo.model.created_at.asc()],  # type: ignore[attr-defined]
            )

            # datetime_range filter
            logs: List = []
            start = None
            end = None
            if filters.datetime_range:
                start = filters.datetime_range.start
                end = filters.datetime_range.end

            for r in records:
                if start and r.created_at < start:
                    continue
                if end and r.created_at > end:
                    continue
                logs.append(r)

            total_actions = len(logs)
            actions_by_category: Dict[str, int] = defaultdict(int)
            actions_by_type: Dict[str, int] = defaultdict(int)
            timeline_map: Dict[str, int] = defaultdict(int)

            for r in logs:
                actions_by_category[r.action_category] += 1
                actions_by_type[r.action_type] += 1
                bucket = r.created_at.date().isoformat()
                timeline_map[bucket] += 1

            # Supervisor / hostel names
            sup = (
                sup_repo.get(filters.supervisor_id)
                if filters.supervisor_id
                else None
            )
            supervisor_name = (
                sup.user.full_name
                if sup and getattr(sup, "user", None)
                else None
            )

            hostel = (
                hostel_repo.get(filters.hostel_id)
                if filters.hostel_id
                else None
            )
            hostel_name = hostel.name if hostel else None

            # Period
            if start and end:
                period_start = start
                period_end = end
            elif logs:
                period_start = logs[0].created_at
                period_end = logs[-1].created_at
            else:
                # No logs; default to now
                now = self._now()
                period_start = now
                period_end = now

            timeline: List[SupervisorActivityTimelinePoint] = [
                SupervisorActivityTimelinePoint(
                    bucket_label=day,
                    action_count=count,
                )
                for day, count in sorted(timeline_map.items())
            ]

            return SupervisorActivitySummary(
                supervisor_id=filters.supervisor_id or UUID(int=0),
                supervisor_name=supervisor_name,
                hostel_id=filters.hostel_id or UUID(int=0),
                hostel_name=hostel_name,
                period_start=period_start,
                period_end=period_end,
                total_actions=total_actions,
                actions_by_category=dict(actions_by_category),
                actions_by_type=dict(actions_by_type),
                timeline=timeline,
            )

# --- File: D:\hostel-management-saas\app\services\audit\__init__.py ---
# app/services/audit/__init__.py
"""
Audit & logging services.

- AuditLogService: core audit log creation, listing, reports, entity history.
- EntityHistoryService: focused per-entity history using audit logs.
- SupervisorActivityService: supervisor activity logging and summaries.
- AdminOverrideAuditService: override logging & summaries (audit perspective).
"""

from .audit_log_service import AuditLogService
from .entity_history_service import EntityHistoryService
from .supervisor_activity_service import SupervisorActivityService
from .admin_override_service import AdminOverrideAuditService

__all__ = [
    "AuditLogService",
    "EntityHistoryService",
    "SupervisorActivityService",
    "AdminOverrideAuditService",
]


# ===== Folder: D:\hostel-management-saas\app\services\auth =====

# --- File: D:\hostel-management-saas\app\services\auth\auth_service.py ---
# app/services/auth/auth_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import UserRepository
from app.schemas.auth.login import (
    LoginRequest,
    PhoneLoginRequest,
    LoginResponse,
    UserLoginInfo,
)
from app.schemas.auth.token import (
    RefreshTokenRequest,
    RefreshTokenResponse,
)
from app.schemas.common.enums import UserRole
from app.services.common import UnitOfWork, security, errors
from app.services.users import UserActivityService


class AuthService:
    """
    Authentication service:

    - Email/password login
    - Phone/password login
    - Refresh token handling

    This service assumes:
    - User model has a password hash column named `password_hash` or `hashed_password`.
    - Passwords are stored using the same hashing scheme as `security.hash_password`.
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        jwt_settings: security.JWTSettings,
        user_activity_service: UserActivityService | None = None,
    ) -> None:
        self._session_factory = session_factory
        self._jwt_settings = jwt_settings
        self._user_activity = user_activity_service

    # ------------------------------------------------------------------ #
    # Internal helpers
    # ------------------------------------------------------------------ #
    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def _get_user_password_hash(self, user) -> str:
        """
        Extract the password hash from the User model.

        Adjust this helper to match your actual column name.
        """
        pwd_hash = getattr(user, "password_hash", None) or getattr(
            user, "hashed_password", None
        )
        if not pwd_hash:
            raise errors.ServiceError(
                "User model is missing password hash. "
                "Add a 'password_hash' (or 'hashed_password') column."
            )
        return pwd_hash

    def _build_user_login_info(self, user) -> UserLoginInfo:
        return UserLoginInfo(
            id=user.id,
            email=user.email,
            full_name=user.full_name,
            role=user.user_role,
            is_email_verified=user.is_email_verified,
            is_phone_verified=user.is_phone_verified,
            profile_image_url=user.profile_image_url,
        )

    # ------------------------------------------------------------------ #
    # Login
    # ------------------------------------------------------------------ #
    def login(
        self,
        data: LoginRequest,
        *,
        ip_address: str | None = None,
        user_agent: str | None = None,
    ) -> LoginResponse:
        """
        Email/password login.

        Raises:
        - ValidationError on invalid credentials
        - NotFoundError if user not found (masked as ValidationError)
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_user_repo(uow)
            user = repo.get_by_email(data.email)

            # Do not leak whether email exists; generic error
            if user is None or not user.is_active:
                raise errors.ValidationError("Invalid email or password")

            if not security.verify_password(
                data.password,
                self._get_user_password_hash(user),
            ):
                raise errors.ValidationError("Invalid email or password")

            # Update last_login_at
            user.last_login_at = self._now()  # type: ignore[attr-defined]
            uow.session.flush()  # type: ignore[union-attr]

            # Issue tokens
            access_token = security.create_access_token(
                subject=user.id,
                email=user.email,
                role=user.user_role,
                jwt_settings=self._jwt_settings,
            )
            refresh_token = security.create_refresh_token(
                subject=user.id,
                jwt_settings=self._jwt_settings,
            )

            if self._user_activity:
                self._user_activity.log_login(
                    user_id=user.id,
                    ip_address=ip_address,
                    user_agent=user_agent,
                )

            # Access token TTL in seconds
            expires_in = self._jwt_settings.access_token_expires_minutes * 60

            return LoginResponse(
                access_token=access_token,
                refresh_token=refresh_token,
                token_type="bearer",
                expires_in=expires_in,
                user=self._build_user_login_info(user),
            )

    def login_with_phone(
        self,
        data: PhoneLoginRequest,
        *,
        ip_address: str | None = None,
        user_agent: str | None = None,
    ) -> LoginResponse:
        """
        Phone/password login.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_user_repo(uow)
            user = repo.get_by_phone(data.phone)

            if user is None or not user.is_active:
                raise errors.ValidationError("Invalid phone or password")

            if not security.verify_password(
                data.password,
                self._get_user_password_hash(user),
            ):
                raise errors.ValidationError("Invalid phone or password")

            user.last_login_at = self._now()  # type: ignore[attr-defined]
            uow.session.flush()  # type: ignore[union-attr]

            access_token = security.create_access_token(
                subject=user.id,
                email=user.email,
                role=user.user_role,
                jwt_settings=self._jwt_settings,
            )
            refresh_token = security.create_refresh_token(
                subject=user.id,
                jwt_settings=self._jwt_settings,
            )

            if self._user_activity:
                self._user_activity.log_login(
                    user_id=user.id,
                    ip_address=ip_address,
                    user_agent=user_agent,
                )

            expires_in = self._jwt_settings.access_token_expires_minutes * 60

            return LoginResponse(
                access_token=access_token,
                refresh_token=refresh_token,
                token_type="bearer",
                expires_in=expires_in,
                user=self._build_user_login_info(user),
            )

    # ------------------------------------------------------------------ #
    # Token refresh
    # ------------------------------------------------------------------ #
    def refresh_token(self, data: RefreshTokenRequest) -> RefreshTokenResponse:
        """
        Given a refresh token, issue a new access (and refresh) token.

        This implementation is stateless (no server-side token store or
        revocation list). For production security, consider:
        - Saving refresh-token jti in DB or cache;
        - Supporting logout/revocation; etc.
        """
        try:
            payload = security.decode_token(data.refresh_token, self._jwt_settings)
        except security.TokenDecodeError:
            raise errors.ValidationError("Invalid refresh token")

        if payload.get("type") != "refresh":
            raise errors.ValidationError("Invalid token type for refresh")

        user_id_str = payload.get("user_id") or payload.get("sub")
        if not user_id_str:
            raise errors.ValidationError("Invalid refresh token payload")

        user_id = UUID(user_id_str)

        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_user_repo(uow)
            user = repo.get(user_id)
            if user is None or not user.is_active:
                raise errors.NotFoundError("User not found or inactive")

            access_token = security.create_access_token(
                subject=user.id,
                email=user.email,
                role=user.user_role,
                jwt_settings=self._jwt_settings,
            )
            new_refresh_token = security.create_refresh_token(
                subject=user.id,
                jwt_settings=self._jwt_settings,
            )

            expires_in = self._jwt_settings.access_token_expires_minutes * 60

            return RefreshTokenResponse(
                access_token=access_token,
                refresh_token=new_refresh_token,
                token_type="bearer",
                expires_in=expires_in,
            )

# --- File: D:\hostel-management-saas\app\services\auth\context_service.py ---
# app/services/auth/context_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Protocol, Optional, List
from uuid import UUID

from app.schemas.admin import (
    HostelContext,
    HostelSwitchRequest,
    ActiveHostelResponse,
    ContextHistory,
    ContextSwitch,
)
from app.services.common import errors


class ContextStore(Protocol):
    """
    Abstract store for admin's active hostel context and history.

    Implementations can use Redis, DB tables, etc.
    """

    def get_active_hostel(self, admin_id: UUID) -> Optional[dict]: ...
    def set_active_hostel(self, admin_id: UUID, context: dict) -> None: ...
    def add_switch_record(self, admin_id: UUID, record: dict) -> None: ...
    def list_switches(self, admin_id: UUID) -> List[dict]: ...


class ContextService:
    """
    Manages the current "active hostel" context for multi-hostel admins.
    """

    def __init__(self, store: ContextStore) -> None:
        self._store = store

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def get_active_context(self, admin_id: UUID) -> Optional[HostelContext]:
        record = self._store.get_active_hostel(admin_id)
        if not record:
            return None
        return HostelContext.model_validate(record)

    def switch_hostel(
        self,
        admin_id: UUID,
        req: HostelSwitchRequest,
        *,
        hostel_name: str,
        hostel_city: str,
        permission_level: str,
    ) -> ActiveHostelResponse:
        """
        Switch active hostel for an admin.

        Caller is responsible for validating that the admin has access to
        the requested hostel and retrieving hostel/permission metadata.
        """
        now = self._now()
        prev = self._store.get_active_hostel(admin_id)
        previous_hostel_id = prev.get("active_hostel_id") if prev else None

        context = {
            "admin_id": admin_id,
            "active_hostel_id": req.hostel_id,
            "hostel_name": hostel_name,
            "hostel_city": hostel_city,
            "permission_level": permission_level,
            "context_started_at": now,
            "last_accessed_at": now,
            "total_students": 0,
            "occupancy_percentage": 0,
            "pending_tasks": 0,
        }
        self._store.set_active_hostel(admin_id, context)

        # Record switch in history
        switch_record = {
            "from_hostel_id": previous_hostel_id,
            "from_hostel_name": prev.get("hostel_name") if prev else None,
            "to_hostel_id": req.hostel_id,
            "to_hostel_name": hostel_name,
            "switched_at": now,
            "session_duration_minutes": None,
        }
        self._store.add_switch_record(admin_id, switch_record)

        return ActiveHostelResponse(
            admin_id=admin_id,
            previous_hostel_id=previous_hostel_id,
            active_hostel_id=req.hostel_id,
            hostel_name=hostel_name,
            permission_level=permission_level,
            permissions={},
            switched_at=now,
            message="Switched active hostel successfully",
        )

    def get_context_history(self, admin_id: UUID) -> ContextHistory:
        records = self._store.list_switches(admin_id)
        switches = [ContextSwitch.model_validate(r) for r in records]
        return ContextHistory(admin_id=admin_id, switches=switches)

# --- File: D:\hostel-management-saas\app\services\auth\otp_service.py ---
# app/services/auth/otp_service.py
from __future__ import annotations

from datetime import datetime, timedelta, timezone
from typing import Protocol, Optional
from uuid import UUID

from app.schemas.auth.otp import (
    OTPGenerateRequest,
    OTPVerifyRequest,
    OTPResponse,
    OTPVerifyResponse,
)
from app.schemas.common.enums import OTPType
from app.services.common import errors


class OTPStore(Protocol):
    """
    Abstract storage for OTP codes.

    Implementations can use Redis, a database table, in-memory cache, etc.
    """

    def save_otp(
        self,
        *,
        key: str,
        code: str,
        otp_type: OTPType,
        expires_at: datetime,
        max_attempts: int,
    ) -> None: ...

    def get_otp(self, key: str, otp_type: OTPType) -> Optional[dict]: ...

    def delete_otp(self, key: str, otp_type: OTPType) -> None: ...


class OTPService:
    """
    OTP generation & verification.

    This service does NOT decide how to send the OTP (email/SMS); it only:
    - generates codes;
    - stores them via an OTPStore;
    - verifies codes on request.
    """

    def __init__(self, store: OTPStore, ttl_seconds: int = 300, max_attempts: int = 3):
        self._store = store
        self._ttl_seconds = ttl_seconds
        self._max_attempts = max_attempts

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def _make_key(self, *, user_id: UUID | None, email: str | None, phone: str | None) -> str:
        if user_id:
            return f"user:{user_id}"
        if email:
            return f"email:{email.lower()}"
        if phone:
            return f"phone:{phone}"
        # Fallback; should not generally happen if validation is correct
        raise errors.ValidationError("OTP request missing identifier")

    # ------------------------------------------------------------------ #
    # Generate
    # ------------------------------------------------------------------ #
    def generate(self, data: OTPGenerateRequest) -> OTPResponse:
        """
        Generate an OTP and store it.

        NOTE: This method does not send the OTP; caller should trigger
        notification_service.email/sms, etc.
        """
        key = self._make_key(
            user_id=data.user_id,
            email=data.email,
            phone=data.phone,
        )

        # Simple numeric 6-digit OTP
        import secrets

        code = "".join(str(secrets.randbelow(10)) for _ in range(6))
        expires_at = self._now() + timedelta(seconds=self._ttl_seconds)

        self._store.save_otp(
            key=key,
            code=code,
            otp_type=data.otp_type,
            expires_at=expires_at,
            max_attempts=self._max_attempts,
        )

        # Masked contact
        if data.email:
            sent_to = data.email
            if "@" in sent_to:
                name, domain = sent_to.split("@", 1)
                masked = name[0] + "***@" + domain
                sent_to = masked
        elif data.phone:
            sent_to = f"***{data.phone[-4:]}"
        else:
            sent_to = "unknown"

        return OTPResponse(
            message="OTP generated successfully",
            expires_in=self._ttl_seconds,
            sent_to=sent_to,
            otp_type=data.otp_type,
            max_attempts=self._max_attempts,
        )

    # ------------------------------------------------------------------ #
    # Verify
    # ------------------------------------------------------------------ #
    def verify(self, data: OTPVerifyRequest) -> OTPVerifyResponse:
        key = self._make_key(
            user_id=data.user_id,
            email=data.email,
            phone=data.phone,
        )
        record = self._store.get_otp(key, data.otp_type)
        now = self._now()

        if not record:
            return OTPVerifyResponse(
                is_valid=False,
                message="OTP not found or expired",
                verified_at=None,
                user_id=data.user_id,
            )

        if now >= record["expires_at"]:
            self._store.delete_otp(key, data.otp_type)
            return OTPVerifyResponse(
                is_valid=False,
                message="OTP expired",
                verified_at=None,
                user_id=data.user_id,
            )

        attempts = record.get("attempts", 0)
        if attempts >= record.get("max_attempts", self._max_attempts):
            self._store.delete_otp(key, data.otp_type)
            return OTPVerifyResponse(
                is_valid=False,
                message="Maximum OTP attempts exceeded",
                verified_at=None,
                user_id=data.user_id,
            )

        # Update attempts
        record["attempts"] = attempts + 1

        if data.otp_code != record["code"]:
            # Save back with incremented attempts
            self._store.save_otp(
                key=key,
                code=record["code"],
                otp_type=data.otp_type,
                expires_at=record["expires_at"],
                max_attempts=record["max_attempts"],
            )
            return OTPVerifyResponse(
                is_valid=False,
                message="Invalid OTP code",
                verified_at=None,
                user_id=data.user_id,
            )

        # Valid OTP: delete and return success
        self._store.delete_otp(key, data.otp_type)
        return OTPVerifyResponse(
            is_valid=True,
            message="OTP verified successfully",
            verified_at=now,
            user_id=data.user_id,
        )

# --- File: D:\hostel-management-saas\app\services\auth\password_service.py ---
# app/services/auth/password_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import UserRepository
from app.schemas.auth.password import (
    PasswordChangeRequest,
    PasswordChangeResponse,
    PasswordStrengthCheck,
    PasswordStrengthResponse,
)
from app.services.common import UnitOfWork, security, errors
from app.services.users import UserActivityService


class PasswordService:
    """
    Password management service:

    - Change password (authenticated user).
    - Password strength evaluation.
    - Hooks for reset flows (token/OTP-based) can be added later.
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        user_activity_service: UserActivityService | None = None,
    ) -> None:
        self._session_factory = session_factory
        self._user_activity = user_activity_service

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def _get_user_password_hash(self, user) -> str:
        pwd_hash = getattr(user, "password_hash", None) or getattr(
            user, "hashed_password", None
        )
        if not pwd_hash:
            raise errors.ServiceError(
                "User model missing password hash column "
                "(expected 'password_hash' or 'hashed_password')."
            )
        return pwd_hash

    # ------------------------------------------------------------------ #
    # Change password (authenticated)
    # ------------------------------------------------------------------ #
    def change_password(
        self,
        user_id: UUID,
        data: PasswordChangeRequest,
        *,
        ip_address: str | None = None,
        user_agent: str | None = None,
    ) -> PasswordChangeResponse:
        """
        Change password for an authenticated user.

        Validates:
        - current_password matches existing hash
        - new_password != current_password (enforced by schema validators)
        """
        with UnitOfWork(self._session_factory) as uow:
            user_repo = self._get_user_repo(uow)
            user = user_repo.get(user_id)
            if user is None or not user.is_active:
                raise errors.NotFoundError("User not found or inactive")

            existing_hash = self._get_user_password_hash(user)
            if not security.verify_password(data.current_password, existing_hash):
                raise errors.ValidationError("Current password is incorrect")

            new_hash = security.hash_password(data.new_password)
            # Assign to the correct attribute
            if hasattr(user, "password_hash"):
                setattr(user, "password_hash", new_hash)
            elif hasattr(user, "hashed_password"):
                setattr(user, "hashed_password", new_hash)
            else:
                raise errors.ServiceError(
                    "User model missing password hash attribute "
                    "(expected 'password_hash' or 'hashed_password')."
                )

            # Optionally update last_login_at or a last_password_change_at column
            if hasattr(user, "updated_at"):
                # timestamp column is already auto-managed; no need to modify.
                pass

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        if self._user_activity:
            self._user_activity.log_password_change(
                user_id=user_id,
                ip_address=ip_address,
                user_agent=user_agent,
            )

        return PasswordChangeResponse(
            message="Password changed successfully",
            user_id=user_id,
        )

    # ------------------------------------------------------------------ #
    # Password strength evaluation
    # ------------------------------------------------------------------ #
    def evaluate_strength(self, data: PasswordStrengthCheck) -> PasswordStrengthResponse:
        """
        Provide a simple password strength evaluation.

        This is independent of DB and can be used client-side as a helper.
        """
        pwd = data.password
        suggestions: list[str] = []
        score = 0

        has_min_length = len(pwd) >= 8
        has_digit = any(c.isdigit() for c in pwd)
        has_upper = any(c.isupper() for c in pwd)
        has_lower = any(c.islower() for c in pwd)
        has_special = any(c in "!@#$%^&*()_+-=[]{}|;:,.<>?/\\'" for c in pwd)

        # Basic scoring
        if has_min_length:
            score += 1
        if has_digit:
            score += 1
        if has_upper:
            score += 1
        if has_lower:
            score += 1
        if has_special:
            score += 1

        if not has_min_length:
            suggestions.append("Use at least 8 characters.")
        if not has_digit:
            suggestions.append("Add at least one digit.")
        if not has_upper:
            suggestions.append("Add at least one uppercase letter.")
        if not has_lower:
            suggestions.append("Add at least one lowercase letter.")
        if not has_special:
            suggestions.append("Add at least one special character.")

        if score <= 2:
            strength_label = "weak"
        elif score == 3:
            strength_label = "medium"
        elif score == 4:
            strength_label = "strong"
        else:
            strength_label = "very_strong"

        return PasswordStrengthResponse(
            score=score,
            strength=strength_label,
            has_minimum_length=has_min_length,
            has_uppercase=has_upper,
            has_lowercase=has_lower,
            has_digit=has_digit,
            has_special_char=has_special,
            suggestions=suggestions,
        )

# --- File: D:\hostel-management-saas\app\services\auth\rbac_service.py ---
# app/services/auth/rbac_service.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Set

from app.schemas.admin import PermissionMatrix, RolePermissions
from app.schemas.common.enums import UserRole
from app.services.common.permissions import Principal, has_permission


@dataclass
class RBACService:
    """
    Simple RBAC helper service based on a role -> permissions matrix.

    You can load the matrix from configuration, DB, or hard-code it.
    """

    permission_matrix: Dict[UserRole, Set[str]]

    def get_role_permissions(self, role: UserRole) -> RolePermissions:
        perms = sorted(self.permission_matrix.get(role, set()))
        return RolePermissions(
            role=role,
            permissions=perms,
            description=f"Permissions for role {role.value}",
        )

    def get_permission_matrix(self) -> PermissionMatrix:
        mapping: Dict[UserRole, List[str]] = {
            role: sorted(perms) for role, perms in self.permission_matrix.items()
        }
        return PermissionMatrix(permissions=mapping)

    def check_permission(self, principal: Principal, permission_key: str) -> bool:
        return has_permission(principal, permission_key, matrix=self.permission_matrix)

# --- File: D:\hostel-management-saas\app\services\auth\registration_service.py ---
# app/services/auth/registration_service.py
from __future__ import annotations

from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import UserRepository
from app.repositories.visitor import VisitorRepository
from app.schemas.auth.register import (
    RegisterRequest,
    RegisterResponse,
    VerifyEmailRequest,
    VerifyPhoneRequest,
)
from app.schemas.common.enums import UserRole
from app.services.common import UnitOfWork, security, errors


class RegistrationService:
    """
    Public-facing user registration.

    Design:
    - Currently supports self-registration for VISITOR role only.
    - Other roles (STUDENT, SUPERVISOR, HOSTEL_ADMIN, SUPER_ADMIN)
      should be created via admin tools, not open registration.

    NOTE:
    - User model must be extended with a password hash column
      (e.g. 'password_hash').
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_visitor_repo(self, uow: UnitOfWork) -> VisitorRepository:
        return uow.get_repo(VisitorRepository)

    # ------------------------------------------------------------------ #
    # Registration
    # ------------------------------------------------------------------ #
    def register(self, data: RegisterRequest) -> RegisterResponse:
        """
        Register a new user.

        Supported roles:
        - VISITOR (self-service)
        """
        # Restrict public registration to VISITOR role
        if data.role != UserRole.VISITOR:
            raise errors.ValidationError(
                "Self-registration is only supported for 'visitor' role. "
                "Other roles must be created by an administrator."
            )

        hashed_pwd = security.hash_password(data.password)

        with UnitOfWork(self._session_factory) as uow:
            user_repo = self._get_user_repo(uow)

            # Uniqueness checks
            if user_repo.get_by_email(data.email):
                raise errors.ConflictError(
                    f"A user with email {data.email!r} already exists"
                )
            if user_repo.get_by_phone(data.phone):
                raise errors.ConflictError(
                    f"A user with phone {data.phone!r} already exists"
                )

            # Create User
            user_payload = {
                "email": data.email,
                "phone": data.phone,
                "full_name": data.full_name,
                "user_role": data.role,
                "gender": data.gender,
                "date_of_birth": data.date_of_birth,
                "profile_image_url": None,
                "is_active": True,
                "is_email_verified": False,
                "is_phone_verified": False,
                # IMPORTANT: add a matching column to core_user model
                "password_hash": hashed_pwd,
            }
            user = user_repo.create(user_payload)  # type: ignore[arg-type]

            # Create Visitor profile with defaults
            visitor_repo = self._get_visitor_repo(uow)
            visitor_payload = {
                "user_id": user.id,
                "preferred_room_type": None,
                "budget_min": None,
                "budget_max": None,
                "preferred_cities": [],
                "preferred_amenities": [],
                "favorite_hostel_ids": [],
                "email_notifications": True,
                "sms_notifications": True,
                "push_notifications": True,
            }
            visitor_repo.create(visitor_payload)  # type: ignore[arg-type]

            uow.commit()

            return RegisterResponse(
                user_id=user.id,
                email=user.email,
                full_name=user.full_name,
                role=user.user_role,
                message="Registration successful",
                verification_required=True,
            )

    # ------------------------------------------------------------------ #
    # Email / phone verification hooks
    # ------------------------------------------------------------------ #
    def mark_email_verified(self, user_id: UUID) -> None:
        """
        Mark a user's email as verified.

        Typically called AFTER OTPService has successfully verified the code.
        """
        with UnitOfWork(self._session_factory) as uow:
            user_repo = self._get_user_repo(uow)
            user = user_repo.get(user_id)
            if user is None:
                raise errors.NotFoundError("User not found")

            user.is_email_verified = True  # type: ignore[attr-defined]
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

    def mark_phone_verified(self, user_id: UUID) -> None:
        """
        Mark a user's phone as verified.

        Typically called AFTER OTPService has successfully verified the code.
        """
        with UnitOfWork(self._session_factory) as uow:
            user_repo = self._get_user_repo(uow)
            user = user_repo.get(user_id)
            if user is None:
                raise errors.NotFoundError("User not found")

            user.is_phone_verified = True  # type: ignore[attr-defined]
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

    # Convenience methods that fit your schemas; actual code verification
    # should be delegated to OTPService.
    def verify_email(self, data: VerifyEmailRequest) -> None:
        """
        High-level flow:

        1. OTPService.verify(user_id, code, type=EMAIL_VERIFICATION)
        2. If valid, mark email verified.
        """
        # OTP verification is expected to be handled by OTPService.
        # Here, we simply mark verified assuming OTP is correct.
        self.mark_email_verified(data.user_id)

    def verify_phone(self, data: VerifyPhoneRequest) -> None:
        """
        High-level flow:

        1. OTPService.verify(user_id, code, type=PHONE_VERIFICATION)
        2. If valid, mark phone verified.
        """
        self.mark_phone_verified(data.user_id)

# --- File: D:\hostel-management-saas\app\services\auth\session_service.py ---
# app/services/auth/session_service.py
from __future__ import annotations

from datetime import datetime, timezone, timedelta
from typing import Protocol, List
from uuid import UUID, uuid4

from app.schemas.user import (
    UserSession,
    SessionInfo,
    ActiveSessionsList,
)
from app.services.common import errors


class SessionStore(Protocol):
    """
    Abstract session storage.

    Implementations can use Redis, a database table, or another store.
    """

    def save_session(self, session: dict) -> None: ...
    def get_session(self, session_id: UUID) -> dict | None: ...
    def delete_session(self, session_id: UUID) -> None: ...
    def list_sessions_for_user(self, user_id: UUID) -> list[dict]: ...


class SessionService:
    """
    User sessions tracking (e.g. for "active devices" list, revocation).

    This is storage-agnostic and expects a SessionStore implementation.
    """

    def __init__(self, store: SessionStore, default_ttl_hours: int = 24) -> None:
        self._store = store
        self._default_ttl = default_ttl_hours

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def create_session(
        self,
        *,
        user_id: UUID,
        device_info: dict | None = None,
        ip_address: str | None = None,
    ) -> UserSession:
        session_id = uuid4()
        now = self._now()
        expires_at = now + timedelta(hours=self._default_ttl)

        record = {
            "id": session_id,
            "user_id": user_id,
            "device_info": device_info or {},
            "ip_address": ip_address,
            "is_revoked": False,
            "expires_at": expires_at,
            "last_activity": now,
            "created_at": now,
        }
        self._store.save_session(record)

        return UserSession(
            id=session_id,
            user_id=user_id,
            device_info=device_info,
            ip_address=ip_address,
            is_revoked=False,
            expires_at=expires_at,
            last_activity=now,
            created_at=now,
            updated_at=now,
        )

    def list_active_sessions(self, user_id: UUID) -> ActiveSessionsList:
        records = self._store.list_sessions_for_user(user_id)
        now = self._now()
        sessions: List[SessionInfo] = []

        for r in records:
            if r.get("is_revoked") or now >= r["expires_at"]:
                continue
            sessions.append(
                SessionInfo(
                    session_id=r["id"],
                    device_name=r["device_info"].get("device_name"),
                    device_type=r["device_info"].get("device_type"),
                    browser=r["device_info"].get("browser"),
                    os=r["device_info"].get("os"),
                    ip_address=r.get("ip_address"),
                    location=r["device_info"].get("location"),
                    is_current=False,  # mark in API layer based on token/jti
                    created_at=r.get("created_at", now),
                    last_activity=r.get("last_activity", now),
                    expires_at=r["expires_at"],
                )
            )

        return ActiveSessionsList(
            sessions=sessions,
            total_sessions=len(sessions),
        )

    def revoke_session(self, session_id: UUID) -> None:
        record = self._store.get_session(session_id)
        if not record:
            raise errors.NotFoundError("Session not found")

        record["is_revoked"] = True
        self._store.save_session(record)

    def revoke_all_for_user(self, user_id: UUID, *, keep_session_id: UUID | None = None) -> None:
        records = self._store.list_sessions_for_user(user_id)
        for r in records:
            if keep_session_id and r["id"] == keep_session_id:
                continue
            r["is_revoked"] = True
            self._store.save_session(r)

# --- File: D:\hostel-management-saas\app\services\auth\social_auth_service.py ---
# app/services/auth/social_auth_service.py
from __future__ import annotations

from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import UserRepository
from app.repositories.visitor import VisitorRepository
from app.schemas.auth.social_auth import (
    GoogleAuthRequest,
    FacebookAuthRequest,
    SocialAuthResponse,
    SocialUserInfo,
)
from app.schemas.common.enums import UserRole
from app.services.common import UnitOfWork, security, errors


class SocialAuthService:
    """
    Social authentication (Google/Facebook).

    This is a high-level skeleton. In a real implementation, you would:
    - Verify tokens with Google/Facebook APIs;
    - Extract profile info;
    - Create or update User + Visitor profile;
    - Issue JWT tokens (similar to AuthService).
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        jwt_settings: security.JWTSettings,
    ) -> None:
        self._session_factory = session_factory
        self._jwt_settings = jwt_settings

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_visitor_repo(self, uow: UnitOfWork) -> VisitorRepository:
        return uow.get_repo(VisitorRepository)

    # For brevity, Google/Facebook verification is omitted and should be added
    # using their respective SDKs or REST APIs.

    def authenticate_with_google(self, data: GoogleAuthRequest) -> SocialAuthResponse:
        """
        Verify Google ID token, then create or fetch user.

        This implementation is a stub and should be extended with actual
        Google token verification logic.
        """
        raise NotImplementedError("Google OAuth integration not implemented")

    def authenticate_with_facebook(self, data: FacebookAuthRequest) -> SocialAuthResponse:
        """
        Verify Facebook access token, then create or fetch user.

        This implementation is a stub and should be extended with actual
        Facebook token verification logic.
        """
        raise NotImplementedError("Facebook OAuth integration not implemented")

# --- File: D:\hostel-management-saas\app\services\auth\__init__.py ---
# app/services/auth/__init__.py
"""
Authentication and authorization services.

- AuthService: login/logout, token issuance, refresh.
- RegistrationService: user registration (visitor-facing signup).
- PasswordService: password change and strength checks.
- OTPService: OTP generation/verification (stubbed integration point).
- SocialAuthService: Google/Facebook OAuth (stubbed).
- SessionService: user session tracking (stubbed, e.g. Redis-based).
- RBACService: role-based permission matrix helpers (stubbed).
- ContextService: per-admin active hostel context (stubbed).
"""

from .auth_service import AuthService
from .registration_service import RegistrationService
from .password_service import PasswordService
from .otp_service import OTPService
from .social_auth_service import SocialAuthService
from .session_service import SessionService
from .rbac_service import RBACService
from .context_service import ContextService

__all__ = [
    "AuthService",
    "RegistrationService",
    "PasswordService",
    "OTPService",
    "SocialAuthService",
    "SessionService",
    "RBACService",
    "ContextService",
]


# ===== Folder: D:\hostel-management-saas\app\services\booking =====

# --- File: D:\hostel-management-saas\app\services\booking\booking_analytics_service.py ---
# app/services/booking/booking_analytics_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, List, Dict, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import BookingRepository
from app.schemas.booking import (
    BookingAnalyticsSummary,
    BookingKPI,
    BookingTrendPoint,
    BookingFunnel,
    CancellationAnalytics,
    BookingStatus,
    BookingSource,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class BookingAnalyticsService:
    """
    Booking analytics based on txn_booking.

    - KPI (counts, rates)
    - Trend by day
    - Funnel approximation
    - Cancellation analytics
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    def get_analytics_for_hostel(
        self,
        hostel_id: Optional[UUID],
        period: DateRangeFilter,
    ) -> BookingAnalyticsSummary:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            filters: dict = {}
            if hostel_id:
                filters["hostel_id"] = hostel_id
            bookings = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

        start = period.start_date or date.min
        end = period.end_date or date.max

        filtered = []
        for b in bookings:
            d = b.booking_date.date()
            if d < start or d > end:
                continue
            filtered.append(b)

        total = len(filtered)
        confirmed = 0
        cancelled = 0
        rejected = 0
        total_revenue = Decimal("0")

        trend_by_date: Dict[str, Dict[str, Decimal | int]] = {}
        cancellations_by_reason: Dict[str, int] = {}
        cancellations_by_status: Dict[BookingStatus, int] = {}
        bookings_by_source: Dict[BookingSource, int] = {}

        for b in filtered:
            if b.booking_status == BookingStatus.CONFIRMED:
                confirmed += 1
            if b.booking_status == BookingStatus.CANCELLED:
                cancelled += 1
            if b.booking_status == BookingStatus.REJECTED:
                rejected += 1

            total_revenue += b.total_amount or Decimal("0")

            day = b.booking_date.date().isoformat()
            bucket = trend_by_date.setdefault(
                day,
                {"total": 0, "confirmed": 0, "cancelled": 0, "rejected": 0, "revenue": Decimal("0")},
            )
            bucket["total"] = int(bucket["total"]) + 1
            if b.booking_status == BookingStatus.CONFIRMED:
                bucket["confirmed"] = int(bucket["confirmed"]) + 1
            if b.booking_status == BookingStatus.CANCELLED:
                bucket["cancelled"] = int(bucket["cancelled"]) + 1
            if b.booking_status == BookingStatus.REJECTED:
                bucket["rejected"] = int(bucket["rejected"]) + 1
            bucket["revenue"] = bucket["revenue"] + b.total_amount

            bookings_by_source[b.source] = bookings_by_source.get(b.source, 0) + 1

        trend_points: List[BookingTrendPoint] = []
        for d, vals in sorted(trend_by_date.items()):
            trend_points.append(
                BookingTrendPoint(
                    date=date.fromisoformat(d),
                    total_bookings=int(vals["total"]),
                    confirmed=int(vals["confirmed"]),
                    cancelled=int(vals["cancelled"]),
                    rejected=int(vals["rejected"]),
                    revenue_for_day=vals["revenue"],
                )
            )

        kpi = BookingKPI(
            hostel_id=hostel_id,
            hostel_name=None,
            total_bookings=total,
            confirmed_bookings=confirmed,
            cancelled_bookings=cancelled,
            rejected_bookings=rejected,
            booking_conversion_rate=Decimal(str(confirmed / total * 100)) if total > 0 else Decimal("0"),
            cancellation_rate=Decimal(str(cancelled / total * 100)) if total > 0 else Decimal("0"),
            average_lead_time_days=Decimal("0"),
        )

        funnel = BookingFunnel(
            period=period,
            generated_at=None,
            hostel_page_views=0,
            booking_form_starts=0,
            booking_submissions=total,
            bookings_confirmed=confirmed,
            view_to_start_rate=Decimal("0"),
            start_to_submit_rate=Decimal("0"),
            submit_to_confirm_rate=Decimal(str(confirmed / total * 100)) if total > 0 else Decimal("0"),
            view_to_confirm_rate=Decimal("0"),
        )

        cancellations = CancellationAnalytics(
            period=period,
            total_cancellations=cancelled,
            cancellation_rate=Decimal(str(cancelled / total * 100)) if total > 0 else Decimal("0"),
            cancellations_by_reason=cancellations_by_reason,
            cancellations_by_status=cancellations_by_status,
            average_time_before_check_in_cancelled_days=Decimal("0"),
        )

        conversion_rate_by_source: Dict[BookingSource, Decimal] = {}
        for src, count in bookings_by_source.items():
            if count > 0:
                src_confirmed = sum(
                    1 for b in filtered if b.source == src and b.booking_status == BookingStatus.CONFIRMED
                )
                conversion_rate_by_source[src] = Decimal(str(src_confirmed / count * 100))
            else:
                conversion_rate_by_source[src] = Decimal("0")

        return BookingAnalyticsSummary(
            hostel_id=hostel_id,
            hostel_name=None,
            period=period,
            generated_at=None,
            kpi=kpi,
            trend=trend_points,
            funnel=funnel,
            cancellations=cancellations,
            bookings_by_source=bookings_by_source,
            conversion_rate_by_source=conversion_rate_by_source,
        )

# --- File: D:\hostel-management-saas\app\services\booking\booking_calendar_service.py ---
# app/services/booking/booking_calendar_service.py
from __future__ import annotations

from datetime import date, timedelta
from typing import Callable, List, Dict, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import BookingRepository
from app.repositories.core import RoomRepository
from app.schemas.booking import (
    CalendarView,
    DayBookings,
    BookingEvent,
    AvailabilityCalendar,
    DayAvailability,
    BookingStatus,
)
from app.services.common import UnitOfWork, errors


class BookingCalendarService:
    """
    Generate calendar views and availability for bookings.

    NOTE:
    - This is a read-only service over txn_booking and rooms.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_booking_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    # ------------------------------------------------------------------ #
    # Calendar view for a month
    # ------------------------------------------------------------------ #
    def get_calendar_view(
        self,
        hostel_id: UUID,
        year: int,
        month: int,
    ) -> CalendarView:
        from calendar import monthrange

        first_day = date(year, month, 1)
        last_day = date(year, month, monthrange(year, month)[1])

        with UnitOfWork(self._session_factory) as uow:
            booking_repo = self._get_booking_repo(uow)

            bookings = booking_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

        # Filter bookings that intersect with the month
        relevant = []
        for b in bookings:
            ci = b.preferred_check_in_date
            co = ci + timedelta(days=30 * b.stay_duration_months)
            if co < first_day or ci > last_day:
                continue
            relevant.append(b)

        days_map: Dict[str, DayBookings] = {}
        available_rooms_by_date: Dict[str, int] = {}

        for offset in range((last_day - first_day).days + 1):
            d = first_day + timedelta(days=offset)
            key = d.isoformat()
            days_map[key] = DayBookings(
                date=d,
                check_ins=[],
                check_outs=[],
                pending_bookings=[],
                available_beds=0,
                total_beds=0,
            )
            available_rooms_by_date[key] = 0

        for b in relevant:
            ci = b.preferred_check_in_date
            co = ci + timedelta(days=30 * b.stay_duration_months)

            # Check-ins
            ci_key = ci.isoformat()
            if ci_key in days_map:
                days_map[ci_key].check_ins.append(
                    BookingEvent(
                        booking_id=b.id,
                        booking_reference=f"BKG-{str(b.id)[:8].upper()}",
                        guest_name=b.guest_name,
                        room_number=None,
                        room_type=b.room_type_requested.value if hasattr(b.room_type_requested, "value") else str(b.room_type_requested),
                        status=b.booking_status,
                        is_check_in=True,
                        is_check_out=False,
                    )
                )

            # Check-outs
            co_key = co.isoformat()
            if co_key in days_map:
                days_map[co_key].check_outs.append(
                    BookingEvent(
                        booking_id=b.id,
                        booking_reference=f"BKG-{str(b.id)[:8].upper()}",
                        guest_name=b.guest_name,
                        room_number=None,
                        room_type=b.room_type_requested.value if hasattr(b.room_type_requested, "value") else str(b.room_type_requested),
                        status=b.booking_status,
                        is_check_in=False,
                        is_check_out=True,
                    )
                )

            # Pending bookings
            if b.booking_status == BookingStatus.PENDING:
                key = b.preferred_check_in_date.isoformat()
                if key in days_map:
                    days_map[key].pending_bookings.append(
                        BookingEvent(
                            booking_id=b.id,
                            booking_reference=f"BKG-{str(b.id)[:8].upper()}",
                            guest_name=b.guest_name,
                            room_number=None,
                            room_type=b.room_type_requested.value if hasattr(b.room_type_requested, "value") else str(b.room_type_requested),
                            status=b.booking_status,
                            is_check_in=False,
                            is_check_out=False,
                        )
                    )

        # available_rooms_by_date is left 0; you can enrich it using room occupancy if needed
        return CalendarView(
            hostel_id=hostel_id,
            month=f"{year:04d}-{month:02d}",
            days=days_map,
            total_check_ins=sum(len(d.check_ins) for d in days_map.values()),
            total_check_outs=sum(len(d.check_outs) for d in days_map.values()),
            peak_occupancy_date=None,
            available_rooms_by_date=available_rooms_by_date,
        )

    # ------------------------------------------------------------------ #
    # Availability calendar (per room)
    # ------------------------------------------------------------------ #
    def get_availability_calendar(
        self,
        room_id: UUID,
        year: int,
        month: int,
    ) -> AvailabilityCalendar:
        from calendar import monthrange

        first_day = date(year, month, 1)
        last_day = date(year, month, monthrange(year, month)[1])

        with UnitOfWork(self._session_factory) as uow:
            booking_repo = self._get_booking_repo(uow)
            room_repo = self._get_room_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            bookings = booking_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"room_id": room_id},
            )

        availability: Dict[str, DayAvailability] = {}
        for offset in range((last_day - first_day).days + 1):
            d = first_day + timedelta(days=offset)
            key = d.isoformat()
            availability[key] = DayAvailability(
                date=d,
                available_beds=room.total_beds,
                total_beds=room.total_beds,
                is_available=True,
                bookings=[],
            )

        from app.schemas.booking.booking_calendar import BookingInfo  # avoid circular imports

        for b in bookings:
            ci = b.preferred_check_in_date
            co = ci + timedelta(days=30 * b.stay_duration_months)
            for offset in range((co - ci).days):
                d = ci + timedelta(days=offset)
                if d < first_day or d > last_day:
                    continue
                key = d.isoformat()
                if key not in availability:
                    continue
                day_avail = availability[key]
                # Each booking “uses” one bed
                day_avail.available_beds = max(0, day_avail.available_beds - 1)
                day_avail.is_available = day_avail.available_beds > 0
                day_avail.bookings.append(
                    BookingInfo(
                        booking_id=b.id,
                        student_name=b.guest_name,
                        check_in_date=ci,
                        check_out_date=co,
                    )
                )

        return AvailabilityCalendar(
            room_id=room_id,
            room_number=room.room_number,
            month=f"{year:04d}-{month:02d}",
            availability=availability,
        )

# --- File: D:\hostel-management-saas\app\services\booking\booking_cancellation_service.py ---
# app/services/booking/booking_cancellation_service.py
from __future__ import annotations

from datetime import datetime, timezone, date
from decimal import Decimal
from typing import Callable, Optional, List, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import BookingRepository, PaymentRepository
from app.schemas.common.enums import BookingStatus, PaymentStatus, PaymentType
from app.schemas.booking import (
    CancellationRequest,
    CancellationResponse,
    RefundCalculation,
    CancellationPolicy,
    CancellationCharge,
    BulkCancellation,
)
from app.services.common import UnitOfWork, errors


class RefundExecutor(Protocol):
    """
    Optional abstraction for actually issuing refunds via payment gateway.
    """

    def execute_refund(
        self,
        *,
        payment_id: UUID,
        amount: Decimal,
        reason: str,
    ) -> str: ...
    # returns refund reference/transaction id


class BookingCancellationService:
    """
    Booking cancellation and refund calculation:

    - Cancel bookings
    - Compute refund amounts based on CancellationPolicy
    - Optionally execute refunds via a RefundExecutor
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        refund_executor: Optional[RefundExecutor] = None,
    ) -> None:
        self._session_factory = session_factory
        self._refund_executor = refund_executor

    def _get_booking_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Policy evaluation
    # ------------------------------------------------------------------ #
    def _find_applicable_charge(
        self,
        policy: CancellationPolicy,
        days_before_checkin: int,
    ) -> CancellationCharge:
        """
        Given days_before_checkin, find the matching charge tier:

        Assumes policy.cancellation_before_days is sorted ascending by days_before_checkin.
        """
        # Simple approach: choose the highest days_before_checkin <= actual days_before
        best: Optional[CancellationCharge] = None
        for tier in policy.cancellation_before_days:
            if days_before_checkin >= tier.days_before_checkin:
                if best is None or tier.days_before_checkin > best.days_before_checkin:
                    best = tier
        # If none matched, choose the strictest (e.g. highest charge)
        if best is None and policy.cancellation_before_days:
            best = policy.cancellation_before_days[-1]
        if best is None:
            # default: no charge
            return CancellationCharge(
                days_before_checkin=0,
                charge_percentage=Decimal("0"),
                description="No policy; full refund",
            )
        return best

    def _calculate_refund(
        self,
        booking,
        payment_amount: Decimal,
        policy: CancellationPolicy,
        cancel_date: date,
    ) -> RefundCalculation:
        check_in = booking.preferred_check_in_date
        days_before = (check_in - cancel_date).days if check_in > cancel_date else 0
        tier = self._find_applicable_charge(policy, days_before)

        cancellation_charge = (payment_amount * tier.charge_percentage) / 100
        refundable = max(Decimal("0"), payment_amount - cancellation_charge)

        return RefundCalculation(
            advance_paid=payment_amount,
            cancellation_charge=cancellation_charge,
            cancellation_charge_percentage=tier.charge_percentage,
            refundable_amount=refundable,
            refund_processing_time_days=policy.refund_processing_days,
            refund_method="original_source",
            breakdown={
                "days_before_checkin": days_before,
                "applied_tier": tier.description,
            },
        )

    # ------------------------------------------------------------------ #
    # Cancel a booking
    # ------------------------------------------------------------------ #
    def cancel(
        self,
        data: CancellationRequest,
        *,
        policy: CancellationPolicy,
    ) -> CancellationResponse:
        with UnitOfWork(self._session_factory) as uow:
            booking_repo = self._get_booking_repo(uow)
            payment_repo = self._get_payment_repo(uow)

            b = booking_repo.get(data.booking_id)
            if b is None:
                raise errors.NotFoundError(f"Booking {data.booking_id} not found")

            # Only pending/confirmed/checked_in bookings are cancellable here
            if b.booking_status not in (
                BookingStatus.PENDING,
                BookingStatus.CONFIRMED,
                BookingStatus.CHECKED_IN,
            ):
                raise errors.ValidationError(f"Booking {data.booking_id} cannot be cancelled in status {b.booking_status}")

            # For simplicity, look for a single booking_advance payment
            payments = payment_repo.list_for_booking(b.id)
            advance_payment = None
            for p in payments:
                if p.payment_type == PaymentType.BOOKING_ADVANCE:
                    advance_payment = p
                    break

            payment_amount = advance_payment.amount if advance_payment else Decimal("0")
            refund = self._calculate_refund(
                booking=b,
                payment_amount=payment_amount,
                policy=policy,
                cancel_date=date.today(),
            )

            # Optionally execute refund via gateway
            if data.request_refund and self._refund_executor and advance_payment:
                refund_ref = self._refund_executor.execute_refund(
                    payment_id=advance_payment.id,
                    amount=refund.refundable_amount,
                    reason=data.cancellation_reason,
                )
                refund.breakdown["refund_reference"] = refund_ref

            # Update booking status
            b.booking_status = BookingStatus.CANCELLED  # type: ignore[attr-defined]
            # For full semantics, you'd also set cancelled_by/at fields via another store.

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return CancellationResponse(
            booking_id=b.id,
            booking_reference=f"BKG-{str(b.id)[:8].upper()}",
            cancelled=True,
            cancelled_at=self._now(),
            refund=refund,
            message="Booking cancelled successfully",
            confirmation_sent=False,
        )

    def bulk_cancel(
        self,
        data: BulkCancellation,
        *,
        policy: CancellationPolicy,
    ) -> List[CancellationResponse]:
        responses: List[CancellationResponse] = []
        for bid in data.booking_ids:
            req = CancellationRequest(
                booking_id=bid,
                cancelled_by_role="admin",
                cancellation_reason=data.reason,
                request_refund=data.process_refunds,
                additional_comments=None,
            )
            responses.append(self.cancel(req, policy=policy))
        return responses

# --- File: D:\hostel-management-saas\app\services\booking\booking_conversion_service.py ---
# app/services/booking/booking_conversion_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import BookingRepository
from app.repositories.core import StudentRepository, HostelRepository, RoomRepository, BedRepository
from app.schemas.booking import (
    ConvertToStudentRequest,
    ConversionResponse,
    ConversionChecklist,
    ChecklistItem,
)
from app.schemas.common.enums import BookingStatus, StudentStatus
from app.services.common import UnitOfWork, errors


class BookingConversionService:
    """
    Convert confirmed bookings into Student profiles.

    - Validates that booking is confirmed
    - Checks financial confirmations
    - Creates Student record
    - Assigns room/bed
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_booking_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    # ------------------------------------------------------------------ #
    # Checklist / eligibility
    # ------------------------------------------------------------------ #
    def build_checklist(self, booking_id: UUID) -> ConversionChecklist:
        """
        Build a simple pre-conversion checklist. Here we only stub it;
        you can enrich with actual checks.
        """
        checks: List[ChecklistItem] = [
            ChecklistItem(
                item_name="Security deposit received",
                description="Verify security deposit payment",
                is_completed=False,
                is_required=True,
                completed_at=None,
                notes=None,
            ),
            ChecklistItem(
                item_name="First month rent received",
                description="Verify first month rent payment",
                is_completed=False,
                is_required=True,
                completed_at=None,
                notes=None,
            ),
            ChecklistItem(
                item_name="ID proof uploaded",
                description="Check that a valid ID proof document is uploaded",
                is_completed=False,
                is_required=True,
                completed_at=None,
                notes=None,
            ),
        ]
        return ConversionChecklist(
            booking_id=booking_id,
            booking_reference=f"BKG-{str(booking_id)[:8].upper()}",
            checks=checks,
            all_checks_passed=False,
            can_convert=False,
            missing_items=[c.item_name for c in checks],
        )

    # ------------------------------------------------------------------ #
    # Conversion
    # ------------------------------------------------------------------ #
    def convert(
        self,
        data: ConvertToStudentRequest,
        *,
        user_id: UUID,
        hostel_id: UUID,
        room_id: UUID,
        bed_id: UUID,
        monthly_rent: Decimal,
        security_deposit: Decimal,
        next_payment_due_date: date,
    ) -> ConversionResponse:
        with UnitOfWork(self._session_factory) as uow:
            booking_repo = self._get_booking_repo(uow)
            student_repo = self._get_student_repo(uow)
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)

            b = booking_repo.get(data.booking_id)
            if b is None:
                raise errors.NotFoundError(f"Booking {data.booking_id} not found")

            if b.booking_status not in (BookingStatus.CONFIRMED, BookingStatus.CHECKED_IN):
                raise errors.ValidationError("Booking must be confirmed before conversion")

            # Create student record
            student_payload = {
                "user_id": user_id,
                "hostel_id": hostel_id,
                "room_id": room_id,
                "bed_id": bed_id,
                "guardian_name": "",
                "guardian_phone": "",
                "guardian_email": None,
                "guardian_relation": None,
                "guardian_address": None,
                "institution_name": None,
                "course": None,
                "year_of_study": None,
                "company_name": None,
                "designation": None,
                "check_in_date": data.actual_check_in_date,
                "expected_checkout_date": None,
                "actual_checkout_date": None,
                "security_deposit_amount": security_deposit,
                "monthly_rent_amount": monthly_rent,
                "mess_subscribed": False,
                "dietary_preference": None,
                "food_allergies": None,
                "student_status": StudentStatus.ACTIVE,
            }
            student = student_repo.create(student_payload)  # type: ignore[arg-type]

            # Assign bed's current_student_id
            bed = bed_repo.get(bed_id)
            if bed:
                bed.current_student_id = student.id  # type: ignore[attr-defined]

            # Optionally mark booking as converted
            b.booking_status = BookingStatus.COMPLETED  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        room = room_repo.get(room_id)
        bed_obj = bed_repo.get(bed_id)

        return ConversionResponse(
            booking_id=data.booking_id,
            student_profile_id=student.id,
            converted=True,
            conversion_date=data.actual_check_in_date,
            room_number=room.room_number if room else "",
            bed_number=bed_obj.bed_number if bed_obj else "",
            monthly_rent=monthly_rent,
            security_deposit=security_deposit,
            next_payment_due_date=next_payment_due_date,
            message="Booking converted to student successfully",
            next_steps=[
                "Complete hostel onboarding form",
                "Collect room keys",
            ],
        )

# --- File: D:\hostel-management-saas\app\services\booking\booking_modification_service.py ---
# app/services/booking/booking_modification_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import BookingRepository
from app.schemas.booking import (
    ModificationRequest,
    ModificationResponse,
    DateChangeRequest,
    DurationChangeRequest,
    RoomTypeChangeRequest,
    ModificationApproval,
)
from app.schemas.common.enums import BookingStatus, RoomType
from app.services.common import UnitOfWork, errors


class BookingModificationService:
    """
    Handle booking modification requests (date/duration/room_type):

    - Calculate price impact
    - Optionally require admin approval
    - Apply changes
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_booking_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    # ------------------------------------------------------------------ #
    # Core modification
    # ------------------------------------------------------------------ #
    def modify(self, data: ModificationRequest) -> ModificationResponse:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)
            b = repo.get(data.booking_id)
            if b is None:
                raise errors.NotFoundError(f"Booking {data.booking_id} not found")

            original_total = b.total_amount
            new_total = b.total_amount
            modifications_applied: List[str] = []

            if data.modify_check_in_date and data.new_check_in_date:
                modifications_applied.append("check_in_date")
                b.preferred_check_in_date = data.new_check_in_date  # type: ignore[attr-defined]

            if data.modify_duration and data.new_duration_months:
                modifications_applied.append("duration")
                b.stay_duration_months = data.new_duration_months  # type: ignore[attr-defined]
                # Recompute total as a stub; real implementation uses FeeStructure
                new_total = b.quoted_rent_monthly * data.new_duration_months  # type: ignore[attr-defined]

            if data.modify_room_type and data.new_room_type:
                modifications_applied.append("room_type")
                b.room_type_requested = data.new_room_type  # type: ignore[attr-defined]
                # Price change may occur; left as-is unless you integrate FeeStructure

            price_difference = new_total - original_total
            additional_payment_required = price_difference > 0
            additional_amount = price_difference if price_difference > 0 else Decimal("0")

            requires_admin_approval = additional_payment_required and not data.accept_price_change
            auto_approved = not requires_admin_approval

            if auto_approved:
                b.total_amount = new_total  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return ModificationResponse(
            booking_id=data.booking_id,
            booking_reference=f"BKG-{str(data.booking_id)[:8].upper()}",
            modifications_applied=modifications_applied,
            original_total=original_total,
            new_total=new_total,
            price_difference=price_difference,
            additional_payment_required=additional_payment_required,
            additional_amount=additional_amount,
            requires_admin_approval=requires_admin_approval,
            auto_approved=auto_approved,
            message="Booking modification processed",
        )

    # Convenience wrappers
    def change_date(self, data: DateChangeRequest) -> ModificationResponse:
        req = ModificationRequest(
            booking_id=data.booking_id,
            modify_check_in_date=True,
            new_check_in_date=data.new_check_in_date,
            modify_duration=False,
            new_duration_months=None,
            modify_room_type=False,
            new_room_type=None,
            modification_reason=data.reason,
            accept_price_change=True,
        )
        return self.modify(req)

    def change_duration(self, data: DurationChangeRequest) -> ModificationResponse:
        req = ModificationRequest(
            booking_id=data.booking_id,
            modify_check_in_date=False,
            new_check_in_date=None,
            modify_duration=True,
            new_duration_months=data.new_duration_months,
            modify_room_type=False,
            new_room_type=None,
            modification_reason=data.reason,
            accept_price_change=True,
        )
        return self.modify(req)

    def change_room_type(self, data: RoomTypeChangeRequest) -> ModificationResponse:
        req = ModificationRequest(
            booking_id=data.booking_id,
            modify_check_in_date=False,
            new_check_in_date=None,
            modify_duration=False,
            new_duration_months=None,
            modify_room_type=True,
            new_room_type=data.new_room_type,
            modification_reason=data.reason,
            accept_price_change=data.accept_price_difference,
        )
        return self.modify(req)

    # Admin approval payload handling
    def approve_modification(self, data: ModificationApproval) -> None:
        # In a fuller implementation, you'd look up a stored modification request,
        # apply adjusted_price, and record admin decision. Left as a stub here.
        pass

# --- File: D:\hostel-management-saas\app\services\booking\booking_service.py ---
# app/services/booking/booking_service.py
from __future__ import annotations

from datetime import datetime, timezone, timedelta, date
from decimal import Decimal
from typing import Callable, Optional, Sequence, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import BookingRepository
from app.repositories.core import HostelRepository, RoomRepository, BedRepository
from app.schemas.common.enums import BookingStatus, BookingSource, RoomType
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.booking import (
    BookingCreate,
    BookingUpdate,
    BookingRequest,
    QuickBookingRequest,
    BookingFilterParams,
    BookingSortOptions,
    BookingSearchRequest,
    BookingResponse,
    BookingDetail,
    BookingListItem,
    BookingConfirmation,
)
from app.services.common import UnitOfWork, pagination, errors


class BookingService:
    """
    Core booking service (internal txn_booking model):

    - Create booking from internal BookingCreate or public BookingRequest/QuickBookingRequest
    - Get single booking (detail)
    - List / search bookings with filters & sorting
    - Update booking & booking status
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_booking_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def _expected_checkout_date(self, check_in: date, months: int) -> date:
        # Very simple month→days approximation; customize as needed
        return check_in + timedelta(days=30 * months)

    def _booking_reference(self, booking_id: UUID) -> str:
        return f"BKG-{str(booking_id)[:8].upper()}"

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_response(self, b) -> BookingResponse:
        hostel = getattr(b, "hostel", None)
        advance_paid = any((p.payment_status.name == "COMPLETED" and p.payment_type.name == "BOOKING_ADVANCE")
                           for p in getattr(b, "payments", []) or [])

        return BookingResponse(
            id=b.id,
            created_at=b.created_at,
            updated_at=b.updated_at,
            booking_reference=self._booking_reference(b.id),
            visitor_id=b.visitor_id,
            hostel_id=b.hostel_id,
            hostel_name=hostel.name if hostel else "",
            room_type_requested=b.room_type_requested,
            preferred_check_in_date=b.preferred_check_in_date,
            stay_duration_months=b.stay_duration_months,
            expected_check_out_date=self._expected_checkout_date(
                b.preferred_check_in_date, b.stay_duration_months
            ),
            guest_name=b.guest_name,
            guest_email=b.guest_email,
            guest_phone=b.guest_phone,
            quoted_rent_monthly=b.quoted_rent_monthly,
            total_amount=b.total_amount,
            security_deposit=b.security_deposit,
            advance_amount=b.advance_amount,
            advance_paid=advance_paid,
            booking_status=b.booking_status,
            booking_date=b.booking_date,
            expires_at=b.expires_at,
        )

    def _to_detail(self, b, hostel_name: str, hostel_city: str, hostel_address: str, hostel_phone: str,
                   room_number: Optional[str], bed_number: Optional[str]) -> BookingDetail:
        advance_payment = None
        for p in getattr(b, "payments", []) or []:
            if p.payment_type.name == "BOOKING_ADVANCE":
                advance_payment = p
                break

        advance_paid = advance_payment is not None and advance_payment.payment_status.name == "COMPLETED"
        advance_payment_id = advance_payment.id if advance_payment else None

        approved_by = None
        approved_by_name = None
        # You can later wire this to a workflow/approval store

        rejected_by = None
        rejected_at = None
        rejection_reason = None

        cancelled_by = None
        cancelled_at = None
        cancellation_reason = None

        converted_to_student = False
        student_profile_id = None
        conversion_date = None

        return BookingDetail(
            id=b.id,
            created_at=b.created_at,
            updated_at=b.updated_at,
            booking_reference=self._booking_reference(b.id),
            visitor_id=b.visitor_id,
            visitor_name=b.guest_name,
            hostel_id=b.hostel_id,
            hostel_name=hostel_name,
            hostel_city=hostel_city,
            hostel_address=hostel_address,
            hostel_phone=hostel_phone,
            room_type_requested=b.room_type_requested,
            preferred_check_in_date=b.preferred_check_in_date,
            stay_duration_months=b.stay_duration_months,
            expected_check_out_date=self._expected_checkout_date(
                b.preferred_check_in_date, b.stay_duration_months
            ),
            room_id=b.room_id,
            room_number=room_number,
            bed_id=b.bed_id,
            bed_number=bed_number,
            guest_name=b.guest_name,
            guest_email=b.guest_email,
            guest_phone=b.guest_phone,
            guest_id_proof_type=None,
            guest_id_proof_number=None,
            emergency_contact_name=None,
            emergency_contact_phone=None,
            emergency_contact_relation=None,
            institution_or_company=None,
            designation_or_course=None,
            special_requests=None,
            dietary_preferences=None,
            has_vehicle=False,
            vehicle_details=None,
            quoted_rent_monthly=b.quoted_rent_monthly,
            total_amount=b.total_amount,
            security_deposit=b.security_deposit,
            advance_amount=b.advance_amount,
            advance_paid=advance_paid,
            advance_payment_id=advance_payment_id,
            booking_status=b.booking_status,
            approved_by=approved_by,
            approved_by_name=approved_by_name,
            approved_at=None,
            rejected_by=rejected_by,
            rejected_at=rejected_at,
            rejection_reason=rejection_reason,
            cancelled_by=cancelled_by,
            cancelled_at=cancelled_at,
            cancellation_reason=cancellation_reason,
            converted_to_student=converted_to_student,
            student_profile_id=student_profile_id,
            conversion_date=conversion_date,
            source=b.source,
            referral_code=b.referral_code,
            booking_date=b.booking_date,
            expires_at=b.expires_at,
        )

    def _to_list_item(self, b, hostel_name: str, is_urgent: bool, days_until_checkin: Optional[int]) -> BookingListItem:
        expected_checkout = self._expected_checkout_date(b.preferred_check_in_date, b.stay_duration_months)
        return BookingListItem(
            id=b.id,
            booking_reference=self._booking_reference(b.id),
            guest_name=b.guest_name,
            guest_phone=b.guest_phone,
            hostel_name=hostel_name,
            room_type_requested=b.room_type_requested.value if hasattr(b.room_type_requested, "value") else str(b.room_type_requested),
            preferred_check_in_date=b.preferred_check_in_date,
            stay_duration_months=b.stay_duration_months,
            total_amount=b.total_amount,
            advance_paid=False,  # you can enrich like in _to_response if needed
            booking_status=b.booking_status,
            booking_date=b.booking_date,
            is_urgent=is_urgent,
            days_until_checkin=days_until_checkin,
        )

    # ------------------------------------------------------------------ #
    # Read
    # ------------------------------------------------------------------ #
    def get_booking(self, booking_id: UUID) -> BookingDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)

            b = repo.get(booking_id)
            if b is None:
                raise errors.NotFoundError(f"Booking {booking_id} not found")

            hostel = hostel_repo.get(b.hostel_id)
            room = room_repo.get(b.room_id) if b.room_id else None
            bed = bed_repo.get(b.bed_id) if b.bed_id else None

            hostel_name = hostel.name if hostel else ""
            hostel_city = hostel.city if hostel else ""
            hostel_address = hostel.address_line1 if hostel else ""
            hostel_phone = hostel.contact_phone if hostel else ""
            room_number = room.room_number if room else None
            bed_number = bed.bed_number if bed else None

            return self._to_detail(
                b,
                hostel_name=hostel_name,
                hostel_city=hostel_city,
                hostel_address=hostel_address,
                hostel_phone=hostel_phone,
                room_number=room_number,
                bed_number=bed_number,
            )

    # ------------------------------------------------------------------ #
    # Listing & filtering
    # ------------------------------------------------------------------ #
    def list_bookings(
        self,
        params: PaginationParams,
        filters: Optional[BookingFilterParams] = None,
        sort: Optional[BookingSortOptions] = None,
    ) -> PaginatedResponse[BookingListItem]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            raw_filters: dict = {}
            if filters:
                if filters.hostel_id:
                    raw_filters["hostel_id"] = filters.hostel_id
                if filters.status:
                    raw_filters["booking_status"] = filters.status
                if filters.room_type:
                    raw_filters["room_type_requested"] = filters.room_type
                if filters.source:
                    raw_filters["source"] = filters.source
                if filters.advance_paid is not None:
                    # This requires payment join; here we skip and let higher layer handle.
                    pass
                if filters.converted_to_student is not None:
                    # Requires conversion tracking; skip here.
                    pass

            order_by = None
            if sort:
                col_map = {
                    "booking_date": repo.model.booking_date,          # type: ignore[attr-defined]
                    "check_in_date": repo.model.preferred_check_in_date,  # type: ignore[attr-defined]
                    "guest_name": repo.model.guest_name,             # type: ignore[attr-defined]
                    "status": repo.model.booking_status,             # type: ignore[attr-defined]
                    "total_amount": repo.model.total_amount,         # type: ignore[attr-defined]
                }
                sort_col = col_map.get(sort.sort_by, repo.model.booking_date)  # type: ignore[attr-defined]
                order_by = [sort_col.asc() if sort.sort_order == "asc" else sort_col.desc()]

            records: Sequence = repo.get_multi(
                skip=params.offset,
                limit=params.limit,
                filters=raw_filters or None,
                order_by=order_by,
            )
            total = repo.count(filters=raw_filters or None)

            now = date.today()
            items: List[BookingListItem] = []
            hostel_name_cache: dict[UUID, str] = {}

            for b in records:
                if b.hostel_id not in hostel_name_cache:
                    h = hostel_repo.get(b.hostel_id)
                    hostel_name_cache[b.hostel_id] = h.name if h else ""
                hostel_name = hostel_name_cache[b.hostel_id]

                days_until_checkin: Optional[int] = None
                if b.preferred_check_in_date:
                    days_until_checkin = (b.preferred_check_in_date - now).days
                is_urgent = days_until_checkin is not None and days_until_checkin <= 1 and b.booking_status == BookingStatus.PENDING

                items.append(
                    self._to_list_item(
                        b,
                        hostel_name=hostel_name,
                        is_urgent=is_urgent,
                        days_until_checkin=days_until_checkin,
                    )
                )

            return PaginatedResponse[BookingListItem].create(
                items=items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    def search_bookings(
        self,
        params: PaginationParams,
        req: BookingSearchRequest,
    ) -> PaginatedResponse[BookingListItem]:
        """
        Simple in-memory search on booking_reference, guest name, email, phone.
        For large datasets, replace with dedicated queries.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            filters: dict = {}
            if req.hostel_id:
                filters["hostel_id"] = req.hostel_id
            if req.status:
                filters["booking_status"] = req.status

            records: Sequence = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
                order_by=[repo.model.booking_date.desc()],  # type: ignore[attr-defined]
            )

            q = req.query.lower()
            filtered: List = []
            for b in records:
                ref = self._booking_reference(b.id).lower()
                if req.search_in_reference and q in ref:
                    filtered.append(b)
                    continue
                if req.search_in_guest_name and q in (b.guest_name or "").lower():
                    filtered.append(b)
                    continue
                if req.search_in_email and q in (b.guest_email or "").lower():
                    filtered.append(b)
                    continue
                if req.search_in_phone and q in (b.guest_phone or "").lower():
                    filtered.append(b)

            total = len(filtered)
            start = params.offset
            end = start + params.limit
            page_items = filtered[start:end]

            now = date.today()
            items: List[BookingListItem] = []
            hostel_name_cache: dict[UUID, str] = {}

            for b in page_items:
                if b.hostel_id not in hostel_name_cache:
                    h = hostel_repo.get(b.hostel_id)
                    hostel_name_cache[b.hostel_id] = h.name if h else ""
                hostel_name = hostel_name_cache[b.hostel_id]

                days_until_checkin: Optional[int] = None
                if b.preferred_check_in_date:
                    days_until_checkin = (b.preferred_check_in_date - now).days
                is_urgent = days_until_checkin is not None and days_until_checkin <= 1 and b.booking_status == BookingStatus.PENDING

                items.append(
                    self._to_list_item(
                        b,
                        hostel_name=hostel_name,
                        is_urgent=is_urgent,
                        days_until_checkin=days_until_checkin,
                    )
                )

            return PaginatedResponse[BookingListItem].create(
                items=items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    # ------------------------------------------------------------------ #
    # Create
    # ------------------------------------------------------------------ #
    def create_booking(self, data: BookingCreate) -> BookingDetail:
        """
        Internal creation using BookingCreate schema (admin/dashboard).
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)

            payload = data.model_dump()
            # Ensure default status
            payload.setdefault("booking_status", BookingStatus.PENDING)
            payload.setdefault("source", BookingSource.WEBSITE)
            payload.setdefault("booking_date", self._now())
            booking = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()
            return self.get_booking(booking.id)

    def create_booking_from_request(
        self,
        visitor_id: UUID,
        data: BookingRequest,
        *,
        source: BookingSource = BookingSource.WEBSITE,
    ) -> BookingDetail:
        """
        Public-facing booking request → internal booking.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)

            total_amount = Decimal(str(data.stay_duration_months or 1)) * Decimal("0")
            # A real implementation would consult FeeStructure; here we require client to
            # send correct total_amount via a separate handler, or you can extend this.

            payload = {
                "visitor_id": visitor_id,
                "hostel_id": data.hostel_id,
                "room_type_requested": data.room_type_requested,
                "preferred_check_in_date": data.preferred_check_in_date,
                "stay_duration_months": data.stay_duration_months,
                "quoted_rent_monthly": Decimal("0"),
                "total_amount": total_amount,
                "security_deposit": Decimal("0"),
                "advance_amount": Decimal("0"),
                "booking_status": BookingStatus.PENDING,
                "source": source,
                "referral_code": data.referral_code,
                "booking_date": self._now(),
                "expires_at": None,
                "guest_name": data.guest_info.guest_name,
                "guest_email": data.guest_info.guest_email,
                "guest_phone": data.guest_info.guest_phone,
                "room_id": None,
                "bed_id": None,
            }
            booking = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()
            return self.get_booking(booking.id)

    def quick_booking(
        self,
        visitor_id: UUID,
        data: QuickBookingRequest,
        *,
        source: BookingSource = BookingSource.WEBSITE,
    ) -> BookingDetail:
        """
        Minimal quick-booking endpoint.
        """
        br = BookingRequest(
            hostel_id=data.hostel_id,
            room_type_requested=data.room_type_requested,
            preferred_check_in_date=data.check_in_date,
            stay_duration_months=data.duration_months,
            guest_info={
                "guest_name": data.name,
                "guest_email": data.email,
                "guest_phone": data.phone,
            },
        )  # type: ignore[arg-type]

        return self.create_booking_from_request(visitor_id, br, source=source)

    # ------------------------------------------------------------------ #
    # Update
    # ------------------------------------------------------------------ #
    def update_booking(self, booking_id: UUID, data: BookingUpdate) -> BookingDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)
            b = repo.get(booking_id)
            if b is None:
                raise errors.NotFoundError(f"Booking {booking_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(b, field) and field != "id":
                    setattr(b, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return self.get_booking(booking_id)

    def set_status(self, booking_id: UUID, status: BookingStatus) -> BookingDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_booking_repo(uow)
            b = repo.get(booking_id)
            if b is None:
                raise errors.NotFoundError(f"Booking {booking_id} not found")

            b.booking_status = status  # type: ignore[attr-defined]
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return self.get_booking(booking_id)

    # ------------------------------------------------------------------ #
    # Confirmation
    # ------------------------------------------------------------------ #
    def build_confirmation(self, booking_id: UUID, *, hostel_contact_email: Optional[str]) -> BookingConfirmation:
        """
        Build a BookingConfirmation response from an existing booking.
        """
        detail = self.get_booking(booking_id)
        balance = detail.total_amount - detail.advance_amount
        return BookingConfirmation(
            booking_id=detail.id,
            booking_reference=detail.booking_reference,
            hostel_name=detail.hostel_name,
            room_type=detail.room_type_requested.value if hasattr(detail.room_type_requested, "value") else str(detail.room_type_requested),
            check_in_date=detail.preferred_check_in_date,
            total_amount=detail.total_amount,
            advance_amount=detail.advance_amount,
            balance_amount=balance,
            confirmation_message="Your booking has been confirmed.",
            next_steps=[
                "Complete payment before check-in.",
                "Bring a valid ID proof.",
            ],
            hostel_contact_phone=detail.hostel_phone,
            hostel_contact_email=hostel_contact_email,
        )

# --- File: D:\hostel-management-saas\app\services\booking\booking_waitlist_service.py ---
# app/services/booking/booking_waitlist_service.py
from __future__ import annotations

from datetime import datetime, timezone, date
from decimal import Decimal
from typing import Protocol, List, Dict
from uuid import UUID

from app.schemas.booking import (
    WaitlistRequest,
    WaitlistResponse,
    WaitlistStatus as WaitlistStatusSchema,
    WaitlistNotification,
    WaitlistConversion,
    WaitlistCancellation,
    WaitlistManagement,
    WaitlistEntry,
)
from app.schemas.common.enums import WaitlistStatus as WaitlistStatusEnum, RoomType


class WaitlistStore(Protocol):
    """
    Abstract store for waitlist entries.

    Implementations can use a DB table or Redis.
    """

    def create_entry(self, data: dict) -> dict: ...
    def update_entry(self, waitlist_id: UUID, data: dict) -> dict: ...
    def get_entry(self, waitlist_id: UUID) -> dict | None: ...
    def list_for_hostel_roomtype(self, hostel_id: UUID, room_type: RoomType) -> List[dict]: ...


class BookingWaitlistService:
    """
    Manage booking waitlists when hostels are full.
    """

    def __init__(self, store: WaitlistStore) -> None:
        self._store = store

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Waitlist management
    # ------------------------------------------------------------------ #
    def add_to_waitlist(self, data: WaitlistRequest, *, hostel_name: str) -> WaitlistResponse:
        record = {
            "id": None,
            "hostel_id": str(data.hostel_id),
            "hostel_name": hostel_name,
            "visitor_id": str(data.visitor_id),
            "room_type": data.room_type.value if hasattr(data.room_type, "value") else str(data.room_type),
            "preferred_check_in_date": data.preferred_check_in_date.isoformat(),
            "contact_email": data.contact_email,
            "contact_phone": data.contact_phone,
            "notes": data.notes,
            "priority": 0,
            "status": WaitlistStatusEnum.WAITING.value,
            "created_at": self._now(),
            "estimated_availability_date": None,
            "notification_count": 0,
        }
        created = self._store.create_entry(record)

        return WaitlistResponse(
            id=UUID(created["id"]),
            created_at=created["created_at"],
            updated_at=created["created_at"],
            hostel_id=data.hostel_id,
            hostel_name=hostel_name,
            visitor_id=data.visitor_id,
            room_type=data.room_type,
            preferred_check_in_date=data.preferred_check_in_date,
            contact_email=data.contact_email,
            contact_phone=data.contact_phone,
            priority=created.get("priority", 0),
            status=WaitlistStatusSchema.WAITING,
            estimated_availability_date=None,
            created_at=created["created_at"],
        )

    def cancel_waitlist(self, data: WaitlistCancellation) -> None:
        entry = self._store.get_entry(data.waitlist_id)
        if not entry:
            return
        entry["status"] = WaitlistStatusEnum.CANCELLED.value
        entry["cancellation_reason"] = data.cancellation_reason
        self._store.update_entry(data.waitlist_id, entry)

    def notify_availability(
        self,
        waitlist_id: UUID,
        *,
        available_room_id: UUID,
        available_bed_id: UUID,
        response_deadline: datetime,
    ) -> WaitlistNotification:
        entry = self._store.get_entry(waitlist_id)
        if not entry:
            raise ValueError(f"Waitlist {waitlist_id} not found")

        entry["status"] = WaitlistStatusEnum.NOTIFIED.value
        entry["notification_count"] = entry.get("notification_count", 0) + 1
        self._store.update_entry(waitlist_id, entry)

        return WaitlistNotification(
            waitlist_id=waitlist_id,
            visitor_id=UUID(entry["visitor_id"]),
            hostel_id=UUID(entry["hostel_id"]),
            message="Room is available for your waitlist request",
            available_room_id=available_room_id,
            available_bed_id=available_bed_id,
            response_deadline=response_deadline,
            booking_link="",
        )

    def list_waitlist_for_hostel(
        self,
        hostel_id: UUID,
        room_type: RoomType,
        *,
        hostel_name: str,
    ) -> WaitlistManagement:
        entries = self._store.list_for_hostel_roomtype(hostel_id, room_type)
        waitlist_entries: List[WaitlistEntry] = []
        for e in entries:
            waitlist_entries.append(
                WaitlistEntry(
                    waitlist_id=UUID(e["id"]),
                    visitor_name="",
                    contact_email=e["contact_email"],
                    contact_phone=e["contact_phone"],
                    preferred_check_in_date=date.fromisoformat(e["preferred_check_in_date"]),
                    priority=e.get("priority", 0),
                    status=WaitlistStatusSchema[e["status"].upper()],
                    days_waiting=(date.today() - e["created_at"].date()).days,
                    created_at=e["created_at"],
                )
            )
        return WaitlistManagement(
            hostel_id=hostel_id,
            room_type=room_type,
            total_in_waitlist=len(waitlist_entries),
            entries=waitlist_entries,
        )

    def convert_waitlist_to_booking(self, data: WaitlistConversion) -> None:
        entry = self._store.get_entry(data.waitlist_id)
        if not entry:
            return

        if data.accept:
            entry["status"] = WaitlistStatusEnum.CONVERTED.value
        else:
            entry["status"] = WaitlistStatusEnum.CANCELLED.value

        self._store.update_entry(data.waitlist_id, entry)

# --- File: D:\hostel-management-saas\app\services\booking\booking_workflow_service.py ---
# app/services/booking/booking_workflow_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.workflows import BookingWorkflowRepository
from app.services.common import UnitOfWork


class BookingWorkflowService:
    """
    Wrapper over wf_booking table.

    Tracks current_status for a booking (pending, approved, rejected, checked_in, checked_out, etc.).
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> BookingWorkflowRepository:
        return uow.get_repo(BookingWorkflowRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def ensure_workflow(self, booking_id: UUID, initial_status: str) -> None:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_booking_id(booking_id)
            if wf is None:
                payload = {
                    "booking_id": booking_id,
                    "current_status": initial_status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
                uow.commit()

    def set_status(self, booking_id: UUID, status: str) -> None:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_booking_id(booking_id)
            if wf is None:
                payload = {
                    "booking_id": booking_id,
                    "current_status": status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
            else:
                wf.current_status = status  # type: ignore[attr-defined]
                wf.last_updated_at = self._now()  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

# --- File: D:\hostel-management-saas\app\services\booking\__init__.py ---
# app/services/booking/__init__.py
"""
Booking services package.

- BookingService: core booking CRUD, list/search, status, confirmations.
- BookingCalendarService: calendar & availability views.
- BookingCancellationService: cancellation & refund calculation.
- BookingConversionService: convert bookings to Student profiles.
- BookingModificationService: date/duration/room-type modifications.
- BookingWaitlistService: waitlist creation & management (store-based).
- BookingWorkflowService: wrapper over wf_booking.
- BookingAnalyticsService: booking analytics & KPIs.
"""

from .booking_service import BookingService
from .booking_calendar_service import BookingCalendarService
from .booking_cancellation_service import BookingCancellationService
from .booking_conversion_service import BookingConversionService
from .booking_modification_service import BookingModificationService
from .booking_waitlist_service import BookingWaitlistService
from .booking_workflow_service import BookingWorkflowService
from .booking_analytics_service import BookingAnalyticsService

__all__ = [
    "BookingService",
    "BookingCalendarService",
    "BookingCancellationService",
    "BookingConversionService",
    "BookingModificationService",
    "BookingWaitlistService",
    "BookingWorkflowService",
    "BookingAnalyticsService",
]


# ===== Folder: D:\hostel-management-saas\app\services\cache =====

# --- File: D:\hostel-management-saas\app\services\cache\cache_service.py ---
# app/cache/services_cache.py
from __future__ import annotations

from typing import Optional
from uuid import UUID

from app.cache.base import BaseCache, CacheBackend
from app.repositories.services import (
    AttendanceRepository,
    ComplaintRepository,
    InquiryRepository,
    LeaveApplicationRepository,
    MaintenanceRepository,
)
from models.services import (
    Attendance,
    Complaint,
    Inquiry,
    LeaveApplication,
    Maintenance,
)


class ServicesCache:
    """
    Central cache facade for service-layer entities.

    It wraps the underlying repositories with simple read-through caches
    (by primary key). Call the `invalidate_*` methods after writes.
    """

    def __init__(
        self,
        backend: CacheBackend,
        *,
        attendance_repo: AttendanceRepository,
        complaint_repo: ComplaintRepository,
        inquiry_repo: InquiryRepository,
        leave_repo: LeaveApplicationRepository,
        maintenance_repo: MaintenanceRepository,
        default_ttl: int | None = 300,
    ) -> None:
        self._attendance_repo = attendance_repo
        self._complaint_repo = complaint_repo
        self._inquiry_repo = inquiry_repo
        self._leave_repo = leave_repo
        self._maintenance_repo = maintenance_repo

        self._attendance_cache = BaseCache[Attendance](backend, prefix="attendance", default_ttl=default_ttl)
        self._complaint_cache = BaseCache[Complaint](backend, prefix="complaint", default_ttl=default_ttl)
        self._inquiry_cache = BaseCache[Inquiry](backend, prefix="inquiry", default_ttl=default_ttl)
        self._leave_cache = BaseCache[LeaveApplication](backend, prefix="leave_application", default_ttl=default_ttl)
        self._maintenance_cache = BaseCache[Maintenance](backend, prefix="maintenance", default_ttl=default_ttl)

    # ------------------------------------------------------------------ #
    # Attendance
    # ------------------------------------------------------------------ #
    def get_attendance_by_id(self, attendance_id: UUID) -> Optional[Attendance]:
        key = str(attendance_id)

        def _load() -> Optional[Attendance]:
            return self._attendance_repo.get(attendance_id)

        return self._attendance_cache.get_or_load(key, _load)

    def invalidate_attendance(self, attendance_id: UUID) -> None:
        self._attendance_cache.delete(str(attendance_id))

    # ------------------------------------------------------------------ #
    # Complaint
    # ------------------------------------------------------------------ #
    def get_complaint_by_id(self, complaint_id: UUID) -> Optional[Complaint]:
        key = str(complaint_id)

        def _load() -> Optional[Complaint]:
            return self._complaint_repo.get(complaint_id)

        return self._complaint_cache.get_or_load(key, _load)

    def invalidate_complaint(self, complaint_id: UUID) -> None:
        self._complaint_cache.delete(str(complaint_id))

    # ------------------------------------------------------------------ #
    # Inquiry
    # ------------------------------------------------------------------ #
    def get_inquiry_by_id(self, inquiry_id: UUID) -> Optional[Inquiry]:
        key = str(inquiry_id)

        def _load() -> Optional[Inquiry]:
            return self._inquiry_repo.get(inquiry_id)

        return self._inquiry_cache.get_or_load(key, _load)

    def invalidate_inquiry(self, inquiry_id: UUID) -> None:
        self._inquiry_cache.delete(str(inquiry_id))

    # ------------------------------------------------------------------ #
    # LeaveApplication
    # ------------------------------------------------------------------ #
    def get_leave_application_by_id(self, leave_id: UUID) -> Optional[LeaveApplication]:
        key = str(leave_id)

        def _load() -> Optional[LeaveApplication]:
            return self._leave_repo.get(leave_id)

        return self._leave_cache.get_or_load(key, _load)

    def invalidate_leave_application(self, leave_id: UUID) -> None:
        self._leave_cache.delete(str(leave_id))

    # ------------------------------------------------------------------ #
    # Maintenance
    # ------------------------------------------------------------------ #
    def get_maintenance_by_id(self, maintenance_id: UUID) -> Optional[Maintenance]:
        key = str(maintenance_id)

        def _load() -> Optional[Maintenance]:
            return self._maintenance_repo.get(maintenance_id)

        return self._maintenance_cache.get_or_load(key, _load)

    def invalidate_maintenance(self, maintenance_id: UUID) -> None:
        self._maintenance_cache.delete(str(maintenance_id))

# --- File: D:\hostel-management-saas\app\services\cache\__init__.py ---



# ===== Folder: D:\hostel-management-saas\app\services\commission =====

# --- File: D:\hostel-management-saas\app\services\commission\commission_service.py ---
# app/services/transactions/commission_service.py
from __future__ import annotations

from datetime import datetime, timezone
from decimal import Decimal
from typing import Optional, Tuple
from uuid import UUID

from sqlalchemy import select

from app.repositories.transactions import (
    BookingRepository,
    ReferralProgramRepository,
    ReferralRepository,
)
from app.schemas.common.enums import ReferralStatus, RewardStatus
from models.transactions import Booking, Referral, ReferralProgram


class CommissionService:
    """
    Business logic for handling referral-based commissions/rewards.

    Responsibilities:
    - Attach completed bookings to matching referrals (via referral_code).
    - Validate that a booking qualifies for a referral program (date/amount/duration).
    - Calculate reward amounts for referrer and referee.
    - Update Referral records with amounts, currency, and statuses.

    Notes:
    - This service does NOT commit the DB session; the caller must manage
      transactions (commit/rollback) around its usage.
    - It relies on the repositories' underlying SQLAlchemy session.
    """

    def __init__(
        self,
        *,
        booking_repo: BookingRepository,
        referral_repo: ReferralRepository,
        referral_program_repo: ReferralProgramRepository,
        completed_status: Optional[ReferralStatus] = None,
        earned_reward_status: Optional[RewardStatus] = None,
    ) -> None:
        """
        :param completed_status:
            Optional enum value to set on Referral.status when a referral
            is successfully completed. If None, status is not changed.
        :param earned_reward_status:
            Optional enum value to set on referrer_reward_status and
            referee_reward_status when rewards are calculated. If None,
            reward statuses are not changed.
        """
        self.booking_repo = booking_repo
        self.referral_repo = referral_repo
        self.referral_program_repo = referral_program_repo

        self.completed_status = completed_status
        self.earned_reward_status = earned_reward_status

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def process_booking_commission(self, booking_id: UUID) -> Optional[Referral]:
        """
        Main entry point: process referral commission for a given booking.

        Steps:
          1. Load booking.
          2. If booking has a referral_code, find matching Referral.
          3. Load associated ReferralProgram.
          4. Verify booking meets program criteria.
          5. Calculate reward amounts.
          6. Update Referral (booking_id, completed_at, amounts, statuses).

        Returns the updated Referral, or None if:
          - Booking not found,
          - Booking has no referral_code,
          - No matching Referral,
          - Program not found or not active,
          - Booking does not meet program criteria.
        """
        booking = self.booking_repo.get(booking_id)
        if booking is None:
            return None

        if not booking.referral_code:
            return None

        referral = self._get_referral_by_code(booking.referral_code)
        if referral is None:
            return None

        program = self.referral_program_repo.get(referral.program_id)
        if program is None or not program.is_active:
            return None

        if not self._booking_meets_program_criteria(program, booking):
            return None

        referrer_amount, referee_amount = self._calculate_reward_amounts(
            booking_total=booking.total_amount,
            program=program,
        )

        # Apply updates on Referral
        self._apply_commission_to_referral(
            referral=referral,
            program=program,
            booking=booking,
            referrer_amount=referrer_amount,
            referee_amount=referee_amount,
        )
        # Repositories do not commit; caller must commit.
        return referral

    def recalculate_commission_for_referral(self, referral_id: UUID) -> Optional[Referral]:
        """
        Recalculate commission for an existing Referral (e.g. if program
        rules changed). Uses current program configuration and linked booking.

        Returns updated Referral or None if missing data / fails validation.
        """
        referral = self.referral_repo.get(referral_id)
        if referral is None or referral.booking_id is None:
            return None

        booking = self.booking_repo.get(referral.booking_id)
        if booking is None:
            return None

        program = self.referral_program_repo.get(referral.program_id)
        if program is None or not program.is_active:
            return None

        if not self._booking_meets_program_criteria(program, booking):
            return None

        referrer_amount, referee_amount = self._calculate_reward_amounts(
            booking_total=booking.total_amount,
            program=program,
        )

        self._apply_commission_to_referral(
            referral=referral,
            program=program,
            booking=booking,
            referrer_amount=referrer_amount,
            referee_amount=referee_amount,
        )
        return referral

    def mark_referrer_reward_status(
        self,
        referral_id: UUID,
        new_status: RewardStatus,
    ) -> Optional[Referral]:
        """
        Generic helper to update the referrer's reward status.
        Does not commit; caller must commit.
        """
        referral = self.referral_repo.get(referral_id)
        if referral is None:
            return None

        referral.referrer_reward_status = new_status
        self.referral_repo.session.flush()
        return referral

    def mark_referee_reward_status(
        self,
        referral_id: UUID,
        new_status: RewardStatus,
    ) -> Optional[Referral]:
        """
        Generic helper to update the referee's reward status.
        Does not commit; caller must commit.
        """
        referral = self.referral_repo.get(referral_id)
        if referral is None:
            return None

        referral.referee_reward_status = new_status
        self.referral_repo.session.flush()
        return referral

    # ------------------------------------------------------------------ #
    # Internal helpers
    # ------------------------------------------------------------------ #
    def _get_referral_by_code(self, referral_code: str) -> Optional[Referral]:
        """
        Look up a Referral by its referral_code.

        This uses the underlying SQLAlchemy session since the repository
        does not currently expose a dedicated 'get_by_code' method.
        """
        stmt = (
            select(Referral)
            .where(Referral.referral_code == referral_code)
            .limit(1)
        )
        return self.referral_repo.session.execute(stmt).scalar_one_or_none()

    def _booking_meets_program_criteria(
        self,
        program: ReferralProgram,
        booking: Booking,
    ) -> bool:
        """
        Check if the booking satisfies the ReferralProgram constraints:
        - valid_from / valid_to date window
        - min_booking_amount
        - min_stay_months
        """
        booking_date = booking.booking_date.date()

        if program.valid_from and booking_date < program.valid_from:
            return False
        if program.valid_to and booking_date > program.valid_to:
            return False

        if program.min_booking_amount is not None:
            if booking.total_amount < program.min_booking_amount:
                return False

        if program.min_stay_months is not None:
            if booking.stay_duration_months < program.min_stay_months:
                return False

        return True

    def _calculate_reward_amounts(
        self,
        *,
        booking_total: Decimal,
        program: ReferralProgram,
    ) -> Tuple[Decimal, Decimal]:
        """
        Calculate reward amounts for referrer and referee based on program.

        Conventions:
        - If program.reward_type == "percentage":
            * referrer_reward_amount and referee_reward_amount are treated
              as percentage values (e.g., 5 means 5% of booking_total).
        - Otherwise:
            * referrer_reward_amount and referee_reward_amount are treated
              as flat amounts in program.currency.
        """
        reward_type = (program.reward_type or "").lower()

        referrer_base = program.referrer_reward_amount or Decimal("0")
        referee_base = program.referee_reward_amount or Decimal("0")

        if reward_type == "percentage":
            referrer_amount = (booking_total * referrer_base) / Decimal("100")
            referee_amount = (booking_total * referee_base) / Decimal("100")
        else:
            # flat amounts
            referrer_amount = referrer_base
            referee_amount = referee_base

        # Ensure non-negative amounts
        if referrer_amount < 0:
            referrer_amount = Decimal("0")
        if referee_amount < 0:
            referee_amount = Decimal("0")

        return referrer_amount, referee_amount

    def _apply_commission_to_referral(
        self,
        *,
        referral: Referral,
        program: ReferralProgram,
        booking: Booking,
        referrer_amount: Decimal,
        referee_amount: Decimal,
    ) -> None:
        """
        Mutate the Referral object with computed commission data and
        flush changes via the repository session.
        """
        now = datetime.now(timezone.utc)

        referral.booking_id = booking.id
        referral.completed_at = now

        referral.referrer_reward_amount = referrer_amount
        referral.referee_reward_amount = referee_amount
        referral.currency = program.currency

        if self.completed_status is not None:
            referral.status = self.completed_status

        if self.earned_reward_status is not None:
            referral.referrer_reward_status = self.earned_reward_status
            referral.referee_reward_status = self.earned_reward_status

        self.referral_repo.session.flush()

# --- File: D:\hostel-management-saas\app\services\commission\__init__.py ---



# ===== Folder: D:\hostel-management-saas\app\services\common =====

# --- File: D:\hostel-management-saas\app\services\common\mapping.py ---
# app/services/common/mapping.py
from __future__ import annotations

from typing import Any, Iterable, List, Sequence, Type, TypeVar

from pydantic import BaseModel

TModel = TypeVar("TModel")
TSchema = TypeVar("TSchema", bound=BaseModel)


def to_schema(obj: TModel, schema_cls: Type[TSchema]) -> TSchema:
    """
    Convert an ORM model (or any attribute-based object) to a Pydantic schema.

    Assumes your BaseSchema has model_config.from_attributes = True (already set).
    """
    if obj is None:
        raise ValueError("to_schema() received None")
    return schema_cls.model_validate(obj)


def to_schema_list(objs: Iterable[TModel], schema_cls: Type[TSchema]) -> List[TSchema]:
    """Convert an iterable of models to a list of schemas."""
    return [schema_cls.model_validate(o) for o in objs]


def update_model_from_schema(
    model_obj: Any,
    schema_obj: BaseModel,
    *,
    exclude_unset: bool = True,
    exclude_fields: Sequence[str] | None = None,
) -> Any:
    """
    Apply fields from a Pydantic schema object to an ORM model.

    Typical usage:
        update_model_from_schema(db_user, user_update_schema, exclude_fields=["id"])
    """
    data = schema_obj.model_dump(exclude_unset=exclude_unset)
    if exclude_fields:
        for field in exclude_fields:
            data.pop(field, None)

    for field_name, value in data.items():
        if hasattr(model_obj, field_name):
            setattr(model_obj, field_name, value)

    return model_obj

# --- File: D:\hostel-management-saas\app\services\common\pagination.py ---
# app/services/common/pagination.py
from __future__ import annotations

from typing import Callable, Iterable, List, Sequence, TypeVar

from app.schemas.common.base import BaseSchema
from app.schemas.common.pagination import (
    PaginationParams,
    PaginatedResponse,
)

TModel = TypeVar("TModel")
TSchema = TypeVar("TSchema", bound=BaseSchema)


def paginate(
    *,
    items: Sequence[TModel],
    total_items: int,
    params: PaginationParams,
    mapper: Callable[[TModel], TSchema],
) -> PaginatedResponse[TSchema]:
    """
    Build a PaginatedResponse from a list of models and total count.

    :param items: Current page of ORM objects
    :param total_items: Total count across all pages
    :param params: PaginationParams
    :param mapper: Function mapping model -> schema
    """
    schema_items: List[TSchema] = [mapper(item) for item in items]
    return PaginatedResponse[TSchema].create(
        items=schema_items,
        total_items=total_items,
        page=params.page,
        page_size=params.page_size,
    )

# --- File: D:\hostel-management-saas\app\services\common\permissions.py ---
# app/services/common/permissions.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, Mapping, Optional, Set
from uuid import UUID

from app.schemas.common.enums import UserRole


class PermissionDenied(Exception):
    """Raised when a user tries an action they are not allowed to perform."""


@dataclass(frozen=True)
class Principal:
    """
    Represents the current authenticated user in the service layer.
    """
    user_id: UUID
    role: UserRole
    # Optional fine-grained permissions (e.g. {'complaint.view', 'student.edit'})
    permissions: Optional[Set[str]] = None


def role_in(principal: Principal, allowed_roles: Iterable[UserRole]) -> bool:
    """Return True if principal.role is in allowed_roles."""
    return principal.role in set(allowed_roles)


def has_permission(
    principal: Principal,
    permission_key: str,
    *,
    matrix: Optional[Mapping[UserRole, Set[str]]] = None,
) -> bool:
    """
    Check if the principal has a given permission.

    Resolution:
    1. Check explicit principal.permissions if provided.
    2. Fallback to role-based matrix if provided.
    """
    if principal.permissions is not None and permission_key in principal.permissions:
        return True

    if matrix is not None:
        allowed_for_role = matrix.get(principal.role, set())
        if permission_key in allowed_for_role:
            return True

    return False


def require_permission(
    principal: Principal,
    permission_key: str,
    *,
    matrix: Optional[Mapping[UserRole, Set[str]]] = None,
) -> None:
    """
    Assert that the principal has the specified permission.

    Raises PermissionDenied if not.
    """
    if not has_permission(principal, permission_key, matrix=matrix):
        raise PermissionDenied(
            f"User {principal.user_id} with role {principal.role.value!r} "
            f"lacks permission {permission_key!r}"
        )

# --- File: D:\hostel-management-saas\app\services\common\security.py ---
# app/services/common/security.py
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, Optional
from uuid import UUID

from jose import JWTError, jwt
from passlib.context import CryptContext

from app.schemas.common.enums import UserRole


_pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


@dataclass(frozen=True)
class JWTSettings:
    """
    Runtime JWT configuration.

    Typically instantiated from environment / settings, e.g.:

        jwt_settings = JWTSettings(
            secret_key=settings.JWT_SECRET_KEY,
            algorithm=settings.JWT_ALGORITHM,
            access_token_expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES,
            refresh_token_expires_days=settings.REFRESH_TOKEN_EXPIRE_DAYS,
        )
    """
    secret_key: str
    algorithm: str = "HS256"
    access_token_expires_minutes: int = 60  # default 1 hour
    refresh_token_expires_days: int = 30


# ------------------------------------------------------------------ #
# Password hashing
# ------------------------------------------------------------------ #
def hash_password(password: str) -> str:
    """Hash a plaintext password."""
    return _pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a plaintext password against a stored hash."""
    return _pwd_context.verify(plain_password, hashed_password)


# ------------------------------------------------------------------ #
# JWT helpers
# ------------------------------------------------------------------ #
def _utcnow() -> datetime:
    return datetime.now(timezone.utc)


class TokenDecodeError(Exception):
    """Raised when token decoding fails."""


def create_access_token(
    *,
    subject: UUID,
    email: str,
    role: UserRole,
    jwt_settings: JWTSettings,
    additional_claims: Optional[Dict[str, Any]] = None,
    expires_delta: Optional[timedelta] = None,
) -> str:
    """
    Create a signed JWT access token.

    :param subject: User ID
    :param email: User email
    :param role: User role
    :param jwt_settings: JWT configuration
    :param additional_claims: optional extra claims to embed
    :param expires_delta: custom expiry (overrides default)
    """
    now = _utcnow()
    if expires_delta is None:
        expires_delta = timedelta(minutes=jwt_settings.access_token_expires_minutes)
    expire = now + expires_delta

    payload: Dict[str, Any] = {
        "sub": str(subject),
        "user_id": str(subject),
        "email": email,
        "role": role.value,
        "iat": int(now.timestamp()),
        "exp": int(expire.timestamp()),
        "type": "access",
    }
    if additional_claims:
        payload.update(additional_claims)

    return jwt.encode(payload, jwt_settings.secret_key, algorithm=jwt_settings.algorithm)


def create_refresh_token(
    *,
    subject: UUID,
    jwt_settings: JWTSettings,
    additional_claims: Optional[Dict[str, Any]] = None,
) -> str:
    """
    Create a signed JWT refresh token.
    """
    now = _utcnow()
    expire = now + timedelta(days=jwt_settings.refresh_token_expires_days)

    payload: Dict[str, Any] = {
        "sub": str(subject),
        "user_id": str(subject),
        "iat": int(now.timestamp()),
        "exp": int(expire.timestamp()),
        "type": "refresh",
    }
    if additional_claims:
        payload.update(additional_claims)

    return jwt.encode(payload, jwt_settings.secret_key, algorithm=jwt_settings.algorithm)


def decode_token(token: str, jwt_settings: JWTSettings) -> Dict[str, Any]:
    """
    Decode a JWT and return its payload.

    Raises TokenDecodeError when invalid or expired.
    """
    try:
        payload = jwt.decode(
            token,
            jwt_settings.secret_key,
            algorithms=[jwt_settings.algorithm],
        )
        return payload
    except JWTError as exc:
        raise TokenDecodeError("Invalid or expired token") from exc

# --- File: D:\hostel-management-saas\app\services\common\unit_of_work.py ---
# app/services/common/unit_of_work.py
from __future__ import annotations

from contextlib import AbstractContextManager
from typing import Callable, Generic, TypeVar

from sqlalchemy.orm import Session

from app.repositories.base import BaseRepository

TRepository = TypeVar("TRepository", bound=BaseRepository)


class UnitOfWork(AbstractContextManager["UnitOfWork"]):
    """
    Simple Unit of Work abstraction over a SQLAlchemy Session.

    Usage:
        uow = UnitOfWork(session_factory)
        with uow as tx:
            user_repo = tx.get_repo(UserRepository)
            user = user_repo.get(user_id)
            ...
            tx.commit()  # optional; auto-commits if no exception
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory
        self.session: Session | None = None
        self._committed: bool = False

    # ------------------------------------------------------------------ #
    # Context manager protocol
    # ------------------------------------------------------------------ #
    def __enter__(self) -> "UnitOfWork":
        self.session = self._session_factory()
        self._committed = False
        return self

    def __exit__(self, exc_type, exc, tb) -> bool:
        if self.session is None:
            return False

        try:
            if exc_type is None:
                # Commit if we haven't already committed manually
                if not self._committed:
                    self.session.commit()
            else:
                # Roll back on error
                self.session.rollback()
        finally:
            self.session.close()
            self.session = None

        # Propagate any exception
        return False

    # ------------------------------------------------------------------ #
    # Transaction helpers
    # ------------------------------------------------------------------ #
    def commit(self) -> None:
        """Explicitly commit current transaction."""
        if self.session is None:
            raise RuntimeError("UnitOfWork.commit() called outside of context")
        self.session.commit()
        self._committed = True

    def rollback(self) -> None:
        """Explicitly roll back current transaction."""
        if self.session is None:
            raise RuntimeError("UnitOfWork.rollback() called outside of context")
        self.session.rollback()
        self._committed = False

    # ------------------------------------------------------------------ #
    # Repository factory
    # ------------------------------------------------------------------ #
    def get_repo(self, repo_cls: type[TRepository]) -> TRepository:
        """
        Instantiate a repository bound to this UnitOfWork's Session.

        Example:
            with UnitOfWork(SessionLocal) as uow:
                user_repo = uow.get_repo(UserRepository)
        """
        if self.session is None:
            raise RuntimeError("UnitOfWork.get_repo() called outside of context")
        return repo_cls(self.session)

# --- File: D:\hostel-management-saas\app\services\common\__init__.py ---
# app/services/common/__init__.py
"""
Shared service-layer infrastructure.

- UnitOfWork: transaction boundary & repository factory
- security: password hashing and JWT helpers
- permissions: generic RBAC helpers
- mapping: model <-> schema utilities
- pagination: helpers to build PaginatedResponse objects
"""

from .unit_of_work import UnitOfWork
from . import security
from . import permissions
from . import mapping
from . import pagination

__all__ = [
    "UnitOfWork",
    "security",
    "permissions",
    "mapping",
    "pagination",
]


# ===== Folder: D:\hostel-management-saas\app\services\complaint =====

# --- File: D:\hostel-management-saas\app\services\complaint\complaint_analytics_service.py ---
# app/services/complaint/complaint_analytics_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, List, Dict, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import ComplaintRepository
from app.schemas.complaint import (
    ComplaintAnalytics,
    ResolutionMetrics,
    CategoryAnalysis,
    CategoryMetrics,
    ComplaintTrendPoint,
    ComplaintHeatmap,
    RoomComplaintCount,
)
from app.schemas.common.filters import DateRangeFilter
from app.schemas.common.enums import ComplaintStatus, Priority
from app.services.common import UnitOfWork


class ComplaintAnalyticsService:
    """
    Basic complaint analytics computed from svc_complaint.

    For heavy reporting, consider dedicated reporting/ETL paths;
    this is intended for dashboard-level stats.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> ComplaintRepository:
        return uow.get_repo(ComplaintRepository)

    # ------------------------------------------------------------------ #
    # High-level analytics
    # ------------------------------------------------------------------ #
    def get_analytics_for_hostel(
        self,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> ComplaintAnalytics:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            complaints = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

            # Filter by opened_at date range in Python for simplicity
            filtered = []
            for c in complaints:
                opened_date = c.opened_at.date() if c.opened_at else None
                if opened_date is None:
                    continue
                if period.start_date and opened_date < period.start_date:
                    continue
                if period.end_date and opened_date > period.end_date:
                    continue
                filtered.append(c)

            total = len(filtered)
            open_count = 0
            resolved_count = 0
            closed_count = 0

            total_resolved_hours = 0.0
            resolved_with_time = 0
            sla_breached = 0
            escalated = 0  # not explicitly tracked; left as 0

            category_counts: Dict[str, int] = {}
            total_resolution_time_by_cat: Dict[str, float] = {}

            for c in filtered:
                if c.status == ComplaintStatus.OPEN:
                    open_count += 1
                if c.status == ComplaintStatus.RESOLVED:
                    resolved_count += 1
                if c.status == ComplaintStatus.CLOSED:
                    closed_count += 1
                if c.sla_breach:
                    sla_breached += 1

                cat_key = c.category.value if hasattr(c.category, "value") else str(c.category)
                category_counts[cat_key] = category_counts.get(cat_key, 0) + 1

                if c.resolved_at and c.opened_at:
                    diff_hours = (c.resolved_at - c.opened_at).total_seconds() / 3600.0
                    total_resolved_hours += diff_hours
                    resolved_with_time += 1
                    total_resolution_time_by_cat[cat_key] = (
                        total_resolution_time_by_cat.get(cat_key, 0.0) + diff_hours
                    )

            avg_resolution = (
                Decimal(str(total_resolved_hours / resolved_with_time))
                if resolved_with_time > 0
                else Decimal("0")
            )

            resolution_rate = (
                Decimal(str(resolved_count / total * 100)) if total > 0 else Decimal("0")
            )
            same_day_rate = Decimal("0")  # can be derived if needed
            escalation_rate = Decimal("0")  # placeholder
            reopen_rate = Decimal("0")

            res_metrics = ResolutionMetrics(
                total_resolved=resolved_count,
                average_resolution_time_hours=avg_resolution,
                median_resolution_time_hours=Decimal("0"),
                fastest_resolution_hours=Decimal("0"),
                slowest_resolution_hours=Decimal("0"),
                resolution_rate=resolution_rate,
                same_day_resolution_rate=same_day_rate,
                escalation_rate=escalation_rate,
                reopen_rate=reopen_rate,
            )

            cat_metrics: List[CategoryMetrics] = []
            for cat, count in category_counts.items():
                avg_cat_res = Decimal(
                    str(
                        total_resolution_time_by_cat.get(cat, 0.0) / count
                        if count > 0
                        else 0.0
                    )
                )
                cat_metrics.append(
                    CategoryMetrics(
                        category=cat,
                        total_complaints=count,
                        open_complaints=0,
                        resolved_complaints=0,
                        average_resolution_time_hours=avg_cat_res,
                        resolution_rate=Decimal("0"),
                        percentage_of_total=Decimal(
                            str(count / total * 100) if total > 0 else "0"
                        ),
                    )
                )

            cat_analysis = CategoryAnalysis(
                categories=cat_metrics,
                most_common_category=cat_metrics[0].category if cat_metrics else "",
                most_problematic_category=cat_metrics[0].category if cat_metrics else "",
            )

            # Simple trend: group by date
            trend_by_date: Dict[str, Dict[str, int]] = {}
            for c in filtered:
                d = c.opened_at.date().isoformat() if c.opened_at else None
                if not d:
                    continue
                bucket = trend_by_date.setdefault(
                    d, {"total": 0, "open": 0, "resolved": 0, "urgent": 0, "high": 0, "medium": 0, "low": 0}
                )
                bucket["total"] += 1
                if c.status == ComplaintStatus.OPEN:
                    bucket["open"] += 1
                if c.status == ComplaintStatus.RESOLVED:
                    bucket["resolved"] += 1
                # Priority buckets
                if c.priority in (Priority.URGENT, Priority.CRITICAL):
                    bucket["urgent"] += 1
                elif c.priority == Priority.HIGH:
                    bucket["high"] += 1
                elif c.priority == Priority.MEDIUM:
                    bucket["medium"] += 1
                else:
                    bucket["low"] += 1

            trend_points: List[ComplaintTrendPoint] = []
            for d, vals in sorted(trend_by_date.items()):
                trend_points.append(
                    ComplaintTrendPoint(
                        period=d,
                        total_complaints=vals["total"],
                        open_complaints=vals["open"],
                        resolved_complaints=vals["resolved"],
                        urgent_count=vals["urgent"],
                        high_count=vals["high"],
                        medium_count=vals["medium"],
                        low_count=vals["low"],
                    )
                )

            priority_dist: Dict[str, int] = {}
            for c in filtered:
                key = c.priority.value if hasattr(c.priority, "value") else str(c.priority)
                priority_dist[key] = priority_dist.get(key, 0) + 1

            return ComplaintAnalytics(
                hostel_id=hostel_id,
                period_start=period.start_date or date.min,
                period_end=period.end_date or date.max,
                total_complaints=total,
                open_complaints=open_count,
                resolved_complaints=resolved_count,
                closed_complaints=closed_count,
                resolution_metrics=res_metrics,
                category_analysis=cat_analysis,
                priority_distribution=priority_dist,
                complaint_trend=trend_points,
                sla_compliance_rate=Decimal(
                    str((total - sla_breached) / total * 100) if total > 0 else "0"
                ),
                sla_breached_count=sla_breached,
                top_resolvers=[],
            )

# --- File: D:\hostel-management-saas\app\services\complaint\complaint_assignment_service.py ---
# app/services/complaint/complaint_assignment_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import ComplaintRepository
from app.repositories.core import SupervisorRepository, UserRepository
from app.schemas.complaint import (
    AssignmentRequest,
    AssignmentResponse,
    ReassignmentRequest,
    BulkAssignment,
    UnassignRequest,
)
from app.schemas.common.enums import ComplaintStatus
from app.services.common import UnitOfWork, errors


class ComplaintAssignmentService:
    """
    Handle assigning / reassigning complaints to supervisors.

    This service updates:
    - complaint.assigned_to_id
    - complaint.status (e.g. ASSIGNED)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_complaint_repo(self, uow: UnitOfWork) -> ComplaintRepository:
        return uow.get_repo(ComplaintRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def _complaint_number(self, complaint_id: UUID) -> str:
        return f"CMP-{str(complaint_id)[:8].upper()}"

    # ------------------------------------------------------------------ #
    # Assignment
    # ------------------------------------------------------------------ #
    def assign(self, data: AssignmentRequest, *, assigned_by_id: UUID) -> AssignmentResponse:
        with UnitOfWork(self._session_factory) as uow:
            complaint_repo = self._get_complaint_repo(uow)
            supervisor_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)

            complaint = complaint_repo.get(data.complaint_id)
            if complaint is None:
                raise errors.NotFoundError(f"Complaint {data.complaint_id} not found")

            supervisor = supervisor_repo.get(data.assigned_to)
            if supervisor is None:
                raise errors.NotFoundError(f"Supervisor {data.assigned_to} not found")

            assigned_to_user = user_repo.get(supervisor.user_id)
            assigned_by_user = user_repo.get(assigned_by_id)

            complaint.assigned_to_id = data.assigned_to  # type: ignore[attr-defined]
            # Move status to ASSIGNED if currently OPEN
            if complaint.status == ComplaintStatus.OPEN:
                complaint.status = ComplaintStatus.ASSIGNED  # type: ignore[attr-defined]

            assigned_at = self._now()
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            return AssignmentResponse(
                complaint_id=complaint.id,
                complaint_number=self._complaint_number(complaint.id),
                assigned_to=data.assigned_to,
                assigned_to_name=assigned_to_user.full_name if assigned_to_user else "",
                assigned_by=assigned_by_id,
                assigned_by_name=assigned_by_user.full_name if assigned_by_user else "",
                assigned_at=assigned_at,
                message="Complaint assigned successfully",
            )

    def reassign(self, data: ReassignmentRequest, *, reassigned_by_id: UUID) -> AssignmentResponse:
        """
        Reassign complaint to a different supervisor.
        """
        with UnitOfWork(self._session_factory) as uow:
            complaint_repo = self._get_complaint_repo(uow)
            supervisor_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)

            complaint = complaint_repo.get(data.complaint_id)
            if complaint is None:
                raise errors.NotFoundError(f"Complaint {data.complaint_id} not found")

            supervisor = supervisor_repo.get(data.new_assigned_to)
            if supervisor is None:
                raise errors.NotFoundError(f"Supervisor {data.new_assigned_to} not found")

            assigned_to_user = user_repo.get(supervisor.user_id)
            reassigned_by_user = user_repo.get(reassigned_by_id)

            complaint.assigned_to_id = data.new_assigned_to  # type: ignore[attr-defined]
            if complaint.status in (ComplaintStatus.OPEN, ComplaintStatus.ASSIGNED):
                complaint.status = ComplaintStatus.ASSIGNED  # type: ignore[attr-defined]

            assigned_at = self._now()
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            return AssignmentResponse(
                complaint_id=complaint.id,
                complaint_number=self._complaint_number(complaint.id),
                assigned_to=data.new_assigned_to,
                assigned_to_name=assigned_to_user.full_name if assigned_to_user else "",
                assigned_by=reassigned_by_id,
                assigned_by_name=reassigned_by_user.full_name if reassigned_by_user else "",
                assigned_at=assigned_at,
                message="Complaint reassigned successfully",
            )

    def bulk_assign(self, data: BulkAssignment, *, assigned_by_id: UUID) -> List[AssignmentResponse]:
        responses: List[AssignmentResponse] = []
        for cid in data.complaint_ids:
            req = AssignmentRequest(
                complaint_id=cid,
                assigned_to=data.assigned_to,
                estimated_resolution_time=None,
                assignment_notes=data.assignment_notes,
            )
            responses.append(self.assign(req, assigned_by_id=assigned_by_id))
        return responses

    def unassign(self, data: UnassignRequest, *, unassigned_by_id: UUID) -> None:
        with UnitOfWork(self._session_factory) as uow:
            complaint_repo = self._get_complaint_repo(uow)

            complaint = complaint_repo.get(data.complaint_id)
            if complaint is None:
                raise errors.NotFoundError(f"Complaint {data.complaint_id} not found")

            complaint.assigned_to_id = None  # type: ignore[attr-defined]
            # Optionally move back to OPEN
            complaint.status = ComplaintStatus.OPEN  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

# --- File: D:\hostel-management-saas\app\services\complaint\complaint_escalation_service.py ---
# app/services/complaint/complaint_escalation_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Protocol, List, Optional
from uuid import UUID

from app.schemas.complaint import (
    EscalationRequest,
    EscalationResponse,
    EscalationHistory,
    EscalationEntry,
    AutoEscalationRule,
)
from app.services.common import errors


class EscalationStore(Protocol):
    """
    Abstract storage for complaint escalations and auto-escalation rules.

    Implementations can use Redis, a dedicated DB table, etc.
    """

    def save_escalation(self, complaint_id: UUID, record: dict) -> None: ...
    def list_escalations(self, complaint_id: UUID) -> List[dict]: ...
    def get_rule(self, hostel_id: UUID) -> Optional[dict]: ...
    def save_rule(self, hostel_id: UUID, rule: dict) -> None: ...


class ComplaintEscalationService:
    """
    Manage manual and automatic escalations for complaints.

    NOTE:
    - This service does not modify the Complaint model directly; it records
      escalation metadata in an EscalationStore. You can hook it together
      with ComplaintService / ComplaintAssignmentService as needed.
    """

    def __init__(self, store: EscalationStore) -> None:
        self._store = store

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Manual escalation
    # ------------------------------------------------------------------ #
    def escalate(
        self,
        data: EscalationRequest,
        *,
        escalated_by_id: UUID,
        escalated_by_name: str,
        escalated_to_name: str,
    ) -> EscalationResponse:
        now = self._now()
        record = {
            "id": UUID.hex(UUID(int=0)),  # placeholder if you want IDs; customize
            "escalated_to": str(data.escalate_to),
            "escalated_to_name": escalated_to_name,
            "escalated_by": str(escalated_by_id),
            "escalated_by_name": escalated_by_name,
            "escalated_at": now,
            "reason": data.escalation_reason,
            "status_before": None,
            "priority_before": None,
            "priority_after": None,
        }
        self._store.save_escalation(data.complaint_id, record)

        return EscalationResponse(
            complaint_id=data.complaint_id,
            complaint_number="",  # can be filled by caller with ComplaintService
            escalated=True,
            escalated_to=data.escalate_to,
            escalated_to_name=escalated_to_name,
            escalated_by=escalated_by_id,
            escalated_by_name=escalated_by_name,
            escalated_at=now,
            new_priority="",
            message="Complaint escalated successfully",
        )

    def get_history(self, complaint_id: UUID, complaint_number: str) -> EscalationHistory:
        records = self._store.list_escalations(complaint_id)
        entries: List[EscalationEntry] = []
        for r in records:
            entries.append(
                EscalationEntry(
                    id=None,  # BaseResponseSchema fields can be left None if not used
                    created_at=r.get("escalated_at"),
                    updated_at=r.get("escalated_at"),
                    escalated_to=UUID(r["escalated_to"]),
                    escalated_to_name=r.get("escalated_to_name"),
                    escalated_by=UUID(r["escalated_by"]),
                    escalated_by_name=r.get("escalated_by_name"),
                    escalated_at=r.get("escalated_at"),
                    reason=r.get("reason"),
                    status_before=r.get("status_before"),
                    priority_before=r.get("priority_before"),
                    priority_after=r.get("priority_after"),
                    response_time_hours=None,
                    resolved_after_escalation=False,
                )
            )

        return EscalationHistory(
            complaint_id=complaint_id,
            complaint_number=complaint_number,
            escalations=entries,
            total_escalations=len(entries),
        )

    # ------------------------------------------------------------------ #
    # Auto-escalation rule config (hostel-level)
    # ------------------------------------------------------------------ #
    def get_auto_rule(self, hostel_id: UUID) -> Optional[AutoEscalationRule]:
        record = self._store.get_rule(hostel_id)
        if not record:
            return None
        return AutoEscalationRule.model_validate(record)

    def set_auto_rule(self, rule: AutoEscalationRule) -> None:
        self._store.save_rule(rule.hostel_id, rule.model_dump())

# --- File: D:\hostel-management-saas\app\services\complaint\complaint_feedback_service.py ---
# app/services/complaint/complaint_feedback_service.py
from __future__ import annotations

from datetime import datetime, date, timezone
from typing import Protocol, List, Optional
from uuid import UUID

from app.schemas.complaint import (
    FeedbackRequest,
    FeedbackResponse,
    FeedbackSummary,
    FeedbackAnalysis,
    RatingTrendPoint,
)
from app.schemas.common.filters import DateRangeFilter


class FeedbackStore(Protocol):
    """
    Abstract storage for complaint feedback.

    Each implementation should persist feedback records and allow querying.
    """

    def save_feedback(self, record: dict) -> None: ...
    def list_feedback_for_complaint(self, complaint_id: UUID) -> List[dict]: ...
    def list_feedback_for_scope(
        self,
        *,
        entity_id: UUID,
        from_date: Optional[date],
        to_date: Optional[date],
    ) -> List[dict]: ...


class ComplaintFeedbackService:
    """
    Manage feedback on resolved complaints.

    NOTE:
    - This service is storage-agnostic; you need to provide a FeedbackStore.
    """

    def __init__(self, store: FeedbackStore) -> None:
        self._store = store

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Submit feedback
    # ------------------------------------------------------------------ #
    def submit_feedback(
        self,
        data: FeedbackRequest,
        *,
        submitted_by: UUID,
        submitted_by_name: str,
    ) -> FeedbackResponse:
        record = {
            "complaint_id": str(data.complaint_id),
            "rating": data.rating,
            "feedback": data.feedback,
            "issue_resolved_satisfactorily": data.issue_resolved_satisfactorily,
            "response_time_satisfactory": data.response_time_satisfactory,
            "staff_helpful": data.staff_helpful,
            "would_recommend": data.would_recommend,
            "submitted_by": str(submitted_by),
            "submitted_at": self._now(),
        }
        self._store.save_feedback(record)

        return FeedbackResponse(
            id=None,
            created_at=record["submitted_at"],
            updated_at=record["submitted_at"],
            complaint_id=data.complaint_id,
            complaint_number="",
            rating=data.rating,
            feedback=data.feedback,
            submitted_by=submitted_by,
            submitted_at=record["submitted_at"],
            message="Feedback submitted successfully",
        )

    # ------------------------------------------------------------------ #
    # Summary / analysis (hostel or supervisor)
    # ------------------------------------------------------------------ #
    def get_summary(
        self,
        entity_id: UUID,
        entity_type: str,
        period_start: date,
        period_end: date,
    ) -> FeedbackSummary:
        records = self._store.list_feedback_for_scope(
            entity_id=entity_id,
            from_date=period_start,
            to_date=period_end,
        )
        total = len(records)
        if total == 0:
            return FeedbackSummary(
                entity_id=entity_id,
                entity_type=entity_type,
                period_start=period_start,
                period_end=period_end,
                total_feedbacks=0,
                average_rating=0,
                rating_5_count=0,
                rating_4_count=0,
                rating_3_count=0,
                rating_2_count=0,
                rating_1_count=0,
                resolution_satisfaction_rate=0,
                response_time_satisfaction_rate=0,
                staff_helpfulness_rate=0,
                recommendation_rate=0,
                positive_feedback_count=0,
                negative_feedback_count=0,
                common_themes=[],
            )

        rating_counts = {i: 0 for i in range(1, 6)}
        sum_ratings = 0
        res_sat = 0
        resp_time_sat = 0
        staff_help = 0
        recommend = 0

        for r in records:
            rating = int(r.get("rating", 0))
            if rating in rating_counts:
                rating_counts[rating] += 1
                sum_ratings += rating
            if r.get("issue_resolved_satisfactorily"):
                res_sat += 1
            if r.get("response_time_satisfactory"):
                resp_time_sat += 1
            if r.get("staff_helpful"):
                staff_help += 1
            if r.get("would_recommend"):
                recommend += 1

        avg_rating = sum_ratings / total if total > 0 else 0
        pct = lambda x: (x / total * 100) if total > 0 else 0

        return FeedbackSummary(
            entity_id=entity_id,
            entity_type=entity_type,
            period_start=period_start,
            period_end=period_end,
            total_feedbacks=total,
            average_rating=avg_rating,
            rating_5_count=rating_counts[5],
            rating_4_count=rating_counts[4],
            rating_3_count=rating_counts[3],
            rating_2_count=rating_counts[2],
            rating_1_count=rating_counts[1],
            resolution_satisfaction_rate=pct(res_sat),
            response_time_satisfaction_rate=pct(resp_time_sat),
            staff_helpfulness_rate=pct(staff_help),
            recommendation_rate=pct(recommend),
            positive_feedback_count=0,
            negative_feedback_count=0,
            common_themes=[],
        )

    def get_analysis(
        self,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> FeedbackAnalysis:
        records = self._store.list_feedback_for_scope(
            entity_id=hostel_id,
            from_date=period.start_date,
            to_date=period.end_date,
        )
        total = len(records)
        if total == 0:
            return FeedbackAnalysis(
                hostel_id=hostel_id,
                period_start=period.start_date,
                period_end=period.end_date,
                rating_trend=[],
                feedback_by_category={},
                feedback_by_priority={},
                avg_rating_quick_response=0,
                avg_rating_slow_response=0,
            )

        # Simplified analysis, extend as needed
        return FeedbackAnalysis(
            hostel_id=hostel_id,
            period_start=period.start_date,
            period_end=period.end_date,
            rating_trend=[],
            feedback_by_category={},
            feedback_by_priority={},
            avg_rating_quick_response=0,
            avg_rating_slow_response=0,
        )

# --- File: D:\hostel-management-saas\app\services\complaint\complaint_service.py ---
# app/services/complaint/complaint_service.py
from __future__ import annotations

from datetime import datetime, timezone, date
from typing import Callable, Optional, Sequence, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import ComplaintRepository
from app.repositories.core import RoomRepository, StudentRepository
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.common.enums import ComplaintStatus, Priority
from app.schemas.complaint import (
    ComplaintCreate,
    ComplaintUpdate,
    ComplaintStatusUpdate,
    ComplaintResponse,
    ComplaintDetail,
    ComplaintListItem,
    ComplaintFilterParams,
    ComplaintSortOptions,
    ComplaintSummary,
)
from app.services.common import UnitOfWork, pagination, errors


class ComplaintService:
    """
    Core Complaint service:

    - Create / update complaints
    - Change status
    - Retrieve single complaint detail
    - List complaints with basic filters/sorting
    - Summary stats per hostel
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_repo(self, uow: UnitOfWork) -> ComplaintRepository:
        return uow.get_repo(ComplaintRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def _complaint_number(self, complaint_id: UUID) -> str:
        # Simple complaint number format; customize as needed
        return f"CMP-{str(complaint_id)[:8].upper()}"

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_list_item(self, c, now: Optional[datetime] = None, room_number: Optional[str] = None,
                      raised_by_name: Optional[str] = None,
                      assigned_to_name: Optional[str] = None) -> ComplaintListItem:
        if now is None:
            now = self._now()
        opened_at = c.opened_at
        age_hours = int((now - opened_at).total_seconds() // 3600) if opened_at else 0

        return ComplaintListItem(
            id=c.id,
            complaint_number=self._complaint_number(c.id),
            title=c.title,
            category=c.category.value if hasattr(c.category, "value") else str(c.category),
            priority=c.priority.value if hasattr(c.priority, "value") else str(c.priority),
            status=c.status,
            raised_by_name=raised_by_name or "",
            room_number=room_number,
            assigned_to_name=assigned_to_name,
            opened_at=opened_at,
            age_hours=age_hours,
            sla_breach=c.sla_breach,
        )

    def _to_response(self, c, now: Optional[datetime] = None) -> ComplaintResponse:
        if now is None:
            now = self._now()
        opened_at = c.opened_at
        age_hours = int((now - opened_at).total_seconds() // 3600) if opened_at else 0

        hostel_name = c.hostel.name if getattr(c, "hostel", None) else ""
        raised_by_name = c.raised_by.full_name if getattr(c, "raised_by", None) else ""
        assigned_to_name = None
        if getattr(c, "assigned_to", None) is not None and getattr(c.assigned_to, "user", None):
            assigned_to_name = c.assigned_to.user.full_name

        return ComplaintResponse(
            id=c.id,
            created_at=c.created_at,
            updated_at=c.updated_at,
            complaint_number=self._complaint_number(c.id),
            hostel_id=c.hostel_id,
            hostel_name=hostel_name,
            raised_by=c.raised_by_id,
            raised_by_name=raised_by_name,
            student_id=c.student_id,
            title=c.title,
            category=c.category,
            priority=c.priority,
            status=c.status,
            assigned_to=c.assigned_to_id,
            assigned_to_name=assigned_to_name,
            opened_at=c.opened_at,
            resolved_at=c.resolved_at,
            sla_breach=c.sla_breach,
            age_hours=age_hours,
        )

    def _to_detail(self, c, room_number: Optional[str] = None,
                   student_name: Optional[str] = None) -> ComplaintDetail:
        hostel = getattr(c, "hostel", None)
        raised_by = getattr(c, "raised_by", None)
        raised_by_user = raised_by
        assigned_to = getattr(c, "assigned_to", None)
        assigned_to_user = getattr(assigned_to, "user", None)

        assigned_by = None
        assigned_by_name = None

        closed_by = None
        closed_by_name = None

        escalated = False
        escalated_to = None
        escalated_to_name = None
        escalated_at = None
        escalation_reason = None

        overridden_by_admin = False
        override_admin_id = None
        override_timestamp = None
        override_reason = None

        # Note: for comments/feedback/override/escalation details you may want
        # dedicated models; this implementation focuses on Complaint core fields.
        return ComplaintDetail(
            id=c.id,
            created_at=c.created_at,
            updated_at=c.updated_at,
            complaint_number=self._complaint_number(c.id),
            hostel_id=c.hostel_id,
            hostel_name=hostel.name if hostel else "",
            raised_by=c.raised_by_id,
            raised_by_name=raised_by_user.full_name if raised_by_user else "",
            raised_by_email=raised_by_user.email if raised_by_user else "",
            raised_by_phone=raised_by_user.phone if getattr(raised_by_user, "phone", None) else "",
            student_id=c.student_id,
            student_name=student_name,
            room_number=room_number,
            title=c.title,
            description=c.description,
            category=c.category,
            sub_category=c.sub_category,
            priority=c.priority,
            room_id=c.room_id,
            location_details=c.location_details,
            attachments=c.attachments or [],
            assigned_to=c.assigned_to_id,
            assigned_to_name=assigned_to_user.full_name if assigned_to_user else None,
            assigned_by=assigned_by,
            assigned_by_name=assigned_by_name,
            assigned_at=None,
            reassigned_count=0,
            status=c.status,
            opened_at=c.opened_at,
            in_progress_at=c.in_progress_at,
            resolved_at=c.resolved_at,
            closed_at=c.closed_at,
            closed_by=closed_by,
            closed_by_name=closed_by_name,
            resolution_notes=None,
            resolution_attachments=[],
            estimated_resolution_time=None,
            actual_resolution_time=None,
            student_feedback=None,
            student_rating=None,
            feedback_submitted_at=None,
            sla_breach=c.sla_breach,
            sla_breach_reason=c.sla_breach_reason,
            escalated=escalated,
            escalated_to=escalated_to,
            escalated_to_name=escalated_to_name,
            escalated_at=escalated_at,
            escalation_reason=escalation_reason,
            overridden_by_admin=overridden_by_admin,
            override_admin_id=override_admin_id,
            override_timestamp=override_timestamp,
            override_reason=override_reason,
            total_comments=0,
            age_hours=int((self._now() - c.opened_at).total_seconds() // 3600) if c.opened_at else 0,
            time_to_resolve_hours=None,
        )

    # ------------------------------------------------------------------ #
    # Read operations
    # ------------------------------------------------------------------ #
    def get_complaint(self, complaint_id: UUID) -> ComplaintDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            room_repo = self._get_room_repo(uow)
            student_repo = self._get_student_repo(uow)

            c = repo.get(complaint_id)
            if c is None:
                raise errors.NotFoundError(f"Complaint {complaint_id} not found")

            room_number = None
            if c.room_id:
                room = room_repo.get(c.room_id)
                room_number = room.room_number if room else None

            student_name = None
            if c.student_id:
                student = student_repo.get(c.student_id)
                if student and getattr(student, "user", None):
                    student_name = student.user.full_name

            return self._to_detail(c, room_number=room_number, student_name=student_name)

    # ------------------------------------------------------------------ #
    # Listing
    # ------------------------------------------------------------------ #
    def list_complaints(
        self,
        params: PaginationParams,
        filters: Optional[ComplaintFilterParams] = None,
        sort: Optional[ComplaintSortOptions] = None,
    ) -> PaginatedResponse[ComplaintListItem]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            raw_filters: dict = {}
            if filters:
                if filters.hostel_id:
                    raw_filters["hostel_id"] = filters.hostel_id
                if filters.raised_by:
                    raw_filters["raised_by_id"] = filters.raised_by
                if filters.student_id:
                    raw_filters["student_id"] = filters.student_id
                if filters.assigned_to:
                    raw_filters["assigned_to_id"] = filters.assigned_to
                if filters.category:
                    raw_filters["category"] = filters.category
                if filters.priority:
                    raw_filters["priority"] = filters.priority
                if filters.status:
                    raw_filters["status"] = filters.status
                if filters.room_id:
                    raw_filters["room_id"] = filters.room_id
                if filters.sla_breached_only:
                    raw_filters["sla_breach"] = True

            # Sorting
            order_by = None
            if sort:
                col_map = {
                    "opened_at": repo.model.opened_at,      # type: ignore[attr-defined]
                    "priority": repo.model.priority,        # type: ignore[attr-defined]
                    "status": repo.model.status,            # type: ignore[attr-defined]
                    "category": repo.model.category,        # type: ignore[attr-defined]
                    "age": repo.model.opened_at,            # type: ignore[attr-defined]
                }
                sort_col = col_map.get(sort.sort_by, repo.model.opened_at)  # type: ignore[attr-defined]
                order_by = [sort_col.asc() if sort.sort_order == "asc" else sort_col.desc()]

            records: Sequence = repo.get_multi(
                skip=params.offset,
                limit=params.limit,
                filters=raw_filters or None,
                order_by=order_by,
            )
            total = repo.count(filters=raw_filters or None)

            now = self._now()
            items: List[ComplaintListItem] = []
            for c in records:
                raised_by_name = c.raised_by.full_name if getattr(c, "raised_by", None) else ""
                assigned_to_name = None
                if getattr(c, "assigned_to", None) is not None and getattr(c.assigned_to, "user", None):
                    assigned_to_name = c.assigned_to.user.full_name
                room_number = None
                if c.room_id and getattr(c, "room", None):
                    room_number = c.room.room_number
                items.append(self._to_list_item(c, now=now,
                                                room_number=room_number,
                                                raised_by_name=raised_by_name,
                                                assigned_to_name=assigned_to_name))

            return PaginatedResponse[ComplaintListItem].create(
                items=items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    def list_open_for_hostel(
        self,
        hostel_id: UUID,
        params: PaginationParams,
        *,
        category: Optional[ComplaintStatus] = None,
        priority: Optional[Priority] = None,
    ) -> PaginatedResponse[ComplaintListItem]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            records = repo.list_open_for_hostel(
                hostel_id,
                category=category,
                priority=priority,
            )
            total = len(records)
            start = params.offset
            end = start + params.limit
            page_items = records[start:end]

            now = self._now()
            items = []
            for c in page_items:
                raised_by_name = c.raised_by.full_name if getattr(c, "raised_by", None) else ""
                assigned_to_name = None
                if getattr(c, "assigned_to", None) is not None and getattr(c.assigned_to, "user", None):
                    assigned_to_name = c.assigned_to.user.full_name
                items.append(self._to_list_item(c, now=now,
                                                raised_by_name=raised_by_name,
                                                assigned_to_name=assigned_to_name))

            return PaginatedResponse[ComplaintListItem].create(
                items=items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    # ------------------------------------------------------------------ #
    # Create / update / status
    # ------------------------------------------------------------------ #
    def create_complaint(self, data: ComplaintCreate) -> ComplaintDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            payload = data.model_dump()
            # Ensure initial status
            payload.setdefault("status", ComplaintStatus.OPEN)
            complaint = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            # For detail we may want student/room names; keep it minimal here
            return self.get_complaint(complaint.id)

    def update_complaint(self, complaint_id: UUID, data: ComplaintUpdate) -> ComplaintDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            complaint = repo.get(complaint_id)
            if complaint is None:
                raise errors.NotFoundError(f"Complaint {complaint_id} not found")

            # Prevent direct status manipulation here; use status_update
            update_data = data.model_copy()
            update_data.status = None
            mapping_dict = update_data.model_dump(exclude_unset=True)
            for field, value in mapping_dict.items():
                if field == "status":
                    continue
                if hasattr(complaint, field):
                    setattr(complaint, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return self.get_complaint(complaint_id)

    def update_status(self, complaint_id: UUID, data: ComplaintStatusUpdate) -> ComplaintDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            complaint = repo.get(complaint_id)
            if complaint is None:
                raise errors.NotFoundError(f"Complaint {complaint_id} not found")

            new_status = data.status
            now = self._now()

            complaint.status = new_status  # type: ignore[attr-defined]
            if new_status == ComplaintStatus.IN_PROGRESS and complaint.in_progress_at is None:
                complaint.in_progress_at = now  # type: ignore[attr-defined]
            if new_status == ComplaintStatus.RESOLVED and complaint.resolved_at is None:
                complaint.resolved_at = now  # type: ignore[attr-defined]
            if new_status == ComplaintStatus.CLOSED and complaint.closed_at is None:
                complaint.closed_at = now  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return self.get_complaint(complaint_id)

    # ------------------------------------------------------------------ #
    # Summary
    # ------------------------------------------------------------------ #
    def get_summary_for_hostel(self, hostel_id: UUID) -> ComplaintSummary:
        """
        Simple summary metrics for a hostel's complaints.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            complaints = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

            total = len(complaints)
            open_count = 0
            in_progress = 0
            resolved = 0
            high_priority = 0
            urgent_priority = 0
            sla_breached = 0
            total_resolution_hours = 0
            resolved_with_time = 0

            for c in complaints:
                if c.status == ComplaintStatus.OPEN:
                    open_count += 1
                if c.status == ComplaintStatus.IN_PROGRESS:
                    in_progress += 1
                if c.status == ComplaintStatus.RESOLVED:
                    resolved += 1

                if c.priority == Priority.HIGH:
                    high_priority += 1
                if c.priority in (Priority.URGENT, Priority.CRITICAL):
                    urgent_priority += 1

                if c.sla_breach:
                    sla_breached += 1

                if c.resolved_at and c.opened_at:
                    diff = c.resolved_at - c.opened_at
                    hours = diff.total_seconds() / 3600.0
                    total_resolution_hours += hours
                    resolved_with_time += 1

            avg_resolution = (
                total_resolution_hours / resolved_with_time if resolved_with_time > 0 else 0.0
            )

            return ComplaintSummary(
                hostel_id=hostel_id,
                total_complaints=total,
                open_complaints=open_count,
                in_progress_complaints=in_progress,
                resolved_complaints=resolved,
                high_priority_count=high_priority,
                urgent_priority_count=urgent_priority,
                sla_breached_count=sla_breached,
                average_resolution_time_hours=avg_resolution,
            )

# --- File: D:\hostel-management-saas\app\services\complaint\complaint_workflow_service.py ---
# app/services/complaint/complaint_workflow_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.workflows import ComplaintWorkflowRepository
from app.services.common import UnitOfWork, errors


class ComplaintWorkflowService:
    """
    Lightweight wrapper over the wf_complaint table.

    Tracks a single workflow row per complaint with the current_status.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> ComplaintWorkflowRepository:
        return uow.get_repo(ComplaintWorkflowRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def ensure_workflow(self, complaint_id: UUID, initial_status: str) -> None:
        """
        Ensure there is a workflow row for this complaint.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_complaint_id(complaint_id)
            if wf is None:
                payload = {
                    "complaint_id": complaint_id,
                    "current_status": initial_status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
                uow.commit()

    def set_status(self, complaint_id: UUID, status: str) -> None:
        """
        Update workflow status for complaint.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_complaint_id(complaint_id)
            if wf is None:
                # Create if missing
                payload = {
                    "complaint_id": complaint_id,
                    "current_status": status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
            else:
                wf.current_status = status  # type: ignore[attr-defined]
                wf.last_updated_at = self._now()  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

# --- File: D:\hostel-management-saas\app\services\complaint\__init__.py ---
# app/services/complaint/__init__.py
"""
Complaint-related services.

- ComplaintService: core CRUD, listing, status updates, summaries.
- ComplaintAssignmentService: assign/reassign/unassign complaints.
- ComplaintEscalationService: escalation metadata & rules (store-agnostic).
- ComplaintFeedbackService: feedback capture & basic analytics (store-agnostic).
- ComplaintWorkflowService: wrapper over wf_complaint.
- ComplaintAnalyticsService: basic hostel-level complaint analytics.
"""

from .complaint_service import ComplaintService
from .complaint_assignment_service import ComplaintAssignmentService
from .complaint_escalation_service import ComplaintEscalationService
from .complaint_feedback_service import ComplaintFeedbackService
from .complaint_workflow_service import ComplaintWorkflowService
from .complaint_analytics_service import ComplaintAnalyticsService

__all__ = [
    "ComplaintService",
    "ComplaintAssignmentService",
    "ComplaintEscalationService",
    "ComplaintFeedbackService",
    "ComplaintWorkflowService",
    "ComplaintAnalyticsService",
]


# ===== Folder: D:\hostel-management-saas\app\services\fee_structure =====

# --- File: D:\hostel-management-saas\app\services\fee_structure\fee_config_service.py ---
# app/services/fee_structure/fee_config_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import FeeStructureRepository
from app.schemas.fee_structure import (
    FeeConfiguration,
    ChargesBreakdown,
)
from app.schemas.common.enums import RoomType, FeeType, ChargeType
from app.services.common import UnitOfWork, errors


class FeeConfigService:
    """
    Compute effective fee configuration & breakdown for a given hostel/room type.

    - Uses FeeStructureRepository.get_effective_fee(as_of)
    - Produces FeeConfiguration + ChargesBreakdown
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_fee_repo(self, uow: UnitOfWork) -> FeeStructureRepository:
        return uow.get_repo(FeeStructureRepository)

    # ------------------------------------------------------------------ #
    # Main API
    # ------------------------------------------------------------------ #
    def get_effective_fee_configuration(
        self,
        *,
        hostel_id: UUID,
        room_type: RoomType,
        fee_type: FeeType,
        as_of: date,
    ) -> FeeConfiguration:
        """
        Get effective FeeConfiguration for a specific hostel/room_type/fee_type on a given date.
        """
        with UnitOfWork(self._session_factory) as uow:
            fee_repo = self._get_fee_repo(uow)
            fs = fee_repo.get_effective_fee(
                hostel_id=hostel_id,
                room_type=room_type,
                fee_type=fee_type,
                as_of=as_of,
            )
            if fs is None:
                raise errors.NotFoundError(
                    f"No active fee structure for hostel={hostel_id}, room_type={room_type}, fee_type={fee_type} as of {as_of}"
                )

        base = fs.amount or Decimal("0")
        security_deposit = fs.security_deposit or Decimal("0")
        mess = fs.mess_charges_monthly or Decimal("0") if fs.includes_mess else Decimal("0")

        # Electricity
        elec = Decimal("0")
        if fs.electricity_charges == ChargeType.FIXED and fs.electricity_fixed_amount:
            elec = fs.electricity_fixed_amount
        # PER_UNIT or INCLUDED: treat as 0 for base configuration; billing can happen separately.

        # Water
        water = Decimal("0")
        if fs.water_charges == ChargeType.FIXED and fs.water_fixed_amount:
            water = fs.water_fixed_amount

        other = Decimal("0")

        total_monthly = base + mess + elec + water + other
        total_first_month = total_monthly + security_deposit

        breakdown = ChargesBreakdown(
            base_rent=base,
            mess_charges=mess,
            electricity_charges=elec,
            water_charges=water,
            other_charges=other,
            total_monthly=total_monthly,
            total_first_month=total_first_month,
            security_deposit=security_deposit,
        )

        return FeeConfiguration(
            hostel_id=hostel_id,
            room_type=room_type,
            fee_type=fee_type,
            base_amount=base,
            security_deposit=security_deposit,
            includes_mess=fs.includes_mess,
            mess_charges_monthly=fs.mess_charges_monthly,
            electricity_charges=fs.electricity_charges,
            electricity_fixed_amount=fs.electricity_fixed_amount,
            water_charges=fs.water_charges,
            water_fixed_amount=fs.water_fixed_amount,
            breakdown=breakdown,
        )

# --- File: D:\hostel-management-saas\app\services\fee_structure\fee_structure_service.py ---
# app/services/fee_structure/fee_structure_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import FeeStructureRepository
from app.repositories.core import HostelRepository
from app.schemas.fee_structure import (
    FeeStructureCreate,
    FeeStructureUpdate,
    FeeStructureResponse,
    FeeStructureList,
    FeeDetail,
)
from app.schemas.common.enums import ChargeType
from app.services.common import UnitOfWork, errors


class FeeStructureService:
    """
    Manage fee structures per hostel & room type.

    - Create / update fee structures
    - Get single fee structure
    - List fee structures for a hostel
    - Compute FeeDetail list for UI (derived first-month & recurring totals)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_fee_repo(self, uow: UnitOfWork) -> FeeStructureRepository:
        return uow.get_repo(FeeStructureRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_response(self, fs, *, hostel_name: str) -> FeeStructureResponse:
        return FeeStructureResponse(
            id=fs.id,
            created_at=fs.created_at,
            updated_at=fs.updated_at,
            hostel_id=fs.hostel_id,
            hostel_name=hostel_name,
            room_type=fs.room_type,
            fee_type=fs.fee_type,
            amount=fs.amount,
            security_deposit=fs.security_deposit,
            includes_mess=fs.includes_mess,
            mess_charges_monthly=fs.mess_charges_monthly,
            electricity_charges=fs.electricity_charges,
            electricity_fixed_amount=fs.electricity_fixed_amount,
            water_charges=fs.water_charges,
            water_fixed_amount=fs.water_fixed_amount,
            effective_from=fs.effective_from,
            effective_to=fs.effective_to,
            is_active=fs.is_active,
        )

    def _to_fee_detail(self, fs) -> FeeDetail:
        """
        Compute FeeDetail from a FeeStructure row.
        """
        base = fs.amount or Decimal("0")
        mess = fs.mess_charges_monthly or Decimal("0") if fs.includes_mess else Decimal("0")

        elec = Decimal("0")
        if fs.electricity_charges == ChargeType.FIXED and fs.electricity_fixed_amount:
            elec = fs.electricity_fixed_amount

        water = Decimal("0")
        if fs.water_charges == ChargeType.FIXED and fs.water_fixed_amount:
            water = fs.water_fixed_amount

        total_recurring = base + mess + elec + water
        total_first_month = total_recurring + (fs.security_deposit or Decimal("0"))

        return FeeDetail(
            room_type=fs.room_type,
            fee_type=fs.fee_type,
            amount=fs.amount,
            security_deposit=fs.security_deposit,
            includes_mess=fs.includes_mess,
            mess_charges_monthly=fs.mess_charges_monthly,
            total_first_month_payable=total_first_month,
            total_recurring_monthly=total_recurring,
        )

    # ------------------------------------------------------------------ #
    # Core operations
    # ------------------------------------------------------------------ #
    def get_fee_structure(self, fee_id: UUID) -> FeeStructureResponse:
        with UnitOfWork(self._session_factory) as uow:
            fee_repo = self._get_fee_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            fs = fee_repo.get(fee_id)
            if fs is None:
                raise errors.NotFoundError(f"FeeStructure {fee_id} not found")

            hostel = hostel_repo.get(fs.hostel_id)
            hostel_name = hostel.name if hostel else ""
            return self._to_response(fs, hostel_name=hostel_name)

    def list_for_hostel(self, hostel_id: UUID) -> FeeStructureList:
        with UnitOfWork(self._session_factory) as uow:
            fee_repo = self._get_fee_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")
            hostel_name = hostel.name

            records = fee_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
                order_by=[fee_repo.model.room_type.asc()],  # type: ignore[attr-defined]
            )

            items: List[FeeStructureResponse] = [
                self._to_response(fs, hostel_name=hostel_name) for fs in records
            ]

            return FeeStructureList(
                hostel_id=hostel_id,
                hostel_name=hostel_name,
                items=items,
            )

    def create_fee_structure(self, data: FeeStructureCreate) -> FeeStructureResponse:
        """
        Create a new fee structure.

        NOTE: Does not enforce overlap checks between effective_from/effective_to;
        add that if needed.
        """
        with UnitOfWork(self._session_factory) as uow:
            fee_repo = self._get_fee_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            payload = data.model_dump()
            fs = fee_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            return self._to_response(fs, hostel_name=hostel.name)

    def update_fee_structure(
        self,
        fee_id: UUID,
        data: FeeStructureUpdate,
    ) -> FeeStructureResponse:
        """
        Update an existing fee structure.
        """
        with UnitOfWork(self._session_factory) as uow:
            fee_repo = self._get_fee_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            fs = fee_repo.get(fee_id)
            if fs is None:
                raise errors.NotFoundError(f"FeeStructure {fee_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(fs, field) and field != "id":
                    setattr(fs, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            hostel = hostel_repo.get(fs.hostel_id)
            hostel_name = hostel.name if hostel else ""
            return self._to_response(fs, hostel_name=hostel_name)

    def deactivate_fee_structure(self, fee_id: UUID) -> FeeStructureResponse:
        """
        Soft-deactivate a fee structure (set is_active = False, effective_to = today).
        """
        from datetime import date as _date

        with UnitOfWork(self._session_factory) as uow:
            fee_repo = self._get_fee_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            fs = fee_repo.get(fee_id)
            if fs is None:
                raise errors.NotFoundError(f"FeeStructure {fee_id} not found")

            fs.is_active = False  # type: ignore[attr-defined]
            if not fs.effective_to:
                fs.effective_to = _date.today()  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            hostel = hostel_repo.get(fs.hostel_id)
            hostel_name = hostel.name if hostel else ""
            return self._to_response(fs, hostel_name=hostel_name)

    # ------------------------------------------------------------------ #
    # Fee details for UI
    # ------------------------------------------------------------------ #
    def get_fee_details_for_hostel(self, hostel_id: UUID) -> List[FeeDetail]:
        """
        Return FeeDetail items for all active fee structures in a hostel.
        """
        with UnitOfWork(self._session_factory) as uow:
            fee_repo = self._get_fee_repo(uow)

            records = fee_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id, "is_active": True},
            )

        return [self._to_fee_detail(fs) for fs in records]

# --- File: D:\hostel-management-saas\app\services\fee_structure\__init__.py ---
# app/services/fee_structure/__init__.py
"""
Fee structure services.

- FeeStructureService: CRUD & listing for fee structures per hostel.
- FeeConfigService: compute effective fee configuration & breakdown.
"""

from .fee_structure_service import FeeStructureService
from .fee_config_service import FeeConfigService

__all__ = [
    "FeeStructureService",
    "FeeConfigService",
]


# ===== Folder: D:\hostel-management-saas\app\services\file =====

# --- File: D:\hostel-management-saas\app\services\file\document_service.py ---
# app/services/file/document_service.py
from __future__ import annotations

from datetime import date, datetime, timezone
from typing import List, Optional, Protocol
from uuid import UUID

from app.schemas.file import (
    DocumentUploadInitRequest,
    DocumentUploadInitResponse,
    DocumentValidationResult,
)
from app.schemas.file.document_upload import DocumentInfo, DocumentList
from app.schemas.file.file_upload import FileUploadInitRequest
from app.services.common import errors
from app.services.file.file_service import FileService


class DocumentStore(Protocol):
    """
    Abstract storage for document metadata (beyond generic files).

    A typical record stored by this protocol might include:
    - id (UUID)
    - storage_key
    - document_type
    - description
    - uploaded_by_user_id
    - student_id / hostel_id
    - uploaded_at (date)
    - verified, verified_by, verified_at, verification_notes
    """

    def create_document(self, data: dict) -> dict: ...
    def get_document(self, doc_id: UUID) -> Optional[dict]: ...
    def list_documents_for_owner(self, owner_type: str, owner_id: UUID) -> List[dict]: ...
    def update_document(self, doc_id: UUID, data: dict) -> dict: ...


class DocumentService:
    """
    Document-specific file handling:

    - Initialize document uploads (PDF or image-as-document)
    - Validate basic properties of uploaded document
    - List documents for a student/hostel/system
    - Read single DocumentInfo
    """

    def __init__(self, file_service: FileService, store: DocumentStore) -> None:
        self._files = file_service
        self._store = store

    def _today(self) -> date:
        return datetime.now(timezone.utc).date()

    # ------------------------------------------------------------------ #
    # Upload init
    # ------------------------------------------------------------------ #
    def init_document_upload(
        self,
        req: DocumentUploadInitRequest,
        *,
        folder: Optional[str] = None,
        is_public: bool = False,
    ) -> DocumentUploadInitResponse:
        """
        Initialize a document upload and create a corresponding document record.

        The actual upload is still handled via FileService and object storage.
        """
        effective_folder = folder or "documents"
        if req.hostel_id:
            effective_folder = f"hostels/{req.hostel_id}/documents"
        elif req.student_id:
            effective_folder = f"students/{req.student_id}/documents"

        file_req = FileUploadInitRequest(
            filename=req.filename,
            content_type=req.content_type,
            size_bytes=req.size_bytes,
            folder=effective_folder,
            uploaded_by_user_id=req.uploaded_by_user_id,
            hostel_id=req.hostel_id,
            category="document",
            tags=[req.document_type],
            is_public=is_public,
        )
        file_resp = self._files.init_upload(file_req)

        # Pre-create document metadata in store
        doc_record = {
            "id": None,  # store may assign UUID
            "storage_key": file_resp.storage_key,
            "document_type": req.document_type,
            "description": req.description,
            "uploaded_by_user_id": req.uploaded_by_user_id,
            "student_id": str(req.student_id) if req.student_id else None,
            "hostel_id": str(req.hostel_id) if req.hostel_id else None,
            "uploaded_at": self._today(),
            "verified": False,
            "verified_by": None,
            "verified_at": None,
            "verification_notes": None,
        }
        self._store.create_document(doc_record)

        # Response is just the generic FileUploadInitResponse shape
        return DocumentUploadInitResponse.model_validate(file_resp.model_dump())

    # ------------------------------------------------------------------ #
    # Validation (simple stub)
    # ------------------------------------------------------------------ #
    def validate_document(
        self,
        storage_key: str,
    ) -> DocumentValidationResult:
        """
        Simple backend-side validation of a document:

        - Confirms the file exists
        - Optionally could check size/mime from FileInfo

        For now, we treat existence as "valid".
        """
        file_info = self._files.get_file(storage_key)

        # Add any additional validation logic here if needed
        is_valid = True
        reason = None

        return DocumentValidationResult(
            storage_key=storage_key,
            is_valid=is_valid,
            reason=reason,
            extracted_metadata=None,
        )

    # ------------------------------------------------------------------ #
    # Read operations
    # ------------------------------------------------------------------ #
    def get_document(self, doc_id: UUID) -> DocumentInfo:
        rec = self._store.get_document(doc_id)
        if not rec:
            raise errors.NotFoundError(f"Document {doc_id} not found")

        storage_key = rec["storage_key"]
        file_info = self._files.get_file(storage_key)

        # Choose URL (prefer public_url, else signed_url)
        url = file_info.public_url or file_info.signed_url
        if url is None:
            # As a fallback, generate a short-lived signed URL
            url_obj = self._files.get_file_url(storage_key, expires_in_seconds=3600)
            url = url_obj.url

        return DocumentInfo(
            id=doc_id,
            storage_key=storage_key,
            url=url,
            document_type=rec.get("document_type", "other"),
            description=rec.get("description"),
            uploaded_by_user_id=rec["uploaded_by_user_id"],
            uploaded_by_name=rec.get("uploaded_by_name"),
            uploaded_at=rec.get("uploaded_at", self._today()),
            verified=rec.get("verified", False),
            verified_by=rec.get("verified_by"),
            verified_at=rec.get("verified_at"),
            verification_notes=rec.get("verification_notes"),
        )

    def list_documents(
        self,
        *,
        owner_type: str,
        owner_id: UUID,
    ) -> DocumentList:
        """
        List documents for a given owner (student|hostel|system).
        """
        records = self._store.list_documents_for_owner(owner_type, owner_id)
        docs: List[DocumentInfo] = []

        for r in records:
            doc_id = r.get("id")
            if not doc_id:
                continue
            docs.append(self.get_document(doc_id))

        return DocumentList(
            owner_type=owner_type,
            owner_id=owner_id,
            documents=docs,
            total_documents=len(docs),
        )

# --- File: D:\hostel-management-saas\app\services\file\file_service.py ---
# app/services/file/file_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import List, Optional, Protocol, Tuple
from uuid import UUID

from app.schemas.file import (
    FileUploadInitRequest,
    FileUploadInitResponse,
    FileUploadCompleteRequest,
    FileInfo,
    FileListResponse,
    FileURL,
)
from app.services.common import errors


class FileStore(Protocol):
    """
    Abstract storage for file metadata and URL generation.

    A typical implementation will:
    - Persist file records in a DB table
    - Generate storage_keys
    - Optionally generate pre-signed upload URLs & signed download URLs
    """

    def init_upload(self, payload: dict) -> dict:
        """
        Initialize upload and persist a pending file record.

        Expected to return a dict compatible with FileUploadInitResponse
        (plus any internal fields).
        """
        ...

    def complete_upload(
        self,
        *,
        storage_key: str,
        uploaded_by_user_id: UUID,
        checksum: Optional[str],
    ) -> dict:
        """
        Mark the file as uploaded and finalize metadata.

        Expected to return a dict compatible with FileInfo.
        """
        ...

    def get_file(self, storage_key: str) -> Optional[dict]:
        """Fetch file metadata by storage_key."""
        ...

    def list_files(
        self,
        *,
        hostel_id: Optional[UUID],
        offset: int,
        limit: int,
    ) -> Tuple[List[dict], int]:
        """
        List files for a hostel (or platform-wide if hostel_id is None).

        Returns (items, total_items).
        Each item should be compatible with FileInfo.
        """
        ...

    def get_file_url(
        self,
        storage_key: str,
        *,
        expires_in_seconds: Optional[int] = None,
    ) -> dict:
        """
        Generate a URL (public or signed) for the given storage_key.

        Should return a dict compatible with FileURL.
        """
        ...


class FileService:
    """
    Generic file service for:

    - Initializing uploads (pre-signed URL style or API upload)
    - Completing uploads (marking as stored)
    - Retrieving file metadata
    - Listing files
    - Generating a single file URL (FileURL)
    """

    def __init__(self, store: FileStore) -> None:
        self._store = store

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Upload lifecycle
    # ------------------------------------------------------------------ #
    def init_upload(self, req: FileUploadInitRequest) -> FileUploadInitResponse:
        """
        Initialize a file upload.

        Delegates to FileStore.init_upload(), which should:
        - Generate a storage_key
        - Optionally generate upload_url and public_url
        - Persist a pending file record
        """
        payload = req.model_dump()
        record = self._store.init_upload(payload)
        return FileUploadInitResponse.model_validate(record)

    def complete_upload(self, req: FileUploadCompleteRequest) -> FileInfo:
        """
        Mark an upload as completed and return final FileInfo.
        """
        record = self._store.complete_upload(
            storage_key=req.storage_key,
            uploaded_by_user_id=req.uploaded_by_user_id,
            checksum=req.checksum,
        )
        return FileInfo.model_validate(record)

    # ------------------------------------------------------------------ #
    # Read operations
    # ------------------------------------------------------------------ #
    def get_file(self, storage_key: str) -> FileInfo:
        record = self._store.get_file(storage_key)
        if not record:
            raise errors.NotFoundError(f"File with storage_key {storage_key!r} not found")
        return FileInfo.model_validate(record)

    def list_files(
        self,
        *,
        hostel_id: Optional[UUID],
        page: int,
        page_size: int,
    ) -> FileListResponse:
        """
        List files (optionally scoped to a hostel), using simple page/page_size.
        """
        if page < 1 or page_size <= 0:
            raise errors.ValidationError("Invalid pagination parameters")

        offset = (page - 1) * page_size
        items_raw, total = self._store.list_files(
            hostel_id=hostel_id,
            offset=offset,
            limit=page_size,
        )
        items = [FileInfo.model_validate(r) for r in items_raw]
        return FileListResponse(
            items=items,
            total_items=total,
            page=page,
            page_size=page_size,
        )

    def get_file_url(
        self,
        storage_key: str,
        *,
        expires_in_seconds: Optional[int] = None,
    ) -> FileURL:
        """
        Return a FileURL for a given storage_key.

        For public files, the store may ignore expires_in_seconds
        and just return a stable public URL.
        """
        record = self._store.get_file_url(
            storage_key,
            expires_in_seconds=expires_in_seconds,
        )
        return FileURL.model_validate(record)

# --- File: D:\hostel-management-saas\app\services\file\image_service.py ---
# app/services/file/image_service.py
from __future__ import annotations

from typing import Optional, List

from app.schemas.file import (
    ImageUploadInitRequest,
    ImageUploadInitResponse,
    ImageProcessingResult,
    ImageVariant,
    FileUploadInitRequest,
)
from app.services.file.file_service import FileService


class ImageService:
    """
    Image upload helper on top of the generic FileService.

    Responsibilities:
    - Validate & initialize image uploads using ImageUploadInitRequest
    - Delegate actual upload handling to FileService
    - Optionally assemble ImageProcessingResult for post-processing flows
    """

    def __init__(self, file_service: FileService) -> None:
        self._file_service = file_service

    # ------------------------------------------------------------------ #
    # Upload init
    # ------------------------------------------------------------------ #
    def init_image_upload(
        self,
        req: ImageUploadInitRequest,
        *,
        folder: Optional[str] = None,
        is_public: bool = True,
    ) -> ImageUploadInitResponse:
        """
        Initialize an image upload by mapping to FileUploadInitRequest.
        """
        # Simple folder heuristic if not given
        effective_folder = folder
        if not effective_folder:
            if req.hostel_id:
                effective_folder = f"hostels/{req.hostel_id}/images"
            else:
                effective_folder = "images"

        file_req = FileUploadInitRequest(
            filename=req.filename,
            content_type=req.content_type,
            size_bytes=req.size_bytes,
            folder=effective_folder,
            uploaded_by_user_id=req.uploaded_by_user_id,
            hostel_id=req.hostel_id,
            category="image",
            tags=[req.usage],
            is_public=is_public,
        )
        base_resp = self._file_service.init_upload(file_req)
        # Reuse same fields; ImageUploadInitResponse extends FileUploadInitResponse
        return ImageUploadInitResponse.model_validate(base_resp.model_dump())

    # ------------------------------------------------------------------ #
    # Post-processing result assembly
    # ------------------------------------------------------------------ #
    def build_processing_result(
        self,
        *,
        storage_key: str,
        original_url: str,
        variants: List[ImageVariant],
    ) -> ImageProcessingResult:
        """
        Convenience helper to create ImageProcessingResult after an image
        processing pipeline has generated variants.

        This does not persist anything by itself; persistence is left
        to the caller if needed.
        """
        return ImageProcessingResult(
            storage_key=storage_key,
            original_url=original_url,
            variants=variants,
        )

# --- File: D:\hostel-management-saas\app\services\file\__init__.py ---
# app/services/file/__init__.py
"""
File management services.

- FileService: generic file upload lifecycle & metadata access.
- ImageService: image-specific upload helper.
- DocumentService: document-specific upload & listing.
"""

from .file_service import FileService, FileStore
from .image_service import ImageService
from .document_service import DocumentService, DocumentStore

__all__ = [
    "FileService",
    "FileStore",
    "ImageService",
    "DocumentService",
    "DocumentStore",
]


# ===== Folder: D:\hostel-management-saas\app\services\hostel =====

# --- File: D:\hostel-management-saas\app\services\hostel\hostel_admin_view_service.py ---
# app/services/hostel/hostel_admin_view_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, Optional, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository, StudentRepository
from app.repositories.transactions import (
    PaymentRepository,
    BookingRepository,
    SubscriptionRepository,
    SubscriptionPlanRepository,
)
from app.repositories.services import ComplaintRepository, MaintenanceRepository
from app.schemas.common.enums import (
    PaymentStatus,
    BookingStatus,
    StudentStatus,
    SubscriptionPlan as SubscriptionPlanEnum,
)
from app.schemas.hostel import HostelAdminView, HostelSettings
from app.services.common import UnitOfWork, errors


class HostelSettingsStore(Protocol):
    """
    Abstract storage for per-hostel admin settings.

    Implementations can use a dedicated DB table, Redis, etc.
    """

    def get_settings(self, hostel_id: UUID) -> Optional[dict]: ...
    def save_settings(self, hostel_id: UUID, data: dict) -> None: ...


class HostelAdminViewService:
    """
    Admin-facing hostel dashboard service.

    - Build HostelAdminView (aggregated stats & status)
    - Get/update HostelSettings (config; store-backed)
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        settings_store: Optional[HostelSettingsStore] = None,
    ) -> None:
        self._session_factory = session_factory
        self._settings_store = settings_store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _get_booking_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    def _get_complaint_repo(self, uow: UnitOfWork) -> ComplaintRepository:
        return uow.get_repo(ComplaintRepository)

    def _get_maintenance_repo(self, uow: UnitOfWork) -> MaintenanceRepository:
        return uow.get_repo(MaintenanceRepository)

    def _get_sub_repo(self, uow: UnitOfWork) -> SubscriptionRepository:
        return uow.get_repo(SubscriptionRepository)

    def _get_plan_repo(self, uow: UnitOfWork) -> SubscriptionPlanRepository:
        return uow.get_repo(SubscriptionPlanRepository)

    def _today(self) -> date:
        return date.today()

    # ------------------------------------------------------------------ #
    # Admin view
    # ------------------------------------------------------------------ #
    def get_admin_view(self, hostel_id: UUID) -> HostelAdminView:
        """
        Build a single HostelAdminView for admin dashboard.

        Aggregates:
        - Capacity & occupancy
        - Student counts
        - Financial (this month's revenue, outstanding)
        - Pending bookings/complaints/maintenance
        - Subscription plan & expiry
        - Ratings & reviews
        """
        today = self._today()

        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)
            payment_repo = self._get_payment_repo(uow)
            booking_repo = self._get_booking_repo(uow)
            complaint_repo = self._get_complaint_repo(uow)
            maintenance_repo = self._get_maintenance_repo(uow)
            sub_repo = self._get_sub_repo(uow)
            plan_repo = self._get_plan_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            # Capacity & occupancy
            total_rooms = hostel.total_rooms or 0
            total_beds = hostel.total_beds or 0
            occupied_beds = hostel.occupied_beds or 0
            available_beds = max(0, total_beds - occupied_beds)
            occupancy_percentage = (
                Decimal(str(occupied_beds / total_beds * 100))
                if total_beds > 0
                else Decimal("0")
            )

            # Students
            students = student_repo.list_for_hostel(hostel_id, status=None)
            total_students = len(students)
            active_students = sum(
                1
                for s in students
                if s.student_status == StudentStatus.ACTIVE
            )

            # Financial: this month's revenue + outstanding
            payments = payment_repo.get_multi(filters={"hostel_id": hostel_id})
            total_revenue_this_month = Decimal("0")
            outstanding_payments = Decimal("0")
            for p in payments:
                if (
                    p.payment_status == PaymentStatus.COMPLETED
                    and p.paid_at is not None
                ):
                    paid_date = p.paid_at.date()
                    if paid_date.year == today.year and paid_date.month == today.month:
                        total_revenue_this_month += p.amount
                if p.payment_status == PaymentStatus.PENDING:
                    outstanding_payments += p.amount

            # Pending items
            pending_bookings = len(
                booking_repo.list_pending_for_hostel(hostel_id)
            )
            pending_complaints = len(
                complaint_repo.list_open_for_hostel(
                    hostel_id,
                    category=None,
                    priority=None,
                )
            )
            pending_maintenance = len(
                maintenance_repo.list_open_for_hostel(
                    hostel_id,
                    category=None,
                    priority=None,
                )
            )

            # Subscription
            active_sub = sub_repo.get_active_for_hostel(hostel_id, as_of=today)
            subscription_plan: Optional[SubscriptionPlanEnum] = None
            subscription_expires_at = None
            if active_sub:
                plan = plan_repo.get(active_sub.plan_id)
                if plan:
                    subscription_plan = plan.plan_type
                subscription_expires_at = active_sub.end_date

            # Ratings/reviews from hostel snapshot
            avg_rating = Decimal(str(hostel.average_rating or 0.0))
            total_reviews = hostel.total_reviews or 0

            return HostelAdminView(
                id=hostel.id,
                name=hostel.name,
                slug=hostel.slug,
                status=hostel.status,
                is_active=hostel.is_active,
                is_public=hostel.is_public,
                is_featured=hostel.is_featured,
                is_verified=hostel.is_verified,
                total_rooms=total_rooms,
                total_beds=total_beds,
                occupied_beds=occupied_beds,
                available_beds=available_beds,
                occupancy_percentage=occupancy_percentage,
                total_students=total_students,
                active_students=active_students,
                total_revenue_this_month=total_revenue_this_month,
                outstanding_payments=outstanding_payments,
                pending_bookings=pending_bookings,
                pending_complaints=pending_complaints,
                pending_maintenance=pending_maintenance,
                subscription_plan=subscription_plan,
                subscription_expires_at=subscription_expires_at,
                average_rating=avg_rating,
                total_reviews=total_reviews,
            )

    # ------------------------------------------------------------------ #
    # Settings (optional; store-backed)
    # ------------------------------------------------------------------ #
    def get_settings(self, hostel_id: UUID) -> HostelSettings:
        """
        Retrieve settings for a hostel, creating defaults if none exist.

        Requires a HostelSettingsStore to be configured.
        """
        if not self._settings_store:
            # If no store is wired, return defaults (not persisted)
            return HostelSettings()

        record = self._settings_store.get_settings(hostel_id)
        if record:
            return HostelSettings.model_validate(record)

        # Create default settings and persist
        settings = HostelSettings()
        self._settings_store.save_settings(hostel_id, settings.model_dump())
        return settings

    def update_settings(
        self,
        hostel_id: UUID,
        data: HostelSettings,
    ) -> HostelSettings:
        """
        Update and persist settings for a hostel.

        Requires a HostelSettingsStore.
        """
        if not self._settings_store:
            raise errors.ServiceError(
                "HostelSettingsStore is not configured for HostelAdminViewService"
            )

        current = self.get_settings(hostel_id)
        update_data = data.model_dump(exclude_unset=True)
        new_settings = current.model_copy(update=update_data)
        self._settings_store.save_settings(hostel_id, new_settings.model_dump())
        return new_settings

# --- File: D:\hostel-management-saas\app\services\hostel\hostel_analytics_service.py ---
# app/services/hostel/hostel_analytics_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Callable, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository
from app.repositories.content import ReviewRepository
from app.schemas.hostel import (
    HostelAnalytics,
    HostelOccupancyStats,
    HostelRevenueStats,
)
from app.schemas.hostel.hostel_analytics import (
    OccupancyAnalytics,
    OccupancyDataPoint,
    RevenueAnalytics,
    RevenueDataPoint,
    BookingAnalytics as HostelBookingAnalytics,
    BookingDataPoint,
    ComplaintAnalytics as HostelComplaintAnalytics,
    ReviewAnalytics,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.analytics import (
    OccupancyAnalyticsService,
    FinancialAnalyticsService,
    BookingAnalyticsService,
    ComplaintAnalyticsService,
)
from app.services.common import UnitOfWork, errors


class HostelAnalyticsService:
    """
    High-level hostel analytics aggregator.

    Uses:
    - OccupancyAnalyticsService
    - FinancialAnalyticsService
    - BookingAnalyticsService
    - ComplaintAnalyticsService
    - ReviewRepository

    to build:
    - HostelAnalytics
    - HostelOccupancyStats
    - HostelRevenueStats
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory
        self._occupancy_svc = OccupancyAnalyticsService(session_factory)
        self._financial_svc = FinancialAnalyticsService(session_factory)
        self._booking_svc = BookingAnalyticsService(session_factory)
        self._complaint_svc = ComplaintAnalyticsService(session_factory)

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Main analytics
    # ------------------------------------------------------------------ #
    def get_hostel_analytics(
        self,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> HostelAnalytics:
        """
        Build a full HostelAnalytics object for the given hostel & period.
        """
        if not (period.start_date and period.end_date):
            raise errors.ValidationError(
                "Both start_date and end_date are required for hostel analytics"
            )

        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")
            hostel_name = hostel.name

        # Occupancy
        occ_report = self._occupancy_svc.get_occupancy_report(hostel_id, period)
        occ_kpi = occ_report.kpi
        occ_trend: List[OccupancyDataPoint] = [
            OccupancyDataPoint(
                date=pt.date,
                occupancy_rate=pt.occupancy_percentage,
                occupied_beds=pt.occupied_beds,
                total_beds=pt.total_beds,
            )
            for pt in occ_report.daily_trend
        ]
        occupancy = OccupancyAnalytics(
            current_occupancy_rate=occ_kpi.current_occupancy_percentage,
            average_occupancy_rate=occ_kpi.average_occupancy_percentage,
            peak_occupancy_rate=occ_kpi.peak_occupancy_percentage,
            lowest_occupancy_rate=occ_kpi.low_occupancy_percentage,
            total_beds=occ_kpi.total_beds,
            occupied_beds=occ_kpi.occupied_beds,
            available_beds=occ_kpi.available_beds,
            occupancy_trend=occ_trend,
            predicted_occupancy_next_month=None,
        )

        # Financial
        fin_report = self._financial_svc.get_financial_report(
            scope_type="hostel",
            scope_id=hostel_id,
            period=period,
        )
        pnl = fin_report.pnl_report
        cashflow = fin_report.cashflow

        revenue_trend: List[RevenueDataPoint] = [
            RevenueDataPoint(
                date=pt.date,
                revenue=pt.inflow,
                collected=pt.inflow,
                pending=Decimal("0"),
            )
            for pt in cashflow.cashflow_timeseries
        ]

        revenue = RevenueAnalytics(
            total_revenue=pnl.revenue.total_revenue,
            rent_revenue=pnl.revenue.rent_revenue,
            mess_revenue=pnl.revenue.mess_revenue,
            other_revenue=pnl.revenue.other_revenue,
            total_collected=cashflow.inflows,
            total_pending=Decimal("0"),
            total_overdue=Decimal("0"),
            collection_rate=fin_report.collection_rate,
            revenue_trend=revenue_trend,
            revenue_vs_last_period=Decimal("0"),
            revenue_vs_last_year=None,
        )

        # Bookings
        booking_summary = self._booking_svc.get_analytics_for_hostel(hostel_id, period)
        kpi = booking_summary.kpi
        trend_points: List[BookingDataPoint] = [
            BookingDataPoint(
                date=pt.date,
                total_bookings=pt.total_bookings,
                approved=pt.confirmed,
                rejected=pt.rejected,
            )
            for pt in booking_summary.trend
        ]
        pending_bookings = (
            kpi.total_bookings
            - kpi.confirmed_bookings
            - kpi.cancelled_bookings
            - kpi.rejected_bookings
        )
        bookings = HostelBookingAnalytics(
            total_bookings=kpi.total_bookings,
            approved_bookings=kpi.confirmed_bookings,
            pending_bookings=pending_bookings,
            rejected_bookings=kpi.rejected_bookings,
            cancelled_bookings=kpi.cancelled_bookings,
            conversion_rate=kpi.booking_conversion_rate,
            cancellation_rate=kpi.cancellation_rate,
            booking_sources={s.value if hasattr(s, "value") else str(s): c for s, c in booking_summary.bookings_by_source.items()},
            booking_trend=trend_points,
        )

        # Complaints (using analytics ComplaintAnalyticsService from analytics package)
        comp_dashboard = self._complaint_svc.get_dashboard_for_hostel(
            hostel_id=hostel_id,
            period=period,
        )
        ckpi = comp_dashboard.kpi
        complaints = HostelComplaintAnalytics(
            total_complaints=ckpi.total_complaints,
            open_complaints=ckpi.open_complaints,
            resolved_complaints=ckpi.resolved_complaints,
            closed_complaints=ckpi.closed_complaints,
            average_resolution_time_hours=ckpi.average_resolution_time_hours,
            resolution_rate=Decimal("0") if ckpi.total_complaints == 0 else (Decimal(str(ckpi.resolved_complaints)) / Decimal(str(ckpi.total_complaints)) * 100),
            complaints_by_category={
                cat.category: cat.count for cat in comp_dashboard.by_category
            },
            complaints_by_priority=comp_dashboard.by_priority,
            sla_compliance_rate=ckpi.sla_compliance_rate,
        )

        # Reviews
        with UnitOfWork(self._session_factory) as uow2:
            review_repo = self._get_review_repo(uow2)
            agg = review_repo.get_aggregates_for_hostel(hostel_id)
            total_reviews = agg["total_reviews"]
            avg_rating = Decimal(str(agg["average_rating"]))

        reviews = ReviewAnalytics(
            total_reviews=total_reviews,
            average_rating=avg_rating,
            rating_distribution={},  # can be filled by a more detailed query later
            average_cleanliness_rating=None,
            average_food_quality_rating=None,
            average_staff_behavior_rating=None,
            average_security_rating=None,
            average_value_rating=None,
            rating_trend=[],
        )

        return HostelAnalytics(
            hostel_id=hostel_id,
            hostel_name=hostel_name,
            period_start=period.start_date,
            period_end=period.end_date,
            occupancy=occupancy,
            revenue=revenue,
            bookings=bookings,
            complaints=complaints,
            reviews=reviews,
            generated_at=self._now(),
        )

    # ------------------------------------------------------------------ #
    # Occupancy & revenue stats
    # ------------------------------------------------------------------ #
    def get_occupancy_stats(
        self,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> HostelOccupancyStats:
        occ_report = self._occupancy_svc.get_occupancy_report(hostel_id, period)
        kpi = occ_report.kpi

        return HostelOccupancyStats(
            hostel_id=hostel_id,
            total_rooms=0,  # not exposed by OccupancyReport; can be fetched from Hostel if needed
            total_beds=kpi.total_beds,
            occupied_beds=kpi.occupied_beds,
            available_beds=kpi.available_beds,
            occupancy_percentage=kpi.current_occupancy_percentage,
            occupancy_by_room_type=[
                # Map from OccupancyByRoomType entries
                {
                    "room_type": rt.room_type,
                    "total_beds": rt.total_beds,
                    "occupied_beds": rt.occupied_beds,
                    "available_beds": rt.total_beds - rt.occupied_beds,
                    "occupancy_percentage": rt.occupancy_percentage,
                }
                for rt in occ_report.by_room_type
            ],
            occupancy_history=[
                OccupancyDataPoint(
                    date=pt.date,
                    occupancy_rate=pt.occupancy_percentage,
                    occupied_beds=pt.occupied_beds,
                    total_beds=pt.total_beds,
                )
                for pt in occ_report.daily_trend
            ],
            projected_occupancy_30_days=None,
            projected_occupancy_90_days=None,
        )

    def get_revenue_stats(
        self,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> HostelRevenueStats:
        fin_report = self._financial_svc.get_financial_report(
            scope_type="hostel",
            scope_id=hostel_id,
            period=period,
        )
        pnl = fin_report.pnl_report
        cashflow = fin_report.cashflow

        monthly_revenue = [
            # Map CashflowPoint(s) by month if desired; for now aggregate as a single month
        ]

        return HostelRevenueStats(
            hostel_id=hostel_id,
            period=period,
            total_revenue=pnl.revenue.total_revenue,
            total_expenses=pnl.expenses.total_expenses,
            net_profit=pnl.net_profit,
            profit_margin=pnl.profit_margin_percentage,
            revenue_by_type=dict(pnl.revenue.revenue_by_payment_type),
            total_collected=cashflow.inflows,
            total_pending=Decimal("0"),
            total_overdue=Decimal("0"),
            collection_efficiency=fin_report.collection_rate,
            monthly_revenue=monthly_revenue,
            revenue_growth_mom=Decimal("0"),
            revenue_growth_yoy=None,
        )

# --- File: D:\hostel-management-saas\app\services\hostel\hostel_comparison_service.py ---
# app/services/hostel/hostel_comparison_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Callable, List, Dict
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository, RoomRepository
from app.repositories.transactions import FeeStructureRepository
from app.schemas.hostel import (
    HostelComparisonRequest,
    ComparisonResult,
    ComparisonItem,
)
from app.schemas.hostel.hostel_comparison import (
    RoomTypeComparison,
)
from app.services.common import UnitOfWork, errors


class HostelComparisonService:
    """
    Compare multiple hostels for admin/visitor UIs.

    Focuses on:
    - Capacity and pricing
    - Rating & reviews
    - Amenities/facilities/security
    - Available room types
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_fee_repo(self, uow: UnitOfWork) -> FeeStructureRepository:
        return uow.get_repo(FeeStructureRepository)

    # ------------------------------------------------------------------ #
    # Main API
    # ------------------------------------------------------------------ #
    def compare_hostels(self, req: HostelComparisonRequest) -> ComparisonResult:
        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            room_repo = self._get_room_repo(uow)
            fee_repo = self._get_fee_repo(uow)

            hostels = []
            for hid in req.hostel_ids:
                h = hostel_repo.get(hid)
                if h is None:
                    raise errors.NotFoundError(f"Hostel {hid} not found")
                hostels.append(h)

            # Preload rooms & fees
            rooms_by_hostel: Dict[UUID, List] = {}
            fees_by_hostel: Dict[UUID, List] = {}
            for h in hostels:
                rooms_by_hostel[h.id] = room_repo.list_for_hostel(
                    hostel_id=h.id,
                    only_available=False,
                    room_type=None,
                )
                fees_by_hostel[h.id] = fee_repo.get_multi(
                    skip=0,
                    limit=None,  # type: ignore[arg-type]
                    filters={"hostel_id": h.id, "is_active": True},
                )

            comparison_items: List[ComparisonItem] = []

            for h in hostels:
                rooms = rooms_by_hostel[h.id]
                fees = fees_by_hostel[h.id]

                # Pricing
                if fees:
                    amounts = [fs.amount for fs in fees if fs.amount is not None]
                    if amounts:
                        min_price = min(amounts)
                        max_price = max(amounts)
                    else:
                        min_price = max_price = h.starting_price_monthly or Decimal("0")
                else:
                    min_price = max_price = h.starting_price_monthly or Decimal("0")

                price_range_str = f"₹{min_price:,.0f} - ₹{max_price:,.0f}"

                sec_deposits = [
                    fs.security_deposit for fs in fees if fs.security_deposit is not None
                ]
                security_deposit = min(sec_deposits) if sec_deposits else None

                # Room type details
                room_type_map: Dict[str, RoomTypeComparison] = {}
                for r in rooms:
                    rt = r.room_type.value if hasattr(r.room_type, "value") else str(r.room_type)
                    existing = room_type_map.get(rt)
                    total_beds = r.total_beds or 0
                    available_beds = total_beds  # more detailed computation could use Student assignments

                    if existing:
                        existing.total_beds += total_beds
                        existing.available_beds += available_beds
                    else:
                        room_type_map[rt] = RoomTypeComparison(
                            room_type=rt,
                            price_monthly=r.price_monthly,
                            available_beds=available_beds,
                            total_beds=total_beds,
                            amenities=r.amenities or [],
                        )

                room_types_available = list(room_type_map.keys())
                room_type_details = list(room_type_map.values())

                # Ratings
                avg_rating = Decimal(str(h.average_rating or 0.0))
                total_reviews = h.total_reviews or 0

                # Rating breakdown not readily available; keep empty
                rating_breakdown: Dict[str, int] = {}

                # Capacity
                total_beds = h.total_beds or 0
                available_beds = max(0, total_beds - (h.occupied_beds or 0))

                comparison_items.append(
                    ComparisonItem(
                        id=h.id,
                        name=h.name,
                        slug=h.slug,
                        hostel_type=h.hostel_type,
                        city=h.city,
                        state=h.state,
                        address=h.address_line1,
                        distance_from_center_km=None,
                        starting_price_monthly=min_price,
                        price_range_monthly=price_range_str,
                        security_deposit=security_deposit,
                        total_beds=total_beds,
                        available_beds=available_beds,
                        average_rating=avg_rating,
                        total_reviews=total_reviews,
                        rating_breakdown=rating_breakdown,
                        amenities=h.amenities or [],
                        facilities=h.facilities or [],
                        security_features=h.security_features or [],
                        room_types_available=room_types_available,
                        room_type_details=room_type_details,
                        check_in_time=h.check_in_time.isoformat() if h.check_in_time else None,
                        check_out_time=h.check_out_time.isoformat() if h.check_out_time else None,
                        visitor_allowed=True if h.visitor_policy else False,
                        cover_image_url=h.cover_image_url,
                        total_images=len(h.gallery_images or []),
                        has_virtual_tour=bool(h.virtual_tour_url),
                        unique_features=[],
                        pros=[],
                        cons=[],
                    )
                )

        comparison_criteria = [
            "price",
            "rating",
            "availability",
            "amenities",
            "location",
        ]

        return ComparisonResult(
            hostels=comparison_items,
            comparison_criteria=comparison_criteria,
            generated_at=datetime.utcnow(),
        )

# --- File: D:\hostel-management-saas\app\services\hostel\hostel_service.py ---
# app/services/hostel/hostel_service.py
from __future__ import annotations

from typing import Callable, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.hostel import (
    HostelCreate,
    HostelUpdate,
    HostelResponse,
    HostelDetail,
    HostelListItem,
    HostelFilterParams,
    HostelSortOptions,
    HostelVisibilityUpdate,
    HostelStatusUpdate,
)
from app.services.common import UnitOfWork, mapping, pagination, errors


class HostelService:
    """
    Core Hostel service:

    - Create, update, retrieve hostels
    - List hostels with filters (admin side)
    - Change visibility and operational status
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    # ------------------------------------------------------------------ #
    # Read operations
    # ------------------------------------------------------------------ #
    def get_hostel(self, hostel_id: UUID) -> HostelDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_hostel_repo(uow)
            hostel = repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")
            return mapping.to_schema(hostel, HostelDetail)

    def get_hostel_by_slug(self, slug: str) -> HostelDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_hostel_repo(uow)
            hostel = repo.get_by_slug(slug)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel with slug {slug!r} not found")
            return mapping.to_schema(hostel, HostelDetail)

    # ------------------------------------------------------------------ #
    # Listing for admin (internal use)
    # ------------------------------------------------------------------ #
    def list_hostels(
        self,
        params: PaginationParams,
        filters: Optional[HostelFilterParams] = None,
        sort: Optional[HostelSortOptions] = None,
    ) -> PaginatedResponse[HostelListItem]:
        """
        List hostels with filters and sorting for admin views.

        Note: HostelRepository already has a list_public() helper for
        visitor-facing searches; this listing is more general for admins.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_hostel_repo(uow)

            raw_filters = {}
            if filters:
                if filters.city:
                    raw_filters["city"] = filters.city
                if filters.state:
                    raw_filters["state"] = filters.state
                if filters.status is not None:
                    raw_filters["status"] = filters.status
                if filters.is_active is not None:
                    raw_filters["is_active"] = filters.is_active
                if filters.is_public is not None:
                    raw_filters["is_public"] = filters.is_public
                if filters.is_featured is not None:
                    raw_filters["is_featured"] = filters.is_featured
                if filters.is_verified is not None:
                    raw_filters["is_verified"] = filters.is_verified

            # Sorting
            order_by = None
            if sort:
                col_map = {
                    "name": repo.model.name,          # type: ignore[attr-defined]
                    "city": repo.model.city,          # type: ignore[attr-defined]
                    "price": repo.model.starting_price_monthly,  # type: ignore[attr-defined]
                    "rating": repo.model.average_rating,         # type: ignore[attr-defined]
                    "occupancy": repo.model.occupied_beds,       # type: ignore[attr-defined]
                    "created_at": repo.model.created_at,         # type: ignore[attr-defined]
                    "updated_at": repo.model.updated_at,         # type: ignore[attr-defined]
                }
                sort_col = col_map.get(sort.sort_by, repo.model.created_at)  # type: ignore[attr-defined]
                order_by = [sort_col.asc() if sort.sort_order == "asc" else sort_col.desc()]

            records = repo.get_multi(
                skip=params.offset,
                limit=params.limit,
                filters=raw_filters or None,
                order_by=order_by,
            )
            total = repo.count(filters=raw_filters or None)

            return pagination.paginate(
                items=records,
                total_items=total,
                params=params,
                mapper=lambda h: mapping.to_schema(h, HostelListItem),
            )

    # ------------------------------------------------------------------ #
    # Creation
    # ------------------------------------------------------------------ #
    def create_hostel(self, data: HostelCreate) -> HostelDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_hostel_repo(uow)

            # Ensure slug uniqueness
            existing = repo.get_by_slug(data.slug)
            if existing is not None:
                raise errors.ConflictError(f"Hostel slug {data.slug!r} is already in use")

            hostel = repo.create(data.model_dump())
            uow.commit()
            return mapping.to_schema(hostel, HostelDetail)

    # ------------------------------------------------------------------ #
    # Update
    # ------------------------------------------------------------------ #
    def update_hostel(self, hostel_id: UUID, data: HostelUpdate) -> HostelDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_hostel_repo(uow)
            hostel = repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            # Slug change uniqueness check
            if data.slug is not None and data.slug != hostel.slug:
                if repo.get_by_slug(data.slug):
                    raise errors.ConflictError(
                        f"Hostel slug {data.slug!r} is already in use"
                    )

            mapping.update_model_from_schema(hostel, data, exclude_fields=["id"])
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return mapping.to_schema(hostel, HostelDetail)

    # ------------------------------------------------------------------ #
    # Visibility & status
    # ------------------------------------------------------------------ #
    def update_visibility(
        self,
        hostel_id: UUID,
        data: HostelVisibilityUpdate,
    ) -> HostelResponse:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_hostel_repo(uow)
            hostel = repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            hostel.is_public = data.is_public  # type: ignore[attr-defined]
            hostel.is_featured = data.is_featured  # type: ignore[attr-defined]
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return mapping.to_schema(hostel, HostelResponse)

    def update_status(
        self,
        hostel_id: UUID,
        data: HostelStatusUpdate,
    ) -> HostelResponse:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_hostel_repo(uow)
            hostel = repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            hostel.status = data.status  # type: ignore[attr-defined]
            hostel.is_active = data.is_active  # type: ignore[attr-defined]
            # Optionally store reason somewhere (e.g., audit log)
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return mapping.to_schema(hostel, HostelResponse)

# --- File: D:\hostel-management-saas\app\services\hostel\__init__.py ---
# app/services/hostel/__init__.py
"""
Hostel-related services.

- HostelService: core Hostel CRUD, visibility and status updates.
- HostelAdminViewService: admin dashboard view & settings.
- HostelAnalyticsService: hostel-level analytics aggregation.
- HostelComparisonService: multi-hostel comparison for admins/visitors.
"""

from .hostel_service import HostelService
from .hostel_admin_view_service import HostelAdminViewService, HostelSettingsStore
from .hostel_analytics_service import HostelAnalyticsService
from .hostel_comparison_service import HostelComparisonService

__all__ = [
    "HostelService",
    "HostelAdminViewService",
    "HostelSettingsStore",
    "HostelAnalyticsService",
    "HostelComparisonService",
]


# ===== Folder: D:\hostel-management-saas\app\services\hostel_public =====

# --- File: D:\hostel-management-saas\app\services\hostel_public\hostel_index_service.py ---
# app/services/hostel_public/hostel_index_service.py
from __future__ import annotations

from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository
from app.schemas.hostel import PublicHostelCard, PublicHostelList
from app.services.common import UnitOfWork, errors


class HostelIndexService:
    """
    Public-facing hostel index service for landing pages.

    - List featured/top hostels for home page
    - Optionally filter by city/state
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_public_card(self, h) -> PublicHostelCard:
        total_beds = h.total_beds or 0
        occupied_beds = h.occupied_beds or 0
        available_beds = max(0, total_beds - occupied_beds)

        avg_rating = Decimal(str(h.average_rating or 0.0))
        starting_price = h.starting_price_monthly or Decimal("0")
        amenities_top = (h.amenities or [])[:5]

        return PublicHostelCard(
            id=h.id,
            name=h.name,
            slug=h.slug,
            hostel_type=h.hostel_type,
            city=h.city,
            state=h.state,
            starting_price_monthly=starting_price,
            currency=h.currency or "INR",
            average_rating=avg_rating,
            total_reviews=h.total_reviews or 0,
            available_beds=available_beds,
            cover_image_url=h.cover_image_url,
            is_featured=h.is_featured,
            amenities=amenities_top,
            distance_km=None,
        )

    # ------------------------------------------------------------------ #
    # Public index
    # ------------------------------------------------------------------ #
    def list_featured_hostels(
        self,
        *,
        city: Optional[str] = None,
        state: Optional[str] = None,
        limit: int = 12,
    ) -> PublicHostelList:
        """
        List featured/top-rated public hostels for home page.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_hostel_repo(uow)

            # list_public already enforces is_public + is_active and orders by
            # is_featured desc, average_rating desc
            hostels = repo.list_public(
                city=city,
                state=state,
                search=None,
                limit=limit,
            )

            cards: List[PublicHostelCard] = [self._to_public_card(h) for h in hostels]

            filters_applied: Dict[str, object] = {}
            if city:
                filters_applied["city"] = city
            if state:
                filters_applied["state"] = state
            filters_applied["featured_only"] = True

            return PublicHostelList(
                hostels=cards,
                total_count=len(cards),
                filters_applied=filters_applied,
            )

    def list_newest_hostels(
        self,
        *,
        city: Optional[str] = None,
        state: Optional[str] = None,
        limit: int = 12,
    ) -> PublicHostelList:
        """
        List newest public hostels (by created_at) for discovery sections.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_hostel_repo(uow)

            filters: Dict[str, object] = {"is_public": True, "is_active": True}
            if city:
                filters["city"] = city
            if state:
                filters["state"] = state

            records = repo.get_multi(
                skip=0,
                limit=limit,
                filters=filters,
                order_by=[repo.model.created_at.desc()],  # type: ignore[attr-defined]
            )

            cards: List[PublicHostelCard] = [self._to_public_card(h) for h in records]

            filters_applied: Dict[str, object] = {}
            if city:
                filters_applied["city"] = city
            if state:
                filters_applied["state"] = state
            filters_applied["sort"] = "newest"

            return PublicHostelList(
                hostels=cards,
                total_count=len(cards),
                filters_applied=filters_applied,
            )

# --- File: D:\hostel-management-saas\app\services\hostel_public\hostel_search_service.py ---
# app/services/hostel_public/hostel_search_service.py
from __future__ import annotations

from math import ceil
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.visitor import VisitorHostelRepository
from app.repositories.core import HostelRepository
from app.schemas.hostel import (
    HostelSearchRequest,
    HostelSearchResponse,
    HostelSearchFilters,
    PublicHostelCard,
)
from app.schemas.hostel.hostel_search import (
    SearchFacets,
    FacetItem,
    PriceRangeFacet,
    RatingFacet,
)
from app.services.common import UnitOfWork


class HostelSearchService:
    """
    Public hostel search:

    - Search hostels using VisitorHostel denormalized view + core_hostel
    - Apply filters/pagination
    - Build facets (cities, hostel types, basic price/rating buckets)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_visitor_hostel_repo(self, uow: UnitOfWork) -> VisitorHostelRepository:
        return uow.get_repo(VisitorHostelRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_public_card_from_pair(self, vh, h) -> PublicHostelCard:
        """
        vh: VisitorHostel row
        h:  core_hostel row (may be None)
        """
        starting_price = vh.min_price or h.starting_price_monthly or Decimal("0")
        avg_rating = Decimal(str(vh.rating or h.average_rating or 0.0))
        total_reviews = vh.total_reviews or h.total_reviews or 0
        available_beds = vh.availability or max(
            0,
            (h.total_beds or 0) - (h.occupied_beds or 0),
        )

        return PublicHostelCard(
            id=vh.hostel_id,
            name=vh.hostel_name,
            slug=h.slug if h else "",
            hostel_type=h.hostel_type if h else None,  # type: ignore[arg-type]
            city=vh.city,
            state=h.state if h else "",
            starting_price_monthly=starting_price,
            currency="INR",
            average_rating=avg_rating,
            total_reviews=total_reviews,
            available_beds=available_beds,
            cover_image_url=h.cover_image_url if h else None,
            is_featured=h.is_featured if h else False,
            amenities=(vh.amenities or [])[:5],
            distance_km=None,
        )

    # ------------------------------------------------------------------ #
    # Search
    # ------------------------------------------------------------------ #
    def search(self, req: HostelSearchRequest) -> HostelSearchResponse:
        """
        Execute a hostel search and return paginated results + facets.

        This uses VisitorHostelRepository.search for coarse filtering, then
        refines results in Python for other filters.
        """
        page = req.page
        page_size = req.page_size
        if page < 1 or page_size <= 0:
            page = 1
            page_size = 20

        with UnitOfWork(self._session_factory) as uow:
            visitor_repo = self._get_visitor_hostel_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            # Map request filters into VisitorHostel.search where possible
            min_price = float(req.min_price) if req.min_price is not None else None
            max_price = float(req.max_price) if req.max_price is not None else None

            # Fetch a superset; VisitorHostelRepository.search has only limit (no offset)
            rough_limit = page * page_size * 2
            vh_list = visitor_repo.search(
                city=req.city,
                area=None,
                min_price=min_price,
                max_price=max_price,
                gender_type=None,
                search=req.query,
                limit=rough_limit,
            )

            # Map hostel_id -> core_hostel (for slug, type, etc.)
            hostel_cache: Dict[UUID, object] = {}
            for vh in vh_list:
                if vh.hostel_id not in hostel_cache:
                    h = hostel_repo.get(vh.hostel_id)
                    hostel_cache[vh.hostel_id] = h

            # Apply remaining filters in Python
            def _match(vh, h) -> bool:
                # State
                if req.state and (not h or h.state != req.state):
                    return False
                # Pincode
                if req.pincode and getattr(vh, "pincode", None) != req.pincode:
                    return False
                # Room type
                if req.room_type and vh.room_types:
                    if req.room_type.value not in vh.room_types:
                        return False
                # Availability
                if req.available_beds_min is not None:
                    if vh.availability is None or vh.availability < req.available_beds_min:
                        return False
                # Rating
                if req.min_rating is not None:
                    rating_value = Decimal(str(vh.rating or h.average_rating or 0.0))
                    if rating_value < req.min_rating:
                        return False
                # Amenities
                if req.amenities:
                    amenities_set = set(vh.amenities or [])
                    for a in req.amenities:
                        if a not in amenities_set:
                            return False
                # Verified/featured only: requires core_hostel
                if req.verified_only and (not h or not h.is_verified):
                    return False
                if req.featured_only and (not h or not h.is_featured):
                    return False
                # Hostel type
                if req.hostel_type and h and h.hostel_type != req.hostel_type:
                    return False
                return True

            filtered: List[tuple] = []
            for vh in vh_list:
                h = hostel_cache.get(vh.hostel_id)
                if _match(vh, h):
                    filtered.append((vh, h))

            total_results = len(filtered)

            # Sorting
            def _sort_key(item):
                vh, h = item
                if req.sort_by == "price_low":
                    val = vh.min_price or h.starting_price_monthly or Decimal("0")
                    return (val, )
                if req.sort_by == "price_high":
                    val = vh.max_price or h.starting_price_monthly or Decimal("0")
                    return (-val, )
                if req.sort_by == "rating":
                    val = Decimal(str(vh.rating or h.average_rating or 0.0))
                    return (-val, )
                if req.sort_by == "newest":
                    # use hostel.created_at
                    created = getattr(h, "created_at", None)
                    return (created or datetime.min, )
                # relevance / distance not implemented; keep original order
                return (0, )

            if req.sort_by != "relevance":
                filtered.sort(key=_sort_key)

            # Pagination slice
            start_idx = (page - 1) * page_size
            end_idx = start_idx + page_size
            page_items = filtered[start_idx:end_idx]

            results: List[PublicHostelCard] = [
                self._to_public_card_from_pair(vh, h) for vh, h in page_items
            ]

            total_pages = ceil(total_results / page_size) if page_size > 0 else 1

            # Facets
            facets = self._build_facets(filtered, hostel_cache)

            # Filters summary
            filters_applied: Dict[str, object] = {}
            for fname in [
                "city",
                "state",
                "pincode",
                "hostel_type",
                "min_price",
                "max_price",
                "room_type",
                "amenities",
                "available_beds_min",
                "min_rating",
                "verified_only",
                "featured_only",
            ]:
                val = getattr(req, fname, None)
                if val not in (None, [], {}):
                    filters_applied[fname] = val

        return HostelSearchResponse(
            results=results,
            total_results=total_results,
            total_pages=total_pages,
            current_page=page,
            filters_applied=filters_applied,
            facets=facets,
        )

    # ------------------------------------------------------------------ #
    # Facets
    # ------------------------------------------------------------------ #
    def _build_facets(
        self,
        filtered: List[tuple],
        hostel_cache: Dict[UUID, object],
    ) -> SearchFacets:
        # Cities
        city_counts: Dict[str, int] = {}
        # Hostel types
        type_counts: Dict[str, int] = {}
        # Amenities
        amenity_counts: Dict[str, int] = {}
        # Ratings
        rating_buckets: Dict[str, int] = {}
        # Price range
        min_price: Optional[Decimal] = None
        max_price: Optional[Decimal] = None

        for vh, h in filtered:
            city_counts[vh.city] = city_counts.get(vh.city, 0) + 1
            if h:
                t_val = h.hostel_type.value if hasattr(h.hostel_type, "value") else str(h.hostel_type)
                type_counts[t_val] = type_counts.get(t_val, 0) + 1

            # amenities
            for a in vh.amenities or []:
                amenity_counts[a] = amenity_counts.get(a, 0) + 1

            # rating bucket
            rating_val = Decimal(str(vh.rating or (h.average_rating if h else 0.0)))
            if rating_val >= Decimal("4.5"):
                bucket = "4.5+"
            elif rating_val >= Decimal("4.0"):
                bucket = "4.0-4.4"
            elif rating_val >= Decimal("3.0"):
                bucket = "3.0-3.9"
            else:
                bucket = "<3.0"
            rating_buckets[bucket] = rating_buckets.get(bucket, 0) + 1

            # price range from min_price field if available
            p_min = vh.min_price or (h.starting_price_monthly if h else None)
            if p_min is not None:
                if min_price is None or p_min < min_price:
                    min_price = p_min
                if max_price is None or p_min > max_price:
                    max_price = p_min

        cities_facet = [
            FacetItem(value=city, label=city, count=count)
            for city, count in sorted(city_counts.items(), key=lambda x: -x[1])
        ]
        hostel_types_facet = [
            FacetItem(value=v, label=v, count=c)
            for v, c in sorted(type_counts.items(), key=lambda x: -x[1])
        ]
        amenities_facet = [
            FacetItem(value=v, label=v, count=c)
            for v, c in sorted(amenity_counts.items(), key=lambda x: -x[1])
        ]
        ratings_facet = [
            RatingFacet(
                min_rating=Decimal("4.5") if bucket == "4.5+" else (
                    Decimal("4.0") if bucket == "4.0-4.4" else (
                        Decimal("3.0") if bucket == "3.0-3.9" else Decimal("0")
                    )
                ),
                label=bucket,
                count=count,
            )
            for bucket, count in sorted(rating_buckets.items(), key=lambda x: -x[1])
        ]

        price_ranges_facet: List[PriceRangeFacet] = []
        if min_price is not None and max_price is not None:
            price_ranges_facet.append(
                PriceRangeFacet(
                    min_price=min_price,
                    max_price=max_price,
                    label=f"₹{min_price:,.0f} - ₹{max_price:,.0f}",
                    count=len(filtered),
                )
            )

        return SearchFacets(
            cities=cities_facet,
            hostel_types=hostel_types_facet,
            price_ranges=price_ranges_facet,
            amenities=amenities_facet,
            ratings=ratings_facet,
        )

# --- File: D:\hostel-management-saas\app\services\hostel_public\public_hostel_service.py ---
# app/services/hostel_public/public_hostel_service.py
from __future__ import annotations

from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository, RoomRepository
from app.repositories.content import ReviewRepository
from app.schemas.hostel import (
    PublicHostelProfile,
    PublicRoomType,
)
from app.services.common import UnitOfWork, errors


class PublicHostelService:
    """
    Public hostel profile service:

    - Get detailed public hostel profile by slug
    - Assembles room-type view and rating aggregates
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    # ------------------------------------------------------------------ #
    # Public profile
    # ------------------------------------------------------------------ #
    def get_public_profile(self, slug: str) -> PublicHostelProfile:
        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            room_repo = self._get_room_repo(uow)
            review_repo = self._get_review_repo(uow)

            hostel = hostel_repo.get_by_slug(slug)
            if hostel is None or not hostel.is_public or not hostel.is_active:
                raise errors.NotFoundError(f"Public hostel {slug!r} not found")

            rooms = room_repo.list_for_hostel(
                hostel_id=hostel.id,
                only_available=False,
                room_type=None,
            )

            # Room-type aggregation
            room_type_map: Dict[str, Dict[str, object]] = {}
            for r in rooms:
                rt = r.room_type.value if hasattr(r.room_type, "value") else str(r.room_type)
                entry = room_type_map.setdefault(
                    rt,
                    {
                        "price_monthly": r.price_monthly,
                        "price_quarterly": r.price_quarterly,
                        "price_yearly": r.price_yearly,
                        "available_beds": 0,
                        "total_beds": 0,
                        "amenities": set(),
                        "room_images": set(),
                    },
                )
                entry["total_beds"] = int(entry["total_beds"]) + (r.total_beds or 0)
                # available beds: simple approximation
                entry["available_beds"] = int(entry["available_beds"]) + (r.total_beds or 0)
                for a in (r.amenities or []):
                    entry["amenities"].add(a)
                for img in (r.room_images or []):
                    entry["room_images"].add(img)

            public_room_types: List[PublicRoomType] = []
            for rt, data in room_type_map.items():
                public_room_types.append(
                    PublicRoomType(
                        room_type=rt,
                        price_monthly=data["price_monthly"],
                        price_quarterly=data["price_quarterly"],
                        price_yearly=data["price_yearly"],
                        available_beds=data["available_beds"],
                        total_beds=data["total_beds"],
                        room_amenities=sorted(list(data["amenities"])),
                        room_images=sorted(list(data["room_images"])),
                    )
                )

            # Ratings aggregate
            agg = review_repo.get_aggregates_for_hostel(hostel.id)
            average_rating = Decimal(str(agg["average_rating"]))
            total_reviews = agg["total_reviews"]

            available_beds = max(
                0,
                (hostel.total_beds or 0) - (hostel.occupied_beds or 0),
            )

            return PublicHostelProfile(
                id=hostel.id,
                name=hostel.name,
                slug=hostel.slug,
                description=hostel.description,
                hostel_type=hostel.hostel_type,
                contact_phone=hostel.contact_phone,
                contact_email=hostel.contact_email,
                website_url=hostel.website_url,
                address_line1=hostel.address_line1,
                address_line2=hostel.address_line2,
                city=hostel.city,
                state=hostel.state,
                pincode=hostel.pincode,
                latitude=None,
                longitude=None,
                starting_price_monthly=hostel.starting_price_monthly or Decimal("0"),
                currency=hostel.currency or "INR",
                available_beds=available_beds,
                average_rating=average_rating,
                total_reviews=total_reviews,
                rating_breakdown={},  # detailed distribution not available from repo
                amenities=hostel.amenities or [],
                facilities=hostel.facilities or [],
                security_features=hostel.security_features or [],
                rules=hostel.rules,
                check_in_time=hostel.check_in_time,
                check_out_time=hostel.check_out_time,
                visitor_policy=hostel.visitor_policy,
                nearby_landmarks=hostel.nearby_landmarks or [],
                connectivity_info=hostel.connectivity_info,
                cover_image_url=hostel.cover_image_url,
                gallery_images=hostel.gallery_images or [],
                virtual_tour_url=hostel.virtual_tour_url,
                room_types=public_room_types,
            )

# --- File: D:\hostel-management-saas\app\services\hostel_public\__init__.py ---
# app/services/hostel_public/__init__.py
"""
Public hostel services.

- HostelIndexService: simple public index (featured/newest hostels).
- HostelSearchService: visitor search with filters & facets.
- PublicHostelService: detailed public profile by slug.
"""

from .hostel_index_service import HostelIndexService
from .hostel_search_service import HostelSearchService
from .public_hostel_service import PublicHostelService

__all__ = [
    "HostelIndexService",
    "HostelSearchService",
    "PublicHostelService",
]


# ===== Folder: D:\hostel-management-saas\app\services\inquiry =====

# --- File: D:\hostel-management-saas\app\services\inquiry\inquiry_assignment_service.py ---
# app/services/inquiry/inquiry_assignment_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import InquiryRepository
from app.repositories.core import AdminRepository, HostelRepository
from app.schemas.common.enums import InquiryStatus
from app.schemas.inquiry import (
    InquiryAssignment,
    InquiryDetail,
)
from app.services.common import UnitOfWork, errors


class InquiryAssignmentService:
    """
    Handle assigning inquiries to admins / staff.

    Semantics:
    - inquiry.contacted_by_id is used as the "assigned_to" admin/staff.
    - inquiry.status is typically moved out of NEW when assigned (e.g., to PENDING).
    - contacted_at is set when first assigned.
    - assignment_notes are appended to inquiry.notes.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_inquiry_repo(self, uow: UnitOfWork) -> InquiryRepository:
        return uow.get_repo(InquiryRepository)

    def _get_admin_repo(self, uow: UnitOfWork) -> AdminRepository:
        return uow.get_repo(AdminRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Assign
    # ------------------------------------------------------------------ #
    def assign(self, data: InquiryAssignment) -> InquiryDetail:
        """
        Assign an inquiry to an admin/staff.

        - Sets inquiry.contacted_by_id = assigned_to
        - Sets inquiry.contacted_at if not already set
        - Optionally updates status to a non-NEW state (e.g., PENDING)
        - Appends assignment_notes into inquiry.notes
        """
        with UnitOfWork(self._session_factory) as uow:
            inquiry_repo = self._get_inquiry_repo(uow)
            admin_repo = self._get_admin_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            inq = inquiry_repo.get(data.inquiry_id)
            if inq is None:
                raise errors.NotFoundError(f"Inquiry {data.inquiry_id} not found")

            assigned_admin = admin_repo.get(data.assigned_to)
            if assigned_admin is None:
                raise errors.NotFoundError(f"Admin {data.assigned_to} not found")

            # Set contacted_by and contacted_at
            inq.contacted_by_id = data.assigned_to  # type: ignore[attr-defined]
            if inq.contacted_at is None:
                inq.contacted_at = self._now()  # type: ignore[attr-defined]

            # Move status from NEW → PENDING by default (if still NEW)
            try:
                if inq.status == InquiryStatus.NEW:
                    inq.status = InquiryStatus.PENDING  # type: ignore[attr-defined]
            except Exception:
                # If enum does not have PENDING, ignore; status is left as is
                pass

            # Append assignment notes to inquiry.notes
            if data.assignment_notes:
                existing = inq.notes or ""  # type: ignore[attr-defined]
                if existing:
                    existing += "\n"
                inq.notes = existing + data.assignment_notes  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            hostel = hostel_repo.get(inq.hostel_id)
            hostel_name = hostel.name if hostel else ""

            assigned_user = assigned_admin.user if getattr(assigned_admin, "user", None) else None
            contacted_by_name = assigned_user.full_name if assigned_user else None

            return InquiryDetail(
                id=inq.id,
                created_at=inq.created_at,
                updated_at=inq.updated_at,
                hostel_id=inq.hostel_id,
                hostel_name=hostel_name,
                visitor_name=inq.visitor_name,
                visitor_email=inq.visitor_email,
                visitor_phone=inq.visitor_phone,
                preferred_check_in_date=inq.preferred_check_in_date,
                stay_duration_months=inq.stay_duration_months,
                room_type_preference=inq.room_type_preference,
                message=inq.message,
                inquiry_source=inq.inquiry_source,
                status=inq.status,
                contacted_by=inq.contacted_by_id,
                contacted_by_name=contacted_by_name,
                contacted_at=inq.contacted_at,
                notes=inq.notes,
            )

# --- File: D:\hostel-management-saas\app\services\inquiry\inquiry_service.py ---
# app/services/inquiry/inquiry_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable, Optional, Sequence, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import InquiryRepository
from app.repositories.core import HostelRepository, AdminRepository
from app.schemas.common.enums import InquiryStatus
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.inquiry import (
    InquiryCreate,
    InquiryResponse,
    InquiryDetail,
    InquiryListItem,
    InquiryStatusUpdate,
)
from app.services.common import UnitOfWork, errors


class InquiryService:
    """
    Visitor inquiry service:

    - Create inquiry
    - Get inquiry detail
    - List inquiries for a hostel
    - Update inquiry status
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_inquiry_repo(self, uow: UnitOfWork) -> InquiryRepository:
        return uow.get_repo(InquiryRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_admin_repo(self, uow: UnitOfWork) -> AdminRepository:
        return uow.get_repo(AdminRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_response(self, inq, *, hostel_name: str) -> InquiryResponse:
        return InquiryResponse(
            id=inq.id,
            created_at=inq.created_at,
            updated_at=inq.updated_at,
            hostel_id=inq.hostel_id,
            hostel_name=hostel_name,
            visitor_name=inq.visitor_name,
            visitor_email=inq.visitor_email,
            visitor_phone=inq.visitor_phone,
            preferred_check_in_date=inq.preferred_check_in_date,
            stay_duration_months=inq.stay_duration_months,
            room_type_preference=inq.room_type_preference,
            status=inq.status,
        )

    def _to_detail(
        self,
        inq,
        *,
        hostel_name: str,
        contacted_by_name: Optional[str],
    ) -> InquiryDetail:
        return InquiryDetail(
            id=inq.id,
            created_at=inq.created_at,
            updated_at=inq.updated_at,
            hostel_id=inq.hostel_id,
            hostel_name=hostel_name,
            visitor_name=inq.visitor_name,
            visitor_email=inq.visitor_email,
            visitor_phone=inq.visitor_phone,
            preferred_check_in_date=inq.preferred_check_in_date,
            stay_duration_months=inq.stay_duration_months,
            room_type_preference=inq.room_type_preference,
            message=inq.message,
            inquiry_source=inq.inquiry_source,
            status=inq.status,
            contacted_by=inq.contacted_by_id,
            contacted_by_name=contacted_by_name,
            contacted_at=inq.contacted_at,
            notes=inq.notes,
        )

    def _to_list_item(self, inq, *, hostel_name: str) -> InquiryListItem:
        return InquiryListItem(
            id=inq.id,
            hostel_name=hostel_name,
            visitor_name=inq.visitor_name,
            visitor_phone=inq.visitor_phone,
            preferred_check_in_date=inq.preferred_check_in_date,
            stay_duration_months=inq.stay_duration_months,
            room_type_preference=inq.room_type_preference,
            status=inq.status,
            created_at=inq.created_at,
        )

    # ------------------------------------------------------------------ #
    # Create / read
    # ------------------------------------------------------------------ #
    def create_inquiry(self, data: InquiryCreate) -> InquiryDetail:
        """
        Create a new visitor inquiry.

        - Validates hostel existence.
        - Uses the default status from InquiryCreate (typically NEW).
        """
        with UnitOfWork(self._session_factory) as uow:
            inquiry_repo = self._get_inquiry_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            payload = data.model_dump()
            inq = inquiry_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            return self._to_detail(
                inq,
                hostel_name=hostel.name,
                contacted_by_name=None,
            )

    def get_inquiry(self, inquiry_id: UUID) -> InquiryDetail:
        """
        Fetch detailed information for a single inquiry.
        """
        with UnitOfWork(self._session_factory) as uow:
            inquiry_repo = self._get_inquiry_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            admin_repo = self._get_admin_repo(uow)

            inq = inquiry_repo.get(inquiry_id)
            if inq is None:
                raise errors.NotFoundError(f"Inquiry {inquiry_id} not found")

            hostel = hostel_repo.get(inq.hostel_id)
            hostel_name = hostel.name if hostel else ""

            contacted_by_name = None
            if inq.contacted_by_id:
                admin = admin_repo.get(inq.contacted_by_id)
                if admin and getattr(admin, "user", None):
                    contacted_by_name = admin.user.full_name

            return self._to_detail(
                inq,
                hostel_name=hostel_name,
                contacted_by_name=contacted_by_name,
            )

    # ------------------------------------------------------------------ #
    # Listing
    # ------------------------------------------------------------------ #
    def list_inquiries_for_hostel(
        self,
        hostel_id: UUID,
        params: PaginationParams,
        *,
        status: Optional[InquiryStatus] = None,
    ) -> PaginatedResponse[InquiryListItem]:
        """
        List inquiries for a hostel with optional status filter.
        """
        with UnitOfWork(self._session_factory) as uow:
            inquiry_repo = self._get_inquiry_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")
            hostel_name = hostel.name

            filters: dict = {"hostel_id": hostel_id}
            if status is not None:
                filters["status"] = status

            records: Sequence = inquiry_repo.get_multi(
                skip=params.offset,
                limit=params.limit,
                filters=filters or None,
                order_by=[inquiry_repo.model.created_at.desc()],  # type: ignore[attr-defined]
            )
            total = inquiry_repo.count(filters=filters or None)

            items: List[InquiryListItem] = [
                self._to_list_item(inq, hostel_name=hostel_name) for inq in records
            ]

            return PaginatedResponse[InquiryListItem].create(
                items=items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    # ------------------------------------------------------------------ #
    # Status update
    # ------------------------------------------------------------------ #
    def update_status(self, data: InquiryStatusUpdate) -> InquiryDetail:
        """
        Update inquiry.status and optionally append notes.

        Status transitions (e.g., NEW -> PENDING -> CONTACTED -> CLOSED)
        are not enforced here; they should be validated at API/business layer
        if you want strict workflows.
        """
        with UnitOfWork(self._session_factory) as uow:
            inquiry_repo = self._get_inquiry_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            admin_repo = self._get_admin_repo(uow)

            inq = inquiry_repo.get(data.inquiry_id)
            if inq is None:
                raise errors.NotFoundError(f"Inquiry {data.inquiry_id} not found")

            inq.status = data.new_status  # type: ignore[attr-defined]

            if data.notes:
                # Append notes to existing notes (simple concatenation)
                existing = inq.notes or ""  # type: ignore[attr-defined]
                if existing:
                    existing += "\n"
                inq.notes = existing + data.notes  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            hostel = hostel_repo.get(inq.hostel_id)
            hostel_name = hostel.name if hostel else ""

            contacted_by_name = None
            if inq.contacted_by_id:
                admin = admin_repo.get(inq.contacted_by_id)
                if admin and getattr(admin, "user", None):
                    contacted_by_name = admin.user.full_name

            return self._to_detail(
                inq,
                hostel_name=hostel_name,
                contacted_by_name=contacted_by_name,
            )

# --- File: D:\hostel-management-saas\app\services\inquiry\__init__.py ---
# app/services/inquiry/__init__.py
"""
Inquiry-related services.

- InquiryService: core inquiry CRUD, listing, status updates.
- InquiryAssignmentService: assign inquiries to admins/staff (contact owner).
"""

from .inquiry_service import InquiryService
from .inquiry_assignment_service import InquiryAssignmentService

__all__ = [
    "InquiryService",
    "InquiryAssignmentService",
]


# ===== Folder: D:\hostel-management-saas\app\services\leave =====

# --- File: D:\hostel-management-saas\app\services\leave\leave_approval_service.py ---
# app/services/leave/leave_approval_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import LeaveApplicationRepository
from app.repositories.core import SupervisorRepository
from app.schemas.common.enums import LeaveStatus
from app.schemas.leave import (
    LeaveApprovalRequest,
    LeaveApprovalResponse,
)
from app.services.common import UnitOfWork, errors


class LeaveApprovalService:
    """
    Approval / rejection of leave applications by supervisor/admin.

    - Approve or reject using LeaveApprovalRequest
    - Update LeaveApplication.status, approved_by_id/rejected_by_id, rejection_reason
    - Return LeaveApprovalResponse
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_leave_repo(self, uow: UnitOfWork) -> LeaveApplicationRepository:
        return uow.get_repo(LeaveApplicationRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Approval / rejection
    # ------------------------------------------------------------------ #
    def process_approval(
        self,
        data: LeaveApprovalRequest,
    ) -> LeaveApprovalResponse:
        """
        Process leave approval or rejection.

        Business rules:
        - Only PENDING requests should be processed.
        """
        now = self._now()

        with UnitOfWork(self._session_factory) as uow:
            leave_repo = self._get_leave_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            leave = leave_repo.get(data.leave_id)
            if leave is None:
                raise errors.NotFoundError(f"Leave {data.leave_id} not found")

            if leave.status != LeaveStatus.PENDING:
                raise errors.ValidationError(
                    f"Leave {data.leave_id} is not in PENDING state"
                )

            supervisor = sup_repo.get(data.approver_id)
            if supervisor is None:
                raise errors.NotFoundError(
                    f"Supervisor {data.approver_id} not found"
                )

            approver_name = (
                supervisor.user.full_name
                if getattr(supervisor, "user", None)
                else None
            )

            approved_by: Optional[UUID] = None
            approved_by_name: Optional[str] = None
            approved_at: Optional[datetime] = None

            rejected_by: Optional[UUID] = None
            rejected_by_name: Optional[str] = None
            rejected_at: Optional[datetime] = None

            if data.approve:
                # Approve
                leave.status = LeaveStatus.APPROVED  # type: ignore[attr-defined]
                leave.approved_by_id = data.approver_id  # type: ignore[attr-defined]
                leave.rejection_reason = None  # type: ignore[attr-defined]

                approved_by = data.approver_id
                approved_by_name = approver_name
                approved_at = now
            else:
                # Reject
                leave.status = LeaveStatus.REJECTED  # type: ignore[attr-defined]
                leave.rejected_by_id = data.approver_id  # type: ignore[attr-defined]
                leave.rejection_reason = data.rejection_reason  # type: ignore[attr-defined]

                rejected_by = data.approver_id
                rejected_by_name = approver_name
                rejected_at = now

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        msg = "Leave approved successfully" if data.approve else "Leave rejected successfully"

        return LeaveApprovalResponse(
            leave_id=data.leave_id,
            status=leave.status,
            approved_by=approved_by,
            approved_by_name=approved_by_name,
            approved_at=approved_at,
            rejected_by=rejected_by,
            rejected_by_name=rejected_by_name,
            rejected_at=rejected_at,
            message=msg,
        )

# --- File: D:\hostel-management-saas\app\services\leave\leave_balance_service.py ---
# app/services/leave/leave_balance_service.py
from __future__ import annotations

from datetime import date
from typing import Callable, Dict, List, Optional, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import LeaveApplicationRepository
from app.repositories.core import StudentRepository, HostelRepository
from app.schemas.common.enums import LeaveStatus, LeaveType
from app.schemas.leave import (
    LeaveBalance,
    LeaveBalanceSummary,
)
from app.services.common import UnitOfWork, errors


class LeaveAllocationStore(Protocol):
    """
    Store for configured annual leave allocations per hostel and leave type.

    Example data shape:
        {
            "SICK": 10,
            "CASUAL": 12,
            "EMERGENCY": 5,
        }
    using LeaveType.value as keys.
    """

    def get_allocations(self, hostel_id: UUID) -> Dict[str, int]: ...
    def save_allocations(self, hostel_id: UUID, allocations: Dict[str, int]) -> None: ...


class LeaveBalanceService:
    """
    Compute leave balance summaries for a student:

    - Uses LeaveApplicationRepository to count used days in a given academic year
    - Uses LeaveAllocationStore to get allocated days per leave type
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        allocation_store: LeaveAllocationStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = allocation_store

    def _get_leave_repo(self, uow: UnitOfWork) -> LeaveApplicationRepository:
        return uow.get_repo(LeaveApplicationRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_balance_summary(
        self,
        *,
        student_id: UUID,
        hostel_id: UUID,
        academic_year_start: date,
        academic_year_end: date,
    ) -> LeaveBalanceSummary:
        """
        Compute LeaveBalanceSummary for one student & hostel over an academic year.
        """
        with UnitOfWork(self._session_factory) as uow:
            leave_repo = self._get_leave_repo(uow)
            student_repo = self._get_student_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            student = student_repo.get(student_id)
            if student is None:
                raise errors.NotFoundError(f"Student {student_id} not found")

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            student_name = (
                student.user.full_name if getattr(student, "user", None) else ""
            )
            hostel_name = hostel.name

            # All leaves for the student
            leaves = leave_repo.list_for_student(student_id)

        # Filter leaves in academic year & with APPROVED or PENDING status
        in_range_leaves = []
        for l in leaves:
            if l.from_date > academic_year_end or l.to_date < academic_year_start:
                continue
            if l.status not in (LeaveStatus.APPROVED, LeaveStatus.PENDING):
                continue
            in_range_leaves.append(l)

        # Used days per leave type
        used_map: Dict[LeaveType, int] = {}
        for l in in_range_leaves:
            lt = l.leave_type
            used_map[lt] = used_map.get(lt, 0) + (l.total_days or 0)

        # Allocations from store (by LeaveType.value)
        allocations_raw = self._store.get_allocations(hostel_id) or {}
        balances: List[LeaveBalance] = []

        # Consider all known leave types from allocations + used_map
        all_types: List[LeaveType] = list(LeaveType)  # type: ignore[arg-type]
        for lt in all_types:
            allocated = int(allocations_raw.get(lt.value, 0))
            used = used_map.get(lt, 0)
            remaining = max(0, allocated - used)
            balances.append(
                LeaveBalance(
                    leave_type=lt,
                    allocated_per_year=allocated,
                    used_days=used,
                    remaining_days=remaining,
                )
            )

        return LeaveBalanceSummary(
            student_id=student_id,
            student_name=student_name,
            hostel_id=hostel_id,
            hostel_name=hostel_name,
            academic_year_start=academic_year_start,
            academic_year_end=academic_year_end,
            balances=balances,
        )

    # Optional: admin API to set allocations
    def set_allocations(
        self,
        *,
        hostel_id: UUID,
        allocations: Dict[LeaveType, int],
    ) -> None:
        """
        Persist per-type annual leave allocations for a hostel.
        """
        raw: Dict[str, int] = {lt.value: v for lt, v in allocations.items()}
        self._store.save_allocations(hostel_id, raw)

# --- File: D:\hostel-management-saas\app\services\leave\leave_service.py ---
# app/services/leave/leave_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import LeaveApplicationRepository
from app.repositories.core import (
    StudentRepository,
    HostelRepository,
    RoomRepository,
)
from app.schemas.common.enums import LeaveStatus
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.leave import (
    LeaveApplicationRequest,
    LeaveCancellationRequest,
    LeaveUpdate,
    LeaveResponse,
    LeaveDetail,
    LeaveListItem,
)
from app.services.common import UnitOfWork, errors


class LeaveService:
    """
    Core leave service:

    - Apply for leave (student)
    - Cancel leave (student)
    - Get leave detail
    - List leaves (by student / by hostel)
    - Update leave (admin/supervisor, before approval)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_leave_repo(self, uow: UnitOfWork) -> LeaveApplicationRepository:
        return uow.get_repo(LeaveApplicationRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_response(
        self,
        leave,
        *,
        student_name: str,
        hostel_name: str,
    ) -> LeaveResponse:
        return LeaveResponse(
            id=leave.id,
            created_at=leave.created_at,
            updated_at=leave.updated_at,
            student_id=leave.student_id,
            student_name=student_name,
            hostel_id=leave.hostel_id,
            hostel_name=hostel_name,
            leave_type=leave.leave_type,
            from_date=leave.from_date,
            to_date=leave.to_date,
            total_days=leave.total_days,
            status=leave.status,
            applied_at=leave.created_at,
        )

    def _to_detail(
        self,
        leave,
        *,
        student_name: str,
        student_room: Optional[str],
        hostel_name: str,
    ) -> LeaveDetail:
        # We don't have explicit approved_at/rejected_at/cancelled_at timestamps in the model.
        applied_at = leave.created_at
        approved_at = None
        rejected_at = None
        cancelled_at = None

        approved_by_name = None
        rejected_by_name = None

        return LeaveDetail(
            id=leave.id,
            created_at=leave.created_at,
            updated_at=leave.updated_at,
            student_id=leave.student_id,
            student_name=student_name,
            student_room=student_room,
            hostel_id=leave.hostel_id,
            hostel_name=hostel_name,
            leave_type=leave.leave_type,
            from_date=leave.from_date,
            to_date=leave.to_date,
            total_days=leave.total_days,
            reason=leave.reason,
            contact_during_leave=leave.contact_during_leave,
            emergency_contact=leave.emergency_contact,
            supporting_document_url=leave.supporting_document_url,
            status=leave.status,
            applied_at=applied_at,
            approved_at=approved_at,
            rejected_at=rejected_at,
            cancelled_at=cancelled_at,
            approved_by=leave.approved_by_id,
            approved_by_name=approved_by_name,
            rejected_by=leave.rejected_by_id,
            rejected_by_name=rejected_by_name,
            rejection_reason=leave.rejection_reason,
            cancellation_reason=leave.cancellation_reason,
        )

    def _to_list_item(
        self,
        leave,
        *,
        student_name: str,
        room_number: Optional[str],
    ) -> LeaveListItem:
        return LeaveListItem(
            id=leave.id,
            student_name=student_name,
            room_number=room_number,
            leave_type=leave.leave_type,
            from_date=leave.from_date,
            to_date=leave.to_date,
            total_days=leave.total_days,
            status=leave.status,
            applied_at=leave.created_at,
        )

    # ------------------------------------------------------------------ #
    # Apply / cancel
    # ------------------------------------------------------------------ #
    def apply_for_leave(self, data: LeaveApplicationRequest) -> LeaveDetail:
        """
        Create a leave application from a student request.

        - Validates student & hostel existence
        - Validates that student belongs to the hostel
        - Computes total_days
        - Sets initial status to PENDING
        """
        total_days = (data.to_date - data.from_date).days + 1
        if total_days <= 0:
            raise errors.ValidationError("to_date must be after or equal to from_date")

        with UnitOfWork(self._session_factory) as uow:
            leave_repo = self._get_leave_repo(uow)
            student_repo = self._get_student_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            room_repo = self._get_room_repo(uow)

            student = student_repo.get(data.student_id)
            if student is None:
                raise errors.NotFoundError(f"Student {data.student_id} not found")

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            if student.hostel_id != data.hostel_id:
                raise errors.ValidationError("Student does not belong to this hostel")

            payload = {
                "student_id": data.student_id,
                "hostel_id": data.hostel_id,
                "leave_type": data.leave_type,
                "from_date": data.from_date,
                "to_date": data.to_date,
                "total_days": total_days,
                "reason": data.reason,
                "contact_during_leave": data.contact_during_leave,
                "emergency_contact": data.emergency_contact,
                "supporting_document_url": data.supporting_document_url,
                "status": LeaveStatus.PENDING,
                "rejection_reason": None,
                "cancellation_reason": None,
            }
            leave = leave_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            student_name = (
                student.user.full_name if getattr(student, "user", None) else ""
            )
            room_number = None
            if student.room_id:
                room = room_repo.get(student.room_id)
                room_number = room.room_number if room else None

            return self._to_detail(
                leave,
                student_name=student_name,
                student_room=room_number,
                hostel_name=hostel.name,
            )

    def cancel_leave(self, data: LeaveCancellationRequest) -> LeaveDetail:
        """
        Student-initiated cancellation of a leave application.

        Allowed statuses: PENDING, APPROVED.
        """
        with UnitOfWork(self._session_factory) as uow:
            leave_repo = self._get_leave_repo(uow)
            student_repo = self._get_student_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            room_repo = self._get_room_repo(uow)

            leave = leave_repo.get(data.leave_id)
            if leave is None:
                raise errors.NotFoundError(f"Leave {data.leave_id} not found")

            if leave.student_id != data.student_id:
                raise errors.ValidationError("Student does not own this leave application")

            if leave.status not in (LeaveStatus.PENDING, LeaveStatus.APPROVED):
                raise errors.ValidationError(
                    f"Leave {data.leave_id} cannot be cancelled from status {leave.status}"
                )

            leave.status = LeaveStatus.CANCELLED  # type: ignore[attr-defined]
            leave.cancellation_reason = data.cancellation_reason  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            student = student_repo.get(leave.student_id)
            hostel = hostel_repo.get(leave.hostel_id)
            student_name = (
                student.user.full_name if student and getattr(student, "user", None) else ""
            )
            room_number = None
            if student and student.room_id:
                room = room_repo.get(student.room_id)
                room_number = room.room_number if room else None

            hostel_name = hostel.name if hostel else ""
            return self._to_detail(
                leave,
                student_name=student_name,
                student_room=room_number,
                hostel_name=hostel_name,
            )

    # ------------------------------------------------------------------ #
    # Generic read/update
    # ------------------------------------------------------------------ #
    def get_leave(self, leave_id: UUID) -> LeaveDetail:
        with UnitOfWork(self._session_factory) as uow:
            leave_repo = self._get_leave_repo(uow)
            student_repo = self._get_student_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            room_repo = self._get_room_repo(uow)

            leave = leave_repo.get(leave_id)
            if leave is None:
                raise errors.NotFoundError(f"Leave {leave_id} not found")

            student = student_repo.get(leave.student_id)
            hostel = hostel_repo.get(leave.hostel_id)

            student_name = (
                student.user.full_name if student and getattr(student, "user", None) else ""
            )
            room_number = None
            if student and student.room_id:
                room = room_repo.get(student.room_id)
                room_number = room.room_number if room else None

            hostel_name = hostel.name if hostel else ""

            return self._to_detail(
                leave,
                student_name=student_name,
                student_room=room_number,
                hostel_name=hostel_name,
            )

    def update_leave(self, leave_id: UUID, data: LeaveUpdate) -> LeaveDetail:
        """
        Update a leave application (typically before approval).

        If from_date/to_date change but total_days is omitted, total_days is recomputed.
        """
        with UnitOfWork(self._session_factory) as uow:
            leave_repo = self._get_leave_repo(uow)

            leave = leave_repo.get(leave_id)
            if leave is None:
                raise errors.NotFoundError(f"Leave {leave_id} not found")

            mapping = data.model_dump(exclude_unset=True)

            # Recompute total_days if date range changed and total_days omitted
            if ("from_date" in mapping or "to_date" in mapping) and "total_days" not in mapping:
                fd = mapping.get("from_date", leave.from_date)
                td = mapping.get("to_date", leave.to_date)
                mapping["total_days"] = (td - fd).days + 1

            for field, value in mapping.items():
                if hasattr(leave, field) and field != "id":
                    setattr(leave, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return self.get_leave(leave_id)

    # ------------------------------------------------------------------ #
    # Listing
    # ------------------------------------------------------------------ #
    def list_leaves_for_student(
        self,
        student_id: UUID,
        params: PaginationParams,
        *,
        status: Optional[LeaveStatus] = None,
    ) -> PaginatedResponse[LeaveListItem]:
        with UnitOfWork(self._session_factory) as uow:
            leave_repo = self._get_leave_repo(uow)
            student_repo = self._get_student_repo(uow)
            room_repo = self._get_room_repo(uow)

            student = student_repo.get(student_id)
            student_name = (
                student.user.full_name if student and getattr(student, "user", None) else ""
            )
            room_number = None
            if student and student.room_id:
                room = room_repo.get(student.room_id)
                room_number = room.room_number if room else None

            records = leave_repo.list_for_student(student_id)
            if status is not None:
                records = [l for l in records if l.status == status]

            total = len(records)
            sliced = records[params.offset : params.offset + params.limit]

            items = [
                self._to_list_item(l, student_name=student_name, room_number=room_number)
                for l in sliced
            ]

            return PaginatedResponse[LeaveListItem].create(
                items=items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    def list_pending_for_hostel(
        self,
        hostel_id: UUID,
        params: PaginationParams,
    ) -> PaginatedResponse[LeaveListItem]:
        """
        List pending leave applications for a hostel.
        """
        with UnitOfWork(self._session_factory) as uow:
            leave_repo = self._get_leave_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)
            room_repo = self._get_room_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            records = leave_repo.list_pending_for_hostel(hostel_id)
            total = len(records)
            sliced = records[params.offset : params.offset + params.limit]

            items: List[LeaveListItem] = []
            for l in sliced:
                st = student_repo.get(l.student_id)
                student_name = (
                    st.user.full_name if st and getattr(st, "user", None) else ""
                )
                room_number = None
                if st and st.room_id:
                    room = room_repo.get(st.room_id)
                    room_number = room.room_number if room else None

                items.append(
                    self._to_list_item(
                        l,
                        student_name=student_name,
                        room_number=room_number,
                    )
                )

            return PaginatedResponse[LeaveListItem].create(
                items=items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

# --- File: D:\hostel-management-saas\app\services\leave\__init__.py ---
# app/services/leave/__init__.py
"""
Leave management services.

- LeaveService: core leave CRUD, apply/cancel, listing.
- LeaveApprovalService: supervisor/admin approval & rejection.
- LeaveBalanceService: compute leave balances using allocation store.
"""

from .leave_service import LeaveService
from .leave_approval_service import LeaveApprovalService
from .leave_balance_service import LeaveBalanceService, LeaveAllocationStore

__all__ = [
    "LeaveService",
    "LeaveApprovalService",
    "LeaveBalanceService",
    "LeaveAllocationStore",
]


# ===== Folder: D:\hostel-management-saas\app\services\maintenance =====

# --- File: D:\hostel-management-saas\app\services\maintenance\maintenance_analytics_service.py ---
# app/services/maintenance/maintenance_analytics_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, List, Dict, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import MaintenanceRepository
from app.schemas.common.filters import DateRangeFilter
from app.schemas.maintenance import (
    MaintenanceAnalytics,
    TrendPoint,
    CostTrendPoint,
    CategoryBreakdown,
    VendorPerformance,
)
from app.services.common import UnitOfWork


class MaintenanceAnalyticsService:
    """
    Basic analytics for maintenance requests.

    - Counts and completion rates
    - Cost totals
    - Simple trends by period
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> MaintenanceRepository:
        return uow.get_repo(MaintenanceRepository)

    def get_analytics_for_hostel(
        self,
        hostel_id: Optional[UUID],
        period: DateRangeFilter,
    ) -> MaintenanceAnalytics:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            filters: dict = {}
            if hostel_id:
                filters["hostel_id"] = hostel_id
            maints = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

        # Filter by created_at or completion date
        filtered = []
        for m in maints:
            created = m.created_at.date()
            if period.start_date and created < period.start_date:
                continue
            if period.end_date and created > period.end_date:
                continue
            filtered.append(m)

        total_requests = len(filtered)
        completed_requests = 0
        pending_requests = 0
        total_cost = Decimal("0")
        total_completed_hours = 0.0
        completed_with_time = 0

        requests_by_category: Dict[str, int] = {}
        cost_by_category: Dict[str, Decimal] = {}

        for m in filtered:
            if m.status.name == "COMPLETED":
                completed_requests += 1
            else:
                pending_requests += 1

            if m.actual_cost:
                total_cost += m.actual_cost

            cat = m.category.value if hasattr(m.category, "value") else str(m.category)
            requests_by_category[cat] = requests_by_category.get(cat, 0) + 1
            if m.actual_cost:
                cost_by_category[cat] = cost_by_category.get(cat, Decimal("0")) + m.actual_cost

            if m.started_at and m.completed_at:
                diff_hours = (m.completed_at - m.started_at).total_seconds() / 3600.0
                total_completed_hours += diff_hours
                completed_with_time += 1

        average_cost = (total_cost / completed_requests) if completed_requests > 0 else Decimal("0")
        average_completion_time = (
            Decimal(str(total_completed_hours / completed_with_time))
            if completed_with_time > 0
            else Decimal("0")
        )
        completion_rate = (
            Decimal(str(completed_requests / total_requests * 100)) if total_requests > 0 else Decimal("0")
        )

        # Simple trend by date
        trend_by_date: Dict[str, Dict[str, int]] = {}
        for m in filtered:
            d = m.created_at.date().isoformat()
            bucket = trend_by_date.setdefault(d, {"requests": 0, "completed": 0})
            bucket["requests"] += 1
            if m.status.name == "COMPLETED":
                bucket["completed"] += 1

        request_trend: List[TrendPoint] = []
        cost_trend: List[CostTrendPoint] = []
        for d, vals in sorted(trend_by_date.items()):
            request_trend.append(
                TrendPoint(
                    period=d,
                    request_count=vals["requests"],
                    completed_count=vals["completed"],
                )
            )
            day_cost = sum(
                (mm.actual_cost or Decimal("0"))
                for mm in filtered
                if mm.created_at.date().isoformat() == d
            )
            cost_trend.append(
                CostTrendPoint(
                    period=d,
                    total_cost=day_cost,
                    request_count=vals["requests"],
                    average_cost=(day_cost / vals["requests"]) if vals["requests"] else Decimal("0"),
                )
            )

        category_breakdowns: List[CategoryBreakdown] = []
        for cat, count in requests_by_category.items():
            avg_cost_cat = (
                cost_by_category.get(cat, Decimal("0")) / count if count > 0 else Decimal("0")
            )
            category_breakdowns.append(
                CategoryBreakdown(
                    category=cat,
                    total_requests=count,
                    completed_requests=0,
                    total_cost=cost_by_category.get(cat, Decimal("0")),
                    average_cost=avg_cost_cat,
                    average_completion_time_hours=average_completion_time,
                )
            )

        return MaintenanceAnalytics(
            hostel_id=hostel_id,
            period=period,
            generated_at=datetime.now(timezone.utc),
            total_requests=total_requests,
            completed_requests=completed_requests,
            pending_requests=pending_requests,
            total_cost=total_cost,
            average_cost=average_cost,
            average_completion_time_hours=average_completion_time,
            completion_rate=completion_rate,
            requests_by_category=requests_by_category,
            cost_by_category=cost_by_category,
            request_trend=request_trend,
            cost_trend=cost_trend,
        )

# --- File: D:\hostel-management-saas\app\services\maintenance\maintenance_approval_service.py ---
# app/services/maintenance/maintenance_approval_service.py
from __future__ import annotations

from datetime import datetime, timezone
from decimal import Decimal
from typing import Protocol, Optional, Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import MaintenanceRepository
from app.schemas.maintenance import (
    ApprovalRequest,
    ApprovalResponse,
    ThresholdConfig,
    ApprovalWorkflow,
    RejectionRequest,
)
from app.services.common import UnitOfWork, errors


class ThresholdStore(Protocol):
    """
    Store for hostel-specific cost approval thresholds.
    Back it with Redis or a DB table.
    """

    def get_threshold(self, hostel_id: UUID) -> Optional[dict]: ...
    def save_threshold(self, hostel_id: UUID, data: dict) -> None: ...


class ApprovalStore(Protocol):
    """
    Store for pending/processed approval requests.

    Simplified: keyed by maintenance_id.
    """

    def get_workflow(self, maintenance_id: UUID) -> Optional[dict]: ...
    def save_workflow(self, maintenance_id: UUID, data: dict) -> None: ...


class MaintenanceApprovalService:
    """
    High-level cost approval service:

    - Maintain ThresholdConfig per hostel.
    - Process supervisor-initiated ApprovalRequest.
    - Mark Maintenance cost_approved / approval_threshold_exceeded.

    This service assumes:
    - Estimated cost is stored in Maintenance.estimated_cost.
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        threshold_store: ThresholdStore,
        approval_store: ApprovalStore,
    ) -> None:
        self._session_factory = session_factory
        self._threshold_store = threshold_store
        self._approval_store = approval_store

    def _get_repo(self, uow: UnitOfWork) -> MaintenanceRepository:
        return uow.get_repo(MaintenanceRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Threshold configuration
    # ------------------------------------------------------------------ #
    def get_threshold_config(self, hostel_id: UUID) -> ThresholdConfig:
        record = self._threshold_store.get_threshold(hostel_id)
        if record:
            return ThresholdConfig.model_validate(record)
        # Default configuration if none stored
        default = ThresholdConfig(hostel_id=hostel_id)
        self._threshold_store.save_threshold(hostel_id, default.model_dump())
        return default

    def set_threshold_config(self, config: ThresholdConfig) -> None:
        self._threshold_store.save_threshold(config.hostel_id, config.model_dump())

    # ------------------------------------------------------------------ #
    # Approval flow
    # ------------------------------------------------------------------ #
    def request_approval(self, data: ApprovalRequest, *, requested_by_id: UUID) -> ApprovalWorkflow:
        """
        Supervisor requests approval for maintenance cost.

        We simply record the request in ApprovalStore; actual decision is
        handled by approve()/reject().
        """
        now = self._now()
        record = {
            "maintenance_id": str(data.maintenance_id),
            "estimated_cost": str(data.estimated_cost),
            "cost_breakdown": data.cost_breakdown or {},
            "approval_reason": data.approval_reason,
            "urgent": data.urgent,
            "preferred_vendor": data.preferred_vendor,
            "vendor_quote": data.vendor_quote,
            "requested_by_id": str(requested_by_id),
            "status": "pending",
            "submitted_for_approval_at": now,
            "approved_at": None,
            "rejected_at": None,
            "approved_by_id": None,
            "rejection_reason": None,
        }
        self._approval_store.save_workflow(data.maintenance_id, record)

        # Evaluate threshold for this maintenance
        with UnitOfWork(self._session_factory) as uow:
            maint_repo = self._get_repo(uow)
            m = maint_repo.get(data.maintenance_id)
            if m is None:
                raise errors.NotFoundError(f"Maintenance {data.maintenance_id} not found")

            config = self.get_threshold_config(m.hostel_id)
            threshold_exceeded = data.estimated_cost > config.admin_approval_required_above

        return ApprovalWorkflow(
            maintenance_id=data.maintenance_id,
            request_number=f"MTN-{str(data.maintenance_id)[:8].upper()}",
            estimated_cost=data.estimated_cost,
            threshold_exceeded=threshold_exceeded,
            requires_approval=True,
            approval_pending=True,
            pending_with=None,
            pending_with_name=None,
            submitted_for_approval_at=record["submitted_for_approval_at"],
            approval_deadline=None,
        )

    def approve(
        self,
        maintenance_id: UUID,
        *,
        approved_by_id: UUID,
        approved_by_name: str,
        approved_amount: Decimal,
        approval_conditions: Optional[str] = None,
    ) -> ApprovalResponse:
        now = self._now()
        workflow = self._approval_store.get_workflow(maintenance_id)
        if not workflow:
            # Create a basic workflow record if missing
            workflow = {
                "maintenance_id": str(maintenance_id),
                "status": "pending",
                "submitted_for_approval_at": now,
            }

        workflow["status"] = "approved"
        workflow["approved_by_id"] = str(approved_by_id)
        workflow["approved_at"] = now
        workflow["rejection_reason"] = None
        self._approval_store.save_workflow(maintenance_id, workflow)

        with UnitOfWork(self._session_factory) as uow:
            maint_repo = self._get_repo(uow)
            m = maint_repo.get(maintenance_id)
            if m is None:
                raise errors.NotFoundError(f"Maintenance {maintenance_id} not found")

            config = self.get_threshold_config(m.hostel_id)
            threshold_exceeded = approved_amount > config.admin_approval_required_above

            # Mark approval flags and adjust estimated_cost
            m.estimated_cost = approved_amount  # type: ignore[attr-defined]
            m.cost_approved = True  # type: ignore[attr-defined]
            m.approval_threshold_exceeded = threshold_exceeded  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return ApprovalResponse(
            maintenance_id=maintenance_id,
            request_number=f"MTN-{str(maintenance_id)[:8].upper()}",
            approved=True,
            approved_by=approved_by_id,
            approved_by_name=approved_by_name,
            approved_at=now,
            approved_amount=approved_amount,
            approval_conditions=approval_conditions,
            message="Maintenance cost approved",
        )

    def reject(
        self,
        data: RejectionRequest,
        *,
        rejected_by_id: UUID,
        rejected_by_name: str,
    ) -> ApprovalResponse:
        now = self._now()
        workflow = self._approval_store.get_workflow(data.maintenance_id)
        if not workflow:
            workflow = {
                "maintenance_id": str(data.maintenance_id),
                "submitted_for_approval_at": now,
            }

        workflow["status"] = "rejected"
        workflow["approved_by_id"] = None
        workflow["approved_at"] = None
        workflow["rejection_reason"] = data.rejection_reason
        workflow["rejected_at"] = now
        self._approval_store.save_workflow(data.maintenance_id, workflow)

        # Do not change Maintenance.cost_approved for rejection; caller may
        # set status separately.

        return ApprovalResponse(
            maintenance_id=data.maintenance_id,
            request_number=f"MTN-{str(data.maintenance_id)[:8].upper()}",
            approved=False,
            approved_by=rejected_by_id,
            approved_by_name=rejected_by_name,
            approved_at=now,
            approved_amount=Decimal("0"),
            approval_conditions=None,
            message="Maintenance approval rejected",
        )

# --- File: D:\hostel-management-saas\app\services\maintenance\maintenance_assignment_service.py ---
# app/services/maintenance/maintenance_assignment_service.py
from __future__ import annotations

from datetime import datetime, timezone, date
from typing import Callable, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import MaintenanceRepository
from app.repositories.core import SupervisorRepository, UserRepository
from app.schemas.maintenance import (
    TaskAssignment,
    AssignmentUpdate,
    BulkAssignment,
)
from app.services.common import UnitOfWork, errors


class MaintenanceAssignmentService:
    """
    Assign/reassign maintenance tasks to supervisors/staff.

    This service updates:
    - maintenance.assigned_to_id
    - optionally status/transitions (e.g., ASSIGNED)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_maintenance_repo(self, uow: UnitOfWork) -> MaintenanceRepository:
        return uow.get_repo(MaintenanceRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def _request_number(self, maintenance_id: UUID) -> str:
        return f"MTN-{str(maintenance_id)[:8].upper()}"

    # ------------------------------------------------------------------ #
    # Assignment
    # ------------------------------------------------------------------ #
    def assign(
        self,
        maintenance_id: UUID,
        assigned_to_id: UUID,
        *,
        assigned_by_id: UUID,
        deadline: Optional[date] = None,
        instructions: Optional[str] = None,
    ) -> TaskAssignment:
        with UnitOfWork(self._session_factory) as uow:
            maint_repo = self._get_maintenance_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)

            m = maint_repo.get(maintenance_id)
            if m is None:
                raise errors.NotFoundError(f"Maintenance {maintenance_id} not found")

            supervisor = sup_repo.get(assigned_to_id)
            if supervisor is None:
                raise errors.NotFoundError(f"Supervisor {assigned_to_id} not found")

            assigned_to_user = user_repo.get(supervisor.user_id)
            assigned_by_user = user_repo.get(assigned_by_id)

            m.assigned_to_id = assigned_to_id  # type: ignore[attr-defined]

            assigned_at = self._now()
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            return TaskAssignment(
                id=None,
                created_at=assigned_at,
                updated_at=assigned_at,
                maintenance_id=m.id,
                request_number=self._request_number(m.id),
                assigned_to=assigned_to_id,
                assigned_to_name=assigned_to_user.full_name if assigned_to_user else "",
                assigned_by=assigned_by_id,
                assigned_by_name=assigned_by_user.full_name if assigned_by_user else "",
                assigned_at=assigned_at,
                deadline=deadline,
                instructions=instructions,
            )

    def update_assignment(self, data: AssignmentUpdate, *, updated_by_id: UUID) -> None:
        """
        Basic reassignment/deadline change, without changing status.
        This demonstrates how you can extend for more complex logic.
        """
        with UnitOfWork(self._session_factory) as uow:
            maint_repo = self._get_maintenance_repo(uow)
            m = maint_repo.get(data.maintenance_id)
            if m is None:
                raise errors.NotFoundError(f"Maintenance {data.maintenance_id} not found")

            if data.new_assigned_to:
                m.assigned_to_id = data.new_assigned_to  # type: ignore[attr-defined]

            # The rest of fields (new_deadline, additional_instructions) would be
            # stored in a separate assignment-history structure; not present in
            # the current Maintenance model, so skipped here.

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

    def bulk_assign(self, data: BulkAssignment, *, assigned_by_id: UUID) -> List[TaskAssignment]:
        responses: List[TaskAssignment] = []
        for maintenance_id in data.maintenance_ids:
            resp = self.assign(
                maintenance_id=maintenance_id,
                assigned_to_id=data.assigned_to,
                assigned_by_id=assigned_by_id,
                deadline=data.common_deadline,
                instructions=data.instructions,
            )
            responses.append(resp)
        return responses

# --- File: D:\hostel-management-saas\app\services\maintenance\maintenance_completion_service.py ---
# app/services/maintenance/maintenance_completion_service.py
from __future__ import annotations

from datetime import datetime, timezone
from decimal import Decimal
from typing import Protocol, List, Optional, Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import MaintenanceRepository
from app.schemas.maintenance import (
    CompletionRequest,
    CompletionResponse,
    QualityCheck,
    CompletionCertificate,
    MaterialItem,
    ChecklistItem,
)
from app.services.common import UnitOfWork, errors


class CompletionStore(Protocol):
    """
    Store for completion details (materials, labor, quality checks, certificates).
    Maintenance model itself does not contain these extended fields.
    """

    def save_completion(self, maintenance_id: UUID, data: dict) -> None: ...
    def get_completion(self, maintenance_id: UUID) -> Optional[dict]: ...


class MaintenanceCompletionService:
    """
    Mark maintenance as completed and record completion details & quality checks.

    This service:
    - Updates Maintenance.actual_cost, completed_at, actual_completion_date.
    - Stores extended details in a CompletionStore.
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: CompletionStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store

    def _get_repo(self, uow: UnitOfWork) -> MaintenanceRepository:
        return uow.get_repo(MaintenanceRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def _request_number(self, maintenance_id: UUID) -> str:
        return f"MTN-{str(maintenance_id)[:8].upper()}"

    # ------------------------------------------------------------------ #
    # Completion
    # ------------------------------------------------------------------ #
    def complete(
        self,
        data: CompletionRequest,
        *,
        completed_by_id: UUID,
        completed_by_name: str,
    ) -> CompletionResponse:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            m = repo.get(data.maintenance_id)
            if m is None:
                raise errors.NotFoundError(f"Maintenance {data.maintenance_id} not found")

            m.actual_cost = data.actual_cost  # type: ignore[attr-defined]
            m.actual_completion_date = data.actual_completion_date  # type: ignore[attr-defined]
            completed_at = self._now()
            m.completed_at = completed_at  # type: ignore[attr-defined]
            # Status update is usually done via MaintenanceService.update_status

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        # Save extended completion metadata
        record = {
            "work_notes": data.work_notes,
            "materials_used": [mi.model_dump() for mi in data.materials_used],
            "labor_hours": str(data.labor_hours),
            "cost_breakdown": data.cost_breakdown or {},
            "completion_photos": [str(p) for p in data.completion_photos],
            "follow_up_required": data.follow_up_required,
            "follow_up_notes": data.follow_up_notes,
        }
        self._store.save_completion(data.maintenance_id, record)

        estimated_cost = m.estimated_cost or Decimal("0")  # type: ignore[name-defined]
        cost_variance = data.actual_cost - estimated_cost
        within_budget = cost_variance <= 0

        return CompletionResponse(
            maintenance_id=data.maintenance_id,
            request_number=self._request_number(data.maintenance_id),
            completed=True,
            completed_at=completed_at,
            completed_by=completed_by_id,
            completed_by_name=completed_by_name,
            estimated_cost=estimated_cost,
            actual_cost=data.actual_cost,
            cost_variance=cost_variance,
            within_budget=within_budget,
            quality_checked=False,
            quality_check_passed=None,
            message="Maintenance marked as completed",
        )

    # ------------------------------------------------------------------ #
    # Quality check
    # ------------------------------------------------------------------ #
    def record_quality_check(self, data: QualityCheck) -> None:
        existing = self._store.get_completion(data.maintenance_id) or {}
        existing["quality_check_passed"] = data.quality_check_passed
        existing["checklist_items"] = [ci.model_dump() for ci in data.checklist_items]
        existing["quality_check_notes"] = data.quality_check_notes
        existing["checked_by"] = str(data.checked_by)
        existing["rework_required"] = data.rework_required
        existing["rework_details"] = data.rework_details
        existing["quality_checked_at"] = self._now()
        self._store.save_completion(data.maintenance_id, existing)

    # ------------------------------------------------------------------ #
    # Certificate (read-only assembly)
    # ------------------------------------------------------------------ #
    def get_completion_certificate(
        self,
        maintenance_id: UUID,
        *,
        verified_by: str,
        approved_by: str,
    ) -> CompletionCertificate:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            m = repo.get(maintenance_id)
            if m is None:
                raise errors.NotFoundError(f"Maintenance {maintenance_id} not found")

        details = self._store.get_completion(maintenance_id) or {}
        materials = [
            MaterialItem.model_validate(mi) for mi in details.get("materials_used", [])
        ]
        labor_hours = Decimal(details.get("labor_hours", "0"))
        total_cost = m.actual_cost or Decimal("0")

        today = date.today()
        return CompletionCertificate(
            maintenance_id=maintenance_id,
            request_number=self._request_number(maintenance_id),
            certificate_number=f"CERT-{str(maintenance_id)[:8].upper()}",
            work_description=details.get("work_notes", ""),
            materials_used=materials,
            labor_hours=labor_hours,
            total_cost=total_cost,
            completed_by="",  # can be filled by caller from user context
            verified_by=verified_by,
            approved_by=approved_by,
            completion_date=m.actual_completion_date or today,
            verification_date=today,
            certificate_issue_date=today,
            warranty_period_months=None,
            warranty_terms=None,
        )

# --- File: D:\hostel-management-saas\app\services\maintenance\maintenance_cost_service.py ---
# app/services/maintenance/maintenance_cost_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Protocol, List, Dict, Optional, Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import MaintenanceRepository
from app.schemas.common.filters import DateRangeFilter
from app.schemas.maintenance import (
    CostTracking,
    BudgetAllocation,
    CategoryBudget,
    ExpenseReport,
    MonthlyExpense,
    ExpenseItem,
    CostAnalysis,
)
from app.services.common import UnitOfWork


class BudgetStore(Protocol):
    """
    Store for hostel maintenance budgets by fiscal year and category.
    """

    def get_budget(self, hostel_id: UUID, fiscal_year: str) -> Optional[dict]: ...
    def save_budget(self, hostel_id: UUID, fiscal_year: str, data: dict) -> None: ...


class CostMetadataStore(Protocol):
    """
    Optional metadata store for materials/labor/vendor_charges breakdown per request.
    """

    def get_cost_metadata(self, maintenance_id: UUID) -> Optional[dict]: ...


class MaintenanceCostService:
    """
    Generate cost tracking and budget/expense analytics for maintenance.

    - Uses Maintenance.actual_cost as primary cost figure.
    - Optionally enriches with metadata from CostMetadataStore.
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        budget_store: BudgetStore,
        cost_metadata_store: Optional[CostMetadataStore] = None,
    ) -> None:
        self._session_factory = session_factory
        self._budget_store = budget_store
        self._cost_meta = cost_metadata_store

    def _get_repo(self, uow: UnitOfWork) -> MaintenanceRepository:
        return uow.get_repo(MaintenanceRepository)

    # ------------------------------------------------------------------ #
    # Cost tracking per request
    # ------------------------------------------------------------------ #
    def get_cost_tracking(self, maintenance_id: UUID) -> CostTracking:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            m = repo.get(maintenance_id)
            if not m:
                raise ValueError(f"Maintenance {maintenance_id} not found")

        meta = self._cost_meta.get_cost_metadata(maintenance_id) if self._cost_meta else {}
        materials_cost = Decimal(str(meta.get("materials_cost", "0")))
        labor_cost = Decimal(str(meta.get("labor_cost", "0")))
        vendor_charges = Decimal(str(meta.get("vendor_charges", "0")))
        other_costs = Decimal(str(meta.get("other_costs", "0")))
        actual_cost = m.actual_cost or Decimal("0")
        estimated_cost = m.estimated_cost or Decimal("0")
        variance = actual_cost - estimated_cost
        variance_pct = Decimal("0")
        if estimated_cost > 0:
            variance_pct = (variance / estimated_cost) * 100

        return CostTracking(
            maintenance_id=maintenance_id,
            request_number=f"MTN-{str(maintenance_id)[:8].upper()}",
            estimated_cost=estimated_cost,
            approved_cost=estimated_cost,
            actual_cost=actual_cost,
            variance=variance,
            variance_percentage=variance_pct,
            within_budget=variance <= 0,
            materials_cost=materials_cost,
            labor_cost=labor_cost,
            vendor_charges=vendor_charges,
            other_costs=other_costs,
        )

    # ------------------------------------------------------------------ #
    # Budget allocation
    # ------------------------------------------------------------------ #
    def get_budget_allocation(self, hostel_id: UUID, fiscal_year: str) -> BudgetAllocation:
        record = self._budget_store.get_budget(hostel_id, fiscal_year)
        if not record:
            # Default zero budget allocation
            return BudgetAllocation(
                hostel_id=hostel_id,
                hostel_name="",
                fiscal_year=fiscal_year,
                total_budget=Decimal("0"),
                allocated_budget=Decimal("0"),
                spent_amount=Decimal("0"),
                remaining_budget=Decimal("0"),
                utilization_percentage=Decimal("0"),
                budget_by_category={},
            )
        return BudgetAllocation.model_validate(record)

    # ------------------------------------------------------------------ #
    # Expense report
    # ------------------------------------------------------------------ #
    def get_expense_report(
        self,
        hostel_id: Optional[UUID],
        period: DateRangeFilter,
    ) -> ExpenseReport:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            filters: dict = {}
            if hostel_id:
                filters["hostel_id"] = hostel_id
            maints = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

        # Filter by completion_date range
        records = []
        for m in maints:
            comp_date = m.actual_completion_date
            if not comp_date:
                continue
            if period.start_date and comp_date < period.start_date:
                continue
            if period.end_date and comp_date > period.end_date:
                continue
            records.append(m)

        total_exp = Decimal("0")
        expenses_by_category: Dict[str, Decimal] = {}
        monthly_map: Dict[str, List[Decimal]] = {}
        expenses_by_priority: Dict[str, Decimal] = {}
        items: List[ExpenseItem] = []

        for m in records:
            cost = m.actual_cost or Decimal("0")
            total_exp += cost
            cat = m.category.value if hasattr(m.category, "value") else str(m.category)
            expenses_by_category[cat] = expenses_by_category.get(cat, Decimal("0")) + cost
            prio = m.priority.value if hasattr(m.priority, "value") else str(m.priority)
            expenses_by_priority[prio] = expenses_by_priority.get(prio, Decimal("0")) + cost

            month_key = m.actual_completion_date.strftime("%Y-%m")  # type: ignore[union-attr]
            monthly_map.setdefault(month_key, []).append(cost)

            items.append(
                ExpenseItem(
                    maintenance_id=m.id,
                    request_number=f"MTN-{str(m.id)[:8].upper()}",
                    title=m.title,
                    category=cat,
                    actual_cost=cost,
                    completion_date=m.actual_completion_date,  # type: ignore[arg-defined]
                )
            )

        monthly_expenses: List[MonthlyExpense] = []
        for month, costs in sorted(monthly_map.items()):
            total_month = sum(costs)
            monthly_expenses.append(
                MonthlyExpense(
                    month=month,
                    total_expenses=total_month,
                    request_count=len(costs),
                    average_cost=(total_month / len(costs)) if costs else Decimal("0"),
                )
            )

        avg_cost = (total_exp / len(records)) if records else Decimal("0")
        return ExpenseReport(
            hostel_id=hostel_id,
            report_period=period,
            generated_at=datetime.now(timezone.utc),
            total_expenses=total_exp,
            total_requests=len(records),
            average_cost_per_request=avg_cost,
            expenses_by_category=expenses_by_category,
            monthly_expenses=monthly_expenses,
            expenses_by_priority=expenses_by_priority,
            top_expensive_requests=sorted(items, key=lambda i: i.actual_cost, reverse=True)[:10],
        )

    # ------------------------------------------------------------------ #
    # Cost analysis
    # ------------------------------------------------------------------ #
    def get_cost_analysis(self, hostel_id: UUID, period: DateRangeFilter) -> CostAnalysis:
        report = self.get_expense_report(hostel_id, period)

        trend = "stable"
        trend_pct = Decimal("0")
        if len(report.monthly_expenses) >= 2:
            last = report.monthly_expenses[-1].total_expenses
            prev = report.monthly_expenses[-2].total_expenses
            if prev > 0:
                trend_pct = (last - prev) / prev * 100
                if trend_pct > 5:
                    trend = "increasing"
                elif trend_pct < -5:
                    trend = "decreasing"

        highest_cat = None
        most_freq_cat = None
        if report.expenses_by_category:
            highest_cat = max(report.expenses_by_category.items(), key=lambda kv: kv[1])[0]
            most_freq_cat = highest_cat  # for simplicity; could use count instead

        # For cost_per_student / cost_per_room we need additional data; set to 0 here,
        # can be enriched later by injecting hostel capacity/student count.
        return CostAnalysis(
            hostel_id=hostel_id,
            analysis_period=period,
            cost_trend=trend,
            trend_percentage=trend_pct,
            highest_cost_category=highest_cat or "",
            most_frequent_category=most_freq_cat or "",
            cost_per_student=Decimal("0"),
            cost_per_room=Decimal("0"),
            comparison_to_previous_period=Decimal("0"),
        )

# --- File: D:\hostel-management-saas\app\services\maintenance\maintenance_schedule_service.py ---
# app/services/maintenance/maintenance_schedule_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Protocol, List, Optional
from uuid import UUID

from app.schemas.maintenance import (
    PreventiveSchedule,
    ScheduleCreate,
    RecurrenceConfig,
    ScheduleExecution,
    ScheduleUpdate,
    ScheduleHistory,
    ExecutionHistoryItem,
)
from app.services.common import errors


class ScheduleStore(Protocol):
    """
    Store preventive maintenance schedules and their execution history.
    """

    def create_schedule(self, data: dict) -> dict: ...
    def update_schedule(self, schedule_id: UUID, data: dict) -> dict: ...
    def get_schedule(self, schedule_id: UUID) -> Optional[dict]: ...
    def list_schedules_for_hostel(self, hostel_id: UUID) -> List[dict]: ...
    def add_execution(self, schedule_id: UUID, execution: dict) -> None: ...
    def list_executions(self, schedule_id: UUID) -> List[dict]: ...


class MaintenanceScheduleService:
    """
    Manage preventive maintenance schedules (non-SQL storage via ScheduleStore).

    - Create/update schedules
    - Record executions
    - Produce schedule history
    """

    def __init__(self, store: ScheduleStore) -> None:
        self._store = store

    # ------------------------------------------------------------------ #
    # Scheduling
    # ------------------------------------------------------------------ #
    def create_schedule(self, data: ScheduleCreate, *, hostel_name: str) -> PreventiveSchedule:
        record = {
            "hostel_id": str(data.hostel_id),
            "hostel_name": hostel_name,
            "title": data.title,
            "description": data.description,
            "category": data.category.value if hasattr(data.category, "value") else str(data.category),
            "recurrence": data.recurrence.value if hasattr(data.recurrence, "value") else str(data.recurrence),
            "next_due_date": data.start_date.isoformat(),
            "assigned_to": str(data.assigned_to) if data.assigned_to else None,
            "assigned_to_name": None,
            "estimated_cost": str(data.estimated_cost) if data.estimated_cost is not None else None,
            "is_active": True,
            "last_completed_date": None,
        }
        created = self._store.create_schedule(record)
        return PreventiveSchedule(
            id=UUID(created["id"]),
            created_at=None,
            updated_at=None,
            hostel_id=data.hostel_id,
            hostel_name=hostel_name,
            title=data.title,
            description=data.description,
            category=data.category,
            recurrence=data.recurrence,
            next_due_date=data.start_date,
            assigned_to=data.assigned_to,
            assigned_to_name=None,
            estimated_cost=data.estimated_cost,
            is_active=True,
            last_completed_date=None,
        )

    def update_schedule(self, schedule_id: UUID, data: ScheduleUpdate) -> PreventiveSchedule:
        existing = self._store.get_schedule(schedule_id)
        if not existing:
            raise errors.NotFoundError(f"Preventive schedule {schedule_id} not found")

        update_data = data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            if field == "recurrence" and value is not None:
                existing["recurrence"] = value.value if hasattr(value, "value") else str(value)
            elif field == "next_due_date" and value is not None:
                existing["next_due_date"] = value.isoformat()
            else:
                existing[field] = value

        updated = self._store.update_schedule(schedule_id, existing)
        return PreventiveSchedule(
            id=schedule_id,
            created_at=None,
            updated_at=None,
            hostel_id=UUID(updated["hostel_id"]),
            hostel_name=updated.get("hostel_name", ""),
            title=updated["title"],
            description=updated.get("description"),
            category=data.recurrence or updated["category"],
            recurrence=data.recurrence or updated["recurrence"],
            next_due_date=date.fromisoformat(updated["next_due_date"]),
            assigned_to=UUID(updated["assigned_to"]) if updated.get("assigned_to") else None,
            assigned_to_name=updated.get("assigned_to_name"),
            estimated_cost=Decimal(updated["estimated_cost"]) if updated.get("estimated_cost") else None,
            is_active=updated.get("is_active", True),
            last_completed_date=date.fromisoformat(updated["last_completed_date"]) if updated.get("last_completed_date") else None,
        )

    # ------------------------------------------------------------------ #
    # Execution
    # ------------------------------------------------------------------ #
    def record_execution(self, data: ScheduleExecution, *, completed_by_name: Optional[str] = None) -> None:
        exec_record = {
            "execution_date": data.execution_date.isoformat(),
            "completed": data.completed,
            "actual_cost": str(data.actual_cost) if data.actual_cost is not None else None,
            "completion_notes": data.completion_notes,
            "completed_by": completed_by_name,
            "skip_next_occurrence": data.skip_next_occurrence,
            "reschedule_next_to": data.reschedule_next_to.isoformat() if data.reschedule_next_to else None,
        }
        self._store.add_execution(data.schedule_id, exec_record)

    def get_history(self, schedule_id: UUID, title: str) -> ScheduleHistory:
        executions = self._store.list_executions(schedule_id)
        items: List[ExecutionHistoryItem] = []
        completed_count = 0
        skipped_count = 0
        for ex in executions:
            completed = ex.get("completed", False)
            if completed:
                completed_count += 1
            if ex.get("skip_next_occurrence"):
                skipped_count += 1

            items.append(
                ExecutionHistoryItem(
                    execution_date=date.fromisoformat(ex["execution_date"]),
                    completed=completed,
                    actual_cost=Decimal(ex["actual_cost"]) if ex.get("actual_cost") else None,
                    completion_notes=ex.get("completion_notes"),
                    completed_by=None,
                    completed_by_name=ex.get("completed_by"),
                )
            )

        return ScheduleHistory(
            schedule_id=schedule_id,
            title=title,
            total_executions=len(executions),
            completed_executions=completed_count,
            skipped_executions=skipped_count,
            executions=items,
        )

# --- File: D:\hostel-management-saas\app\services\maintenance\maintenance_service.py ---
# app/services/maintenance/maintenance_service.py
from __future__ import annotations

from datetime import datetime, timezone, date
from typing import Callable, Optional, Sequence, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import MaintenanceRepository
from app.repositories.core import HostelRepository, RoomRepository, StudentRepository, UserRepository, SupervisorRepository
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.common.enums import MaintenanceStatus, Priority
from app.schemas.maintenance import (
    MaintenanceCreate,
    MaintenanceUpdate,
    MaintenanceStatusUpdate,
    MaintenanceResponse,
    MaintenanceDetail,
    RequestListItem,
    MaintenanceSummary,
    MaintenanceFilterParams,
    SearchRequest,
)
from app.services.common import UnitOfWork, pagination, errors


class MaintenanceService:
    """
    Core Maintenance service:

    - Create/update maintenance records
    - Change status
    - Retrieve single maintenance detail
    - List maintenance with basic filters/search
    - Summary stats per hostel
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_repo(self, uow: UnitOfWork) -> MaintenanceRepository:
        return uow.get_repo(MaintenanceRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def _request_number(self, maintenance_id: UUID) -> str:
        # Simple maintenance request number format; customize as needed
        return f"MTN-{str(maintenance_id)[:8].upper()}"

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_list_item(
        self,
        m,
        now: Optional[datetime] = None,
        room_number: Optional[str] = None,
        assigned_to_name: Optional[str] = None,
    ) -> RequestListItem:
        if now is None:
            now = self._now()
        created_at = m.created_at
        est_completion = m.estimated_completion_date
        return RequestListItem(
            id=m.id,
            request_number=self._request_number(m.id),
            title=m.title,
            category=m.category.value if hasattr(m.category, "value") else str(m.category),
            priority=m.priority.value if hasattr(m.priority, "value") else str(m.priority),
            status=m.status,
            room_number=room_number,
            estimated_cost=m.estimated_cost,
            assigned_to_name=assigned_to_name,
            created_at=created_at,
            estimated_completion_date=est_completion,
        )

    def _to_response(self, m) -> MaintenanceResponse:
        hostel = getattr(m, "hostel", None)
        requested_by = getattr(m, "requested_by", None)
        assigned_to = getattr(m, "assigned_to", None)
        assigned_to_user = getattr(assigned_to, "user", None) if assigned_to else None

        return MaintenanceResponse(
            id=m.id,
            created_at=m.created_at,
            updated_at=m.updated_at,
            request_number=self._request_number(m.id),
            hostel_id=m.hostel_id,
            hostel_name=hostel.name if hostel else "",
            requested_by=m.requested_by_id,
            requested_by_name=requested_by.full_name if requested_by else "",
            title=m.title,
            category=m.category,
            priority=m.priority,
            status=m.status,
            assigned_to=m.assigned_to_id,
            assigned_to_name=assigned_to_user.full_name if assigned_to_user else None,
            estimated_cost=m.estimated_cost,
            actual_cost=m.actual_cost,
            created_at=m.created_at,
            estimated_completion_date=m.estimated_completion_date,
            completed_at=m.completed_at,
        )

    def _to_detail(
        self,
        m,
        room_number: Optional[str] = None,
    ) -> MaintenanceDetail:
        hostel = getattr(m, "hostel", None)
        requested_by = getattr(m, "requested_by", None)
        assigned_to = getattr(m, "assigned_to", None)
        assigned_to_user = getattr(assigned_to, "user", None) if assigned_to else None

        return MaintenanceDetail(
            id=m.id,
            created_at=m.created_at,
            updated_at=m.updated_at,
            request_number=self._request_number(m.id),
            hostel_id=m.hostel_id,
            hostel_name=hostel.name if hostel else "",
            requested_by=m.requested_by_id,
            requested_by_name=requested_by.full_name if requested_by else "",
            room_id=m.room_id,
            room_number=room_number,
            title=m.title,
            description=m.description,
            category=m.category,
            priority=m.priority,
            issue_type=m.issue_type.value if hasattr(m.issue_type, "value") else str(m.issue_type),
            location=m.location,
            floor=m.floor,
            specific_area=m.specific_area,
            issue_photos=m.issue_photos or [],
            completion_photos=[],
            assigned_to=m.assigned_to_id,
            assigned_to_name=assigned_to_user.full_name if assigned_to_user else None,
            assigned_by=None,
            assigned_by_name=None,
            assigned_at=None,
            vendor_name=None,
            vendor_contact=None,
            status=m.status,
            approved_by=None,
            approved_by_name=None,
            approved_at=None,
            rejected_by=None,
            rejected_at=None,
            rejection_reason=None,
            started_at=m.started_at,
            completed_at=m.completed_at,
            estimated_cost=m.estimated_cost,
            actual_cost=m.actual_cost,
            cost_approved=m.cost_approved,
            approval_threshold_exceeded=m.approval_threshold_exceeded,
            estimated_completion_date=m.estimated_completion_date,
            actual_completion_date=m.actual_completion_date,
            work_notes=None,
            materials_used=[],
            labor_hours=None,
            quality_checked_by=None,
            quality_check_passed=None,
            quality_check_notes=None,
            quality_checked_at=None,
            is_preventive=False,
            next_scheduled_date=None,
            recurrence="none",
        )

    # ------------------------------------------------------------------ #
    # Read operations
    # ------------------------------------------------------------------ #
    def get_maintenance(self, maintenance_id: UUID) -> MaintenanceDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            room_repo = self._get_room_repo(uow)

            m = repo.get(maintenance_id)
            if m is None:
                raise errors.NotFoundError(f"Maintenance {maintenance_id} not found")

            room_number = None
            if m.room_id:
                room = room_repo.get(m.room_id)
                room_number = room.room_number if room else None

            return self._to_detail(m, room_number=room_number)

    # ------------------------------------------------------------------ #
    # Listing
    # ------------------------------------------------------------------ #
    def list_maintenance(
        self,
        params: PaginationParams,
        filters: Optional[MaintenanceFilterParams] = None,
    ) -> PaginatedResponse[RequestListItem]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            raw_filters: dict = {}
            if filters:
                if filters.hostel_id:
                    raw_filters["hostel_id"] = filters.hostel_id
                if filters.requested_by:
                    raw_filters["requested_by_id"] = filters.requested_by
                if filters.assigned_to:
                    raw_filters["assigned_to_id"] = filters.assigned_to
                if filters.room_id:
                    raw_filters["room_id"] = filters.room_id
                if filters.category:
                    raw_filters["category"] = filters.category
                if filters.priority:
                    raw_filters["priority"] = filters.priority
                if filters.status:
                    raw_filters["status"] = filters.status
                if filters.approval_pending:
                    raw_filters["cost_approved"] = False

            records: Sequence = repo.get_multi(
                skip=params.offset,
                limit=params.limit,
                filters=raw_filters or None,
                order_by=None,
            )
            total = repo.count(filters=raw_filters or None)

            now = self._now()
            items: List[RequestListItem] = []
            room_ids = {r.room_id for r in records if getattr(r, "room_id", None)}
            room_map = {}
            if room_ids:
                room_repo = self._get_room_repo(uow)
                # naive: fetch each; for scale, implement bulk fetch
                for rid in room_ids:
                    room = room_repo.get(rid)
                    if room:
                        room_map[rid] = room.room_number

            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)
            for m in records:
                room_number = room_map.get(m.room_id) if m.room_id else None
                assigned_to_name = None
                if m.assigned_to_id:
                    sup = sup_repo.get(m.assigned_to_id)
                    if sup and getattr(sup, "user", None):
                        assigned_to_name = sup.user.full_name
                items.append(self._to_list_item(m, now=now,
                                                room_number=room_number,
                                                assigned_to_name=assigned_to_name))

            return PaginatedResponse[RequestListItem].create(
                items=items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    def search(
        self,
        params: PaginationParams,
        req: SearchRequest,
    ) -> PaginatedResponse[RequestListItem]:
        """
        Very simple search implementation (title/description/number) using in-memory filtering.
        For large data sets, replace with a dedicated query or search index.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            records: Sequence = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": req.hostel_id} if req.hostel_id else None,
            )

            q = req.query.lower()
            filtered = []
            for m in records:
                if req.search_in_title and q in (m.title or "").lower():
                    filtered.append(m)
                    continue
                if req.search_in_description and q in (m.description or "").lower():
                    filtered.append(m)
                    continue
                if req.search_in_number and q in self._request_number(m.id).lower():
                    filtered.append(m)

            total = len(filtered)
            start = params.offset
            end = start + params.limit
            page_items = filtered[start:end]

            now = self._now()
            items: List[RequestListItem] = []
            room_repo = self._get_room_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            for m in page_items:
                room_number = None
                if m.room_id:
                    room = room_repo.get(m.room_id)
                    room_number = room.room_number if room else None
                assigned_to_name = None
                if m.assigned_to_id:
                    sup = sup_repo.get(m.assigned_to_id)
                    if sup and getattr(sup, "user", None):
                        assigned_to_name = sup.user.full_name
                items.append(self._to_list_item(m, now=now,
                                                room_number=room_number,
                                                assigned_to_name=assigned_to_name))

            return PaginatedResponse[RequestListItem].create(
                items=items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    # ------------------------------------------------------------------ #
    # Create / update / status
    # ------------------------------------------------------------------ #
    def create_maintenance(self, data: MaintenanceCreate) -> MaintenanceDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            payload = data.model_dump()
            payload.setdefault("status", MaintenanceStatus.PENDING)
            m = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()
            return self.get_maintenance(m.id)

    def update_maintenance(self, maintenance_id: UUID, data: MaintenanceUpdate) -> MaintenanceDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            m = repo.get(maintenance_id)
            if m is None:
                raise errors.NotFoundError(f"Maintenance {maintenance_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(m, field) and field != "id":
                    setattr(m, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return self.get_maintenance(maintenance_id)

    def update_status(self, maintenance_id: UUID, data: MaintenanceStatusUpdate) -> MaintenanceDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            m = repo.get(maintenance_id)
            if m is None:
                raise errors.NotFoundError(f"Maintenance {maintenance_id} not found")

            new_status = data.status
            now = self._now()

            m.status = new_status  # type: ignore[attr-defined]
            if new_status == MaintenanceStatus.IN_PROGRESS and m.started_at is None:
                m.started_at = now  # type: ignore[attr-defined]
            if new_status == MaintenanceStatus.COMPLETED and m.completed_at is None:
                m.completed_at = now  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return self.get_maintenance(maintenance_id)

    # ------------------------------------------------------------------ #
    # Summary
    # ------------------------------------------------------------------ #
    def get_summary_for_hostel(self, hostel_id: UUID) -> MaintenanceSummary:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            records = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

            total = len(records)
            pending = 0
            in_progress = 0
            completed = 0
            high_priority = 0
            urgent_priority = 0
            total_estimated = 0.0
            total_actual = 0.0
            total_completion_hours = 0.0
            completed_with_time = 0

            for m in records:
                if m.status in (MaintenanceStatus.PENDING, MaintenanceStatus.APPROVED, MaintenanceStatus.ASSIGNED):
                    pending += 1
                if m.status == MaintenanceStatus.IN_PROGRESS:
                    in_progress += 1
                if m.status == MaintenanceStatus.COMPLETED:
                    completed += 1

                if m.priority == Priority.HIGH:
                    high_priority += 1
                if m.priority in (Priority.URGENT, Priority.CRITICAL):
                    urgent_priority += 1

                if m.estimated_cost:
                    total_estimated += float(m.estimated_cost)
                if m.actual_cost:
                    total_actual += float(m.actual_cost)

                if m.completed_at and m.started_at:
                    diff_hours = (m.completed_at - m.started_at).total_seconds() / 3600.0
                    total_completion_hours += diff_hours
                    completed_with_time += 1

            avg_completion = (
                total_completion_hours / completed_with_time if completed_with_time > 0 else 0.0
            )

            return MaintenanceSummary(
                hostel_id=hostel_id,
                total_requests=total,
                pending_requests=pending,
                in_progress_requests=in_progress,
                completed_requests=completed,
                high_priority_count=high_priority,
                urgent_priority_count=urgent_priority,
                total_estimated_cost=total_estimated,
                total_actual_cost=total_actual,
                average_completion_time_hours=avg_completion,
            )

# --- File: D:\hostel-management-saas\app\services\maintenance\maintenance_workflow_service.py ---
# app/services/maintenance/maintenance_workflow_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.workflows import MaintenanceWorkflowRepository
from app.services.common import UnitOfWork, errors


class MaintenanceWorkflowService:
    """
    Lightweight wrapper over wf_maintenance table.

    Tracks a single workflow row per maintenance with the current_status.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> MaintenanceWorkflowRepository:
        return uow.get_repo(MaintenanceWorkflowRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def ensure_workflow(self, maintenance_id: UUID, initial_status: str) -> None:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_maintenance_id(maintenance_id)
            if wf is None:
                payload = {
                    "maintenance_id": maintenance_id,
                    "current_status": initial_status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
                uow.commit()

    def set_status(self, maintenance_id: UUID, status: str) -> None:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_maintenance_id(maintenance_id)
            if wf is None:
                payload = {
                    "maintenance_id": maintenance_id,
                    "current_status": status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
            else:
                wf.current_status = status  # type: ignore[attr-defined]
                wf.last_updated_at = self._now()  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

# --- File: D:\hostel-management-saas\app\services\maintenance\__init__.py ---
# app/services/maintenance/__init__.py
"""
Maintenance services package.

- MaintenanceService: core CRUD, listing, status, hostel summary.
- MaintenanceAssignmentService: assign/reassign tasks to supervisors.
- MaintenanceApprovalService: cost approval with hostel-specific thresholds.
- MaintenanceCompletionService: completion details, quality checks, certificates.
- MaintenanceCostService: cost tracking, budgets, expense reports & analysis.
- MaintenanceScheduleService: preventive maintenance scheduling (store-based).
- MaintenanceAnalyticsService: basic analytics for maintenance requests.
- MaintenanceWorkflowService: wrapper over wf_maintenance table.
"""

from .maintenance_service import MaintenanceService
from .maintenance_assignment_service import MaintenanceAssignmentService
from .maintenance_approval_service import MaintenanceApprovalService
from .maintenance_completion_service import MaintenanceCompletionService
from .maintenance_cost_service import MaintenanceCostService
from .maintenance_schedule_service import MaintenanceScheduleService
from .maintenance_analytics_service import MaintenanceAnalyticsService
from .maintenance_workflow_service import MaintenanceWorkflowService

__all__ = [
    "MaintenanceService",
    "MaintenanceAssignmentService",
    "MaintenanceApprovalService",
    "MaintenanceCompletionService",
    "MaintenanceCostService",
    "MaintenanceScheduleService",
    "MaintenanceAnalyticsService",
    "MaintenanceWorkflowService",
]


# ===== Folder: D:\hostel-management-saas\app\services\mess =====

# --- File: D:\hostel-management-saas\app\services\mess\mess_feedback_service.py ---
# app/services/mess/mess_feedback_service.py
from __future__ import annotations

from collections import Counter, defaultdict
from datetime import date, datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import MessMenuRepository
from app.repositories.core import HostelRepository, StudentRepository
from app.schemas.common.enums import MealType
from app.schemas.common.filters import DateRangeFilter
from app.schemas.mess.menu_feedback import (
    FeedbackRequest,
    FeedbackResponse,
    RatingsSummary,
    QualityMetrics,
    ItemRating,
    FeedbackAnalysis,
)
from app.services.common import UnitOfWork, errors


class MessFeedbackStore(Protocol):
    """
    Abstract storage for mess menu feedback.

    Implementations can use a dedicated DB table, Redis, or another store.

    Expected record shape (example):

        {
            "menu_id": UUID,
            "hostel_id": UUID,
            "menu_date": date,
            "student_id": UUID,
            "student_name": str,
            "meal_type": "BREAKFAST" | "LUNCH" | ...,
            "rating": int,
            "comments": str | None,
            "taste_rating": int | None,
            "quantity_rating": int | None,
            "quality_rating": int | None,
            "hygiene_rating": int | None,
            "submitted_at": datetime,
        }
    """

    def save_feedback(self, record: dict) -> None: ...
    def list_feedback_for_menu(self, menu_id: UUID) -> List[dict]: ...
    def list_feedback_for_hostel(
        self,
        hostel_id: UUID,
        *,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
    ) -> List[dict]: ...


class MessFeedbackService:
    """
    Mess menu feedback service:

    - Submit feedback for a menu/meal
    - Compute RatingsSummary per menu
    - Compute QualityMetrics / FeedbackAnalysis per hostel & period
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: MessFeedbackStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_menu_repo(self, uow: UnitOfWork) -> MessMenuRepository:
        return uow.get_repo(MessMenuRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Submit feedback
    # ------------------------------------------------------------------ #
    def submit_feedback(self, data: FeedbackRequest) -> FeedbackResponse:
        """
        Persist feedback for a given menu and student.
        """
        with UnitOfWork(self._session_factory) as uow:
            menu_repo = self._get_menu_repo(uow)
            student_repo = self._get_student_repo(uow)

            menu = menu_repo.get(data.menu_id)
            if menu is None:
                raise errors.NotFoundError(f"MessMenu {data.menu_id} not found")

            student = student_repo.get(data.student_id)
            if student is None or not getattr(student, "user", None):
                raise errors.NotFoundError(f"Student {data.student_id} not found")
            student_name = student.user.full_name

        submitted_at = self._now()

        record = {
            "menu_id": data.menu_id,
            "hostel_id": menu.hostel_id,
            "menu_date": menu.menu_date,
            "student_id": data.student_id,
            "student_name": student_name,
            "meal_type": data.meal_type.value
            if hasattr(data.meal_type, "value")
            else str(data.meal_type),
            "rating": data.rating,
            "comments": data.comments,
            "taste_rating": data.taste_rating,
            "quantity_rating": data.quantity_rating,
            "quality_rating": data.quality_rating,
            "hygiene_rating": data.hygiene_rating,
            "submitted_at": submitted_at,
        }
        self._store.save_feedback(record)

        return FeedbackResponse(
            id=None,
            created_at=submitted_at,
            updated_at=submitted_at,
            menu_id=data.menu_id,
            student_id=data.student_id,
            student_name=student_name,
            meal_type=data.meal_type,
            rating=data.rating,
            comments=data.comments,
            submitted_at=submitted_at,
        )

    # ------------------------------------------------------------------ #
    # Ratings per menu
    # ------------------------------------------------------------------ #
    def get_ratings_summary(self, menu_id: UUID) -> RatingsSummary:
        """
        Aggregate feedback for a single menu.
        """
        with UnitOfWork(self._session_factory) as uow:
            menu_repo = self._get_menu_repo(uow)

            menu = menu_repo.get(menu_id)
            if menu is None:
                raise errors.NotFoundError(f"MessMenu {menu_id} not found")

        records = self._store.list_feedback_for_menu(menu_id)

        total = len(records)
        if total == 0:
            return RatingsSummary(
                menu_id=menu_id,
                menu_date=menu.menu_date,
                total_feedbacks=0,
                average_rating=Decimal("0"),
                breakfast_rating=None,
                lunch_rating=None,
                snacks_rating=None,
                dinner_rating=None,
                rating_5_count=0,
                rating_4_count=0,
                rating_3_count=0,
                rating_2_count=0,
                rating_1_count=0,
                average_taste_rating=Decimal("0"),
                average_quantity_rating=Decimal("0"),
                average_quality_rating=Decimal("0"),
                average_hygiene_rating=Decimal("0"),
            )

        ratings_by_meal: Dict[str, List[int]] = defaultdict(list)
        rating_counts = {i: 0 for i in range(1, 6)}

        taste_vals: List[int] = []
        qty_vals: List[int] = []
        qual_vals: List[int] = []
        hyg_vals: List[int] = []

        for r in records:
            rating = int(r.get("rating", 0))
            if 1 <= rating <= 5:
                rating_counts[rating] += 1
            meal = str(r.get("meal_type", "")).lower()
            ratings_by_meal[meal].append(rating)

            if r.get("taste_rating") is not None:
                taste_vals.append(int(r["taste_rating"]))
            if r.get("quantity_rating") is not None:
                qty_vals.append(int(r["quantity_rating"]))
            if r.get("quality_rating") is not None:
                qual_vals.append(int(r["quality_rating"]))
            if r.get("hygiene_rating") is not None:
                hyg_vals.append(int(r["hygiene_rating"]))

        def _avg(vals: List[int]) -> Decimal:
            return (
                Decimal(str(sum(vals))) / Decimal(str(len(vals)))
                if vals
                else Decimal("0")
            )

        all_ratings = [int(r.get("rating", 0)) for r in records if r.get("rating")]
        avg_overall = _avg(all_ratings)

        def _meal_avg(key: str) -> Optional[Decimal]:
            vals = ratings_by_meal.get(key, [])
            return _avg(vals) if vals else None

        return RatingsSummary(
            menu_id=menu_id,
            menu_date=menu.menu_date,
            total_feedbacks=total,
            average_rating=avg_overall,
            breakfast_rating=_meal_avg("breakfast"),
            lunch_rating=_meal_avg("lunch"),
            snacks_rating=_meal_avg("snacks"),
            dinner_rating=_meal_avg("dinner"),
            rating_5_count=rating_counts[5],
            rating_4_count=rating_counts[4],
            rating_3_count=rating_counts[3],
            rating_2_count=rating_counts[2],
            rating_1_count=rating_counts[1],
            average_taste_rating=_avg(taste_vals),
            average_quantity_rating=_avg(qty_vals),
            average_quality_rating=_avg(qual_vals),
            average_hygiene_rating=_avg(hyg_vals),
        )

    # ------------------------------------------------------------------ #
    # Quality metrics per hostel
    # ------------------------------------------------------------------ #
    def get_quality_metrics(
        self,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> QualityMetrics:
        """
        Compute QualityMetrics for a hostel over a period.
        """
        if not (period.start_date and period.end_date):
            raise errors.ValidationError(
                "Both start_date and end_date are required for quality metrics"
            )

        start = period.start_date
        end = period.end_date

        records = self._store.list_feedback_for_hostel(
            hostel_id, start_date=start, end_date=end
        )

        total_feedbacks = len(records)
        if total_feedbacks == 0:
            return QualityMetrics(
                hostel_id=hostel_id,
                period_start=start,
                period_end=end,
                overall_average_rating=Decimal("0"),
                total_feedbacks=0,
                rating_trend="stable",
                trend_percentage=None,
                best_rated_items=[],
                worst_rated_items=[],
                ratings_by_day={},
            )

        # Overall average
        ratings = [int(r["rating"]) for r in records if r.get("rating") is not None]
        overall_avg = (
            Decimal(str(sum(ratings))) / Decimal(str(len(ratings)))
            if ratings
            else Decimal("0")
        )

        # Trend: compare first half vs second half of period
        mid_point = start + (end - start) / 2
        first_half = [
            int(r["rating"])
            for r in records
            if r.get("submitted_at") and r["submitted_at"].date() <= mid_point
        ]
        second_half = [
            int(r["rating"])
            for r in records
            if r.get("submitted_at") and r["submitted_at"].date() > mid_point
        ]

        def _avg_int(vals: List[int]) -> Decimal:
            return (
                Decimal(str(sum(vals))) / Decimal(str(len(vals)))
                if vals
                else Decimal("0")
            )

        avg_first = _avg_int(first_half)
        avg_second = _avg_int(second_half)

        if avg_first > 0:
            change = (avg_second - avg_first) / avg_first * Decimal("100")
            if change > Decimal("5"):
                trend = "improving"
            elif change < Decimal("-5"):
                trend = "declining"
            else:
                trend = "stable"
            trend_pct = change
        else:
            trend = "stable"
            trend_pct = None

        # Best / worst items – schema suggests per-item ratings, but we do not
        # collect per-item feedback in this codebase. Leave empty lists.
        best_items: List[ItemRating] = []
        worst_items: List[ItemRating] = []

        # Ratings by day-of-week
        by_day: Dict[str, List[int]] = defaultdict(list)
        for r in records:
            d = r.get("menu_date") or (
                r["submitted_at"].date() if r.get("submitted_at") else None
            )
            if not isinstance(d, date):
                continue
            day_name = d.strftime("%A")
            if r.get("rating") is not None:
                by_day[day_name].append(int(r["rating"]))

        ratings_by_day: Dict[str, Decimal] = {
            day: _avg_int(vals) for day, vals in by_day.items()
        }

        return QualityMetrics(
            hostel_id=hostel_id,
            period_start=start,
            period_end=end,
            overall_average_rating=overall_avg,
            total_feedbacks=total_feedbacks,
            rating_trend=trend,
            trend_percentage=trend_pct,
            best_rated_items=best_items,
            worst_rated_items=worst_items,
            ratings_by_day=ratings_by_day,
        )

    # ------------------------------------------------------------------ #
    # Deeper analysis (simple heuristic)
    # ------------------------------------------------------------------ #
    def get_feedback_analysis(
        self,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> FeedbackAnalysis:
        """
        Very simple feedback analysis using ratings and comments.
        """
        if not (period.start_date and period.end_date):
            raise errors.ValidationError(
                "Both start_date and end_date are required for feedback analysis"
            )

        start = period.start_date
        end = period.end_date

        records = self._store.list_feedback_for_hostel(
            hostel_id, start_date=start, end_date=end
        )

        total = len(records)
        if total == 0:
            return FeedbackAnalysis(
                hostel_id=hostel_id,
                analysis_period=period,
                positive_feedback_percentage=Decimal("0"),
                negative_feedback_percentage=Decimal("0"),
                common_complaints=[],
                common_compliments=[],
                items_to_keep=[],
                items_to_improve=[],
                items_to_remove=[],
            )

        pos = neg = 0
        positive_comments: List[str] = []
        negative_comments: List[str] = []

        for r in records:
            rating = int(r.get("rating", 0))
            comment = (r.get("comments") or "").strip()
            if rating >= 4:
                pos += 1
                if comment:
                    positive_comments.append(comment)
            elif rating <= 2:
                neg += 1
                if comment:
                    negative_comments.append(comment)

        positive_pct = (
            Decimal(str(pos)) / Decimal(str(total)) * Decimal("100")
            if total > 0
            else Decimal("0")
        )
        negative_pct = (
            Decimal(str(neg)) / Decimal(str(total)) * Decimal("100")
            if total > 0
            else Decimal("0")
        )

        def _top_strings(items: List[str], limit: int = 5) -> List[str]:
            if not items:
                return []
            counts = Counter(items)
            return [s for s, _ in counts.most_common(limit)]

        common_complaints = _top_strings(negative_comments)
        common_compliments = _top_strings(positive_comments)

        # Without per-item feedback, we cannot reliably recommend items to keep/improve/remove.
        return FeedbackAnalysis(
            hostel_id=hostel_id,
            analysis_period=period,
            positive_feedback_percentage=positive_pct,
            negative_feedback_percentage=negative_pct,
            common_complaints=common_complaints,
            common_compliments=common_compliments,
            items_to_keep=[],
            items_to_improve=[],
            items_to_remove=[],
        )

# --- File: D:\hostel-management-saas\app\services\mess\mess_menu_planning_service.py ---
# app/services/mess/mess_menu_planning_service.py
from __future__ import annotations

from datetime import date, timedelta
from typing import Callable, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import MessMenuRepository
from app.repositories.core import HostelRepository
from app.schemas.common.base import BaseSchema  # only for typing hints if needed
from app.schemas.mess.menu_duplication import (
    DuplicateMenuRequest,
    BulkMenuCreate,
    DuplicateResponse,
)
from app.services.common import UnitOfWork, errors


class MessMenuPlanningService:
    """
    Menu planning & duplication helpers:

    - Duplicate a single menu to another date
    - Bulk-create menus for a date range using an existing menu or pattern
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_menu_repo(self, uow: UnitOfWork) -> MessMenuRepository:
        return uow.get_repo(MessMenuRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    # ------------------------------------------------------------------ #
    # Single duplication
    # ------------------------------------------------------------------ #
    def duplicate_menu(self, req: DuplicateMenuRequest) -> DuplicateResponse:
        """
        Duplicate a single menu to a target_date.

        - If a menu already exists on target_date for that hostel,
          raises ConflictError (no override here).
        - If `modifications` is provided, it should be a partial dict of
          MessMenu fields (e.g. breakfast_items, lunch_items, etc.).
        """
        with UnitOfWork(self._session_factory) as uow:
            menu_repo = self._get_menu_repo(uow)

            src = menu_repo.get(req.source_menu_id)
            if src is None:
                raise errors.NotFoundError(f"MessMenu {req.source_menu_id} not found")

            existing = menu_repo.get_for_date(src.hostel_id, req.target_date)
            if existing:
                raise errors.ConflictError(
                    f"Menu already exists for {req.target_date} at this hostel"
                )

            payload = {
                "hostel_id": src.hostel_id,
                "menu_date": req.target_date,
                "day_of_week": req.target_date.strftime("%A"),
                "breakfast_items": list(src.breakfast_items or []),
                "lunch_items": list(src.lunch_items or []),
                "snacks_items": list(src.snacks_items or []),
                "dinner_items": list(src.dinner_items or []),
                "breakfast_time": src.breakfast_time,
                "lunch_time": src.lunch_time,
                "snacks_time": src.snacks_time,
                "dinner_time": src.dinner_time,
                "is_special_menu": src.is_special_menu,
                "special_occasion": src.special_occasion,
                "vegetarian_available": src.vegetarian_available,
                "non_vegetarian_available": src.non_vegetarian_available,
                "vegan_available": src.vegan_available,
                "jain_available": src.jain_available,
            }

            if req.modify_items and req.modifications:
                for field, value in req.modifications.items():
                    if field in payload:
                        payload[field] = value

            created = menu_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            return DuplicateResponse(
                source_menu_id=req.source_menu_id,
                created_menus=[created.id],
                total_created=1,
                skipped=0,
                message="Menu duplicated successfully",
            )

    # ------------------------------------------------------------------ #
    # Bulk creation
    # ------------------------------------------------------------------ #
    def bulk_create_menus(self, req: BulkMenuCreate) -> DuplicateResponse:
        """
        Create menus for a date range based on a source menu or weekly pattern.

        Supported source_type values:
        - 'existing_menu': use `source_menu_id` as template.
        - 'weekly_pattern': use `weekly_pattern` dict:
              { "monday": {...}, "tuesday": {...}, ... }
          where each value is a partial MessMenu payload, e.g.:
              {
                  "breakfast_items": [...],
                  "lunch_items": [...],
                  "snacks_items": [...],
                  "dinner_items": [...]
              }

        NOTE:
        - 'template' source_type is not implemented in this skeleton
          (no MenuTemplate persistence defined yet).
        """
        if req.start_date > req.end_date:
            raise errors.ValidationError("start_date must be <= end_date")

        with UnitOfWork(self._session_factory) as uow:
            menu_repo = self._get_menu_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(req.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {req.hostel_id} not found")

            source_menu = None
            if req.source_type == "existing_menu":
                if not req.source_menu_id:
                    raise errors.ValidationError(
                        "source_menu_id is required when source_type='existing_menu'"
                    )
                source_menu = menu_repo.get(req.source_menu_id)
                if source_menu is None:
                    raise errors.NotFoundError(
                        f"Source menu {req.source_menu_id} not found"
                    )

            if req.source_type == "template":
                # No MenuTemplate model defined in this codebase; stub.
                raise errors.ServiceError(
                    "Template-based bulk menu creation is not implemented"
                )

            created_ids: List[UUID] = []
            skipped = 0

            cur = req.start_date
            while cur <= req.end_date:
                existing = menu_repo.get_for_date(req.hostel_id, cur)
                if existing:
                    if req.override_existing:
                        # We'll override the first existing record.
                        target = existing[0]
                        self._apply_source_to_menu(
                            target,
                            source_type=req.source_type,
                            source_menu=source_menu,
                            weekly_pattern=req.weekly_pattern,
                            target_date=cur,
                        )
                        uow.session.flush()  # type: ignore[union-attr]
                        created_ids.append(target.id)
                    elif req.skip_existing:
                        skipped += 1
                    else:
                        # Neither override nor skip -> conflict
                        raise errors.ConflictError(
                            f"Menu already exists for {cur}; "
                            "set skip_existing or override_existing."
                        )
                else:
                    payload = self._build_payload_from_source(
                        hostel_id=req.hostel_id,
                        source_type=req.source_type,
                        source_menu=source_menu,
                        weekly_pattern=req.weekly_pattern,
                        target_date=cur,
                    )
                    if payload is None:
                        skipped += 1
                    else:
                        created = menu_repo.create(payload)  # type: ignore[arg-type]
                        created_ids.append(created.id)

                cur += timedelta(days=1)

            uow.commit()

        return DuplicateResponse(
            source_menu_id=req.source_menu_id or UUID(int=0),
            created_menus=created_ids,
            total_created=len(created_ids),
            skipped=skipped,
            message="Bulk menu creation completed",
        )

    # ------------------------------------------------------------------ #
    # Internal helpers
    # ------------------------------------------------------------------ #
    def _build_payload_from_source(
        self,
        *,
        hostel_id: UUID,
        source_type: str,
        source_menu,
        weekly_pattern: dict | None,
        target_date: date,
    ) -> dict | None:
        """
        Construct a new MessMenu payload based on the given source type.
        Returns None if no data is available for the given day (for patterns).
        """
        base = {
            "hostel_id": hostel_id,
            "menu_date": target_date,
            "day_of_week": target_date.strftime("%A"),
        }

        if source_type == "existing_menu":
            if source_menu is None:
                return None
            base.update(
                {
                    "breakfast_items": list(source_menu.breakfast_items or []),
                    "lunch_items": list(source_menu.lunch_items or []),
                    "snacks_items": list(source_menu.snacks_items or []),
                    "dinner_items": list(source_menu.dinner_items or []),
                    "breakfast_time": source_menu.breakfast_time,
                    "lunch_time": source_menu.lunch_time,
                    "snacks_time": source_menu.snacks_time,
                    "dinner_time": source_menu.dinner_time,
                    "is_special_menu": source_menu.is_special_menu,
                    "special_occasion": source_menu.special_occasion,
                    "vegetarian_available": source_menu.vegetarian_available,
                    "non_vegetarian_available": source_menu.non_vegetarian_available,
                    "vegan_available": source_menu.vegan_available,
                    "jain_available": source_menu.jain_available,
                }
            )
            return base

        if source_type == "weekly_pattern":
            if not weekly_pattern:
                return None
            key = target_date.strftime("%A").lower()
            day_conf = weekly_pattern.get(key)
            if not day_conf:
                return None
            # day_conf is expected to be a partial menu dict.
            base.update(day_conf)
            return base

        # Unknown type
        return None

    def _apply_source_to_menu(
        self,
        menu_obj,
        *,
        source_type: str,
        source_menu,
        weekly_pattern: dict | None,
        target_date: date,
    ) -> None:
        """
        Apply source data to an existing MessMenu instance (for overrides).
        """
        if source_type == "existing_menu" and source_menu is not None:
            menu_obj.menu_date = target_date
            menu_obj.day_of_week = target_date.strftime("%A")
            menu_obj.breakfast_items = list(source_menu.breakfast_items or [])
            menu_obj.lunch_items = list(source_menu.lunch_items or [])
            menu_obj.snacks_items = list(source_menu.snacks_items or [])
            menu_obj.dinner_items = list(source_menu.dinner_items or [])
            menu_obj.breakfast_time = source_menu.breakfast_time
            menu_obj.lunch_time = source_menu.lunch_time
            menu_obj.snacks_time = source_menu.snacks_time
            menu_obj.dinner_time = source_menu.dinner_time
            menu_obj.is_special_menu = source_menu.is_special_menu
            menu_obj.special_occasion = source_menu.special_occasion
            menu_obj.vegetarian_available = source_menu.vegetarian_available
            menu_obj.non_vegetarian_available = source_menu.non_vegetarian_available
            menu_obj.vegan_available = source_menu.vegan_available
            menu_obj.jain_available = source_menu.jain_available
            return

        if source_type == "weekly_pattern" and weekly_pattern:
            key = target_date.strftime("%A").lower()
            day_conf = weekly_pattern.get(key)
            if not day_conf:
                return
            menu_obj.menu_date = target_date
            menu_obj.day_of_week = target_date.strftime("%A")
            for field, value in day_conf.items():
                if hasattr(menu_obj, field):
                    setattr(menu_obj, field, value)

# --- File: D:\hostel-management-saas\app\services\mess\mess_menu_service.py ---
# app/services/mess/mess_menu_service.py
from __future__ import annotations

from calendar import monthrange
from datetime import date
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import MessMenuRepository
from app.repositories.core import HostelRepository
from app.schemas.common.filters import DateRangeFilter
from app.schemas.mess import (
    MessMenuCreate,
    MessMenuUpdate,
    MenuResponse,
    MenuDetail,
    WeeklyMenu,
    MonthlyMenu,
)
from app.schemas.mess.mess_menu_response import DailyMenuSummary, TodayMenu
from app.services.common import UnitOfWork, errors


class MessMenuService:
    """
    Core Mess Menu service:

    - Create / update menus
    - Get single menu detail
    - Get menu for a specific date (Today view)
    - Weekly and monthly calendar-style views
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_menu_repo(self, uow: UnitOfWork) -> MessMenuRepository:
        return uow.get_repo(MessMenuRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_menu_response(self, m, *, hostel_name: str) -> MenuResponse:
        """
        Lightweight summary used in list views.
        """
        average_rating = getattr(m, "average_rating", None)
        if average_rating is None:
            average_rating = Decimal("0")

        is_published = bool(getattr(m, "is_published", True))

        return MenuResponse(
            id=m.id,
            created_at=m.created_at,
            updated_at=m.updated_at,
            hostel_id=m.hostel_id,
            hostel_name=hostel_name,
            menu_date=m.menu_date,
            day_of_week=m.day_of_week,
            breakfast_items=m.breakfast_items or [],
            lunch_items=m.lunch_items or [],
            snacks_items=m.snacks_items or [],
            dinner_items=m.dinner_items or [],
            is_special_menu=m.is_special_menu,
            special_occasion=m.special_occasion,
            is_published=is_published,
            average_rating=average_rating,
        )

    def _to_detail(self, m, *, hostel_name: str) -> MenuDetail:
        """
        Full detail view for a menu.

        NOTE:
        - Some metadata (created_by, approved_by, ratings) are not present
          on the MessMenu model in this codebase; we provide safe defaults.
        """
        from datetime import datetime

        created_by_id = getattr(m, "created_by_id", None) or UUID(int=0)
        created_by_name = getattr(m, "created_by_name", "") or ""

        approved_by = getattr(m, "approved_by_id", None)
        approved_by_name = getattr(m, "approved_by_name", None)
        approved_at = getattr(m, "approved_at", None)
        if approved_at is not None and not isinstance(approved_at, datetime):
            approved_at = None

        is_published = bool(getattr(m, "is_published", True))
        published_at = getattr(m, "published_at", None)
        if published_at is not None and not isinstance(published_at, datetime):
            published_at = None

        average_rating = getattr(m, "average_rating", None)
        if average_rating is None:
            average_rating = Decimal("0")
        total_feedback_count = getattr(m, "total_feedback_count", None) or 0

        return MenuDetail(
            id=m.id,
            created_at=m.created_at,
            updated_at=m.updated_at,
            hostel_id=m.hostel_id,
            hostel_name=hostel_name,
            menu_date=m.menu_date,
            day_of_week=m.day_of_week,
            breakfast_items=m.breakfast_items or [],
            breakfast_time=m.breakfast_time,
            lunch_items=m.lunch_items or [],
            lunch_time=m.lunch_time,
            snacks_items=m.snacks_items or [],
            snacks_time=m.snacks_time,
            dinner_items=m.dinner_items or [],
            dinner_time=m.dinner_time,
            vegetarian_available=m.vegetarian_available,
            non_vegetarian_available=m.non_vegetarian_available,
            vegan_available=m.vegan_available,
            jain_available=m.jain_available,
            is_special_menu=m.is_special_menu,
            special_occasion=m.special_occasion,
            created_by=created_by_id,
            created_by_name=created_by_name,
            approved_by=approved_by,
            approved_by_name=approved_by_name,
            approved_at=approved_at,
            is_published=is_published,
            published_at=published_at,
            average_rating=average_rating,
            total_feedback_count=total_feedback_count,
        )

    # ------------------------------------------------------------------ #
    # Core CRUD
    # ------------------------------------------------------------------ #
    def create_menu(self, data: MessMenuCreate) -> MenuDetail:
        """
        Create a new mess menu for a hostel.
        """
        with UnitOfWork(self._session_factory) as uow:
            menu_repo = self._get_menu_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            payload = {
                "hostel_id": data.hostel_id,
                "menu_date": data.menu_date,
                "day_of_week": data.day_of_week,
                "breakfast_items": data.breakfast_items or [],
                "lunch_items": data.lunch_items or [],
                "snacks_items": data.snacks_items or [],
                "dinner_items": data.dinner_items or [],
                "breakfast_time": data.breakfast_time,
                "lunch_time": data.lunch_time,
                "snacks_time": data.snacks_time,
                "dinner_time": data.dinner_time,
                "is_special_menu": data.is_special_menu,
                "special_occasion": data.special_occasion,
                "vegetarian_available": data.vegetarian_available,
                "non_vegetarian_available": data.non_vegetarian_available,
                "vegan_available": data.vegan_available,
                "jain_available": data.jain_available,
            }
            m = menu_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            return self._to_detail(m, hostel_name=hostel.name)

    def update_menu(self, menu_id: UUID, data: MessMenuUpdate) -> MenuDetail:
        """
        Update an existing mess menu (mutable fields only).
        """
        with UnitOfWork(self._session_factory) as uow:
            menu_repo = self._get_menu_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            m = menu_repo.get(menu_id)
            if m is None:
                raise errors.NotFoundError(f"MessMenu {menu_id} not found")

            update_data = data.model_dump(exclude_unset=True)
            for field, value in update_data.items():
                if hasattr(m, field):
                    setattr(m, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            hostel = hostel_repo.get(m.hostel_id)
            hostel_name = hostel.name if hostel else ""
            return self._to_detail(m, hostel_name=hostel_name)

    def get_menu(self, menu_id: UUID) -> MenuDetail:
        """
        Fetch a single menu by ID.
        """
        with UnitOfWork(self._session_factory) as uow:
            menu_repo = self._get_menu_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            m = menu_repo.get(menu_id)
            if m is None:
                raise errors.NotFoundError(f"MessMenu {menu_id} not found")

            hostel = hostel_repo.get(m.hostel_id)
            hostel_name = hostel.name if hostel else ""
            return self._to_detail(m, hostel_name=hostel_name)

    # ------------------------------------------------------------------ #
    # Date-based access
    # ------------------------------------------------------------------ #
    def get_menu_for_date(self, hostel_id: UUID, menu_date: date) -> MenuDetail:
        """
        Fetch the menu (if any) for a given hostel and date.
        """
        with UnitOfWork(self._session_factory) as uow:
            menu_repo = self._get_menu_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            menus = menu_repo.get_for_date(hostel_id, menu_date)
            if not menus:
                raise errors.NotFoundError(
                    f"No mess menu found for hostel {hostel_id} on {menu_date}"
                )
            m = menus[0]

            hostel = hostel_repo.get(hostel_id)
            hostel_name = hostel.name if hostel else ""
            return self._to_detail(m, hostel_name=hostel_name)

    def get_today_menu(self, hostel_id: UUID, day: Optional[date] = None) -> TodayMenu:
        """
        Return a TodayMenu view for the given hostel and date (default: today).
        """
        from datetime import date as _date

        target_date = day or _date.today()
        detail = self.get_menu_for_date(hostel_id, target_date)

        def _fmt_time(t) -> str:
            return t.strftime("%H:%M") if t else ""

        return TodayMenu(
            hostel_id=detail.hostel_id,
            hostel_name=detail.hostel_name,
            date=detail.menu_date,
            day_of_week=detail.day_of_week,
            breakfast=detail.breakfast_items,
            breakfast_time=_fmt_time(detail.breakfast_time),
            lunch=detail.lunch_items,
            lunch_time=_fmt_time(detail.lunch_time),
            snacks=detail.snacks_items,
            snacks_time=_fmt_time(detail.snacks_time),
            dinner=detail.dinner_items,
            dinner_time=_fmt_time(detail.dinner_time),
            is_special=detail.is_special_menu,
            special_occasion=detail.special_occasion,
            dietary_note=None,
        )

    # ------------------------------------------------------------------ #
    # Weekly / monthly calendars
    # ------------------------------------------------------------------ #
    def get_weekly_menu(
        self,
        hostel_id: UUID,
        week_start_date: date,
    ) -> WeeklyMenu:
        """
        Build a WeeklyMenu for [week_start_date, week_start_date+6].
        """
        week_end_date = week_start_date + timedelta(days=6)  # type: ignore[name-defined]

        from datetime import timedelta  # local import to avoid top-of-file clutter

        with UnitOfWork(self._session_factory) as uow:
            menu_repo = self._get_menu_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            menus = menu_repo.get_range(hostel_id, week_start_date, week_end_date)

        summaries: List[DailyMenuSummary] = []
        for m in sorted(menus, key=lambda x: x.menu_date):
            summaries.append(
                DailyMenuSummary(
                    menu_id=m.id,
                    date=m.menu_date,
                    day_of_week=m.day_of_week,
                    breakfast=m.breakfast_items or [],
                    lunch=m.lunch_items or [],
                    dinner=m.dinner_items or [],
                    is_special=m.is_special_menu,
                    average_rating=None,  # can be filled via feedback analytics
                )
            )

        return WeeklyMenu(
            hostel_id=hostel_id,
            hostel_name=hostel.name,
            week_start_date=week_start_date,
            week_end_date=week_end_date,
            menus=summaries,
        )

    def get_monthly_menu(self, hostel_id: UUID, month: str) -> MonthlyMenu:
        """
        Build a MonthlyMenu calendar for the given month (YYYY-MM).
        """
        try:
            year, m = map(int, month.split("-"))
        except ValueError:
            raise errors.ValidationError("month must be in 'YYYY-MM' format")

        start = date(year, m, 1)
        end = date(year, m, monthrange(year, m)[1])

        with UnitOfWork(self._session_factory) as uow:
            menu_repo = self._get_menu_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            menus = menu_repo.get_range(hostel_id, start, end)

        menus_by_date: Dict[str, DailyMenuSummary] = {}
        total_rating = Decimal("0")
        rating_count = 0
        special_days = 0

        for m in menus:
            key = m.menu_date.isoformat()
            avg_rating: Optional[Decimal] = getattr(m, "average_rating", None)
            if avg_rating is not None:
                total_rating += avg_rating
                rating_count += 1
            if m.is_special_menu:
                special_days += 1

            menus_by_date[key] = DailyMenuSummary(
                menu_id=m.id,
                date=m.menu_date,
                day_of_week=m.day_of_week,
                breakfast=m.breakfast_items or [],
                lunch=m.lunch_items or [],
                dinner=m.dinner_items or [],
                is_special=m.is_special_menu,
                average_rating=avg_rating,
            )

        total_days = len(menus_by_date)
        average_rating = (
            total_rating / Decimal(str(rating_count)) if rating_count > 0 else Decimal("0")
        )

        return MonthlyMenu(
            hostel_id=hostel_id,
            hostel_name=hostel.name,
            month=month,
            menus_by_date=menus_by_date,
            total_days=total_days,
            special_days=special_days,
            average_rating=average_rating,
        )

# --- File: D:\hostel-management-saas\app\services\mess\__init__.py ---
# app/services/mess/__init__.py
"""
Mess / dining-related services.

- MessMenuService: CRUD, retrieval, and calendar views for mess menus.
- MessMenuPlanningService: bulk creation, duplication, and planning helpers.
- MessFeedbackService: feedback capture and rating/quality analytics.
"""

from .mess_menu_service import MessMenuService
from .mess_menu_planning_service import MessMenuPlanningService
from .mess_feedback_service import MessFeedbackService, MessFeedbackStore

__all__ = [
    "MessMenuService",
    "MessMenuPlanningService",
    "MessFeedbackService",
    "MessFeedbackStore",
]


# ===== Folder: D:\hostel-management-saas\app\services\notice =====

# --- File: D:\hostel-management-saas\app\services\notice\notice_service.py ---
# app/services/notice/notice_service.py
from __future__ import annotations

from datetime import datetime, date, timezone
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import NoticeRepository
from app.repositories.core import HostelRepository
from app.schemas.common.enums import TargetAudience
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.notice.notice_base import (
    NoticeCreate,
    NoticeUpdate,
)
from app.schemas.notice.notice_filters import (
    NoticeFilterParams,
)
from app.schemas.notice.notice_response import (
    NoticeResponse,
    NoticeDetail,
    NoticeList,
    NoticeListItem,
)
from app.services.common import UnitOfWork, errors


class NoticeService:
    """
    Core Notice service:

    - Create / update notices
    - Retrieve single notice detail
    - List & search notices (with filters)
    - List active notices for hostel / system-wide
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_notice_repo(self, uow: UnitOfWork) -> NoticeRepository:
        return uow.get_repo(NoticeRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_response(
        self,
        n,
        *,
        hostel_name: str,
    ) -> NoticeResponse:
        return NoticeResponse(
            id=n.id,
            created_at=n.created_at,
            updated_at=n.updated_at,
            hostel_id=n.hostel_id,
            hostel_name=hostel_name,
            title=n.notice_title,
            content=n.notice_content,
            category=n.category,
            target_audience=n.target_audience,
            priority=n.priority,
            is_urgent=n.is_urgent,
            published_at=n.published_at,
            expires_at=n.expires_at,
        )

    def _to_detail(
        self,
        n,
        *,
        hostel_name: str,
    ) -> NoticeDetail:
        return NoticeDetail(
            id=n.id,
            created_at=n.created_at,
            updated_at=n.updated_at,
            hostel_id=n.hostel_id,
            hostel_name=hostel_name,
            title=n.notice_title,
            content=n.notice_content,
            category=n.category,
            target_audience=n.target_audience,
            priority=n.priority,
            is_urgent=n.is_urgent,
            published_at=n.published_at,
            expires_at=n.expires_at,
            is_active=(
                n.published_at is not None
                and (n.expires_at is None or n.expires_at > self._now())
            ),
        )

    def _to_list_item(self, n) -> NoticeListItem:
        return NoticeListItem(
            id=n.id,
            title=n.notice_title,
            category=n.category,
            priority=n.priority,
            is_urgent=n.is_urgent,
            published_at=n.published_at,
            expires_at=n.expires_at,
        )

    # ------------------------------------------------------------------ #
    # Read operations
    # ------------------------------------------------------------------ #
    def get_notice(self, notice_id: UUID) -> NoticeDetail:
        """
        Fetch a single notice with full detail.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_notice_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            n = repo.get(notice_id)
            if n is None:
                raise errors.NotFoundError(f"Notice {notice_id} not found")

            hostel_name = ""
            if n.hostel_id:
                hostel = hostel_repo.get(n.hostel_id)
                hostel_name = hostel.name if hostel else ""

            return self._to_detail(n, hostel_name=hostel_name)

    def list_active_notices(
        self,
        *,
        hostel_id: Optional[UUID] = None,
        audience: Optional[TargetAudience] = None,
    ) -> List[NoticeResponse]:
        """
        List currently active notices (published & not expired).

        - If hostel_id is None, includes system-wide notices.
        - If audience is provided, filter by target_audience.
        """
        now = self._now()

        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_notice_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            notices = repo.list_active_notices(
                hostel_id=hostel_id,
                audience=audience,
                now=now,
            )

            hostel_cache: Dict[UUID, str] = {}
            responses: List[NoticeResponse] = []

            for n in notices:
                hostel_name = ""
                if n.hostel_id:
                    if n.hostel_id not in hostel_cache:
                        h = hostel_repo.get(n.hostel_id)
                        hostel_cache[n.hostel_id] = h.name if h else ""
                    hostel_name = hostel_cache[n.hostel_id]
                responses.append(self._to_response(n, hostel_name=hostel_name))

            return responses

    def list_notices(
        self,
        params: PaginationParams,
        filters: Optional[NoticeFilterParams] = None,
    ) -> PaginatedResponse[NoticeListItem]:
        """
        Paginated listing of notices with filter support (admin/system view).
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_notice_repo(uow)

            raw_filters: Dict[str, object] = {}
            if filters:
                if filters.hostel_id:
                    raw_filters["hostel_id"] = filters.hostel_id
                if filters.category:
                    raw_filters["category"] = filters.category
                if filters.priority:
                    raw_filters["priority"] = filters.priority
                if filters.target_audience:
                    raw_filters["target_audience"] = filters.target_audience
                if filters.is_urgent is not None:
                    raw_filters["is_urgent"] = filters.is_urgent

            records: Sequence = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=raw_filters or None,
            )

            def _matches_advanced(n) -> bool:
                if not filters:
                    return True

                # Text search
                if filters.search:
                    q = filters.search.lower()
                    text = f"{n.notice_title or ''} {n.notice_content or ''}".lower()
                    if q not in text:
                        return False

                # Published date range
                if filters.published_date_from or filters.published_date_to:
                    if not n.published_at:
                        return False
                    d = n.published_at.date()
                    if filters.published_date_from and d < filters.published_date_from:
                        return False
                    if filters.published_date_to and d > filters.published_date_to:
                        return False

                # Created date range
                if filters.created_date_from or filters.created_date_to:
                    d = n.created_at.date()
                    if filters.created_date_from and d < filters.created_date_from:
                        return False
                    if filters.created_date_to and d > filters.created_date_to:
                        return False

                today = date.today()
                # Active / expired flags
                if filters.active_only:
                    if n.published_at is None:
                        return False
                    if n.expires_at and n.expires_at.date() <= today:
                        return False
                if filters.expired_only:
                    if not n.expires_at or n.expires_at.date() > today:
                        return False

                return True

            filtered = [n for n in records if _matches_advanced(n)]

            def _sort_key(n) -> datetime:
                return n.published_at or n.created_at

            sorted_records = sorted(filtered, key=_sort_key, reverse=True)

            start = params.offset
            end = start + params.limit
            page_records = sorted_records[start:end]

            items: List[NoticeListItem] = [
                self._to_list_item(n) for n in page_records
            ]

            return PaginatedResponse[NoticeListItem].create(
                items=items,
                total_items=len(sorted_records),
                page=params.page,
                page_size=params.page_size,
            )

    # ------------------------------------------------------------------ #
    # Create / update
    # ------------------------------------------------------------------ #
    def create_notice(self, data: NoticeCreate) -> NoticeDetail:
        """
        Create a new notice.

        - If hostel_id is None, it's treated as a system-wide notice.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_notice_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            if data.hostel_id:
                hostel = hostel_repo.get(data.hostel_id)
                if hostel is None:
                    raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")
                hostel_name = hostel.name
            else:
                hostel_name = ""

            payload = {
                "hostel_id": data.hostel_id,
                "notice_title": data.notice_title,
                "notice_content": data.notice_content,
                "category": data.category,
                "target_audience": data.target_audience,
                "priority": data.priority,
                "is_urgent": data.is_urgent,
                "published_at": data.published_at,
                "expires_at": data.expires_at,
            }
            n = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            return self._to_detail(n, hostel_name=hostel_name)

    def update_notice(
        self,
        notice_id: UUID,
        data: NoticeUpdate,
    ) -> NoticeDetail:
        """
        Update mutable notice fields.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_notice_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            n = repo.get(notice_id)
            if n is None:
                raise errors.NotFoundError(f"Notice {notice_id} not found")

            update_data = data.model_dump(exclude_unset=True)
            for field, value in update_data.items():
                if hasattr(n, field) and field != "id":
                    setattr(n, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            hostel_name = ""
            if n.hostel_id:
                hostel = hostel_repo.get(n.hostel_id)
                hostel_name = hostel.name if hostel else ""

            return self._to_detail(n, hostel_name=hostel_name)

# --- File: D:\hostel-management-saas\app\services\notice\__init__.py ---
# app/services/notice/__init__.py
"""
Notice-related services.

- NoticeService: core CRUD, listing, and active/public retrieval
  for content_notice records.
"""

from .notice_service import NoticeService

__all__ = [
    "NoticeService",
]


# ===== Folder: D:\hostel-management-saas\app\services\notification =====

# --- File: D:\hostel-management-saas\app\services\notification\email_service.py ---
# app/services/notification/email_service.py
from __future__ import annotations

from datetime import date, datetime, timezone
from decimal import Decimal
from typing import List, Optional, Protocol
from uuid import UUID, uuid4

from app.schemas.notification.email_notification import (
    EmailRequest,
    EmailConfig,
    EmailTracking,
    BulkEmailRequest,
    EmailStats,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import errors


class EmailProvider(Protocol):
    """
    Provider-agnostic email sender (SendGrid, SES, SMTP, etc.).
    """

    def send_email(self, request: EmailRequest, config: EmailConfig) -> Optional[str]:
        """
        Send a single email.

        Returns:
            provider_message_id (if available) or None.
        """
        ...

    def send_bulk(
        self,
        request: BulkEmailRequest,
        config: EmailConfig,
    ) -> List[Optional[str]]:
        """
        Send a bulk email.

        Returns:
            List of provider_message_id per recipient (same order as recipients).
        """
        ...


class EmailConfigStore(Protocol):
    """
    Storage abstraction for EmailConfig.
    """

    def get_config(self) -> Optional[dict]: ...
    def save_config(self, data: dict) -> None: ...


class EmailTrackingStore(Protocol):
    """
    Storage abstraction for EmailTracking records.
    """

    def save_tracking(self, record: dict) -> None: ...
    def get_tracking(self, email_id: UUID) -> Optional[dict]: ...
    def list_tracking_range(self, *, start: date, end: date) -> List[dict]: ...


class EmailService:
    """
    Email sending + basic tracking/stats.

    - get/set EmailConfig
    - send single email (returns EmailTracking)
    - send bulk emails (returns EmailStats)
    - compute stats over a period
    """

    def __init__(
        self,
        config_store: EmailConfigStore,
        tracking_store: EmailTrackingStore,
        provider: EmailProvider,
    ) -> None:
        self._config_store = config_store
        self._tracking_store = tracking_store
        self._provider = provider

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Config
    # ------------------------------------------------------------------ #
    def get_config(self) -> EmailConfig:
        record = self._config_store.get_config()
        if not record:
            raise errors.ServiceError("Email configuration not set")
        return EmailConfig.model_validate(record)

    def set_config(self, cfg: EmailConfig) -> None:
        self._config_store.save_config(cfg.model_dump())

    # ------------------------------------------------------------------ #
    # Send
    # ------------------------------------------------------------------ #
    def send_email(self, request: EmailRequest) -> EmailTracking:
        """
        Send a single email and persist an EmailTracking record.
        """
        config = self.get_config()
        email_id = uuid4()
        sent_at = self._now()

        status = "sent"
        delivered_at = None
        bounced_at = None
        error_message: Optional[str] = None
        provider_message_id: Optional[str] = None

        try:
            provider_message_id = self._provider.send_email(request, config)
        except Exception as exc:  # pragma: no cover - provider-specific
            status = "failed"
            error_message = str(exc)

        record = {
            "email_id": email_id,
            "recipient_email": str(request.recipient_email),
            "sent_at": sent_at,
            "delivered_at": delivered_at,
            "bounced_at": bounced_at,
            "delivery_status": status,  # sent|delivered|bounced|failed|spam
            "opened": False,
            "first_opened_at": None,
            "open_count": 0,
            "clicked": False,
            "first_clicked_at": None,
            "click_count": 0,
            "bounce_type": None,
            "error_message": error_message,
        }
        self._tracking_store.save_tracking(record)
        return EmailTracking.model_validate(record)

    def send_bulk(self, request: BulkEmailRequest) -> EmailStats:
        """
        Simple bulk implementation via fan-out to send_email.

        For large volumes, prefer a queue/worker.
        """
        if not request.recipients:
            raise errors.ValidationError("At least one recipient is required")

        total_sent = 0
        total_failed = 0

        for recipient in request.recipients:
            single_req = EmailRequest(
                recipient_email=recipient,
                cc_emails=[],
                bcc_emails=[],
                subject=request.subject,
                body_html=request.body_html,
                body_text=None,
                attachments=[],
                template_code=request.template_code,
                template_variables=(
                    (request.recipient_variables or {}).get(str(recipient))
                    if request.recipient_variables
                    else None
                ),
                reply_to=None,
                from_name=None,
                track_opens=True,
                track_clicks=True,
                priority="normal",
            )
            tracking = self.send_email(single_req)
            total_sent += 1
            if tracking.delivery_status != "sent":
                total_failed += 1

        total_delivered = total_sent - total_failed
        total_bounced = 0  # bounce webhooks would update this later

        def _pct(num: int, denom: int) -> Decimal:
            return (
                Decimal(str(num)) / Decimal(str(denom)) * Decimal("100")
                if denom > 0
                else Decimal("0")
            )

        today = date.today()

        return EmailStats(
            total_sent=total_sent,
            total_delivered=total_delivered,
            total_bounced=total_bounced,
            total_failed=total_failed,
            delivery_rate=_pct(total_delivered, total_sent),
            bounce_rate=_pct(total_bounced, total_sent),
            total_opened=0,
            open_rate=Decimal("0"),
            total_clicked=0,
            click_rate=Decimal("0"),
            period_start=today,
            period_end=today,
        )

    # ------------------------------------------------------------------ #
    # Stats
    # ------------------------------------------------------------------ #
    def get_stats(self, period: DateRangeFilter) -> EmailStats:
        """
        Aggregate stats from tracking store for a given period.
        """
        start = period.start_date or date.min
        end = period.end_date or date.max

        records = self._tracking_store.list_tracking_range(start=start, end=end)
        total_sent = len(records)
        total_delivered = sum(1 for r in records if r.get("delivery_status") == "delivered")
        total_failed = sum(1 for r in records if r.get("delivery_status") == "failed")
        total_bounced = sum(1 for r in records if r.get("delivery_status") == "bounced")

        total_opened = sum(1 for r in records if r.get("opened"))
        total_clicked = sum(1 for r in records if r.get("clicked"))

        def _pct(num: int, denom: int) -> Decimal:
            return (
                Decimal(str(num)) / Decimal(str(denom)) * Decimal("100")
                if denom > 0
                else Decimal("0")
            )

        return EmailStats(
            total_sent=total_sent,
            total_delivered=total_delivered,
            total_bounced=total_bounced,
            total_failed=total_failed,
            delivery_rate=_pct(total_delivered, total_sent),
            bounce_rate=_pct(total_bounced, total_sent),
            total_opened=total_opened,
            open_rate=_pct(total_opened, total_sent),
            total_clicked=total_clicked,
            click_rate=_pct(total_clicked, total_sent),
            period_start=start,
            period_end=end,
        )

# --- File: D:\hostel-management-saas\app\services\notification\notification_service.py ---
# app/services/notification/notification_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Dict, List, Optional, Protocol
from uuid import UUID, uuid4

from app.schemas.notification import (
    NotificationCreate,
    NotificationUpdate,
    NotificationResponse,
    NotificationList,
    UnreadCount,
    NotificationDetail,
)
from app.schemas.notification.notification_response import NotificationListItem
from app.schemas.notification.notification_base import (
    MarkAsRead,
    BulkMarkAsRead,
    NotificationDelete,
)
from app.schemas.common.enums import NotificationType, Priority
from app.services.common import errors
from app.services.notification.email_service import EmailService
from app.services.notification.sms_service import SMSService
from app.services.notification.push_service import PushService


class NotificationStore(Protocol):
    """
    Storage abstraction for in-app notifications.

    Expected record keys (example):
        {
            "id": UUID,
            "recipient_user_id": UUID | None,
            "recipient_email": str | None,
            "recipient_phone": str | None,
            "notification_type": NotificationType,
            "template_code": str | None,
            "subject": str | None,
            "message_body": str,
            "priority": Priority,
            "status": str,
            "scheduled_at": datetime | None,
            "sent_at": datetime | None,
            "failed_at": datetime | None,
            "failure_reason": str | None,
            "retry_count": int,
            "max_retries": int,
            "metadata": dict,
            "hostel_id": UUID | None,
            "is_read": bool,
            "read_at": datetime | None,
            "created_at": datetime,
            "updated_at": datetime,
        }
    """

    def save_notification(self, record: dict) -> dict: ...
    def update_notification(self, notification_id: UUID, data: dict) -> dict: ...
    def get_notification(self, notification_id: UUID) -> Optional[dict]: ...
    def list_notifications_for_user(self, user_id: UUID) -> List[dict]: ...
    def mark_read(self, notification_id: UUID, user_id: UUID) -> None: ...
    def mark_bulk_read(self, notification_ids: List[UUID], user_id: UUID) -> None: ...
    def delete_notification(self, notification_id: UUID, permanent: bool) -> None: ...


class NotificationService:
    """
    High-level notification orchestrator (in-app + channels):

    - Create & (optionally) dispatch notifications
    - Map to Email/SMS/Push services when sending immediately
    - Read/unread management and listing
    """

    def __init__(
        self,
        store: NotificationStore,
        email_service: Optional[EmailService] = None,
        sms_service: Optional[SMSService] = None,
        push_service: Optional[PushService] = None,
    ) -> None:
        self._store = store
        self._email_service = email_service
        self._sms_service = sms_service
        self._push_service = push_service

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_response(self, rec: dict) -> NotificationResponse:
        return NotificationResponse(
            id=rec["id"],
            created_at=rec["created_at"],
            updated_at=rec["updated_at"],
            recipient_user_id=rec.get("recipient_user_id"),
            recipient_email=rec.get("recipient_email"),
            recipient_phone=rec.get("recipient_phone"),
            notification_type=rec["notification_type"],
            subject=rec.get("subject"),
            message_body=rec["message_body"],
            priority=rec["priority"].value if hasattr(rec["priority"], "value") else str(rec["priority"]),
            status=rec["status"],
            scheduled_at=rec.get("scheduled_at"),
            sent_at=rec.get("sent_at"),
        )

    def _to_detail(self, rec: dict) -> NotificationDetail:
        return NotificationDetail(
            id=rec["id"],
            created_at=rec["created_at"],
            updated_at=rec["updated_at"],
            recipient_user_id=rec.get("recipient_user_id"),
            recipient_email=rec.get("recipient_email"),
            recipient_phone=rec.get("recipient_phone"),
            notification_type=rec["notification_type"],
            template_code=rec.get("template_code"),
            subject=rec.get("subject"),
            message_body=rec["message_body"],
            priority=rec["priority"].value if hasattr(rec["priority"], "value") else str(rec["priority"]),
            status=rec["status"],
            scheduled_at=rec.get("scheduled_at"),
            sent_at=rec.get("sent_at"),
            failed_at=rec.get("failed_at"),
            failure_reason=rec.get("failure_reason"),
            retry_count=rec.get("retry_count", 0),
            max_retries=rec.get("max_retries", 0),
            metadata=rec.get("metadata", {}),
            hostel_id=rec.get("hostel_id"),
            # timestamps already set
        )

    def _to_list_item(self, rec: dict) -> NotificationListItem:
        body = rec["message_body"] or ""
        preview = body[:100]
        return NotificationListItem(
            id=rec["id"],
            notification_type=rec["notification_type"],
            subject=rec.get("subject"),
            message_preview=preview,
            priority=rec["priority"].value if hasattr(rec["priority"], "value") else str(rec["priority"]),
            is_read=rec.get("is_read", False),
            read_at=rec.get("read_at"),
            created_at=rec["created_at"],
            action_url=rec.get("metadata", {}).get("action_url"),
            icon=rec.get("metadata", {}).get("icon"),
        )

    # ------------------------------------------------------------------ #
    # Core create / send
    # ------------------------------------------------------------------ #
    def create_notification(
        self,
        data: NotificationCreate,
        *,
        send_immediately: bool = True,
        max_retries: int = 3,
    ) -> NotificationDetail:
        """
        Create an in-app notification and optionally dispatch to its channel.

        For scheduled notifications (scheduled_at != None), send_immediately
        should typically be False and a queue/worker should handle dispatch.
        """
        now = self._now()
        nid = uuid4()

        priority: Priority = getattr(data, "priority", None) or Priority.MEDIUM

        record = {
            "id": nid,
            "recipient_user_id": data.recipient_user_id,
            "recipient_email": data.recipient_email,
            "recipient_phone": data.recipient_phone,
            "notification_type": data.notification_type,
            "template_code": data.template_code,
            "subject": data.subject,
            "message_body": data.message_body,
            "priority": priority,
            "status": "queued",  # string; NotificationStatus handled by schema
            "scheduled_at": data.scheduled_at,
            "sent_at": None,
            "failed_at": None,
            "failure_reason": None,
            "retry_count": 0,
            "max_retries": max_retries,
            "metadata": data.metadata or {},
            "hostel_id": data.hostel_id,
            "is_read": False,
            "read_at": None,
            "created_at": now,
            "updated_at": now,
        }
        saved = self._store.save_notification(record)

        # Synchronous send if requested and not scheduled in the future
        if send_immediately and not data.scheduled_at:
            self._dispatch_channel(saved)

        fresh = self._store.get_notification(nid) or saved
        return self._to_detail(fresh)

    def _dispatch_channel(self, rec: dict) -> None:
        """
        Dispatch notification to the underlying channel service.
        """
        ntype: NotificationType = rec["notification_type"]
        now = self._now()

        try:
            if ntype == NotificationType.EMAIL and self._email_service:
                from app.schemas.notification.email_notification import EmailRequest

                if not rec.get("recipient_email"):
                    raise errors.ValidationError("recipient_email required for email notification")

                email_req = EmailRequest(
                    recipient_email=rec["recipient_email"],
                    cc_emails=[],
                    bcc_emails=[],
                    subject=rec.get("subject") or "",
                    body_html=rec["message_body"],
                    body_text=None,
                    attachments=[],
                    template_code=rec.get("template_code"),
                    template_variables=None,
                    reply_to=None,
                    from_name=None,
                    track_opens=True,
                    track_clicks=True,
                    priority="normal",
                )
                self._email_service.send_email(email_req)

            elif ntype == NotificationType.SMS and self._sms_service:
                from app.schemas.notification.sms_notification import SMSRequest

                if not rec.get("recipient_phone"):
                    raise errors.ValidationError("recipient_phone required for SMS notification")

                sms_req = SMSRequest(
                    recipient_phone=rec["recipient_phone"],
                    message=rec["message_body"],
                    template_code=rec.get("template_code"),
                    template_variables=None,
                    sender_id=None,
                    priority="normal",
                    dlt_template_id=None,
                )
                self._sms_service.send_sms(sms_req)

            elif ntype == NotificationType.PUSH and self._push_service:
                from app.schemas.notification.push_notification import PushRequest

                if not rec.get("recipient_user_id"):
                    raise errors.ValidationError("recipient_user_id required for push notification")

                push_req = PushRequest(
                    user_id=rec["recipient_user_id"],
                    device_token=None,
                    device_tokens=None,
                    title=rec.get("subject") or "",
                    body=rec["message_body"],
                    data=rec.get("metadata", {}),
                    action_url=rec.get("metadata", {}).get("action_url"),
                    icon=None,
                    image_url=None,
                    badge_count=None,
                    sound="default",
                    priority="normal",
                    ttl=86400,
                )
                self._push_service.send_push(push_req)

            # If we reach here without error, treat as sent
            rec["status"] = "sent"
            rec["sent_at"] = now
            rec["updated_at"] = now
            self._store.update_notification(rec["id"], rec)

        except errors.ServiceError as exc:
            rec["status"] = "failed"
            rec["failed_at"] = now
            rec["failure_reason"] = str(exc)
            rec["updated_at"] = now
            self._store.update_notification(rec["id"], rec)
        except Exception as exc:  # pragma: no cover
            rec["status"] = "failed"
            rec["failed_at"] = now
            rec["failure_reason"] = str(exc)
            rec["updated_at"] = now
            self._store.update_notification(rec["id"], rec)

    # ------------------------------------------------------------------ #
    # Read ops
    # ------------------------------------------------------------------ #
    def get_notification(self, notification_id: UUID) -> NotificationDetail:
        rec = self._store.get_notification(notification_id)
        if not rec:
            raise errors.NotFoundError(f"Notification {notification_id} not found")
        return self._to_detail(rec)

    def list_notifications_for_user(self, user_id: UUID) -> NotificationList:
        recs = self._store.list_notifications_for_user(user_id)
        items = [
            self._to_list_item(r)
            for r in sorted(recs, key=lambda x: x["created_at"], reverse=True)
        ]
        total = len(items)
        unread = sum(1 for r in recs if not r.get("is_read"))
        return NotificationList(
            user_id=user_id,
            total_notifications=total,
            unread_count=unread,
            notifications=items,
        )

    def get_unread_count(self, user_id: UUID) -> UnreadCount:
        recs = self._store.list_notifications_for_user(user_id)
        total_unread = sum(1 for r in recs if not r.get("is_read"))

        email_unread = sum(
            1 for r in recs if not r.get("is_read") and r["notification_type"] == NotificationType.EMAIL
        )
        sms_unread = sum(
            1 for r in recs if not r.get("is_read") and r["notification_type"] == NotificationType.SMS
        )
        push_unread = sum(
            1 for r in recs if not r.get("is_read") and r["notification_type"] == NotificationType.PUSH
        )
        in_app_unread = total_unread  # union here

        urgent_unread = sum(
            1
            for r in recs
            if not r.get("is_read") and r.get("priority") == Priority.CRITICAL
        )
        high_unread = sum(
            1
            for r in recs
            if not r.get("is_read") and r.get("priority") == Priority.HIGH
        )

        return UnreadCount(
            user_id=user_id,
            total_unread=total_unread,
            email_unread=email_unread,
            sms_unread=sms_unread,
            push_unread=push_unread,
            in_app_unread=in_app_unread,
            urgent_unread=urgent_unread,
            high_unread=high_unread,
        )

    # ------------------------------------------------------------------ #
    # Read/mark/delete
    # ------------------------------------------------------------------ #
    def mark_as_read(self, data: MarkAsRead) -> None:
        self._store.mark_read(data.notification_id, data.user_id)

    def bulk_mark_as_read(self, data: BulkMarkAsRead) -> None:
        self._store.mark_bulk_read(data.notification_ids, data.user_id)

    def delete_notification(self, data: NotificationDelete) -> None:
        self._store.delete_notification(data.notification_id, data.permanent)

# --- File: D:\hostel-management-saas\app\services\notification\preference_service.py ---
# app/services/notification/preference_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Optional, Protocol
from uuid import UUID, uuid4

from app.schemas.notification.notification_preferences import (
    UserPreferences,
    FrequencySettings,
    PreferenceUpdate,
    UnsubscribeRequest,
)
from app.services.common import errors


class PreferenceStore(Protocol):
    """
    Storage abstraction for per-user notification preferences.
    """

    def get_preferences(self, user_id: UUID) -> Optional[dict]: ...
    def save_preferences(self, user_id: UUID, data: dict) -> None: ...


class PreferenceService:
    """
    Manage per-user notification preferences.

    - Get or create default UserPreferences
    - Update preferences
    - Handle unsubscribe requests
    """

    def __init__(self, store: PreferenceStore) -> None:
        self._store = store

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _default_preferences(self, user_id: UUID) -> UserPreferences:
        now = self._now()
        freq = FrequencySettings(
            id=uuid4(),
            created_at=now,
            updated_at=now,
            immediate_notifications=True,
            batch_notifications=False,
            batch_interval_hours=4,
            daily_digest_time=None,
            weekly_digest_day=None,
        )
        return UserPreferences(
            id=uuid4(),
            created_at=now,
            updated_at=now,
            user_id=user_id,
            notifications_enabled=True,
            email_enabled=True,
            sms_enabled=True,
            push_enabled=True,
            frequency_settings=freq,
            quiet_hours_enabled=False,
            quiet_hours_start=None,
            quiet_hours_end=None,
            payment_notifications=True,
            booking_notifications=True,
            complaint_notifications=True,
            announcement_notifications=True,
            maintenance_notifications=True,
            attendance_notifications=True,
            marketing_notifications=False,
        )

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_preferences(self, user_id: UUID) -> UserPreferences:
        record = self._store.get_preferences(user_id)
        if record:
            return UserPreferences.model_validate(record)

        prefs = self._default_preferences(user_id)
        self._store.save_preferences(user_id, prefs.model_dump())
        return prefs

    def update_preferences(
        self,
        user_id: UUID,
        data: PreferenceUpdate,
    ) -> UserPreferences:
        prefs = self.get_preferences(user_id)
        mapping = data.model_dump(exclude_unset=True)
        for field, value in mapping.items():
            if hasattr(prefs, field):
                setattr(prefs, field, value)
        prefs.updated_at = self._now()
        self._store.save_preferences(user_id, prefs.model_dump())
        return prefs

    def unsubscribe(self, req: UnsubscribeRequest) -> UserPreferences:
        """
        Handle unsubscribe requests at various levels.
        """
        prefs = self.get_preferences(req.user_id)

        if req.unsubscribe_type == "all":
            prefs.notifications_enabled = False
            prefs.email_enabled = False
            prefs.sms_enabled = False
            prefs.push_enabled = False
            prefs.marketing_notifications = False
        elif req.unsubscribe_type == "email":
            prefs.email_enabled = False
            prefs.marketing_notifications = False
        elif req.unsubscribe_type == "sms":
            prefs.sms_enabled = False
        elif req.unsubscribe_type == "marketing":
            prefs.marketing_notifications = False
        elif req.unsubscribe_type == "specific_category":
            cat = (req.category or "").lower()
            if cat == "payment":
                prefs.payment_notifications = False
            elif cat == "booking":
                prefs.booking_notifications = False
            elif cat == "complaint":
                prefs.complaint_notifications = False
            elif cat == "announcement":
                prefs.announcement_notifications = False
            elif cat == "maintenance":
                prefs.maintenance_notifications = False
            elif cat == "attendance":
                prefs.attendance_notifications = False
        else:
            raise errors.ValidationError("Unknown unsubscribe_type")

        prefs.updated_at = self._now()
        self._store.save_preferences(req.user_id, prefs.model_dump())
        return prefs

# --- File: D:\hostel-management-saas\app\services\notification\push_service.py ---
# app/services/notification/push_service.py
from __future__ import annotations

from datetime import date, datetime, timezone
from decimal import Decimal
from typing import List, Optional, Protocol
from uuid import UUID, uuid4

from app.schemas.notification.push_notification import (
    PushRequest,
    PushConfig,
    DeviceRegistration,
    DeviceUnregistration,
    DeviceToken,
    PushDeliveryStatus,
    PushStats,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import errors


class PushProvider(Protocol):
    """
    Provider-agnostic push sender (FCM/APNs/etc).
    """

    def send(self, request: PushRequest, config: PushConfig, device_token: str) -> Optional[str]:
        """
        Send a push notification to a single device_token.
        Returns provider_message_id or None.
        """
        ...


class PushConfigStore(Protocol):
    """Storage for PushConfig."""

    def get_config(self) -> Optional[dict]: ...
    def save_config(self, data: dict) -> None: ...


class DeviceStore(Protocol):
    """
    Storage for device tokens and delivery statuses.
    """

    # Device tokens
    def save_device(self, record: dict) -> dict: ...
    def get_device(self, device_token: str) -> Optional[dict]: ...
    def deactivate_device(self, device_token: str) -> None: ...
    def list_devices_for_user(self, user_id: UUID) -> List[dict]: ...

    # Delivery status
    def save_delivery_status(self, record: dict) -> None: ...
    def list_delivery_status_range(self, *, start: date, end: date) -> List[dict]: ...


class PushService:
    """
    Push notifications & device registration.

    - Configure push (PushConfig)
    - Register / unregister devices
    - Send push (to user or explicit tokens)
    - Basic stats from delivery records
    """

    def __init__(
        self,
        config_store: PushConfigStore,
        device_store: DeviceStore,
        provider: PushProvider,
    ) -> None:
        self._config_store = config_store
        self._device_store = device_store
        self._provider = provider

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Config
    # ------------------------------------------------------------------ #
    def get_config(self) -> PushConfig:
        record = self._config_store.get_config()
        if not record:
            raise errors.ServiceError("Push configuration not set")
        return PushConfig.model_validate(record)

    def set_config(self, cfg: PushConfig) -> None:
        self._config_store.save_config(cfg.model_dump())

    # ------------------------------------------------------------------ #
    # Device registration
    # ------------------------------------------------------------------ #
    def register_device(self, req: DeviceRegistration) -> DeviceToken:
        """
        Register (or update) a device token for a user.
        """
        now = self._now()
        record = {
            "id": uuid4(),
            "user_id": req.user_id,
            "device_token": req.device_token,
            "device_type": req.device_type,
            "device_name": req.device_name,
            "device_model": req.device_model,
            "os_version": req.os_version,
            "app_version": req.app_version,
            "is_active": True,
            "last_used_at": now,
            "registered_at": now,
        }
        saved = self._device_store.save_device(record)
        return DeviceToken.model_validate(saved)

    def unregister_device(self, req: DeviceUnregistration) -> None:
        """
        Deactivate a device token.
        """
        self._device_store.deactivate_device(req.device_token)

    # ------------------------------------------------------------------ #
    # Send push
    # ------------------------------------------------------------------ #
    def send_push(self, req: PushRequest) -> List[PushDeliveryStatus]:
        """
        Send a push notification to:

        - all active devices of req.user_id, or
        - specific device_token(s) if provided.
        """
        config = self.get_config()
        now = self._now()

        # Determine target tokens
        tokens: List[str] = []
        if req.device_tokens:
            tokens.extend(req.device_tokens)
        if req.device_token:
            tokens.append(req.device_token)
        if req.user_id:
            for dev in self._device_store.list_devices_for_user(req.user_id):
                if dev.get("is_active"):
                    tokens.append(dev["device_token"])

        tokens = list(dict.fromkeys(tokens))  # de-duplicate

        results: List[PushDeliveryStatus] = []
        for token in tokens:
            status = "queued"
            provider_message_id = None
            error_message = None

            try:
                provider_message_id = self._provider.send(req, config, token)
                status = "sent"
            except Exception as exc:  # pragma: no cover
                status = "failed"
                error_message = str(exc)

            record = {
                "notification_id": uuid4(),
                "device_token": token,
                "status": status,  # queued|sent|delivered|failed|expired
                "sent_at": now if status in ("sent", "delivered") else None,
                "delivered_at": None,
                "failed_at": now if status == "failed" else None,
                "error_code": None,
                "error_message": error_message,
                "provider_message_id": provider_message_id,
            }
            self._device_store.save_delivery_status(record)
            results.append(PushDeliveryStatus.model_validate(record))

        return results

    # ------------------------------------------------------------------ #
    # Stats
    # ------------------------------------------------------------------ #
    def get_stats(self, period: DateRangeFilter) -> PushStats:
        start = period.start_date or date.min
        end = period.end_date or date.max

        records = self._device_store.list_delivery_status_range(start=start, end=end)
        total_sent = len(records)
        total_delivered = sum(1 for r in records if r.get("status") == "delivered")
        total_failed = sum(1 for r in records if r.get("status") == "failed")
        total_opened = 0  # requires app-side tracking

        def _pct(num: int, denom: int) -> Decimal:
            return (
                Decimal(str(num)) / Decimal(str(denom)) * Decimal("100")
                if denom > 0
                else Decimal("0")
            )

        # Platform breakdown would need device_type in delivery records; set 0 here.
        ios_sent = android_sent = web_sent = 0

        return PushStats(
            total_sent=total_sent,
            total_delivered=total_delivered,
            total_failed=total_failed,
            delivery_rate=_pct(total_delivered, total_sent),
            ios_sent=ios_sent,
            android_sent=android_sent,
            web_sent=web_sent,
            total_opened=total_opened,
            open_rate=_pct(total_opened, total_sent),
            period_start=start,
            period_end=end,
        )

# --- File: D:\hostel-management-saas\app\services\notification\queue_service.py ---
# app/services/notification/queue_service.py
from __future__ import annotations

from datetime import date, datetime, timezone
from decimal import Decimal
from typing import List, Optional, Protocol
from uuid import UUID

from app.schemas.notification.notification_queue import (
    QueueStatus,
    QueuedNotification,
    BatchProcessing,
    QueueStats,
)
from app.schemas.common.enums import NotificationType, Priority
from app.schemas.common.filters import DateRangeFilter


class NotificationQueueStore(Protocol):
    """
    Storage abstraction for queued notifications and batch processing.
    """

    # Queue
    def enqueue(self, record: dict) -> None: ...
    def get(self, notification_id: UUID) -> Optional[dict]: ...
    def update(self, notification_id: UUID, data: dict) -> None: ...
    def list_all(self) -> List[dict]: ...

    # Batches (optional, not fully used here)
    def save_batch(self, record: dict) -> None: ...
    def get_batch(self, batch_id: UUID) -> Optional[dict]: ...
    def list_batches(self) -> List[dict]: ...


class QueueService:
    """
    Notification queue management:

    - Enqueue notifications for async processing
    - Update status (processing, completed, failed)
    - Provide high-level queue status & stats
    """

    def __init__(self, store: NotificationQueueStore) -> None:
        self._store = store

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Enqueue & update
    # ------------------------------------------------------------------ #
    def enqueue_notification(
        self,
        *,
        notification_id: UUID,
        notification_type: NotificationType,
        priority: Priority,
        recipient: str,
        scheduled_at: Optional[datetime] = None,
        max_retries: int = 3,
    ) -> QueuedNotification:
        now = self._now()
        record = {
            "notification_id": notification_id,
            "notification_type": notification_type,
            "priority": priority,
            "status": "queued",  # NotificationStatus as string
            "recipient": recipient,
            "scheduled_at": scheduled_at,
            "queued_at": now,
            "retry_count": 0,
            "max_retries": max_retries,
            "estimated_send_time": scheduled_at or now,
        }
        self._store.enqueue(record)
        return QueuedNotification.model_validate(record)

    def update_status(
        self,
        notification_id: UUID,
        *,
        status: str,
        retry_count: Optional[int] = None,
        estimated_send_time: Optional[datetime] = None,
    ) -> QueuedNotification:
        rec = self._store.get(notification_id)
        if not rec:
            raise ValueError(f"Queued notification {notification_id} not found")

        rec["status"] = status
        if retry_count is not None:
            rec["retry_count"] = retry_count
        if estimated_send_time is not None:
            rec["estimated_send_time"] = estimated_send_time

        self._store.update(notification_id, rec)
        return QueuedNotification.model_validate(rec)

    # ------------------------------------------------------------------ #
    # Status
    # ------------------------------------------------------------------ #
    def get_queue_status(self) -> QueueStatus:
        records = self._store.list_all()
        total_queued = sum(1 for r in records if r.get("status") == "queued")
        total_processing = sum(1 for r in records if r.get("status") == "processing")
        total_failed = sum(1 for r in records if r.get("status") == "failed")

        urgent_queued = sum(
            1
            for r in records
            if r.get("status") == "queued"
            and r.get("priority") == Priority.CRITICAL
        )
        high_queued = sum(
            1
            for r in records
            if r.get("status") == "queued"
            and r.get("priority") == Priority.HIGH
        )
        medium_queued = sum(
            1
            for r in records
            if r.get("status") == "queued"
            and r.get("priority") == Priority.MEDIUM
        )
        low_queued = sum(
            1
            for r in records
            if r.get("status") == "queued"
            and r.get("priority") == Priority.LOW
        )

        email_queued = sum(
            1
            for r in records
            if r.get("status") == "queued"
            and r.get("notification_type") == NotificationType.EMAIL
        )
        sms_queued = sum(
            1
            for r in records
            if r.get("status") == "queued"
            and r.get("notification_type") == NotificationType.SMS
        )
        push_queued = sum(
            1
            for r in records
            if r.get("status") == "queued"
            and r.get("notification_type") == NotificationType.PUSH
        )

        return QueueStatus(
            total_queued=total_queued,
            total_processing=total_processing,
            total_failed=total_failed,
            urgent_queued=urgent_queued,
            high_queued=high_queued,
            medium_queued=medium_queued,
            low_queued=low_queued,
            email_queued=email_queued,
            sms_queued=sms_queued,
            push_queued=push_queued,
            avg_processing_time_seconds=Decimal("0"),
            throughput_per_minute=Decimal("0"),
        )

    def get_queue_stats(self, period: DateRangeFilter) -> QueueStats:
        """
        Placeholder implementation.

        A real implementation would require per-notification timestamps
        (when queued, when processed, etc.). Here we return zeros.
        """
        start = period.start_date or date.min
        end = period.end_date or date.max

        return QueueStats(
            current_queue_size=len(self._store.list_all()),
            oldest_queued_age_minutes=None,
            today_processed=0,
            today_successful=0,
            today_failed=0,
            success_rate=Decimal("0"),
            failure_rate=Decimal("0"),
            average_queue_time_minutes=Decimal("0"),
            average_processing_time_seconds=Decimal("0"),
        )

# --- File: D:\hostel-management-saas\app\services\notification\routing_service.py ---
# app/services/notification/routing_service.py
from __future__ import annotations

from typing import Dict, List, Optional, Protocol
from uuid import UUID

from app.schemas.notification.notification_routing import (
    RoutingConfig,
    RoutingRule,
    NotificationRoute,
)
from app.schemas.common.enums import Priority
from app.services.common import errors


class RoutingStore(Protocol):
    """
    Storage abstraction for routing configs per hostel.
    """

    def get_routing_config(self, hostel_id: UUID) -> Optional[dict]: ...
    def save_routing_config(self, hostel_id: UUID, data: dict) -> None: ...


class RoutingService:
    """
    Notification routing:

    - Manage RoutingConfig per hostel
    - Determine a NotificationRoute for a given event
    """

    def __init__(self, store: RoutingStore) -> None:
        self._store = store

    # ------------------------------------------------------------------ #
    # Config
    # ------------------------------------------------------------------ #
    def get_config(self, hostel_id: UUID) -> RoutingConfig:
        record = self._store.get_routing_config(hostel_id)
        if record:
            return RoutingConfig.model_validate(record)
        # default routing with no rules
        cfg = RoutingConfig(
            id=None,
            created_at=None,
            updated_at=None,
            hostel_id=hostel_id,
            rules=[],
            enable_escalation=True,
            escalation_timeout_hours=24,
        )
        self._store.save_routing_config(hostel_id, cfg.model_dump())
        return cfg

    def set_config(self, cfg: RoutingConfig) -> None:
        self._store.save_routing_config(cfg.hostel_id, cfg.model_dump())

    # ------------------------------------------------------------------ #
    # Route resolution
    # ------------------------------------------------------------------ #
    def determine_route(
        self,
        *,
        notification_id: UUID,
        hostel_id: UUID,
        event_type: str,
        priority: Optional[Priority] = None,
    ) -> NotificationRoute:
        """
        Build a simple NotificationRoute:

        - Filter rules by event_type (and priority, if provided)
        - Uses specific_users as primary_recipients
        - Does not yet expand recipient_roles to actual user IDs
        """
        cfg = self.get_config(hostel_id)
        primary: List[UUID] = []
        cc: List[UUID] = []
        recipient_channels: Dict[UUID, List[str]] = {}

        for rule in cfg.rules:
            if not rule.is_active:
                continue
            if rule.event_type != event_type:
                continue
            if priority and rule.priority and rule.priority != priority:
                continue

            for uid in rule.specific_users:
                if uid not in primary:
                    primary.append(uid)
                    recipient_channels[uid] = list(rule.channels)

        return NotificationRoute(
            notification_id=notification_id,
            primary_recipients=primary,
            cc_recipients=cc,
            recipient_channels=recipient_channels,
            escalation_enabled=cfg.enable_escalation,
            escalation_path=None,
        )

# --- File: D:\hostel-management-saas\app\services\notification\sms_service.py ---
# app/services/notification/sms_service.py
from __future__ import annotations

from datetime import date, datetime, timezone
from decimal import Decimal
from typing import List, Optional, Protocol
from uuid import UUID, uuid4

from app.schemas.notification.sms_notification import (
    SMSRequest,
    SMSConfig,
    DeliveryStatus as SMSDeliveryStatus,
    SMSTemplate,
    BulkSMSRequest,
    SMSStats,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import errors


class SMSProvider(Protocol):
    """
    Provider-agnostic SMS sender (Twilio, SNS, MSG91, etc.).
    """

    def send_sms(self, request: SMSRequest, config: SMSConfig) -> Optional[str]:
        """
        Send a single SMS. Returns provider_message_id or None.
        """
        ...

    def send_bulk(
        self,
        request: BulkSMSRequest,
        config: SMSConfig,
    ) -> List[Optional[str]]:
        """
        Send bulk SMS messages. Returns list of provider_message_id per recipient.
        """
        ...


class SMSConfigStore(Protocol):
    """Storage for SMSConfig."""

    def get_config(self) -> Optional[dict]: ...
    def save_config(self, data: dict) -> None: ...


class SMSStatusStore(Protocol):
    """Storage for SMS delivery status records."""

    def save_status(self, record: dict) -> None: ...
    def get_status(self, sms_id: UUID) -> Optional[dict]: ...
    def list_status_range(self, *, start: date, end: date) -> List[dict]: ...


class SMSService:
    """
    SMS sending + basic delivery status & stats.
    """

    def __init__(
        self,
        config_store: SMSConfigStore,
        status_store: SMSStatusStore,
        provider: SMSProvider,
    ) -> None:
        self._config_store = config_store
        self._status_store = status_store
        self._provider = provider

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Config
    # ------------------------------------------------------------------ #
    def get_config(self) -> SMSConfig:
        record = self._config_store.get_config()
        if not record:
            raise errors.ServiceError("SMS configuration not set")
        return SMSConfig.model_validate(record)

    def set_config(self, cfg: SMSConfig) -> None:
        self._config_store.save_config(cfg.model_dump())

    # ------------------------------------------------------------------ #
    # Send
    # ------------------------------------------------------------------ #
    def send_sms(self, request: SMSRequest) -> SMSDeliveryStatus:
        """
        Send a single SMS and persist DeliveryStatus.
        """
        config = self.get_config()
        sms_id = uuid4()
        now = self._now()

        status = "queued"
        error_message: Optional[str] = None
        provider_message_id: Optional[str] = None

        try:
            provider_message_id = self._provider.send_sms(request, config)
            status = "sent"
        except Exception as exc:  # pragma: no cover
            status = "failed"
            error_message = str(exc)

        record = {
            "sms_id": sms_id,
            "recipient_phone": request.recipient_phone,
            "status": status,  # queued|sent|delivered|failed|undelivered
            "queued_at": now,
            "sent_at": now if status == "sent" else None,
            "delivered_at": None,
            "failed_at": now if status == "failed" else None,
            "error_code": None,
            "error_message": error_message,
            "provider_message_id": provider_message_id,
            "segments_count": 1,
            "cost": None,
        }
        self._status_store.save_status(record)
        return SMSDeliveryStatus.model_validate(record)

    def send_bulk(self, request: BulkSMSRequest) -> SMSStats:
        """
        Naive bulk implementation via fan-out to send_sms.
        """
        if not request.recipients:
            raise errors.ValidationError("At least one recipient is required")

        total_sent = 0
        total_failed = 0
        total_segments = 0

        for phone in request.recipients:
            single_req = SMSRequest(
                recipient_phone=phone,
                message=request.message,
                template_code=request.template_code,
                template_variables=(
                    (request.recipient_variables or {}).get(phone)
                    if request.recipient_variables
                    else None
                ),
                sender_id=None,
                priority="normal",
                dlt_template_id=None,
            )
            status = self.send_sms(single_req)
            total_sent += 1
            total_segments += status.segments_count
            if status.status != "sent":
                total_failed += 1

        total_delivered = total_sent - total_failed

        def _pct(num: int, denom: int) -> Decimal:
            return (
                Decimal(str(num)) / Decimal(str(denom)) * Decimal("100")
                if denom > 0
                else Decimal("0")
            )

        today = date.today()
        total_cost = Decimal("0")
        avg_cost = Decimal("0")
        avg_seg = (
            Decimal(str(total_segments)) / Decimal(str(total_sent))
            if total_sent > 0
            else Decimal("0")
        )

        return SMSStats(
            total_sent=total_sent,
            total_delivered=total_delivered,
            total_failed=total_failed,
            delivery_rate=_pct(total_delivered, total_sent),
            failure_rate=_pct(total_failed, total_sent),
            total_cost=total_cost,
            average_cost_per_sms=avg_cost,
            total_segments=total_segments,
            average_segments_per_sms=avg_seg,
            period_start=today,
            period_end=today,
        )

    # ------------------------------------------------------------------ #
    # Stats
    # ------------------------------------------------------------------ #
    def get_stats(self, period: DateRangeFilter) -> SMSStats:
        start = period.start_date or date.min
        end = period.end_date or date.max

        records = self._status_store.list_status_range(start=start, end=end)
        total_sent = len(records)
        total_delivered = sum(1 for r in records if r.get("status") == "delivered")
        total_failed = sum(1 for r in records if r.get("status") == "failed")
        total_segments = sum(int(r.get("segments_count", 1)) for r in records)

        def _pct(num: int, denom: int) -> Decimal:
            return (
                Decimal(str(num)) / Decimal(str(denom)) * Decimal("100")
                if denom > 0
                else Decimal("0")
            )

        total_cost = sum(
            Decimal(str(r.get("cost"))) for r in records if r.get("cost") is not None
        ) or Decimal("0")
        avg_cost = (
            total_cost / Decimal(str(total_sent)) if total_sent > 0 else Decimal("0")
        )
        avg_seg = (
            Decimal(str(total_segments)) / Decimal(str(total_sent))
            if total_sent > 0
            else Decimal("0")
        )

        return SMSStats(
            total_sent=total_sent,
            total_delivered=total_delivered,
            total_failed=total_failed,
            delivery_rate=_pct(total_delivered, total_sent),
            failure_rate=_pct(total_failed, total_sent),
            total_cost=total_cost,
            average_cost_per_sms=avg_cost,
            total_segments=total_segments,
            average_segments_per_sms=avg_seg,
            period_start=start,
            period_end=end,
        )

# --- File: D:\hostel-management-saas\app\services\notification\template_service.py ---
# app/services/notification/template_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Dict, List, Optional, Protocol
from uuid import uuid4

from app.schemas.notification.notification_template import (
    TemplateCreate,
    TemplateUpdate,
    TemplateResponse,
    VariableMapping,
    TemplatePreview,
    TemplatePreviewResponse,
    TemplateList,
)
from app.services.common import errors


class TemplateStore(Protocol):
    """
    Abstract storage for notification templates (TemplateResponse-like dicts).
    """

    def get_template(self, template_code: str) -> Optional[dict]: ...
    def save_template(self, template_code: str, data: dict) -> None: ...
    def delete_template(self, template_code: str) -> None: ...
    def list_templates(self) -> List[dict]: ...


class TemplateService:
    """
    Manage notification templates:

    - Create / update / delete
    - List templates
    - Render / preview templates with variables
    """

    def __init__(self, store: TemplateStore) -> None:
        self._store = store

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # CRUD
    # ------------------------------------------------------------------ #
    def create_template(self, data: TemplateCreate) -> TemplateResponse:
        if self._store.get_template(data.template_code):
            raise errors.ConflictError(
                f"Template {data.template_code!r} already exists"
            )

        now = self._now()
        record = {
            "id": uuid4(),
            "created_at": now,
            "updated_at": now,
            "template_code": data.template_code,
            "template_name": data.template_name,
            "template_type": data.template_type,
            "subject": data.subject,
            "body_template": data.body_template,
            "variables": data.variables,
            "is_active": data.is_active,
            "description": data.description,
            "usage_count": 0,
            "last_used_at": None,
        }
        self._store.save_template(data.template_code, record)
        return TemplateResponse.model_validate(record)

    def update_template(
        self,
        template_code: str,
        data: TemplateUpdate,
    ) -> TemplateResponse:
        record = self._store.get_template(template_code)
        if not record:
            raise errors.NotFoundError(f"Template {template_code!r} not found")

        mapping = data.model_dump(exclude_unset=True)
        for field, value in mapping.items():
            record[field] = value
        record["updated_at"] = self._now()

        self._store.save_template(template_code, record)
        return TemplateResponse.model_validate(record)

    def delete_template(self, template_code: str) -> None:
        record = self._store.get_template(template_code)
        if not record:
            raise errors.NotFoundError(f"Template {template_code!r} not found")
        self._store.delete_template(template_code)

    def get_template(self, template_code: str) -> TemplateResponse:
        record = self._store.get_template(template_code)
        if not record:
            raise errors.NotFoundError(f"Template {template_code!r} not found")
        return TemplateResponse.model_validate(record)

    def list_templates(self) -> TemplateList:
        records = self._store.list_templates()
        templates = [TemplateResponse.model_validate(r) for r in records]
        total = len(templates)
        active = sum(1 for t in templates if t.is_active)
        return TemplateList(
            total_templates=total,
            active_templates=active,
            templates=templates,
        )

    # ------------------------------------------------------------------ #
    # Rendering / preview
    # ------------------------------------------------------------------ #
    def render_template(
        self,
        template_code: str,
        variables: Dict[str, str],
        *,
        mark_used: bool = False,
    ) -> TemplatePreviewResponse:
        record = self._store.get_template(template_code)
        if not record:
            raise errors.NotFoundError(f"Template {template_code!r} not found")

        tmpl = TemplateResponse.model_validate(record)
        missing_vars = [v for v in tmpl.variables if v not in variables]
        all_provided = not missing_vars

        body = tmpl.body_template
        for key, value in variables.items():
            body = body.replace(f"{{{{{key}}}}}", value)

        if mark_used:
            record["usage_count"] = int(record.get("usage_count") or 0) + 1
            record["last_used_at"] = self._now()
            self._store.save_template(template_code, record)

        return TemplatePreviewResponse(
            subject=tmpl.subject,
            rendered_body=body,
            all_variables_provided=all_provided,
            missing_variables=missing_vars,
        )

    def preview(self, data: TemplatePreview) -> TemplatePreviewResponse:
        return self.render_template(
            template_code=data.template_code,
            variables=data.variables,
            mark_used=False,
        )

# --- File: D:\hostel-management-saas\app\services\notification\__init__.py ---
# app/services/notification/__init__.py
"""
Notification services package.

- NotificationService:
    Orchestrates in‑app notifications and dispatch to channels
    (email / SMS / push), plus read/unread management.

- EmailService:
    Email sending, configuration, and basic stats (provider‑agnostic).

- SMSService:
    SMS sending, configuration, and basic stats (provider‑agnostic).

- PushService:
    Push notifications + device registration and stats.

- TemplateService:
    Notification template CRUD and rendering/preview.

- PreferenceService:
    Per‑user notification preferences.

- RoutingService:
    Hostel notification routing rules (who should receive what).

- QueueService:
    Notification queue abstraction for async processing.
"""

from .notification_service import NotificationService, NotificationStore
from .email_service import EmailService, EmailProvider, EmailConfigStore, EmailTrackingStore
from .sms_service import SMSService, SMSProvider, SMSConfigStore, SMSStatusStore
from .push_service import PushService, PushProvider, PushConfigStore, DeviceStore
from .template_service import TemplateService, TemplateStore
from .preference_service import PreferenceService, PreferenceStore
from .routing_service import RoutingService, RoutingStore
from .queue_service import QueueService, NotificationQueueStore

__all__ = [
    "NotificationService",
    "NotificationStore",
    "EmailService",
    "EmailProvider",
    "EmailConfigStore",
    "EmailTrackingStore",
    "SMSService",
    "SMSProvider",
    "SMSConfigStore",
    "SMSStatusStore",
    "PushService",
    "PushProvider",
    "PushConfigStore",
    "DeviceStore",
    "TemplateService",
    "TemplateStore",
    "PreferenceService",
    "PreferenceStore",
    "RoutingService",
    "RoutingStore",
    "QueueService",
    "NotificationQueueStore",
]


# ===== Folder: D:\hostel-management-saas\app\services\payment =====

# --- File: D:\hostel-management-saas\app\services\payment\payment_gateway_service.py ---
# app/services/payment/payment_gateway_service.py
from __future__ import annotations

from datetime import datetime, timezone, date
from typing import Callable, Optional, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import PaymentRepository
from app.repositories.core import UserRepository
from app.schemas.common.enums import PaymentStatus
from app.schemas.payment.payment_gateway import (
    GatewayRequest,
    GatewayResponse,
    GatewayWebhook,
    GatewayCallback,
    GatewayRefundRequest,
    GatewayRefundResponse,
)
from app.services.common import UnitOfWork, errors


class PaymentGatewayClient(Protocol):
    """
    Abstract payment gateway client.

    Implementations should wrap Razorpay/Stripe/Paytm SDKs.
    """

    def create_order(self, req: GatewayRequest) -> GatewayResponse: ...
    def process_refund(self, req: GatewayRefundRequest) -> GatewayRefundResponse: ...
    def verify_webhook(self, webhook: GatewayWebhook) -> bool: ...


class PaymentGatewayService:
    """
    Gateway-facing payment operations:

    - Build GatewayRequest from Payment + User data
    - Call PaymentGatewayClient to create orders
    - Handle gateway callbacks/webhooks to update Payment.status
    - Initiate and record refunds via gateway
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        client: PaymentGatewayClient,
    ) -> None:
        self._session_factory = session_factory
        self._client = client

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Initiation
    # ------------------------------------------------------------------ #
    def build_gateway_request(self, payment_id: UUID, *, order_id: str, description: str,
                              callback_url: str, success_url: Optional[str] = None,
                              failure_url: Optional[str] = None) -> GatewayRequest:
        """
        Build a GatewayRequest from an existing Payment and its payer.
        """
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            user_repo = self._get_user_repo(uow)

            p = pay_repo.get(payment_id)
            if p is None:
                raise errors.NotFoundError(f"Payment {payment_id} not found")

            payer = user_repo.get(p.payer_id)
            if payer is None:
                raise errors.NotFoundError(f"Payer user {p.payer_id} not found")

            return GatewayRequest(
                payment_id=payment_id,
                amount=p.amount,
                currency=p.currency,
                customer_name=payer.full_name,
                customer_email=payer.email,
                customer_phone=getattr(payer, "phone", ""),
                order_id=order_id,
                description=description,
                callback_url=callback_url,
                success_url=success_url,
                failure_url=failure_url,
                metadata={},
            )

    def create_gateway_order(self, req: GatewayRequest) -> GatewayResponse:
        """
        Delegate to PaymentGatewayClient.create_order.
        """
        return self._client.create_order(req)

    # ------------------------------------------------------------------ #
    # Callbacks & webhooks
    # ------------------------------------------------------------------ #
    def handle_callback(self, cb: GatewayCallback) -> None:
        """
        Handle a synchronous callback (e.g. front-end redirect) from the gateway.

        - Updates payment_status based on cb.success.
        """
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)

            p = pay_repo.get(cb.payment_id)
            if p is None:
                raise errors.NotFoundError(f"Payment {cb.payment_id} not found")

            if cb.success:
                p.payment_status = PaymentStatus.COMPLETED  # type: ignore[attr-defined]
                p.paid_at = self._now()  # type: ignore[attr-defined]
            else:
                p.payment_status = PaymentStatus.FAILED  # type: ignore[attr-defined]
                p.failed_at = self._now()  # type: ignore[attr-defined]
                p.failure_reason = cb.error_message  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

    def handle_webhook(self, webhook: GatewayWebhook) -> None:
        """
        Handle gateway webhook:

        - Verify signature via client
        - Lookup Payment by gateway_order_id or gateway_payment_id (out of scope here)
        - Update Payment status as appropriate
        """
        if not self._client.verify_webhook(webhook):
            raise errors.ValidationError("Invalid webhook signature")

        # Application-specific mapping from gateway IDs to internal payment_id
        # is not implemented here; caller should extend this method.
        # This is a skeleton to update a known payment_id if present in metadata.

    # ------------------------------------------------------------------ #
    # Refunds
    # ------------------------------------------------------------------ #
    def request_refund(self, req: GatewayRefundRequest) -> GatewayRefundResponse:
        """
        Request a refund from the gateway.
        """
        return self._client.process_refund(req)

# --- File: D:\hostel-management-saas\app\services\payment\payment_ledger_service.py ---
# app/services/payment/payment_ledger_service.py
from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Callable, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import PaymentRepository
from app.repositories.core import HostelRepository, StudentRepository, UserRepository
from app.schemas.common.enums import PaymentStatus
from app.schemas.payment.payment_ledger import (
    LedgerEntry,
    LedgerSummary,
    AccountStatement,
    TransactionHistory,
    TransactionItem,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork, errors


class PaymentLedgerService:
    """
    Ledger-style views derived from payments:

    - Generate ledger entries & summaries per student
    - Produce account statements for periods
    - Simple transaction history
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Ledger summary
    # ------------------------------------------------------------------ #
    def get_ledger_summary(self, student_id: UUID, hostel_id: UUID) -> LedgerSummary:
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            student_repo = self._get_student_repo(uow)

            student = student_repo.get(student_id)
            if not student or student.hostel_id != hostel_id:
                raise errors.NotFoundError("Student/hostel mismatch or not found")

            payments = pay_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"student_id": student_id, "hostel_id": hostel_id},
            )

        total_payments = Decimal("0")
        last_tx_date: Optional[date] = None

        for p in payments:
            if p.payment_status == PaymentStatus.COMPLETED and p.paid_at:
                total_payments += p.amount
                d = p.paid_at.date()
                if not last_tx_date or d > last_tx_date:
                    last_tx_date = d

        current_balance = Decimal("0") - total_payments
        total_charges = Decimal("0")
        total_refunds = Decimal("0")
        total_due = Decimal("0")
        overdue_amount = Decimal("0")

        last_payment_date = last_tx_date
        last_payment_amount = total_payments if last_tx_date else None

        return LedgerSummary(
            student_id=student_id,
            student_name=student.user.full_name if getattr(student, "user", None) else "",
            hostel_id=hostel_id,
            current_balance=current_balance,
            total_charges=total_charges,
            total_payments=total_payments,
            total_refunds=total_refunds,
            total_due=total_due,
            overdue_amount=overdue_amount,
            last_transaction_date=last_tx_date,
            last_payment_date=last_payment_date,
        )

    # ------------------------------------------------------------------ #
    # Account statement
    # ------------------------------------------------------------------ #
    def get_account_statement(
        self,
        student_id: UUID,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> AccountStatement:
        if not (period.start_date and period.end_date):
            raise errors.ValidationError(
                "Both start_date and end_date are required for account statement"
            )
        start = period.start_date
        end = period.end_date

        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)

            student = student_repo.get(student_id)
            if not student or student.hostel_id != hostel_id:
                raise errors.NotFoundError("Student/hostel mismatch or not found")

            hostel = hostel_repo.get(hostel_id)
            if not hostel:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            payments = pay_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"student_id": student_id, "hostel_id": hostel_id},
            )

        # Opening balance assumed 0 for simplicity
        opening_balance = Decimal("0")
        balance = opening_balance

        entries: List[LedgerEntry] = []
        total_debits = Decimal("0")
        total_credits = Decimal("0")

        seq = sorted(
            [p for p in payments if p.paid_at and start <= p.paid_at.date() <= end],
            key=lambda p: p.paid_at,
        )

        for p in seq:
            amount = p.amount
            balance_before = balance
            balance_after = balance_before + amount * Decimal("-1")
            balance = balance_after

            entry = LedgerEntry(
                id=p.id,
                created_at=p.created_at,
                updated_at=p.updated_at,
                student_id=student_id,
                hostel_id=hostel_id,
                entry_date=p.paid_at.date() if p.paid_at else start,
                entry_type="credit",
                transaction_type=p.payment_type.value if hasattr(p.payment_type, "value") else str(p.payment_type),
                amount=amount,
                balance_before=balance_before,
                balance_after=balance_after,
                payment_id=p.id,
                payment_reference=str(p.id),
                description="Payment received",
                created_by=None,
                notes=None,
            )
            entries.append(entry)
            total_credits += amount

        closing_balance = balance

        return AccountStatement(
            student_id=student_id,
            student_name=student.user.full_name if getattr(student, "user", None) else "",
            hostel_id=hostel_id,
            hostel_name=hostel.name,
            statement_period_start=start,
            statement_period_end=end,
            generated_at=self._now(),
            opening_balance=opening_balance,
            entries=entries,
            total_debits=total_debits,
            total_credits=total_credits,
            closing_balance=closing_balance,
            pdf_url=None,
        )

    # ------------------------------------------------------------------ #
    # Transaction history
    # ------------------------------------------------------------------ #
    def get_transaction_history(
        self,
        student_id: UUID,
        *,
        page: int = 1,
        page_size: int = 20,
    ) -> TransactionHistory:
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)

            payments = pay_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"student_id": student_id},
                order_by=[pay_repo.model.created_at.desc()],  # type: ignore[attr-defined]
            )

        total = len(payments)
        start_ix = (page - 1) * page_size
        end_ix = start_ix + page_size
        subset = payments[start_ix:end_ix]

        balance = Decimal("0")
        items: List[TransactionItem] = []
        for p in reversed(subset):  # chronological
            amount = p.amount
            balance = balance - amount
            items.append(
                TransactionItem(
                    transaction_id=p.id,
                    transaction_date=p.paid_at or p.created_at,
                    transaction_type=p.payment_type.value if hasattr(p.payment_type, "value") else str(p.payment_type),
                    amount=amount,
                    balance_after=balance,
                    description="Payment",
                    payment_reference=str(p.id),
                    status=p.payment_status.value if hasattr(p.payment_status, "value") else str(p.payment_status),
                )
            )

        return TransactionHistory(
            student_id=student_id,
            transactions=items,
            total_transactions=total,
            page=page,
            page_size=page_size,
        )

# --- File: D:\hostel-management-saas\app\services\payment\payment_reminder_service.py ---
# app/services/payment/payment_reminder_service.py
from __future__ import annotations

from datetime import date, datetime, timedelta, timezone
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Protocol
from uuid import UUID, uuid4

from sqlalchemy.orm import Session

from app.repositories.transactions import PaymentRepository
from app.repositories.core import StudentRepository, HostelRepository, UserRepository
from app.schemas.common.enums import PaymentStatus
from app.schemas.payment.payment_reminder import (
    ReminderConfig,
    ReminderLog,
    SendReminderRequest,
    ReminderBatch,
    ReminderStats,
)
from app.services.common import UnitOfWork, errors


class ReminderConfigStore(Protocol):
    """
    Storage for ReminderConfig per hostel.
    """

    def get_config(self, hostel_id: UUID) -> Optional[dict]: ...
    def save_config(self, hostel_id: UUID, data: dict) -> None: ...


class ReminderLogStore(Protocol):
    """
    Storage for ReminderLog entries.
    """

    def save_log(self, record: dict) -> dict: ...
    def list_logs_for_period(self, hostel_id: UUID, start: date, end: date) -> List[dict]: ...


class ReminderSender(Protocol):
    """
    Abstraction for sending reminders (email/SMS/push/notification).
    """

    def send(
        self,
        *,
        student_id: UUID,
        student_email: str,
        student_phone: str,
        channel: str,
        subject: Optional[str],
        message: str,
    ) -> bool: ...


class PaymentReminderService:
    """
    Payment reminder service:

    - Manage ReminderConfig per hostel
    - Send manual reminders (per payment/student/hostel)
    - Basic stats over reminders
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        config_store: ReminderConfigStore,
        log_store: ReminderLogStore,
        sender: ReminderSender,
    ) -> None:
        self._session_factory = session_factory
        self._config_store = config_store
        self._log_store = log_store
        self._sender = sender

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Config
    # ------------------------------------------------------------------ #
    def get_config(self, hostel_id: UUID) -> ReminderConfig:
        record = self._config_store.get_config(hostel_id)
        if record:
            return ReminderConfig.model_validate(record)

        cfg = ReminderConfig(
            id=None,
            created_at=None,
            updated_at=None,
            hostel_id=hostel_id,
        )
        self._config_store.save_config(hostel_id, cfg.model_dump())
        return cfg

    def set_config(self, cfg: ReminderConfig) -> None:
        self._config_store.save_config(cfg.hostel_id, cfg.model_dump())

    # ------------------------------------------------------------------ #
    # Sending
    # ------------------------------------------------------------------ #
    def send_reminders(self, req: SendReminderRequest) -> ReminderBatch:
        """
        Send reminders based on filters in SendReminderRequest.

        This is a simplified implementation that:
        - Finds PENDING payments (optionally overdue-only).
        - Sends reminders via configured channels.
        - Logs ReminderLog entries.
        """
        now = self._now()
        batch_id = uuid4()

        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            student_repo = self._get_student_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            payments = self._select_target_payments(uow, req)
            total_payments = len(payments)

            reminders_sent = reminders_failed = 0
            email_sent = sms_sent = push_sent = 0

            for p in payments:
                if p.student_id is None:
                    continue
                st = student_repo.get(p.student_id)
                if st is None or not getattr(st, "user", None):
                    continue
                user = st.user
                subject = "Payment Reminder"
                base_message = req.custom_message or "You have a pending payment."

                for ch in req.channels:
                    ok = self._sender.send(
                        student_id=st.id,
                        student_email=user.email,
                        student_phone=getattr(user, "phone", ""),
                        channel=ch,
                        subject=subject if ch == "email" else None,
                        message=base_message,
                    )
                    if ok:
                        reminders_sent += 1
                        if ch == "email":
                            email_sent += 1
                        elif ch == "sms":
                            sms_sent += 1
                        elif ch == "push":
                            push_sent += 1
                        self._log_reminder(
                            p=p,
                            student=st,
                            user=user,
                            reminder_type=req.reminder_type,
                            channel=ch,
                            message_preview=base_message[:100],
                        )
                    else:
                        reminders_failed += 1

        return ReminderBatch(
            batch_id=batch_id,
            total_payments=total_payments,
            reminders_sent=reminders_sent,
            reminders_failed=reminders_failed,
            email_sent=email_sent,
            sms_sent=sms_sent,
            push_sent=push_sent,
            started_at=now,
            completed_at=self._now(),
            status="completed",
        )

    # Helpers for sending
    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _select_target_payments(
        self,
        uow: UnitOfWork,
        req: SendReminderRequest,
    ) -> List:
        pay_repo = self._get_payment_repo(uow)

        filters: Dict[str, object] = {"payment_status": PaymentStatus.PENDING}
        if req.payment_id:
            filters["id"] = req.payment_id
        if req.student_id:
            filters["student_id"] = req.student_id
        if req.hostel_id:
            filters["hostel_id"] = req.hostel_id

        payments = pay_repo.get_multi(
            skip=0,
            limit=None,  # type: ignore[arg-type]
            filters=filters,
        )
        # For overdue reminders, restrict to past-due
        if req.reminder_type in ("overdue", "final_notice"):
            today = date.today()
            payments = [p for p in payments if p.due_date and p.due_date < today]
        return list(payments)

    def _log_reminder(
        self,
        *,
        p,
        student,
        user,
        reminder_type: str,
        channel: str,
        message_preview: str,
    ) -> None:
        record = {
            "id": uuid4(),
            "created_at": self._now(),
            "updated_at": self._now(),
            "payment_id": p.id,
            "payment_reference": str(p.id),
            "student_id": student.id,
            "student_name": user.full_name,
            "student_email": user.email,
            "student_phone": getattr(user, "phone", ""),
            "reminder_type": reminder_type,
            "reminder_channel": channel,
            "sent_at": self._now(),
            "delivery_status": "sent",
            "subject": None,
            "message_preview": message_preview,
            "opened": False,
            "clicked": False,
        }
        self._log_store.save_log(record)

    # ------------------------------------------------------------------ #
    # Stats
    # ------------------------------------------------------------------ #
    def get_stats(self, hostel_id: UUID, *, period_start: date, period_end: date) -> ReminderStats:
        logs = self._log_store.list_logs_for_period(hostel_id, period_start, period_end)
        total = len(logs)

        due_soon = sum(1 for l in logs if l.get("reminder_type") == "due_soon")
        overdue = sum(1 for l in logs if l.get("reminder_type") == "overdue")
        final_notice = sum(1 for l in logs if l.get("reminder_type") == "final_notice")

        email_count = sum(1 for l in logs if l.get("reminder_channel") == "email")
        sms_count = sum(1 for l in logs if l.get("reminder_channel") == "sms")
        push_count = sum(1 for l in logs if l.get("reminder_channel") == "push")

        # Effectiveness metrics require link to payments;
        # here we just return zeros as placeholders.
        return ReminderStats(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
            total_reminders_sent=total,
            due_soon_reminders=due_soon,
            overdue_reminders=overdue,
            final_notices=final_notice,
            email_reminders=email_count,
            sms_reminders=sms_count,
            push_reminders=push_count,
            payment_rate_after_reminder=Decimal("0"),
            average_days_to_payment=Decimal("0"),
        )

# --- File: D:\hostel-management-saas\app\services\payment\payment_reporting_service.py ---
# app/services/payment/payment_reporting_service.py
from __future__ import annotations

from collections import defaultdict
from datetime import date
from decimal import Decimal
from typing import Callable, Dict, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import PaymentRepository
from app.schemas.common.enums import PaymentStatus
from app.schemas.payment.payment_filters import PaymentReportRequest
from app.services.common import UnitOfWork, errors


class PaymentReportingService:
    """
    Payment reporting and aggregation:

    - Build grouped aggregates for PaymentReportRequest
      (by day/week/month/payment_type/payment_method).
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def build_report(self, req: PaymentReportRequest) -> Dict[str, object]:
        """
        Return a simple dict-based report structure for the given request.

        Structure example:
        {
            "hostel_id": ...,
            "period": {"from": ..., "to": ...},
            "group_by": "day",
            "totals": {...},
            "groups": [
                {"key": "...", "total_amount": ..., "count": ..., "completed": ...},
                ...
            ],
        }
        """
        if req.date_from > req.date_to:
            raise errors.ValidationError("date_from must be <= date_to")

        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_payment_repo(uow)

            filters: Dict[str, object] = {}
            if req.hostel_id:
                filters["hostel_id"] = req.hostel_id
            if req.payment_types:
                filters["payment_type"] = req.payment_types
            if req.payment_methods:
                filters["payment_method"] = req.payment_methods

            payments = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

        # Time filter on paid_at or created_at
        in_period = []
        for p in payments:
            d = p.paid_at.date() if p.paid_at else p.created_at.date()
            if req.date_from <= d <= req.date_to:
                in_period.append(p)

        total_amount = Decimal("0")
        total_count = 0
        total_completed = 0

        for p in in_period:
            total_amount += p.amount
            total_count += 1
            if p.payment_status == PaymentStatus.COMPLETED:
                total_completed += 1

        groups = self._group_payments(in_period, req.group_by)

        return {
            "hostel_id": req.hostel_id,
            "period": {"from": req.date_from, "to": req.date_to},
            "group_by": req.group_by,
            "totals": {
                "total_amount": total_amount,
                "total_count": total_count,
                "completed_count": total_completed,
            },
            "groups": groups,
        }

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _group_payments(self, payments: List, group_by: str) -> List[Dict[str, object]]:
        buckets: Dict[str, Dict[str, object]] = {}

        for p in payments:
            d = p.paid_at.date() if p.paid_at else p.created_at.date()
            if group_by == "day":
                key = d.isoformat()
            elif group_by == "week":
                iso_year, iso_week, _ = d.isocalendar()
                key = f"{iso_year}-W{iso_week:02d}"
            elif group_by == "month":
                key = d.strftime("%Y-%m")
            elif group_by == "payment_type":
                key = p.payment_type.value if hasattr(p.payment_type, "value") else str(p.payment_type)
            elif group_by == "payment_method":
                key = p.payment_method.value if hasattr(p.payment_method, "value") else str(p.payment_method)
            else:
                key = "other"

            bucket = buckets.setdefault(
                key,
                {
                    "key": key,
                    "total_amount": Decimal("0"),
                    "count": 0,
                    "completed": 0,
                },
            )
            bucket["total_amount"] += p.amount
            bucket["count"] += 1
            if p.payment_status == PaymentStatus.COMPLETED:
                bucket["completed"] += 1

        return list(buckets.values())

# --- File: D:\hostel-management-saas\app\services\payment\payment_request_service.py ---
# app/services/payment/payment_request_service.py
from __future__ import annotations

from datetime import datetime
from typing import Callable, Optional
from uuid import UUID, uuid4

from sqlalchemy.orm import Session

from app.repositories.transactions import PaymentRepository
from app.repositories.core import HostelRepository, StudentRepository, UserRepository
from app.schemas.common.enums import PaymentStatus
from app.schemas.payment import (
    PaymentRequest,
    PaymentInitiation,
    ManualPaymentRequest,
)
from app.services.common import UnitOfWork, errors
from app.services.payment.payment_gateway_service import PaymentGatewayService


class PaymentRequestService:
    """
    High-level payment initiation:

    - Online payment initiation (gateway-based)
    - Manual payment recording (cash/cheque/bank_transfer)
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        gateway_service: PaymentGatewayService,
    ) -> None:
        self._session_factory = session_factory
        self._gateway = gateway_service

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Online payment
    # ------------------------------------------------------------------ #
    def initiate_online_payment(self, data: PaymentRequest) -> PaymentInitiation:
        """
        Create a Payment record with PENDING status and build a gateway order.

        The returned PaymentInitiation contains gateway details for client-side checkout.
        """
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            if data.student_id:
                st = student_repo.get(data.student_id)
                if st is None:
                    raise errors.NotFoundError(f"Student {data.student_id} not found")

            # For online payments, payer is the student.user or direct user later; here we reuse student_id
            payer_id: UUID = data.student_id or UUID(int=0)

            payload = {
                "payer_id": payer_id,
                "hostel_id": data.hostel_id,
                "student_id": data.student_id,
                "booking_id": data.booking_id,
                "payment_type": data.payment_type,
                "amount": data.amount,
                "currency": "INR",
                "payment_period_start": data.payment_period_start,
                "payment_period_end": data.payment_period_end,
                "payment_method": data.payment_method,
                "payment_gateway": data.payment_gateway,
                "payment_status": PaymentStatus.PENDING,
                "due_date": None,
            }
            payment = pay_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

        # Outside UnitOfWork: build gateway request and order
        order_id = f"ORD-{payment.id}"
        description = f"{data.payment_type.value if hasattr(data.payment_type,'value') else str(data.payment_type)}"
        gw_req = self._gateway.build_gateway_request(
            payment_id=payment.id,
            order_id=order_id,
            description=description,
            callback_url=data.success_url or "",
            success_url=data.success_url,
            failure_url=data.failure_url,
        )
        gw_resp = self._gateway.create_gateway_order(gw_req)

        return PaymentInitiation(
            payment_id=payment.id,
            payment_reference=str(payment.id),
            amount=payment.amount,
            currency=payment.currency,
            gateway=data.payment_gateway,
            gateway_order_id=gw_resp.gateway_order_id,
            gateway_key="",
            checkout_url=None,
            checkout_token=None,
            gateway_options=gw_resp.gateway_response,
        )

    # ------------------------------------------------------------------ #
    # Manual payments
    # ------------------------------------------------------------------ #
    def record_manual_payment(self, data: ManualPaymentRequest) -> UUID:
        """
        Record a manual payment (cash/cheque/bank_transfer) as COMPLETED.
        Returns the new Payment.id.
        """
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            st = student_repo.get(data.student_id)
            if st is None:
                raise errors.NotFoundError(f"Student {data.student_id} not found")

            payer_id = st.user_id

            payload = {
                "payer_id": payer_id,
                "hostel_id": data.hostel_id,
                "student_id": data.student_id,
                "booking_id": None,
                "payment_type": data.payment_type,
                "amount": data.amount,
                "currency": "INR",
                "payment_period_start": data.payment_period_start,
                "payment_period_end": data.payment_period_end,
                "payment_method": data.payment_method,
                "payment_gateway": None,
                "payment_status": PaymentStatus.COMPLETED,
                "transaction_id": data.transaction_reference,
                "due_date": None,
                "paid_at": datetime.combine(data.collection_date, datetime.min.time()),
                "failure_reason": None,
            }
            p = pay_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()
            return p.id

# --- File: D:\hostel-management-saas\app\services\payment\payment_schedule_service.py ---
# app/services/payment/payment_schedule_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Protocol
from uuid import UUID, uuid4

from sqlalchemy.orm import Session

from app.repositories.transactions import PaymentRepository
from app.repositories.core import HostelRepository, StudentRepository
from app.schemas.common.enums import FeeType, PaymentType, PaymentMethod, PaymentStatus
from app.schemas.payment.payment_schedule import (
    PaymentSchedule,
    ScheduleCreate,
    ScheduleUpdate,
    ScheduleGeneration,
    ScheduledPaymentGenerated,
)
from app.services.common import UnitOfWork, errors


class ScheduleStore(Protocol):
    """
    Storage for payment schedules (PaymentSchedule-like dicts).
    """

    def get_schedule(self, schedule_id: UUID) -> Optional[dict]: ...
    def save_schedule(self, schedule_id: UUID, data: dict) -> None: ...
    def list_schedules_for_student(self, student_id: UUID) -> List[dict]: ...


class PaymentScheduleService:
    """
    Payment schedules:

    - Create/update schedules
    - Fetch schedule
    - Generate scheduled payments via PaymentRepository
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: ScheduleStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _period_months(self, fee_type: FeeType) -> int:
        mapping = {
            FeeType.MONTHLY: 1,
            FeeType.QUARTERLY: 3,
            FeeType.HALF_YEARLY: 6,
            FeeType.YEARLY: 12,
        }
        return mapping.get(fee_type, 1)

    def _add_months(self, d: date, months: int) -> date:
        month = d.month - 1 + months
        year = d.year + month // 12
        month = month % 12 + 1
        day = min(
            d.day,
            [31, 29 if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0) else 28,
             31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1],
        )
        return date(year, month, day)

    # ------------------------------------------------------------------ #
    # CRUD
    # ------------------------------------------------------------------ #
    def create_schedule(self, data: ScheduleCreate) -> PaymentSchedule:
        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            student = student_repo.get(data.student_id)
            if student is None or not getattr(student, "user", None):
                raise errors.NotFoundError(f"Student {data.student_id} not found")

            schedule_id = uuid4()
            record = {
                "id": schedule_id,
                "created_at": None,
                "updated_at": None,
                "student_id": data.student_id,
                "student_name": student.user.full_name,
                "hostel_id": data.hostel_id,
                "hostel_name": hostel.name,
                "fee_type": data.fee_type,
                "amount": data.amount,
                "start_date": data.start_date,
                "end_date": data.end_date,
                "next_due_date": data.first_due_date,
                "auto_generate_invoice": data.auto_generate_invoice,
                "is_active": True,
            }
            self._store.save_schedule(schedule_id, record)
            return PaymentSchedule.model_validate(record)

    def get_schedule(self, schedule_id: UUID) -> PaymentSchedule:
        record = self._store.get_schedule(schedule_id)
        if not record:
            raise errors.NotFoundError(f"PaymentSchedule {schedule_id} not found")
        return PaymentSchedule.model_validate(record)

    def update_schedule(self, schedule_id: UUID, data: ScheduleUpdate) -> PaymentSchedule:
        record = self._store.get_schedule(schedule_id)
        if not record:
            raise errors.NotFoundError(f"PaymentSchedule {schedule_id} not found")

        mapping = data.model_dump(exclude_unset=True)
        for field, value in mapping.items():
            record[field] = value
        self._store.save_schedule(schedule_id, record)
        return PaymentSchedule.model_validate(record)

    # ------------------------------------------------------------------ #
    # Generation
    # ------------------------------------------------------------------ #
    def generate_scheduled_payments(self, data: ScheduleGeneration) -> ScheduledPaymentGenerated:
        record = self._store.get_schedule(data.schedule_id)
        if not record:
            raise errors.NotFoundError(f"PaymentSchedule {data.schedule_id} not found")

        schedule = PaymentSchedule.model_validate(record)
        months = self._period_months(schedule.fee_type)

        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)

            payments_generated: List[UUID] = []
            payments_skipped = 0

            current_due = schedule.next_due_date
            while current_due <= data.generate_to_date:
                if current_due < data.generate_from_date:
                    current_due = self._add_months(current_due, months)
                    continue

                # Check if a payment already exists for this student & due_date
                existing = pay_repo.get_multi(
                    skip=0,
                    limit=1,
                    filters={
                        "student_id": schedule.student_id,
                        "hostel_id": schedule.hostel_id,
                        "due_date": current_due,
                    },
                )
                if existing and data.skip_if_already_paid:
                    payments_skipped += 1
                else:
                    payload = {
                        "payer_id": None,
                        "hostel_id": schedule.hostel_id,
                        "student_id": schedule.student_id,
                        "booking_id": None,
                        "payment_type": PaymentType.RENT,
                        "amount": schedule.amount,
                        "currency": "INR",
                        "payment_period_start": current_due,
                        "payment_period_end": None,
                        "payment_method": PaymentMethod.PAYMENT_GATEWAY,
                        "payment_gateway": "razorpay",
                        "payment_status": PaymentStatus.PENDING,
                        "due_date": current_due,
                    }
                    p = pay_repo.create(payload)  # type: ignore[arg-type]
                    payments_generated.append(p.id)

                current_due = self._add_months(current_due, months)

            # Update next_due_date on schedule
            record["next_due_date"] = current_due
            self._store.save_schedule(data.schedule_id, record)
            uow.commit()

        return ScheduledPaymentGenerated(
            schedule_id=data.schedule_id,
            payments_generated=len(payments_generated),
            payments_skipped=payments_skipped,
            generated_payment_ids=payments_generated,
            next_generation_date=record["next_due_date"],
        )

# --- File: D:\hostel-management-saas\app\services\payment\payment_service.py ---
# app/services/payment/payment_service.py
from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import PaymentRepository
from app.repositories.core import HostelRepository, StudentRepository, UserRepository
from app.schemas.common.enums import PaymentStatus
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.payment import (
    PaymentCreate,
    PaymentUpdate,
    PaymentResponse,
    PaymentDetail,
    PaymentListItem,
    PaymentSummary,
)
from app.schemas.payment.payment_filters import (
    PaymentFilterParams,
    PaymentSearchRequest,
)
from app.services.common import UnitOfWork, errors


class PaymentService:
    """
    Core payment service:

    - Create / update payments
    - Retrieve payment detail
    - List & search payments (with filters)
    - Summaries per student / hostel
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    def _is_overdue(self, p) -> bool:
        if p.payment_status != PaymentStatus.PENDING:
            return False
        if not p.due_date:
            return False
        return p.due_date < date.today()

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_response(
        self,
        p,
        *,
        payer_name: str,
        hostel_name: str,
    ) -> PaymentResponse:
        return PaymentResponse(
            id=p.id,
            created_at=p.created_at,
            updated_at=p.updated_at,
            payment_reference=str(p.id),
            transaction_id=p.transaction_id,
            payer_id=p.payer_id,
            payer_name=payer_name,
            hostel_id=p.hostel_id,
            hostel_name=hostel_name,
            payment_type=p.payment_type,
            amount=p.amount,
            currency=p.currency,
            payment_method=p.payment_method,
            payment_status=p.payment_status,
            paid_at=p.paid_at,
            due_date=p.due_date,
            is_overdue=self._is_overdue(p),
            receipt_number=p.receipt_number,
            receipt_url=p.receipt_url,
        )

    def _to_detail(
        self,
        p,
        *,
        payer_name: str,
        payer_email: str,
        payer_phone: str,
        hostel_name: str,
        student_name: Optional[str],
        booking_reference: Optional[str],
        collected_by_name: Optional[str],
    ) -> PaymentDetail:
        is_overdue = self._is_overdue(p)

        return PaymentDetail(
            id=p.id,
            created_at=p.created_at,
            updated_at=p.updated_at,
            payment_reference=str(p.id),
            transaction_id=p.transaction_id,
            payer_id=p.payer_id,
            payer_name=payer_name,
            payer_email=payer_email,
            payer_phone=payer_phone,
            hostel_id=p.hostel_id,
            hostel_name=hostel_name,
            student_id=p.student_id,
            student_name=student_name,
            booking_id=p.booking_id,
            booking_reference=booking_reference,
            payment_type=p.payment_type,
            amount=p.amount,
            currency=p.currency,
            payment_period_start=p.payment_period_start,
            payment_period_end=p.payment_period_end,
            payment_method=p.payment_method,
            payment_gateway=p.payment_gateway,
            payment_status=p.payment_status,
            paid_at=p.paid_at,
            failed_at=p.failed_at,
            failure_reason=p.failure_reason,
            gateway_response=None,
            receipt_number=p.receipt_number,
            receipt_url=p.receipt_url,
            receipt_generated_at=None,
            refund_amount=Decimal("0"),
            refund_status="none",
            refunded_at=None,
            refund_transaction_id=None,
            refund_reason=None,
            collected_by=None,
            collected_by_name=collected_by_name,
            collected_at=None,
            due_date=p.due_date,
            is_overdue=is_overdue,
            reminder_sent_count=0,
            last_reminder_sent_at=None,
        )

    def _to_list_item(
        self,
        p,
        *,
        payer_name: str,
        hostel_name: str,
    ) -> PaymentListItem:
        return PaymentListItem(
            id=p.id,
            payment_reference=str(p.id),
            payer_name=payer_name,
            hostel_name=hostel_name,
            payment_type=p.payment_type.value if hasattr(p.payment_type, "value") else str(p.payment_type),
            amount=p.amount,
            payment_method=p.payment_method.value
            if hasattr(p.payment_method, "value")
            else str(p.payment_method),
            payment_status=p.payment_status,
            paid_at=p.paid_at,
            due_date=p.due_date,
            is_overdue=self._is_overdue(p),
            created_at=p.created_at,
        )

    # ------------------------------------------------------------------ #
    # Core read
    # ------------------------------------------------------------------ #
    def get_payment(self, payment_id: UUID) -> PaymentDetail:
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)
            user_repo = self._get_user_repo(uow)

            p = pay_repo.get(payment_id)
            if p is None:
                raise errors.NotFoundError(f"Payment {payment_id} not found")

            payer = user_repo.get(p.payer_id)
            if payer is None:
                raise errors.NotFoundError(f"Payer user {p.payer_id} not found")
            payer_name = payer.full_name
            payer_email = payer.email
            payer_phone = getattr(payer, "phone", "")

            hostel = hostel_repo.get(p.hostel_id)
            hostel_name = hostel.name if hostel else ""

            student_name = None
            if p.student_id:
                st = student_repo.get(p.student_id)
                if st and getattr(st, "user", None):
                    student_name = st.user.full_name

            booking_reference = None
            collected_by_name = None

            return self._to_detail(
                p,
                payer_name=payer_name,
                payer_email=payer_email,
                payer_phone=payer_phone,
                hostel_name=hostel_name,
                student_name=student_name,
                booking_reference=booking_reference,
                collected_by_name=collected_by_name,
            )

    # ------------------------------------------------------------------ #
    # Create / update
    # ------------------------------------------------------------------ #
    def create_payment(self, data: PaymentCreate) -> PaymentDetail:
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)
            user_repo = self._get_user_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            payer = user_repo.get(data.payer_id)
            if payer is None:
                raise errors.NotFoundError(f"Payer user {data.payer_id} not found")

            payload = {
                "payer_id": data.payer_id,
                "hostel_id": data.hostel_id,
                "student_id": data.student_id,
                "booking_id": data.booking_id,
                "payment_type": data.payment_type,
                "amount": data.amount,
                "currency": data.currency,
                "payment_period_start": data.payment_period_start,
                "payment_period_end": data.payment_period_end,
                "payment_method": data.payment_method,
                "payment_gateway": data.payment_gateway,
                "payment_status": PaymentStatus.PENDING,
                "transaction_id": data.transaction_id,
                "due_date": data.due_date,
            }
            p = pay_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            student_name = None
            if p.student_id:
                st = student_repo.get(p.student_id)
                if st and getattr(st, "user", None):
                    student_name = st.user.full_name

            return self._to_detail(
                p,
                payer_name=payer.full_name,
                payer_email=payer.email,
                payer_phone=getattr(payer, "phone", ""),
                hostel_name=hostel.name,
                student_name=student_name,
                booking_reference=None,
                collected_by_name=None,
            )

    def update_payment(
        self,
        payment_id: UUID,
        data: PaymentUpdate,
    ) -> PaymentDetail:
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)

            p = pay_repo.get(payment_id)
            if p is None:
                raise errors.NotFoundError(f"Payment {payment_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(p, field) and field != "id":
                    setattr(p, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return self.get_payment(payment_id)

    # ------------------------------------------------------------------ #
    # Listing & filters
    # ------------------------------------------------------------------ #
    def list_payments(
        self,
        params: PaginationParams,
        filters: Optional[PaymentFilterParams] = None,
    ) -> PaginatedResponse[PaymentListItem]:
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            raw_filters: Dict[str, object] = {}
            if filters:
                if filters.hostel_id:
                    raw_filters["hostel_id"] = filters.hostel_id
                elif filters.hostel_ids:
                    raw_filters["hostel_id"] = filters.hostel_ids
                if filters.student_id:
                    raw_filters["student_id"] = filters.student_id
                if filters.payer_id:
                    raw_filters["payer_id"] = filters.payer_id
                if filters.payment_type:
                    raw_filters["payment_type"] = filters.payment_type
                elif filters.payment_types:
                    raw_filters["payment_type"] = filters.payment_types
                if filters.payment_method:
                    raw_filters["payment_method"] = filters.payment_method
                elif filters.payment_methods:
                    raw_filters["payment_method"] = filters.payment_methods
                if filters.payment_status:
                    raw_filters["payment_status"] = filters.payment_status
                elif filters.payment_statuses:
                    raw_filters["payment_status"] = filters.payment_statuses
                if filters.payment_gateway:
                    raw_filters["payment_gateway"] = filters.payment_gateway

            records: Sequence = pay_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=raw_filters or None,
                order_by=[pay_repo.model.created_at.desc()],  # type: ignore[attr-defined]
            )

            def _matches_advanced(p) -> bool:
                if not filters:
                    return True

                # Amount range
                if filters.amount_min is not None and p.amount < filters.amount_min:
                    return False
                if filters.amount_max is not None and p.amount > filters.amount_max:
                    return False

                # Paid date range
                if filters.paid_date_from or filters.paid_date_to:
                    if not p.paid_at:
                        return False
                    d = p.paid_at.date()
                    if filters.paid_date_from and d < filters.paid_date_from:
                        return False
                    if filters.paid_date_to and d > filters.paid_date_to:
                        return False

                # Due date range
                if filters.due_date_from or filters.due_date_to:
                    if not p.due_date:
                        return False
                    d = p.due_date
                    if filters.due_date_from and d < filters.due_date_from:
                        return False
                    if filters.due_date_to and d > filters.due_date_to:
                        return False

                # Created date range
                if filters.created_date_from or filters.created_date_to:
                    d = p.created_at.date()
                    if filters.created_date_from and d < filters.created_date_from:
                        return False
                    if filters.created_date_to and d > filters.created_date_to:
                        return False

                # Overdue
                if filters.overdue_only:
                    if not self._is_overdue(p):
                        return False

                return True

            filtered = [p for p in records if _matches_advanced(p)]

            # Text search requires payer / hostel names or transaction_id
            if filters and filters.search:
                q = filters.search.lower()
                user_cache: Dict[UUID, str] = {}
                hostel_cache: Dict[UUID, str] = {}
                tmp: List = []
                for p in filtered:
                    if p.payer_id not in user_cache:
                        u = user_repo.get(p.payer_id)
                        user_cache[p.payer_id] = u.full_name if u else ""
                    if p.hostel_id not in hostel_cache:
                        h = hostel_repo.get(p.hostel_id)
                        hostel_cache[p.hostel_id] = h.name if h else ""

                    haystack = " ".join(
                        [
                            str(p.id),
                            p.transaction_id or "",
                            user_cache[p.payer_id],
                            hostel_cache[p.hostel_id],
                        ]
                    ).lower()
                    if q in haystack:
                        tmp.append(p)
                filtered = tmp

            total = len(filtered)
            start = params.offset
            end = start + params.limit
            page_records = filtered[start:end]

            user_cache: Dict[UUID, str] = {}
            hostel_cache: Dict[UUID, str] = {}

            items: List[PaymentListItem] = []
            for p in page_records:
                if p.payer_id not in user_cache:
                    u = user_repo.get(p.payer_id)
                    user_cache[p.payer_id] = u.full_name if u else ""
                if p.hostel_id not in hostel_cache:
                    h = hostel_repo.get(p.hostel_id)
                    hostel_cache[p.hostel_id] = h.name if h else ""
                items.append(
                    self._to_list_item(
                        p,
                        payer_name=user_cache[p.payer_id],
                        hostel_name=hostel_cache[p.hostel_id],
                    )
                )

            return PaginatedResponse[PaymentListItem].create(
                items=items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    def search_payments(
        self,
        params: PaginationParams,
        req: PaymentSearchRequest,
    ) -> PaginatedResponse[PaymentListItem]:
        """
        Simple search on reference/payer_name/transaction_id within a hostel.
        """
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            filters: Dict[str, object] = {}
            if req.hostel_id:
                filters["hostel_id"] = req.hostel_id
            if req.payment_status:
                filters["payment_status"] = req.payment_status

            records: Sequence = pay_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

            q = req.query.lower()
            user_cache: Dict[UUID, str] = {}
            hostel_cache: Dict[UUID, str] = {}

            def _matches(p) -> bool:
                if p.payer_id not in user_cache:
                    u = user_repo.get(p.payer_id)
                    user_cache[p.payer_id] = u.full_name if u else ""
                if p.hostel_id not in hostel_cache:
                    h = hostel_repo.get(p.hostel_id)
                    hostel_cache[p.hostel_id] = h.name if h else ""

                terms: List[str] = []
                if req.search_in_reference:
                    terms.append(str(p.id))
                if req.search_in_payer_name:
                    terms.append(user_cache[p.payer_id])
                if req.search_in_transaction_id and p.transaction_id:
                    terms.append(p.transaction_id)

                text = " ".join(terms).lower()
                return q in text

            matched = [p for p in records if _matches(p)]

            def _sort_key(p) -> datetime:
                return p.paid_at or p.created_at

            matched_sorted = sorted(matched, key=_sort_key, reverse=True)
            start = params.offset
            end = start + params.limit
            page_records = matched_sorted[start:end]

            items: List[PaymentListItem] = []
            for p in page_records:
                items.append(
                    self._to_list_item(
                        p,
                        payer_name=user_cache[p.payer_id],
                        hostel_name=hostel_cache[p.hostel_id],
                    )
                )

            return PaginatedResponse[PaymentListItem].create(
                items=items,
                total_items=len(matched_sorted),
                page=params.page,
                page_size=params.page_size,
            )

    # ------------------------------------------------------------------ #
    # Summaries
    # ------------------------------------------------------------------ #
    def get_summary_for_student(self, student_id: UUID) -> PaymentSummary:
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)

            records = pay_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"student_id": student_id},
            )

        total_paid = Decimal("0")
        total_pending = Decimal("0")
        total_overdue = Decimal("0")
        last_payment_date: Optional[date] = None
        last_payment_amount: Optional[Decimal] = None
        next_payment_due_date: Optional[date] = None
        next_payment_amount: Optional[Decimal] = None

        completed = pending = 0

        for p in records:
            if p.payment_status == PaymentStatus.COMPLETED and p.paid_at:
                total_paid += p.amount
                completed += 1
                d = p.paid_at.date()
                if not last_payment_date or d > last_payment_date:
                    last_payment_date = d
                    last_payment_amount = p.amount
            elif p.payment_status == PaymentStatus.PENDING:
                total_pending += p.amount
                pending += 1
                if self._is_overdue(p):
                    total_overdue += p.amount
                if p.due_date:
                    if not next_payment_due_date or p.due_date < next_payment_due_date:
                        next_payment_due_date = p.due_date
                        next_payment_amount = p.amount

        return PaymentSummary(
            entity_id=student_id,
            entity_type="student",
            total_paid=total_paid,
            total_pending=total_pending,
            total_overdue=total_overdue,
            last_payment_date=last_payment_date,
            last_payment_amount=last_payment_amount,
            next_payment_due_date=next_payment_due_date,
            next_payment_amount=next_payment_amount,
            total_payments=len(records),
            completed_payments=completed,
            pending_payments=pending,
        )

    def get_summary_for_hostel(self, hostel_id: UUID) -> PaymentSummary:
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)

            records = pay_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

        total_paid = Decimal("0")
        total_pending = Decimal("0")
        total_overdue = Decimal("0")
        last_payment_date: Optional[date] = None
        last_payment_amount: Optional[Decimal] = None
        next_payment_due_date: Optional[date] = None
        next_payment_amount: Optional[Decimal] = None

        completed = pending = 0

        for p in records:
            if p.payment_status == PaymentStatus.COMPLETED and p.paid_at:
                total_paid += p.amount
                completed += 1
                d = p.paid_at.date()
                if not last_payment_date or d > last_payment_date:
                    last_payment_date = d
                    last_payment_amount = p.amount
            elif p.payment_status == PaymentStatus.PENDING:
                total_pending += p.amount
                pending += 1
                if self._is_overdue(p):
                    total_overdue += p.amount
                if p.due_date:
                    if not next_payment_due_date or p.due_date < next_payment_due_date:
                        next_payment_due_date = p.due_date
                        next_payment_amount = p.amount

        return PaymentSummary(
            entity_id=hostel_id,
            entity_type="hostel",
            total_paid=total_paid,
            total_pending=total_pending,
            total_overdue=total_overdue,
            last_payment_date=last_payment_date,
            last_payment_amount=last_payment_amount,
            next_payment_due_date=next_payment_due_date,
            next_payment_amount=next_payment_amount,
            total_payments=len(records),
            completed_payments=completed,
            pending_payments=pending,
        )

# --- File: D:\hostel-management-saas\app\services\payment\refund_service.py ---
# app/services/payment/refund_service.py
from __future__ import annotations

from datetime import datetime, timezone, date
from decimal import Decimal
from typing import List, Optional, Protocol
from uuid import UUID, uuid4

from app.repositories.transactions import PaymentRepository
from app.schemas.payment.payment_refund import (
    RefundRequest,
    RefundResponse,
    RefundStatus,
    RefundApproval,
    RefundList,
    RefundListItem,
)
from app.services.common import UnitOfWork, errors
from sqlalchemy.orm import Session


class RefundStore(Protocol):
    """
    Storage for refund records.

    Expected record keys (example):
        {
            "refund_id": UUID,
            "payment_id": UUID,
            "payment_reference": str,
            "refund_amount": Decimal,
            "refund_status": str,
            "refund_method": str,
            "refund_reference": str | None,
            "requested_at": datetime,
            "processed_at": datetime | None,
            "completed_at": datetime | None,
            "estimated_completion_date": date | None,
            "refunded_to": str,
        }
    """

    def save_refund(self, record: dict) -> dict: ...
    def get_refund(self, refund_id: UUID) -> Optional[dict]: ...
    def update_refund(self, refund_id: UUID, data: dict) -> dict: ...
    def list_refunds(self) -> List[dict]: ...


class RefundService:
    """
    Refund management:

    - Create refund requests
    - Track refund status
    - Approve/reject refunds
    - Simple listing
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: RefundStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    # ------------------------------------------------------------------ #
    # Create / approve
    # ------------------------------------------------------------------ #
    def create_refund(self, data: RefundRequest) -> RefundResponse:
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)

            p = pay_repo.get(data.payment_id)
            if p is None:
                raise errors.NotFoundError(f"Payment {data.payment_id} not found")

            if data.refund_amount > p.amount:
                raise errors.ValidationError("Refund amount cannot exceed payment amount")

            refund_id = uuid4()
            now = self._now()

            record = {
                "refund_id": refund_id,
                "payment_id": p.id,
                "payment_reference": str(p.id),
                "refund_amount": data.refund_amount,
                "refund_status": "pending",
                "refund_method": data.refund_method,
                "refund_reference": None,
                "requested_at": now,
                "processed_at": None,
                "completed_at": None,
                "estimated_completion_date": None,
                "refunded_to": "original_source",
            }
            self._store.save_refund(record)

        return RefundResponse(
            id=refund_id,
            created_at=now,
            updated_at=now,
            refund_id=refund_id,
            payment_id=p.id,
            payment_reference=str(p.id),
            refund_amount=data.refund_amount,
            refund_status="pending",
            refund_method=data.refund_method,
            refund_reference=None,
            requested_at=now,
            processed_at=None,
            completed_at=None,
            estimated_completion_date=None,
            refunded_to="original_source",
            message="Refund request created",
        )

    def approve_refund(self, data: RefundApproval) -> RefundStatus:
        record = self._store.get_refund(data.refund_id)
        if not record:
            raise errors.NotFoundError(f"Refund {data.refund_id} not found")

        now = self._now()

        if not data.approved:
            record["refund_status"] = "failed"
            record["failure_reason"] = data.rejection_reason or "Refund rejected"
            record["completed_at"] = now
        else:
            record["refund_status"] = "processing"
            record["processing_started_at"] = now

        self._store.update_refund(data.refund_id, record)

        return RefundStatus(
            refund_id=data.refund_id,
            payment_reference=record["payment_reference"],
            refund_amount=record["refund_amount"],
            currency="INR",
            status=record["refund_status"],
            requested_at=record["requested_at"],
            processing_started_at=record.get("processing_started_at"),
            completed_at=record.get("completed_at"),
            days_since_request=(now.date() - record["requested_at"].date()).days,
            failure_reason=record.get("failure_reason"),
            next_action=None,
            expected_completion_date=record.get("estimated_completion_date"),
        )

    # ------------------------------------------------------------------ #
    # Listing
    # ------------------------------------------------------------------ #
    def list_refunds(self) -> RefundList:
        records = self._store.list_refunds()
        total_amount = sum(
            Decimal(str(r.get("refund_amount"))) for r in records
        ) if records else Decimal("0")

        items: List[RefundListItem] = []
        for r in records:
            items.append(
                RefundListItem(
                    refund_id=r["refund_id"],
                    payment_reference=r["payment_reference"],
                    student_name="",
                    refund_amount=r["refund_amount"],
                    status=r["refund_status"],
                    requested_at=r["requested_at"],
                    completed_at=r.get("completed_at"),
                )
            )

        return RefundList(
            total_refunds=len(records),
            total_amount_refunded=total_amount,
            refunds=items,
        )

# --- File: D:\hostel-management-saas\app\services\payment\__init__.py ---
# app/services/payment/__init__.py
"""
Payment-related services.

- PaymentService:
    Core CRUD, listing, search and summaries for payments.

- PaymentGatewayService:
    Gateway-facing operations (callbacks, webhooks, refunds).

- PaymentRequestService:
    High-level flow for initiating online and manual payments.

- PaymentScheduleService:
    Student payment schedules and scheduled payment generation.

- PaymentReminderService:
    Reminder configuration and reminder sending/statistics.

- PaymentLedgerService:
    Ledger-style views and account statements per student.

- RefundService:
    Internal refund tracking and approval flow.

- PaymentReportingService:
    Aggregated reporting and grouping over payments.
"""

from .payment_service import PaymentService
from .payment_gateway_service import PaymentGatewayService
from .payment_request_service import PaymentRequestService
from .payment_schedule_service import PaymentScheduleService, ScheduleStore
from .payment_reminder_service import PaymentReminderService, ReminderConfigStore, ReminderLogStore
from .payment_ledger_service import PaymentLedgerService
from .refund_service import RefundService, RefundStore
from .payment_reporting_service import PaymentReportingService

__all__ = [
    "PaymentService",
    "PaymentGatewayService",
    "PaymentRequestService",
    "PaymentScheduleService",
    "ScheduleStore",
    "PaymentReminderService",
    "ReminderConfigStore",
    "ReminderLogStore",
    "PaymentLedgerService",
    "RefundService",
    "RefundStore",
    "PaymentReportingService",
]


# ===== Folder: D:\hostel-management-saas\app\services\rate_limiting =====

# --- File: D:\hostel-management-saas\app\services\rate_limiting\rate_limit_service.py ---


# --- File: D:\hostel-management-saas\app\services\rate_limiting\__init__.py ---



# ===== Folder: D:\hostel-management-saas\app\services\referral =====

# --- File: D:\hostel-management-saas\app\services\referral\referral_program_service.py ---
# app/services/referral/referral_program_service.py
from __future__ import annotations

from datetime import date
from typing import Callable, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import ReferralProgramRepository
from app.schemas.referral.referral_program_base import (
    ProgramCreate,
    ProgramUpdate,
)
from app.schemas.referral.referral_program_response import (
    ProgramResponse,
    ProgramList,
)
from app.services.common import UnitOfWork, errors


class ReferralProgramService:
    """
    Referral program management:

    - Create / update programs
    - Get single program
    - List active programs (optionally by date)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_repo(self, uow: UnitOfWork) -> ReferralProgramRepository:
        return uow.get_repo(ReferralProgramRepository)

    # ------------------------------------------------------------------ #
    # Mapping
    # ------------------------------------------------------------------ #
    def _to_response(self, p) -> ProgramResponse:
        return ProgramResponse(
            id=p.id,
            created_at=p.created_at,
            updated_at=p.updated_at,
            program_name=p.program_name,
            program_type=p.program_type,
            reward_type=p.reward_type,
            referrer_reward_amount=p.referrer_reward_amount,
            referee_reward_amount=p.referee_reward_amount,
            currency=p.currency,
            min_booking_amount=p.min_booking_amount,
            min_stay_months=p.min_stay_months,
            is_active=p.is_active,
            valid_from=p.valid_from,
            valid_to=p.valid_to,
            terms_and_conditions=p.terms_and_conditions,
        )

    # ------------------------------------------------------------------ #
    # CRUD
    # ------------------------------------------------------------------ #
    def create_program(self, data: ProgramCreate) -> ProgramResponse:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            payload = data.model_dump(exclude_unset=True)
            p = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()
            return self._to_response(p)

    def update_program(self, program_id: UUID, data: ProgramUpdate) -> ProgramResponse:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            p = repo.get(program_id)
            if p is None:
                raise errors.NotFoundError(f"ReferralProgram {program_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(p, field) and field != "id":
                    setattr(p, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return self._to_response(p)

    def get_program(self, program_id: UUID) -> ProgramResponse:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            p = repo.get(program_id)
            if p is None:
                raise errors.NotFoundError(f"ReferralProgram {program_id} not found")
            return self._to_response(p)

    def list_active_programs(self, as_of: Optional[date] = None) -> ProgramList:
        """
        List all active programs, optionally filtered by a date in their validity window.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            recs = repo.list_active(as_of=as_of)

        programs: List[ProgramResponse] = [self._to_response(p) for p in recs]
        return ProgramList(programs=programs)

# --- File: D:\hostel-management-saas\app\services\referral\referral_reward_service.py ---
# app/services/referral/referral_reward_service.py
from __future__ import annotations

from datetime import datetime, timezone
from decimal import Decimal
from typing import Dict, List, Optional, Protocol
from uuid import UUID, uuid4

from sqlalchemy.orm import Session

from app.repositories.transactions import ReferralRepository
from app.schemas.referral.referral_rewards import (
    RewardConfig,
    RewardTracking,
    PayoutRequest,
    PayoutRequestResponse,
)
from app.services.common import UnitOfWork, errors


class RewardConfigStore(Protocol):
    """
    Storage abstraction for global RewardConfig.
    """

    def get_config(self) -> Optional[dict]: ...
    def save_config(self, data: dict) -> None: ...


class PayoutStore(Protocol):
    """
    Storage abstraction for payout requests.

    Expected record shape (example):

        {
            "payout_request_id": UUID,
            "user_id": UUID,
            "amount": Decimal,
            "payout_method": PaymentMethod,
            "status": str,
            "requested_at": datetime,
            "processed_at": datetime | None,
            "failure_reason": str | None,
        }
    """

    def save_payout_request(self, record: dict) -> dict: ...
    def get_payout_request(self, payout_request_id: UUID) -> Optional[dict]: ...
    def update_payout_request(self, payout_request_id: UUID, data: dict) -> dict: ...


class ReferralRewardService:
    """
    Referral reward management:

    - Get/set RewardConfig
    - Compute RewardTracking for a user based on Referral records
    - Create payout requests
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        config_store: RewardConfigStore,
        payout_store: PayoutStore,
    ) -> None:
        self._session_factory = session_factory
        self._config_store = config_store
        self._payout_store = payout_store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_referral_repo(self, uow: UnitOfWork) -> ReferralRepository:
        return uow.get_repo(ReferralRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Config
    # ------------------------------------------------------------------ #
    def get_config(self) -> RewardConfig:
        record = self._config_store.get_config()
        if record:
            return RewardConfig.model_validate(record)
        cfg = RewardConfig()
        self._config_store.save_config(cfg.model_dump())
        return cfg

    def set_config(self, cfg: RewardConfig) -> None:
        self._config_store.save_config(cfg.model_dump())

    # ------------------------------------------------------------------ #
    # Tracking
    # ------------------------------------------------------------------ #
    def get_tracking_for_user(self, user_id: UUID) -> RewardTracking:
        """
        Aggregate rewards for a referrer using Referral records.

        - total_rewards_earned: sum of all referrer_reward_amount
        - total_rewards_paid: approximated based on reward_status strings
        - pending_rewards: earned - paid
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_referral_repo(uow)
            recs = repo.list_for_referrer(user_id)

        total_earned = Decimal("0")
        total_paid = Decimal("0")
        by_program: Dict[str, Decimal] = {}

        for r in recs:
            amt = r.referrer_reward_amount or Decimal("0")
            total_earned += amt

            prog_key = str(r.program_id)
            by_program[prog_key] = by_program.get(prog_key, Decimal("0")) + amt

            status_obj = getattr(r, "referrer_reward_status", None)
            status_str = getattr(status_obj, "value", str(status_obj)).lower() if status_obj is not None else ""
            if status_str in {"paid", "completed", "settled"}:
                total_paid += amt

        pending = total_earned - total_paid

        return RewardTracking(
            user_id=user_id,
            total_rewards_earned=total_earned,
            total_rewards_paid=total_paid,
            pending_rewards=pending,
            rewards_by_program=by_program,
        )

    # ------------------------------------------------------------------ #
    # Payouts
    # ------------------------------------------------------------------ #
    def request_payout(self, req: PayoutRequest) -> PayoutRequestResponse:
        """
        Create a payout request, ensuring:

        - requested amount <= pending_rewards
        - requested amount >= min_payout_amount
        """
        cfg = self.get_config()
        tracking = self.get_tracking_for_user(req.user_id)

        if req.amount > tracking.pending_rewards:
            raise errors.ValidationError("Requested amount exceeds pending rewards")

        if req.amount < cfg.min_payout_amount:
            raise errors.ValidationError(
                f"Minimum payout amount is {cfg.min_payout_amount}"
            )

        now = self._now()
        payout_id = uuid4()

        record = {
            "payout_request_id": payout_id,
            "user_id": req.user_id,
            "amount": req.amount,
            "payout_method": req.payout_method,
            "status": "pending",
            "requested_at": now,
            "processed_at": None,
            "failure_reason": None,
            "payout_details": req.payout_details,
        }
        self._payout_store.save_payout_request(record)

        return PayoutRequestResponse(
            payout_request_id=payout_id,
            user_id=req.user_id,
            amount=req.amount,
            payout_method=req.payout_method,
            status="pending",
            requested_at=now,
            processed_at=None,
            failure_reason=None,
        )

# --- File: D:\hostel-management-saas\app\services\referral\referral_service.py ---
# app/services/referral/referral_service.py
from __future__ import annotations

import secrets
import string
from datetime import date
from typing import Callable, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import ReferralRepository, ReferralProgramRepository
from app.repositories.core import UserRepository
from app.schemas.common.enums import ReferralStatus
from app.schemas.referral.referral_base import ReferralCreate
from app.schemas.referral.referral_code import (
    ReferralCodeGenerate,
    ReferralCodeResponse,
    CodeValidationRequest,
    CodeValidationResponse,
)
from app.schemas.referral.referral_program_response import ProgramResponse
from app.schemas.referral.referral_response import (
    ReferralResponse,
    ReferralStats,
)
from app.services.common import UnitOfWork, errors


class ReferralService:
    """
    Referral operations:

    - Generate referral codes for users
    - Create referral records (when shared / used)
    - Validate referral codes
    - List and compute stats for referrers
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_referral_repo(self, uow: UnitOfWork) -> ReferralRepository:
        return uow.get_repo(ReferralRepository)

    def _get_program_repo(self, uow: UnitOfWork) -> ReferralProgramRepository:
        return uow.get_repo(ReferralProgramRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _generate_code(self, prefix: str) -> str:
        """
        Generate a short referral code with the given prefix.
        """
        token = "".join(secrets.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        return f"{prefix}-{token}"

    # ------------------------------------------------------------------ #
    # Mapping
    # ------------------------------------------------------------------ #
    def _to_response(
        self,
        r,
        *,
        program_name: str,
        referrer_name: str,
    ) -> ReferralResponse:
        return ReferralResponse(
            id=r.id,
            created_at=r.created_at,
            updated_at=r.updated_at,
            program_id=r.program_id,
            program_name=program_name,
            referrer_id=r.referrer_id,
            referrer_name=referrer_name,
            referee_email=r.referee_email,
            referee_phone=r.referee_phone,
            referee_user_id=r.referee_user_id,
            referral_code=r.referral_code,
            status=r.status,
            booking_id=r.booking_id,
            completed_at=r.completed_at,
            referrer_reward_amount=r.referrer_reward_amount,
            referee_reward_amount=r.referee_reward_amount,
            currency=r.currency,
            referrer_reward_status=r.referrer_reward_status,
            referee_reward_status=r.referee_reward_status,
        )

    # ------------------------------------------------------------------ #
    # Code generation & validation
    # ------------------------------------------------------------------ #
    def generate_code(self, data: ReferralCodeGenerate) -> ReferralCodeResponse:
        """
        Generate a unique referral code for a user in a given program and
        create a base Referral record without referee populated yet.
        """
        prefix = data.prefix.upper().strip() or "REF"

        with UnitOfWork(self._session_factory) as uow:
            program_repo = self._get_program_repo(uow)
            referral_repo = self._get_referral_repo(uow)
            user_repo = self._get_user_repo(uow)

            prog = program_repo.get(data.program_id)
            if prog is None:
                raise errors.NotFoundError(f"ReferralProgram {data.program_id} not found")

            user = user_repo.get(data.user_id)
            if user is None:
                raise errors.NotFoundError(f"User {data.user_id} not found")

            # Find a unique code
            while True:
                code = self._generate_code(prefix)
                existing = referral_repo.get_multi(
                    skip=0,
                    limit=1,
                    filters={"referral_code": code},
                )
                if not existing:
                    break

            payload = {
                "program_id": data.program_id,
                "referrer_id": data.user_id,
                "referee_email": None,
                "referee_phone": None,
                "referee_user_id": None,
                "referral_code": code,
                "status": ReferralStatus.PENDING,
            }
            referral_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

        return ReferralCodeResponse(
            user_id=data.user_id,
            program_id=data.program_id,
            referral_code=code,
        )

    def validate_code(self, data: CodeValidationRequest) -> CodeValidationResponse:
        """
        Validate a referral code and return referrer/program info if valid.

        Validation checks:
        - Code exists
        - Program is active and within validity period (if specified)
        """
        today = date.today()

        with UnitOfWork(self._session_factory) as uow:
            referral_repo = self._get_referral_repo(uow)
            program_repo = self._get_program_repo(uow)

            refs = referral_repo.get_multi(
                skip=0,
                limit=1,
                filters={"referral_code": data.referral_code},
            )
            if not refs:
                return CodeValidationResponse(
                    referral_code=data.referral_code,
                    is_valid=False,
                    program_id=None,
                    referrer_id=None,
                    message="Invalid or unknown referral code",
                )

            r = refs[0]
            prog = program_repo.get(r.program_id)
            if not prog or not prog.is_active:
                return CodeValidationResponse(
                    referral_code=data.referral_code,
                    is_valid=False,
                    program_id=r.program_id,
                    referrer_id=r.referrer_id,
                    message="Referral program is not active",
                )

            if prog.valid_from and today < prog.valid_from:
                return CodeValidationResponse(
                    referral_code=data.referral_code,
                    is_valid=False,
                    program_id=r.program_id,
                    referrer_id=r.referrer_id,
                    message="Referral program has not started yet",
                )
            if prog.valid_to and today > prog.valid_to:
                return CodeValidationResponse(
                    referral_code=data.referral_code,
                    is_valid=False,
                    program_id=r.program_id,
                    referrer_id=r.referrer_id,
                    message="Referral program has expired",
                )

            return CodeValidationResponse(
                referral_code=data.referral_code,
                is_valid=True,
                program_id=r.program_id,
                referrer_id=r.referrer_id,
                message="Referral code is valid",
            )

    # ------------------------------------------------------------------ #
    # Referral records
    # ------------------------------------------------------------------ #
    def create_referral(self, data: ReferralCreate) -> ReferralResponse:
        """
        Create a referral record (e.g. when a user shares or when booking uses a code).
        """
        with UnitOfWork(self._session_factory) as uow:
            referral_repo = self._get_referral_repo(uow)
            program_repo = self._get_program_repo(uow)
            user_repo = self._get_user_repo(uow)

            prog = program_repo.get(data.program_id)
            if prog is None:
                raise errors.NotFoundError(f"ReferralProgram {data.program_id} not found")

            referrer = user_repo.get(data.referrer_id)
            if referrer is None:
                raise errors.NotFoundError(f"Referrer user {data.referrer_id} not found")

            payload = data.model_dump(exclude_unset=True)
            r = referral_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            return self._to_response(
                r,
                program_name=prog.program_name,
                referrer_name=referrer.full_name,
            )

    def get_referral(self, referral_id: UUID) -> ReferralResponse:
        with UnitOfWork(self._session_factory) as uow:
            referral_repo = self._get_referral_repo(uow)
            program_repo = self._get_program_repo(uow)
            user_repo = self._get_user_repo(uow)

            r = referral_repo.get(referral_id)
            if r is None:
                raise errors.NotFoundError(f"Referral {referral_id} not found")

            prog = program_repo.get(r.program_id)
            referrer = user_repo.get(r.referrer_id)

            program_name = prog.program_name if prog else ""
            referrer_name = referrer.full_name if referrer else ""

            return self._to_response(
                r,
                program_name=program_name,
                referrer_name=referrer_name,
            )

    def list_referrals_for_user(self, user_id: UUID) -> List[ReferralResponse]:
        """
        List all referrals where user_id is the referrer.
        """
        with UnitOfWork(self._session_factory) as uow:
            referral_repo = self._get_referral_repo(uow)
            program_repo = self._get_program_repo(uow)
            user_repo = self._get_user_repo(uow)

            recs = referral_repo.list_for_referrer(user_id)
            referrer = user_repo.get(user_id)
            referrer_name = referrer.full_name if referrer else ""

            # Cache programs
            prog_cache: dict[UUID, str] = {}
            results: List[ReferralResponse] = []

            for r in recs:
                if r.program_id not in prog_cache:
                    p = program_repo.get(r.program_id)
                    prog_cache[r.program_id] = p.program_name if p else ""
                program_name = prog_cache[r.program_id]
                results.append(
                    self._to_response(
                        r,
                        program_name=program_name,
                        referrer_name=referrer_name,
                    )
                )
            return results

    # ------------------------------------------------------------------ #
    # Stats
    # ------------------------------------------------------------------ #
    def get_stats_for_user(self, user_id: UUID) -> ReferralStats:
        """
        Aggregate referral statistics for a referrer.
        """
        with UnitOfWork(self._session_factory) as uow:
            referral_repo = self._get_referral_repo(uow)
            recs = referral_repo.list_for_referrer(user_id)

        total = len(recs)
        successful = sum(1 for r in recs if r.status == ReferralStatus.COMPLETED)
        pending = sum(1 for r in recs if r.status == ReferralStatus.PENDING)

        total_earned = sum(
            (r.referrer_reward_amount or Decimal("0")) for r in recs  # type: ignore[name-defined]
        )
        total_paid_out = Decimal("0")
        total_pending_rewards = total_earned - total_paid_out

        return ReferralStats(
            user_id=user_id,
            total_referrals=total,
            successful_referrals=successful,
            pending_referrals=pending,
            total_earned=total_earned,
            total_paid_out=total_paid_out,
            total_pending_rewards=total_pending_rewards,
        )

# --- File: D:\hostel-management-saas\app\services\referral\__init__.py ---
# app/services/referral/__init__.py
"""
Referral-related services.

- ReferralProgramService:
    Manage referral program definitions.

- ReferralService:
    Handle referral code generation, validation, and individual referral records.

- ReferralRewardService:
    Compute referral rewards and handle payout requests.
"""

from .referral_program_service import ReferralProgramService
from .referral_service import ReferralService
from .referral_reward_service import ReferralRewardService, RewardConfigStore, PayoutStore

__all__ = [
    "ReferralProgramService",
    "ReferralService",
    "ReferralRewardService",
    "RewardConfigStore",
    "PayoutStore",
]


# ===== Folder: D:\hostel-management-saas\app\services\reporting =====

# --- File: D:\hostel-management-saas\app\services\reporting\audit_reporting_service.py ---
# app/services/reporting/audit_reporting_service.py
from __future__ import annotations

from typing import Callable, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.schemas.common.filters import DateRangeFilter
from app.schemas.audit import (
    AuditFilterParams,
    AuditReport,
)
from app.schemas.audit import (
    AdminOverrideSummary,
)
from app.schemas.audit import (
    SupervisorActivityFilter,
    SupervisorActivitySummary,
)
from app.services.common import UnitOfWork
from app.services.audit import (
    AuditLogService,
    AdminOverrideAuditService,
    SupervisorActivityService,
)


class AuditReportingService:
    """
    Aggregated audit reporting facade:

    - High-level AuditReport over audit_log table.
    - AdminOverride summaries.
    - Supervisor activity summaries.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory
        self._audit_log_service = AuditLogService(session_factory)
        self._override_service = AdminOverrideAuditService(session_factory)
        self._supervisor_service = SupervisorActivityService(session_factory)

    # ------------------------------------------------------------------ #
    # Audit logs
    # ------------------------------------------------------------------ #
    def build_audit_report(
        self,
        period: DateRangeFilter,
        *,
        hostel_id: Optional[UUID] = None,
    ) -> AuditReport:
        """
        Delegate to AuditLogService.build_report.
        """
        return self._audit_log_service.build_report(
            period=period,
            hostel_id=hostel_id,
        )

    # ------------------------------------------------------------------ #
    # Admin overrides
    # ------------------------------------------------------------------ #
    def get_admin_override_summary(
        self,
        period: DateRangeFilter,
        *,
        supervisor_id: Optional[UUID] = None,
        hostel_id: Optional[UUID] = None,
    ) -> AdminOverrideSummary:
        """
        Delegate to AdminOverrideAuditService.get_summary.
        """
        return self._override_service.get_summary(
            period=period,
            supervisor_id=supervisor_id,
            hostel_id=hostel_id,
        )

    # ------------------------------------------------------------------ #
    # Supervisor activity
    # ------------------------------------------------------------------ #
    def get_supervisor_activity_summary(
        self,
        filters: SupervisorActivityFilter,
    ) -> SupervisorActivitySummary:
        """
        Delegate to SupervisorActivityService.get_summary.
        """
        return self._supervisor_service.get_summary(filters)

# --- File: D:\hostel-management-saas\app\services\reporting\export_service.py ---
# app/services/reporting/export_service.py
from __future__ import annotations

import csv
import io
import json
from typing import Any, Dict, List, Optional, Protocol

from app.schemas.payment.payment_filters import PaymentExportRequest
from app.services.common import errors


class ExportBackend(Protocol):
    """
    Abstract export backend.

    Implementations may wrap libraries for Excel/PDF generation.
    """

    def export_csv(self, rows: List[Dict[str, Any]], columns: Optional[List[str]] = None) -> bytes: ...
    def export_excel(self, rows: List[Dict[str, Any]], columns: Optional[List[str]] = None) -> bytes: ...
    def export_pdf(self, rows: List[Dict[str, Any]], columns: Optional[List[str]] = None) -> bytes: ...


class SimpleCSVBackend:
    """
    Minimal CSV-only backend implementation.

    - Excel/PDF methods raise NotImplementedError.
    """

    def export_csv(self, rows: List[Dict[str, Any]], columns: Optional[List[str]] = None) -> bytes:
        if not rows:
            return b""

        # Determine column order
        if columns is None:
            # Preserve insertion order of first row
            columns = list(rows[0].keys())

        buf = io.StringIO()
        writer = csv.DictWriter(buf, fieldnames=columns, extrasaction="ignore")
        writer.writeheader()
        for r in rows:
            writer.writerow(r)
        return buf.getvalue().encode("utf-8")

    def export_excel(self, rows: List[Dict[str, Any]], columns: Optional[List[str]] = None) -> bytes:
        raise NotImplementedError("Excel export not implemented for SimpleCSVBackend")

    def export_pdf(self, rows: List[Dict[str, Any]], columns: Optional[List[str]] = None) -> bytes:
        raise NotImplementedError("PDF export not implemented for SimpleCSVBackend")


class ExportService:
    """
    Generic export service for tabular data.

    - export_table: core primitive (rows + columns -> bytes).
    - export_payments: convenience wrapper for PaymentExportRequest.
    """

    def __init__(self, backend: Optional[ExportBackend] = None) -> None:
        self._backend = backend or SimpleCSVBackend()

    # ------------------------------------------------------------------ #
    # Core export
    # ------------------------------------------------------------------ #
    def export_table(
        self,
        rows: List[Dict[str, Any]],
        *,
        fmt: str,
        columns: Optional[List[str]] = None,
    ) -> bytes:
        """
        Export table rows in the given format ('csv', 'excel', 'pdf').

        Returns raw bytes, suitable for sending as a file response.
        """
        fmt = fmt.lower()
        if fmt == "csv":
            return self._backend.export_csv(rows, columns)
        if fmt == "excel":
            return self._backend.export_excel(rows, columns)
        if fmt == "pdf":
            return self._backend.export_pdf(rows, columns)
        if fmt == "json":
            return json.dumps(rows, default=str).encode("utf-8")
        raise errors.ValidationError(f"Unsupported export format {fmt!r}")

    # ------------------------------------------------------------------ #
    # Payment-specific helper
    # ------------------------------------------------------------------ #
    def export_payments(
        self,
        req: PaymentExportRequest,
        rows: List[Dict[str, Any]],
    ) -> bytes:
        """
        Export payment rows according to PaymentExportRequest.

        The service does NOT fetch payments itself; caller is responsible for
        supplying already-filtered rows (e.g. from PaymentService / custom report).
        """
        fmt = req.format.lower()
        return self.export_table(
            rows,
            fmt=fmt,
            columns=None,  # let backend infer columns
        )

# --- File: D:\hostel-management-saas\app\services\reporting\financial_reporting_service.py ---
# app/services/reporting/financial_reporting_service.py
from __future__ import annotations

from typing import Callable, Dict, Any, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.schemas.common.filters import DateRangeFilter
from app.schemas.payment.payment_filters import PaymentReportRequest
from app.schemas.analytics.financial_analytics import FinancialReport
from app.services.common import UnitOfWork
from app.services.payment import PaymentReportingService
from app.services.analytics import FinancialAnalyticsService


class FinancialReportingService:
    """
    Financial reporting facade.

    - Payment volume/amount reports (grouped by day/week/month/type/method)
      via PaymentReportingService.
    - Higher-level FinancialReport (P&L, cashflow, ratios) via
      FinancialAnalyticsService.
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
    ) -> None:
        self._session_factory = session_factory
        # Underlying services created on demand using the same session_factory
        self._payment_reporting = PaymentReportingService(session_factory)
        self._financial_analytics = FinancialAnalyticsService(session_factory)

    # ------------------------------------------------------------------ #
    # Payment-based reports
    # ------------------------------------------------------------------ #
    def build_payment_report(self, req: PaymentReportRequest) -> Dict[str, Any]:
        """
        Delegate to PaymentReportingService.build_report.
        """
        return self._payment_reporting.build_report(req)

    # ------------------------------------------------------------------ #
    # Financial analytics
    # ------------------------------------------------------------------ #
    def get_financial_analytics(
        self,
        *,
        scope_type: str,           # "hostel" or "platform"
        scope_id: Optional[UUID],
        period: DateRangeFilter,
    ) -> FinancialReport:
        """
        Convenience wrapper over FinancialAnalyticsService.get_financial_report.
        """
        return self._financial_analytics.get_financial_report(
            scope_type=scope_type,
            scope_id=scope_id,
            period=period,
        )

# --- File: D:\hostel-management-saas\app\services\reporting\occupancy_reporting_service.py ---
# app/services/reporting/occupancy_reporting_service.py
from __future__ import annotations

from typing import Callable, List, Dict, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository
from app.schemas.common.filters import DateRangeFilter
from app.schemas.analytics.occupancy_analytics import (
    OccupancyReport,
    OccupancyKPI,
)
from app.services.analytics import OccupancyAnalyticsService
from app.services.common import UnitOfWork, errors


class OccupancyReportingService:
    """
    Occupancy reporting:

    - Per-hostel OccupancyReport (daily trend, KPIs, by room type).
    - Convenience multi-hostel KPI snapshot for admins.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory
        self._occupancy_analytics = OccupancyAnalyticsService(session_factory)

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    # ------------------------------------------------------------------ #
    # Per-hostel
    # ------------------------------------------------------------------ #
    def get_hostel_occupancy_report(
        self,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> OccupancyReport:
        """
        Direct wrapper over OccupancyAnalyticsService.get_occupancy_report.
        """
        return self._occupancy_analytics.get_occupancy_report(
            hostel_id=hostel_id,
            period=period,
        )

    # ------------------------------------------------------------------ #
    # Multi-hostel snapshot
    # ------------------------------------------------------------------ #
    def get_multi_hostel_kpis(
        self,
        hostel_ids: List[UUID],
        period: DateRangeFilter,
    ) -> Dict[UUID, OccupancyKPI]:
        """
        Build a simple map of hostel_id -> OccupancyKPI for the given hostels.
        """
        results: Dict[UUID, OccupancyKPI] = {}
        for hid in hostel_ids:
            report = self._occupancy_analytics.get_occupancy_report(
                hostel_id=hid,
                period=period,
            )
            results[hid] = report.kpi
        return results

    def get_all_active_hostels_kpis(
        self,
        period: DateRangeFilter,
        *,
        limit: Optional[int] = None,
    ) -> Dict[UUID, OccupancyKPI]:
        """
        Convenience method: fetch KPIs for all active hostels (optionally limited).

        This uses core_hostel via HostelRepository to discover hostels and then
        calls occupancy analytics per hostel.
        """
        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            hostels = hostel_repo.list_public(limit=limit or 0)

        hostel_ids = [h.id for h in hostels]
        return self.get_multi_hostel_kpis(hostel_ids, period)

# --- File: D:\hostel-management-saas\app\services\reporting\__init__.py ---
# app/services/reporting/__init__.py
"""
Reporting services.

- FinancialReportingService:
    High-level financial reporting over payments + financial analytics.

- OccupancyReportingService:
    Hostel occupancy reporting, using occupancy analytics.

- AuditReportingService:
    Audit / override / supervisor activity reporting facades.

- ExportService:
    Generic tabular export (CSV/Excel/PDF) via a pluggable backend.
"""

from .financial_reporting_service import FinancialReportingService
from .occupancy_reporting_service import OccupancyReportingService
from .audit_reporting_service import AuditReportingService
from .export_service import ExportService, ExportBackend

__all__ = [
    "FinancialReportingService",
    "OccupancyReportingService",
    "AuditReportingService",
    "ExportService",
    "ExportBackend",
]


# ===== Folder: D:\hostel-management-saas\app\services\review =====

# --- File: D:\hostel-management-saas\app\services\review\hostel_response_service.py ---
# app/services/review/hostel_response_service.py
from __future__ import annotations

from datetime import datetime, date
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Protocol
from uuid import UUID, uuid4

from sqlalchemy.orm import Session

from app.repositories.content import ReviewRepository
from app.repositories.core import HostelRepository, UserRepository
from app.schemas.review.review_response_schema import (
    HostelResponseCreate,
    OwnerResponse,
    ResponseUpdate,
    ResponseGuidelines,
    ResponseStats,
)
from app.services.common import UnitOfWork, errors


class HostelResponseStore(Protocol):
    """
    Storage for hostel responses to reviews.

    Expected record shape:

        {
            "id": UUID,
            "review_id": UUID,
            "hostel_id": UUID,
            "response_text": str,
            "responded_by": UUID,
            "responded_by_name": str,
            "responded_by_role": str,
            "responded_at": datetime,
            "created_at": datetime,
            "updated_at": datetime,
        }
    """

    def save_response(self, record: dict) -> dict: ...
    def get_response_by_review(self, review_id: UUID) -> Optional[dict]: ...
    def get_response(self, response_id: UUID) -> Optional[dict]: ...
    def update_response(self, response_id: UUID, data: dict) -> dict: ...
    def list_responses_for_hostel(self, hostel_id: UUID) -> List[dict]: ...


class HostelResponseService:
    """
    Hostel/owner responses to reviews:

    - Create/update responses
    - Guidelines
    - Response statistics
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: HostelResponseStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Guidelines
    # ------------------------------------------------------------------ #
    def get_guidelines(self) -> ResponseGuidelines:
        return ResponseGuidelines()

    # ------------------------------------------------------------------ #
    # Responses
    # ------------------------------------------------------------------ #
    def create_response(
        self,
        data: HostelResponseCreate,
        *,
        responded_by_role: str,
    ) -> OwnerResponse:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            user_repo = self._get_user_repo(uow)

            r = review_repo.get(data.review_id)
            if r is None:
                raise errors.NotFoundError(f"Review {data.review_id} not found")

            user = user_repo.get(data.responded_by)
            responded_by_name = user.full_name if user else ""

            now = self._now()
            record = {
                "id": uuid4(),
                "review_id": data.review_id,
                "hostel_id": r.hostel_id,
                "response_text": data.response_text,
                "responded_by": data.responded_by,
                "responded_by_name": responded_by_name,
                "responded_by_role": responded_by_role,
                "responded_at": now,
                "created_at": now,
                "updated_at": now,
            }
            saved = self._store.save_response(record)

        return OwnerResponse(
            id=saved["id"],
            created_at=saved["created_at"],
            updated_at=saved["updated_at"],
            review_id=saved["review_id"],
            response_text=saved["response_text"],
            responded_by=saved["responded_by"],
            responded_by_name=saved["responded_by_name"],
            responded_by_role=saved["responded_by_role"],
            responded_at=saved["responded_at"],
        )

    def update_response(self, data: ResponseUpdate) -> OwnerResponse:
        record = self._store.get_response(data.response_id)
        if not record:
            raise errors.NotFoundError(f"Response {data.response_id} not found")

        record["response_text"] = data.response_text
        record["updated_at"] = self._now()
        updated = self._store.update_response(data.response_id, record)

        return OwnerResponse(
            id=updated["id"],
            created_at=updated["created_at"],
            updated_at=updated["updated_at"],
            review_id=updated["review_id"],
            response_text=updated["response_text"],
            responded_by=updated["responded_by"],
            responded_by_name=updated["responded_by_name"],
            responded_by_role=updated["responded_by_role"],
            responded_at=updated["responded_at"],
        )

    def get_response_for_review(self, review_id: UUID) -> Optional[OwnerResponse]:
        record = self._store.get_response_by_review(review_id)
        if not record:
            return None
        return OwnerResponse(
            id=record["id"],
            created_at=record["created_at"],
            updated_at=record["updated_at"],
            review_id=record["review_id"],
            response_text=record["response_text"],
            responded_by=record["responded_by"],
            responded_by_name=record["responded_by_name"],
            responded_by_role=record["responded_by_role"],
            responded_at=record["responded_at"],
        )

    # ------------------------------------------------------------------ #
    # Stats
    # ------------------------------------------------------------------ #
    def get_stats(
        self,
        hostel_id: UUID,
        *,
        period_start: date,
        period_end: date,
    ) -> ResponseStats:
        """
        Compute ResponseStats using ReviewRepository + HostelResponseStore.
        """
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)

            reviews = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

        total_reviews = len(reviews)
        if total_reviews == 0:
            return ResponseStats(
                hostel_id=hostel_id,
                total_reviews=0,
                total_responses=0,
                response_rate=Decimal("0"),
                average_response_time_hours=Decimal("0"),
                response_rate_5_star=Decimal("0"),
                response_rate_4_star=Decimal("0"),
                response_rate_3_star=Decimal("0"),
                response_rate_2_star=Decimal("0"),
                response_rate_1_star=Decimal("0"),
            )

        responses = self._store.list_responses_for_hostel(hostel_id)
        total_responses = len(responses)

        def _pct(num: int, denom: int) -> Decimal:
            return (
                Decimal(str(num)) / Decimal(str(denom)) * Decimal("100")
                if denom > 0
                else Decimal("0")
            )

        # Average response time
        response_times: List[float] = []
        resp_by_review: Dict[UUID, dict] = {
            r["review_id"]: r for r in responses
        }

        by_rating_responses = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}
        by_rating_total = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}

        for rv in reviews:
            d = rv.created_at.date()
            if not (period_start <= d <= period_end):
                continue

            val = int(round(float(rv.overall_rating)))
            val = min(5, max(1, val))
            by_rating_total[val] += 1

            resp = resp_by_review.get(rv.id)
            if resp:
                delta = resp["responded_at"] - rv.created_at
                response_times.append(delta.total_seconds() / 3600.0)
                by_rating_responses[val] += 1

        avg_hours = (
            Decimal(str(sum(response_times) / len(response_times)))
            if response_times
            else Decimal("0")
        )

        return ResponseStats(
            hostel_id=hostel_id,
            total_reviews=total_reviews,
            total_responses=total_responses,
            response_rate=_pct(total_responses, total_reviews),
            average_response_time_hours=avg_hours,
            response_rate_5_star=_pct(by_rating_responses[5], by_rating_total[5]),
            response_rate_4_star=_pct(by_rating_responses[4], by_rating_total[4]),
            response_rate_3_star=_pct(by_rating_responses[3], by_rating_total[3]),
            response_rate_2_star=_pct(by_rating_responses[2], by_rating_total[2]),
            response_rate_1_star=_pct(by_rating_responses[1], by_rating_total[1]),
        )

# --- File: D:\hostel-management-saas\app\services\review\public_review_service.py ---
# app/services/review/public_review_service.py
from __future__ import annotations

from datetime import datetime
from typing import Callable, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import ReviewRepository
from app.repositories.core import HostelRepository, UserRepository, StudentRepository
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.review.review_submission import (
    ReviewSubmissionRequest,
    DetailedRatings,
    ReviewGuidelines,
    ReviewEligibility,
)
from app.schemas.review import ReviewDetail, ReviewListItem
from app.schemas.review.review_filters import ReviewFilterParams, SortOptions
from app.services.common import UnitOfWork, errors
from .review_service import ReviewService


class PublicReviewService:
    """
    Public-facing wrapper for internal reviews:

    - Submit review (ReviewSubmissionRequest) as an internal Review
    - Check simple review eligibility
    - Provide guidelines
    - List public reviews for hostel (approved + sorted)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory
        self._review_service = ReviewService(session_factory)

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Eligibility & guidelines
    # ------------------------------------------------------------------ #
    def get_guidelines(self) -> ReviewGuidelines:
        return ReviewGuidelines()

    def check_eligibility(self, user_id: UUID, hostel_id: UUID) -> ReviewEligibility:
        """
        Very simple eligibility:

        - can_review if the user has not already reviewed this hostel.
        - has_booking/has_stayed are not checked (no booking linkage here).
        """
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)

            existing = review_repo.get_multi(
                skip=0,
                limit=1,
                filters={"hostel_id": hostel_id, "reviewer_id": user_id},
            )

        already = bool(existing)
        can_review = not already
        reason = "Eligible to review" if can_review else "You have already reviewed this hostel"

        return ReviewEligibility(
            user_id=user_id,
            hostel_id=hostel_id,
            can_review=can_review,
            reason=reason,
            has_stayed=False,
            has_booking=False,
            already_reviewed=already,
            existing_review_id=existing[0].id if already else None,
            can_edit=already,
        )

    # ------------------------------------------------------------------ #
    # Submission
    # ------------------------------------------------------------------ #
    def submit_review(
        self,
        reviewer_id: UUID,
        data: ReviewSubmissionRequest,
    ) -> ReviewDetail:
        """
        Map ReviewSubmissionRequest to internal ReviewCreate and delegate to ReviewService.
        """
        # The ReviewCreate schema is similar to ReviewSubmissionRequest; we map manually.
        from app.schemas.review import ReviewCreate

        # Approximate mapping from DetailedRatings
        dr: DetailedRatings = data.detailed_ratings

        create = ReviewCreate(
            hostel_id=data.hostel_id,
            reviewer_id=reviewer_id,
            student_id=data.student_id,
            booking_id=data.booking_id,
            overall_rating=data.overall_rating,
            title=data.title,
            review_text=data.review_text,
            cleanliness_rating=dr.cleanliness,
            food_quality_rating=dr.food_quality,
            staff_behavior_rating=dr.staff_behavior,
            security_rating=dr.security,
            value_for_money_rating=dr.value_for_money,
            amenities_rating=dr.amenities,
            photos=data.photos,
        )
        return self._review_service.create_review(create)

    # ------------------------------------------------------------------ #
    # Public listing
    # ------------------------------------------------------------------ #
    def list_public_reviews(
        self,
        hostel_id: UUID,
        params: PaginationParams,
        *,
        min_rating: Optional[float] = None,
    ) -> PaginatedResponse[ReviewListItem]:
        """
        Convenience wrapper: show only approved reviews for hostel,
        optionally filtered by minimum rating.
        """
        filters = ReviewFilterParams(
            hostel_id=hostel_id,
            min_rating=min_rating,
            approved_only=True,
        )
        sort = SortOptions(sort_by="helpful", verified_first=True, with_photos_first=True)
        return self._review_service.list_reviews(params, filters=filters, sort=sort)

# --- File: D:\hostel-management-saas\app\services\review\review_analytics_service.py ---
# app/services/review/review_analytics_service.py
from __future__ import annotations

from collections import defaultdict
from datetime import datetime, date, timedelta
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import ReviewRepository
from app.repositories.core import HostelRepository
from app.schemas.common.filters import DateRangeFilter
from app.schemas.review.review_analytics import (
    ReviewAnalytics,
    RatingDistribution,
    TrendAnalysis,
    MonthlyRating,
    SentimentAnalysis,
)
from app.services.common import UnitOfWork, errors


class ReviewAnalyticsService:
    """
    Review analytics per hostel:

    - Rating distribution
    - Detailed aspect averages
    - TrendAnalysis over time
    - Simple engagement metrics (helpful votes, verification rate)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_hostel_review_analytics(
        self,
        hostel_id: UUID,
        period: Optional[DateRangeFilter] = None,
    ) -> ReviewAnalytics:
        """
        Build ReviewAnalytics for a hostel over optional period.
        If period is None or missing dates, considers all time.
        """
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            recs = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

        if not period or (not period.start_date and not period.end_date):
            start = date.min
            end = date.max
        else:
            start = period.start_date or date.min
            end = period.end_date or date.max

        # Filter by created_at date
        reviews = [
            r for r in recs
            if start <= r.created_at.date() <= end
        ]

        total = len(reviews)
        if total == 0:
            return ReviewAnalytics(
                hostel_id=hostel_id,
                hostel_name=hostel.name,
                analysis_period=period,
                generated_at=self._now(),
                total_reviews=0,
                average_rating=Decimal("0"),
                rating_distribution=RatingDistribution(
                    rating_5_count=0,
                    rating_4_count=0,
                    rating_3_count=0,
                    rating_2_count=0,
                    rating_1_count=0,
                    rating_5_percentage=Decimal("0"),
                    rating_4_percentage=Decimal("0"),
                    rating_3_percentage=Decimal("0"),
                    rating_2_percentage=Decimal("0"),
                    rating_1_percentage=Decimal("0"),
                    positive_reviews=0,
                    neutral_reviews=0,
                    negative_reviews=0,
                    positive_percentage=Decimal("0"),
                    neutral_percentage=Decimal("0"),
                    negative_percentage=Decimal("0"),
                ),
                detailed_ratings_average={},
                rating_trend=TrendAnalysis(
                    trend_direction="stable",
                    trend_percentage=None,
                    monthly_ratings=[],
                    last_30_days_rating=Decimal("0"),
                    last_90_days_rating=Decimal("0"),
                    all_time_rating=Decimal("0"),
                ),
                sentiment_analysis=None,
                verified_reviews_count=0,
                verification_rate=Decimal("0"),
                average_helpful_votes=Decimal("0"),
                response_rate=Decimal("0"),
            )

        # Overall average
        total_rating = sum((r.overall_rating for r in reviews), Decimal("0"))
        avg_rating = total_rating / Decimal(str(total))

        # Rating distribution
        rating_counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}
        for r in reviews:
            val = int(round(float(r.overall_rating)))
            val = min(5, max(1, val))
            rating_counts[val] += 1

        def _pct(num: int, denom: int) -> Decimal:
            return (
                Decimal(str(num)) / Decimal(str(denom)) * Decimal("100")
                if denom > 0
                else Decimal("0")
            )

        dist = RatingDistribution(
            rating_5_count=rating_counts[5],
            rating_4_count=rating_counts[4],
            rating_3_count=rating_counts[3],
            rating_2_count=rating_counts[2],
            rating_1_count=rating_counts[1],
            rating_5_percentage=_pct(rating_counts[5], total),
            rating_4_percentage=_pct(rating_counts[4], total),
            rating_3_percentage=_pct(rating_counts[3], total),
            rating_2_percentage=_pct(rating_counts[2], total),
            rating_1_percentage=_pct(rating_counts[1], total),
            positive_reviews=rating_counts[5] + rating_counts[4],
            neutral_reviews=rating_counts[3],
            negative_reviews=rating_counts[1] + rating_counts[2],
            positive_percentage=_pct(rating_counts[5] + rating_counts[4], total),
            neutral_percentage=_pct(rating_counts[3], total),
            negative_percentage=_pct(rating_counts[1] + rating_counts[2], total),
        )

        # Detailed aspect averages
        aspects = [
            "cleanliness_rating",
            "food_quality_rating",
            "staff_behavior_rating",
            "security_rating",
            "value_for_money_rating",
            "amenities_rating",
        ]
        detailed: Dict[str, Decimal] = {}
        for field in aspects:
            vals = [
                Decimal(str(getattr(r, field)))
                for r in reviews
                if getattr(r, field) is not None
            ]
            if vals:
                detailed[field] = sum(vals) / Decimal(str(len(vals)))

        # Trend: monthly
        monthly_map: Dict[str, Dict[str, object]] = {}
        for r in reviews:
            key = r.created_at.strftime("%Y-%m")
            bucket = monthly_map.setdefault(
                key, {"sum": Decimal("0"), "count": 0}
            )
            bucket["sum"] = bucket["sum"] + r.overall_rating  # type: ignore[operator]
            bucket["count"] = bucket["count"] + 1  # type: ignore[operator]

        monthly_ratings: List[MonthlyRating] = []
        for month, vals in sorted(monthly_map.items()):
            avg_m = (
                vals["sum"] / Decimal(str(vals["count"]))  # type: ignore[index]
                if vals["count"]  # type: ignore[index]
                else Decimal("0")
            )
            monthly_ratings.append(
                MonthlyRating(
                    month=month,
                    average_rating=avg_m,
                    review_count=vals["count"],  # type: ignore[index]
                )
            )

        # Trend direction based on first vs last month
        trend_direction = "stable"
        trend_pct: Optional[Decimal] = None
        if len(monthly_ratings) >= 2:
            first = monthly_ratings[0].average_rating
            last = monthly_ratings[-1].average_rating
            if first > 0:
                change = (last - first) / first * Decimal("100")
                trend_pct = change
                if change > Decimal("5"):
                    trend_direction = "improving"
                elif change < Decimal("-5"):
                    trend_direction = "declining"
                else:
                    trend_direction = "stable"

        # Last 30/90 days vs all-time
        today = date.today()
        last_30 = [
            r for r in reviews if r.created_at.date() >= today - timedelta(days=30)
        ]
        last_90 = [
            r for r in reviews if r.created_at.date() >= today - timedelta(days=90)
        ]
        def _avg(lst) -> Decimal:
            if not lst:
                return Decimal("0")
            s = sum((x.overall_rating for x in lst), Decimal("0"))
            return s / Decimal(str(len(lst)))

        trend = TrendAnalysis(
            trend_direction=trend_direction,
            trend_percentage=trend_pct,
            monthly_ratings=monthly_ratings,
            last_30_days_rating=_avg(last_30),
            last_90_days_rating=_avg(last_90),
            all_time_rating=avg_rating,
        )

        # Sentiment placeholder
        sentiment: Optional[SentimentAnalysis] = None

        # Verification & engagement
        verified_count = sum(1 for r in reviews if r.is_verified_stay)
        verification_rate = _pct(verified_count, total)

        avg_helpful = (
            Decimal(
                str(sum(int(r.helpful_count) for r in reviews))
            )
            / Decimal(str(total))
        )

        # Response rate not tracked here -> 0
        response_rate = Decimal("0")

        return ReviewAnalytics(
            hostel_id=hostel_id,
            hostel_name=hostel.name,
            analysis_period=period,
            generated_at=self._now(),
            total_reviews=total,
            average_rating=avg_rating,
            rating_distribution=dist,
            detailed_ratings_average=detailed,
            rating_trend=trend,
            sentiment_analysis=sentiment,
            verified_reviews_count=verified_count,
            verification_rate=verification_rate,
            average_helpful_votes=avg_helpful,
            response_rate=response_rate,
        )

# --- File: D:\hostel-management-saas\app\services\review\review_moderation_service.py ---
# app/services/review/review_moderation_service.py
from __future__ import annotations

from datetime import datetime, date
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import ReviewRepository
from app.repositories.core import HostelRepository, UserRepository
from app.schemas.review.review_moderation import (
    ModerationRequest,
    ModerationResponse,
    ModerationQueue,
    PendingReview,
    BulkModeration,
    ModerationStats,
)
from app.services.common import UnitOfWork, errors


class ModerationStore(Protocol):
    """
    Storage for review moderation metadata not present in the Review model.

    Expected record keys (example):
        {
            "review_id": UUID,
            "moderation_status": "pending|approved|rejected|flagged",
            "rejection_reason": str | None,
            "flag_reason": str | None,
            "flag_details": str | None,
            "moderator_notes": str | None,
            "flag_count": int,
            "spam_score": Decimal | None,
            "sentiment_score": Decimal | None,
            "submitted_at": datetime,
            "moderated_at": datetime | None,
            "moderated_by": UUID | None,
            "moderated_by_name": str | None,
        }
    """

    def get_metadata(self, review_id: UUID) -> Optional[dict]: ...
    def save_metadata(self, review_id: UUID, data: dict) -> None: ...


class ReviewModerationService:
    """
    Review moderation:

    - Approve/reject/flag/unflag reviews
    - Build moderation queue
    - Moderation statistics
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: ModerationStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    def _ensure_meta(self, review_id: UUID) -> dict:
        meta = self._store.get_metadata(review_id)
        if meta:
            return meta
        now = self._now()
        meta = {
            "review_id": review_id,
            "moderation_status": "pending",
            "rejection_reason": None,
            "flag_reason": None,
            "flag_details": None,
            "moderator_notes": None,
            "flag_count": 0,
            "spam_score": None,
            "sentiment_score": None,
            "submitted_at": now,
            "moderated_at": None,
            "moderated_by": None,
            "moderated_by_name": None,
        }
        self._store.save_metadata(review_id, meta)
        return meta

    # ------------------------------------------------------------------ #
    # Moderate
    # ------------------------------------------------------------------ #
    def moderate(
        self,
        data: ModerationRequest,
        *,
        moderator_id: UUID,
    ) -> ModerationResponse:
        """
        Apply a moderation action to a review.
        """
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            user_repo = self._get_user_repo(uow)

            r = review_repo.get(data.review_id)
            if r is None:
                raise errors.NotFoundError(f"Review {data.review_id} not found")

            moderator = user_repo.get(moderator_id)
            moderator_name = moderator.full_name if moderator else ""

            meta = self._ensure_meta(r.id)
            now = self._now()

            action = data.action
            if action == "approve":
                r.is_approved = True  # type: ignore[attr-defined]
                r.is_flagged = False  # type: ignore[attr-defined]
                meta["moderation_status"] = "approved"
                meta["rejection_reason"] = None
            elif action == "reject":
                r.is_approved = False  # type: ignore[attr-defined]
                meta["moderation_status"] = "rejected"
                meta["rejection_reason"] = data.rejection_reason
            elif action == "flag":
                r.is_flagged = True  # type: ignore[attr-defined]
                meta["moderation_status"] = "flagged"
                meta["flag_reason"] = data.flag_reason
                meta["flag_details"] = data.flag_details
                meta["flag_count"] = int(meta.get("flag_count", 0)) + 1
            elif action == "unflag":
                r.is_flagged = False  # type: ignore[attr-defined]
                meta["moderation_status"] = "approved" if r.is_approved else "pending"
                meta["flag_reason"] = None
                meta["flag_details"] = None
            else:
                raise errors.ValidationError("Unknown moderation action")

            meta["moderated_at"] = now
            meta["moderated_by"] = moderator_id
            meta["moderated_by_name"] = moderator_name
            meta["moderator_notes"] = data.moderator_notes

            self._store.save_metadata(r.id, meta)
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return ModerationResponse(
            review_id=r.id,
            action_taken=action,
            moderated_by=moderator_id,
            moderated_by_name=moderator_name,
            moderated_at=now,
            reviewer_notified=False,
            message=f"Review {action}d successfully",
        )

    def bulk_moderate(
        self,
        data: BulkModeration,
        *,
        moderator_id: UUID,
    ) -> List[ModerationResponse]:
        responses: List[ModerationResponse] = []
        for rid in data.review_ids:
            req = ModerationRequest(
                review_id=rid,
                action=data.action,
                rejection_reason=data.reason,
                flag_reason=None,
                flag_details=None,
                moderator_notes=data.reason,
            )
            responses.append(self.moderate(req, moderator_id=moderator_id))
        return responses

    # ------------------------------------------------------------------ #
    # Queue
    # ------------------------------------------------------------------ #
    def get_moderation_queue(
        self,
        *,
        hostel_id: Optional[UUID] = None,
        limit: int = 50,
    ) -> ModerationQueue:
        """
        Build a simple moderation queue:

        - Pending or flagged reviews.
        """
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            filters: Dict[str, object] = {}
            if hostel_id:
                filters["hostel_id"] = hostel_id

            recs = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

            pending: List[PendingReview] = []
            total_pending = flagged = auto_approved = 0

            for r in recs:
                meta = self._ensure_meta(r.id)
                status = meta.get("moderation_status", "pending")
                if status == "pending" or status == "flagged":
                    total_pending += 1
                if status == "flagged":
                    flagged += 1
                if status == "approved" and meta.get("moderated_by") is None:
                    auto_approved += 1

                if len(pending) >= limit:
                    continue

                hostel = hostel_repo.get(r.hostel_id)
                hostel_name = hostel.name if hostel else ""

                reviewer = user_repo.get(r.reviewer_id)
                reviewer_name = reviewer.full_name if reviewer else ""

                excerpt = (r.review_text or "")[:200]
                pending.append(
                    PendingReview(
                        review_id=r.id,
                        hostel_id=r.hostel_id,
                        hostel_name=hostel_name,
                        reviewer_name=reviewer_name,
                        overall_rating=r.overall_rating,
                        title=r.title,
                        review_excerpt=excerpt,
                        is_verified_stay=r.is_verified_stay,
                        is_flagged=r.is_flagged,
                        flag_count=int(meta.get("flag_count", 0)),
                        submitted_at=r.created_at,
                        spam_score=meta.get("spam_score"),
                        sentiment_score=meta.get("sentiment_score"),
                    )
                )

        return ModerationQueue(
            hostel_id=hostel_id,
            total_pending=total_pending,
            flagged_reviews=flagged,
            auto_approved=auto_approved,
            pending_reviews=pending,
        )

    # ------------------------------------------------------------------ #
    # Stats
    # ------------------------------------------------------------------ #
    def get_moderation_stats(
        self,
        *,
        hostel_id: Optional[UUID],
        period_start: date,
        period_end: date,
    ) -> ModerationStats:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)

            filters: Dict[str, object] = {}
            if hostel_id:
                filters["hostel_id"] = hostel_id

            recs = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

        total = auto_approved = manually_approved = rejected = flagged = 0
        moderation_times: List[float] = []
        moderations_by_user: Dict[str, int] = {}

        for r in recs:
            if not (period_start <= r.created_at.date() <= period_end):
                continue
            total += 1
            meta = self._ensure_meta(r.id)
            status = meta.get("moderation_status", "pending")
            mod_at = meta.get("moderated_at")
            mod_by = meta.get("moderated_by")
            sub_at = meta.get("submitted_at", r.created_at)

            if status == "approved":
                if mod_by is None:
                    auto_approved += 1
                else:
                    manually_approved += 1
            elif status == "rejected":
                rejected += 1
            elif status == "flagged":
                flagged += 1

            if mod_at:
                hours = (mod_at - sub_at).total_seconds() / 3600.0
                moderation_times.append(hours)
            if mod_by:
                key = str(mod_by)
                moderations_by_user[key] = moderations_by_user.get(key, 0) + 1

        avg_time = (
            Decimal(str(sum(moderation_times) / len(moderation_times)))
            if moderation_times
            else Decimal("0")
        )

        return ModerationStats(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
            total_reviews=total,
            auto_approved=auto_approved,
            manually_approved=manually_approved,
            rejected=rejected,
            flagged=flagged,
            average_moderation_time_hours=avg_time,
            moderations_by_user=moderations_by_user,
        )

# --- File: D:\hostel-management-saas\app\services\review\review_service.py ---
# app/services/review/review_service.py
from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import ReviewRepository
from app.repositories.core import HostelRepository, UserRepository, StudentRepository
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.review import (
    ReviewCreate,
    ReviewUpdate,
    ReviewResponse,
    ReviewDetail,
    ReviewListItem,
    ReviewFilterParams,
    SearchRequest,
    SortOptions,
)
from app.schemas.review.review_response import ReviewSummary
from app.services.common import UnitOfWork, errors


class ReviewService:
    """
    Core internal review service (content_review):

    - Create/update reviews
    - Get review detail
    - List & search reviews with filters + sorting
    - Summary per hostel
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _to_response(
        self,
        r,
        *,
        hostel_name: str,
        reviewer_name: str,
    ) -> ReviewResponse:
        return ReviewResponse(
            id=r.id,
            created_at=r.created_at,
            updated_at=r.updated_at,
            hostel_id=r.hostel_id,
            hostel_name=hostel_name,
            reviewer_id=r.reviewer_id,
            reviewer_name=reviewer_name,
            overall_rating=r.overall_rating,
            title=r.title,
            review_text=r.review_text,
            is_verified_stay=r.is_verified_stay,
            verified_at=r.verified_at,
            is_approved=r.is_approved,
            helpful_count=r.helpful_count,
            not_helpful_count=r.not_helpful_count,
            created_at=r.created_at,
        )

    def _to_detail(
        self,
        r,
        *,
        hostel_name: str,
        reviewer_name: str,
        reviewer_profile_image: Optional[str],
        student_name: Optional[str],
    ) -> ReviewDetail:
        # Model does not hold moderation metadata / hostel response;
        # we return safe defaults here.
        is_published = bool(r.is_approved and not r.is_flagged)

        return ReviewDetail(
            id=r.id,
            created_at=r.created_at,
            updated_at=r.updated_at,
            hostel_id=r.hostel_id,
            hostel_name=hostel_name,
            reviewer_id=r.reviewer_id,
            reviewer_name=reviewer_name,
            reviewer_profile_image=reviewer_profile_image,
            student_id=r.student_id,
            booking_id=r.booking_id,
            overall_rating=r.overall_rating,
            cleanliness_rating=r.cleanliness_rating,
            food_quality_rating=r.food_quality_rating,
            staff_behavior_rating=r.staff_behavior_rating,
            security_rating=r.security_rating,
            value_for_money_rating=r.value_for_money_rating,
            amenities_rating=r.amenities_rating,
            title=r.title,
            review_text=r.review_text,
            photos=r.photos or [],
            is_verified_stay=r.is_verified_stay,
            verified_at=r.verified_at,
            is_approved=r.is_approved,
            approved_by=None,
            approved_at=None,
            is_flagged=r.is_flagged,
            flag_reason=None,
            flagged_by=None,
            flagged_at=None,
            helpful_count=r.helpful_count,
            not_helpful_count=r.not_helpful_count,
            report_count=0,
            hostel_response=None,
            is_published=is_published,
        )

    def _to_list_item(
        self,
        r,
        *,
        reviewer_name: str,
    ) -> ReviewListItem:
        excerpt = (r.review_text or "")[:150]
        return ReviewListItem(
            id=r.id,
            reviewer_name=reviewer_name,
            overall_rating=r.overall_rating,
            title=r.title,
            review_excerpt=excerpt,
            is_verified_stay=r.is_verified_stay,
            helpful_count=r.helpful_count,
            created_at=r.created_at,
            has_hostel_response=False,
        )

    # ------------------------------------------------------------------ #
    # Core read
    # ------------------------------------------------------------------ #
    def get_review(self, review_id: UUID) -> ReviewDetail:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            r = review_repo.get(review_id)
            if r is None:
                raise errors.NotFoundError(f"Review {review_id} not found")

            hostel = hostel_repo.get(r.hostel_id)
            hostel_name = hostel.name if hostel else ""

            reviewer = user_repo.get(r.reviewer_id)
            reviewer_name = reviewer.full_name if reviewer else ""
            reviewer_img = getattr(reviewer, "profile_image_url", None) if reviewer else None

            student_name = None
            if r.student_id:
                st = self._get_student_repo(uow).get(r.student_id)
                if st and getattr(st, "user", None):
                    student_name = st.user.full_name

            return self._to_detail(
                r,
                hostel_name=hostel_name,
                reviewer_name=reviewer_name,
                reviewer_profile_image=reviewer_img,
                student_name=student_name,
            )

    # ------------------------------------------------------------------ #
    # Create / update
    # ------------------------------------------------------------------ #
    def create_review(self, data: ReviewCreate) -> ReviewDetail:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            reviewer = user_repo.get(data.reviewer_id)
            if reviewer is None:
                raise errors.NotFoundError(f"User {data.reviewer_id} not found")

            payload = data.model_dump(exclude_unset=True)
            r = review_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            student_name = None
            if r.student_id:
                st = self._get_student_repo(uow).get(r.student_id)
                if st and getattr(st, "user", None):
                    student_name = st.user.full_name

            return self._to_detail(
                r,
                hostel_name=hostel.name,
                reviewer_name=reviewer.full_name,
                reviewer_profile_image=getattr(reviewer, "profile_image_url", None),
                student_name=student_name,
            )

    def update_review(self, review_id: UUID, data: ReviewUpdate) -> ReviewDetail:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)

            r = review_repo.get(review_id)
            if r is None:
                raise errors.NotFoundError(f"Review {review_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(r, field) and field != "id":
                    setattr(r, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return self.get_review(review_id)

    # ------------------------------------------------------------------ #
    # Listing with filters/sorting
    # ------------------------------------------------------------------ #
    def list_reviews(
        self,
        params: PaginationParams,
        filters: Optional[ReviewFilterParams] = None,
        sort: Optional[SortOptions] = None,
    ) -> PaginatedResponse[ReviewListItem]:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            user_repo = self._get_user_repo(uow)

            raw_filters: Dict[str, object] = {}
            if filters:
                if filters.hostel_id:
                    raw_filters["hostel_id"] = filters.hostel_id
                elif filters.hostel_ids:
                    raw_filters["hostel_id"] = filters.hostel_ids
                if filters.approved_only:
                    raw_filters["is_approved"] = True

            records: Sequence = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=raw_filters or None,
            )

            def _matches(r) -> bool:
                if not filters:
                    return True

                if filters.min_rating is not None and r.overall_rating < filters.min_rating:
                    return False
                if filters.max_rating is not None and r.overall_rating > filters.max_rating:
                    return False
                if filters.rating is not None and int(round(float(r.overall_rating))) != filters.rating:
                    return False

                if filters.verified_only and not r.is_verified_stay:
                    return False

                if filters.posted_date_from or filters.posted_date_to:
                    d = r.created_at.date()
                    if filters.posted_date_from and d < filters.posted_date_from:
                        return False
                    if filters.posted_date_to and d > filters.posted_date_to:
                        return False

                if filters.flagged_only is True and not r.is_flagged:
                    return False

                if filters.min_helpful_count is not None and r.helpful_count < filters.min_helpful_count:
                    return False

                if filters.with_photos_only and not r.photos:
                    return False

                return True

            filtered = [r for r in records if _matches(r)]

            # Sorting
            sort = sort or SortOptions()
            def _sort_key(r):
                base = []
                if sort.sort_by == "helpful":
                    base.append(-r.helpful_count)
                elif sort.sort_by == "recent":
                    base.append(-(r.created_at.timestamp()))
                elif sort.sort_by == "rating_high":
                    base.append(-float(r.overall_rating))
                elif sort.sort_by == "rating_low":
                    base.append(float(r.overall_rating))
                elif sort.sort_by == "verified":
                    base.append(0 if r.is_verified_stay else 1)

                # Secondary modifiers
                if sort.verified_first:
                    base.append(0 if r.is_verified_stay else 1)
                if sort.with_photos_first:
                    base.append(0 if r.photos else 1)

                # Always add created_at desc as tie breaker
                base.append(-r.created_at.timestamp())
                return tuple(base)

            sorted_records = sorted(filtered, key=_sort_key)

            # Pagination
            start = params.offset
            end = start + params.limit
            page_records = sorted_records[start:end]

            # Map to list items
            user_cache: Dict[UUID, str] = {}
            items: List[ReviewListItem] = []
            for r in page_records:
                if r.reviewer_id not in user_cache:
                    u = user_repo.get(r.reviewer_id)
                    user_cache[r.reviewer_id] = u.full_name if u else ""
                reviewer_name = user_cache[r.reviewer_id]
                items.append(self._to_list_item(r, reviewer_name=reviewer_name))

            return PaginatedResponse[ReviewListItem].create(
                items=items,
                total_items=len(sorted_records),
                page=params.page,
                page_size=params.page_size,
            )

    def search_reviews(
        self,
        params: PaginationParams,
        req: SearchRequest,
    ) -> PaginatedResponse[ReviewListItem]:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            user_repo = self._get_user_repo(uow)

            filters: Dict[str, object] = {}
            if req.hostel_id:
                filters["hostel_id"] = req.hostel_id

            records: Sequence = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

            q = req.query.lower()
            user_cache: Dict[UUID, str] = {}

            def _matches(r) -> bool:
                if req.min_rating is not None and r.overall_rating < req.min_rating:
                    return False

                if r.reviewer_id not in user_cache:
                    u = user_repo.get(r.reviewer_id)
                    user_cache[r.reviewer_id] = u.full_name if u else ""
                reviewer_name = user_cache[r.reviewer_id]

                text_parts: List[str] = []
                if req.search_in_title:
                    text_parts.append(r.title or "")
                if req.search_in_content:
                    text_parts.append(r.review_text or "")
                text_parts.append(reviewer_name)

                haystack = " ".join(text_parts).lower()
                return q in haystack

            matched = [r for r in records if _matches(r)]

            matched_sorted = sorted(matched, key=lambda r: r.created_at, reverse=True)
            start = params.offset
            end = start + params.limit
            page_records = matched_sorted[start:end]

            items: List[ReviewListItem] = []
            for r in page_records:
                reviewer_name = user_cache[r.reviewer_id]
                items.append(self._to_list_item(r, reviewer_name=reviewer_name))

            return PaginatedResponse[ReviewListItem].create(
                items=items,
                total_items=len(matched_sorted),
                page=params.page,
                page_size=params.page_size,
            )

    # ------------------------------------------------------------------ #
    # Summary
    # ------------------------------------------------------------------ #
    def get_summary_for_hostel(self, hostel_id: UUID) -> ReviewSummary:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            user_repo = self._get_user_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            reviews = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

            total_reviews = len(reviews)
            if total_reviews == 0:
                return ReviewSummary(
                    hostel_id=hostel_id,
                    hostel_name=hostel.name,
                    total_reviews=0,
                    average_rating=Decimal("0"),
                    rating_5_count=0,
                    rating_4_count=0,
                    rating_3_count=0,
                    rating_2_count=0,
                    rating_1_count=0,
                    verified_reviews_count=0,
                    verified_reviews_percentage=Decimal("0"),
                    recent_reviews=[],
                    would_recommend_percentage=Decimal("0"),
                )

            rating_counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}
            total_rating = Decimal("0")
            verified_count = 0

            for r in reviews:
                val = int(round(float(r.overall_rating)))
                val = min(5, max(1, val))
                rating_counts[val] += 1
                total_rating += r.overall_rating
                if r.is_verified_stay:
                    verified_count += 1

            avg_rating = total_rating / Decimal(str(total_reviews))

            verified_pct = (
                Decimal(str(verified_count)) / Decimal(str(total_reviews)) * Decimal("100")
            )

            # Recent reviews (up to 5)
            user_cache: Dict[UUID, str] = {}
            sorted_reviews = sorted(reviews, key=lambda r: r.created_at, reverse=True)
            recent_items: List[ReviewListItem] = []
            for r in sorted_reviews[:5]:
                if r.reviewer_id not in user_cache:
                    u = user_repo.get(r.reviewer_id)
                    user_cache[r.reviewer_id] = u.full_name if u else ""
                reviewer_name = user_cache[r.reviewer_id]
                recent_items.append(self._to_list_item(r, reviewer_name=reviewer_name))

            # would_recommend_percentage not tracked -> 0
            return ReviewSummary(
                hostel_id=hostel_id,
                hostel_name=hostel.name,
                total_reviews=total_reviews,
                average_rating=avg_rating,
                rating_5_count=rating_counts[5],
                rating_4_count=rating_counts[4],
                rating_3_count=rating_counts[3],
                rating_2_count=rating_counts[2],
                rating_1_count=rating_counts[1],
                verified_reviews_count=verified_count,
                verified_reviews_percentage=verified_pct,
                recent_reviews=recent_items,
                would_recommend_percentage=Decimal("0"),
            )

# --- File: D:\hostel-management-saas\app\services\review\review_voting_service.py ---
# app/services/review/review_voting_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from math import sqrt
from typing import Callable, Dict, List, Optional, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.content import ReviewRepository
from app.repositories.core import HostelRepository
from app.schemas.common.enums import VoteType
from app.schemas.review.review_voting import (
    VoteRequest,
    VoteResponse,
    HelpfulnessScore,
    VoteHistory,
    VoteHistoryItem,
    RemoveVote,
)
from app.services.common import UnitOfWork, errors


class VoteStore(Protocol):
    """
    Storage for per-user votes on reviews.

    Expected record shape:

        {
            "review_id": UUID,
            "voter_id": UUID,
            "vote_type": "helpful" | "not_helpful",
            "voted_at": datetime,
        }
    """

    def get_vote(self, review_id: UUID, voter_id: UUID) -> Optional[dict]: ...
    def save_vote(self, record: dict) -> None: ...
    def delete_vote(self, review_id: UUID, voter_id: UUID) -> None: ...
    def list_votes_for_review(self, review_id: UUID) -> List[dict]: ...
    def list_votes_for_user(self, user_id: UUID) -> List[dict]: ...


class ReviewVotingService:
    """
    Review helpfulness voting:

    - Cast/modify votes (helpful / not_helpful)
    - Remove vote
    - Compute HelpfulnessScore with Wilson score
    - User voting history
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        store: VoteStore,
    ) -> None:
        self._session_factory = session_factory
        self._store = store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_review_repo(self, uow: UnitOfWork) -> ReviewRepository:
        return uow.get_repo(ReviewRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Voting
    # ------------------------------------------------------------------ #
    def vote(self, data: VoteRequest) -> VoteResponse:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)

            r = review_repo.get(data.review_id)
            if r is None:
                raise errors.NotFoundError(f"Review {data.review_id} not found")

            existing = self._store.get_vote(data.review_id, data.voter_id)
            vote_type_str = data.vote_type.value if hasattr(data.vote_type, "value") else str(data.vote_type)

            # Adjust counts
            if existing:
                old_type = existing["vote_type"]
                if old_type == vote_type_str:
                    # No-op
                    return VoteResponse(
                        review_id=data.review_id,
                        vote_type=data.vote_type,
                        helpful_count=r.helpful_count,
                        not_helpful_count=r.not_helpful_count,
                        message="Vote unchanged",
                    )
                # Switch vote
                if old_type == "helpful":
                    r.helpful_count = max(0, r.helpful_count - 1)  # type: ignore[attr-defined]
                else:
                    r.not_helpful_count = max(0, r.not_helpful_count - 1)  # type: ignore[attr-defined]
            # Apply new vote
            if vote_type_str == "helpful":
                r.helpful_count = r.helpful_count + 1  # type: ignore[attr-defined]
            else:
                r.not_helpful_count = r.not_helpful_count + 1  # type: ignore[attr-defined]

            record = {
                "review_id": data.review_id,
                "voter_id": data.voter_id,
                "vote_type": vote_type_str,
                "voted_at": self._now(),
            }
            self._store.save_vote(record)
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return VoteResponse(
            review_id=data.review_id,
            vote_type=data.vote_type,
            helpful_count=r.helpful_count,
            not_helpful_count=r.not_helpful_count,
            message="Vote recorded",
        )

    def remove_vote(self, data: RemoveVote) -> VoteResponse:
        with UnitOfWork(self._session_factory) as uow:
            review_repo = self._get_review_repo(uow)

            r = review_repo.get(data.review_id)
            if r is None:
                raise errors.NotFoundError(f"Review {data.review_id} not found")

            existing = self._store.get_vote(data.review_id, data.voter_id)
            if not existing:
                raise errors.NotFoundError("Vote not found")

            if existing["vote_type"] == "helpful":
                r.helpful_count = max(0, r.helpful_count - 1)  # type: ignore[attr-defined]
            else:
                r.not_helpful_count = max(0, r.not_helpful_count - 1)  # type: ignore[attr-defined]

            self._store.delete_vote(data.review_id, data.voter_id)
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        # Return current counts (vote_type not really relevant here)
        return VoteResponse(
            review_id=data.review_id,
            vote_type=VoteType.HELPFUL,  # placeholder
            helpful_count=r.helpful_count,
            not_helpful_count=r.not_helpful_count,
            message="Vote removed",
        )

    # ------------------------------------------------------------------ #
    # Scores
    # ------------------------------------------------------------------ #
    def get_helpfulness_score(self, review_id: UUID) -> HelpfulnessScore:
        votes = self._store.list_votes_for_review(review_id)
        helpful = sum(1 for v in votes if v.get("vote_type") == "helpful")
        not_helpful = sum(1 for v in votes if v.get("vote_type") == "not_helpful")
        total = helpful + not_helpful

        if total == 0:
            return HelpfulnessScore(
                review_id=review_id,
                helpful_count=0,
                not_helpful_count=0,
                total_votes=0,
                helpfulness_percentage=Decimal("0"),
                helpfulness_score=Decimal("0"),
            )

        pct = Decimal(str(helpful)) / Decimal(str(total)) * Decimal("100")

        # Wilson score for lower bound of helpfulness
        phat = helpful / total
        z = 1.96
        wilson = (
            phat
            + z * z / (2 * total)
            - z * sqrt(
                phat * (1 - phat) / total + z * z / (4 * total * total)
            )
        ) / (1 + z * z / total)
        score = Decimal(str(wilson))

        return HelpfulnessScore(
            review_id=review_id,
            helpful_count=helpful,
            not_helpful_count=not_helpful,
            total_votes=total,
            helpfulness_percentage=pct,
            helpfulness_score=score,
        )

    # ------------------------------------------------------------------ #
    # History
    # ------------------------------------------------------------------ #
    def get_vote_history(self, user_id: UUID, *, limit: int = 10) -> VoteHistory:
        with UnitOfWork(self._session_factory) as uow:
            votes = self._store.list_votes_for_user(user_id)
            review_repo = self._get_review_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            votes_sorted = sorted(votes, key=lambda v: v.get("voted_at"), reverse=True)
            votes_subset = votes_sorted[:limit]

            items: List[VoteHistoryItem] = []
            helpful_votes = not_helpful_votes = 0

            cache_hostel: Dict[UUID, str] = {}

            for v in votes_subset:
                rid = v["review_id"]
                r = review_repo.get(rid)
                if not r:
                    continue
                hid = r.hostel_id
                if hid not in cache_hostel:
                    h = hostel_repo.get(hid)
                    cache_hostel[hid] = h.name if h else ""
                hostel_name = cache_hostel[hid]

                vt = v["vote_type"]
                if vt == "helpful":
                    helpful_votes += 1
                else:
                    not_helpful_votes += 1

                items.append(
                    VoteHistoryItem(
                        review_id=rid,
                        hostel_name=hostel_name,
                        vote_type=VoteType.HELPFUL if vt == "helpful" else VoteType.NOT_HELPFUL,
                        voted_at=v["voted_at"],
                    )
                )

        total_votes = len(votes)
        return VoteHistory(
            user_id=user_id,
            total_votes=total_votes,
            helpful_votes=helpful_votes,
            not_helpful_votes=not_helpful_votes,
            recent_votes=items,
        )

# --- File: D:\hostel-management-saas\app\services\review\__init__.py ---
# app/services/review/__init__.py
"""
Review-related services.

- ReviewService:
    Core CRUD, listing, summary for internal reviews (content_review).

- PublicReviewService:
    Public-facing submission flow mapped onto the internal review model.

- ReviewModerationService:
    Moderation queue, approve/reject/flag, and moderation stats.

- ReviewAnalyticsService:
    Aggregated review analytics per hostel.

- ReviewVotingService:
    Helpfulness voting (helpful / not helpful) with Wilson score.

- HostelResponseService:
    Hostel/owner responses to reviews and response stats.
"""

from .review_service import ReviewService
from .public_review_service import PublicReviewService
from .review_moderation_service import ReviewModerationService, ModerationStore
from .review_analytics_service import ReviewAnalyticsService
from .review_voting_service import ReviewVotingService, VoteStore
from .hostel_response_service import HostelResponseService, HostelResponseStore

__all__ = [
    "ReviewService",
    "PublicReviewService",
    "ReviewModerationService",
    "ModerationStore",
    "ReviewAnalyticsService",
    "ReviewVotingService",
    "VoteStore",
    "HostelResponseService",
    "HostelResponseStore",
]


# ===== Folder: D:\hostel-management-saas\app\services\room =====

# --- File: D:\hostel-management-saas\app\services\room\bed_assignment_service.py ---
# app/services/room/bed_assignment_service.py
from __future__ import annotations

from datetime import date
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import BedRepository, RoomRepository, StudentRepository, HostelRepository
from app.repositories.associations import StudentRoomAssignmentRepository
from app.schemas.room.bed_base import BedAssignmentRequest, BedReleaseRequest
from app.schemas.room.bed_response import (
    BedAssignment,
    BedHistory,
    BedAssignmentHistory,
)
from app.schemas.common.enums import BedStatus
from app.services.common import UnitOfWork, errors


class BedAssignmentService:
    """
    Bed assignment history service:

    - Assign bed to student (update Bed + Student + StudentRoomAssignment)
    - Release bed from student
    - Get bed history
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_assignment_repo(self, uow: UnitOfWork) -> StudentRoomAssignmentRepository:
        return uow.get_repo(StudentRoomAssignmentRepository)

    # ------------------------------------------------------------------ #
    # Assign
    # ------------------------------------------------------------------ #
    def assign_bed(self, req: BedAssignmentRequest) -> BedAssignment:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            room_repo = self._get_room_repo(uow)
            student_repo = self._get_student_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            assignment_repo = self._get_assignment_repo(uow)

            bed = bed_repo.get(req.bed_id)
            if bed is None:
                raise errors.NotFoundError(f"Bed {req.bed_id} not found")

            room = room_repo.get(bed.room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {bed.room_id} not found")

            hostel = hostel_repo.get(UUID(room.hostel_id) if isinstance(room.hostel_id, str) else room.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {room.hostel_id} not found")

            student = student_repo.get(req.student_id)
            if student is None or not getattr(student, "user", None):
                raise errors.NotFoundError(f"Student {req.student_id} not found")

            # Ensure bed is free
            if bed.current_student_id is not None:
                raise errors.ConflictError("Bed is already occupied")

            # Update bed
            bed.current_student_id = student.id  # type: ignore[attr-defined]
            bed.occupied_from = req.occupied_from  # type: ignore[attr-defined]
            bed.status = BedStatus.OCCUPIED  # type: ignore[attr-defined]

            # Update student
            student.room_id = room.id  # type: ignore[attr-defined]
            student.bed_id = bed.id  # type: ignore[attr-defined]

            # Create assignment history
            assignment_repo.create(
                {
                    "student_id": student.id,
                    "hostel_id": hostel.id,
                    "room_id": room.id,
                    "bed_id": bed.id,
                    "move_in_date": req.occupied_from,
                    "move_out_date": None,
                    "rent_amount": student.monthly_rent_amount,
                    "reason": None,
                }
            )

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            return BedAssignment(
                id=None,
                created_at=None,
                updated_at=None,
                bed_id=bed.id,
                room_id=room.id,
                room_number=room.room_number,
                bed_number=bed.bed_number,
                student_id=student.id,
                student_name=student.user.full_name,
                occupied_from=req.occupied_from,
                expected_vacate_date=None,
                monthly_rent=student.monthly_rent_amount,
            )

    # ------------------------------------------------------------------ #
    # Release
    # ------------------------------------------------------------------ #
    def release_bed(self, req: BedReleaseRequest) -> None:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            student_repo = self._get_student_repo(uow)
            assignment_repo = self._get_assignment_repo(uow)

            bed = bed_repo.get(req.bed_id)
            if bed is None:
                raise errors.NotFoundError(f"Bed {req.bed_id} not found")

            if bed.current_student_id is None:
                raise errors.ConflictError("Bed is not currently occupied")

            student = student_repo.get(bed.current_student_id)
            if student is None or not getattr(student, "user", None):
                raise errors.NotFoundError(f"Student {bed.current_student_id} not found")

            # Clear bed
            bed.current_student_id = None  # type: ignore[attr-defined]
            bed.occupied_from = None  # type: ignore[attr-defined]
            bed.status = BedStatus.AVAILABLE  # type: ignore[attr-defined]

            # Clear student bed assign (keep room_id if you want history)
            student.bed_id = None  # type: ignore[attr-defined]

            # Close active assignment
            active = assignment_repo.get_active_assignment(student.id)
            if active:
                active.move_out_date = req.release_date  # type: ignore[attr-defined]
                if req.reason:
                    active.reason = req.reason  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

    # ------------------------------------------------------------------ #
    # History
    # ------------------------------------------------------------------ #
    def get_bed_history(self, bed_id: UUID) -> BedHistory:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            room_repo = self._get_room_repo(uow)
            assignment_repo = self._get_assignment_repo(uow)
            student_repo = self._get_student_repo(uow)

            bed = bed_repo.get(bed_id)
            if bed is None:
                raise errors.NotFoundError(f"Bed {bed_id} not found")

            room = room_repo.get(bed.room_id)
            room_number = room.room_number if room else ""

            assignments = assignment_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"bed_id": bed_id},
            )

            history_items: List[BedAssignmentHistory] = []
            for a in assignments:
                st = student_repo.get(a.student_id)
                student_name = st.user.full_name if st and getattr(st, "user", None) else ""
                dur = None
                if a.move_out_date:
                    dur = (a.move_out_date - a.move_in_date).days
                history_items.append(
                    BedAssignmentHistory(
                        student_id=a.student_id,
                        student_name=student_name,
                        move_in_date=a.move_in_date,
                        move_out_date=a.move_out_date,
                        duration_days=dur,
                    )
                )

        return BedHistory(
            bed_id=bed_id,
            room_number=room_number,
            bed_number=bed.bed_number,
            assignments=history_items,
        )

# --- File: D:\hostel-management-saas\app\services\room\bed_service.py ---
# app/services/room/bed_service.py
from __future__ import annotations

from datetime import date
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import BedRepository, RoomRepository, StudentRepository
from app.schemas.room import (
    BedCreate,
    BedUpdate,
    BulkBedCreate,
    BedResponse,
)
from app.schemas.room.bed_response import BedAvailability
from app.schemas.common.enums import BedStatus
from app.services.common import UnitOfWork, errors


class BedService:
    """
    Bed lifecycle service:

    - Create/update beds (bulk & single)
    - Get bed detail
    - List beds for a room
    - Simple availability info
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    # ------------------------------------------------------------------ #
    # Mapping
    # ------------------------------------------------------------------ #
    def _to_bed_response(self, bed) -> BedResponse:
        return BedResponse(
            id=bed.id,
            created_at=bed.created_at,
            updated_at=bed.updated_at,
            room_id=bed.room_id,
            bed_number=bed.bed_number,
            is_occupied=bed.current_student_id is not None,
            status=bed.status,
            current_student_id=bed.current_student_id,
            occupied_from=bed.occupied_from,
        )

    # ------------------------------------------------------------------ #
    # CRUD
    # ------------------------------------------------------------------ #
    def create_bed(self, data: BedCreate) -> BedResponse:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            room_repo = self._get_room_repo(uow)

            room = room_repo.get(data.room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {data.room_id} not found")

            payload = data.model_dump(exclude_unset=True)
            bed = bed_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()
            return self._to_bed_response(bed)

    def bulk_create_beds(self, data: BulkBedCreate) -> List[BedResponse]:
        """
        Create a sequence of beds (e.g. B1..B4) for a given room.
        """
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            room_repo = self._get_room_repo(uow)

            room = room_repo.get(data.room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {data.room_id} not found")

            payloads = []
            for i in range(data.start_number, data.start_number + data.bed_count):
                bed_number = f"{data.bed_prefix}{i}"
                payloads.append(
                    {
                        "hostel_id": room.hostel_id,
                        "room_id": data.room_id,
                        "bed_number": bed_number,
                        "status": BedStatus.AVAILABLE,
                    }
                )
            beds = bed_repo.bulk_create(payloads)  # type: ignore[arg-type]
            uow.commit()
            return [self._to_bed_response(b) for b in beds]

    def update_bed(self, bed_id: UUID, data: BedUpdate) -> BedResponse:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)

            bed = bed_repo.get(bed_id)
            if bed is None:
                raise errors.NotFoundError(f"Bed {bed_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(bed, field) and field != "id":
                    setattr(bed, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return self._to_bed_response(bed)

    def get_bed(self, bed_id: UUID) -> BedResponse:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            bed = bed_repo.get(bed_id)
            if bed is None:
                raise errors.NotFoundError(f"Bed {bed_id} not found")
            return self._to_bed_response(bed)

    # ------------------------------------------------------------------ #
    # Listing & availability
    # ------------------------------------------------------------------ #
    def list_beds_for_room(self, room_id: UUID) -> List[BedResponse]:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            beds = bed_repo.get_multi(filters={"room_id": room_id})
            return [self._to_bed_response(b) for b in beds]

    def list_available_beds_for_room(self, room_id: UUID) -> List[BedAvailability]:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            room_repo = self._get_room_repo(uow)
            student_repo = self._get_student_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            beds = bed_repo.list_available_beds_for_room(room_id)

            avail: List[BedAvailability] = []
            for b in beds:
                student_name = None
                if b.current_student_id:
                    st = student_repo.get(b.current_student_id)
                    if st and getattr(st, "user", None):
                        student_name = st.user.full_name

                avail.append(
                    BedAvailability(
                        bed_id=b.id,
                        room_id=room_id,
                        room_number=room.room_number,
                        bed_number=b.bed_number,
                        is_available=b.current_student_id is None and b.status == BedStatus.AVAILABLE,
                        status=b.status,
                        available_from=b.occupied_from if b.current_student_id else date.today(),
                        current_student_name=student_name,
                    )
                )

            return avail

# --- File: D:\hostel-management-saas\app\services\room\room_availability_service.py ---
# app/services/room/room_availability_service.py
from __future__ import annotations

from calendar import monthrange
from datetime import date, timedelta
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import RoomRepository, BedRepository, HostelRepository, StudentRepository
from app.schemas.room.room_availability import (
    RoomAvailabilityRequest,
    AvailabilityResponse,
    AvailableRoom,
    AvailabilityCalendar,
    DayAvailability,
    BookingInfo,
)
from app.schemas.common.enums import RoomType, BedStatus
from app.services.common import UnitOfWork, errors


class RoomAvailabilityService:
    """
    Room availability service (simplified):

    - Check current availability for a hostel/date/room_type.
    - Build a naive monthly availability calendar per room.

    NOTE:
    For accurate future occupancy, integrate with booking/schedule data.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _add_months(self, d: date, months: int) -> date:
        month = d.month - 1 + months
        year = d.year + month // 12
        month = month % 12 + 1
        day = min(
            d.day,
            monthrange(year, month)[1],
        )
        return date(year, month, day)

    # ------------------------------------------------------------------ #
    # Availability
    # ------------------------------------------------------------------ #
    def check_availability(self, req: RoomAvailabilityRequest) -> AvailabilityResponse:
        """
        Compute availability for given hostel/date/room_type.

        This implementation uses current bed occupancy only (no future bookings).
        """
        check_in = req.check_in_date
        check_out = self._add_months(check_in, req.duration_months)

        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(req.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {req.hostel_id} not found")

            rooms = room_repo.list_for_hostel(
                hostel_id=req.hostel_id,
                only_available=True,
                room_type=req.room_type,
            )
            room_ids = [r.id for r in rooms]
            bed_map: Dict[UUID, List] = {rid: [] for rid in room_ids}
            all_beds = bed_repo.get_multi(filters={"room_id": room_ids}) if room_ids else []
            for b in all_beds:
                bed_map.setdefault(b.room_id, []).append(b)

        available_rooms: List[AvailableRoom] = []
        total_available_beds = 0

        for r in rooms:
            beds = bed_map.get(r.id, [])
            available_beds = sum(
                1 for b in beds
                if b.current_student_id is None and b.status == BedStatus.AVAILABLE
            )
            if available_beds <= 0:
                continue

            total_available_beds += available_beds

            available_rooms.append(
                AvailableRoom(
                    room_id=r.id,
                    room_number=r.room_number,
                    room_type=r.room_type,
                    floor_number=r.floor_number,
                    available_beds=available_beds,
                    total_beds=r.total_beds,
                    price_monthly=r.price_monthly,
                    is_ac=r.is_ac,
                    has_attached_bathroom=r.has_attached_bathroom,
                    amenities=r.amenities or [],
                    room_images=r.room_images or [],
                )
            )

        return AvailabilityResponse(
            hostel_id=req.hostel_id,
            check_in_date=check_in,
            check_out_date=check_out,
            available_rooms=available_rooms,
            total_available_beds=total_available_beds,
            has_availability=total_available_beds > 0,
        )

    # ------------------------------------------------------------------ #
    # Calendar
    # ------------------------------------------------------------------ #
    def get_availability_calendar(
        self,
        room_id: UUID,
        month: str,
    ) -> AvailabilityCalendar:
        """
        Naive availability calendar for a room.

        Assumes current occupancy is constant over the month (no bookings).
        """
        try:
            year, m = map(int, month.split("-"))
        except ValueError:
            raise errors.ValidationError("month must be in 'YYYY-MM' format")

        start = date(year, m, 1)
        last_day = monthrange(year, m)[1]
        end = date(year, m, last_day)

        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)
            student_repo = self._get_student_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            beds = bed_repo.get_multi(filters={"room_id": room.id})
            total_beds = room.total_beds
            available_beds = sum(
                1 for b in beds
                if b.current_student_id is None and b.status == BedStatus.AVAILABLE
            )

        # For now we assume occupancy static across the month.
        availability: Dict[str, DayAvailability] = {}
        cur = start
        while cur <= end:
            availability[cur.isoformat()] = DayAvailability(
                date=cur,
                available_beds=available_beds,
                total_beds=total_beds,
                is_available=available_beds > 0,
                bookings=[],  # no booking data wired yet
            )
            cur += timedelta(days=1)

        return AvailabilityCalendar(
            room_id=room.id,
            room_number=room.room_number,
            month=month,
            availability=availability,
        )

# --- File: D:\hostel-management-saas\app\services\room\room_service.py ---
# app/services/room/room_service.py
from __future__ import annotations

from decimal import Decimal
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import RoomRepository, BedRepository, HostelRepository, StudentRepository
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.room import (
    RoomCreate,
    RoomUpdate,
    BulkRoomCreate,
    RoomResponse,
    RoomDetail,
    RoomListItem,
    RoomWithBeds,
)
from app.schemas.room.room_response import BedDetail, RoomOccupancyStats
from app.schemas.common.enums import RoomType, RoomStatus, BedStatus
from app.services.common import UnitOfWork, errors


class RoomService:
    """
    Core room service:

    - Create / update rooms (bulk + single)
    - Get room detail with bed occupancy
    - List rooms for a hostel
    - Simple occupancy stats
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _occupied_available(
        self,
        *,
        total_beds: int,
        beds: Sequence,
    ) -> tuple[int, int]:
        occupied = sum(1 for b in beds if b.current_student_id is not None)
        available = max(0, total_beds - occupied)
        return occupied, available

    def _to_room_response(
        self,
        room,
        *,
        occupied_beds: int,
        available_beds: int,
    ) -> RoomResponse:
        return RoomResponse(
            id=room.id,
            created_at=room.created_at,
            updated_at=room.updated_at,
            hostel_id=UUID(room.hostel_id) if isinstance(room.hostel_id, str) else room.hostel_id,
            room_number=room.room_number,
            floor_number=room.floor_number,
            wing=room.wing,
            room_type=room.room_type,
            total_beds=room.total_beds,
            occupied_beds=occupied_beds,
            available_beds=available_beds,
            price_monthly=room.price_monthly,
            is_ac=room.is_ac,
            has_attached_bathroom=room.has_attached_bathroom,
            status=room.status,
            is_available_for_booking=room.is_available_for_booking,
        )

    def _to_room_list_item(
        self,
        room,
        *,
        available_beds: int,
    ) -> RoomListItem:
        return RoomListItem(
            id=room.id,
            room_number=room.room_number,
            floor_number=room.floor_number,
            wing=room.wing,
            room_type=room.room_type,
            total_beds=room.total_beds,
            available_beds=available_beds,
            price_monthly=room.price_monthly,
            is_ac=room.is_ac,
            status=room.status,
            is_available_for_booking=room.is_available_for_booking,
        )

    def _to_bed_detail(self, bed, *, student_name: Optional[str]) -> BedDetail:
        return BedDetail(
            id=bed.id,
            bed_number=bed.bed_number,
            is_occupied=bed.current_student_id is not None,
            status=bed.status.value if hasattr(bed.status, "value") else str(bed.status),
            current_student_id=bed.current_student_id,
            current_student_name=student_name,
            occupied_from=bed.occupied_from,
        )

    def _to_room_detail(
        self,
        room,
        *,
        hostel_name: str,
        beds: Sequence,
        student_names: Dict[UUID, str],
    ) -> RoomDetail:
        occupied, available = self._occupied_available(
            total_beds=room.total_beds,
            beds=beds,
        )

        bed_details: List[BedDetail] = []
        for b in beds:
            s_name = student_names.get(b.current_student_id) if b.current_student_id else None
            bed_details.append(self._to_bed_detail(b, student_name=s_name))

        return RoomDetail(
            id=room.id,
            created_at=room.created_at,
            updated_at=room.updated_at,
            hostel_id=UUID(room.hostel_id) if isinstance(room.hostel_id, str) else room.hostel_id,
            hostel_name=hostel_name,
            room_number=room.room_number,
            floor_number=room.floor_number,
            wing=room.wing,
            room_type=room.room_type,
            total_beds=room.total_beds,
            occupied_beds=occupied,
            available_beds=available,
            price_monthly=room.price_monthly,
            price_quarterly=room.price_quarterly,
            price_half_yearly=room.price_half_yearly,
            price_yearly=room.price_yearly,
            room_size_sqft=room.room_size_sqft,
            is_ac=room.is_ac,
            has_attached_bathroom=room.has_attached_bathroom,
            has_balcony=room.has_balcony,
            has_wifi=room.has_wifi,
            amenities=room.amenities or [],
            furnishing=room.furnishing or [],
            status=room.status,
            is_available_for_booking=room.is_available_for_booking,
            is_under_maintenance=room.is_under_maintenance,
            maintenance_start_date=None,
            maintenance_end_date=None,
            room_images=room.room_images or [],
            beds=bed_details,
        )

    # ------------------------------------------------------------------ #
    # CRUD
    # ------------------------------------------------------------------ #
    def create_room(self, data: RoomCreate) -> RoomDetail:
        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            payload = data.model_dump(exclude_unset=True)
            room = room_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            # No beds yet
            return self._to_room_detail(
                room,
                hostel_name=hostel.name,
                beds=[],
                student_names={},
            )

    def bulk_create_rooms(self, data: BulkRoomCreate) -> List[RoomDetail]:
        responses: List[RoomDetail] = []
        for rc in data.rooms:
            # enforce same hostel_id as BulkRoomCreate
            rc = RoomCreate(**{**rc.model_dump(exclude_unset=True), "hostel_id": data.hostel_id})
            responses.append(self.create_room(rc))
        return responses

    def update_room(self, room_id: UUID, data: RoomUpdate) -> RoomDetail:
        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            bed_repo = self._get_bed_repo(uow)
            student_repo = self._get_student_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(room, field) and field != "id":
                    setattr(room, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            hostel = hostel_repo.get(UUID(room.hostel_id) if isinstance(room.hostel_id, str) else room.hostel_id)
            hostel_name = hostel.name if hostel else ""
            beds = bed_repo.get_multi(filters={"room_id": room.id})
            student_names: Dict[UUID, str] = {}
            for b in beds:
                if b.current_student_id and b.current_student_id not in student_names:
                    st = student_repo.get(b.current_student_id)
                    if st and getattr(st, "user", None):
                        student_names[b.current_student_id] = st.user.full_name

            uow.commit()
            return self._to_room_detail(room, hostel_name=hostel_name, beds=beds, student_names=student_names)

    def get_room(self, room_id: UUID) -> RoomDetail:
        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            hostel = hostel_repo.get(UUID(room.hostel_id) if isinstance(room.hostel_id, str) else room.hostel_id)
            hostel_name = hostel.name if hostel else ""

            beds = bed_repo.get_multi(filters={"room_id": room.id})
            student_names: Dict[UUID, str] = {}
            for b in beds:
                if b.current_student_id and b.current_student_id not in student_names:
                    st = student_repo.get(b.current_student_id)
                    if st and getattr(st, "user", None):
                        student_names[b.current_student_id] = st.user.full_name

            return self._to_room_detail(room, hostel_name=hostel_name, beds=beds, student_names=student_names)

    # ------------------------------------------------------------------ #
    # Listing
    # ------------------------------------------------------------------ #
    def list_rooms_for_hostel(
        self,
        hostel_id: UUID,
        params: PaginationParams,
        *,
        room_type: Optional[RoomType] = None,
        only_available: bool = False,
    ) -> PaginatedResponse[RoomListItem]:
        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)

            rooms = room_repo.list_for_hostel(
                hostel_id=hostel_id,
                only_available=only_available,
                room_type=room_type,
            )

            # Preload beds grouped by room
            room_ids = [r.id for r in rooms]
            bed_map: Dict[UUID, List] = {rid: [] for rid in room_ids}
            all_beds = bed_repo.get_multi(filters={"room_id": room_ids}) if room_ids else []
            for b in all_beds:
                bed_map.setdefault(b.room_id, []).append(b)

            items: List[RoomListItem] = []
            for r in rooms:
                beds = bed_map.get(r.id, [])
                _, available = self._occupied_available(total_beds=r.total_beds, beds=beds)
                items.append(self._to_room_list_item(r, available_beds=available))

            total = len(items)
            start = params.offset
            end = start + params.limit
            page_items = items[start:end]

            return PaginatedResponse[RoomListItem].create(
                items=page_items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    # ------------------------------------------------------------------ #
    # Room with beds & stats
    # ------------------------------------------------------------------ #
    def get_room_with_beds(self, room_id: UUID) -> RoomWithBeds:
        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)
            student_repo = self._get_student_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            beds = bed_repo.get_multi(filters={"room_id": room.id})
            occupied, available = self._occupied_available(
                total_beds=room.total_beds,
                beds=beds,
            )

            from app.schemas.room.room_response import BedInfo

            student_names: Dict[UUID, str] = {}
            bed_infos: List[BedInfo] = []
            for b in beds:
                s_name = None
                if b.current_student_id:
                    if b.current_student_id not in student_names:
                        st = student_repo.get(b.current_student_id)
                        if st and getattr(st, "user", None):
                            student_names[b.current_student_id] = st.user.full_name
                    s_name = student_names.get(b.current_student_id)
                bed_infos.append(
                    BedInfo(
                        id=b.id,
                        bed_number=b.bed_number,
                        is_occupied=b.current_student_id is not None,
                        status=b.status.value if hasattr(b.status, "value") else str(b.status),
                        student_name=s_name,
                    )
                )

            return RoomWithBeds(
                id=room.id,
                created_at=room.created_at,
                updated_at=room.updated_at,
                hostel_id=UUID(room.hostel_id) if isinstance(room.hostel_id, str) else room.hostel_id,
                room_number=room.room_number,
                room_type=room.room_type,
                total_beds=room.total_beds,
                occupied_beds=occupied,
                available_beds=available,
                beds=bed_infos,
            )

    def get_room_occupancy_stats(self, room_id: UUID) -> RoomOccupancyStats:
        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            beds = bed_repo.get_multi(filters={"room_id": room.id})
            occupied, available = self._occupied_available(
                total_beds=room.total_beds,
                beds=beds,
            )

            # Very simple revenue estimates:
            current_revenue = room.price_monthly * Decimal(str(occupied))
            potential_revenue = room.price_monthly * Decimal(str(room.total_beds))

            occ_pct = (
                Decimal(str(occupied)) / Decimal(str(room.total_beds)) * Decimal("100")
                if room.total_beds > 0
                else Decimal("0")
            )

            return RoomOccupancyStats(
                room_id=room.id,
                room_number=room.room_number,
                total_beds=room.total_beds,
                occupied_beds=occupied,
                available_beds=available,
                occupancy_percentage=occ_pct,
                current_revenue=current_revenue,
                potential_revenue=potential_revenue,
            )

# --- File: D:\hostel-management-saas\app\services\room\__init__.py ---
# app/services/room/__init__.py
"""
Room and bed services.

- RoomService:
    Core CRUD, listing, and detail for rooms with occupancy data.

- RoomAvailabilityService:
    Availability checks and basic availability calendar per room.

- BedService:
    CRUD and listing for beds, plus simple availability info.

- BedAssignmentService:
    Assign/release beds to/from students and maintain history.
"""

from .room_service import RoomService
from .room_availability_service import RoomAvailabilityService
from .bed_service import BedService
from .bed_assignment_service import BedAssignmentService

__all__ = [
    "RoomService",
    "RoomAvailabilityService",
    "BedService",
    "BedAssignmentService",
]


# ===== Folder: D:\hostel-management-saas\app\services\search =====

# --- File: D:\hostel-management-saas\app\services\search\autocomplete_service.py ---
# app/services/search/autocomplete_service.py
from __future__ import annotations

from typing import Callable, Dict, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.visitor import VisitorHostelRepository
from app.schemas.search.search_autocomplete import (
    AutocompleteRequest,
    AutocompleteResponse,
    Suggestion,
)
from app.services.common import UnitOfWork


class AutocompleteService:
    """
    Autocomplete / suggestions for:

    - hostel names
    - city
    - area

    Uses VisitorHostel denormalized view for simple prefix-based suggestions.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_visitor_hostel_repo(self, uow: UnitOfWork) -> VisitorHostelRepository:
        return uow.get_repo(VisitorHostelRepository)

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_suggestions(self, req: AutocompleteRequest) -> AutocompleteResponse:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_visitor_hostel_repo(uow)

            # Fetch a reasonable number of items; refine in Python
            candidates = repo.search(
                city=None,
                area=None,
                min_price=None,
                max_price=None,
                gender_type=None,
                search=req.prefix,
                limit=200,
            )

            suggestions: List[Suggestion] = []
            prefix = req.prefix.lower()

            if req.type == "hostel":
                # Suggest hostel names starting with prefix
                seen: Dict[str, bool] = {}
                for vh in candidates:
                    name = vh.hostel_name
                    if not name:
                        continue
                    if not name.lower().startswith(prefix):
                        continue
                    if name in seen:
                        continue
                    seen[name] = True
                    suggestions.append(
                        Suggestion(
                            value=name,
                            label=name,
                            type="hostel",
                            extra={
                                "hostel_id": str(vh.hostel_id),
                                "city": vh.city,
                            },
                        )
                    )
                    if len(suggestions) >= req.limit:
                        break

            elif req.type == "city":
                # Unique city names starting with prefix
                seen: Dict[str, int] = {}
                for vh in candidates:
                    city = vh.city
                    if not city:
                        continue
                    if not city.lower().startswith(prefix):
                        continue
                    seen[city] = seen.get(city, 0) + 1

                for city, count in sorted(seen.items(), key=lambda x: -x[1])[: req.limit]:
                    suggestions.append(
                        Suggestion(
                            value=city,
                            label=city,
                            type="city",
                            extra={"count": count},
                        )
                    )

            else:  # area
                # Use VisitorHostel.location or area field (if present)
                seen: Dict[str, int] = {}
                for vh in candidates:
                    area = getattr(vh, "area", None) or getattr(vh, "location", None)
                    if not area:
                        continue
                    if not area.lower().startswith(prefix):
                        continue
                    seen[area] = seen.get(area, 0) + 1

                for area, count in sorted(seen.items(), key=lambda x: -x[1])[: req.limit]:
                    suggestions.append(
                        Suggestion(
                            value=area,
                            label=area,
                            type="area",
                            extra={"count": count},
                        )
                    )

        return AutocompleteResponse(suggestions=suggestions)

# --- File: D:\hostel-management-saas\app\services\search\search_analytics_service.py ---
# app/services/search/search_analytics_service.py
from __future__ import annotations

from collections import defaultdict
from datetime import datetime
from typing import List, Dict, Protocol

from app.schemas.search.search_analytics import (
    SearchAnalytics,
    SearchTermStats,
)
from app.schemas.common.filters import DateRangeFilter


class SearchEventStore(Protocol):
    """
    Abstract store for individual search events.

    Each event record is expected to include:
    - term: str
    - results_count: int
    - created_at: datetime
    """

    def save_event(
        self,
        *,
        term: str,
        results_count: int,
        created_at: datetime,
    ) -> None: ...

    def list_events(
        self,
        *,
        period_start: datetime,
        period_end: datetime,
    ) -> List[dict]: ...


class SearchAnalyticsService:
    """
    Record and compute analytics for search usage:

    - Record each search event (term + results_count)
    - Aggregate per-term statistics over a DateRangeFilter
    - Provide SearchAnalytics with top terms, zero-result terms, etc.
    """

    def __init__(self, store: SearchEventStore) -> None:
        self._store = store

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Recording
    # ------------------------------------------------------------------ #
    def record_search_event(self, term: str, results_count: int) -> None:
        """
        Record a single search event.
        """
        self._store.save_event(
            term=term.strip().lower(),
            results_count=results_count,
            created_at=self._now(),
        )

    # ------------------------------------------------------------------ #
    # Analytics
    # ------------------------------------------------------------------ #
    def get_analytics(self, period: DateRangeFilter) -> SearchAnalytics:
        if not (period.start_date and period.end_date):
            # If period not specified, default to "all time"
            period_start = datetime.min
            period_end = datetime.max
        else:
            period_start = datetime.combine(period.start_date, datetime.min.time())
            period_end = datetime.combine(period.end_date, datetime.max.time())

        events = self._store.list_events(
            period_start=period_start,
            period_end=period_end,
        )

        # Aggregate per term
        term_stats: Dict[str, Dict[str, object]] = defaultdict(
            lambda: {
                "count": 0,
                "sum_results": 0,
                "zero_results": 0,
                "last_at": datetime.min,
            }
        )

        total_searches = 0
        total_results_sum = 0
        zero_result_searches = 0

        for ev in events:
            term = (ev.get("term") or "").strip().lower()
            if not term:
                continue
            rc = int(ev.get("results_count", 0))
            ts: datetime = ev.get("created_at", datetime.min)

            total_searches += 1
            total_results_sum += rc
            if rc == 0:
                zero_result_searches += 1

            s = term_stats[term]
            s["count"] = int(s["count"]) + 1
            s["sum_results"] = int(s["sum_results"]) + rc
            if rc == 0:
                s["zero_results"] = int(s["zero_results"]) + 1
            if ts > s["last_at"]:
                s["last_at"] = ts

        unique_terms = len(term_stats)

        # Build SearchTermStats lists
        top_terms: List[SearchTermStats] = []
        zero_terms: List[SearchTermStats] = []

        for term, s in term_stats.items():
            count = int(s["count"])
            sum_results = int(s["sum_results"])
            zero_count = int(s["zero_results"])
            last_at: datetime = s["last_at"]
            avg_results = float(sum_results / count) if count > 0 else 0.0

            sts = SearchTermStats(
                term=term,
                search_count=count,
                avg_results=avg_results,
                zero_result_count=zero_count,
                last_searched_at=last_at,
            )
            top_terms.append(sts)
            if zero_count > 0:
                zero_terms.append(sts)

        # Sort by search_count descending
        top_terms.sort(key=lambda s: s.search_count, reverse=True)
        zero_terms.sort(key=lambda s: s.search_count, reverse=True)

        avg_results_per_search = (
            float(total_results_sum / total_searches) if total_searches > 0 else 0.0
        )

        return SearchAnalytics(
            period=period,
            total_searches=total_searches,
            unique_terms=unique_terms,
            zero_result_searches=zero_result_searches,
            top_terms=top_terms[:20],
            zero_result_terms=zero_terms[:20],
            avg_results_per_search=avg_results_per_search,
        )

# --- File: D:\hostel-management-saas\app\services\search\search_indexer_service.py ---
# app/services/search/search_indexer_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository
from app.repositories.visitor import VisitorHostelRepository
from app.schemas.common.enums import HostelStatus
from app.services.common import UnitOfWork, errors


class SearchIndexBackend(Protocol):
    """
    Abstract search index backend.

    Implementations should wrap your actual search engine client
    (Elasticsearch, Meilisearch, OpenSearch, etc.).
    """

    def index_document(
        self,
        *,
        index: str,
        document_id: str,
        body: Dict,
    ) -> None: ...
    """
    Index (create or update) a document in the given index.
    """

    def delete_document(
        self,
        *,
        index: str,
        document_id: str,
    ) -> None: ...
    """
    Delete a document from the given index (no-op if not found).
    """

    def bulk_index(
        self,
        *,
        index: str,
        documents: List[Dict],
    ) -> None: ...
    """
    Bulk index documents.

    Each document dict is expected to include an 'id' key used as document_id.
    """


class SearchIndexerService:
    """
    Service responsible for (re)indexing hostels into a search backend.

    - Build a unified search document combining VisitorHostel + core Hostel
    - Index a single hostel
    - Bulk reindex all public/active hostels
    - Remove hostel from index

    This is optional infrastructure: your current SearchService works directly
    on the DB. Use this when you introduce a dedicated search engine.
    """

    INDEX_NAME = "hostels"

    def __init__(
        self,
        session_factory: Callable[[], Session],
        backend: SearchIndexBackend,
    ) -> None:
        self._session_factory = session_factory
        self._backend = backend

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_visitor_hostel_repo(self, uow: UnitOfWork) -> VisitorHostelRepository:
        return uow.get_repo(VisitorHostelRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Document builder
    # ------------------------------------------------------------------ #
    def _build_hostel_document(
        self,
        *,
        hostel,
        visitor_hostel: Optional[object],
    ) -> Dict:
        """
        Build a single search document from core_hostel + visitor_hostel.

        The resulting dict is what gets sent to the search engine.
        """
        # Base from core_hostel
        doc: Dict[str, object] = {
            "id": str(hostel.id),
            "hostel_id": str(hostel.id),
            "slug": hostel.slug,
            "name": hostel.name,
            "description": hostel.description or "",
            "hostel_type": hostel.hostel_type.value
            if hasattr(hostel.hostel_type, "value")
            else str(hostel.hostel_type),
            # Location
            "address_line1": hostel.address_line1,
            "address_line2": hostel.address_line2 or "",
            "city": hostel.city,
            "state": hostel.state,
            "pincode": hostel.pincode,
            "country": hostel.country,
            # Pricing
            "starting_price_monthly": float(hostel.starting_price_monthly or 0),
            "currency": hostel.currency or "INR",
            # Capacity
            "total_rooms": hostel.total_rooms or 0,
            "total_beds": hostel.total_beds or 0,
            "occupied_beds": hostel.occupied_beds or 0,
            "available_beds": max(
                0,
                (hostel.total_beds or 0) - (hostel.occupied_beds or 0),
            ),
            # Features
            "amenities": hostel.amenities or [],
            "facilities": hostel.facilities or [],
            "security_features": hostel.security_features or [],
            # Ratings
            "average_rating": float(hostel.average_rating or 0.0),
            "total_reviews": hostel.total_reviews or 0,
            # Status flags
            "is_public": hostel.is_public,
            "is_featured": hostel.is_featured,
            "is_verified": hostel.is_verified,
            "is_active": hostel.is_active,
            "status": hostel.status.value
            if hasattr(hostel.status, "value")
            else str(hostel.status),
            # Media
            "cover_image_url": hostel.cover_image_url or "",
            "gallery_images": hostel.gallery_images or [],
            "virtual_tour_url": hostel.virtual_tour_url or "",
            # Timestamps
            "created_at": hostel.created_at.isoformat()
            if getattr(hostel, "created_at", None)
            else None,
            "updated_at": hostel.updated_at.isoformat()
            if getattr(hostel, "updated_at", None)
            else None,
        }

        # Enrich from VisitorHostel if available
        if visitor_hostel is not None:
            vh = visitor_hostel
            # Price range / rating from visitor table may be more tailored
            if getattr(vh, "min_price", None) is not None:
                doc["starting_price_monthly"] = float(vh.min_price)
            doc["min_price"] = float(vh.min_price or 0)
            doc["max_price"] = float(vh.max_price or 0)
            doc["price_range"] = vh.price_range or ""
            doc["gender_type"] = vh.gender_type or ""
            doc["availability"] = vh.availability or 0
            doc["total_capacity"] = vh.total_capacity or 0
            doc["rating"] = float(vh.rating or hostel.average_rating or 0.0)
            doc["total_reviews"] = vh.total_reviews or hostel.total_reviews or 0
            doc["visitor_amenities"] = vh.amenities or []
            doc["photos"] = vh.photos or []
            doc["availability_status"] = vh.availability_status or ""
            doc["location"] = vh.location or ""
            doc["area"] = vh.area or ""
            doc["visitor_contact_number"] = vh.contact_number or ""
            doc["visitor_contact_email"] = vh.contact_email or ""

        return doc

    # ------------------------------------------------------------------ #
    # Single hostel indexing
    # ------------------------------------------------------------------ #
    def index_hostel(self, hostel_id: UUID) -> Dict:
        """
        Fetch a single hostel + visitor_hostel view and index it.

        Returns the document body that was indexed.
        """
        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            visitor_repo = self._get_visitor_hostel_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {hostel_id} not found")

            # Only index public/active hostels
            if not hostel.is_public or not hostel.is_active or hostel.status != HostelStatus.ACTIVE:
                # If it's in index, we should remove it instead
                self.remove_hostel_from_index(hostel_id)
                raise errors.ValidationError(
                    "Only active & public hostels can be indexed"
                )

            vh = visitor_repo.get_by_id(hostel_id) if hasattr(visitor_repo, "get_by_id") else None

            doc = self._build_hostel_document(hostel=hostel, visitor_hostel=vh)

        self._backend.index_document(
            index=self.INDEX_NAME,
            document_id=str(hostel_id),
            body=doc,
        )
        return doc

    # ------------------------------------------------------------------ #
    # Bulk reindex
    # ------------------------------------------------------------------ #
    def reindex_all_hostels(self, batch_size: int = 200) -> int:
        """
        Bulk reindex all public & active hostels into the search index.

        Returns the total number of hostels indexed.
        """
        total_indexed = 0

        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            visitor_repo = self._get_visitor_hostel_repo(uow)

            # Fetch all hostels that are public & active & HOSTEL_STATUS = ACTIVE
            filters = {
                "is_public": True,
                "is_active": True,
                "status": HostelStatus.ACTIVE,
            }
            all_hostels = hostel_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters,
            )

            # Index in batches
            batch_docs: List[Dict] = []
            for hostel in all_hostels:
                vh = None
                # Use visitor_hostel row if you have a get_by_hostel_id helper;
                # otherwise you can search via get_multi
                if hasattr(visitor_repo, "get_by_hostel_id"):
                    vh = visitor_repo.get_by_hostel_id(hostel.id)
                else:
                    cand = visitor_repo.get_multi(
                        skip=0,
                        limit=1,
                        filters={"hostel_id": hostel.id},
                    )
                    vh = cand[0] if cand else None

                doc = self._build_hostel_document(
                    hostel=hostel,
                    visitor_hostel=vh,
                )
                batch_docs.append(doc)

                if len(batch_docs) >= batch_size:
                    self._backend.bulk_index(
                        index=self.INDEX_NAME,
                        documents=batch_docs,
                    )
                    total_indexed += len(batch_docs)
                    batch_docs = []

            if batch_docs:
                self._backend.bulk_index(
                    index=self.INDEX_NAME,
                    documents=batch_docs,
                )
                total_indexed += len(batch_docs)

        return total_indexed

    # ------------------------------------------------------------------ #
    # Deletion
    # ------------------------------------------------------------------ #
    def remove_hostel_from_index(self, hostel_id: UUID) -> None:
        """
        Remove a hostel document from the search index.
        """
        self._backend.delete_document(
            index=self.INDEX_NAME,
            document_id=str(hostel_id),
        )

# --- File: D:\hostel-management-saas\app\services\search\search_service.py ---
# app/services/search/search_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from math import ceil
from typing import Callable, Dict, List, Optional, Tuple
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.visitor import VisitorHostelRepository
from app.repositories.core import HostelRepository
from app.schemas.hostel.hostel_public import PublicHostelCard
from app.schemas.search.search_request import (
    AdvancedSearchRequest,
    BasicSearchRequest,
)
from app.schemas.search.search_response import (
    SearchResultItem,
    FacetBucket,
    FacetedSearchResponse,
)
from app.services.common import UnitOfWork


class SearchService:
    """
    Search service for hostels (public side), using:

    - AdvancedSearchRequest / BasicSearchRequest
    - FacetedSearchResponse, SearchResultItem

    It leverages VisitorHostel (denormalized search view) + core_hostel
    to provide reasonable search & facet behavior without a dedicated
    search engine.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_visitor_hostel_repo(self, uow: UnitOfWork) -> VisitorHostelRepository:
        return uow.get_repo(VisitorHostelRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def basic_search(self, req: BasicSearchRequest) -> FacetedSearchResponse:
        """
        Map BasicSearchRequest → AdvancedSearchRequest with only query filled.
        """
        adv = AdvancedSearchRequest(
            query=req.query,
            city=None,
            state=None,
            pincode=None,
            latitude=None,
            longitude=None,
            radius_km=None,
            hostel_type=None,
            room_type=None,
            min_price=None,
            max_price=None,
            amenities=None,
            min_rating=None,
            verified_only=False,
            available_only=False,
            sort_by="relevance",
            page=1,
            page_size=20,
        )
        return self.advanced_search(adv)

    def advanced_search(self, req: AdvancedSearchRequest) -> FacetedSearchResponse:
        """
        Execute an advanced hostel search and return faceted results.

        Implementation notes:
        - Uses VisitorHostelRepository.search for coarse filters (city/price/query).
        - Applies other filters (ratings, amenities, availability, etc.) in Python.
        - Computes simple facets (city, hostel_type, price, rating, amenities).
        """
        page = req.page
        page_size = req.page_size
        if page < 1:
            page = 1
        if page_size <= 0:
            page_size = 20

        start_time = datetime.utcnow()

        with UnitOfWork(self._session_factory) as uow:
            visitor_repo = self._get_visitor_hostel_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            min_price = float(req.min_price) if req.min_price is not None else None
            max_price = float(req.max_price) if req.max_price is not None else None

            # "Rough" superset; adjust multiplier if needed
            rough_limit = page * page_size * 2

            vh_list = visitor_repo.search(
                city=req.city,
                area=None,
                min_price=min_price,
                max_price=max_price,
                gender_type=None,
                search=req.query,
                limit=rough_limit,
            )

            # Map hostel_id -> core_hostel
            hostel_cache: Dict[UUID, object] = {}
            for vh in vh_list:
                if vh.hostel_id not in hostel_cache:
                    hostel_cache[vh.hostel_id] = hostel_repo.get(vh.hostel_id)

            def _match(vh, h) -> bool:
                # State / pincode
                if req.state and (not h or h.state != req.state):
                    return False
                if req.pincode and getattr(vh, "pincode", None) != req.pincode:
                    return False

                # Room type
                if req.room_type and vh.room_types:
                    if req.room_type.value not in vh.room_types:
                        return False

                # Availability (available_only)
                if req.available_only:
                    if vh.availability is None or vh.availability <= 0:
                        return False

                # Min rating
                if req.min_rating is not None:
                    rating_val = Decimal(str(vh.rating or (h.average_rating if h else 0.0)))
                    if rating_val < req.min_rating:
                        return False

                # Amenities
                if req.amenities:
                    amenities_set = set(vh.amenities or [])
                    for a in req.amenities:
                        if a not in amenities_set:
                            return False

                # Verified_only requires core_hostel
                if req.verified_only and (not h or not h.is_verified):
                    return False

                # Hostel type
                if req.hostel_type and h and h.hostel_type != req.hostel_type:
                    return False

                # Radius_km / lat/long not implemented here; can be added if you store coords
                return True

            matched: List[tuple] = []
            for vh in vh_list:
                h = hostel_cache.get(vh.hostel_id)
                if _match(vh, h):
                    matched.append((vh, h))

            total_results = len(matched)

            # Sorting
            def _sort_key(item):
                vh, h = item
                if req.sort_by == "price_asc":
                    val = vh.min_price or (h.starting_price_monthly if h else Decimal("0"))
                    return (val,)
                if req.sort_by == "price_desc":
                    val = vh.max_price or (h.starting_price_monthly if h else Decimal("0"))
                    return (-val,)
                if req.sort_by == "rating_desc":
                    val = Decimal(str(vh.rating or (h.average_rating if h else 0.0)))
                    return (-val,)
                if req.sort_by == "newest":
                    created = getattr(h, "created_at", None)
                    return (created or datetime.min,)
                if req.sort_by == "distance_asc":
                    # Distance not implemented; treat as stable sort
                    return (0,)
                # "relevance": rely on original order
                return (0,)

            if req.sort_by != "relevance":
                matched.sort(key=_sort_key)

            # Pagination
            start_idx = (page - 1) * page_size
            end_idx = start_idx + page_size
            page_items = matched[start_idx:end_idx]

            # Map to SearchResultItem
            results: List[SearchResultItem] = []
            for vh, h in page_items:
                card = self._to_public_card(vh, h)
                # Simple score heuristic: rating + availability fraction
                rating_val = Decimal(str(vh.rating or (h.average_rating if h else 0.0)))
                avail = vh.availability or 0
                score = rating_val + Decimal(str(min(avail, 1)))
                results.append(
                    SearchResultItem(
                        hostel=card,
                        score=score,
                    )
                )

            total_pages = ceil(total_results / page_size) if page_size > 0 else 1

            facets = self._build_facets(matched, hostel_cache)
            raw_query: Dict[str, object] = {
                "request": req.model_dump(),
            }

        elapsed_ms = int((datetime.utcnow() - start_time).total_seconds() * 1000)

        return FacetedSearchResponse(
            results=results,
            total_results=total_results,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
            facets=facets,
            query_time_ms=elapsed_ms,
            raw_query=raw_query,
        )

    # ------------------------------------------------------------------ #
    # Mapping
    # ------------------------------------------------------------------ #
    def _to_public_card(self, vh, h) -> PublicHostelCard:
        starting_price = vh.min_price or (h.starting_price_monthly if h else Decimal("0"))
        available_beds = vh.availability
        if available_beds is None and h:
            total_beds = h.total_beds or 0
            occupied_beds = h.occupied_beds or 0
            available_beds = max(0, total_beds - occupied_beds)

        avg_rating = Decimal(str(vh.rating or (h.average_rating if h else 0.0)))
        total_reviews = vh.total_reviews or (h.total_reviews if h else 0) or 0

        return PublicHostelCard(
            id=vh.hostel_id,
            name=vh.hostel_name,
            slug=h.slug if h else "",
            hostel_type=h.hostel_type if h else None,  # type: ignore[arg-type]
            city=vh.city,
            state=h.state if h else "",
            starting_price_monthly=starting_price,
            currency="INR",
            average_rating=avg_rating,
            total_reviews=total_reviews,
            available_beds=available_beds or 0,
            cover_image_url=h.cover_image_url if h else None,
            is_featured=h.is_featured if h else False,
            amenities=(vh.amenities or [])[:5],
            distance_km=None,
        )

    # ------------------------------------------------------------------ #
    # Facets
    # ------------------------------------------------------------------ #
    def _build_facets(
        self,
        matched: List[tuple],
        hostel_cache: Dict[UUID, object],
    ) -> Dict[str, List[FacetBucket]]:
        """
        Build basic facets:
        - city
        - hostel_type
        - amenity
        - rating_bucket
        - price_range (single range across all matched)
        """
        city_counts: Dict[str, int] = {}
        type_counts: Dict[str, int] = {}
        amenity_counts: Dict[str, int] = {}
        rating_counts: Dict[str, int] = {}
        min_price: Optional[Decimal] = None
        max_price: Optional[Decimal] = None

        for vh, h in matched:
            # City
            city_counts[vh.city] = city_counts.get(vh.city, 0) + 1

            # Hostel type
            if h:
                type_val = (
                    h.hostel_type.value
                    if hasattr(h.hostel_type, "value")
                    else str(h.hostel_type)
                )
                type_counts[type_val] = type_counts.get(type_val, 0) + 1

            # Amenities
            for a in vh.amenities or []:
                amenity_counts[a] = amenity_counts.get(a, 0) + 1

            # Rating bucket
            rating_val = Decimal(str(vh.rating or (h.average_rating if h else 0.0)))
            if rating_val >= Decimal("4.5"):
                bucket = "4.5+"
            elif rating_val >= Decimal("4.0"):
                bucket = "4.0-4.4"
            elif rating_val >= Decimal("3.0"):
                bucket = "3.0-3.9"
            else:
                bucket = "<3.0"
            rating_counts[bucket] = rating_counts.get(bucket, 0) + 1

            # Price
            p = vh.min_price or (h.starting_price_monthly if h else None)
            if p is not None:
                if min_price is None or p < min_price:
                    min_price = p
                if max_price is None or p > max_price:
                    max_price = p

        facets: Dict[str, List[FacetBucket]] = {}

        facets["city"] = [
            FacetBucket(value=city, count=count, label=city)
            for city, count in sorted(city_counts.items(), key=lambda x: -x[1])
        ]

        facets["hostel_type"] = [
            FacetBucket(value=t, count=count, label=t)
            for t, count in sorted(type_counts.items(), key=lambda x: -x[1])
        ]

        facets["amenity"] = [
            FacetBucket(value=a, count=count, label=a)
            for a, count in sorted(amenity_counts.items(), key=lambda x: -x[1])
        ]

        facets["rating"] = [
            FacetBucket(value=bucket, count=count, label=bucket)
            for bucket, count in sorted(rating_counts.items(), key=lambda x: -x[1])
        ]

        if min_price is not None and max_price is not None:
            label = f"₹{min_price:,.0f} - ₹{max_price:,.0f}"
            facets["price_range"] = [
                FacetBucket(
                    value=label,
                    count=len(matched),
                    label=label,
                )
            ]

        return facets

# --- File: D:\hostel-management-saas\app\services\search\__init__.py ---
# app/services/search/__init__.py
from .search_service import SearchService
from .autocomplete_service import AutocompleteService
from .search_analytics_service import SearchAnalyticsService, SearchEventStore
from .search_indexer_service import SearchIndexerService, SearchIndexBackend

__all__ = [
    "SearchService",
    "AutocompleteService",
    "SearchAnalyticsService",
    "SearchEventStore",
    "SearchIndexerService",
    "SearchIndexBackend",
]


# ===== Folder: D:\hostel-management-saas\app\services\student =====

# --- File: D:\hostel-management-saas\app\services\student\student_dashboard_service.py ---
# app/services/student/student_dashboard_service.py
from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import (
    StudentRepository,
    HostelRepository,
    RoomRepository,
    BedRepository,
)
from app.repositories.transactions import PaymentRepository
from app.repositories.services import ComplaintRepository, LeaveApplicationRepository
from app.repositories.content import AnnouncementRepository, MessMenuRepository
from app.schemas.common.enums import LeaveStatus
from app.schemas.common.filters import DateRangeFilter
from app.schemas.student.student_dashboard import (
    StudentDashboard,
    StudentStats,
    StudentFinancialSummary,
    RecentPayment,
    RecentComplaint,
    PendingLeave,
    RecentAnnouncement,
    TodayMessMenu,
)
from app.services.analytics import AttendanceAnalyticsService
from app.services.common import UnitOfWork, errors


class StudentDashboardService:
    """
    Aggregated student dashboard:

    - Basic hostel/room/bed info
    - Financial summary (payments)
    - Attendance summary via AttendanceAnalyticsService
    - Recent payments/complaints/leaves/announcements
    - Today's mess menu
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory
        self._attendance_analytics = AttendanceAnalyticsService(session_factory)

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _get_complaint_repo(self, uow: UnitOfWork) -> ComplaintRepository:
        return uow.get_repo(ComplaintRepository)

    def _get_leave_repo(self, uow: UnitOfWork) -> LeaveApplicationRepository:
        return uow.get_repo(LeaveApplicationRepository)

    def _get_announcement_repo(self, uow: UnitOfWork) -> AnnouncementRepository:
        return uow.get_repo(AnnouncementRepository)

    def _get_menu_repo(self, uow: UnitOfWork) -> MessMenuRepository:
        return uow.get_repo(MessMenuRepository)

    def _today(self) -> date:
        return date.today()

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_dashboard(self, student_id: UUID) -> StudentDashboard:
        today = self._today()

        with UnitOfWork(self._session_factory) as uow:
            student_repo = self._get_student_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)
            payment_repo = self._get_payment_repo(uow)
            complaint_repo = self._get_complaint_repo(uow)
            leave_repo = self._get_leave_repo(uow)
            announcement_repo = self._get_announcement_repo(uow)
            menu_repo = self._get_menu_repo(uow)

            s = student_repo.get(student_id)
            if s is None or not getattr(s, "user", None):
                raise errors.NotFoundError(f"Student {student_id} not found")

            user = s.user
            hostel = hostel_repo.get(s.hostel_id)
            hostel_name = hostel.name if hostel else ""

            room_number = bed_number = ""
            if s.room_id:
                room = room_repo.get(s.room_id)
                room_number = room.room_number if room else ""
            if s.bed_id:
                bed = bed_repo.get(s.bed_id)
                bed_number = bed.bed_number if bed else ""

            # Financial summary
            payments = payment_repo.list_for_student(s.id)
            (
                fin_summary,
                recent_payments,
            ) = self._build_financial_summary_and_recent(payments, s)

            # Attendance summary via analytics service
            period = DateRangeFilter(
                start_date=today.replace(day=1),
                end_date=today,
            )
            attendance_report = self._attendance_analytics.get_student_report(
                student_id, period
            )
            att_summary = attendance_report.summary

            # Recent complaints
            complaints = complaint_repo.list_for_student(s.id)[:5]
            recent_complaints: List[RecentComplaint] = []
            for c in complaints:
                recent_complaints.append(
                    RecentComplaint(
                        complaint_id=c.id,
                        title=c.title,
                        category=c.category.value if hasattr(c.category, "value") else str(c.category),
                        status=c.status.value if hasattr(c.status, "value") else str(c.status),
                        priority=c.priority.value if hasattr(c.priority, "value") else str(c.priority),
                        created_at=c.created_at,
                        updated_at=c.updated_at,
                    )
                )

            # Pending leaves
            leaves_all = leave_repo.list_for_student(s.id)
            pending_leaves = [
                l for l in leaves_all if l.status == LeaveStatus.PENDING
            ]
            pending_leave_items: List[PendingLeave] = []
            for l in pending_leaves:
                pending_leave_items.append(
                    PendingLeave(
                        leave_id=l.id,
                        leave_type=l.leave_type.value if hasattr(l.leave_type, "value") else str(l.leave_type),
                        from_date=l.from_date,
                        to_date=l.to_date,
                        total_days=l.total_days,
                        status=l.status.value if hasattr(l.status, "value") else str(l.status),
                        applied_at=l.created_at,
                    )
                )

            # Announcements (recent, hostel-level)
            ann_list = announcement_repo.list_published_for_hostel(
                hostel_id=s.hostel_id,
                now=self._now(),
                audience=None,
            )[:5]
            recent_anns: List[RecentAnnouncement] = []
            for a in ann_list:
                recent_anns.append(
                    RecentAnnouncement(
                        announcement_id=a.id,
                        title=a.title,
                        category=a.category.value if hasattr(a.category, "value") else str(a.category),
                        priority=a.priority.value if hasattr(a.priority, "value") else str(a.priority),
                        published_at=a.published_at or a.created_at,
                        is_read=False,
                    )
                )

            # Today's mess menu
            today_menu = None
            menus_today = menu_repo.get_for_date(s.hostel_id, today)
            if menus_today:
                m = menus_today[0]
                today_menu = TodayMessMenu(
                    date=m.menu_date,
                    breakfast=m.breakfast_items or [],
                    lunch=m.lunch_items or [],
                    snacks=m.snacks_items or [],
                    dinner=m.dinner_items or [],
                    is_special=m.is_special_menu,
                )

            # Student stats (simple)
            stats = StudentStats(
                days_in_hostel=(
                    (today - s.check_in_date).days
                    if s.check_in_date
                    else 0
                ),
                total_payments_made=len(
                    [p for p in payments if p.paid_at]
                ),
                total_amount_paid=sum(
                    (p.amount for p in payments if p.paid_at), Decimal("0")
                ),
                complaints_raised=len(complaints),
                complaints_resolved=len(
                    [c for c in complaints if str(c.status).lower().endswith("closed") or str(c.status).lower() == "resolved"]  # type: ignore[str-bytes-safe]
                ),
                current_attendance_percentage=att_summary.attendance_percentage,
            )

        attendance_summary = attendance_report.summary

        return StudentDashboard(
            student_id=s.id,
            student_name=user.full_name,
            hostel_name=hostel_name,
            room_number=room_number,
            bed_number=bed_number,
            financial_summary=fin_summary,
            attendance_summary=attendance_summary,
            recent_payments=recent_payments,
            recent_complaints=recent_complaints,
            pending_leave_applications=pending_leave_items,
            recent_announcements=recent_anns,
            today_mess_menu=today_menu,
            stats=stats,
        )

    # ------------------------------------------------------------------ #
    # Helpers (financial)
    # ------------------------------------------------------------------ #
    def _build_financial_summary_and_recent(
        self,
        payments,
        student,
    ) -> tuple[StudentFinancialSummary, List[RecentPayment]]:
        today = self._today()

        amount_due = Decimal("0")
        amount_overdue = Decimal("0")
        next_due_date: Optional[date] = None

        for p in payments:
            if p.payment_status.name == "PENDING":  # PaymentStatus.PENDING
                amount_due += p.amount
                if p.due_date and p.due_date < today:
                    amount_overdue += p.amount
                if p.due_date:
                    if not next_due_date or p.due_date < next_due_date:
                        next_due_date = p.due_date

        days_until_due = (
            (next_due_date - today).days if next_due_date else None
        )

        payment_status_str = "current"
        if amount_overdue > 0:
            payment_status_str = "overdue"
        elif amount_due > 0:
            payment_status_str = "due_soon"

        # Mess details are placeholders; not modeled in payments yet.
        fin_summary = StudentFinancialSummary(
            monthly_rent=student.monthly_rent_amount or Decimal("0"),
            next_due_date=next_due_date or today,
            amount_due=amount_due,
            amount_overdue=amount_overdue,
            advance_balance=Decimal("0"),
            security_deposit=student.security_deposit_amount or Decimal("0"),
            mess_charges=Decimal("0"),
            mess_balance=Decimal("0"),
            payment_status=payment_status_str,
            days_until_due=days_until_due,
        )

        # Recent payments
        recent_payments: List[RecentPayment] = []
        for p in sorted(payments, key=lambda x: x.paid_at or x.created_at, reverse=True)[:5]:
            recent_payments.append(
                RecentPayment(
                    payment_id=p.id,
                    amount=p.amount,
                    payment_type=p.payment_type.value if hasattr(p.payment_type, "value") else str(p.payment_type),
                    payment_date=(p.paid_at or p.created_at).date(),
                    status=p.payment_status.value if hasattr(p.payment_status, "value") else str(p.payment_status),
                    receipt_url=p.receipt_url,
                )
            )

        return fin_summary, recent_payments

# --- File: D:\hostel-management-saas\app\services\student\student_finance_service.py ---
# app/services/student/student_finance_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import PaymentRepository
from app.repositories.core import StudentRepository
from app.schemas.common.enums import PaymentStatus
from app.schemas.student.student_dashboard import StudentFinancialSummary
from app.schemas.student.student_response import StudentFinancialInfo
from app.services.common import UnitOfWork, errors


class StudentFinanceService:
    """
    Student-level financial data:

    - StudentFinancialSummary (for dashboard)
    - StudentFinancialInfo (detailed, for admin views)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _today(self) -> date:
        return date.today()

    # ------------------------------------------------------------------ #
    # Summary for dashboard
    # ------------------------------------------------------------------ #
    def get_financial_summary(self, student_id: UUID) -> StudentFinancialSummary:
        today = self._today()

        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            student_repo = self._get_student_repo(uow)

            s = student_repo.get(student_id)
            if s is None:
                raise errors.NotFoundError(f"Student {student_id} not found")

            payments = pay_repo.list_for_student(student_id)

        amount_due = Decimal("0")
        amount_overdue = Decimal("0")
        next_due_date: Optional[date] = None

        for p in payments:
            if p.payment_status == PaymentStatus.PENDING:
                amount_due += p.amount
                if p.due_date and p.due_date < today:
                    amount_overdue += p.amount
                if p.due_date:
                    if not next_due_date or p.due_date < next_due_date:
                        next_due_date = p.due_date

        days_until_due = (
            (next_due_date - today).days if next_due_date else None
        )

        status_str = "current"
        if amount_overdue > 0:
            status_str = "overdue"
        elif amount_due > 0:
            status_str = "due_soon"

        return StudentFinancialSummary(
            monthly_rent=s.monthly_rent_amount or Decimal("0"),
            next_due_date=next_due_date or today,
            amount_due=amount_due,
            amount_overdue=amount_overdue,
            advance_balance=Decimal("0"),
            security_deposit=s.security_deposit_amount or Decimal("0"),
            mess_charges=Decimal("0"),
            mess_balance=Decimal("0"),
            payment_status=status_str,
            days_until_due=days_until_due,
        )

    # ------------------------------------------------------------------ #
    # Detailed info
    # ------------------------------------------------------------------ #
    def get_financial_info(self, student_id: UUID) -> StudentFinancialInfo:
        today = self._today()

        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            student_repo = self._get_student_repo(uow)

            s = student_repo.get(student_id)
            if s is None or not getattr(s, "user", None):
                raise errors.NotFoundError(f"Student {student_id} not found")

            payments = pay_repo.list_for_student(student_id)

        total_paid = Decimal("0")
        total_due = Decimal("0")
        overdue_amount = Decimal("0")
        advance_amount = Decimal("0")
        last_payment_date: Optional[date] = None
        next_due_date: Optional[date] = None

        for p in payments:
            if p.payment_status == PaymentStatus.COMPLETED and p.paid_at:
                total_paid += p.amount
                d = p.paid_at.date()
                if not last_payment_date or d > last_payment_date:
                    last_payment_date = d
            elif p.payment_status == PaymentStatus.PENDING:
                total_due += p.amount
                if p.due_date and p.due_date < today:
                    overdue_amount += p.amount
                if p.due_date:
                    if not next_due_date or p.due_date < next_due_date:
                        next_due_date = p.due_date

        return StudentFinancialInfo(
            student_id=student_id,
            student_name=s.user.full_name,
            monthly_rent_amount=s.monthly_rent_amount or Decimal("0"),
            security_deposit_amount=s.security_deposit_amount or Decimal("0"),
            security_deposit_paid=False,
            security_deposit_refundable=s.security_deposit_amount or Decimal("0"),
            total_paid=total_paid,
            total_due=total_due,
            last_payment_date=last_payment_date,
            next_due_date=next_due_date,
            overdue_amount=overdue_amount,
            advance_amount=advance_amount,
            mess_charges_monthly=Decimal("0"),
            mess_balance=Decimal("0"),
        )

# --- File: D:\hostel-management-saas\app\services\student\student_profile_service.py ---
# app/services/student/student_profile_service.py
from __future__ import annotations

from datetime import datetime
from typing import Callable, List, Optional, Protocol
from uuid import UUID, uuid4

from sqlalchemy.orm import Session

from app.repositories.core import StudentRepository, UserRepository
from app.schemas.student.student_profile import (
    StudentProfileCreate,
    StudentProfileUpdate,
    StudentDocuments,
    DocumentInfo,
    DocumentUploadRequest,
    DocumentVerificationRequest,
    StudentPreferences,
)
from app.schemas.student.student_response import StudentDetail
from app.services.common import UnitOfWork, errors
from .student_service import StudentService


class StudentDocumentStore(Protocol):
    """
    Storage abstraction for student documents.

    Expected record fields (example):
        {
            "id": UUID,
            "student_id": UUID,
            "document_type": str,
            "document_name": str,
            "document_url": str,
            "uploaded_at": datetime,
            "verified": bool,
            "verified_by": UUID | None,
            "verified_at": datetime | None,
            "notes": str | None,
        }
    """

    def list_documents(self, student_id: UUID) -> List[dict]: ...
    def save_document(self, record: dict) -> dict: ...
    def get_document(self, document_id: UUID) -> Optional[dict]: ...
    def update_document(self, document_id: UUID, data: dict) -> dict: ...


class StudentProfileService:
    """
    Student profile & documents:

    - Get/update student "profile" fields (guardian, institution, employment, preferences).
    - Manage uploaded documents via a DocumentStore.
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        document_store: StudentDocumentStore,
    ) -> None:
        self._session_factory = session_factory
        self._documents = document_store
        self._student_service = StudentService(session_factory)

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Profile (uses Student + User)
    # ------------------------------------------------------------------ #
    def update_profile(
        self,
        student_id: UUID,
        data: StudentProfileUpdate,
    ) -> StudentDetail:
        """
        Merge StudentProfileUpdate fields into Student.
        """
        with UnitOfWork(self._session_factory) as uow:
            student_repo = self._get_student_repo(uow)

            s = student_repo.get(student_id)
            if s is None:
                raise errors.NotFoundError(f"Student {student_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(s, field) and field != "id":
                    setattr(s, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return self._student_service.get_student(student_id)

    # ------------------------------------------------------------------ #
    # Documents
    # ------------------------------------------------------------------ #
    def list_documents(self, student_id: UUID) -> StudentDocuments:
        records = self._documents.list_documents(student_id)
        docs = [DocumentInfo.model_validate(r) for r in records]
        return StudentDocuments(student_id=student_id, documents=docs)

    def upload_document(self, data: DocumentUploadRequest) -> DocumentInfo:
        now = self._now()
        record = {
            "id": uuid4(),
            "student_id": data.student_id,
            "document_type": data.document_type,
            "document_name": data.document_name,
            "document_url": str(data.document_url),
            "uploaded_at": now,
            "verified": False,
            "verified_by": None,
            "verified_at": None,
            "notes": None,
        }
        saved = self._documents.save_document(record)
        return DocumentInfo.model_validate(saved)

    def verify_document(self, data: DocumentVerificationRequest, *, verifier_id: UUID) -> DocumentInfo:
        record = self._documents.get_document(data.document_id)
        if not record:
            raise errors.NotFoundError(f"Document {data.document_id} not found")

        record["verified"] = data.verified
        record["verified_by"] = verifier_id
        record["verified_at"] = self._now()
        record["notes"] = data.notes

        updated = self._documents.update_document(data.document_id, record)
        return DocumentInfo.model_validate(updated)

    # ------------------------------------------------------------------ #
    # Preferences
    # ------------------------------------------------------------------ #
    def update_preferences(self, student_id: UUID, prefs: StudentPreferences) -> StudentDetail:
        """
        Update student-level preferences that live on Student.
        """
        with UnitOfWork(self._session_factory) as uow:
            student_repo = self._get_student_repo(uow)

            s = student_repo.get(student_id)
            if s is None:
                raise errors.NotFoundError(f"Student {student_id} not found")

            mapping = prefs.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(s, field) and field != "id":
                    setattr(s, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return self._student_service.get_student(student_id)

# --- File: D:\hostel-management-saas\app\services\student\student_room_history_service.py ---
# app/services/student/student_room_history_service.py
from __future__ import annotations

from datetime import date
from typing import Callable, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.associations import StudentRoomAssignmentRepository
from app.repositories.core import HostelRepository, RoomRepository, StudentRepository
from app.schemas.student.student_room_history import (
    RoomHistoryResponse,
    RoomHistoryItem,
)
from app.services.common import UnitOfWork, errors


class StudentRoomHistoryService:
    """
    Student room/bed history:

    - Build RoomHistoryResponse from StudentRoomAssignment records.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_assignment_repo(self, uow: UnitOfWork) -> StudentRoomAssignmentRepository:
        return uow.get_repo(StudentRoomAssignmentRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    # ------------------------------------------------------------------ #
    # API
    # ------------------------------------------------------------------ #
    def get_room_history(self, student_id: UUID) -> RoomHistoryResponse:
        with UnitOfWork(self._session_factory) as uow:
            assignment_repo = self._get_assignment_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            room_repo = self._get_room_repo(uow)
            student_repo = self._get_student_repo(uow)

            student = student_repo.get(student_id)
            if student is None or not getattr(student, "user", None):
                raise errors.NotFoundError(f"Student {student_id} not found")

            assignments = assignment_repo.get_history_for_student(student_id)
            if not assignments:
                # Build empty response
                return RoomHistoryResponse(
                    student_id=student_id,
                    student_name=student.user.full_name,
                    hostel_id=student.hostel_id,
                    hostel_name=hostel_repo.get(student.hostel_id).name if hostel_repo.get(student.hostel_id) else "",
                    room_history=[],
                )

            hostel = hostel_repo.get(assignments[0].hostel_id)
            hostel_name = hostel.name if hostel else ""

            items: List[RoomHistoryItem] = []
            for a in assignments:
                room = room_repo.get(a.room_id)
                room_number = room.room_number if room else ""
                room_type = (
                    room.room_type.value if room and hasattr(room.room_type, "value") else ""
                )

                dur = None
                if a.move_out_date:
                    dur = (a.move_out_date - a.move_in_date).days

                items.append(
                    RoomHistoryItem(
                        id=a.id,
                        created_at=a.created_at,
                        updated_at=a.updated_at,
                        hostel_id=a.hostel_id,
                        hostel_name=hostel_name,
                        room_id=a.room_id,
                        room_number=room_number,
                        room_type=room_type,
                        bed_id=a.bed_id,
                        bed_number=None,
                        move_in_date=a.move_in_date,
                        move_out_date=a.move_out_date,
                        duration_days=dur,
                        rent_amount=a.rent_amount,
                        reason=a.reason,
                        requested_by=None,
                        approved_by=None,
                    )
                )

        return RoomHistoryResponse(
            student_id=student_id,
            student_name=student.user.full_name,
            hostel_id=student.hostel_id,
            hostel_name=hostel_name,
            room_history=items,
        )

# --- File: D:\hostel-management-saas\app\services\student\student_search_service.py ---
# app/services/student/student_search_service.py
from __future__ import annotations

from typing import Callable, Dict, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import (
    StudentRepository,
    UserRepository,
    RoomRepository,
    BedRepository,
)
from app.schemas.common.pagination import PaginatedResponse
from app.schemas.student.student_filters import (
    StudentSearchRequest,
    StudentSortOptions,
)
from app.schemas.student.student_response import StudentListItem
from app.services.common import UnitOfWork


class StudentSearchService:
    """
    Advanced student search service:

    - Full-text-ish search over name/email/phone/room/institution.
    - Pagination & simple sorting options.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    # ------------------------------------------------------------------ #
    # Search
    # ------------------------------------------------------------------ #
    def search(self, req: StudentSearchRequest) -> PaginatedResponse[StudentListItem]:
        with UnitOfWork(self._session_factory) as uow:
            student_repo = self._get_student_repo(uow)
            user_repo = self._get_user_repo(uow)
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)

            filters: Dict[str, object] = {}
            if req.hostel_id:
                filters["hostel_id"] = req.hostel_id
            if req.status:
                filters["student_status"] = req.status

            students = student_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

            q = req.query.lower()

            user_cache: Dict[UUID, object] = {}
            room_cache: Dict[UUID, object] = {}
            bed_cache: Dict[UUID, object] = {}

            def _matches(s) -> bool:
                # load user
                if s.user_id not in user_cache:
                    user_cache[s.user_id] = user_repo.get(s.user_id)
                user = user_cache[s.user_id]
                if user is None:
                    return False

                haystack_parts: List[str] = []
                if req.search_in_name:
                    haystack_parts.append(getattr(user, "full_name", ""))
                if req.search_in_email:
                    haystack_parts.append(getattr(user, "email", ""))
                if req.search_in_phone:
                    haystack_parts.append(getattr(user, "phone", ""))

                if req.search_in_room:
                    if s.room_id:
                        if s.room_id not in room_cache:
                            room_cache[s.room_id] = room_repo.get(s.room_id)
                        room = room_cache[s.room_id]
                        if room:
                            haystack_parts.append(room.room_number or "")
                    if s.bed_id:
                        if s.bed_id not in bed_cache:
                            bed_cache[s.bed_id] = bed_repo.get(s.bed_id)
                        bed = bed_cache[s.bed_id]
                        if bed:
                            haystack_parts.append(bed.bed_number or "")

                if req.search_in_institution:
                    haystack_parts.append(s.institution_name or "")

                haystack = " ".join(haystack_parts).lower()
                return q in haystack

            matched = [s for s in students if _matches(s)]

            # Sorting (simple: by created_at desc)
            matched_sorted = sorted(matched, key=lambda s: s.created_at, reverse=True)

            # Pagination
            page = req.page
            page_size = req.page_size
            offset = (page - 1) * page_size
            page_records = matched_sorted[offset : offset + page_size]

            items: List[StudentListItem] = []
            for s in page_records:
                user = user_cache[s.user_id]
                room_number = bed_number = None
                if s.room_id:
                    room = room_cache.get(s.room_id)
                    if room:
                        room_number = room.room_number
                if s.bed_id:
                    bed = bed_cache.get(s.bed_id)
                    if bed:
                        bed_number = bed.bed_number

                items.append(
                    StudentListItem(
                        id=s.id,
                        user_id=s.user_id,
                        full_name=user.full_name,
                        email=user.email,
                        phone=getattr(user, "phone", ""),
                        room_number=room_number,
                        bed_number=bed_number,
                        student_status=s.student_status,
                        check_in_date=s.check_in_date,
                        monthly_rent=s.monthly_rent_amount,
                        payment_status="current",
                        created_at=s.created_at,
                    )
                )

            return PaginatedResponse[StudentListItem].create(
                items=items,
                total_items=len(matched),
                page=page,
                page_size=page_size,
            )

# --- File: D:\hostel-management-saas\app\services\student\student_service.py ---
# app/services/student/student_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import (
    StudentRepository,
    UserRepository,
    HostelRepository,
    RoomRepository,
    BedRepository,
)
from app.schemas.common.enums import StudentStatus
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.student import (
    StudentCreate,
    StudentUpdate,
    StudentResponse,
    StudentDetail,
    StudentListItem,
    StudentFilterParams,
    StudentSortOptions,
)
from app.services.common import UnitOfWork, errors


class StudentService:
    """
    Core student service:

    - Create/update students
    - Get student detail
    - List students with filters + sorting
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _room_bed_labels(self, student, room_repo: RoomRepository, bed_repo: BedRepository) -> tuple[Optional[str], Optional[str]]:
        room_number = bed_number = None
        if student.room_id:
            room = room_repo.get(student.room_id)
            room_number = room.room_number if room else None
        if student.bed_id:
            bed = bed_repo.get(student.bed_id)
            bed_number = bed.bed_number if bed else None
        return room_number, bed_number

    def _to_response(
        self,
        s,
        *,
        hostel_name: str,
        room_number: Optional[str],
        bed_number: Optional[str],
        user,
    ) -> StudentResponse:
        # Payment & deposit derived fields are placeholders here
        security_deposit_paid = False

        return StudentResponse(
            id=s.id,
            created_at=s.created_at,
            updated_at=s.updated_at,
            user_id=s.user_id,
            hostel_id=s.hostel_id,
            hostel_name=hostel_name,
            room_id=s.room_id,
            room_number=room_number,
            bed_id=s.bed_id,
            bed_number=bed_number,
            full_name=user.full_name,
            email=user.email,
            phone=getattr(user, "phone", ""),
            guardian_name=s.guardian_name,
            guardian_phone=s.guardian_phone,
            student_status=s.student_status,
            check_in_date=s.check_in_date,
            expected_checkout_date=s.expected_checkout_date,
            monthly_rent_amount=s.monthly_rent_amount,
            security_deposit_amount=s.security_deposit_amount,
            security_deposit_paid=security_deposit_paid,
            mess_subscribed=s.mess_subscribed,
        )

    def _to_detail(
        self,
        s,
        *,
        user,
        hostel_name: str,
        room_number: Optional[str],
        room_type: Optional[str],
        bed_number: Optional[str],
    ) -> StudentDetail:
        return StudentDetail(
            id=s.id,
            created_at=s.created_at,
            updated_at=s.updated_at,
            user_id=user.id,
            full_name=user.full_name,
            email=user.email,
            phone=getattr(user, "phone", ""),
            gender=getattr(user, "gender", None).value if getattr(user, "gender", None) else None,
            date_of_birth=getattr(user, "date_of_birth", None),
            profile_image_url=getattr(user, "profile_image_url", None),
            hostel_id=s.hostel_id,
            hostel_name=hostel_name,
            room_id=s.room_id,
            room_number=room_number,
            room_type=room_type,
            bed_id=s.bed_id,
            bed_number=bed_number,
            id_proof_type=s.id_proof_type,
            id_proof_number=s.id_proof_number,
            id_proof_document_url=None,
            guardian_name=s.guardian_name,
            guardian_phone=s.guardian_phone,
            guardian_email=s.guardian_email,
            guardian_relation=s.guardian_relation,
            guardian_address=s.guardian_address,
            institution_name=s.institution_name,
            course=s.course,
            year_of_study=s.year_of_study,
            student_id_number=None,
            company_name=s.company_name,
            designation=s.designation,
            company_id_url=None,
            check_in_date=s.check_in_date,
            expected_checkout_date=s.expected_checkout_date,
            actual_checkout_date=s.actual_checkout_date,
            security_deposit_amount=s.security_deposit_amount,
            security_deposit_paid=False,
            security_deposit_paid_date=None,
            monthly_rent_amount=s.monthly_rent_amount,
            mess_subscribed=s.mess_subscribed,
            dietary_preference=s.dietary_preference,
            food_allergies=s.food_allergies,
            student_status=s.student_status,
            notice_period_start=None,
            notice_period_end=None,
            booking_id=None,
            additional_documents=[],
        )

    def _to_list_item(
        self,
        s,
        *,
        user,
        room_number: Optional[str],
        bed_number: Optional[str],
        payment_status: str,
    ) -> StudentListItem:
        return StudentListItem(
            id=s.id,
            user_id=user.id,
            full_name=user.full_name,
            email=user.email,
            phone=getattr(user, "phone", ""),
            room_number=room_number,
            bed_number=bed_number,
            student_status=s.student_status,
            check_in_date=s.check_in_date,
            monthly_rent=s.monthly_rent_amount,
            payment_status=payment_status,
            created_at=s.created_at,
        )

    # ------------------------------------------------------------------ #
    # CRUD
    # ------------------------------------------------------------------ #
    def create_student(self, data: StudentCreate) -> StudentDetail:
        with UnitOfWork(self._session_factory) as uow:
            student_repo = self._get_student_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            room_repo = self._get_room_repo(uow)

            user = user_repo.get(data.user_id)
            if user is None:
                raise errors.NotFoundError(f"User {data.user_id} not found")

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            if data.room_id:
                room = room_repo.get(data.room_id)
                if room is None:
                    raise errors.NotFoundError(f"Room {data.room_id} not found")

            payload = data.model_dump(exclude_unset=True)
            student = student_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            room_number, bed_number = self._room_bed_labels(student, room_repo, self._get_bed_repo(uow))
            room_type = None
            if student.room_id:
                room = room_repo.get(student.room_id)
                room_type = room.room_type.value if room and hasattr(room.room_type, "value") else None

            return self._to_detail(
                student,
                user=user,
                hostel_name=hostel.name,
                room_number=room_number,
                room_type=room_type,
                bed_number=bed_number,
            )

    def update_student(self, student_id: UUID, data: StudentUpdate) -> StudentDetail:
        with UnitOfWork(self._session_factory) as uow:
            student_repo = self._get_student_repo(uow)

            s = student_repo.get(student_id)
            if s is None:
                raise errors.NotFoundError(f"Student {student_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(s, field) and field != "id":
                    setattr(s, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return self.get_student(student_id)

    def get_student(self, student_id: UUID) -> StudentDetail:
        with UnitOfWork(self._session_factory) as uow:
            student_repo = self._get_student_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            room_repo = self._get_room_repo(uow)

            s = student_repo.get(student_id)
            if s is None:
                raise errors.NotFoundError(f"Student {student_id} not found")

            user = user_repo.get(s.user_id)
            if user is None:
                raise errors.NotFoundError(f"User {s.user_id} not found")

            hostel = hostel_repo.get(s.hostel_id)
            hostel_name = hostel.name if hostel else ""

            room_number, bed_number = self._room_bed_labels(s, room_repo, self._get_bed_repo(uow))
            room_type = None
            if s.room_id:
                room = room_repo.get(s.room_id)
                room_type = room.room_type.value if room and hasattr(room.room_type, "value") else None

            return self._to_detail(
                s,
                user=user,
                hostel_name=hostel_name,
                room_number=room_number,
                room_type=room_type,
                bed_number=bed_number,
            )

    # ------------------------------------------------------------------ #
    # Listing with filters/sort
    # ------------------------------------------------------------------ #
    def list_students(
        self,
        params: PaginationParams,
        filters: Optional[StudentFilterParams] = None,
        sort: Optional[StudentSortOptions] = None,
    ) -> PaginatedResponse[StudentListItem]:
        with UnitOfWork(self._session_factory) as uow:
            student_repo = self._get_student_repo(uow)
            user_repo = self._get_user_repo(uow)
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)

            raw_filters: Dict[str, object] = {}
            if filters:
                if filters.hostel_id:
                    raw_filters["hostel_id"] = filters.hostel_id
                elif filters.hostel_ids:
                    raw_filters["hostel_id"] = filters.hostel_ids
                if filters.status:
                    raw_filters["student_status"] = filters.status
                elif filters.statuses:
                    raw_filters["student_status"] = filters.statuses

            records: Sequence = student_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=raw_filters or None,
            )

            # Advanced filter logic
            def _matches(s) -> bool:
                if not filters:
                    return True

                if filters.checked_in_after and (not s.check_in_date or s.check_in_date < filters.checked_in_after):
                    return False
                if filters.checked_in_before and (not s.check_in_date or s.check_in_date > filters.checked_in_before):
                    return False

                if filters.expected_checkout_after and (
                    not s.expected_checkout_date or s.expected_checkout_date < filters.expected_checkout_after
                ):
                    return False
                if filters.expected_checkout_before and (
                    not s.expected_checkout_date or s.expected_checkout_date > filters.expected_checkout_before
                ):
                    return False

                if filters.mess_subscribed is not None and s.mess_subscribed != filters.mess_subscribed:
                    return False

                if filters.institution_name and (s.institution_name or "").lower() != filters.institution_name.lower():
                    return False
                if filters.course and (s.course or "").lower() != filters.course.lower():
                    return False
                if filters.company_name and (s.company_name or "").lower() != filters.company_name.lower():
                    return False

                return True

            filtered = [s for s in records if _matches(s)]

            # Sorting
            sort = sort or StudentSortOptions()
            def _sort_key(s):
                if sort.sort_by == "name":
                    return getattr(s, "full_name", "").lower()
                if sort.sort_by == "check_in_date":
                    return s.check_in_date or datetime.min.date()
                if sort.sort_by == "monthly_rent":
                    return s.monthly_rent_amount or Decimal("0")
                # Fallback: created_at
                return s.created_at

            reverse = sort.sort_order == "desc"
            filtered_sorted = sorted(filtered, key=_sort_key, reverse=reverse)

            # Pagination
            start = params.offset
            end = start + params.limit
            page_records = filtered_sorted[start:end]

            # Map to list items
            user_cache: Dict[UUID, object] = {}
            room_cache: Dict[UUID, object] = {}
            bed_cache: Dict[UUID, object] = {}

            items: List[StudentListItem] = []
            for s in page_records:
                # user
                if s.user_id not in user_cache:
                    user_cache[s.user_id] = user_repo.get(s.user_id)
                user = user_cache[s.user_id]
                if user is None:
                    continue

                # room/bed
                room_number = bed_number = None
                if s.room_id:
                    if s.room_id not in room_cache:
                        room_cache[s.room_id] = room_repo.get(s.room_id)
                    room = room_cache[s.room_id]
                    room_number = room.room_number if room else None
                if s.bed_id:
                    if s.bed_id not in bed_cache:
                        bed_cache[s.bed_id] = bed_repo.get(s.bed_id)
                    bed = bed_cache[s.bed_id]
                    bed_number = bed.bed_number if bed else None

                # payment_status placeholder
                payment_status = "current"
                items.append(
                    self._to_list_item(
                        s,
                        user=user,
                        room_number=room_number,
                        bed_number=bed_number,
                        payment_status=payment_status,
                    )
                )

            return PaginatedResponse[StudentListItem].create(
                items=items,
                total_items=len(filtered_sorted),
                page=params.page,
                page_size=params.page_size,
            )

# --- File: D:\hostel-management-saas\app\services\student\__init__.py ---
# app/services/student/__init__.py
"""
Student-related services.

- StudentService:
    Core CRUD, listing, and detail for students.

- StudentProfileService:
    Profile & document management on top of Student/User.

- StudentDashboardService:
    Student dashboard aggregation (financial, attendance, activity).

- StudentSearchService:
    Advanced search & sorting over students.

- StudentRoomHistoryService:
    Room/bed history and transfer-oriented views.

- StudentFinanceService:
    Student-level financial summaries & details.
"""

from .student_service import StudentService
from .student_profile_service import StudentProfileService, StudentDocumentStore
from .student_dashboard_service import StudentDashboardService
from .student_search_service import StudentSearchService
from .student_room_history_service import StudentRoomHistoryService
from .student_finance_service import StudentFinanceService

__all__ = [
    "StudentService",
    "StudentProfileService",
    "StudentDocumentStore",
    "StudentDashboardService",
    "StudentSearchService",
    "StudentRoomHistoryService",
    "StudentFinanceService",
]


# ===== Folder: D:\hostel-management-saas\app\services\subscription =====

# --- File: D:\hostel-management-saas\app\services\subscription\commission_service.py ---
# app/services/subscription/commission_service.py
from __future__ import annotations

from datetime import date, timedelta
from decimal import Decimal
from typing import Dict, List, Optional, Protocol
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import (
    BookingRepository,
    SubscriptionRepository,
    SubscriptionPlanRepository,
)
from app.schemas.subscription.commission import (
    CommissionConfig,
    BookingCommissionResponse,
    CommissionSummary,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork, errors


class CommissionConfigStore(Protocol):
    """
    Storage abstraction for CommissionConfig.
    """

    def get_config(self) -> Optional[dict]: ...
    def save_config(self, data: dict) -> None: ...


class CommissionStore(Protocol):
    """
    Storage abstraction for booking commission records.

    Expected record shape:

        {
            "id": UUID,
            "booking_id": UUID,
            "hostel_id": UUID,
            "subscription_id": UUID,
            "booking_amount": Decimal,
            "commission_percentage": Decimal,
            "commission_amount": Decimal,
            "currency": str,
            "status": str,       # pending|calculated|paid|waived
            "due_date": date | None,
            "paid_date": date | None,
            "payment_reference": str | None,
            "created_at": datetime,
        }
    """

    def save_commission(self, record: dict) -> dict: ...
    def get_by_booking(self, booking_id: UUID) -> Optional[dict]: ...
    def list_commissions(
        self,
        *,
        hostel_id: Optional[UUID],
        start_date: date,
        end_date: date,
    ) -> List[dict]: ...


class CommissionService:
    """
    Booking commission management:

    - Global/platform commission config
    - Calculate commission for a booking based on subscription plan
    - Commission summary per platform/hostel & period
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        config_store: CommissionConfigStore,
        commission_store: CommissionStore,
    ) -> None:
        self._session_factory = session_factory
        self._config_store = config_store
        self._commission_store = commission_store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_booking_repo(self, uow: UnitOfWork) -> BookingRepository:
        return uow.get_repo(BookingRepository)

    def _get_sub_repo(self, uow: UnitOfWork) -> SubscriptionRepository:
        return uow.get_repo(SubscriptionRepository)

    def _get_plan_repo(self, uow: UnitOfWork) -> SubscriptionPlanRepository:
        return uow.get_repo(SubscriptionPlanRepository)

    def _default_config(self) -> CommissionConfig:
        cfg = CommissionConfig()
        self._config_store.save_config(cfg.model_dump())
        return cfg

    # ------------------------------------------------------------------ #
    # Config
    # ------------------------------------------------------------------ #
    def get_config(self) -> CommissionConfig:
        record = self._config_store.get_config()
        if record:
            return CommissionConfig.model_validate(record)
        return self._default_config()

    def set_config(self, cfg: CommissionConfig) -> None:
        self._config_store.save_config(cfg.model_dump())

    # ------------------------------------------------------------------ #
    # Commission calculation
    # ------------------------------------------------------------------ #
    def calculate_for_booking(self, booking_id: UUID) -> BookingCommissionResponse:
        """
        Calculate and persist commission for a single booking.

        Uses:
        - CommissionConfig (default or per plan_type override)
        - Active Subscription for the booking's hostel (if any)
        """
        cfg = self.get_config()

        with UnitOfWork(self._session_factory) as uow:
            booking_repo = self._get_booking_repo(uow)
            sub_repo = self._get_sub_repo(uow)
            plan_repo = self._get_plan_repo(uow)

            booking = booking_repo.get(booking_id)
            if booking is None:
                raise errors.NotFoundError(f"Booking {booking_id} not found")

            booking_amount = getattr(booking, "total_amount", None)
            if booking_amount is None:
                raise errors.ValidationError("Booking has no total_amount set")

            booking_date = booking.booking_date.date() if booking.booking_date else date.today()

            sub = sub_repo.get_active_for_hostel(booking.hostel_id, as_of=booking_date)
            subscription_id: UUID
            plan_type_key = "default"

            if sub:
                subscription_id = sub.id
                plan = plan_repo.get(sub.plan_id)
                if plan and getattr(plan, "plan_type", None):
                    plan_type_key = getattr(plan.plan_type, "value", str(plan.plan_type))
            else:
                subscription_id = UUID(int=0)

            # Determine commission percentage
            pct = cfg.default_commission_percentage
            override = cfg.commission_by_plan.get(plan_type_key)
            if override is not None:
                pct = override

            # Clamp between min/max
            pct = max(cfg.min_commission_percentage, min(cfg.max_commission_percentage, pct))

            commission_amount = (booking_amount * pct / Decimal("100")).quantize(Decimal("0.01"))
            due_date = booking_date + timedelta(days=30)

            record = {
                "id": UUID(int=0),
                "booking_id": booking.id,
                "hostel_id": booking.hostel_id,
                "subscription_id": subscription_id,
                "booking_amount": booking_amount,
                "commission_percentage": pct,
                "commission_amount": commission_amount,
                "currency": "INR",
                "status": "calculated",
                "due_date": due_date,
                "paid_date": None,
                "payment_reference": None,
            }
            saved = self._commission_store.save_commission(record)

        return BookingCommissionResponse.model_validate(saved)

    # ------------------------------------------------------------------ #
    # Summary
    # ------------------------------------------------------------------ #
    def get_commission_summary(
        self,
        scope_type: str,      # "platform" | "hostel"
        *,
        hostel_id: Optional[UUID],
        period: DateRangeFilter,
    ) -> CommissionSummary:
        if scope_type not in {"platform", "hostel"}:
            raise errors.ValidationError("scope_type must be 'platform' or 'hostel'")

        if scope_type == "platform":
            hostel_id_filter = None
        else:
            hostel_id_filter = hostel_id

        start = period.start_date or date.min
        end = period.end_date or date.max

        records = self._commission_store.list_commissions(
            hostel_id=hostel_id_filter,
            start_date=start,
            end_date=end,
        )

        total_due = Decimal("0")
        total_paid = Decimal("0")
        total_bookings = len(records)
        bookings_with_commission = 0

        for r in records:
            amt = Decimal(str(r.get("commission_amount", "0")))
            if amt > 0:
                bookings_with_commission += 1

            status = (r.get("status") or "").lower()
            if status in {"pending", "calculated"}:
                total_due += amt
            elif status == "paid":
                total_paid += amt

        return CommissionSummary(
            scope_type=scope_type,
            hostel_id=hostel_id_filter,
            period_start=start,
            period_end=end,
            total_commission_due=total_due,
            total_commission_paid=total_paid,
            total_bookings_count=total_bookings,
            bookings_with_commission_count=bookings_with_commission,
        )

# --- File: D:\hostel-management-saas\app\services\subscription\subscription_billing_service.py ---
# app/services/subscription/subscription_billing_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, List, Optional, Protocol
from uuid import UUID, uuid4

from sqlalchemy.orm import Session

from app.repositories.transactions import SubscriptionRepository, SubscriptionPlanRepository
from app.schemas.subscription.subscription_billing import (
    BillingCycleInfo,
    GenerateInvoiceRequest,
    InvoiceInfo,
)
from app.schemas.common.enums import BillingCycle
from app.services.common import UnitOfWork, errors


class InvoiceStore(Protocol):
    """
    Storage abstraction for invoices.

    Expected record keys:

        {
            "invoice_id": UUID,
            "subscription_id": UUID,
            "hostel_id": UUID,
            "invoice_number": str,
            "invoice_date": date,
            "due_date": date,
            "amount": Decimal,
            "currency": str,
            "status": str,  # draft|issued|paid|overdue|cancelled
            "invoice_url": str | None,
        }
    """

    def save_invoice(self, record: dict) -> dict: ...
    def get_invoice(self, invoice_id: UUID) -> Optional[dict]: ...
    def list_invoices_for_subscription(self, subscription_id: UUID) -> List[dict]: ...


class SubscriptionBillingService:
    """
    Subscription billing:

    - Provide BillingCycleInfo for a subscription
    - Generate an invoice for a billing date
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        invoice_store: InvoiceStore,
    ) -> None:
        self._session_factory = session_factory
        self._invoice_store = invoice_store

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_sub_repo(self, uow: UnitOfWork) -> SubscriptionRepository:
        return uow.get_repo(SubscriptionRepository)

    def _get_plan_repo(self, uow: UnitOfWork) -> SubscriptionPlanRepository:
        return uow.get_repo(SubscriptionPlanRepository)

    # ------------------------------------------------------------------ #
    # Billing cycle
    # ------------------------------------------------------------------ #
    def get_billing_cycle_info(
        self,
        subscription_id: UUID,
        *,
        as_of: Optional[date] = None,
    ) -> BillingCycleInfo:
        """
        Compute a simple BillingCycleInfo for a subscription.

        Currently uses the full subscription start/end as the cycle period.
        """
        with UnitOfWork(self._session_factory) as uow:
            sub_repo = self._get_sub_repo(uow)
            plan_repo = self._get_plan_repo(uow)

            sub = sub_repo.get(subscription_id)
            if sub is None:
                raise errors.NotFoundError(f"Subscription {subscription_id} not found")

            plan = plan_repo.get(sub.plan_id)
            plan_name = plan.display_name if plan else ""

        cycle_start = sub.start_date
        cycle_end = sub.end_date
        billing_cycle_str = sub.billing_cycle.value if hasattr(sub.billing_cycle, "value") else str(sub.billing_cycle)

        info = BillingCycleInfo(
            subscription_id=sub.id,
            hostel_id=sub.hostel_id,
            plan_name=plan_name,
            cycle_start=cycle_start,
            cycle_end=cycle_end,
            billing_cycle=billing_cycle_str,
            amount=sub.amount,
            currency=sub.currency,
            next_billing_date=sub.next_billing_date or cycle_end,
            auto_renew=sub.auto_renew,
        )
        return info

    # ------------------------------------------------------------------ #
    # Invoice generation
    # ------------------------------------------------------------------ #
    def generate_invoice(self, req: GenerateInvoiceRequest) -> InvoiceInfo:
        """
        Generate and persist an invoice for the given subscription & billing_date.
        """
        with UnitOfWork(self._session_factory) as uow:
            sub_repo = self._get_sub_repo(uow)

            sub = sub_repo.get(req.subscription_id)
            if sub is None:
                raise errors.NotFoundError(f"Subscription {req.subscription_id} not found")

        amount = req.amount_override or sub.amount  # type: ignore[attr-defined]
        invoice_id = uuid4()
        invoice_number = f"INV-{sub.id}-{req.billing_date.isoformat()}"  # type: ignore[attr-defined]
        due_date = req.billing_date

        record = {
            "invoice_id": invoice_id,
            "subscription_id": sub.id,      # type: ignore[attr-defined]
            "hostel_id": sub.hostel_id,     # type: ignore[attr-defined]
            "invoice_number": invoice_number,
            "invoice_date": req.billing_date,
            "due_date": due_date,
            "amount": amount,
            "currency": sub.currency,       # type: ignore[attr-defined]
            "status": "issued",
            "invoice_url": None,
        }
        saved = self._invoice_store.save_invoice(record)

        return InvoiceInfo.model_validate(saved)

# --- File: D:\hostel-management-saas\app\services\subscription\subscription_plan_service.py ---
# app/services/subscription/subscription_plan_service.py
from __future__ import annotations

from typing import Callable, Dict, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import SubscriptionPlanRepository
from app.schemas.subscription.subscription_plan_base import PlanCreate, PlanUpdate
from app.schemas.subscription.subscription_plan_response import (
    PlanResponse,
    PlanComparison,
)
from app.services.common import UnitOfWork, errors


class SubscriptionPlanService:
    """
    Manage subscription plans:

    - Create / update plans
    - Get single plan
    - List public plans
    - Compare multiple plans (feature matrix)
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_repo(self, uow: UnitOfWork) -> SubscriptionPlanRepository:
        return uow.get_repo(SubscriptionPlanRepository)

    # ------------------------------------------------------------------ #
    # Mapping
    # ------------------------------------------------------------------ #
    def _to_response(self, p) -> PlanResponse:
        return PlanResponse(
            id=p.id,
            created_at=p.created_at,
            updated_at=p.updated_at,
            plan_name=p.plan_name,
            display_name=p.display_name,
            plan_type=p.plan_type,
            description=p.description,
            price_monthly=p.price_monthly,
            price_yearly=p.price_yearly,
            currency=p.currency,
            features=p.features or {},
            max_hostels=p.max_hostels,
            max_rooms_per_hostel=p.max_rooms_per_hostel,
            max_students=p.max_students,
            is_active=p.is_active,
            is_public=p.is_public,
            sort_order=p.sort_order,
        )

    # ------------------------------------------------------------------ #
    # CRUD
    # ------------------------------------------------------------------ #
    def create_plan(self, data: PlanCreate) -> PlanResponse:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            payload = data.model_dump(exclude_unset=True)
            p = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()
            return self._to_response(p)

    def update_plan(self, plan_id: UUID, data: PlanUpdate) -> PlanResponse:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            p = repo.get(plan_id)
            if p is None:
                raise errors.NotFoundError(f"SubscriptionPlan {plan_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(p, field) and field != "id":
                    setattr(p, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return self._to_response(p)

    def get_plan(self, plan_id: UUID) -> PlanResponse:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            p = repo.get(plan_id)
            if p is None:
                raise errors.NotFoundError(f"SubscriptionPlan {plan_id} not found")
            return self._to_response(p)

    def list_public_plans(self) -> List[PlanResponse]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            recs = repo.list_public()
        return [self._to_response(p) for p in recs]

    # ------------------------------------------------------------------ #
    # Comparison
    # ------------------------------------------------------------------ #
    def compare_plans(self, plan_ids: List[UUID]) -> PlanComparison:
        """
        Build a PlanComparison for the given plan_ids.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            recs = []
            for pid in plan_ids:
                p = repo.get(pid)
                if p:
                    recs.append(p)

        responses = [self._to_response(p) for p in recs]

        # feature_matrix: feature_key -> plan_name -> value
        feature_matrix: Dict[str, Dict[str, object]] = {}
        for p in responses:
            for key, value in (p.features or {}).items():
                feature_matrix.setdefault(key, {})[p.plan_name] = value

        return PlanComparison(
            plans=responses,
            feature_matrix=feature_matrix,
        )

# --- File: D:\hostel-management-saas\app\services\subscription\subscription_service.py ---
# app/services/subscription/subscription_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import SubscriptionRepository, SubscriptionPlanRepository
from app.repositories.core import HostelRepository
from app.schemas.subscription.subscription_base import (
    SubscriptionCreate,
    SubscriptionUpdate,
)
from app.schemas.subscription.subscription_response import (
    SubscriptionResponse,
    BillingHistory,
    BillingHistoryItem,
)
from app.services.common import UnitOfWork, errors


class SubscriptionService:
    """
    Hostel subscription management:

    - Create / update subscription records
    - Get subscription detail
    - Get active subscription for a hostel
    - (Skeleton) billing history placeholder
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_sub_repo(self, uow: UnitOfWork) -> SubscriptionRepository:
        return uow.get_repo(SubscriptionRepository)

    def _get_plan_repo(self, uow: UnitOfWork) -> SubscriptionPlanRepository:
        return uow.get_repo(SubscriptionPlanRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    # ------------------------------------------------------------------ #
    # Mapping
    # ------------------------------------------------------------------ #
    def _to_response(
        self,
        sub,
        *,
        hostel_name: str,
        plan,
    ) -> SubscriptionResponse:
        return SubscriptionResponse(
            id=sub.id,
            created_at=sub.created_at,
            updated_at=sub.updated_at,
            hostel_id=sub.hostel_id,
            hostel_name=hostel_name,
            plan_id=sub.plan_id,
            plan_name=plan.plan_name if plan else "",
            display_name=plan.display_name if plan else "",
            plan_type=plan.plan_type if plan else None,
            subscription_reference=sub.subscription_reference,
            billing_cycle=sub.billing_cycle,
            amount=sub.amount,
            currency=sub.currency,
            start_date=sub.start_date,
            end_date=sub.end_date,
            auto_renew=sub.auto_renew,
            next_billing_date=sub.next_billing_date,
            status=sub.status,
            trial_end_date=None,           # not stored in model
            last_payment_date=None,        # can be wired via PaymentRepository
            last_payment_amount=None,      # can be wired via PaymentRepository
        )

    # ------------------------------------------------------------------ #
    # CRUD
    # ------------------------------------------------------------------ #
    def create_subscription(self, data: SubscriptionCreate) -> SubscriptionResponse:
        with UnitOfWork(self._session_factory) as uow:
            sub_repo = self._get_sub_repo(uow)
            plan_repo = self._get_plan_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            plan = plan_repo.get(data.plan_id)
            if plan is None:
                raise errors.NotFoundError(f"SubscriptionPlan {data.plan_id} not found")

            payload = data.model_dump(exclude={"trial_end_date"}, exclude_unset=True)
            sub = sub_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()
            return self._to_response(sub, hostel_name=hostel.name, plan=plan)

    def update_subscription(self, subscription_id: UUID, data: SubscriptionUpdate) -> SubscriptionResponse:
        with UnitOfWork(self._session_factory) as uow:
            sub_repo = self._get_sub_repo(uow)
            plan_repo = self._get_plan_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            sub = sub_repo.get(subscription_id)
            if sub is None:
                raise errors.NotFoundError(f"Subscription {subscription_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(sub, field) and field != "id":
                    setattr(sub, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            hostel = hostel_repo.get(sub.hostel_id)
            plan = plan_repo.get(sub.plan_id)
            uow.commit()

            hostel_name = hostel.name if hostel else ""
            return self._to_response(sub, hostel_name=hostel_name, plan=plan)

    def get_subscription(self, subscription_id: UUID) -> SubscriptionResponse:
        with UnitOfWork(self._session_factory) as uow:
            sub_repo = self._get_sub_repo(uow)
            plan_repo = self._get_plan_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            sub = sub_repo.get(subscription_id)
            if sub is None:
                raise errors.NotFoundError(f"Subscription {subscription_id} not found")

            hostel = hostel_repo.get(sub.hostel_id)
            plan = plan_repo.get(sub.plan_id)
            hostel_name = hostel.name if hostel else ""
            return self._to_response(sub, hostel_name=hostel_name, plan=plan)

    # ------------------------------------------------------------------ #
    # Active subscription
    # ------------------------------------------------------------------ #
    def get_active_for_hostel(self, hostel_id: UUID, as_of: Optional[date] = None) -> Optional[SubscriptionResponse]:
        with UnitOfWork(self._session_factory) as uow:
            sub_repo = self._get_sub_repo(uow)
            plan_repo = self._get_plan_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            sub = sub_repo.get_active_for_hostel(hostel_id, as_of=as_of)
            if not sub:
                return None

            hostel = hostel_repo.get(sub.hostel_id)
            plan = plan_repo.get(sub.plan_id)
            hostel_name = hostel.name if hostel else ""
            return self._to_response(sub, hostel_name=hostel_name, plan=plan)

    # ------------------------------------------------------------------ #
    # Billing history (placeholder)
    # ------------------------------------------------------------------ #
    def get_billing_history(self, subscription_id: UUID) -> BillingHistory:
        """
        Placeholder: returns an empty BillingHistory.

        For a real implementation, this should be wired to invoices/payments
        generated per billing cycle.
        """
        return BillingHistory(
            subscription_id=subscription_id,
            hostel_id=UUID(int=0),
            items=[],
            total_billed=Decimal("0"),
            total_paid=Decimal("0"),
            total_outstanding=Decimal("0"),
        )

# --- File: D:\hostel-management-saas\app\services\subscription\subscription_upgrade_service.py ---
# app/services/subscription/subscription_upgrade_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import SubscriptionRepository, SubscriptionPlanRepository
from app.schemas.subscription.subscription_upgrade import (
    UpgradeRequest,
    UpgradePreview,
)
from app.schemas.subscription.subscription_response import SubscriptionResponse
from app.services.common import UnitOfWork, errors


class SubscriptionUpgradeService:
    """
    Handle subscription upgrade/downgrade:

    - Preview cost impact (proration) of changing plans.
    - Apply the new plan to the Subscription (without billing integration).
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_sub_repo(self, uow: UnitOfWork) -> SubscriptionRepository:
        return uow.get_repo(SubscriptionRepository)

    def _get_plan_repo(self, uow: UnitOfWork) -> SubscriptionPlanRepository:
        return uow.get_repo(SubscriptionPlanRepository)

    # ------------------------------------------------------------------ #
    # Preview
    # ------------------------------------------------------------------ #
    def preview_upgrade(self, req: UpgradeRequest) -> UpgradePreview:
        with UnitOfWork(self._session_factory) as uow:
            sub_repo = self._get_sub_repo(uow)
            plan_repo = self._get_plan_repo(uow)

            sub = sub_repo.get_active_for_hostel(req.hostel_id, as_of=req.effective_from)
            if not sub:
                raise errors.NotFoundError(f"No active subscription for hostel {req.hostel_id}")

            if sub.plan_id != req.current_plan_id:
                # Allow but warn logically; for now, we just ignore mismatch.
                pass

            current_plan = plan_repo.get(sub.plan_id)
            new_plan = plan_repo.get(req.new_plan_id)
            if not current_plan or not new_plan:
                raise errors.NotFoundError("Current or new plan not found")

            current_amount = self._amount_for_cycle(current_plan, req.billing_cycle)
            new_amount = self._amount_for_cycle(new_plan, req.billing_cycle)

            # Simple proration based on days remaining in subscription term
            total_days = (sub.end_date - sub.start_date).days or 1  # type: ignore[attr-defined]
            remaining_days = (sub.end_date - req.effective_from).days  # type: ignore[attr-defined]
            remaining_ratio = Decimal(str(max(0, remaining_days))) / Decimal(str(total_days))

            diff = new_amount - current_amount
            if diff > 0:
                prorated_charge = diff * remaining_ratio
                prorated_refund = Decimal("0")
            else:
                prorated_charge = Decimal("0")
                prorated_refund = abs(diff) * remaining_ratio

        message = "Upgrade preview" if diff >= 0 else "Downgrade preview"

        return UpgradePreview(
            current_plan_name=current_plan.display_name,
            new_plan_name=new_plan.display_name,
            current_amount=current_amount,
            new_amount=new_amount,
            prorated_charge=prorated_charge.quantize(Decimal("0.01")),
            prorated_refund=prorated_refund.quantize(Decimal("0.01")),
            effective_from=req.effective_from,
            message=message,
        )

    def _amount_for_cycle(self, plan, billing_cycle) -> Decimal:
        if billing_cycle.name == "MONTHLY":
            return plan.price_monthly
        if billing_cycle.name == "YEARLY":
            return plan.price_yearly
        # Default to monthly
        return plan.price_monthly

    # ------------------------------------------------------------------ #
    # Apply upgrade
    # ------------------------------------------------------------------ #
    def apply_upgrade(self, req: UpgradeRequest) -> SubscriptionResponse:
        """
        Apply upgrade to Subscription: switch plan + billing_cycle/amount.

        NOTE:
        - Does not create billing records; caller should handle charging/refunding
          based on preview_upgrade.
        """
        from app.schemas.subscription.subscription_response import SubscriptionResponse as SubRespSchema

        preview = self.preview_upgrade(req)

        with UnitOfWork(self._session_factory) as uow:
            sub_repo = self._get_sub_repo(uow)
            plan_repo = self._get_plan_repo(uow)

            sub = sub_repo.get_active_for_hostel(req.hostel_id, as_of=req.effective_from)
            if not sub:
                raise errors.NotFoundError(f"No active subscription for hostel {req.hostel_id}")

            new_plan = plan_repo.get(req.new_plan_id)
            if not new_plan:
                raise errors.NotFoundError(f"New plan {req.new_plan_id} not found")

            # Update subscription
            sub.plan_id = req.new_plan_id  # type: ignore[attr-defined]
            sub.billing_cycle = req.billing_cycle  # type: ignore[attr-defined]
            sub.amount = preview.new_amount  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        # Use SubscriptionService for consistent mapping if desired;
        # here we construct a minimal SubscriptionResponse-like object.
        return SubRespSchema(
            id=sub.id,
            created_at=sub.created_at,
            updated_at=sub.updated_at,
            hostel_id=sub.hostel_id,
            hostel_name="",  # could be filled via HostelRepository if needed
            plan_id=sub.plan_id,
            plan_name=new_plan.plan_name,
            display_name=new_plan.display_name,
            plan_type=new_plan.plan_type,
            subscription_reference=sub.subscription_reference,
            billing_cycle=sub.billing_cycle,
            amount=sub.amount,
            currency=sub.currency,
            start_date=sub.start_date,
            end_date=sub.end_date,
            auto_renew=sub.auto_renew,
            next_billing_date=sub.next_billing_date,
            status=sub.status,
            trial_end_date=None,
            last_payment_date=None,
            last_payment_amount=None,
        )

# --- File: D:\hostel-management-saas\app\services\subscription\__init__.py ---
# app/services/subscription/__init__.py
"""
Subscription & commission services.

- SubscriptionPlanService:
    Manage subscription plan definitions and comparisons.

- SubscriptionService:
    Manage hostel subscriptions (create/update/get/active).

- SubscriptionBillingService:
    Billing cycle info and invoice generation for subscriptions.

- SubscriptionUpgradeService:
    Upgrade/downgrade preview and application.

- CommissionService:
    Booking commission calculation and summaries.
"""

from .subscription_plan_service import SubscriptionPlanService
from .subscription_service import SubscriptionService
from .subscription_billing_service import SubscriptionBillingService, InvoiceStore
from .subscription_upgrade_service import SubscriptionUpgradeService
from .commission_service import CommissionService, CommissionConfigStore, CommissionStore

__all__ = [
    "SubscriptionPlanService",
    "SubscriptionService",
    "SubscriptionBillingService",
    "InvoiceStore",
    "SubscriptionUpgradeService",
    "CommissionService",
    "CommissionConfigStore",
    "CommissionStore",
]


# ===== Folder: D:\hostel-management-saas\app\services\supervisor =====

# --- File: D:\hostel-management-saas\app\services\supervisor\supervisor_activity_service.py ---
# app/services/supervisor/supervisor_activity_service.py
from __future__ import annotations

from collections import defaultdict
from datetime import datetime
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.audit import SupervisorActivityRepository
from app.repositories.core import SupervisorRepository, HostelRepository
from app.schemas.common.filters import DateTimeRangeFilter
from app.schemas.supervisor.supervisor_activity import (
    SupervisorActivityLog,
    ActivitySummary,
    ActivityDetail,
    ActivityFilterParams,
    TopActivity,
    ActivityTimelinePoint,
)
from app.services.common import UnitOfWork, errors


class SupervisorActivityService:
    """
    Supervisor activity reporting:

    - List activity logs with filtering
    - Get single activity detail
    - Build summary over a period
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # Helpers
    def _get_repo(self, uow: UnitOfWork) -> SupervisorActivityRepository:
        return uow.get_repo(SupervisorActivityRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # Mapping
    def _to_log(
        self,
        rec,
        *,
        supervisor_name: str,
        hostel_name: str,
    ) -> SupervisorActivityLog:
        from app.schemas.common.enums import AuditActionCategory

        category = rec.action_category
        if not isinstance(category, AuditActionCategory):
            try:
                category = AuditActionCategory(category)
            except Exception:
                category = AuditActionCategory.OTHER  # type: ignore[attr-defined]

        return SupervisorActivityLog(
            id=rec.id,
            created_at=rec.created_at,
            updated_at=rec.created_at,
            supervisor_id=rec.supervisor_id,
            supervisor_name=supervisor_name,
            hostel_id=rec.hostel_id,
            hostel_name=hostel_name,
            action_type=rec.action_type,
            action_category=category,
            entity_type=rec.entity_type,
            entity_id=rec.entity_id,
            action_description=rec.action_description,
            metadata=rec.metadata or {},
            ip_address=rec.ip_address,
            user_agent=rec.user_agent,
        )

    # Listing
    def list_activity_logs(self, filters: ActivityFilterParams) -> List[SupervisorActivityLog]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            raw_filters: Dict[str, object] = {}
            if filters.supervisor_id:
                raw_filters["supervisor_id"] = filters.supervisor_id
            elif filters.supervisor_ids:
                raw_filters["supervisor_id"] = filters.supervisor_ids
            if filters.hostel_id:
                raw_filters["hostel_id"] = filters.hostel_id
            if filters.action_type:
                raw_filters["action_type"] = filters.action_type
            if filters.entity_type:
                raw_filters["entity_type"] = filters.entity_type
            if filters.entity_id:
                raw_filters["entity_id"] = filters.entity_id

            recs = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=raw_filters or None,
                order_by=[repo.model.created_at.desc()],  # type: ignore[attr-defined]
            )

            def _in_range(rec) -> bool:
                dr: Optional[DateTimeRangeFilter] = filters.date_range
                if not dr:
                    return True
                if dr.start and rec.created_at < dr.start:
                    return False
                if dr.end and rec.created_at > dr.end:
                    return False
                return True

            def _cat_ok(rec) -> bool:
                if filters.action_category:
                    return rec.action_category == filters.action_category
                if filters.action_categories:
                    return rec.action_category in filters.action_categories
                return True

            def _success_ok(rec) -> bool:
                # Success/failure flags not in model; treat all as success
                if filters.success_only:
                    return True
                if filters.failed_only:
                    return False
                return True

            filtered = [r for r in recs if _in_range(r) and _cat_ok(r) and _success_ok(r)]

            # Pagination
            page = filters.page
            page_size = filters.page_size
            offset = (page - 1) * page_size
            page_recs = filtered[offset : offset + page_size]

            # Cache names
            sup_cache: Dict[UUID, str] = {}
            hostel_cache: Dict[UUID, str] = {}

            logs: List[SupervisorActivityLog] = []
            for r in page_recs:
                if r.supervisor_id not in sup_cache:
                    sup = sup_repo.get(r.supervisor_id)
                    sup_cache[r.supervisor_id] = (
                        sup.user.full_name if sup and getattr(sup, "user", None) else ""
                    )
                supervisor_name = sup_cache[r.supervisor_id]

                if r.hostel_id not in hostel_cache:
                    h = hostel_repo.get(r.hostel_id)
                    hostel_cache[r.hostel_id] = h.name if h else ""
                hostel_name = hostel_cache[r.hostel_id]

                logs.append(self._to_log(r, supervisor_name=supervisor_name, hostel_name=hostel_name))

            return logs

    # Detail
    def get_activity_detail(self, activity_id: UUID) -> ActivityDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            r = repo.get(activity_id)
            if r is None:
                raise errors.NotFoundError(f"SupervisorActivity {activity_id} not found")

            sup = sup_repo.get(r.supervisor_id)
            sup_name = sup.user.full_name if sup and getattr(sup, "user", None) else ""

        return ActivityDetail(
            activity_id=r.id,
            supervisor_id=r.supervisor_id,
            supervisor_name=sup_name,
            timestamp=r.created_at,
            action_type=r.action_type,
            action_category=r.action_category,
            action_description=r.action_description,
            entity_type=r.entity_type,
            entity_id=r.entity_id,
            entity_name=None,
            old_values=None,
            new_values=None,
            ip_address=r.ip_address,
            user_agent=r.user_agent,
            location=None,
            success=True,
            error_message=None,
        )

    # Summary
    def get_activity_summary(self, filters: ActivityFilterParams) -> ActivitySummary:
        logs = self.list_activity_logs(filters)

        if filters.date_range and filters.date_range.start and filters.date_range.end:
            period_start = filters.date_range.start
            period_end = filters.date_range.end
        elif logs:
            period_start = logs[-1].created_at
            period_end = logs[0].created_at
        else:
            now = self._now()
            period_start = period_end = now

        total_actions = len(logs)
        actions_by_category: Dict[str, int] = defaultdict(int)
        actions_by_type: Dict[str, int] = defaultdict(int)
        timeline_map: Dict[str, Dict[str, int]] = defaultdict(lambda: defaultdict(int))
        type_cat_counts: Dict[tuple[str, str], Dict[str, object]] = {}

        for l in logs:
            cat_key = l.action_category.value if hasattr(l.action_category, "value") else str(l.action_category)
            type_key = l.action_type
            actions_by_category[cat_key] += 1
            actions_by_type[type_key] += 1

            # timeline (per day)
            day_label = l.created_at.date().isoformat()
            timeline_map[day_label][cat_key] += 1

            key = (type_key, cat_key)
            rec = type_cat_counts.setdefault(
                key,
                {"count": 0, "last": l.created_at},
            )
            rec["count"] += 1
            if l.created_at > rec["last"]:
                rec["last"] = l.created_at

        # Top activities
        top_activities: List[TopActivity] = []
        for (act_type, cat), v in sorted(
            type_cat_counts.items(), key=lambda kv: kv[1]["count"], reverse=True
        )[:5]:
            top_activities.append(
                TopActivity(
                    action_type=act_type,
                    action_category=cat,
                    count=v["count"],
                    last_performed=v["last"],
                )
            )

        # Timeline points
        timeline: List[ActivityTimelinePoint] = []
        for day, cats in sorted(timeline_map.items()):
            ts = datetime.fromisoformat(day)
            total_day = sum(cats.values())
            timeline.append(
                ActivityTimelinePoint(
                    timestamp=ts,
                    action_count=total_day,
                    categories=dict(cats),
                )
            )

        # Peak hours
        hour_counts: Dict[int, int] = defaultdict(int)
        for l in logs:
            hour_counts[l.created_at.hour] += 1
        sorted_hours = sorted(hour_counts.items(), key=lambda kv: kv[1], reverse=True)
        peak_hours = [h for h, _ in sorted_hours[:3]]

        supervisor_id = filters.supervisor_id or UUID(int=0)
        supervisor_name = ""

        return ActivitySummary(
            supervisor_id=supervisor_id,
            supervisor_name=supervisor_name,
            period_start=period_start,
            period_end=period_end,
            total_actions=total_actions,
            actions_by_category=dict(actions_by_category),
            actions_by_type=dict(actions_by_type),
            top_activities=top_activities,
            activity_timeline=timeline,
            peak_hours=peak_hours,
        )

# --- File: D:\hostel-management-saas\app\services\supervisor\supervisor_assignment_service.py ---
# app/services/supervisor/supervisor_assignment_service.py
from __future__ import annotations

from datetime import date
from typing import Callable, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import SupervisorRepository, UserRepository, HostelRepository
from app.repositories.associations import SupervisorHostelRepository
from app.schemas.supervisor import (
    SupervisorAssignment,
    AssignmentRequest,
    AssignmentUpdate,
    RevokeAssignmentRequest,
)
from app.schemas.common.enums import EmploymentType, SupervisorStatus
from app.services.common import UnitOfWork, errors


class SupervisorAssignmentService:
    """
    Supervisor ↔ hostel assignments (multi-hostel):

    - Assign supervisor (user) to a hostel (creates core_supervisor if needed).
    - Update assignment metadata.
    - Revoke assignment.
    - List assignments for a supervisor or hostel (simple).
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # Helpers
    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_assoc_repo(self, uow: UnitOfWork) -> SupervisorHostelRepository:
        return uow.get_repo(SupervisorHostelRepository)

    # Mapping
    def _build_assignment(
        self,
        assoc,
        *,
        supervisor_name: str,
        hostel_name: str,
        assigned_by: UUID,
        assigned_by_name: str,
    ) -> SupervisorAssignment:
        return SupervisorAssignment(
            id=assoc.id,
            created_at=assoc.created_at,
            updated_at=assoc.updated_at,
            supervisor_id=assoc.supervisor_id,
            supervisor_name=supervisor_name,
            hostel_id=assoc.hostel_id,
            hostel_name=hostel_name,
            assigned_by=assigned_by,
            assigned_by_name=assigned_by_name,
            assigned_date=assoc.join_date,
            is_active=assoc.is_active,
            permission_level="standard",
            last_active=None,
        )

    # Assignment
    def assign_supervisor(
        self,
        data: AssignmentRequest,
        *,
        assigned_by: UUID,
    ) -> SupervisorAssignment:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            assoc_repo = self._get_assoc_repo(uow)

            user = user_repo.get(data.user_id)
            if user is None:
                raise errors.NotFoundError(f"User {data.user_id} not found")

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            # Ensure a core_supervisor exists for this user
            sup_list = sup_repo.get_multi(filters={"user_id": data.user_id})
            if sup_list:
                supervisor = sup_list[0]
            else:
                supervisor = sup_repo.create(
                    {
                        "user_id": data.user_id,
                        "hostel_id": data.hostel_id,
                        "employee_id": data.employee_id,
                        "join_date": data.join_date,
                        "employment_type": EmploymentType.FULL_TIME,
                        "shift_timing": data.shift_timing,
                        "status": SupervisorStatus.ACTIVE,
                        "is_active": True,
                        "permissions": data.permissions or {},
                    }
                )

            # Prevent duplicate assignment
            existing = assoc_repo.get_multi(
                skip=0,
                limit=1,
                filters={"supervisor_id": supervisor.id, "hostel_id": data.hostel_id},
            )
            if existing:
                raise errors.ConflictError("Supervisor already assigned to this hostel")

            assoc = assoc_repo.create(
                {
                    "supervisor_id": supervisor.id,
                    "hostel_id": data.hostel_id,
                    "employee_id": data.employee_id,
                    "join_date": data.join_date,
                    "employment_type": data.employment_type,
                    "shift_timing": data.shift_timing,
                    "is_active": True,
                    "permissions": data.permissions or {},
                }
            )

            assigned_by_user = user_repo.get(assigned_by)
            assigned_by_name = assigned_by_user.full_name if assigned_by_user else ""

            uow.commit()
            return self._build_assignment(
                assoc,
                supervisor_name=user.full_name,
                hostel_name=hostel.name,
                assigned_by=assigned_by,
                assigned_by_name=assigned_by_name,
            )

    def update_assignment(self, assignment_id: UUID, data: AssignmentUpdate) -> SupervisorAssignment:
        with UnitOfWork(self._session_factory) as uow:
            assoc_repo = self._get_assoc_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            assoc = assoc_repo.get(assignment_id)
            if assoc is None:
                raise errors.NotFoundError(f"SupervisorHostel {assignment_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(assoc, field) and field != "id":
                    setattr(assoc, field, value)

            uow.session.flush()  # type: ignore[union-attr]

            sup_user = user_repo.get(assoc.supervisor_id)
            supervisor_name = sup_user.full_name if sup_user else ""
            hostel = hostel_repo.get(assoc.hostel_id)
            hostel_name = hostel.name if hostel else ""

            uow.commit()
            return self._build_assignment(
                assoc,
                supervisor_name=supervisor_name,
                hostel_name=hostel_name,
                assigned_by=UUID(int=0),
                assigned_by_name="",
            )

    def revoke_assignment(
        self,
        data: RevokeAssignmentRequest,
        *,
        revoked_by: UUID,
    ) -> None:
        """
        Mark supervisor-hostel association as inactive.
        """
        with UnitOfWork(self._session_factory) as uow:
            assoc_repo = self._get_assoc_repo(uow)

            # Find associations for this supervisor (all hostels)
            assocs = assoc_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"supervisor_id": data.supervisor_id},
            )
            if not assocs:
                raise errors.NotFoundError(f"No assignments found for supervisor {data.supervisor_id}")

            for a in assocs:
                a.is_active = False  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

    def list_assignments_for_supervisor(self, supervisor_id: UUID) -> List[SupervisorAssignment]:
        with UnitOfWork(self._session_factory) as uow:
            assoc_repo = self._get_assoc_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            assocs = assoc_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"supervisor_id": supervisor_id},
            )

            sup_user = user_repo.get(supervisor_id)
            supervisor_name = sup_user.full_name if sup_user else ""

            results: List[SupervisorAssignment] = []
            for a in assocs:
                hostel = hostel_repo.get(a.hostel_id)
                hostel_name = hostel.name if hostel else ""
                results.append(
                    self._build_assignment(
                        a,
                        supervisor_name=supervisor_name,
                        hostel_name=hostel_name,
                        assigned_by=UUID(int=0),
                        assigned_by_name="",
                    )
                )
            return results

# --- File: D:\hostel-management-saas\app\services\supervisor\supervisor_dashboard_service.py ---
# app/services/supervisor/supervisor_dashboard_service.py
from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import (
    SupervisorRepository,
    HostelRepository,
    StudentRepository,
    BedRepository,
)
from app.repositories.services import (
    ComplaintRepository,
    MaintenanceRepository,
    AttendanceRepository,
    LeaveApplicationRepository,
)
from app.repositories.transactions import PaymentRepository
from app.schemas.common.enums import ComplaintStatus, MaintenanceStatus, AttendanceStatus, LeaveStatus, Priority
from app.schemas.supervisor import (
    SupervisorDashboard,
    DashboardMetrics,
    TaskSummary,
    RecentComplaintItem,
    RecentMaintenanceItem,
    PendingLeaveItem,
    TodaySchedule,
    ScheduledMaintenanceItem,
    ScheduledMeeting,
    DashboardAlert,
)
from app.services.common import UnitOfWork, errors


class SupervisorDashboardService:
    """
    Supervisor dashboard aggregation:

    - Quick metrics for students, occupancy, complaints, maintenance, attendance, payments.
    - Recent complaints/maintenance/leaves.
    - Simple schedule skeleton and alerts.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # Helpers
    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _get_complaint_repo(self, uow: UnitOfWork) -> ComplaintRepository:
        return uow.get_repo(ComplaintRepository)

    def _get_maintenance_repo(self, uow: UnitOfWork) -> MaintenanceRepository:
        return uow.get_repo(MaintenanceRepository)

    def _get_attendance_repo(self, uow: UnitOfWork) -> AttendanceRepository:
        return uow.get_repo(AttendanceRepository)

    def _get_leave_repo(self, uow: UnitOfWork) -> LeaveApplicationRepository:
        return uow.get_repo(LeaveApplicationRepository)

    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _today(self) -> date:
        return date.today()

    def _now(self) -> datetime:
        return datetime.utcnow()

    # Public API
    def get_dashboard(self, supervisor_id: UUID) -> SupervisorDashboard:
        today = self._today()

        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)
            bed_repo = self._get_bed_repo(uow)
            complaint_repo = self._get_complaint_repo(uow)
            maintenance_repo = self._get_maintenance_repo(uow)
            attendance_repo = self._get_attendance_repo(uow)
            leave_repo = self._get_leave_repo(uow)
            payment_repo = self._get_payment_repo(uow)

            sup = sup_repo.get(supervisor_id)
            if sup is None or not getattr(sup, "user", None):
                raise errors.NotFoundError(f"Supervisor {supervisor_id} not found")

            hostel = hostel_repo.get(sup.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {sup.hostel_id} not found")

            hostel_name = hostel.name

            # Students & beds
            students = student_repo.list_for_hostel(hostel.id, status=None)
            total_students = len(students)
            active_students = sum(1 for s in students if s.student_status.name == "ACTIVE")

            beds = bed_repo.get_multi(filters={"hostel_id": hostel.id})
            total_beds = len(beds)
            occupied_beds = sum(1 for b in beds if b.current_student_id is not None)
            available_beds = max(0, total_beds - occupied_beds)
            occupancy_pct = (
                Decimal(str(occupied_beds)) / Decimal(str(total_beds)) * Decimal("100")
                if total_beds > 0
                else Decimal("0")
            )

            # Complaints
            open_complaints_list = complaint_repo.list_open_for_hostel(
                hostel.id,
                category=None,
                priority=None,
            )
            total_complaints = len(
                complaint_repo.get_multi(filters={"hostel_id": hostel.id})
            )
            assigned_to_me = len(
                [c for c in open_complaints_list if c.assigned_to_id == supervisor_id]
            )
            resolved_today = 0  # detailed tracking omitted

            # Maintenance
            open_maintenance_list = maintenance_repo.list_open_for_hostel(
                hostel.id,
                category=None,
                priority=None,
            )
            pending_maintenance = len(open_maintenance_list)
            in_progress_maintenance = len(
                [m for m in open_maintenance_list if m.status == MaintenanceStatus.IN_PROGRESS]
            )
            completed_today = 0  # placeholder

            # Attendance today
            todays_attendance = attendance_repo.list_for_hostel_date(hostel.id, today)
            attendance_marked_today = len(todays_attendance) > 0
            total_present_today = len(
                [a for a in todays_attendance if a.status == AttendanceStatus.PRESENT]
            ) + len(
                [a for a in todays_attendance if a.status == AttendanceStatus.LATE]
            )
            total_absent_today = len(
                [a for a in todays_attendance if a.status == AttendanceStatus.ABSENT]
            )
            students_on_leave = len(
                [a for a in todays_attendance if a.status == AttendanceStatus.ON_LEAVE]
            )

            # Payments overdue
            overdue_payments = payment_repo.list_due_for_hostel(
                hostel.id,
                on_or_before=today,
            )
            overdue_payments_count = len(overdue_payments)

            # DashboardMetrics
            metrics = DashboardMetrics(
                total_students=total_students,
                active_students=active_students,
                total_beds=total_beds,
                occupied_beds=occupied_beds,
                available_beds=available_beds,
                occupancy_percentage=occupancy_pct,
                total_complaints=total_complaints,
                open_complaints=len(open_complaints_list),
                assigned_to_me=assigned_to_me,
                resolved_today=resolved_today,
                average_resolution_time_hours=Decimal("0"),
                pending_maintenance=pending_maintenance,
                in_progress_maintenance=in_progress_maintenance,
                completed_today=completed_today,
                attendance_marked_today=attendance_marked_today,
                total_present_today=total_present_today,
                total_absent_today=total_absent_today,
                students_on_leave=students_on_leave,
                overdue_payments_count=overdue_payments_count,
                unread_admin_messages=0,
            )

            # TaskSummary (simple heuristic)
            urgent_complaints = len(
                [c for c in open_complaints_list if c.priority in (Priority.CRITICAL, Priority.URGENT)]
            )
            critical_maintenance = len(
                [m for m in open_maintenance_list if m.priority in (Priority.CRITICAL, Priority.URGENT)]
            )
            pending_leave_approvals = len(
                leave_repo.list_pending_for_hostel(hostel.id)
            )

            attendance_pending = not attendance_marked_today
            menu_published_today = True
            daily_inspection_done = False

            overdue_complaint_resolutions = 0
            overdue_maintenance = 0

            total_pending_tasks = (
                urgent_complaints
                + critical_maintenance
                + pending_leave_approvals
                + (1 if attendance_pending else 0)
            )

            tasks = TaskSummary(
                urgent_complaints=urgent_complaints,
                critical_maintenance=critical_maintenance,
                pending_leave_approvals=pending_leave_approvals,
                attendance_pending=attendance_pending,
                menu_published_today=menu_published_today,
                daily_inspection_done=daily_inspection_done,
                overdue_complaint_resolutions=overdue_complaint_resolutions,
                overdue_maintenance=overdue_maintenance,
                total_pending_tasks=total_pending_tasks,
            )

            # Recent complaints (assigned to supervisor)
            rec_complaints = complaint_repo.list_for_supervisor(
                supervisor_id,
                include_closed=True,
            )[:5]
            recent_complaints: List[RecentComplaintItem] = []
            for c in rec_complaints:
                age_hours = int((self._now() - c.created_at).total_seconds() // 3600)
                recent_complaints.append(
                    RecentComplaintItem(
                        complaint_id=c.id,
                        complaint_number=str(c.id),
                        title=c.title,
                        category=c.category.value if hasattr(c.category, "value") else str(c.category),
                        priority=c.priority.value if hasattr(c.priority, "value") else str(c.priority),
                        status=c.status.value if hasattr(c.status, "value") else str(c.status),
                        student_name="",
                        room_number="",
                        created_at=c.created_at,
                        age_hours=age_hours,
                    )
                )

            # Recent maintenance
            all_maint = maintenance_repo.list_open_for_hostel(hostel.id, category=None, priority=None)[:5]
            recent_maintenance: List[RecentMaintenanceItem] = []
            for m in all_maint:
                recent_maintenance.append(
                    RecentMaintenanceItem(
                        request_id=m.id,
                        request_number=str(m.id),
                        title=m.title,
                        category=m.category.value if hasattr(m.category, "value") else str(m.category),
                        priority=m.priority.value if hasattr(m.priority, "value") else str(m.priority),
                        status=m.status.value if hasattr(m.status, "value") else str(m.status),
                        room_number=None,
                        estimated_cost=m.estimated_cost,
                        created_at=m.created_at,
                    )
                )

            # Pending leave approvals
            pending_leaves = leave_repo.list_pending_for_hostel(hostel.id)[:5]
            pending_leaves_items: List[PendingLeaveItem] = []
            for l in pending_leaves:
                pending_leaves_items.append(
                    PendingLeaveItem(
                        leave_id=l.id,
                        student_name="",
                        room_number="",
                        leave_type=l.leave_type.value if hasattr(l.leave_type, "value") else str(l.leave_type),
                        from_date=l.from_date,
                        to_date=l.to_date,
                        total_days=l.total_days,
                        reason=l.reason,
                        applied_at=l.created_at,
                    )
                )

            # Today's schedule (simple defaults)
            today_schedule = TodaySchedule(
                date=today,
                attendance_marking_time="09:00",
                inspection_rounds=["Ground Floor", "First Floor"],
                scheduled_maintenance=[],
                scheduled_meetings=[],
                special_events=[],
            )

            # Alerts (placeholder)
            alerts: List[DashboardAlert] = []

            last_login = getattr(sup.user, "last_login_at", None)
            actions_today = 0

        return SupervisorDashboard(
            supervisor_id=supervisor_id,
            supervisor_name=sup.user.full_name,
            hostel_id=hostel.id,
            hostel_name=hostel_name,
            metrics=metrics,
            tasks=tasks,
            recent_complaints=recent_complaints,
            recent_maintenance=recent_maintenance,
            pending_leaves=pending_leaves_items,
            today_schedule=today_schedule,
            alerts=alerts,
            last_login=last_login,
            actions_today=actions_today,
        )

# --- File: D:\hostel-management-saas\app\services\supervisor\supervisor_performance_service.py ---
# app/services/supervisor/supervisor_performance_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Callable, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository, SupervisorRepository
from app.repositories.analytics import SupervisorPerformanceMetricsRepository
from app.schemas.common.filters import DateRangeFilter
from app.schemas.supervisor import (
    PerformanceMetrics,
    PerformanceReport,
    ComplaintPerformance,
    AttendancePerformance,
    MaintenancePerformance,
)
from app.services.analytics import SupervisorAnalyticsService
from app.services.common import UnitOfWork, errors


class SupervisorPerformanceService:
    """
    Supervisor performance service:

    - Map analytics_supervisor_performance into PerformanceMetrics.
    - Provide a basic PerformanceReport wrapper.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory
        self._analytics = SupervisorAnalyticsService(session_factory)

    # Helpers
    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_metrics_repo(self, uow: UnitOfWork) -> SupervisorPerformanceMetricsRepository:
        return uow.get_repo(SupervisorPerformanceMetricsRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # Mapping
    def _to_performance_metrics(self, m, *, supervisor_name: str) -> PerformanceMetrics:
        total_complaints = m.complaints_assigned
        complaints_resolved = m.complaints_resolved
        complaint_resolution_rate = (
            Decimal(str(complaints_resolved)) / Decimal(str(total_complaints)) * Decimal("100")
            if total_complaints > 0
            else Decimal("0")
        )

        return PerformanceMetrics(
            supervisor_id=m.supervisor_id,
            supervisor_name=supervisor_name,
            hostel_id=m.hostel_id,
            period_start=m.period_start,
            period_end=m.period_end,
            complaints_handled=m.complaints_assigned,
            complaints_resolved=m.complaints_resolved,
            complaint_resolution_rate=complaint_resolution_rate,
            average_resolution_time_hours=m.avg_complaint_resolution_time_hours,
            sla_compliance_rate=Decimal("0"),
            attendance_records_created=m.attendance_records_marked,
            attendance_accuracy=Decimal("0"),
            leaves_approved=0,
            leaves_rejected=0,
            maintenance_requests_created=m.maintenance_requests_created,
            maintenance_completed=m.maintenance_requests_completed,
            maintenance_completion_rate=Decimal("0"),
            average_maintenance_time_hours=m.avg_maintenance_completion_time_hours,
            announcements_created=0,
            announcement_reach=0,
            average_first_response_time_minutes=Decimal("0"),
            availability_percentage=Decimal("0"),
            student_feedback_score=None,
            overall_performance_score=m.overall_performance_score,
        )

    # Public API
    def get_performance_metrics(
        self,
        supervisor_id: UUID,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> Optional[PerformanceMetrics]:
        with UnitOfWork(self._session_factory) as uow:
            metrics_repo = self._get_metrics_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            m = metrics_repo.get_for_supervisor_period(
                supervisor_id=supervisor_id,
                hostel_id=hostel_id,
                period_start=period.start_date,
                period_end=period.end_date,
            )
            if not m:
                return None

            sup = sup_repo.get(supervisor_id)
            sup_name = sup.user.full_name if sup and getattr(sup, "user", None) else ""

        return self._to_performance_metrics(m, supervisor_name=sup_name)

    def get_performance_report(
        self,
        supervisor_id: UUID,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> Optional[PerformanceReport]:
        with UnitOfWork(self._session_factory) as uow:
            metrics_repo = self._get_metrics_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            m = metrics_repo.get_for_supervisor_period(
                supervisor_id=supervisor_id,
                hostel_id=hostel_id,
                period_start=period.start_date,
                period_end=period.end_date,
            )
            if not m:
                return None

            sup = sup_repo.get(supervisor_id)
            hostel = hostel_repo.get(hostel_id)
            sup_name = sup.user.full_name if sup and getattr(sup, "user", None) else ""
            hostel_name = hostel.name if hostel else ""

        metrics = self._to_performance_metrics(m, supervisor_name=sup_name)

        # Very simple placeholders for detailed sections
        complaint_perf = ComplaintPerformance(
            total_complaints=m.complaints_assigned,
            resolved_complaints=m.complaints_resolved,
            pending_complaints=m.complaints_assigned - m.complaints_resolved,
            complaints_by_category={},
            complaints_by_priority={},
            average_resolution_time_hours=m.avg_complaint_resolution_time_hours,
            fastest_resolution_hours=m.avg_complaint_resolution_time_hours,
            slowest_resolution_hours=m.avg_complaint_resolution_time_hours,
            within_sla=0,
            breached_sla=0,
            sla_compliance_rate=Decimal("0"),
            average_complaint_rating=None,
        )

        attendance_perf = AttendancePerformance(
            total_attendance_records=m.attendance_records_marked,
            days_attendance_marked=0,
            days_attendance_missed=0,
            on_time_marking_rate=Decimal("0"),
            average_marking_delay_minutes=Decimal("0"),
            corrections_made=0,
            accuracy_rate=Decimal("0"),
            leaves_processed=0,
            average_leave_approval_time_hours=Decimal("0"),
        )

        maintenance_perf = MaintenancePerformance(
            requests_created=m.maintenance_requests_created,
            requests_completed=m.maintenance_requests_completed,
            requests_pending=m.maintenance_requests_created - m.maintenance_requests_completed,
            requests_by_category={},
            average_completion_time_hours=m.avg_maintenance_completion_time_hours,
            total_maintenance_cost=Decimal("0"),
            average_cost_per_request=Decimal("0"),
            within_budget_rate=Decimal("0"),
            preventive_tasks_completed=0,
            preventive_compliance_rate=Decimal("0"),
        )

        return PerformanceReport(
            supervisor_id=supervisor_id,
            supervisor_name=sup_name,
            hostel_name=hostel_name,
            report_period=period,
            generated_at=self._now(),
            summary=metrics,
            complaint_performance=complaint_perf,
            attendance_performance=attendance_perf,
            maintenance_performance=maintenance_perf,
            performance_trends=[],
            comparison_with_peers=None,
            comparison_with_previous_period=None,
            strengths=[],
            areas_for_improvement=[],
            recommendations=[],
        )

# --- File: D:\hostel-management-saas\app\services\supervisor\supervisor_permissions_service.py ---
# app/services/supervisor/supervisor_permissions_service.py
from __future__ import annotations

from decimal import Decimal
from typing import Callable, Dict, Any
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import SupervisorRepository
from app.schemas.supervisor import (
    SupervisorPermissions,
    PermissionUpdate,
    PermissionCheckRequest,
    PermissionCheckResponse,
)
from app.services.common import UnitOfWork, errors


class SupervisorPermissionsService:
    """
    Supervisor permission management:

    - Get/set permissions (stored on core_supervisor.permissions JSON)
    - Evaluate a simple permission check, including threshold-based checks
      (e.g., maintenance_approval_threshold).
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    # Internal helpers
    def _load_permissions(self, sup) -> SupervisorPermissions:
        """
        Merge stored JSON permissions onto SupervisorPermissions defaults.
        """
        stored = sup.permissions or {}
        base = SupervisorPermissions()
        data = base.model_dump()
        data.update(stored)
        return SupervisorPermissions.model_validate(data)

    # Public API
    def get_permissions(self, supervisor_id: UUID) -> SupervisorPermissions:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            sup = sup_repo.get(supervisor_id)
            if sup is None:
                raise errors.NotFoundError(f"Supervisor {supervisor_id} not found")
            return self._load_permissions(sup)

    def update_permissions(
        self,
        supervisor_id: UUID,
        data: PermissionUpdate,
    ) -> SupervisorPermissions:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            sup = sup_repo.get(supervisor_id)
            if sup is None:
                raise errors.NotFoundError(f"Supervisor {supervisor_id} not found")

            current = sup.permissions or {}
            current.update(data.permissions)
            sup.permissions = current  # type: ignore[attr-defined]
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            return self._load_permissions(sup)

    def check_permission(self, req: PermissionCheckRequest) -> PermissionCheckResponse:
        perms = self.get_permissions(req.supervisor_id)
        data = perms.model_dump()

        key = req.permission_key
        ctx = req.context or {}
        has_perm = False
        requires_approval = False
        threshold_exceeded = False
        threshold_value: Decimal | None = None
        actual_value: Decimal | None = None
        message = ""

        if key not in data and key != "maintenance_approval_threshold":
            return PermissionCheckResponse(
                supervisor_id=req.supervisor_id,
                permission_key=key,
                has_permission=False,
                requires_approval=False,
                threshold_exceeded=False,
                message="Unknown permission key",
                threshold_value=None,
                actual_value=None,
            )

        if key == "maintenance_approval_threshold":
            # Threshold-based check
            threshold_value = Decimal(str(data.get("maintenance_approval_threshold", "0")))
            amount = ctx.get("amount")
            if amount is not None:
                actual_value = Decimal(str(amount))
                threshold_exceeded = actual_value > threshold_value
                has_perm = True
                requires_approval = threshold_exceeded
                message = (
                    "Amount exceeds supervisor approval threshold; admin approval required."
                    if threshold_exceeded
                    else "Within supervisor approval threshold."
                )
            else:
                has_perm = True
                message = "Threshold value retrieved."
        else:
            val = data.get(key)
            if isinstance(val, bool):
                has_perm = val
                message = "Permission granted." if val else "Permission denied."
            else:
                has_perm = bool(val)

        return PermissionCheckResponse(
            supervisor_id=req.supervisor_id,
            permission_key=key,
            has_permission=has_perm,
            requires_approval=requires_approval,
            threshold_exceeded=threshold_exceeded,
            message=message,
            threshold_value=threshold_value,
            actual_value=actual_value,
        )

# --- File: D:\hostel-management-saas\app\services\supervisor\supervisor_service.py ---
# app/services/supervisor/supervisor_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import (
    SupervisorRepository,
    UserRepository,
    HostelRepository,
)
from app.schemas.common.enums import SupervisorStatus, EmploymentType
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.supervisor import (
    SupervisorCreate,
    SupervisorUpdate,
    SupervisorResponse,
    SupervisorDetail,
    SupervisorListItem,
)
from app.services.common import UnitOfWork, errors


class SupervisorService:
    """
    Core supervisor service:

    - Create/update supervisors
    - Get supervisor detail
    - List supervisors for a hostel
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # Helpers
    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # Mapping
    def _to_response(
        self,
        s,
        *,
        user,
        hostel_name: str,
        assigned_by: UUID,
        assigned_date: datetime,
    ) -> SupervisorResponse:
        return SupervisorResponse(
            id=s.id,
            created_at=s.created_at,
            updated_at=s.updated_at,
            user_id=s.user_id,
            full_name=user.full_name,
            email=user.email,
            phone=getattr(user, "phone", ""),
            assigned_hostel_id=s.hostel_id,
            hostel_name=hostel_name,
            employee_id=s.employee_id,
            join_date=s.join_date,
            employment_type=s.employment_type,
            status=s.status,
            is_active=s.is_active,
            assigned_by=assigned_by,
            assigned_date=assigned_date.date(),
        )

    def _to_detail(
        self,
        s,
        *,
        user,
        hostel_name: str,
        assigned_by: UUID,
        assigned_by_name: str,
        assigned_date: datetime,
    ) -> SupervisorDetail:
        return SupervisorDetail(
            id=s.id,
            created_at=s.created_at,
            updated_at=s.updated_at,
            user_id=user.id,
            full_name=user.full_name,
            email=user.email,
            phone=getattr(user, "phone", ""),
            profile_image_url=getattr(user, "profile_image_url", None),
            assigned_hostel_id=s.hostel_id,
            hostel_name=hostel_name,
            assigned_by=assigned_by,
            assigned_by_name=assigned_by_name,
            assigned_date=assigned_date.date(),
            employee_id=s.employee_id,
            join_date=s.join_date,
            employment_type=s.employment_type,
            shift_timing=s.shift_timing,
            status=s.status,
            is_active=s.is_active,
            termination_date=None,
            termination_reason=None,
            permissions=s.permissions or {},
            total_complaints_resolved=0,
            average_resolution_time_hours=Decimal("0"),
            last_performance_review=None,
            performance_rating=None,
            last_login=None,
            total_logins=0,
        )

    def _to_list_item(
        self,
        s,
        *,
        user,
        hostel_name: str,
    ) -> SupervisorListItem:
        return SupervisorListItem(
            id=s.id,
            user_id=user.id,
            full_name=user.full_name,
            email=user.email,
            phone=getattr(user, "phone", ""),
            hostel_name=hostel_name,
            employee_id=s.employee_id,
            employment_type=s.employment_type,
            status=s.status,
            is_active=s.is_active,
            join_date=s.join_date,
            performance_rating=None,
        )

    # CRUD
    def create_supervisor(self, data: SupervisorCreate) -> SupervisorDetail:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            user = user_repo.get(data.user_id)
            if user is None:
                raise errors.NotFoundError(f"User {data.user_id} not found")

            hostel = hostel_repo.get(data.assigned_hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.assigned_hostel_id} not found")

            payload = {
                "user_id": data.user_id,
                "hostel_id": data.assigned_hostel_id,
                "employee_id": data.employee_id,
                "join_date": data.join_date,
                "employment_type": data.employment_type,
                "shift_timing": data.shift_timing,
                "status": SupervisorStatus.ACTIVE,
                "is_active": True,
                "permissions": data.permissions or {},
            }
            s = sup_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            assigned_by_user = user_repo.get(data.assigned_by)
            assigned_by_name = assigned_by_user.full_name if assigned_by_user else ""
            assigned_date = datetime.combine(data.join_date, datetime.min.time())

            return self._to_detail(
                s,
                user=user,
                hostel_name=hostel.name,
                assigned_by=data.assigned_by,
                assigned_by_name=assigned_by_name,
                assigned_date=assigned_date,
            )

    def update_supervisor(self, supervisor_id: UUID, data: SupervisorUpdate) -> SupervisorDetail:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            s = sup_repo.get(supervisor_id)
            if s is None:
                raise errors.NotFoundError(f"Supervisor {supervisor_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(s, field) and field != "id":
                    setattr(s, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            user = user_repo.get(s.user_id)
            hostel = hostel_repo.get(s.hostel_id)
            uow.commit()

            assigned_by = UUID(int=0)
            assigned_by_name = ""
            assigned_date = datetime.combine(s.join_date, datetime.min.time())

            return self._to_detail(
                s,
                user=user,
                hostel_name=hostel.name if hostel else "",
                assigned_by=assigned_by,
                assigned_by_name=assigned_by_name,
                assigned_date=assigned_date,
            )

    def get_supervisor(self, supervisor_id: UUID) -> SupervisorDetail:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            s = sup_repo.get(supervisor_id)
            if s is None:
                raise errors.NotFoundError(f"Supervisor {supervisor_id} not found")

            user = user_repo.get(s.user_id)
            hostel = hostel_repo.get(s.hostel_id)
            assigned_by = UUID(int=0)
            assigned_by_name = ""
            assigned_date = datetime.combine(s.join_date, datetime.min.time())

            return self._to_detail(
                s,
                user=user,
                hostel_name=hostel.name if hostel else "",
                assigned_by=assigned_by,
                assigned_by_name=assigned_by_name,
                assigned_date=assigned_date,
            )

    # Listing
    def list_supervisors_for_hostel(
        self,
        hostel_id: UUID,
        params: PaginationParams,
        *,
        status: Optional[SupervisorStatus] = None,
    ) -> PaginatedResponse[SupervisorListItem]:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            supervisors = sup_repo.list_for_hostel(hostel_id, status=status)
            hostel = hostel_repo.get(hostel_id)
            hostel_name = hostel.name if hostel else ""

            items: List[SupervisorListItem] = []
            for s in supervisors:
                user = user_repo.get(s.user_id)
                if not user:
                    continue
                items.append(self._to_list_item(s, user=user, hostel_name=hostel_name))

            total = len(items)
            start = params.offset
            end = start + params.limit
            page_items = items[start:end]

            return PaginatedResponse[SupervisorListItem].create(
                items=page_items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

# --- File: D:\hostel-management-saas\app\services\supervisor\__init__.py ---
# app/services/supervisor/__init__.py
"""
Supervisor-related services.

- SupervisorService:
    Core CRUD, listing, and detail for supervisors.

- SupervisorAssignmentService:
    Assign / revoke supervisors to hostels (multi-hostel support).

- SupervisorPermissionsService:
    Manage supervisor permissions and perform permission checks.

- SupervisorDashboardService:
    Supervisor dashboard aggregation (complaints, maintenance, attendance, etc.).

- SupervisorPerformanceService:
    Performance metrics & reports based on analytics tables.

- SupervisorActivityService:
    Activity log listing, details, and summaries for supervisors.
"""

from .supervisor_service import SupervisorService
from .supervisor_assignment_service import SupervisorAssignmentService
from .supervisor_permissions_service import SupervisorPermissionsService
from .supervisor_dashboard_service import SupervisorDashboardService
from .supervisor_performance_service import SupervisorPerformanceService
from .supervisor_activity_service import SupervisorActivityService

__all__ = [
    "SupervisorService",
    "SupervisorAssignmentService",
    "SupervisorPermissionsService",
    "SupervisorDashboardService",
    "SupervisorPerformanceService",
    "SupervisorActivityService",
]


# ===== Folder: D:\hostel-management-saas\app\services\system =====

# --- File: D:\hostel-management-saas\app\services\system\feature_flag_service.py ---


# --- File: D:\hostel-management-saas\app\services\system\notification_config_service.py ---


# --- File: D:\hostel-management-saas\app\services\system\platform_config_service.py ---


# --- File: D:\hostel-management-saas\app\services\system\system_settings_service.py ---


# --- File: D:\hostel-management-saas\app\services\system\__init__.py ---



# ===== Folder: D:\hostel-management-saas\app\services\users =====

# --- File: D:\hostel-management-saas\app\services\users\user_activity_service.py ---
# app/services/users/user_activity_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.audit import UserActivityRepository
from app.schemas.audit import UserActivityLog  # if you have such a schema; otherwise adjust
from app.services.common import UnitOfWork, errors


class UserActivityService:
    """
    Lightweight user activity logger:

    - log_login
    - log_logout
    - log_password_change
    - log_custom_activity

    Backed by audit_user_activity via UserActivityRepository.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # Helpers
    def _get_repo(self, uow: UnitOfWork) -> UserActivityRepository:
        return uow.get_repo(UserActivityRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Logging helpers
    # ------------------------------------------------------------------ #
    def log_login(
        self,
        *,
        user_id: UUID,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> None:
        self._log(
            user_id=user_id,
            activity_type="login",
            description="User logged in",
            ip_address=ip_address,
            user_agent=user_agent,
        )

    def log_logout(
        self,
        *,
        user_id: UUID,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> None:
        self._log(
            user_id=user_id,
            activity_type="logout",
            description="User logged out",
            ip_address=ip_address,
            user_agent=user_agent,
        )

    def log_password_change(
        self,
        *,
        user_id: UUID,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> None:
        self._log(
            user_id=user_id,
            activity_type="password_change",
            description="User changed password",
            ip_address=ip_address,
            user_agent=user_agent,
        )

    def log_custom(
        self,
        *,
        user_id: UUID,
        activity_type: str,
        description: Optional[str] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> None:
        self._log(
            user_id=user_id,
            activity_type=activity_type,
            description=description or activity_type,
            ip_address=ip_address,
            user_agent=user_agent,
        )

    # Internal
    def _log(
        self,
        *,
        user_id: UUID,
        activity_type: str,
        description: Optional[str],
        ip_address: Optional[str],
        user_agent: Optional[str],
    ) -> None:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            record = {
                "user_id": user_id,
                "activity_type": activity_type,
                "description": description,
                "ip_address": ip_address,
                "user_agent": user_agent,
            }
            repo.create(record)  # type: ignore[arg-type]
            uow.commit()

# --- File: D:\hostel-management-saas\app\services\users\user_profile_service.py ---
# app/services/users/user_profile_service.py
from __future__ import annotations

from datetime import datetime
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import UserRepository
from app.schemas.user.user_profile import (
    ProfileUpdate,
    ProfileImageUpdate,
    ContactInfoUpdate,
)
from app.schemas.user import UserDetail
from app.services.common import UnitOfWork, errors
from .user_service import UserService


class UserProfileService:
    """
    User profile management:

    - Update basic profile fields (name, gender, DOB, address).
    - Update contact info & emergency details.
    - Update profile image.

    Note:
    - Underlying core_user model currently has only base fields; address/
      emergency fields are applied only if/when they exist on the model.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory
        self._user_service = UserService(session_factory)

    # Helpers
    def _get_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Profile
    # ------------------------------------------------------------------ #
    def update_profile(self, user_id: UUID, data: ProfileUpdate) -> UserDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            user = repo.get(user_id)
            if user is None:
                raise errors.NotFoundError(f"User {user_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(user, field) and field != "id":
                    setattr(user, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return self._user_service.get_user(user_id)

    def update_profile_image(self, user_id: UUID, data: ProfileImageUpdate) -> UserDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            user = repo.get(user_id)
            if user is None:
                raise errors.NotFoundError(f"User {user_id} not found")

            user.profile_image_url = str(data.profile_image_url)  # type: ignore[attr-defined]
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return self._user_service.get_user(user_id)

    def update_contact_info(self, user_id: UUID, data: ContactInfoUpdate) -> UserDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            user = repo.get(user_id)
            if user is None:
                raise errors.NotFoundError(f"User {user_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(user, field) and field != "id":
                    setattr(user, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return self._user_service.get_user(user_id)

# --- File: D:\hostel-management-saas\app\services\users\user_service.py ---
# app/services/users/user_service.py
from __future__ import annotations

from datetime import datetime
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import UserRepository
from app.schemas.common.enums import UserRole
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.user import (
    UserCreate,
    UserUpdate,
    UserResponse,
    UserDetail,
    UserListItem,
)
from app.services.common import UnitOfWork, security, errors


class UserService:
    """
    Core user service (core_user):

    - Create users (admin-side; registration has its own service).
    - Update users.
    - Get user detail.
    - List/search users.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Mapping
    # ------------------------------------------------------------------ #
    def _to_response(self, u) -> UserResponse:
        return UserResponse(
            id=u.id,
            created_at=u.created_at,
            updated_at=u.updated_at,
            email=u.email,
            phone=u.phone,
            full_name=u.full_name,
            user_role=u.user_role,
            is_active=u.is_active,
            is_email_verified=u.is_email_verified,
            is_phone_verified=u.is_phone_verified,
            profile_image_url=getattr(u, "profile_image_url", None),
            last_login_at=u.last_login_at,
        )

    def _to_detail(self, u) -> UserDetail:
        # Address/emergency fields are not on core_user by default; use getattr.
        return UserDetail(
            id=u.id,
            created_at=u.created_at,
            updated_at=u.updated_at,
            email=u.email,
            phone=u.phone,
            full_name=u.full_name,
            user_role=u.user_role,
            gender=getattr(u, "gender", None),
            date_of_birth=getattr(u, "date_of_birth", None),
            profile_image_url=getattr(u, "profile_image_url", None),
            address_line1=getattr(u, "address_line1", None),
            address_line2=getattr(u, "address_line2", None),
            city=getattr(u, "city", None),
            state=getattr(u, "state", None),
            country=getattr(u, "country", None),
            pincode=getattr(u, "pincode", None),
            emergency_contact_name=getattr(u, "emergency_contact_name", None),
            emergency_contact_phone=getattr(u, "emergency_contact_phone", None),
            emergency_contact_relation=getattr(u, "emergency_contact_relation", None),
            is_active=u.is_active,
            is_email_verified=u.is_email_verified,
            is_phone_verified=u.is_phone_verified,
            email_verified_at=getattr(u, "email_verified_at", None),
            phone_verified_at=getattr(u, "phone_verified_at", None),
            last_login_at=u.last_login_at,
        )

    def _to_list_item(self, u) -> UserListItem:
        return UserListItem(
            id=u.id,
            email=u.email,
            full_name=u.full_name,
            user_role=u.user_role,
            is_active=u.is_active,
            profile_image_url=getattr(u, "profile_image_url", None),
            created_at=u.created_at,
        )

    # ------------------------------------------------------------------ #
    # CRUD
    # ------------------------------------------------------------------ #
    def create_user(self, data: UserCreate) -> UserDetail:
        """
        Admin-driven user creation.

        Note:
        - For self-registration, use RegistrationService instead.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            if repo.get_by_email(data.email):
                raise errors.ConflictError(f"User with email {data.email!r} already exists")
            if repo.get_by_phone(data.phone):
                raise errors.ConflictError(f"User with phone {data.phone!r} already exists")

            hashed_pwd = security.hash_password(data.password)

            payload = {
                "email": data.email,
                "phone": data.phone,
                "full_name": data.full_name,
                "user_role": data.user_role,
                "gender": data.gender,
                "date_of_birth": data.date_of_birth,
                "profile_image_url": data.profile_image_url,
                "is_active": True,
                "is_email_verified": False,
                "is_phone_verified": False,
                "password_hash": hashed_pwd,
            }
            u = repo.create(payload)  # type: ignore[arg-type]
            uow.commit()
            return self._to_detail(u)

    def update_user(self, user_id: UUID, data: UserUpdate) -> UserDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            u = repo.get(user_id)
            if u is None:
                raise errors.NotFoundError(f"User {user_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(u, field) and field != "id":
                    setattr(u, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return self._to_detail(u)

    def get_user(self, user_id: UUID) -> UserDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            u = repo.get(user_id)
            if u is None:
                raise errors.NotFoundError(f"User {user_id} not found")
            return self._to_detail(u)

    # ------------------------------------------------------------------ #
    # Listing & search
    # ------------------------------------------------------------------ #
    def list_users(
        self,
        params: PaginationParams,
        *,
        role: Optional[UserRole] = None,
        is_active: Optional[bool] = None,
        search: Optional[str] = None,
    ) -> PaginatedResponse[UserListItem]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)

            filters: Dict[str, object] = {}
            if role:
                filters["user_role"] = role
            if is_active is not None:
                filters["is_active"] = is_active

            records: Sequence = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

            if search:
                q = search.lower()
                def _match(u) -> bool:
                    return (
                        q in (u.full_name or "").lower()
                        or q in (u.email or "").lower()
                        or q in (u.phone or "").lower()
                    )
                records = [u for u in records if _match(u)]

            # sort by created_at desc
            sorted_records = sorted(records, key=lambda u: u.created_at, reverse=True)

            start = params.offset
            end = start + params.limit
            page_users = sorted_records[start:end]

            items = [self._to_list_item(u) for u in page_users]

            return PaginatedResponse[UserListItem].create(
                items=items,
                total_items=len(sorted_records),
                page=params.page,
                page_size=params.page_size,
            )

# --- File: D:\hostel-management-saas\app\services\users\__init__.py ---
# app/services/users/__init__.py
"""
User-facing services.

- UserService:
    Core CRUD, listing, and detail for users (core_user).

- UserProfileService:
    Profile/contact/image updates and simple document-like extensions.

- UserActivityService:
    Lightweight activity logging (logins, password changes, etc.).
"""

from .user_service import UserService
from .user_profile_service import UserProfileService
from .user_activity_service import UserActivityService

__all__ = [
    "UserService",
    "UserProfileService",
    "UserActivityService",
]


# ===== Folder: D:\hostel-management-saas\app\services\visitor =====

# --- File: D:\hostel-management-saas\app\services\visitor\favorites_service.py ---
# app/services/visitor/favorites_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository
from app.repositories.associations import UserHostelRepository
from app.repositories.visitor import VisitorRepository
from app.schemas.visitor.visitor_favorites import (
    FavoriteRequest,
    FavoritesList,
    FavoriteHostelItem,
    FavoriteUpdate,
)
from app.services.common import UnitOfWork, errors


class FavoritesService:
    """
    Visitor favorites/wishlist management.

    Implementation:

    - Uses assoc_user_hostel as backing store with association_type="favorite".
    - FavoriteHostelItem.favorite_id is assoc_user_hostel.id.
    - Extra metadata (notes, price_when_saved, times_viewed, etc.) is stored in
      UserHostel.metadata_json.
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
    ) -> None:
        self._session_factory = session_factory

    # Helpers
    def _get_visitor_repo(self, uow: UnitOfWork) -> VisitorRepository:
        return uow.get_repo(VisitorRepository)

    def _get_assoc_repo(self, uow: UnitOfWork) -> UserHostelRepository:
        return uow.get_repo(UserHostelRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Set favorite
    # ------------------------------------------------------------------ #
    def set_favorite(
        self,
        user_id: UUID,
        data: FavoriteRequest,
    ) -> None:
        """
        Add or remove a hostel from a user's favorites.

        - If is_favorite=True: upsert assoc_user_hostel.
        - If is_favorite=False: soft-delete assoc_user_hostel rows.
        """
        with UnitOfWork(self._session_factory) as uow:
            assoc_repo = self._get_assoc_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            existing = assoc_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={
                    "user_id": user_id,
                    "hostel_id": data.hostel_id,
                    "association_type": "favorite",
                },
            )

            if data.is_favorite:
                if existing:
                    assoc = existing[0]
                    meta = assoc.metadata_json or {}
                    meta["notes"] = data.notes
                    meta.setdefault("price_when_saved", str(hostel.starting_price_monthly or Decimal("0")))
                    assoc.metadata_json = meta  # type: ignore[attr-defined]
                    uow.session.flush()  # type: ignore[union-attr]
                else:
                    meta = {
                        "notes": data.notes,
                        "price_when_saved": str(hostel.starting_price_monthly or Decimal("0")),
                        "times_viewed": 0,
                        "last_viewed": None,
                    }
                    assoc_repo.create(
                        {
                            "user_id": user_id,
                            "hostel_id": data.hostel_id,
                            "association_type": "favorite",
                            "metadata_json": meta,
                        }
                    )
            else:
                for a in existing:
                    assoc_repo.delete(a)

            uow.commit()

    # ------------------------------------------------------------------ #
    # List favorites
    # ------------------------------------------------------------------ #
    def get_favorites(self, user_id: UUID) -> FavoritesList:
        with UnitOfWork(self._session_factory) as uow:
            assoc_repo = self._get_assoc_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            visitor_repo = self._get_visitor_repo(uow)

            visitor = visitor_repo.get_by_user_id(user_id)
            if visitor is None:
                raise errors.NotFoundError(f"Visitor profile for user {user_id} not found")

            assocs = assoc_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={
                    "user_id": user_id,
                    "association_type": "favorite",
                },
            )

            items: List[FavoriteHostelItem] = []
            now = self._now()

            for a in assocs:
                hostel = hostel_repo.get(a.hostel_id)
                if not hostel:
                    continue

                starting_price = hostel.starting_price_monthly or Decimal("0")
                current_price = starting_price

                meta = a.metadata_json or {}
                notes = meta.get("notes")
                price_when_saved = Decimal(str(meta.get("price_when_saved", starting_price)))
                times_viewed = int(meta.get("times_viewed", 0))
                last_viewed = meta.get("last_viewed")

                has_price_drop = current_price < price_when_saved
                drop_pct: Optional[Decimal] = None
                if has_price_drop and price_when_saved > 0:
                    drop_pct = (
                        (price_when_saved - current_price)
                        / price_when_saved
                        * Decimal("100")
                    )

                available_beds = max(
                    0, (hostel.total_beds or 0) - (hostel.occupied_beds or 0)
                )
                has_availability = available_beds > 0

                items.append(
                    FavoriteHostelItem(
                        favorite_id=a.id,
                        hostel_id=hostel.id,
                        hostel_name=hostel.name,
                        hostel_slug=hostel.slug,
                        hostel_city=hostel.city,
                        hostel_type=hostel.hostel_type.value
                        if hasattr(hostel.hostel_type, "value")
                        else str(hostel.hostel_type),
                        starting_price_monthly=starting_price,
                        price_when_saved=price_when_saved,
                        current_price=current_price,
                        has_price_drop=has_price_drop,
                        price_drop_percentage=drop_pct,
                        available_beds=available_beds,
                        has_availability=has_availability,
                        average_rating=Decimal(str(hostel.average_rating or 0.0)),
                        total_reviews=hostel.total_reviews or 0,
                        cover_image_url=hostel.cover_image_url,
                        notes=notes,
                        added_to_favorites=a.created_date
                        if getattr(a, "created_date", None)
                        else now.date(),
                        times_viewed=times_viewed,
                        last_viewed=last_viewed,
                    )
                )

        return FavoritesList(
            visitor_id=visitor.id,
            total_favorites=len(items),
            favorites=items,
        )

    # ------------------------------------------------------------------ #
    # Update favorite metadata (notes)
    # ------------------------------------------------------------------ #
    def update_favorite(self, user_id: UUID, data: FavoriteUpdate) -> None:
        with UnitOfWork(self._session_factory) as uow:
            assoc_repo = self._get_assoc_repo(uow)

            assoc = assoc_repo.get(data.favorite_id)
            if assoc is None or assoc.user_id != user_id:
                raise errors.NotFoundError("Favorite not found or not owned by user")

            meta = assoc.metadata_json or {}
            meta["notes"] = data.notes
            assoc.metadata_json = meta  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

# --- File: D:\hostel-management-saas\app\services\visitor\visitor_dashboard_service.py ---
# app/services/visitor/visitor_dashboard_service.py
from __future__ import annotations

from datetime import datetime, date
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.visitor import (
    VisitorRepository,
    HostelBookingRepository,
    VisitorBehaviorAnalyticsVisitorRepository,
)
from app.repositories.core import HostelRepository, UserRepository
from app.schemas.visitor.visitor_dashboard import (
    VisitorDashboard,
    SavedHostels,
    SavedHostelItem,
    BookingHistory,
    BookingHistoryItem,
    RecentSearch,
    RecentlyViewedHostel,
    RecommendedHostel,
    PriceDropAlert,
    AvailabilityAlert,
)
from app.services.common import UnitOfWork, errors


class VisitorDashboardService:
    """
    Visitor dashboard aggregation:

    - Saved hostels summary (from Visitor.favorite_hostel_ids + core_hostel).
    - Booking history from visitor_hostel_booking.
    - Simple behavior stats via VisitorBehaviorAnalytics.
    - Placeholders for searches, recommendations, and alerts.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # Helpers
    def _get_visitor_repo(self, uow: UnitOfWork) -> VisitorRepository:
        return uow.get_repo(VisitorRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_booking_repo(self, uow: UnitOfWork) -> HostelBookingRepository:
        return uow.get_repo(HostelBookingRepository)

    def _get_behavior_repo(self, uow: UnitOfWork) -> VisitorBehaviorAnalyticsVisitorRepository:
        return uow.get_repo(VisitorBehaviorAnalyticsVisitorRepository)

    def _today(self) -> date:
        return date.today()

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_dashboard(self, user_id: UUID) -> VisitorDashboard:
        now = self._now()

        with UnitOfWork(self._session_factory) as uow:
            visitor_repo = self._get_visitor_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            booking_repo = self._get_booking_repo(uow)
            behavior_repo = self._get_behavior_repo(uow)

            user = user_repo.get(user_id)
            if user is None:
                raise errors.NotFoundError(f"User {user_id} not found")

            v = visitor_repo.get_by_user_id(user_id)
            if v is None:
                raise errors.NotFoundError(f"Visitor profile for user {user_id} not found")

            # Saved hostels
            saved_ids = v.favorite_hostel_ids or []
            hostels = []
            for hid in saved_ids:
                h = hostel_repo.get(hid)
                if h:
                    hostels.append(h)

            saved_items: List[SavedHostelItem] = []
            for h in hostels:
                starting_price = h.starting_price_monthly or Decimal("0")
                avg_rating = Decimal(str(h.average_rating or 0.0))
                available_beds = max(0, (h.total_beds or 0) - (h.occupied_beds or 0))
                saved_items.append(
                    SavedHostelItem(
                        hostel_id=h.id,
                        hostel_name=h.name,
                        hostel_city=h.city,
                        starting_price=starting_price,
                        average_rating=avg_rating,
                        available_beds=available_beds,
                        cover_image_url=h.cover_image_url,
                        saved_at=now,
                        notes=None,
                        price_when_saved=starting_price,
                        current_price=starting_price,
                        price_changed=False,
                        price_change_percentage=None,
                    )
                )

            saved_hostels = SavedHostels(
                total_saved=len(saved_items),
                hostels=saved_items,
            )

            # Booking history
            bookings = booking_repo.list_for_visitor(v.id)
            bh_items: List[BookingHistoryItem] = []
            active = completed = cancelled = 0
            for b in sorted(bookings, key=lambda x: x.created_at, reverse=True):
                status_str = b.booking_status or ""
                status_lower = status_str.lower()
                if status_lower in {"pending", "confirmed", "checked_in"}:
                    active += 1
                elif status_lower in {"completed", "checked_out"}:
                    completed += 1
                elif status_lower == "cancelled":
                    cancelled += 1

                # naive duration parsing: expecting strings like "3 months"
                duration_months = 0
                if b.duration:
                    parts = b.duration.split()
                    if parts and parts[0].isdigit():
                        duration_months = int(parts[0])

                bh_items.append(
                    BookingHistoryItem(
                        booking_id=b.id,
                        booking_reference=str(b.id),
                        hostel_id=b.hostel_id,
                        hostel_name="",  # could be filled via HostelRepository if desired
                        room_type=b.room_type,
                        booking_date=b.created_at,
                        check_in_date=b.check_in_date,
                        duration_months=duration_months,
                        status=status_str,
                        total_amount=b.total_amount,
                        can_cancel=status_lower in {"pending", "confirmed"},
                        can_modify=status_lower in {"pending", "confirmed"},
                        can_review=status_lower in {"completed", "checked_out"},
                    )
                )

            booking_history = BookingHistory(
                total_bookings=len(bookings),
                active_bookings=active,
                completed_bookings=completed,
                cancelled_bookings=cancelled,
                bookings=bh_items,
            )

            # Behavior analytics
            behavior = behavior_repo.get_by_visitor_id(v.id)
            total_searches = behavior.total_searches if behavior else 0
            total_hostel_views = behavior.hostels_viewed if behavior else 0
            total_bookings = behavior.bookings_made if behavior else len(bookings)

        # Placeholders for sections not yet tracked
        recent_searches: List[RecentSearch] = []
        recently_viewed: List[RecentlyViewedHostel] = []
        recommended: List[RecommendedHostel] = []
        price_alerts: List[PriceDropAlert] = []
        availability_alerts: List[AvailabilityAlert] = []

        return VisitorDashboard(
            visitor_id=v.id,
            visitor_name=user.full_name,
            saved_hostels=saved_hostels,
            booking_history=booking_history,
            recent_searches=recent_searches,
            recently_viewed=recently_viewed,
            recommended_hostels=recommended,
            price_drop_alerts=price_alerts,
            availability_alerts=availability_alerts,
            total_searches=total_searches,
            total_hostel_views=total_hostel_views,
            total_bookings=total_bookings,
        )

# --- File: D:\hostel-management-saas\app\services\visitor\visitor_hostel_search_service.py ---
# app/services/visitor/visitor_hostel_search_service.py
from __future__ import annotations

from typing import Callable, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.visitor import VisitorHostelRepository, VisitorRepository
from app.schemas.visitor.visitor_preferences import SearchPreferences
from app.services.common import UnitOfWork, errors


class VisitorHostelSearchService:
    """
    Public hostel search facade using visitor_hostel (denormalized search index).

    - search_hostels: direct parameterized search over VisitorHostelRepository.
    - search_from_preferences: build a query based on a visitor's preferences.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # Helpers
    def _get_hostel_repo(self, uow: UnitOfWork) -> VisitorHostelRepository:
        return uow.get_repo(VisitorHostelRepository)

    def _get_visitor_repo(self, uow: UnitOfWork) -> VisitorRepository:
        return uow.get_repo(VisitorRepository)

    # ------------------------------------------------------------------ #
    # Direct search
    # ------------------------------------------------------------------ #
    def search_hostels(
        self,
        *,
        city: Optional[str] = None,
        area: Optional[str] = None,
        min_price: Optional[float] = None,
        max_price: Optional[float] = None,
        gender_type: Optional[str] = None,
        search: Optional[str] = None,
        limit: int = 50,
    ):
        """
        Directly delegate to VisitorHostelRepository.search.

        Returns:
            List[VisitorHostel] ORM instances.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_hostel_repo(uow)
            results = repo.search(
                city=city,
                area=area,
                min_price=min_price,
                max_price=max_price,
                gender_type=gender_type,
                search=search,
                limit=limit,
            )
        return results

    # ------------------------------------------------------------------ #
    # Search from preferences
    # ------------------------------------------------------------------ #
    def search_from_visitor_preferences(
        self,
        user_id: UUID,
        *,
        limit: int = 50,
    ):
        """
        Build a search query from a visitor's stored preferences:

        - city: first preferred city if any
        - min_price/max_price: budget_min/budget_max
        - other fields left to free-text 'search' or gender_type as provided by caller.
        """
        with UnitOfWork(self._session_factory) as uow:
            visitor_repo = self._get_visitor_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            v = visitor_repo.get_by_user_id(user_id)
            if v is None:
                raise errors.NotFoundError(f"Visitor profile for user {user_id} not found")

            city = v.preferred_cities[0] if v.preferred_cities else None
            min_price = float(v.budget_min) if v.budget_min is not None else None
            max_price = float(v.budget_max) if v.budget_max is not None else None

            results = hostel_repo.search(
                city=city,
                area=None,
                min_price=min_price,
                max_price=max_price,
                gender_type=None,
                search=None,
                limit=limit,
            )

        return results

# --- File: D:\hostel-management-saas\app\services\visitor\visitor_preferences_service.py ---
# app/services/visitor/visitor_preferences_service.py
from __future__ import annotations

from datetime import datetime
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.visitor import VisitorRepository
from app.repositories.core import UserRepository
from app.schemas.visitor.visitor_preferences import (
    VisitorPreferences,
    PreferenceUpdate,
)
from app.services.common import UnitOfWork, errors


class VisitorPreferencesService:
    """
    Visitor preferences management:

    - Map Visitor ORM to VisitorPreferences (with safe defaults).
    - Update preferences via PreferenceUpdate using overlapping fields.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # Helpers
    def _get_visitor_repo(self, uow: UnitOfWork) -> VisitorRepository:
        return uow.get_repo(VisitorRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # Internal mapping
    def _to_preferences(self, v) -> VisitorPreferences:
        return VisitorPreferences(
            preferred_room_type=v.preferred_room_type,
            preferred_hostel_type=None,
            budget_min=v.budget_min,
            budget_max=v.budget_max,
            preferred_cities=v.preferred_cities or [],
            preferred_areas=[],
            max_distance_from_work_km=None,
            required_amenities=v.preferred_amenities or [],
            preferred_amenities=v.preferred_amenities or [],
            need_parking=False,
            need_gym=False,
            need_laundry=False,
            need_mess=False,
            dietary_preference=None,
            earliest_move_in_date=None,
            preferred_lease_duration_months=None,
            email_notifications=v.email_notifications,
            sms_notifications=v.sms_notifications,
            push_notifications=v.push_notifications,
            notify_on_price_drop=True,
            notify_on_availability=True,
            notify_on_new_listings=True,
        )

    # Public API
    def get_preferences(self, user_id: UUID) -> VisitorPreferences:
        with UnitOfWork(self._session_factory) as uow:
            visitor_repo = self._get_visitor_repo(uow)

            v = visitor_repo.get_by_user_id(user_id)
            if v is None:
                raise errors.NotFoundError(f"Visitor profile for user {user_id} not found")

        return self._to_preferences(v)

    def update_preferences(
        self,
        user_id: UUID,
        data: PreferenceUpdate,
    ) -> VisitorPreferences:
        with UnitOfWork(self._session_factory) as uow:
            visitor_repo = self._get_visitor_repo(uow)

            v = visitor_repo.get_by_user_id(user_id)
            if v is None:
                raise errors.NotFoundError(f"Visitor profile for user {user_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            field_map = {
                "preferred_room_type": "preferred_room_type",
                "preferred_hostel_type": None,
                "budget_min": "budget_min",
                "budget_max": "budget_max",
                "preferred_cities": "preferred_cities",
                "required_amenities": "preferred_amenities",
                "dietary_preference": None,
                "email_notifications": "email_notifications",
                "sms_notifications": "sms_notifications",
                "push_notifications": "push_notifications",
                "notify_on_price_drop": None,
                "notify_on_availability": None,
                "notify_on_new_listings": None,
            }
            for key, value in mapping.items():
                target = field_map.get(key)
                if target and hasattr(v, target):
                    setattr(v, target, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

        return self._to_preferences(v)

# --- File: D:\hostel-management-saas\app\services\visitor\visitor_service.py ---
# app/services/visitor/visitor_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Callable, Optional, List
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.visitor import (
    VisitorRepository,
    HostelBookingRepository,
    HostelReviewRepository,
)
from app.repositories.core import UserRepository
from app.schemas.visitor import (
    VisitorUpdate,
    VisitorResponse,
    VisitorDetail,
)
from app.services.common import UnitOfWork, errors


class VisitorService:
    """
    Core Visitor service (public-side profile):

    - Get visitor detail (by user_id).
    - Lightweight summary for header/profile.
    - Update visitor preferences & notification flags.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_visitor_repo(self, uow: UnitOfWork) -> VisitorRepository:
        return uow.get_repo(VisitorRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_booking_repo(self, uow: UnitOfWork) -> HostelBookingRepository:
        return uow.get_repo(HostelBookingRepository)

    def _get_review_repo(self, uow: UnitOfWork) -> HostelReviewRepository:
        return uow.get_repo(HostelReviewRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # ------------------------------------------------------------------ #
    # Mapping
    # ------------------------------------------------------------------ #
    def _to_response(
        self,
        v,
        *,
        user,
        total_bookings: int,
        saved_hostels_count: int,
    ) -> VisitorResponse:
        return VisitorResponse(
            id=v.id,
            created_at=v.created_at,
            updated_at=v.updated_at,
            user_id=v.user_id,
            full_name=user.full_name,
            email=user.email,
            phone=getattr(user, "phone", ""),
            preferred_room_type=v.preferred_room_type,
            budget_min=v.budget_min,
            budget_max=v.budget_max,
            preferred_cities=v.preferred_cities or [],
            total_bookings=total_bookings,
            saved_hostels_count=saved_hostels_count,
            email_notifications=v.email_notifications,
            sms_notifications=v.sms_notifications,
            push_notifications=v.push_notifications,
        )

    def _to_detail(
        self,
        v,
        *,
        user,
        total_bookings: int,
        completed_bookings: int,
        cancelled_bookings: int,
        total_inquiries: int,
        total_reviews: int,
        avg_rating_given: Optional[Decimal],
    ) -> VisitorDetail:
        return VisitorDetail(
            id=v.id,
            created_at=v.created_at,
            updated_at=v.updated_at,
            user_id=v.user_id,
            full_name=user.full_name,
            email=user.email,
            phone=getattr(user, "phone", ""),
            profile_image_url=getattr(user, "profile_image_url", None),
            preferred_room_type=v.preferred_room_type,
            budget_min=v.budget_min,
            budget_max=v.budget_max,
            preferred_cities=v.preferred_cities or [],
            preferred_amenities=v.preferred_amenities or [],
            favorite_hostel_ids=v.favorite_hostel_ids or [],
            total_saved_hostels=len(v.favorite_hostel_ids or []),
            total_bookings=total_bookings,
            completed_bookings=completed_bookings,
            cancelled_bookings=cancelled_bookings,
            total_inquiries=total_inquiries,
            total_reviews_written=total_reviews,
            average_rating_given=avg_rating_given,
            email_notifications=v.email_notifications,
            sms_notifications=v.sms_notifications,
            push_notifications=v.push_notifications,
            last_login=user.last_login_at,
        )

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_visitor_detail(self, user_id: UUID) -> VisitorDetail:
        """
        Fetch detailed visitor profile by core_user.id.
        """
        with UnitOfWork(self._session_factory) as uow:
            visitor_repo = self._get_visitor_repo(uow)
            user_repo = self._get_user_repo(uow)
            booking_repo = self._get_booking_repo(uow)
            review_repo = self._get_review_repo(uow)

            user = user_repo.get(user_id)
            if user is None:
                raise errors.NotFoundError(f"User {user_id} not found")

            v = visitor_repo.get_by_user_id(user_id)
            if v is None:
                raise errors.NotFoundError(f"Visitor profile for user {user_id} not found")

            # Bookings
            bookings = booking_repo.list_for_visitor(v.id)
            total_bookings = len(bookings)
            completed_bookings = sum(
                1
                for b in bookings
                if (b.booking_status or "").lower() in {"completed", "checked_out"}
            )
            cancelled_bookings = sum(
                1 for b in bookings if (b.booking_status or "").lower() == "cancelled"
            )

            # Inquiries not directly modeled under visitor; placeholder
            total_inquiries = 0

            # Reviews
            reviews = review_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"visitor_id": v.id},
            )
            total_reviews = len(reviews)
            if total_reviews:
                total_rating = sum(
                    (Decimal(str(r.overall_rating)) for r in reviews), Decimal("0")
                )
                avg_rating_given: Optional[Decimal] = total_rating / Decimal(
                    str(total_reviews)
                )
            else:
                avg_rating_given = None

        return self._to_detail(
            v,
            user=user,
            total_bookings=total_bookings,
            completed_bookings=completed_bookings,
            cancelled_bookings=cancelled_bookings,
            total_inquiries=total_inquiries,
            total_reviews=total_reviews,
            avg_rating_given=avg_rating_given,
        )

    def update_visitor(
        self,
        user_id: UUID,
        data: VisitorUpdate,
    ) -> VisitorDetail:
        """
        Update visitor profile fields (preferences & notification flags).
        """
        with UnitOfWork(self._session_factory) as uow:
            visitor_repo = self._get_visitor_repo(uow)

            v = visitor_repo.get_by_user_id(user_id)
            if v is None:
                raise errors.NotFoundError(f"Visitor profile for user {user_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(v, field) and field != "id":
                    setattr(v, field, value)

            uow.session.flush()  # type: ignore[union-attr]

            # Reuse get_visitor_detail for full mapping
            uow.commit()

        return self.get_visitor_detail(user_id)

    def get_summary(self, user_id: UUID) -> VisitorResponse:
        """
        Lightweight summary for a visitor (e.g., for header/profile).
        """
        with UnitOfWork(self._session_factory) as uow:
            visitor_repo = self._get_visitor_repo(uow)
            user_repo = self._get_user_repo(uow)
            booking_repo = self._get_booking_repo(uow)

            user = user_repo.get(user_id)
            if user is None:
                raise errors.NotFoundError(f"User {user_id} not found")

            v = visitor_repo.get_by_user_id(user_id)
            if v is None:
                raise errors.NotFoundError(f"Visitor profile for user {user_id} not found")

            bookings = booking_repo.list_for_visitor(v.id)
            total_bookings = len(bookings)
            saved_hostels_count = len(v.favorite_hostel_ids or [])

        return self._to_response(
            v,
            user=user,
            total_bookings=total_bookings,
            saved_hostels_count=saved_hostels_count,
        )

# --- File: D:\hostel-management-saas\app\services\visitor\__init__.py ---
# app/services/visitor/__init__.py
"""
Visitor-facing services.

- VisitorService:
    Core profile retrieval and updates for Visitor (public side).

- VisitorDashboardService:
    Visitor dashboard aggregation (favorites, bookings, stats).

- FavoritesService:
    Manage favorites/wishlist for hostels.

- VisitorPreferencesService:
    Manage visitor preferences (budget, room type, notifications, etc.).

- VisitorHostelSearchService:
    Public hostel search facade (visitor_hostel).
"""

from .visitor_service import VisitorService
from .visitor_dashboard_service import VisitorDashboardService
from .favorites_service import FavoritesService
from .visitor_preferences_service import VisitorPreferencesService
from .visitor_hostel_search_service import VisitorHostelSearchService

__all__ = [
    "VisitorService",
    "VisitorDashboardService",
    "FavoritesService",
    "VisitorPreferencesService",
    "VisitorHostelSearchService",
]


# ===== Folder: D:\hostel-management-saas\app\services\workflows =====

# --- File: D:\hostel-management-saas\app\services\workflows\approval_workflow_service.py ---
# app/services/workflows/approval_workflow_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.workflows import ApprovalWorkflowRepository
from app.services.common import UnitOfWork


class ApprovalWorkflowService:
    """
    Wrapper over wf_approval table.

    Tracks approval workflow for entities that require explicit approval
    (announcements, menus, large maintenance jobs, etc.).
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> ApprovalWorkflowRepository:
        return uow.get_repo(ApprovalWorkflowRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    # ------------------------------------------------------------------ #
    # Creation / ensure
    # ------------------------------------------------------------------ #
    def ensure_workflow(
        self,
        *,
        entity_type: str,
        entity_id: UUID,
        requested_by_id: UUID,
        initial_status: str = "pending",
        reason: Optional[str] = None,
    ) -> None:
        """
        Ensure that there is an approval workflow row for this entity.

        - If one already exists, this is a no-op.
        - Otherwise, a new row is created in 'pending' (or given) status.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_for_entity(
                scope_type=entity_type,  # type: ignore[call-arg]
                scope_id=entity_id,      # type: ignore[call-arg]
            )
            # ^ The repository signature is (entity_type, entity_id); using keyword
            # arguments that match the underlying method is recommended. If your
            # repository method is named differently, adjust the call accordingly.

            # Fallback for direct call to get_for_entity(entity_type, entity_id)
            if wf is None:
                payload = {
                    "entity_type": entity_type,
                    "entity_id": entity_id,
                    "status": initial_status,
                    "requested_by_id": requested_by_id,
                    "reason": reason,
                    "requested_at": self._now(),
                    "approver_id": None,
                    "decided_at": None,
                    "decision_notes": None,
                }
                repo.create(payload)  # type: ignore[arg-type]
                uow.commit()

    # ------------------------------------------------------------------ #
    # Status updates
    # ------------------------------------------------------------------ #
    def set_status(
        self,
        *,
        entity_type: str,
        entity_id: UUID,
        status: str,
        approver_id: Optional[UUID] = None,
        decision_notes: Optional[str] = None,
    ) -> None:
        """
        Update approval status for an entity.

        - If workflow row does not exist, it is created with the provided status.
        - If status is 'approved' or 'rejected', decided_at is set.
        """
        now = self._now()
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_for_entity(
                scope_type=entity_type,  # type: ignore[call-arg]
                scope_id=entity_id,      # type: ignore[call-arg]
            )

            if wf is None:
                payload = {
                    "entity_type": entity_type,
                    "entity_id": entity_id,
                    "status": status,
                    "requested_by_id": approver_id,  # best-effort when missing
                    "requested_at": now,
                    "approver_id": approver_id,
                    "decided_at": now if status in {"approved", "rejected"} else None,
                    "reason": None,
                    "decision_notes": decision_notes,
                }
                repo.create(payload)  # type: ignore[arg-type]
            else:
                wf.status = status  # type: ignore[attr-defined]
                if approver_id is not None:
                    wf.approver_id = approver_id  # type: ignore[attr-defined]
                if status in {"approved", "rejected"}:
                    wf.decided_at = now  # type: ignore[attr-defined]
                if decision_notes is not None:
                    wf.decision_notes = decision_notes  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

# --- File: D:\hostel-management-saas\app\services\workflows\booking_workflow_service.py ---
# app/services/workflows/booking_workflow_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.workflows import BookingWorkflowRepository
from app.services.common import UnitOfWork


class BookingWorkflowService:
    """
    Wrapper over wf_booking table.

    Tracks current_status for a booking (pending, approved, rejected,
    checked_in, checked_out, etc.).
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> BookingWorkflowRepository:
        return uow.get_repo(BookingWorkflowRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def ensure_workflow(self, booking_id: UUID, initial_status: str) -> None:
        """
        Ensure that a workflow row exists for the given booking.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_booking_id(booking_id)
            if wf is None:
                payload = {
                    "booking_id": booking_id,
                    "current_status": initial_status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
                uow.commit()

    def set_status(self, booking_id: UUID, status: str) -> None:
        """
        Set (or create) workflow status for the booking.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_booking_id(booking_id)
            if wf is None:
                payload = {
                    "booking_id": booking_id,
                    "current_status": status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
            else:
                wf.current_status = status  # type: ignore[attr-defined]
                wf.last_updated_at = self._now()  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

# --- File: D:\hostel-management-saas\app\services\workflows\complaint_workflow_service.py ---
# app/services/workflows/complaint_workflow_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.workflows import ComplaintWorkflowRepository
from app.services.common import UnitOfWork


class ComplaintWorkflowService:
    """
    Lightweight wrapper over the wf_complaint table.

    Tracks a single workflow row per complaint with the current_status.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> ComplaintWorkflowRepository:
        return uow.get_repo(ComplaintWorkflowRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def ensure_workflow(self, complaint_id: UUID, initial_status: str) -> None:
        """
        Ensure there is a workflow row for this complaint.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_complaint_id(complaint_id)
            if wf is None:
                payload = {
                    "complaint_id": complaint_id,
                    "current_status": initial_status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
                uow.commit()

    def set_status(self, complaint_id: UUID, status: str) -> None:
        """
        Update workflow status for complaint.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_complaint_id(complaint_id)
            if wf is None:
                # Create if missing
                payload = {
                    "complaint_id": complaint_id,
                    "current_status": status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
            else:
                wf.current_status = status  # type: ignore[attr-defined]
                wf.last_updated_at = self._now()  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

# --- File: D:\hostel-management-saas\app\services\workflows\maintenance_workflow_service.py ---
# app/services/workflows/maintenance_workflow_service.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Callable
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.workflows import MaintenanceWorkflowRepository
from app.services.common import UnitOfWork


class MaintenanceWorkflowService:
    """
    Maintenance approval & execution workflow wrapper over wf_maintenance.

    Tracks current_status for a maintenance request:
    (pending_approval, approved, in_progress, completed, etc.).
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> MaintenanceWorkflowRepository:
        return uow.get_repo(MaintenanceWorkflowRepository)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def ensure_workflow(self, maintenance_id: UUID, initial_status: str) -> None:
        """
        Ensure there is a workflow row for this maintenance request.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_maintenance_id(maintenance_id)
            if wf is None:
                payload = {
                    "maintenance_id": maintenance_id,
                    "current_status": initial_status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
                uow.commit()

    def set_status(self, maintenance_id: UUID, status: str) -> None:
        """
        Update workflow status for a maintenance request.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            wf = repo.get_by_maintenance_id(maintenance_id)
            if wf is None:
                payload = {
                    "maintenance_id": maintenance_id,
                    "current_status": status,
                    "last_updated_at": self._now(),
                }
                repo.create(payload)  # type: ignore[arg-type]
            else:
                wf.current_status = status  # type: ignore[attr-defined]
                wf.last_updated_at = self._now()  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

# --- File: D:\hostel-management-saas\app\services\workflows\__init__.py ---
# app/services/workflows/__init__.py
"""
Workflow-related services.

Thin wrappers over wf_* workflow tables:

- ApprovalWorkflowService: generic approval workflow for entities.
- BookingWorkflowService: booking lifecycle workflow.
- ComplaintWorkflowService: complaint lifecycle workflow.
- MaintenanceWorkflowService: maintenance approval & execution workflow.
"""

from .approval_workflow_service import ApprovalWorkflowService
from .booking_workflow_service import BookingWorkflowService
from .complaint_workflow_service import ComplaintWorkflowService
from .maintenance_workflow_service import MaintenanceWorkflowService

__all__ = [
    "ApprovalWorkflowService",
    "BookingWorkflowService",
    "ComplaintWorkflowService",
    "MaintenanceWorkflowService",
]
