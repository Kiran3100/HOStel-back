### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\analytics ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\analytics =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\analytics\attendance_analytics_service.py ---
# app/services/analytics/complaint_analytics_service.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import ComplaintRepository
from app.repositories.core import HostelRepository
from app.schemas.analytics.complaint_analytics import (
    ComplaintKPI,
    ComplaintTrend,
    ComplaintTrendPoint,
    CategoryBreakdown,
    ComplaintDashboard,
)
from app.schemas.common.enums import ComplaintStatus, Priority
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class ComplaintAnalyticsService:
    """
    Dashboard-level complaint analytics using analytics.complaint_analytics schemas.

    For more detailed per-complaint analytics, see services/complaint.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_complaint_repo(self, uow: UnitOfWork) -> ComplaintRepository:
        return uow.get_repo(ComplaintRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    # ------------------------------------------------------------------ #
    # Dashboard
    # ------------------------------------------------------------------ #
    def get_dashboard_for_hostel(
        self,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> ComplaintDashboard:
        with UnitOfWork(self._session_factory) as uow:
            complaint_repo = self._get_complaint_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            hostel_name = hostel.name if hostel else ""

            complaints = complaint_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"hostel_id": hostel_id},
            )

        # Filter by opened_at within period
        start = period.start_date or date.min
        end = period.end_date or date.max

        filtered = []
        for c in complaints:
            opened_date = c.opened_at.date() if c.opened_at else None
            if opened_date is None:
                continue
            if opened_date < start or opened_date > end:
                continue
            filtered.append(c)

        total = len(filtered)
        open_count = resolved_count = closed_count = 0

        total_resolved_hours = 0.0
        resolved_with_time = 0
        sla_breached = 0

        # Category + priority aggregation
        category_counts: Dict[str, int] = {}
        total_resolution_time_by_cat: Dict[str, float] = {}
        priority_counts: Dict[str, int] = {}

        for c in filtered:
            if c.status == ComplaintStatus.OPEN:
                open_count += 1
            if c.status == ComplaintStatus.RESOLVED:
                resolved_count += 1
            if c.status == ComplaintStatus.CLOSED:
                closed_count += 1
            if c.sla_breach:
                sla_breached += 1

            cat_key = c.category.value if hasattr(c.category, "value") else str(c.category)
            category_counts[cat_key] = category_counts.get(cat_key, 0) + 1

            if c.priority in (Priority.URGENT, Priority.CRITICAL):
                prio_key = "urgent"
            else:
                prio_key = (c.priority.value if hasattr(c.priority, "value") else str(c.priority))
            priority_counts[prio_key] = priority_counts.get(prio_key, 0) + 1

            if c.resolved_at and c.opened_at:
                diff_hours = (c.resolved_at - c.opened_at).total_seconds() / 3600.0
                total_resolved_hours += diff_hours
                resolved_with_time += 1
                total_resolution_time_by_cat[cat_key] = total_resolution_time_by_cat.get(cat_key, 0.0) + diff_hours

        avg_resolution = (
            Decimal(str(total_resolved_hours / resolved_with_time))
            if resolved_with_time > 0
            else Decimal("0")
        )

        sla_compliance_rate = (
            Decimal(str((total - sla_breached) / total * 100)) if total > 0 else Decimal("0")
        )
        escalation_rate = Decimal("0")  # not tracked in Complaint model
        reopen_rate = Decimal("0")  # also not tracked here

        kpi = ComplaintKPI(
            hostel_id=hostel_id,
            hostel_name=hostel_name,
            total_complaints=total,
            open_complaints=open_count,
            resolved_complaints=resolved_count,
            closed_complaints=closed_count,
            average_resolution_time_hours=avg_resolution,
            sla_compliance_rate=sla_compliance_rate,
            escalation_rate=escalation_rate,
            reopen_rate=reopen_rate,
        )

        # Trend
        trend_by_date: Dict[str, Dict[str, int]] = {}
        for c in filtered:
            if not c.opened_at:
                continue
            d = c.opened_at.date().isoformat()
            bucket = trend_by_date.setdefault(
                d,
                {
                    "total": 0,
                    "open": 0,
                    "resolved": 0,
                    "escalated": 0,
                    "sla_breached": 0,
                },
            )
            bucket["total"] += 1
            if c.status == ComplaintStatus.OPEN:
                bucket["open"] += 1
            if c.status == ComplaintStatus.RESOLVED:
                bucket["resolved"] += 1
            # escalate / SLA not explicitly modeled; sla_breach used
            if c.sla_breach:
                bucket["sla_breached"] += 1

        points: List[ComplaintTrendPoint] = []
        for d, vals in sorted(trend_by_date.items()):
            points.append(
                ComplaintTrendPoint(
                    date=date.fromisoformat(d),
                    total_complaints=vals["total"],
                    open_complaints=vals["open"],
                    resolved_complaints=vals["resolved"],
                    escalated=vals["escalated"],
                    sla_breached=vals["sla_breached"],
                )
            )

        trend = ComplaintTrend(
            period=period,
            points=points,
        )

        # Category breakdown
        cat_breakdown: List[CategoryBreakdown] = []
        for cat, count in category_counts.items():
            pct = Decimal(str(count / total * 100)) if total > 0 else Decimal("0")
            avg_cat_res = Decimal(
                str(total_resolution_time_by_cat.get(cat, 0.0) / count if count > 0 else 0.0)
            )
            cat_breakdown.append(
                CategoryBreakdown(
                    category=cat,
                    count=count,
                    percentage_of_total=pct,
                    average_resolution_time_hours=avg_cat_res,
                )
            )

        return ComplaintDashboard(
            hostel_id=hostel_id,
            hostel_name=hostel_name,
            period=period,
            generated_at=datetime.utcnow(),
            kpi=kpi,
            trend=trend,
            by_category=cat_breakdown,
            by_priority=priority_counts,
        )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\analytics\complaint_analytics_service.py ---
# app/services/analytics/attendance_analytics_service.py
from __future__ import annotations

from datetime import date, datetime, timedelta
from typing import Callable, List, Dict, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.services import AttendanceRepository
from app.schemas.attendance.attendance_report import (
    AttendanceReport,
    AttendanceSummary,
    DailyAttendanceRecord,
    TrendAnalysis,
    WeeklyAttendance,
    MonthlyComparison,
)
from app.schemas.common.enums import AttendanceStatus
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class AttendanceAnalyticsService:
    """
    Attendance analytics from svc_attendance:

    - Student-level attendance report (summary + daily + trend)
    - Can be extended later for hostel-level analytics
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> AttendanceRepository:
        return uow.get_repo(AttendanceRepository)

    def _today(self) -> date:
        return date.today()

    # ------------------------------------------------------------------ #
    # Student-level report
    # ------------------------------------------------------------------ #
    def get_student_report(
        self,
        student_id: UUID,
        period: DateRangeFilter,
    ) -> AttendanceReport:
        """
        Build an AttendanceReport for a single student over a period.

        If period.start_date / end_date are omitted, defaults to last 30 days.
        """
        # Determine period bounds
        end = period.end_date or self._today()
        start = period.start_date or (end - timedelta(days=29))
        if start > end:
            start, end = end, start

        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            records = repo.list_for_student_range(student_id, start_date=start, end_date=end)

        # Index by date for easy lookup
        by_date: Dict[date, List] = {}
        for r in records:
            by_date.setdefault(r.attendance_date, []).append(r)

        total_days = (end - start).days + 1
        total_present = total_absent = total_late = total_on_leave = total_half_day = 0

        daily_records: List[DailyAttendanceRecord] = []

        cur = start
        while cur <= end:
            recs = by_date.get(cur, [])
            # If multiple records exist for same day (edge cases), pick the one
            # with latest check_in_time; otherwise the first.
            rec = None
            if recs:
                rec = sorted(
                    recs,
                    key=lambda x: (x.check_in_time or datetime.min.time()),
                    reverse=True,
                )[0]

            if rec is None:
                # No record; treat as ABSENT (or leave as None if you prefer)
                status_str = AttendanceStatus.ABSENT.value
                status_enum = AttendanceStatus.ABSENT
                is_late = False
                late_minutes = None
                notes = None
                check_in = None
                check_out = None
            else:
                status_enum = rec.status
                status_str = status_enum.value if hasattr(status_enum, "value") else str(status_enum)
                is_late = rec.is_late
                late_minutes = rec.late_minutes
                notes = rec.notes
                check_in = rec.check_in_time
                check_out = rec.check_out_time

            if status_enum == AttendanceStatus.PRESENT:
                total_present += 1
            elif status_enum == AttendanceStatus.ABSENT:
                total_absent += 1
            elif status_enum == AttendanceStatus.LATE:
                total_late += 1
            elif status_enum == AttendanceStatus.ON_LEAVE:
                total_on_leave += 1
            elif status_enum == AttendanceStatus.HALF_DAY:
                total_half_day += 1

            daily_records.append(
                DailyAttendanceRecord(
                    date=cur,
                    day_of_week=cur.strftime("%A"),
                    status=status_str,
                    check_in_time=check_in,
                    check_out_time=check_out,
                    is_late=is_late,
                    late_minutes=late_minutes,
                    notes=notes,
                )
            )
            cur += timedelta(days=1)

        attendance_percentage = (
            (Decimal(str(total_present + total_half_day * 0.5)) / Decimal(str(total_days)) * 100)
            if total_days > 0
            else Decimal("0")
        )
        late_percentage = (
            (Decimal(str(total_late)) / Decimal(str(total_days)) * 100)
            if total_days > 0
            else Decimal("0")
        )

        # Streaks (simple forward pass using daily_records)
        current_present_streak = 0
        longest_present_streak = 0
        current_absent_streak = 0

        for day in daily_records:
            if day.status in (
                AttendanceStatus.PRESENT.value,
                AttendanceStatus.LATE.value,
                AttendanceStatus.HALF_DAY.value,
            ):
                current_present_streak += 1
                longest_present_streak = max(longest_present_streak, current_present_streak)
                current_absent_streak = 0
            elif day.status == AttendanceStatus.ABSENT.value:
                current_absent_streak += 1
                current_present_streak = 0
            else:
                current_present_streak = 0
                current_absent_streak = 0

        # Attendance status classification
        if attendance_percentage >= Decimal("90"):
            status_label = "excellent"
        elif attendance_percentage >= Decimal("75"):
            status_label = "good"
        elif attendance_percentage >= Decimal("60"):
            status_label = "warning"
        else:
            status_label = "critical"

        summary = AttendanceSummary(
            total_days=total_days,
            total_present=total_present,
            total_absent=total_absent,
            total_late=total_late,
            total_on_leave=total_on_leave,
            total_half_day=total_half_day,
            attendance_percentage=attendance_percentage,
            late_percentage=late_percentage,
            current_present_streak=current_present_streak,
            longest_present_streak=longest_present_streak,
            current_absent_streak=current_absent_streak,
            attendance_status=status_label,
            meets_minimum_requirement=attendance_percentage >= Decimal("75"),
        )

        trend = self._build_trend_analysis(start, end, daily_records)

        return AttendanceReport(
            hostel_id=None,
            student_id=student_id,
            report_period=DateRangeFilter(start_date=start, end_date=end),
            generated_at=datetime.utcnow(),
            summary=summary,
            daily_records=daily_records,
            trend_analysis=trend,
        )

    # ------------------------------------------------------------------ #
    # Trend helpers
    # ------------------------------------------------------------------ #
    def _build_trend_analysis(
        self,
        start: date,
        end: date,
        daily_records: List[DailyAttendanceRecord],
    ) -> TrendAnalysis:
        # Weekly rollup
        weekly_map: Dict[int, Dict[str, int]] = {}
        for rec in daily_records:
            week_num = rec.date.isocalendar()[1]
            bucket = weekly_map.setdefault(
                week_num,
                {"start": rec.date, "end": rec.date, "present": 0, "absent": 0, "total": 0},
            )
            bucket["start"] = min(bucket["start"], rec.date)
            bucket["end"] = max(bucket["end"], rec.date)
            bucket["total"] += 1
            if rec.status in (
                AttendanceStatus.PRESENT.value,
                AttendanceStatus.LATE.value,
                AttendanceStatus.HALF_DAY.value,
            ):
                bucket["present"] += 1
            elif rec.status == AttendanceStatus.ABSENT.value:
                bucket["absent"] += 1

        weekly_attendance: List[WeeklyAttendance] = []
        for week, vals in sorted(weekly_map.items(), key=lambda kv: kv[0]):
            total = vals["total"] or 1
            pct = (Decimal(str(vals["present"])) / Decimal(str(total)) * 100)
            weekly_attendance.append(
                WeeklyAttendance(
                    week_number=week,
                    week_start_date=vals["start"],
                    week_end_date=vals["end"],
                    total_days=vals["total"],
                    present_days=vals["present"],
                    absent_days=vals["absent"],
                    attendance_percentage=pct,
                )
            )

        # Monthly comparison (simple: group by YYYY-MM)
        monthly_map: Dict[str, Dict[str, int]] = {}
        for rec in daily_records:
            key = rec.date.strftime("%Y-%m")
            bucket = monthly_map.setdefault(key, {"present": 0, "absent": 0, "total": 0})
            bucket["total"] += 1
            if rec.status in (
                AttendanceStatus.PRESENT.value,
                AttendanceStatus.LATE.value,
                AttendanceStatus.HALF_DAY.value,
            ):
                bucket["present"] += 1
            elif rec.status == AttendanceStatus.ABSENT.value:
                bucket["absent"] += 1

        monthly_comparison: List[MonthlyComparison] = []
        for month, vals in sorted(monthly_map.items()):
            total = vals["total"] or 1
            pct = Decimal(str(vals["present"])) / Decimal(str(total)) * 100
            monthly_comparison.append(
                MonthlyComparison(
                    month=month,
                    attendance_percentage=pct,
                    total_present=vals["present"],
                    total_absent=vals["absent"],
                )
            )

        # Simple trend direction based on first vs last month
        trend_direction = "stable"
        improvement_rate: Optional[Decimal] = None
        if len(monthly_comparison) >= 2:
            first = monthly_comparison[0].attendance_percentage
            last = monthly_comparison[-1].attendance_percentage
            if first > 0:
                change = (last - first) / first * 100
                improvement_rate = change
                if change > Decimal("5"):
                    trend_direction = "attendance_improving"
                elif change < Decimal("-5"):
                    trend_direction = "attendance_declining"
                else:
                    trend_direction = "attendance_stable"
            else:
                trend_direction = "attendance_stable"

        # Map into expected pattern (improving|declining|stable)
        mapped_trend = "stable"
        if trend_direction == "attendance_improving":
            mapped_trend = "improving"
        elif trend_direction == "attendance_declining":
            mapped_trend = "declining"

        return TrendAnalysis(
            period_start=start,
            period_end=end,
            weekly_attendance=weekly_attendance,
            monthly_comparison=monthly_comparison or None,
            most_absent_day=None,
            attendance_improving=(mapped_trend == "improving"),
            improvement_rate=improvement_rate,
        )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\analytics\custom_report_service.py ---
# app/services/analytics/custom_report_service.py
from __future__ import annotations

from datetime import date, datetime
from typing import Any, Callable, Dict, Iterable, List, Optional, Tuple, Type
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.base import BaseRepository
from app.repositories.transactions import PaymentRepository, BookingRepository
from app.repositories.services import ComplaintRepository, AttendanceRepository
from app.schemas.analytics.custom_reports import (
    CustomReportRequest,
    CustomReportDefinition,
    CustomReportResult,
    CustomReportField,
    CustomReportFilter,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class CustomReportService:
    """
    Very lightweight custom report builder.

    Supported modules (initially):
    - 'payments'  -> txn_payment via PaymentRepository
    - 'bookings'  -> txn_booking via BookingRepository
    - 'complaints'-> svc_complaint via ComplaintRepository
    - 'attendance'-> svc_attendance via AttendanceRepository

    NOTE:
    - This is intentionally conservative: it loads rows via repositories and
      applies filters/aggregations in Python. For large datasets, consider a
      dedicated reporting DB / ETL.
    """

    _MODULE_REPOS: Dict[str, Type[BaseRepository]] = {
        "payments": PaymentRepository,
        "bookings": BookingRepository,
        "complaints": ComplaintRepository,
        "attendance": AttendanceRepository,
    }

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def run_report(self, req: CustomReportRequest) -> CustomReportResult:
        """
        Execute a custom report request and return tabular data + summary.
        """
        module = req.module.lower()
        if module not in self._MODULE_REPOS:
            raise ValueError(f"Unsupported module {module!r} for custom reports")

        with UnitOfWork(self._session_factory) as uow:
            repo_cls = self._MODULE_REPOS[module]
            repo: BaseRepository = uow.get_repo(repo_cls)  # type: ignore[type-arg]

            # For simplicity, fetch all rows that match rough period filters via repo,
            # then refine in Python.
            base_filters: Dict[str, Any] = {}
            objs = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=base_filters or None,
            )

        # Apply time period filter (if any) on created_at where available
        objs = list(self._apply_period_filter(objs, req.period))

        # Apply custom filters in Python
        objs = list(self._apply_filters(objs, req.filters or []))

        # Map to rows (dict) according to fields
        rows: List[Dict[str, Any]] = self._build_rows(objs, req.fields)

        # Perform simple aggregations for summary
        summary = self._build_summary(rows, req.fields)

        return CustomReportResult(
            report_id=None,
            report_name=req.report_name,
            generated_at=datetime.utcnow(),
            rows=rows,
            total_rows=len(rows),
            summary=summary if req.include_summary else None,
            charts=None,  # Can be filled by higher-level code if needed
        )

    # ------------------------------------------------------------------ #
    # Internal helpers
    # ------------------------------------------------------------------ #
    def _apply_period_filter(
        self,
        objs: Iterable[Any],
        period: Optional[DateRangeFilter],
    ) -> Iterable[Any]:
        if not period or (not period.start_date and not period.end_date):
            return objs

        start = period.start_date or date.min
        end = period.end_date or date.max

        for obj in objs:
            created = getattr(obj, "created_at", None)
            if not created or not isinstance(created, datetime):
                yield obj  # if no created_at, keep it
                continue
            d = created.date()
            if d < start or d > end:
                continue
            yield obj

    def _apply_filters(
        self,
        objs: Iterable[Any],
        filters: List[CustomReportFilter],
    ) -> Iterable[Any]:
        def matches(obj: Any, f: CustomReportFilter) -> bool:
            val = getattr(obj, f.field_name, None)
            op = f.operator

            if op == "eq":
                return val == f.value
            if op == "ne":
                return val != f.value
            if op == "gt":
                return val is not None and val > f.value
            if op == "lt":
                return val is not None and val < f.value
            if op == "gte":
                return val is not None and val >= f.value
            if op == "lte":
                return val is not None and val <= f.value
            if op == "in":
                return isinstance(f.value, (list, tuple, set)) and val in f.value
            if op == "contains":
                return isinstance(val, str) and isinstance(f.value, str) and f.value.lower() in val.lower()
            if op == "between":
                if f.value is None or f.value_to is None:
                    return True
                return val is not None and f.value <= val <= f.value_to
            # Fallback: no-op
            return True

        for obj in objs:
            ok = True
            for f in filters:
                if not matches(obj, f):
                    ok = False
                    break
            if ok:
                yield obj

    def _build_rows(
        self,
        objs: Iterable[Any],
        fields: List[CustomReportField],
    ) -> List[Dict[str, Any]]:
        rows: List[Dict[str, Any]] = []
        for obj in objs:
            row: Dict[str, Any] = {}
            for field in fields:
                raw_val = getattr(obj, field.field_name, None)
                key = field.display_label or field.field_name
                row[key] = raw_val
            rows.append(row)
        return rows

    def _build_summary(
        self,
        rows: List[Dict[str, Any]],
        fields: List[CustomReportField],
    ) -> Dict[str, Any]:
        """
        Perform basic aggregations for fields that requested them.
        Supported aggregations: sum, avg, min, max, count.
        """
        summary: Dict[str, Any] = {}
        if not rows:
            return summary

        for f in fields:
            if not f.aggregation or f.aggregation == "none":
                continue
            key = f.display_label or f.field_name
            values = [r.get(key) for r in rows if isinstance(r.get(key), (int, float, Decimal))]
            if not values:
                continue

            agg_name = f.aggregation.lower()
            if agg_name == "sum":
                summary[key + "_sum"] = sum(values)
            elif agg_name == "avg":
                summary[key + "_avg"] = sum(values) / len(values)
            elif agg_name == "min":
                summary[key + "_min"] = min(values)
            elif agg_name == "max":
                summary[key + "_max"] = max(values)
            elif agg_name == "count":
                summary[key + "_count"] = len(values)

        return summary

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\analytics\dashboard_analytics_service.py ---
# app/services/analytics/dashboard_analytics_service.py
from __future__ import annotations

from datetime import datetime
from typing import Callable, List, Optional, Dict
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.analytics import DashboardMetricsRepository
from app.schemas.analytics.dashboard_analytics import (
    DashboardMetrics as DashboardMetricsSchema,
    QuickStats,
    KPIResponse,
    TimeseriesPoint,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class DashboardAnalyticsService:
    """
    DashboardMetrics service backed by analytics_dashboard_metrics table.

    - Fetch dashboard metrics for a scope (hostel|platform|admin)
    - If no exact period match, fall back to latest snapshot for scope
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> DashboardMetricsRepository:
        return uow.get_repo(DashboardMetricsRepository)

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_dashboard_metrics(
        self,
        *,
        scope_type: str,
        scope_id: Optional[UUID],
        period: Optional[DateRangeFilter] = None,
    ) -> Optional[DashboardMetricsSchema]:
        """
        Fetch DashboardMetrics for given scope+period, or latest if period not supplied.
        """
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            rec = None
            if period and period.start_date and period.end_date:
                rec = repo.get_for_scope_and_period(
                    scope_type=scope_type,
                    scope_id=scope_id,
                    period_start=period.start_date,
                    period_end=period.end_date,
                )
            if rec is None:
                rec = repo.get_latest_for_scope(scope_type=scope_type, scope_id=scope_id)
            if rec is None:
                return None

        # Map DB row -> QuickStats
        quick = QuickStats(
            total_hostels=rec.total_hostels,
            active_hostels=rec.active_hostels,
            total_students=rec.total_students,
            active_students=rec.active_students,
            total_visitors=rec.total_visitors,
            todays_check_ins=rec.todays_check_ins,
            todays_check_outs=rec.todays_check_outs,
            open_complaints=rec.open_complaints,
            pending_maintenance=rec.pending_maintenance,
            todays_revenue=rec.todays_revenue,
            monthly_revenue=rec.monthly_revenue,
            outstanding_payments=rec.outstanding_payments,
        )

        # Simple example KPIs: you can extend this with more meaningful KPIs
        kpis: List[KPIResponse] = [
            KPIResponse(
                name="Monthly Revenue",
                value=rec.monthly_revenue,
                unit="INR",
                trend_direction=None,
                trend_percentage=None,
                target_value=None,
                good_when="higher_is_better",
            ),
            KPIResponse(
                name="Occupancy (approx)",
                value=rec.active_students,
                unit="students",
                trend_direction=None,
                trend_percentage=None,
                target_value=None,
                good_when="higher_is_better",
            ),
        ]

        # No timeseries is stored in this snapshot table; return empty lists
        period_filter = DateRangeFilter(
            start_date=rec.period_start,
            end_date=rec.period_end,
        )

        return DashboardMetricsSchema(
            scope_type=scope_type,
            scope_id=scope_id,
            period=period_filter,
            generated_at=rec.generated_at,
            kpis=kpis,
            quick_stats=quick,
            revenue_timeseries=[],
            occupancy_timeseries=[],
            booking_timeseries=[],
            complaint_timeseries=[],
        )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\analytics\financial_analytics_service.py ---
# app/services/analytics/financial_analytics_service.py
from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.transactions import PaymentRepository
from app.repositories.services import MaintenanceRepository
from app.schemas.analytics.financial_analytics import (
    FinancialReport,
    RevenueBreakdown,
    ExpenseBreakdown,
    ProfitAndLossReport,
    CashflowSummary,
    CashflowPoint,
)
from app.schemas.common.enums import PaymentStatus, PaymentType
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class FinancialAnalyticsService:
    """
    Basic financial analytics using txn_payment and svc_maintenance:

    - Revenue breakdown by type/payment_type
    - Maintenance expenses as primary expense category
    - Simple P&L and cashflow summary
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _get_maintenance_repo(self, uow: UnitOfWork) -> MaintenanceRepository:
        return uow.get_repo(MaintenanceRepository)

    def _today(self) -> date:
        return date.today()

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_financial_report(
        self,
        *,
        scope_type: str,          # 'hostel' or 'platform'
        scope_id: Optional[UUID],
        period: DateRangeFilter,
    ) -> FinancialReport:
        """
        Compute a FinancialReport for a hostel or platform over a period.

        For 'platform' scope, aggregates across all hostels.
        """
        with UnitOfWork(self._session_factory) as uow:
            pay_repo = self._get_payment_repo(uow)
            maint_repo = self._get_maintenance_repo(uow)

            pay_filters: Dict[str, object] = {}
            maint_filters: Dict[str, object] = {}
            if scope_type == "hostel" and scope_id:
                pay_filters["hostel_id"] = scope_id
                maint_filters["hostel_id"] = scope_id

            payments = pay_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=pay_filters or None,
            )
            maints = maint_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=maint_filters or None,
            )

        start = period.start_date or date.min
        end = period.end_date or date.max

        # Revenue: COMPLETED payments with paid_at in [start,end]
        payments_in_period = []
        for p in payments:
            if p.payment_status != PaymentStatus.COMPLETED or not p.paid_at:
                continue
            d = p.paid_at.date()
            if d < start or d > end:
                continue
            payments_in_period.append(p)

        # Revenue breakdown by PaymentType
        booking_revenue = rent_revenue = mess_revenue = other_revenue = Decimal("0")
        revenue_by_type: Dict[str, Decimal] = {}

        for p in payments_in_period:
            if p.payment_type == PaymentType.BOOKING_ADVANCE:
                booking_revenue += p.amount
            elif p.payment_type == PaymentType.RENT:
                rent_revenue += p.amount
            elif p.payment_type == PaymentType.MESS_CHARGES:
                mess_revenue += p.amount
            else:
                other_revenue += p.amount

            key = p.payment_type.value if hasattr(p.payment_type, "value") else str(p.payment_type)
            revenue_by_type[key] = revenue_by_type.get(key, Decimal("0")) + p.amount

        total_revenue = booking_revenue + rent_revenue + mess_revenue + other_revenue

        revenue_breakdown = RevenueBreakdown(
            total_revenue=total_revenue,
            booking_revenue=booking_revenue,
            rent_revenue=rent_revenue,
            mess_revenue=mess_revenue,
            other_revenue=other_revenue,
            revenue_by_hostel={},  # not broken down here
            revenue_by_payment_type={k: v for k, v in revenue_by_type.items()},
        )

        # Expenses from Maintenance.actual_cost
        expenses_in_period = []
        for m in maints:
            if not m.actual_completion_date or not m.actual_cost:
                continue
            d = m.actual_completion_date
            if d < start or d > end:
                continue
            expenses_in_period.append(m)

        maintenance_expenses = Decimal("0")
        expenses_by_category: Dict[str, Decimal] = {}
        for m in expenses_in_period:
            maintenance_expenses += m.actual_cost or Decimal("0")
            cat = m.category.value if hasattr(m.category, "value") else str(m.category)
            expenses_by_category[cat] = expenses_by_category.get(cat, Decimal("0")) + (m.actual_cost or Decimal("0"))

        total_expenses = maintenance_expenses  # others set to 0 here

        expense_breakdown = ExpenseBreakdown(
            total_expenses=total_expenses,
            maintenance_expenses=maintenance_expenses,
            staff_expenses=Decimal("0"),
            utility_expenses=Decimal("0"),
            other_expenses=Decimal("0"),
            expenses_by_hostel={},     # not broken down
            expenses_by_category=expenses_by_category,
        )

        gross_profit = total_revenue - total_expenses
        net_profit = gross_profit  # no tax/other adjustments modeled
        profit_margin = (
            (net_profit / total_revenue * 100) if total_revenue > 0 else Decimal("0")
        )

        pnl = ProfitAndLossReport(
            scope_type=scope_type,
            scope_id=scope_id,
            period=period,
            generated_at=datetime.utcnow(),
            revenue=revenue_breakdown,
            expenses=expense_breakdown,
            gross_profit=gross_profit,
            net_profit=net_profit,
            profit_margin_percentage=profit_margin,
        )

        # Cashflow summary: simple inflow(outflow) per day
        inflows = total_revenue
        outflows = total_expenses
        opening_balance = Decimal("0")
        closing_balance = opening_balance + inflows - outflows

        # Daily timeseries
        daily_in: Dict[date, Decimal] = {}
        daily_out: Dict[date, Decimal] = {}

        for p in payments_in_period:
            d = p.paid_at.date()
            daily_in[d] = daily_in.get(d, Decimal("0")) + p.amount

        for m in expenses_in_period:
            d = m.actual_completion_date
            daily_out[d] = daily_out.get(d, Decimal("0")) + (m.actual_cost or Decimal("0"))

        cashflow_points: List[CashflowPoint] = []
        cur = start
        while cur <= end:
            inflow = daily_in.get(cur, Decimal("0"))
            outflow = daily_out.get(cur, Decimal("0"))
            cashflow_points.append(
                CashflowPoint(
                    date=cur,
                    inflow=inflow,
                    outflow=outflow,
                    net_flow=inflow - outflow,
                )
            )
            cur += timedelta(days=1)

        cashflow = CashflowSummary(
            scope_type=scope_type,
            scope_id=scope_id,
            period=period,
            generated_at=datetime.utcnow(),
            opening_balance=opening_balance,
            closing_balance=closing_balance,
            inflows=inflows,
            outflows=outflows,
            inflow_breakdown={"payments": inflows},
            outflow_breakdown={"maintenance": outflows},
            cashflow_timeseries=cashflow_points,
        )

        # Ratios (very basic)
        # For collection_rate we compare completed vs all payments in period (created_at)
        # Re-load payments for the period on created_at
        total_billed = Decimal("0")
        total_billed_completed = Decimal("0")
        for p in payments:
            d = p.created_at.date()
            if d < start or d > end:
                continue
            total_billed += p.amount
            if p.payment_status == PaymentStatus.COMPLETED:
                total_billed_completed += p.amount

        collection_rate = (
            (total_billed_completed / total_billed * 100) if total_billed > 0 else Decimal("0")
        )
        overdue_ratio = Decimal("0")  # could be computed from pending+due_date < today

        financial_report = FinancialReport(
            scope_type=scope_type,
            scope_id=scope_id,
            period=period,
            generated_at=datetime.utcnow(),
            pnl_report=pnl,
            cashflow=cashflow,
            collection_rate=collection_rate,
            overdue_ratio=overdue_ratio,
            avg_revenue_per_student=Decimal("0"),
            avg_revenue_per_bed=Decimal("0"),
        )
        return financial_report

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\analytics\occupancy_analytics_service.py ---
# app/services/analytics/occupancy_analytics_service.py
from __future__ import annotations

from datetime import date, datetime, timedelta
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository, RoomRepository, StudentRepository
from app.schemas.analytics.occupancy_analytics import (
    OccupancyReport,
    OccupancyKPI,
    OccupancyTrendPoint,
    ForecastData,
    ForecastPoint,
    OccupancyByRoomType,
)
from app.schemas.common.enums import RoomType
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class OccupancyAnalyticsService:
    """
    Occupancy analytics based on core_hostel, core_room, core_student:

    - Daily occupancy trend for a hostel
    - Breakdown by room type
    - Simple KPI metrics
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_occupancy_report(
        self,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> OccupancyReport:
        with UnitOfWork(self._session_factory) as uow:
            hostel_repo = self._get_hostel_repo(uow)
            room_repo = self._get_room_repo(uow)
            student_repo = self._get_student_repo(uow)

            hostel = hostel_repo.get(hostel_id)
            if hostel is None:
                raise ValueError(f"Hostel {hostel_id} not found")

            rooms = room_repo.list_for_hostel(hostel_id=hostel_id, only_available=False, room_type=None)
            students = student_repo.list_for_hostel(hostel_id, status=None)

        start = period.start_date or date.today()
        end = period.end_date or start

        # Current capacity & occupancy from hostel snapshot
        total_beds = hostel.total_beds or 0
        occupied_beds = hostel.occupied_beds or 0
        available_beds = max(0, total_beds - occupied_beds)
        current_occ_pct = (
            Decimal(str(occupied_beds / total_beds * 100)) if total_beds > 0 else Decimal("0")
        )

        # Daily trend: compute occupancy from student stay dates
        daily_trend: List[OccupancyTrendPoint] = []
        agg_occupied = 0
        peak_occ_pct = Decimal("0")
        low_occ_pct = None

        cur = start
        while cur <= end:
            occ = self._occupied_beds_for_day(cur, students)
            pct = Decimal(str(occ / total_beds * 100)) if total_beds > 0 else Decimal("0")

            daily_trend.append(
                OccupancyTrendPoint(
                    date=cur,
                    occupancy_percentage=pct,
                    occupied_beds=occ,
                    total_beds=total_beds,
                )
            )
            agg_occupied += occ
            peak_occ_pct = max(peak_occ_pct, pct)
            if low_occ_pct is None or pct < low_occ_pct:
                low_occ_pct = pct
            cur += timedelta(days=1)

        days = (end - start).days + 1
        avg_occ_pct = (
            Decimal(str(agg_occupied / days / total_beds * 100)) if days > 0 and total_beds > 0 else Decimal("0")
        )
        low_occ_pct = low_occ_pct or Decimal("0")

        kpi = OccupancyKPI(
            hostel_id=hostel_id,
            hostel_name=hostel.name,
            current_occupancy_percentage=current_occ_pct,
            average_occupancy_percentage=avg_occ_pct,
            peak_occupancy_percentage=peak_occ_pct,
            low_occupancy_percentage=low_occ_pct,
            total_beds=total_beds,
            occupied_beds=occupied_beds,
            available_beds=available_beds,
        )

        # By room type
        by_room_type: List[OccupancyByRoomType] = []
        room_type_totals: Dict[RoomType, int] = {}
        room_type_occupied: Dict[RoomType, int] = {}

        # Count beds per room type from Room.total_beds
        for r in rooms:
            rt = r.room_type
            room_type_totals[rt] = room_type_totals.get(rt, 0) + (r.total_beds or 0)

        # Count occupied per room type from current students
        room_id_to_type: Dict[UUID, RoomType] = {r.id: r.room_type for r in rooms}
        for s in students:
            if s.room_id and s.room_id in room_id_to_type:
                rt = room_id_to_type[s.room_id]
                room_type_occupied[rt] = room_type_occupied.get(rt, 0) + 1

        for rt, total_rt_beds in room_type_totals.items():
            occ_rt = room_type_occupied.get(rt, 0)
            pct_rt = (
                Decimal(str(occ_rt / total_rt_beds * 100)) if total_rt_beds > 0 else Decimal("0")
            )
            by_room_type.append(
                OccupancyByRoomType(
                    room_type=rt.value if hasattr(rt, "value") else str(rt),
                    total_beds=total_rt_beds,
                    occupied_beds=occ_rt,
                    occupancy_percentage=pct_rt,
                )
            )

        # By floor is optional; leaving empty dict for now
        report = OccupancyReport(
            hostel_id=hostel_id,
            hostel_name=hostel.name,
            period=DateRangeFilter(start_date=start, end_date=end),
            generated_at=datetime.utcnow(),
            kpi=kpi,
            daily_trend=daily_trend,
            by_room_type=by_room_type,
            by_floor={},
            forecast=None,  # can be added later
        )
        return report

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _occupied_beds_for_day(self, day: date, students: List[Any]) -> int:  # type: ignore[valid-type]
        """
        Count students whose stay includes the given day.
        """
        count = 0
        for s in students:
            # check_in_date <= day <= (actual_checkout_date or expected_checkout_date or "forever")
            cin = s.check_in_date
            if not cin:
                continue
            if cin > day:
                continue
            cout = s.actual_checkout_date or s.expected_checkout_date
            if cout and day > cout:
                continue
            count += 1
        return count

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\analytics\platform_analytics_service.py ---
# app/services/analytics/platform_analytics_service.py
from __future__ import annotations

from typing import Callable, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.analytics import (
    PlatformMetricsRepository,
    GrowthMetricsRepository,
    PlatformUsageAnalyticsRepository,
)
from app.schemas.analytics.platform_analytics import (
    PlatformMetrics as PlatformMetricsSchema,
    GrowthMetrics as GrowthMetricsSchema,
    PlatformUsageAnalytics as PlatformUsageAnalyticsSchema,
    MonthlyMetric,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork


class PlatformAnalyticsService:
    """
    Platform-wide analytics facade.

    Wraps analytics_platform_metrics, analytics_growth_metrics,
    and analytics_platform_usage tables into the corresponding schemas.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_platform_repo(self, uow: UnitOfWork) -> PlatformMetricsRepository:
        return uow.get_repo(PlatformMetricsRepository)

    def _get_growth_repo(self, uow: UnitOfWork) -> GrowthMetricsRepository:
        return uow.get_repo(GrowthMetricsRepository)

    def _get_usage_repo(self, uow: UnitOfWork) -> PlatformUsageAnalyticsRepository:
        return uow.get_repo(PlatformUsageAnalyticsRepository)

    # ------------------------------------------------------------------ #
    # Platform metrics
    # ------------------------------------------------------------------ #
    def get_latest_platform_metrics(self) -> Optional[PlatformMetricsSchema]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_platform_repo(uow)
            rec = repo.get_latest()
            if not rec:
                return None

        return PlatformMetricsSchema(
            period=DateRangeFilter(start_date=rec.period_start, end_date=rec.period_end),
            generated_at=rec.generated_at,
            total_hostels=rec.total_hostels,
            active_hostels=rec.active_hostels,
            hostels_on_trial=rec.hostels_on_trial,
            total_users=rec.total_users,
            total_students=rec.total_students,
            total_supervisors=rec.total_supervisors,
            total_admins=rec.total_admins,
            total_visitors=rec.total_visitors,
            avg_daily_active_users=rec.avg_daily_active_users,
            peak_concurrent_sessions=rec.peak_concurrent_sessions,
        )

    def get_growth_metrics(
        self,
        period: DateRangeFilter,
    ) -> Optional[GrowthMetricsSchema]:
        if not (period.start_date and period.end_date):
            return None

        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_growth_repo(uow)
            rec = repo.get_for_period(
                period_start=period.start_date,
                period_end=period.end_date,
            )
            if not rec:
                return None

        # monthly_* lists are not stored in the model; keep them empty for now.
        return GrowthMetricsSchema(
            period=period,
            new_hostels=rec.new_hostels,
            churned_hostels=rec.churned_hostels,
            net_hostel_growth=rec.net_hostel_growth,
            total_revenue=rec.total_revenue,
            revenue_growth_rate=rec.revenue_growth_rate,
            new_users=rec.new_users,
            user_growth_rate=rec.user_growth_rate,
            monthly_revenue=[],
            monthly_new_hostels=[],
            monthly_new_users=[],
        )

    def get_latest_usage_metrics(self) -> Optional[PlatformUsageAnalyticsSchema]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_usage_repo(uow)
            rec = repo.get_latest()
            if not rec:
                return None

        return PlatformUsageAnalyticsSchema(
            period=DateRangeFilter(start_date=rec.period_start, end_date=rec.period_end),
            generated_at=rec.generated_at,
            total_requests=rec.total_requests,
            avg_requests_per_minute=rec.avg_requests_per_minute,
            api_error_rate=rec.api_error_rate,
            requests_by_module={},
            avg_response_time_ms=rec.avg_response_time_ms,
            p95_response_time_ms=rec.p95_response_time_ms,
            p99_response_time_ms=rec.p99_response_time_ms,
            avg_cpu_usage_percent=None,
            avg_memory_usage_percent=None,
        )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\analytics\supervisor_analytics_service.py ---
# app/services/analytics/supervisor_analytics_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.analytics import SupervisorPerformanceMetricsRepository
from app.repositories.core import HostelRepository, SupervisorRepository
from app.schemas.analytics.supervisor_analytics import (
    SupervisorKPI,
    SupervisorDashboardAnalytics,
    SupervisorTrendPoint,
    SupervisorComparison,
)
from app.schemas.common.filters import DateRangeFilter
from app.services.common import UnitOfWork



class SupervisorAnalyticsService:
    """
    Supervisor performance analytics based on analytics_supervisor_performance.

    - Per-supervisor KPI & dashboard
    - Comparison between supervisors in a hostel or platform-wide
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_repo(self, uow: UnitOfWork) -> SupervisorPerformanceMetricsRepository:
        return uow.get_repo(SupervisorPerformanceMetricsRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    # ------------------------------------------------------------------ #
    # Individual dashboard
    # ------------------------------------------------------------------ #
    def get_dashboard(
        self,
        *,
        supervisor_id: UUID,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> Optional[SupervisorDashboardAnalytics]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            metrics = repo.get_for_supervisor_period(
                supervisor_id=supervisor_id,
                hostel_id=hostel_id,
                period_start=period.start_date,
                period_end=period.end_date,
            )
            if not metrics:
                return None

            sup = sup_repo.get(supervisor_id)
            hostel = hostel_repo.get(hostel_id)
            sup_name = sup.user.full_name if sup and getattr(sup, "user", None) else ""
            hostel_name = hostel.name if hostel else ""

            kpi = self._to_kpi(metrics, supervisor_name=sup_name, hostel_name=hostel_name, period=period)

            # Trend: for now, we only return a single point for this period.
            trend = [
                SupervisorTrendPoint(
                    period_label=f"{period.start_date}{period.end_date}",
                    complaints_resolved=metrics.complaints_resolved,
                    maintenance_completed=metrics.maintenance_requests_completed,
                    performance_score=metrics.overall_performance_score,
                )
            ]

            return SupervisorDashboardAnalytics(
                supervisor_id=supervisor_id,
                supervisor_name=sup_name,
                hostel_id=hostel_id,
                hostel_name=hostel_name,
                period=period,
                generated_at=datetime.utcnow(),
                kpi=kpi,
                trend=trend,
                complaints_by_category={},
                maintenance_by_category={},
            )

    # ------------------------------------------------------------------ #
    # Comparison
    # ------------------------------------------------------------------ #
    def get_comparison(
        self,
        *,
        scope_type: str,    # 'hostel' or 'platform'
        hostel_id: Optional[UUID],
        period: DateRangeFilter,
    ) -> SupervisorComparison:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            # Fetch all metrics for given period & scope
            filters: Dict[str, object] = {}
            if hostel_id:
                filters["hostel_id"] = hostel_id
            # BaseRepository.get_multi will apply equality filters
            metrics_list = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=filters or None,
            )

            # Filter by period_start/end in Python to be safe
            filtered = [
                m
                for m in metrics_list
                if (not period.start_date or m.period_start >= period.start_date)
                and (not period.end_date or m.period_end <= period.end_date)
            ]

            kpis: List[SupervisorKPI] = []
            score_by_supervisor: Dict[UUID, Decimal] = {}
            speed_by_supervisor: Dict[UUID, Decimal] = {}

            for m in filtered:
                sup = sup_repo.get(m.supervisor_id)
                hostel = hostel_repo.get(m.hostel_id)
                sup_name = sup.user.full_name if sup and getattr(sup, "user", None) else ""
                hostel_name = hostel.name if hostel else ""

                kpi = self._to_kpi(m, supervisor_name=sup_name, hostel_name=hostel_name, period=period)
                kpis.append(kpi)
                score_by_supervisor[m.supervisor_id] = kpi.overall_performance_score
                speed_by_supervisor[m.supervisor_id] = kpi.avg_complaint_resolution_time_hours

            # Rankings
            ranked_by_performance = sorted(
                score_by_supervisor, key=lambda sid: score_by_supervisor[sid], reverse=True
            )
            ranked_by_resolution_speed = sorted(
                speed_by_supervisor, key=lambda sid: speed_by_supervisor[sid]
            )
            ranked_by_feedback_score: List[UUID] = []  # feedback not yet wired

            return SupervisorComparison(
                scope_type=scope_type,
                hostel_id=hostel_id,
                period=period,
                generated_at=datetime.utcnow(),
                supervisors=kpis,
                ranked_by_performance=ranked_by_performance,
                ranked_by_resolution_speed=ranked_by_resolution_speed,
                ranked_by_feedback_score=ranked_by_feedback_score,
            )

    # ------------------------------------------------------------------ #
    # Mapping helper
    # ------------------------------------------------------------------ #
    def _to_kpi(
        self,
        m,
        *,
        supervisor_name: str,
        hostel_name: str,
        period: DateRangeFilter,
    ) -> SupervisorKPI:
        return SupervisorKPI(
            supervisor_id=m.supervisor_id,
            supervisor_name=supervisor_name,
            hostel_id=m.hostel_id,
            hostel_name=hostel_name,
            period=period,
            complaints_assigned=m.complaints_assigned,
            complaints_resolved=m.complaints_resolved,
            maintenance_requests_created=m.maintenance_requests_created,
            maintenance_requests_completed=m.maintenance_requests_completed,
            attendance_records_marked=m.attendance_records_marked,
            avg_complaint_resolution_time_hours=m.avg_complaint_resolution_time_hours,
            avg_maintenance_completion_time_hours=m.avg_maintenance_completion_time_hours,
            complaint_sla_compliance_rate=Decimal("0"),
            maintenance_sla_compliance_rate=Decimal("0"),
            student_feedback_score=None,
            overall_performance_score=m.overall_performance_score,
        )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\analytics\visitor_analytics_service.py ---
# app/services/analytics/visitor_analytics_service.py
from __future__ import annotations

from datetime import datetime, date
from decimal import Decimal
from typing import Callable, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.analytics import VisitorBehaviorAnalyticsRepository
from app.repositories.visitor import VisitorRepository
from app.schemas.visitor import VisitorStats
from app.services.common import UnitOfWork, errors


class VisitorAnalyticsService:
    """
    Visitor analytics service.
    
    Provides analytics and statistics for visitor behavior,
    search patterns, and conversion metrics.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_visitor_repo(self, uow: UnitOfWork) -> VisitorRepository:
        return uow.get_repo(VisitorRepository)

    def _get_analytics_repo(self, uow: UnitOfWork) -> VisitorBehaviorAnalyticsRepository:
        return uow.get_repo(VisitorBehaviorAnalyticsRepository)

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def get_visitor_stats(self, visitor_id: UUID) -> VisitorStats:
        """
        Get comprehensive statistics for a visitor.
        
        Args:
            visitor_id: Visitor UUID
            
        Returns:
            VisitorStats schema with all analytics data
        """
        with UnitOfWork(self._session_factory) as uow:
            visitor_repo = self._get_visitor_repo(uow)
            analytics_repo = self._get_analytics_repo(uow)

            # Get visitor
            visitor = visitor_repo.get(visitor_id)
            if visitor is None:
                raise errors.NotFoundError(f"Visitor {visitor_id} not found")

            # Get analytics data
            analytics = analytics_repo.get_by_visitor_id(visitor_id)

            if analytics is None:
                # Return empty stats if no analytics data exists
                return VisitorStats(
                    visitor_id=visitor_id,
                    total_searches=0,
                    unique_hostels_viewed=0,
                    average_search_filters_used=Decimal("0"),
                    total_hostel_views=0,
                    total_comparisons=0,
                    total_inquiries=0,
                    total_bookings=0,
                    booking_conversion_rate=Decimal("0"),
                    most_searched_city=None,
                    most_viewed_room_type=None,
                    average_budget=None,
                )

            # Calculate conversion rate
            conversion_rate = Decimal("0")
            if analytics.hostels_viewed > 0:
                conversion_rate = (
                    Decimal(str(analytics.bookings_made)) 
                    / Decimal(str(analytics.hostels_viewed)) 
                    * Decimal("100")
                ).quantize(Decimal("0.01"))

            # Calculate average search filters
            avg_filters = Decimal("0")
            if analytics.total_searches > 0:
                # This would need to be tracked separately in real implementation
                # For now, returning a placeholder
                avg_filters = Decimal("2.5")

            # Get most searched city
            most_searched_city = None
            if analytics.most_searched_locations:
                most_searched_city = analytics.most_searched_locations[0]

            # Parse preferred price range for average budget
            average_budget = None
            if analytics.preferred_price_range:
                try:
                    # Parse range like "5000-10000"
                    if "-" in analytics.preferred_price_range:
                        min_price, max_price = analytics.preferred_price_range.split("-")
                        average_budget = (
                            Decimal(min_price.strip()) + Decimal(max_price.strip())
                        ) / Decimal("2")
                except (ValueError, AttributeError):
                    pass

            return VisitorStats(
                visitor_id=visitor_id,
                total_searches=analytics.total_searches,
                unique_hostels_viewed=analytics.hostels_viewed,
                average_search_filters_used=avg_filters,
                total_hostel_views=analytics.total_page_views,
                total_comparisons=analytics.comparisons_made,
                total_inquiries=analytics.inquiries_sent,
                total_bookings=analytics.bookings_made,
                booking_conversion_rate=conversion_rate,
                most_searched_city=most_searched_city,
                most_viewed_room_type=None,  # Would need additional tracking
                average_budget=average_budget,
            )

    def get_visitor_stats_by_user_id(self, user_id: UUID) -> VisitorStats:
        """
        Get visitor statistics by user ID.
        
        Args:
            user_id: User UUID
            
        Returns:
            VisitorStats schema
        """
        with UnitOfWork(self._session_factory) as uow:
            visitor_repo = self._get_visitor_repo(uow)

            # Get visitor by user_id
            visitor = visitor_repo.get_by_user_id(user_id)
            if visitor is None:
                raise errors.NotFoundError(f"Visitor profile for user {user_id} not found")

        return self.get_visitor_stats(visitor.id)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\analytics\__init__.py ---
# app/services/analytics/__init__.py
"""
Analytics services package.

High-level analytics and reporting over core/service/transaction models:

- AttendanceAnalyticsService: student attendance reports & trends.
- ComplaintAnalyticsService: complaint KPIs and dashboard metrics.
- CustomReportService: generic, schema-driven custom reports.
- DashboardAnalyticsService: dashboard quick stats (hostel/platform/admin).
- FinancialAnalyticsService: revenue/expense, P&L, and cashflow.
- OccupancyAnalyticsService: hostel bed occupancy & trends.
- PlatformAnalyticsService: platform-wide metrics, growth, usage.
- SupervisorAnalyticsService: supervisor performance and comparisons.
"""

from .custom_report_service import CustomReportService
from .dashboard_analytics_service import DashboardAnalyticsService
from .financial_analytics_service import FinancialAnalyticsService
from .occupancy_analytics_service import OccupancyAnalyticsService
from .platform_analytics_service import PlatformAnalyticsService
from .supervisor_analytics_service import SupervisorAnalyticsService
from .visitor_analytics_service import VisitorAnalyticsService
from .attendance_analytics_service import AttendanceAnalyticsService

__all__ = [
    "CustomReportService",
    "DashboardAnalyticsService",
    "FinancialAnalyticsService",
    "OccupancyAnalyticsService",
    "PlatformAnalyticsService",
    "SupervisorAnalyticsService",
    "VisitorAnalyticsService",
    "AttendanceAnalyticsService",

]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\services\analytics\__pycache__ =====
