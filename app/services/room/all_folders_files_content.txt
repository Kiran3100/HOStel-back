### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\services\room ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\services\room =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\room\bed_assignment_service.py ---
# app/services/room/bed_assignment_service.py
from __future__ import annotations

from datetime import date
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import BedRepository, RoomRepository, StudentRepository, HostelRepository
from app.repositories.associations import StudentRoomAssignmentRepository
from app.schemas.room.bed_base import BedAssignmentRequest, BedReleaseRequest
from app.schemas.room.bed_response import (
    BedAssignment,
    BedHistory,
    BedAssignmentHistory,
)
from app.schemas.common.enums import BedStatus
from app.services.common import UnitOfWork, errors


class BedAssignmentService:
    """
    Bed assignment history service:

    - Assign bed to student (update Bed + Student + StudentRoomAssignment)
    - Release bed from student
    - Get bed history
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_assignment_repo(self, uow: UnitOfWork) -> StudentRoomAssignmentRepository:
        return uow.get_repo(StudentRoomAssignmentRepository)

    # ------------------------------------------------------------------ #
    # Assign
    # ------------------------------------------------------------------ #
    def assign_bed(self, req: BedAssignmentRequest) -> BedAssignment:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            room_repo = self._get_room_repo(uow)
            student_repo = self._get_student_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            assignment_repo = self._get_assignment_repo(uow)

            bed = bed_repo.get(req.bed_id)
            if bed is None:
                raise errors.NotFoundError(f"Bed {req.bed_id} not found")

            room = room_repo.get(bed.room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {bed.room_id} not found")

            hostel = hostel_repo.get(UUID(room.hostel_id) if isinstance(room.hostel_id, str) else room.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {room.hostel_id} not found")

            student = student_repo.get(req.student_id)
            if student is None or not getattr(student, "user", None):
                raise errors.NotFoundError(f"Student {req.student_id} not found")

            # Ensure bed is free
            if bed.current_student_id is not None:
                raise errors.ConflictError("Bed is already occupied")

            # Update bed
            bed.current_student_id = student.id  # type: ignore[attr-defined]
            bed.occupied_from = req.occupied_from  # type: ignore[attr-defined]
            bed.status = BedStatus.OCCUPIED  # type: ignore[attr-defined]

            # Update student
            student.room_id = room.id  # type: ignore[attr-defined]
            student.bed_id = bed.id  # type: ignore[attr-defined]

            # Create assignment history
            assignment_repo.create(
                {
                    "student_id": student.id,
                    "hostel_id": hostel.id,
                    "room_id": room.id,
                    "bed_id": bed.id,
                    "move_in_date": req.occupied_from,
                    "move_out_date": None,
                    "rent_amount": student.monthly_rent_amount,
                    "reason": None,
                }
            )

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            return BedAssignment(
                id=None,
                created_at=None,
                updated_at=None,
                bed_id=bed.id,
                room_id=room.id,
                room_number=room.room_number,
                bed_number=bed.bed_number,
                student_id=student.id,
                student_name=student.user.full_name,
                occupied_from=req.occupied_from,
                expected_vacate_date=None,
                monthly_rent=student.monthly_rent_amount,
            )

    # ------------------------------------------------------------------ #
    # Release
    # ------------------------------------------------------------------ #
    def release_bed(self, req: BedReleaseRequest) -> None:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            student_repo = self._get_student_repo(uow)
            assignment_repo = self._get_assignment_repo(uow)

            bed = bed_repo.get(req.bed_id)
            if bed is None:
                raise errors.NotFoundError(f"Bed {req.bed_id} not found")

            if bed.current_student_id is None:
                raise errors.ConflictError("Bed is not currently occupied")

            student = student_repo.get(bed.current_student_id)
            if student is None or not getattr(student, "user", None):
                raise errors.NotFoundError(f"Student {bed.current_student_id} not found")

            # Clear bed
            bed.current_student_id = None  # type: ignore[attr-defined]
            bed.occupied_from = None  # type: ignore[attr-defined]
            bed.status = BedStatus.AVAILABLE  # type: ignore[attr-defined]

            # Clear student bed assign (keep room_id if you want history)
            student.bed_id = None  # type: ignore[attr-defined]

            # Close active assignment
            active = assignment_repo.get_active_assignment(student.id)
            if active:
                active.move_out_date = req.release_date  # type: ignore[attr-defined]
                if req.reason:
                    active.reason = req.reason  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

    # ------------------------------------------------------------------ #
    # History
    # ------------------------------------------------------------------ #
    def get_bed_history(self, bed_id: UUID) -> BedHistory:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            room_repo = self._get_room_repo(uow)
            assignment_repo = self._get_assignment_repo(uow)
            student_repo = self._get_student_repo(uow)

            bed = bed_repo.get(bed_id)
            if bed is None:
                raise errors.NotFoundError(f"Bed {bed_id} not found")

            room = room_repo.get(bed.room_id)
            room_number = room.room_number if room else ""

            assignments = assignment_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"bed_id": bed_id},
            )

            history_items: List[BedAssignmentHistory] = []
            for a in assignments:
                st = student_repo.get(a.student_id)
                student_name = st.user.full_name if st and getattr(st, "user", None) else ""
                dur = None
                if a.move_out_date:
                    dur = (a.move_out_date - a.move_in_date).days
                history_items.append(
                    BedAssignmentHistory(
                        student_id=a.student_id,
                        student_name=student_name,
                        move_in_date=a.move_in_date,
                        move_out_date=a.move_out_date,
                        duration_days=dur,
                    )
                )

        return BedHistory(
            bed_id=bed_id,
            room_number=room_number,
            bed_number=bed.bed_number,
            assignments=history_items,
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\room\bed_service.py ---
# app/services/room/bed_service.py
from __future__ import annotations

from datetime import date
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import BedRepository, RoomRepository, StudentRepository
from app.schemas.room import (
    BedCreate,
    BedUpdate,
    BulkBedCreate,
    BedResponse,
)
from app.schemas.room.bed_response import BedAvailability
from app.schemas.common.enums import BedStatus
from app.services.common import UnitOfWork, errors


class BedService:
    """
    Bed lifecycle service:

    - Create/update beds (bulk & single)
    - Get bed detail
    - List beds for a room
    - Simple availability info
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    # ------------------------------------------------------------------ #
    # Mapping
    # ------------------------------------------------------------------ #
    def _to_bed_response(self, bed) -> BedResponse:
        return BedResponse(
            id=bed.id,
            created_at=bed.created_at,
            updated_at=bed.updated_at,
            room_id=bed.room_id,
            bed_number=bed.bed_number,
            is_occupied=bed.current_student_id is not None,
            status=bed.status,
            current_student_id=bed.current_student_id,
            occupied_from=bed.occupied_from,
        )

    # ------------------------------------------------------------------ #
    # CRUD
    # ------------------------------------------------------------------ #
    def create_bed(self, data: BedCreate) -> BedResponse:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            room_repo = self._get_room_repo(uow)

            room = room_repo.get(data.room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {data.room_id} not found")

            payload = data.model_dump(exclude_unset=True)
            bed = bed_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()
            return self._to_bed_response(bed)

    def bulk_create_beds(self, data: BulkBedCreate) -> List[BedResponse]:
        """
        Create a sequence of beds (e.g. B1..B4) for a given room.
        """
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            room_repo = self._get_room_repo(uow)

            room = room_repo.get(data.room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {data.room_id} not found")

            payloads = []
            for i in range(data.start_number, data.start_number + data.bed_count):
                bed_number = f"{data.bed_prefix}{i}"
                payloads.append(
                    {
                        "hostel_id": room.hostel_id,
                        "room_id": data.room_id,
                        "bed_number": bed_number,
                        "status": BedStatus.AVAILABLE,
                    }
                )
            beds = bed_repo.bulk_create(payloads)  # type: ignore[arg-type]
            uow.commit()
            return [self._to_bed_response(b) for b in beds]

    def update_bed(self, bed_id: UUID, data: BedUpdate) -> BedResponse:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)

            bed = bed_repo.get(bed_id)
            if bed is None:
                raise errors.NotFoundError(f"Bed {bed_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(bed, field) and field != "id":
                    setattr(bed, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()
            return self._to_bed_response(bed)

    def get_bed(self, bed_id: UUID) -> BedResponse:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            bed = bed_repo.get(bed_id)
            if bed is None:
                raise errors.NotFoundError(f"Bed {bed_id} not found")
            return self._to_bed_response(bed)

    # ------------------------------------------------------------------ #
    # Listing & availability
    # ------------------------------------------------------------------ #
    def list_beds_for_room(self, room_id: UUID) -> List[BedResponse]:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            beds = bed_repo.get_multi(filters={"room_id": room_id})
            return [self._to_bed_response(b) for b in beds]

    def list_available_beds_for_room(self, room_id: UUID) -> List[BedAvailability]:
        with UnitOfWork(self._session_factory) as uow:
            bed_repo = self._get_bed_repo(uow)
            room_repo = self._get_room_repo(uow)
            student_repo = self._get_student_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            beds = bed_repo.list_available_beds_for_room(room_id)

            avail: List[BedAvailability] = []
            for b in beds:
                student_name = None
                if b.current_student_id:
                    st = student_repo.get(b.current_student_id)
                    if st and getattr(st, "user", None):
                        student_name = st.user.full_name

                avail.append(
                    BedAvailability(
                        bed_id=b.id,
                        room_id=room_id,
                        room_number=room.room_number,
                        bed_number=b.bed_number,
                        is_available=b.current_student_id is None and b.status == BedStatus.AVAILABLE,
                        status=b.status,
                        available_from=b.occupied_from if b.current_student_id else date.today(),
                        current_student_name=student_name,
                    )
                )

            return avail

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\room\room_availability_service.py ---
# app/services/room/room_availability_service.py
from __future__ import annotations

from calendar import monthrange
from datetime import timedelta
from datetime import date as Date
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import RoomRepository, BedRepository, HostelRepository, StudentRepository
from app.schemas.room.room_availability import (
    RoomAvailabilityRequest,
    AvailabilityResponse,
    AvailableRoom,
    AvailabilityCalendar,
    DayAvailability,
    BookingInfo,
)
from app.schemas.common.enums import RoomType, BedStatus
from app.services.common import UnitOfWork, errors


class RoomAvailabilityService:
    """
    Room availability service (simplified):

    - Check current availability for a hostel/date/room_type.
    - Build a naive monthly availability calendar per room.

    NOTE:
    For accurate future occupancy, integrate with booking/schedule data.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _add_months(self, d: Date, months: int) -> Date:
        month = d.month - 1 + months
        year = d.year + month // 12
        month = month % 12 + 1
        day = min(
            d.day,
            monthrange(year, month)[1],
        )
        return Date(year, month, day)

    # ------------------------------------------------------------------ #
    # Availability
    # ------------------------------------------------------------------ #
    def check_availability(self, req: RoomAvailabilityRequest) -> AvailabilityResponse:
        """
        Compute availability for given hostel/date/room_type.

        This implementation uses current bed occupancy only (no future bookings).
        """
        check_in = req.check_in_date
        check_out = self._add_months(check_in, req.duration_months)

        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(req.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {req.hostel_id} not found")

            rooms = room_repo.list_for_hostel(
                hostel_id=req.hostel_id,
                only_available=True,
                room_type=req.room_type,
            )
            room_ids = [r.id for r in rooms]
            bed_map: Dict[UUID, List] = {rid: [] for rid in room_ids}
            all_beds = bed_repo.get_multi(filters={"room_id": room_ids}) if room_ids else []
            for b in all_beds:
                bed_map.setdefault(b.room_id, []).append(b)

        available_rooms: List[AvailableRoom] = []
        total_available_beds = 0

        for r in rooms:
            beds = bed_map.get(r.id, [])
            available_beds = sum(
                1 for b in beds
                if b.current_student_id is None and b.status == BedStatus.AVAILABLE
            )
            if available_beds <= 0:
                continue

            total_available_beds += available_beds

            available_rooms.append(
                AvailableRoom(
                    room_id=r.id,
                    room_number=r.room_number,
                    room_type=r.room_type,
                    floor_number=r.floor_number,
                    available_beds=available_beds,
                    total_beds=r.total_beds,
                    price_monthly=r.price_monthly,
                    is_ac=r.is_ac,
                    has_attached_bathroom=r.has_attached_bathroom,
                    amenities=r.amenities or [],
                    room_images=r.room_images or [],
                )
            )

        return AvailabilityResponse(
            hostel_id=req.hostel_id,
            check_in_date=check_in,
            check_out_date=check_out,
            available_rooms=available_rooms,
            total_available_beds=total_available_beds,
            has_availability=total_available_beds > 0,
        )

    # ------------------------------------------------------------------ #
    # Calendar
    # ------------------------------------------------------------------ #
    def get_availability_calendar(
        self,
        room_id: UUID,
        month: str,
    ) -> AvailabilityCalendar:
        """
        Naive availability calendar for a room.

        Assumes current occupancy is constant over the month (no bookings).
        """
        try:
            year, m = map(int, month.split("-"))
        except ValueError:
            raise errors.ValidationError("month must be in 'YYYY-MM' format")

        start = Date(year, m, 1)
        last_day = monthrange(year, m)[1]
        end = Date(year, m, last_day)

        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)
            student_repo = self._get_student_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            beds = bed_repo.get_multi(filters={"room_id": room.id})
            total_beds = room.total_beds
            available_beds = sum(
                1 for b in beds
                if b.current_student_id is None and b.status == BedStatus.AVAILABLE
            )

        # For now we assume occupancy static across the month.
        availability: Dict[str, DayAvailability] = {}
        cur = start
        while cur <= end:
            availability[cur.isoformat()] = DayAvailability(
                date=cur,
                available_beds=available_beds,
                total_beds=total_beds,
                is_available=available_beds > 0,
                bookings=[],  # no booking data wired yet
            )
            cur += timedelta(days=1)

        return AvailabilityCalendar(
            room_id=room.id,
            room_number=room.room_number,
            month=month,
            availability=availability,
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\room\room_service.py ---
# app/services/room/room_service.py
from __future__ import annotations

from decimal import Decimal
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import RoomRepository, BedRepository, HostelRepository, StudentRepository
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.room import (
    RoomCreate,
    RoomUpdate,
    BulkRoomCreate,
    RoomResponse,
    RoomDetail,
    RoomListItem,
    RoomWithBeds,
)
from app.schemas.room.room_response import BedDetail, RoomOccupancyStats
from app.schemas.common.enums import RoomType, RoomStatus, BedStatus
from app.services.common import UnitOfWork, errors


class RoomService:
    """
    Core room service:

    - Create / update rooms (bulk + single)
    - Get room detail with bed occupancy
    - List rooms for a hostel
    - Simple occupancy stats
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_room_repo(self, uow: UnitOfWork) -> RoomRepository:
        return uow.get_repo(RoomRepository)

    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    # ------------------------------------------------------------------ #
    # Mapping helpers
    # ------------------------------------------------------------------ #
    def _occupied_available(
        self,
        *,
        total_beds: int,
        beds: Sequence,
    ) -> tuple[int, int]:
        occupied = sum(1 for b in beds if b.current_student_id is not None)
        available = max(0, total_beds - occupied)
        return occupied, available

    def _to_room_response(
        self,
        room,
        *,
        occupied_beds: int,
        available_beds: int,
    ) -> RoomResponse:
        return RoomResponse(
            id=room.id,
            created_at=room.created_at,
            updated_at=room.updated_at,
            hostel_id=UUID(room.hostel_id) if isinstance(room.hostel_id, str) else room.hostel_id,
            room_number=room.room_number,
            floor_number=room.floor_number,
            wing=room.wing,
            room_type=room.room_type,
            total_beds=room.total_beds,
            occupied_beds=occupied_beds,
            available_beds=available_beds,
            price_monthly=room.price_monthly,
            is_ac=room.is_ac,
            has_attached_bathroom=room.has_attached_bathroom,
            status=room.status,
            is_available_for_booking=room.is_available_for_booking,
        )

    def _to_room_list_item(
        self,
        room,
        *,
        available_beds: int,
    ) -> RoomListItem:
        return RoomListItem(
            id=room.id,
            room_number=room.room_number,
            floor_number=room.floor_number,
            wing=room.wing,
            room_type=room.room_type,
            total_beds=room.total_beds,
            available_beds=available_beds,
            price_monthly=room.price_monthly,
            is_ac=room.is_ac,
            status=room.status,
            is_available_for_booking=room.is_available_for_booking,
        )

    def _to_bed_detail(self, bed, *, student_name: Optional[str]) -> BedDetail:
        return BedDetail(
            id=bed.id,
            bed_number=bed.bed_number,
            is_occupied=bed.current_student_id is not None,
            status=bed.status.value if hasattr(bed.status, "value") else str(bed.status),
            current_student_id=bed.current_student_id,
            current_student_name=student_name,
            occupied_from=bed.occupied_from,
        )

    def _to_room_detail(
        self,
        room,
        *,
        hostel_name: str,
        beds: Sequence,
        student_names: Dict[UUID, str],
    ) -> RoomDetail:
        occupied, available = self._occupied_available(
            total_beds=room.total_beds,
            beds=beds,
        )

        bed_details: List[BedDetail] = []
        for b in beds:
            s_name = student_names.get(b.current_student_id) if b.current_student_id else None
            bed_details.append(self._to_bed_detail(b, student_name=s_name))

        return RoomDetail(
            id=room.id,
            created_at=room.created_at,
            updated_at=room.updated_at,
            hostel_id=UUID(room.hostel_id) if isinstance(room.hostel_id, str) else room.hostel_id,
            hostel_name=hostel_name,
            room_number=room.room_number,
            floor_number=room.floor_number,
            wing=room.wing,
            room_type=room.room_type,
            total_beds=room.total_beds,
            occupied_beds=occupied,
            available_beds=available,
            price_monthly=room.price_monthly,
            price_quarterly=room.price_quarterly,
            price_half_yearly=room.price_half_yearly,
            price_yearly=room.price_yearly,
            room_size_sqft=room.room_size_sqft,
            is_ac=room.is_ac,
            has_attached_bathroom=room.has_attached_bathroom,
            has_balcony=room.has_balcony,
            has_wifi=room.has_wifi,
            amenities=room.amenities or [],
            furnishing=room.furnishing or [],
            status=room.status,
            is_available_for_booking=room.is_available_for_booking,
            is_under_maintenance=room.is_under_maintenance,
            maintenance_start_date=None,
            maintenance_end_date=None,
            room_images=room.room_images or [],
            beds=bed_details,
        )

    # ------------------------------------------------------------------ #
    # CRUD
    # ------------------------------------------------------------------ #
    def create_room(self, data: RoomCreate) -> RoomDetail:
        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            payload = data.model_dump(exclude_unset=True)
            room = room_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            # No beds yet
            return self._to_room_detail(
                room,
                hostel_name=hostel.name,
                beds=[],
                student_names={},
            )

    def bulk_create_rooms(self, data: BulkRoomCreate) -> List[RoomDetail]:
        responses: List[RoomDetail] = []
        for rc in data.rooms:
            # enforce same hostel_id as BulkRoomCreate
            rc = RoomCreate(**{**rc.model_dump(exclude_unset=True), "hostel_id": data.hostel_id})
            responses.append(self.create_room(rc))
        return responses

    def update_room(self, room_id: UUID, data: RoomUpdate) -> RoomDetail:
        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            bed_repo = self._get_bed_repo(uow)
            student_repo = self._get_student_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(room, field) and field != "id":
                    setattr(room, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            hostel = hostel_repo.get(UUID(room.hostel_id) if isinstance(room.hostel_id, str) else room.hostel_id)
            hostel_name = hostel.name if hostel else ""
            beds = bed_repo.get_multi(filters={"room_id": room.id})
            student_names: Dict[UUID, str] = {}
            for b in beds:
                if b.current_student_id and b.current_student_id not in student_names:
                    st = student_repo.get(b.current_student_id)
                    if st and getattr(st, "user", None):
                        student_names[b.current_student_id] = st.user.full_name

            uow.commit()
            return self._to_room_detail(room, hostel_name=hostel_name, beds=beds, student_names=student_names)

    def get_room(self, room_id: UUID) -> RoomDetail:
        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            hostel = hostel_repo.get(UUID(room.hostel_id) if isinstance(room.hostel_id, str) else room.hostel_id)
            hostel_name = hostel.name if hostel else ""

            beds = bed_repo.get_multi(filters={"room_id": room.id})
            student_names: Dict[UUID, str] = {}
            for b in beds:
                if b.current_student_id and b.current_student_id not in student_names:
                    st = student_repo.get(b.current_student_id)
                    if st and getattr(st, "user", None):
                        student_names[b.current_student_id] = st.user.full_name

            return self._to_room_detail(room, hostel_name=hostel_name, beds=beds, student_names=student_names)

    # ------------------------------------------------------------------ #
    # Listing
    # ------------------------------------------------------------------ #
    def list_rooms_for_hostel(
        self,
        hostel_id: UUID,
        params: PaginationParams,
        *,
        room_type: Optional[RoomType] = None,
        only_available: bool = False,
    ) -> PaginatedResponse[RoomListItem]:
        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)

            rooms = room_repo.list_for_hostel(
                hostel_id=hostel_id,
                only_available=only_available,
                room_type=room_type,
            )

            # Preload beds grouped by room
            room_ids = [r.id for r in rooms]
            bed_map: Dict[UUID, List] = {rid: [] for rid in room_ids}
            all_beds = bed_repo.get_multi(filters={"room_id": room_ids}) if room_ids else []
            for b in all_beds:
                bed_map.setdefault(b.room_id, []).append(b)

            items: List[RoomListItem] = []
            for r in rooms:
                beds = bed_map.get(r.id, [])
                _, available = self._occupied_available(total_beds=r.total_beds, beds=beds)
                items.append(self._to_room_list_item(r, available_beds=available))

            total = len(items)
            start = params.offset
            end = start + params.limit
            page_items = items[start:end]

            return PaginatedResponse[RoomListItem].create(
                items=page_items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

    # ------------------------------------------------------------------ #
    # Room with beds & stats
    # ------------------------------------------------------------------ #
    def get_room_with_beds(self, room_id: UUID) -> RoomWithBeds:
        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)
            student_repo = self._get_student_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            beds = bed_repo.get_multi(filters={"room_id": room.id})
            occupied, available = self._occupied_available(
                total_beds=room.total_beds,
                beds=beds,
            )

            from app.schemas.room.room_response import BedInfo

            student_names: Dict[UUID, str] = {}
            bed_infos: List[BedInfo] = []
            for b in beds:
                s_name = None
                if b.current_student_id:
                    if b.current_student_id not in student_names:
                        st = student_repo.get(b.current_student_id)
                        if st and getattr(st, "user", None):
                            student_names[b.current_student_id] = st.user.full_name
                    s_name = student_names.get(b.current_student_id)
                bed_infos.append(
                    BedInfo(
                        id=b.id,
                        bed_number=b.bed_number,
                        is_occupied=b.current_student_id is not None,
                        status=b.status.value if hasattr(b.status, "value") else str(b.status),
                        student_name=s_name,
                    )
                )

            return RoomWithBeds(
                id=room.id,
                created_at=room.created_at,
                updated_at=room.updated_at,
                hostel_id=UUID(room.hostel_id) if isinstance(room.hostel_id, str) else room.hostel_id,
                room_number=room.room_number,
                room_type=room.room_type,
                total_beds=room.total_beds,
                occupied_beds=occupied,
                available_beds=available,
                beds=bed_infos,
            )

    def get_room_occupancy_stats(self, room_id: UUID) -> RoomOccupancyStats:
        with UnitOfWork(self._session_factory) as uow:
            room_repo = self._get_room_repo(uow)
            bed_repo = self._get_bed_repo(uow)

            room = room_repo.get(room_id)
            if room is None:
                raise errors.NotFoundError(f"Room {room_id} not found")

            beds = bed_repo.get_multi(filters={"room_id": room.id})
            occupied, available = self._occupied_available(
                total_beds=room.total_beds,
                beds=beds,
            )

            # Very simple revenue estimates:
            current_revenue = room.price_monthly * Decimal(str(occupied))
            potential_revenue = room.price_monthly * Decimal(str(room.total_beds))

            occ_pct = (
                Decimal(str(occupied)) / Decimal(str(room.total_beds)) * Decimal("100")
                if room.total_beds > 0
                else Decimal("0")
            )

            return RoomOccupancyStats(
                room_id=room.id,
                room_number=room.room_number,
                total_beds=room.total_beds,
                occupied_beds=occupied,
                available_beds=available,
                occupancy_percentage=occ_pct,
                current_revenue=current_revenue,
                potential_revenue=potential_revenue,
            )

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\room\__init__.py ---
# app/services/room/__init__.py
"""
Room and bed services.

- RoomService:
    Core CRUD, listing, and detail for rooms with occupancy data.

- RoomAvailabilityService:
    Availability checks and basic availability calendar per room.

- BedService:
    CRUD and listing for beds, plus simple availability info.

- BedAssignmentService:
    Assign/release beds to/from students and maintain history.
"""

from .room_service import RoomService
from .room_availability_service import RoomAvailabilityService
from .bed_service import BedService
from .bed_assignment_service import BedAssignmentService

__all__ = [
    "RoomService",
    "RoomAvailabilityService",
    "BedService",
    "BedAssignmentService",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\services\room\__pycache__ =====
