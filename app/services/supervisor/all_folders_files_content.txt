### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\services\supervisor ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\services\supervisor =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\supervisor\supervisor_activity_service.py ---
# app/services/supervisor/supervisor_activity_service.py
from __future__ import annotations

from collections import defaultdict
from datetime import datetime
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.audit import SupervisorActivityRepository
from app.repositories.core import SupervisorRepository, HostelRepository
from app.schemas.common.filters import DateTimeRangeFilter
from app.schemas.supervisor.supervisor_activity import (
    SupervisorActivityLog,
    ActivitySummary,
    ActivityDetail,
    ActivityFilterParams,
    TopActivity,
    ActivityTimelinePoint,
)
from app.services.common import UnitOfWork, errors


class SupervisorActivityService:
    """
    Supervisor activity reporting:

    - List activity logs with filtering
    - Get single activity detail
    - Build summary over a period
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # Helpers
    def _get_repo(self, uow: UnitOfWork) -> SupervisorActivityRepository:
        return uow.get_repo(SupervisorActivityRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # Mapping
    def _to_log(
        self,
        rec,
        *,
        supervisor_name: str,
        hostel_name: str,
    ) -> SupervisorActivityLog:
        from app.schemas.common.enums import AuditActionCategory

        category = rec.action_category
        if not isinstance(category, AuditActionCategory):
            try:
                category = AuditActionCategory(category)
            except Exception:
                category = AuditActionCategory.OTHER  # type: ignore[attr-defined]

        return SupervisorActivityLog(
            id=rec.id,
            created_at=rec.created_at,
            updated_at=rec.created_at,
            supervisor_id=rec.supervisor_id,
            supervisor_name=supervisor_name,
            hostel_id=rec.hostel_id,
            hostel_name=hostel_name,
            action_type=rec.action_type,
            action_category=category,
            entity_type=rec.entity_type,
            entity_id=rec.entity_id,
            action_description=rec.action_description,
            metadata=rec.metadata or {},
            ip_address=rec.ip_address,
            user_agent=rec.user_agent,
        )

    # Listing
    def list_activity_logs(self, filters: ActivityFilterParams) -> List[SupervisorActivityLog]:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            raw_filters: Dict[str, object] = {}
            if filters.supervisor_id:
                raw_filters["supervisor_id"] = filters.supervisor_id
            elif filters.supervisor_ids:
                raw_filters["supervisor_id"] = filters.supervisor_ids
            if filters.hostel_id:
                raw_filters["hostel_id"] = filters.hostel_id
            if filters.action_type:
                raw_filters["action_type"] = filters.action_type
            if filters.entity_type:
                raw_filters["entity_type"] = filters.entity_type
            if filters.entity_id:
                raw_filters["entity_id"] = filters.entity_id

            recs = repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters=raw_filters or None,
                order_by=[repo.model.created_at.desc()],  # type: ignore[attr-defined]
            )

            def _in_range(rec) -> bool:
                dr: Optional[DateTimeRangeFilter] = filters.date_range
                if not dr:
                    return True
                if dr.start and rec.created_at < dr.start:
                    return False
                if dr.end and rec.created_at > dr.end:
                    return False
                return True

            def _cat_ok(rec) -> bool:
                if filters.action_category:
                    return rec.action_category == filters.action_category
                if filters.action_categories:
                    return rec.action_category in filters.action_categories
                return True

            def _success_ok(rec) -> bool:
                # Success/failure flags not in model; treat all as success
                if filters.success_only:
                    return True
                if filters.failed_only:
                    return False
                return True

            filtered = [r for r in recs if _in_range(r) and _cat_ok(r) and _success_ok(r)]

            # Pagination
            page = filters.page
            page_size = filters.page_size
            offset = (page - 1) * page_size
            page_recs = filtered[offset : offset + page_size]

            # Cache names
            sup_cache: Dict[UUID, str] = {}
            hostel_cache: Dict[UUID, str] = {}

            logs: List[SupervisorActivityLog] = []
            for r in page_recs:
                if r.supervisor_id not in sup_cache:
                    sup = sup_repo.get(r.supervisor_id)
                    sup_cache[r.supervisor_id] = (
                        sup.user.full_name if sup and getattr(sup, "user", None) else ""
                    )
                supervisor_name = sup_cache[r.supervisor_id]

                if r.hostel_id not in hostel_cache:
                    h = hostel_repo.get(r.hostel_id)
                    hostel_cache[r.hostel_id] = h.name if h else ""
                hostel_name = hostel_cache[r.hostel_id]

                logs.append(self._to_log(r, supervisor_name=supervisor_name, hostel_name=hostel_name))

            return logs

    # Detail
    def get_activity_detail(self, activity_id: UUID) -> ActivityDetail:
        with UnitOfWork(self._session_factory) as uow:
            repo = self._get_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            r = repo.get(activity_id)
            if r is None:
                raise errors.NotFoundError(f"SupervisorActivity {activity_id} not found")

            sup = sup_repo.get(r.supervisor_id)
            sup_name = sup.user.full_name if sup and getattr(sup, "user", None) else ""

        return ActivityDetail(
            activity_id=r.id,
            supervisor_id=r.supervisor_id,
            supervisor_name=sup_name,
            timestamp=r.created_at,
            action_type=r.action_type,
            action_category=r.action_category,
            action_description=r.action_description,
            entity_type=r.entity_type,
            entity_id=r.entity_id,
            entity_name=None,
            old_values=None,
            new_values=None,
            ip_address=r.ip_address,
            user_agent=r.user_agent,
            location=None,
            success=True,
            error_message=None,
        )

    # Summary
    def get_activity_summary(self, filters: ActivityFilterParams) -> ActivitySummary:
        logs = self.list_activity_logs(filters)

        if filters.date_range and filters.date_range.start and filters.date_range.end:
            period_start = filters.date_range.start
            period_end = filters.date_range.end
        elif logs:
            period_start = logs[-1].created_at
            period_end = logs[0].created_at
        else:
            now = self._now()
            period_start = period_end = now

        total_actions = len(logs)
        actions_by_category: Dict[str, int] = defaultdict(int)
        actions_by_type: Dict[str, int] = defaultdict(int)
        timeline_map: Dict[str, Dict[str, int]] = defaultdict(lambda: defaultdict(int))
        type_cat_counts: Dict[tuple[str, str], Dict[str, object]] = {}

        for l in logs:
            cat_key = l.action_category.value if hasattr(l.action_category, "value") else str(l.action_category)
            type_key = l.action_type
            actions_by_category[cat_key] += 1
            actions_by_type[type_key] += 1

            # timeline (per day)
            day_label = l.created_at.date().isoformat()
            timeline_map[day_label][cat_key] += 1

            key = (type_key, cat_key)
            rec = type_cat_counts.setdefault(
                key,
                {"count": 0, "last": l.created_at},
            )
            rec["count"] += 1
            if l.created_at > rec["last"]:
                rec["last"] = l.created_at

        # Top activities
        top_activities: List[TopActivity] = []
        for (act_type, cat), v in sorted(
            type_cat_counts.items(), key=lambda kv: kv[1]["count"], reverse=True
        )[:5]:
            top_activities.append(
                TopActivity(
                    action_type=act_type,
                    action_category=cat,
                    count=v["count"],
                    last_performed=v["last"],
                )
            )

        # Timeline points
        timeline: List[ActivityTimelinePoint] = []
        for day, cats in sorted(timeline_map.items()):
            ts = datetime.fromisoformat(day)
            total_day = sum(cats.values())
            timeline.append(
                ActivityTimelinePoint(
                    timestamp=ts,
                    action_count=total_day,
                    categories=dict(cats),
                )
            )

        # Peak hours
        hour_counts: Dict[int, int] = defaultdict(int)
        for l in logs:
            hour_counts[l.created_at.hour] += 1
        sorted_hours = sorted(hour_counts.items(), key=lambda kv: kv[1], reverse=True)
        peak_hours = [h for h, _ in sorted_hours[:3]]

        supervisor_id = filters.supervisor_id or UUID(int=0)
        supervisor_name = ""

        return ActivitySummary(
            supervisor_id=supervisor_id,
            supervisor_name=supervisor_name,
            period_start=period_start,
            period_end=period_end,
            total_actions=total_actions,
            actions_by_category=dict(actions_by_category),
            actions_by_type=dict(actions_by_type),
            top_activities=top_activities,
            activity_timeline=timeline,
            peak_hours=peak_hours,
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\supervisor\supervisor_assignment_service.py ---
# app/services/supervisor/supervisor_assignment_service.py
from __future__ import annotations

from datetime import date
from typing import Callable, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import SupervisorRepository, UserRepository, HostelRepository
from app.repositories.associations import SupervisorHostelRepository
from app.schemas.supervisor import (
    SupervisorAssignment,
    AssignmentRequest,
    AssignmentUpdate,
    RevokeAssignmentRequest,
)
from app.schemas.common.enums import EmploymentType, SupervisorStatus
from app.services.common import UnitOfWork, errors


class SupervisorAssignmentService:
    """
    Supervisor â†” hostel assignments (multi-hostel):

    - Assign supervisor (user) to a hostel (creates core_supervisor if needed).
    - Update assignment metadata.
    - Revoke assignment.
    - List assignments for a supervisor or hostel (simple).
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # Helpers
    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_assoc_repo(self, uow: UnitOfWork) -> SupervisorHostelRepository:
        return uow.get_repo(SupervisorHostelRepository)

    # Mapping
    def _build_assignment(
        self,
        assoc,
        *,
        supervisor_name: str,
        hostel_name: str,
        assigned_by: UUID,
        assigned_by_name: str,
    ) -> SupervisorAssignment:
        return SupervisorAssignment(
            id=assoc.id,
            created_at=assoc.created_at,
            updated_at=assoc.updated_at,
            supervisor_id=assoc.supervisor_id,
            supervisor_name=supervisor_name,
            hostel_id=assoc.hostel_id,
            hostel_name=hostel_name,
            assigned_by=assigned_by,
            assigned_by_name=assigned_by_name,
            assigned_date=assoc.join_date,
            is_active=assoc.is_active,
            permission_level="standard",
            last_active=None,
        )

    # Assignment
    def assign_supervisor(
        self,
        data: AssignmentRequest,
        *,
        assigned_by: UUID,
    ) -> SupervisorAssignment:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            assoc_repo = self._get_assoc_repo(uow)

            user = user_repo.get(data.user_id)
            if user is None:
                raise errors.NotFoundError(f"User {data.user_id} not found")

            hostel = hostel_repo.get(data.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.hostel_id} not found")

            # Ensure a core_supervisor exists for this user
            sup_list = sup_repo.get_multi(filters={"user_id": data.user_id})
            if sup_list:
                supervisor = sup_list[0]
            else:
                supervisor = sup_repo.create(
                    {
                        "user_id": data.user_id,
                        "hostel_id": data.hostel_id,
                        "employee_id": data.employee_id,
                        "join_date": data.join_date,
                        "employment_type": EmploymentType.FULL_TIME,
                        "shift_timing": data.shift_timing,
                        "status": SupervisorStatus.ACTIVE,
                        "is_active": True,
                        "permissions": data.permissions or {},
                    }
                )

            # Prevent duplicate assignment
            existing = assoc_repo.get_multi(
                skip=0,
                limit=1,
                filters={"supervisor_id": supervisor.id, "hostel_id": data.hostel_id},
            )
            if existing:
                raise errors.ConflictError("Supervisor already assigned to this hostel")

            assoc = assoc_repo.create(
                {
                    "supervisor_id": supervisor.id,
                    "hostel_id": data.hostel_id,
                    "employee_id": data.employee_id,
                    "join_date": data.join_date,
                    "employment_type": data.employment_type,
                    "shift_timing": data.shift_timing,
                    "is_active": True,
                    "permissions": data.permissions or {},
                }
            )

            assigned_by_user = user_repo.get(assigned_by)
            assigned_by_name = assigned_by_user.full_name if assigned_by_user else ""

            uow.commit()
            return self._build_assignment(
                assoc,
                supervisor_name=user.full_name,
                hostel_name=hostel.name,
                assigned_by=assigned_by,
                assigned_by_name=assigned_by_name,
            )

    def update_assignment(self, assignment_id: UUID, data: AssignmentUpdate) -> SupervisorAssignment:
        with UnitOfWork(self._session_factory) as uow:
            assoc_repo = self._get_assoc_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            assoc = assoc_repo.get(assignment_id)
            if assoc is None:
                raise errors.NotFoundError(f"SupervisorHostel {assignment_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(assoc, field) and field != "id":
                    setattr(assoc, field, value)

            uow.session.flush()  # type: ignore[union-attr]

            sup_user = user_repo.get(assoc.supervisor_id)
            supervisor_name = sup_user.full_name if sup_user else ""
            hostel = hostel_repo.get(assoc.hostel_id)
            hostel_name = hostel.name if hostel else ""

            uow.commit()
            return self._build_assignment(
                assoc,
                supervisor_name=supervisor_name,
                hostel_name=hostel_name,
                assigned_by=UUID(int=0),
                assigned_by_name="",
            )

    def revoke_assignment(
        self,
        data: RevokeAssignmentRequest,
        *,
        revoked_by: UUID,
    ) -> None:
        """
        Mark supervisor-hostel association as inactive.
        """
        with UnitOfWork(self._session_factory) as uow:
            assoc_repo = self._get_assoc_repo(uow)

            # Find associations for this supervisor (all hostels)
            assocs = assoc_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"supervisor_id": data.supervisor_id},
            )
            if not assocs:
                raise errors.NotFoundError(f"No assignments found for supervisor {data.supervisor_id}")

            for a in assocs:
                a.is_active = False  # type: ignore[attr-defined]

            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

    def list_assignments_for_supervisor(self, supervisor_id: UUID) -> List[SupervisorAssignment]:
        with UnitOfWork(self._session_factory) as uow:
            assoc_repo = self._get_assoc_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            assocs = assoc_repo.get_multi(
                skip=0,
                limit=None,  # type: ignore[arg-type]
                filters={"supervisor_id": supervisor_id},
            )

            sup_user = user_repo.get(supervisor_id)
            supervisor_name = sup_user.full_name if sup_user else ""

            results: List[SupervisorAssignment] = []
            for a in assocs:
                hostel = hostel_repo.get(a.hostel_id)
                hostel_name = hostel.name if hostel else ""
                results.append(
                    self._build_assignment(
                        a,
                        supervisor_name=supervisor_name,
                        hostel_name=hostel_name,
                        assigned_by=UUID(int=0),
                        assigned_by_name="",
                    )
                )
            return results

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\supervisor\supervisor_dashboard_service.py ---
# app/services/supervisor/supervisor_dashboard_service.py
from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import (
    SupervisorRepository,
    HostelRepository,
    StudentRepository,
    BedRepository,
)
from app.repositories.services import (
    ComplaintRepository,
    MaintenanceRepository,
    AttendanceRepository,
    LeaveApplicationRepository,
)
from app.repositories.transactions import PaymentRepository
from app.schemas.common.enums import ComplaintStatus, MaintenanceStatus, AttendanceStatus, LeaveStatus, Priority
from app.schemas.supervisor import (
    SupervisorDashboard,
    DashboardMetrics,
    TaskSummary,
    RecentComplaintItem,
    RecentMaintenanceItem,
    PendingLeaveItem,
    TodaySchedule,
    ScheduledMaintenanceItem,
    ScheduledMeeting,
    DashboardAlert,
)
from app.services.common import UnitOfWork, errors


class SupervisorDashboardService:
    """
    Supervisor dashboard aggregation:

    - Quick metrics for students, occupancy, complaints, maintenance, attendance, payments.
    - Recent complaints/maintenance/leaves.
    - Simple schedule skeleton and alerts.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # Helpers
    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_student_repo(self, uow: UnitOfWork) -> StudentRepository:
        return uow.get_repo(StudentRepository)

    def _get_bed_repo(self, uow: UnitOfWork) -> BedRepository:
        return uow.get_repo(BedRepository)

    def _get_complaint_repo(self, uow: UnitOfWork) -> ComplaintRepository:
        return uow.get_repo(ComplaintRepository)

    def _get_maintenance_repo(self, uow: UnitOfWork) -> MaintenanceRepository:
        return uow.get_repo(MaintenanceRepository)

    def _get_attendance_repo(self, uow: UnitOfWork) -> AttendanceRepository:
        return uow.get_repo(AttendanceRepository)

    def _get_leave_repo(self, uow: UnitOfWork) -> LeaveApplicationRepository:
        return uow.get_repo(LeaveApplicationRepository)

    def _get_payment_repo(self, uow: UnitOfWork) -> PaymentRepository:
        return uow.get_repo(PaymentRepository)

    def _today(self) -> date:
        return date.today()

    def _now(self) -> datetime:
        return datetime.utcnow()

    # Public API
    def get_dashboard(self, supervisor_id: UUID) -> SupervisorDashboard:
        today = self._today()

        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)
            student_repo = self._get_student_repo(uow)
            bed_repo = self._get_bed_repo(uow)
            complaint_repo = self._get_complaint_repo(uow)
            maintenance_repo = self._get_maintenance_repo(uow)
            attendance_repo = self._get_attendance_repo(uow)
            leave_repo = self._get_leave_repo(uow)
            payment_repo = self._get_payment_repo(uow)

            sup = sup_repo.get(supervisor_id)
            if sup is None or not getattr(sup, "user", None):
                raise errors.NotFoundError(f"Supervisor {supervisor_id} not found")

            hostel = hostel_repo.get(sup.hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {sup.hostel_id} not found")

            hostel_name = hostel.name

            # Students & beds
            students = student_repo.list_for_hostel(hostel.id, status=None)
            total_students = len(students)
            active_students = sum(1 for s in students if s.student_status.name == "ACTIVE")

            beds = bed_repo.get_multi(filters={"hostel_id": hostel.id})
            total_beds = len(beds)
            occupied_beds = sum(1 for b in beds if b.current_student_id is not None)
            available_beds = max(0, total_beds - occupied_beds)
            occupancy_pct = (
                Decimal(str(occupied_beds)) / Decimal(str(total_beds)) * Decimal("100")
                if total_beds > 0
                else Decimal("0")
            )

            # Complaints
            open_complaints_list = complaint_repo.list_open_for_hostel(
                hostel.id,
                category=None,
                priority=None,
            )
            total_complaints = len(
                complaint_repo.get_multi(filters={"hostel_id": hostel.id})
            )
            assigned_to_me = len(
                [c for c in open_complaints_list if c.assigned_to_id == supervisor_id]
            )
            resolved_today = 0  # detailed tracking omitted

            # Maintenance
            open_maintenance_list = maintenance_repo.list_open_for_hostel(
                hostel.id,
                category=None,
                priority=None,
            )
            pending_maintenance = len(open_maintenance_list)
            in_progress_maintenance = len(
                [m for m in open_maintenance_list if m.status == MaintenanceStatus.IN_PROGRESS]
            )
            completed_today = 0  # placeholder

            # Attendance today
            todays_attendance = attendance_repo.list_for_hostel_date(hostel.id, today)
            attendance_marked_today = len(todays_attendance) > 0
            total_present_today = len(
                [a for a in todays_attendance if a.status == AttendanceStatus.PRESENT]
            ) + len(
                [a for a in todays_attendance if a.status == AttendanceStatus.LATE]
            )
            total_absent_today = len(
                [a for a in todays_attendance if a.status == AttendanceStatus.ABSENT]
            )
            students_on_leave = len(
                [a for a in todays_attendance if a.status == AttendanceStatus.ON_LEAVE]
            )

            # Payments overdue
            overdue_payments = payment_repo.list_due_for_hostel(
                hostel.id,
                on_or_before=today,
            )
            overdue_payments_count = len(overdue_payments)

            # DashboardMetrics
            metrics = DashboardMetrics(
                total_students=total_students,
                active_students=active_students,
                total_beds=total_beds,
                occupied_beds=occupied_beds,
                available_beds=available_beds,
                occupancy_percentage=occupancy_pct,
                total_complaints=total_complaints,
                open_complaints=len(open_complaints_list),
                assigned_to_me=assigned_to_me,
                resolved_today=resolved_today,
                average_resolution_time_hours=Decimal("0"),
                pending_maintenance=pending_maintenance,
                in_progress_maintenance=in_progress_maintenance,
                completed_today=completed_today,
                attendance_marked_today=attendance_marked_today,
                total_present_today=total_present_today,
                total_absent_today=total_absent_today,
                students_on_leave=students_on_leave,
                overdue_payments_count=overdue_payments_count,
                unread_admin_messages=0,
            )

            # TaskSummary (simple heuristic)
            urgent_complaints = len(
                [c for c in open_complaints_list if c.priority in (Priority.CRITICAL, Priority.URGENT)]
            )
            critical_maintenance = len(
                [m for m in open_maintenance_list if m.priority in (Priority.CRITICAL, Priority.URGENT)]
            )
            pending_leave_approvals = len(
                leave_repo.list_pending_for_hostel(hostel.id)
            )

            attendance_pending = not attendance_marked_today
            menu_published_today = True
            daily_inspection_done = False

            overdue_complaint_resolutions = 0
            overdue_maintenance = 0

            total_pending_tasks = (
                urgent_complaints
                + critical_maintenance
                + pending_leave_approvals
                + (1 if attendance_pending else 0)
            )

            tasks = TaskSummary(
                urgent_complaints=urgent_complaints,
                critical_maintenance=critical_maintenance,
                pending_leave_approvals=pending_leave_approvals,
                attendance_pending=attendance_pending,
                menu_published_today=menu_published_today,
                daily_inspection_done=daily_inspection_done,
                overdue_complaint_resolutions=overdue_complaint_resolutions,
                overdue_maintenance=overdue_maintenance,
                total_pending_tasks=total_pending_tasks,
            )

            # Recent complaints (assigned to supervisor)
            rec_complaints = complaint_repo.list_for_supervisor(
                supervisor_id,
                include_closed=True,
            )[:5]
            recent_complaints: List[RecentComplaintItem] = []
            for c in rec_complaints:
                age_hours = int((self._now() - c.created_at).total_seconds() // 3600)
                recent_complaints.append(
                    RecentComplaintItem(
                        complaint_id=c.id,
                        complaint_number=str(c.id),
                        title=c.title,
                        category=c.category.value if hasattr(c.category, "value") else str(c.category),
                        priority=c.priority.value if hasattr(c.priority, "value") else str(c.priority),
                        status=c.status.value if hasattr(c.status, "value") else str(c.status),
                        student_name="",
                        room_number="",
                        created_at=c.created_at,
                        age_hours=age_hours,
                    )
                )

            # Recent maintenance
            all_maint = maintenance_repo.list_open_for_hostel(hostel.id, category=None, priority=None)[:5]
            recent_maintenance: List[RecentMaintenanceItem] = []
            for m in all_maint:
                recent_maintenance.append(
                    RecentMaintenanceItem(
                        request_id=m.id,
                        request_number=str(m.id),
                        title=m.title,
                        category=m.category.value if hasattr(m.category, "value") else str(m.category),
                        priority=m.priority.value if hasattr(m.priority, "value") else str(m.priority),
                        status=m.status.value if hasattr(m.status, "value") else str(m.status),
                        room_number=None,
                        estimated_cost=m.estimated_cost,
                        created_at=m.created_at,
                    )
                )

            # Pending leave approvals
            pending_leaves = leave_repo.list_pending_for_hostel(hostel.id)[:5]
            pending_leaves_items: List[PendingLeaveItem] = []
            for l in pending_leaves:
                pending_leaves_items.append(
                    PendingLeaveItem(
                        leave_id=l.id,
                        student_name="",
                        room_number="",
                        leave_type=l.leave_type.value if hasattr(l.leave_type, "value") else str(l.leave_type),
                        from_date=l.from_date,
                        to_date=l.to_date,
                        total_days=l.total_days,
                        reason=l.reason,
                        applied_at=l.created_at,
                    )
                )

            # Today's schedule (simple defaults)
            today_schedule = TodaySchedule(
                date=today,
                attendance_marking_time="09:00",
                inspection_rounds=["Ground Floor", "First Floor"],
                scheduled_maintenance=[],
                scheduled_meetings=[],
                special_events=[],
            )

            # Alerts (placeholder)
            alerts: List[DashboardAlert] = []

            last_login = getattr(sup.user, "last_login_at", None)
            actions_today = 0

        return SupervisorDashboard(
            supervisor_id=supervisor_id,
            supervisor_name=sup.user.full_name,
            hostel_id=hostel.id,
            hostel_name=hostel_name,
            metrics=metrics,
            tasks=tasks,
            recent_complaints=recent_complaints,
            recent_maintenance=recent_maintenance,
            pending_leaves=pending_leaves_items,
            today_schedule=today_schedule,
            alerts=alerts,
            last_login=last_login,
            actions_today=actions_today,
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\supervisor\supervisor_performance_service.py ---
# app/services/supervisor/supervisor_performance_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Callable, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import HostelRepository, SupervisorRepository
from app.repositories.analytics import SupervisorPerformanceMetricsRepository
from app.schemas.common.filters import DateRangeFilter
from app.schemas.supervisor import (
    PerformanceMetrics,
    PerformanceReport,
    ComplaintPerformance,
    AttendancePerformance,
    MaintenancePerformance,
)
from app.services.analytics import SupervisorAnalyticsService
from app.services.common import UnitOfWork, errors


class SupervisorPerformanceService:
    """
    Supervisor performance service:

    - Map analytics_supervisor_performance into PerformanceMetrics.
    - Provide a basic PerformanceReport wrapper.
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory
        self._analytics = SupervisorAnalyticsService(session_factory)

    # Helpers
    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_metrics_repo(self, uow: UnitOfWork) -> SupervisorPerformanceMetricsRepository:
        return uow.get_repo(SupervisorPerformanceMetricsRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # Mapping
    def _to_performance_metrics(self, m, *, supervisor_name: str) -> PerformanceMetrics:
        total_complaints = m.complaints_assigned
        complaints_resolved = m.complaints_resolved
        complaint_resolution_rate = (
            Decimal(str(complaints_resolved)) / Decimal(str(total_complaints)) * Decimal("100")
            if total_complaints > 0
            else Decimal("0")
        )

        return PerformanceMetrics(
            supervisor_id=m.supervisor_id,
            supervisor_name=supervisor_name,
            hostel_id=m.hostel_id,
            period_start=m.period_start,
            period_end=m.period_end,
            complaints_handled=m.complaints_assigned,
            complaints_resolved=m.complaints_resolved,
            complaint_resolution_rate=complaint_resolution_rate,
            average_resolution_time_hours=m.avg_complaint_resolution_time_hours,
            sla_compliance_rate=Decimal("0"),
            attendance_records_created=m.attendance_records_marked,
            attendance_accuracy=Decimal("0"),
            leaves_approved=0,
            leaves_rejected=0,
            maintenance_requests_created=m.maintenance_requests_created,
            maintenance_completed=m.maintenance_requests_completed,
            maintenance_completion_rate=Decimal("0"),
            average_maintenance_time_hours=m.avg_maintenance_completion_time_hours,
            announcements_created=0,
            announcement_reach=0,
            average_first_response_time_minutes=Decimal("0"),
            availability_percentage=Decimal("0"),
            student_feedback_score=None,
            overall_performance_score=m.overall_performance_score,
        )

    # Public API
    def get_performance_metrics(
        self,
        supervisor_id: UUID,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> Optional[PerformanceMetrics]:
        with UnitOfWork(self._session_factory) as uow:
            metrics_repo = self._get_metrics_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)

            m = metrics_repo.get_for_supervisor_period(
                supervisor_id=supervisor_id,
                hostel_id=hostel_id,
                period_start=period.start_date,
                period_end=period.end_date,
            )
            if not m:
                return None

            sup = sup_repo.get(supervisor_id)
            sup_name = sup.user.full_name if sup and getattr(sup, "user", None) else ""

        return self._to_performance_metrics(m, supervisor_name=sup_name)

    def get_performance_report(
        self,
        supervisor_id: UUID,
        hostel_id: UUID,
        period: DateRangeFilter,
    ) -> Optional[PerformanceReport]:
        with UnitOfWork(self._session_factory) as uow:
            metrics_repo = self._get_metrics_repo(uow)
            sup_repo = self._get_supervisor_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            m = metrics_repo.get_for_supervisor_period(
                supervisor_id=supervisor_id,
                hostel_id=hostel_id,
                period_start=period.start_date,
                period_end=period.end_date,
            )
            if not m:
                return None

            sup = sup_repo.get(supervisor_id)
            hostel = hostel_repo.get(hostel_id)
            sup_name = sup.user.full_name if sup and getattr(sup, "user", None) else ""
            hostel_name = hostel.name if hostel else ""

        metrics = self._to_performance_metrics(m, supervisor_name=sup_name)

        # Very simple placeholders for detailed sections
        complaint_perf = ComplaintPerformance(
            total_complaints=m.complaints_assigned,
            resolved_complaints=m.complaints_resolved,
            pending_complaints=m.complaints_assigned - m.complaints_resolved,
            complaints_by_category={},
            complaints_by_priority={},
            average_resolution_time_hours=m.avg_complaint_resolution_time_hours,
            fastest_resolution_hours=m.avg_complaint_resolution_time_hours,
            slowest_resolution_hours=m.avg_complaint_resolution_time_hours,
            within_sla=0,
            breached_sla=0,
            sla_compliance_rate=Decimal("0"),
            average_complaint_rating=None,
        )

        attendance_perf = AttendancePerformance(
            total_attendance_records=m.attendance_records_marked,
            days_attendance_marked=0,
            days_attendance_missed=0,
            on_time_marking_rate=Decimal("0"),
            average_marking_delay_minutes=Decimal("0"),
            corrections_made=0,
            accuracy_rate=Decimal("0"),
            leaves_processed=0,
            average_leave_approval_time_hours=Decimal("0"),
        )

        maintenance_perf = MaintenancePerformance(
            requests_created=m.maintenance_requests_created,
            requests_completed=m.maintenance_requests_completed,
            requests_pending=m.maintenance_requests_created - m.maintenance_requests_completed,
            requests_by_category={},
            average_completion_time_hours=m.avg_maintenance_completion_time_hours,
            total_maintenance_cost=Decimal("0"),
            average_cost_per_request=Decimal("0"),
            within_budget_rate=Decimal("0"),
            preventive_tasks_completed=0,
            preventive_compliance_rate=Decimal("0"),
        )

        return PerformanceReport(
            supervisor_id=supervisor_id,
            supervisor_name=sup_name,
            hostel_name=hostel_name,
            report_period=period,
            generated_at=self._now(),
            summary=metrics,
            complaint_performance=complaint_perf,
            attendance_performance=attendance_perf,
            maintenance_performance=maintenance_perf,
            performance_trends=[],
            comparison_with_peers=None,
            comparison_with_previous_period=None,
            strengths=[],
            areas_for_improvement=[],
            recommendations=[],
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\supervisor\supervisor_permissions_service.py ---
# app/services/supervisor/supervisor_permissions_service.py
from __future__ import annotations

from decimal import Decimal
from typing import Callable, Dict, Any
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import SupervisorRepository
from app.schemas.supervisor import (
    SupervisorPermissions,
    PermissionUpdate,
    PermissionCheckRequest,
    PermissionCheckResponse,
)
from app.services.common import UnitOfWork, errors


class SupervisorPermissionsService:
    """
    Supervisor permission management:

    - Get/set permissions (stored on core_supervisor.permissions JSON)
    - Evaluate a simple permission check, including threshold-based checks
      (e.g., maintenance_approval_threshold).
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    # Internal helpers
    def _load_permissions(self, sup) -> SupervisorPermissions:
        """
        Merge stored JSON permissions onto SupervisorPermissions defaults.
        """
        stored = sup.permissions or {}
        base = SupervisorPermissions()
        data = base.model_dump()
        data.update(stored)
        return SupervisorPermissions.model_validate(data)

    # Public API
    def get_permissions(self, supervisor_id: UUID) -> SupervisorPermissions:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            sup = sup_repo.get(supervisor_id)
            if sup is None:
                raise errors.NotFoundError(f"Supervisor {supervisor_id} not found")
            return self._load_permissions(sup)

    def update_permissions(
        self,
        supervisor_id: UUID,
        data: PermissionUpdate,
    ) -> SupervisorPermissions:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            sup = sup_repo.get(supervisor_id)
            if sup is None:
                raise errors.NotFoundError(f"Supervisor {supervisor_id} not found")

            current = sup.permissions or {}
            current.update(data.permissions)
            sup.permissions = current  # type: ignore[attr-defined]
            uow.session.flush()  # type: ignore[union-attr]
            uow.commit()

            return self._load_permissions(sup)

    def check_permission(self, req: PermissionCheckRequest) -> PermissionCheckResponse:
        perms = self.get_permissions(req.supervisor_id)
        data = perms.model_dump()

        key = req.permission_key
        ctx = req.context or {}
        has_perm = False
        requires_approval = False
        threshold_exceeded = False
        threshold_value: Decimal | None = None
        actual_value: Decimal | None = None
        message = ""

        if key not in data and key != "maintenance_approval_threshold":
            return PermissionCheckResponse(
                supervisor_id=req.supervisor_id,
                permission_key=key,
                has_permission=False,
                requires_approval=False,
                threshold_exceeded=False,
                message="Unknown permission key",
                threshold_value=None,
                actual_value=None,
            )

        if key == "maintenance_approval_threshold":
            # Threshold-based check
            threshold_value = Decimal(str(data.get("maintenance_approval_threshold", "0")))
            amount = ctx.get("amount")
            if amount is not None:
                actual_value = Decimal(str(amount))
                threshold_exceeded = actual_value > threshold_value
                has_perm = True
                requires_approval = threshold_exceeded
                message = (
                    "Amount exceeds supervisor approval threshold; admin approval required."
                    if threshold_exceeded
                    else "Within supervisor approval threshold."
                )
            else:
                has_perm = True
                message = "Threshold value retrieved."
        else:
            val = data.get(key)
            if isinstance(val, bool):
                has_perm = val
                message = "Permission granted." if val else "Permission denied."
            else:
                has_perm = bool(val)

        return PermissionCheckResponse(
            supervisor_id=req.supervisor_id,
            permission_key=key,
            has_permission=has_perm,
            requires_approval=requires_approval,
            threshold_exceeded=threshold_exceeded,
            message=message,
            threshold_value=threshold_value,
            actual_value=actual_value,
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\supervisor\supervisor_service.py ---
# app/services/supervisor/supervisor_service.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Callable, Dict, List, Optional, Sequence
from uuid import UUID

from sqlalchemy.orm import Session

from app.repositories.core import (
    SupervisorRepository,
    UserRepository,
    HostelRepository,
)
from app.schemas.common.enums import SupervisorStatus, EmploymentType
from app.schemas.common.pagination import PaginationParams, PaginatedResponse
from app.schemas.supervisor import (
    SupervisorCreate,
    SupervisorUpdate,
    SupervisorResponse,
    SupervisorDetail,
    SupervisorListItem,
)
from app.services.common import UnitOfWork, errors


class SupervisorService:
    """
    Core supervisor service:

    - Create/update supervisors
    - Get supervisor detail
    - List supervisors for a hostel
    """

    def __init__(self, session_factory: Callable[[], Session]) -> None:
        self._session_factory = session_factory

    # Helpers
    def _get_supervisor_repo(self, uow: UnitOfWork) -> SupervisorRepository:
        return uow.get_repo(SupervisorRepository)

    def _get_user_repo(self, uow: UnitOfWork) -> UserRepository:
        return uow.get_repo(UserRepository)

    def _get_hostel_repo(self, uow: UnitOfWork) -> HostelRepository:
        return uow.get_repo(HostelRepository)

    def _now(self) -> datetime:
        return datetime.utcnow()

    # Mapping
    def _to_response(
        self,
        s,
        *,
        user,
        hostel_name: str,
        assigned_by: UUID,
        assigned_date: datetime,
    ) -> SupervisorResponse:
        return SupervisorResponse(
            id=s.id,
            created_at=s.created_at,
            updated_at=s.updated_at,
            user_id=s.user_id,
            full_name=user.full_name,
            email=user.email,
            phone=getattr(user, "phone", ""),
            assigned_hostel_id=s.hostel_id,
            hostel_name=hostel_name,
            employee_id=s.employee_id,
            join_date=s.join_date,
            employment_type=s.employment_type,
            status=s.status,
            is_active=s.is_active,
            assigned_by=assigned_by,
            assigned_date=assigned_date.date(),
        )

    def _to_detail(
        self,
        s,
        *,
        user,
        hostel_name: str,
        assigned_by: UUID,
        assigned_by_name: str,
        assigned_date: datetime,
    ) -> SupervisorDetail:
        return SupervisorDetail(
            id=s.id,
            created_at=s.created_at,
            updated_at=s.updated_at,
            user_id=user.id,
            full_name=user.full_name,
            email=user.email,
            phone=getattr(user, "phone", ""),
            profile_image_url=getattr(user, "profile_image_url", None),
            assigned_hostel_id=s.hostel_id,
            hostel_name=hostel_name,
            assigned_by=assigned_by,
            assigned_by_name=assigned_by_name,
            assigned_date=assigned_date.date(),
            employee_id=s.employee_id,
            join_date=s.join_date,
            employment_type=s.employment_type,
            shift_timing=s.shift_timing,
            status=s.status,
            is_active=s.is_active,
            termination_date=None,
            termination_reason=None,
            permissions=s.permissions or {},
            total_complaints_resolved=0,
            average_resolution_time_hours=Decimal("0"),
            last_performance_review=None,
            performance_rating=None,
            last_login=None,
            total_logins=0,
        )

    def _to_list_item(
        self,
        s,
        *,
        user,
        hostel_name: str,
    ) -> SupervisorListItem:
        return SupervisorListItem(
            id=s.id,
            user_id=user.id,
            full_name=user.full_name,
            email=user.email,
            phone=getattr(user, "phone", ""),
            hostel_name=hostel_name,
            employee_id=s.employee_id,
            employment_type=s.employment_type,
            status=s.status,
            is_active=s.is_active,
            join_date=s.join_date,
            performance_rating=None,
        )

    # CRUD
    def create_supervisor(self, data: SupervisorCreate) -> SupervisorDetail:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            user = user_repo.get(data.user_id)
            if user is None:
                raise errors.NotFoundError(f"User {data.user_id} not found")

            hostel = hostel_repo.get(data.assigned_hostel_id)
            if hostel is None:
                raise errors.NotFoundError(f"Hostel {data.assigned_hostel_id} not found")

            payload = {
                "user_id": data.user_id,
                "hostel_id": data.assigned_hostel_id,
                "employee_id": data.employee_id,
                "join_date": data.join_date,
                "employment_type": data.employment_type,
                "shift_timing": data.shift_timing,
                "status": SupervisorStatus.ACTIVE,
                "is_active": True,
                "permissions": data.permissions or {},
            }
            s = sup_repo.create(payload)  # type: ignore[arg-type]
            uow.commit()

            assigned_by_user = user_repo.get(data.assigned_by)
            assigned_by_name = assigned_by_user.full_name if assigned_by_user else ""
            assigned_date = datetime.combine(data.join_date, datetime.min.time())

            return self._to_detail(
                s,
                user=user,
                hostel_name=hostel.name,
                assigned_by=data.assigned_by,
                assigned_by_name=assigned_by_name,
                assigned_date=assigned_date,
            )

    def update_supervisor(self, supervisor_id: UUID, data: SupervisorUpdate) -> SupervisorDetail:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            s = sup_repo.get(supervisor_id)
            if s is None:
                raise errors.NotFoundError(f"Supervisor {supervisor_id} not found")

            mapping = data.model_dump(exclude_unset=True)
            for field, value in mapping.items():
                if hasattr(s, field) and field != "id":
                    setattr(s, field, value)

            uow.session.flush()  # type: ignore[union-attr]
            user = user_repo.get(s.user_id)
            hostel = hostel_repo.get(s.hostel_id)
            uow.commit()

            assigned_by = UUID(int=0)
            assigned_by_name = ""
            assigned_date = datetime.combine(s.join_date, datetime.min.time())

            return self._to_detail(
                s,
                user=user,
                hostel_name=hostel.name if hostel else "",
                assigned_by=assigned_by,
                assigned_by_name=assigned_by_name,
                assigned_date=assigned_date,
            )

    def get_supervisor(self, supervisor_id: UUID) -> SupervisorDetail:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            s = sup_repo.get(supervisor_id)
            if s is None:
                raise errors.NotFoundError(f"Supervisor {supervisor_id} not found")

            user = user_repo.get(s.user_id)
            hostel = hostel_repo.get(s.hostel_id)
            assigned_by = UUID(int=0)
            assigned_by_name = ""
            assigned_date = datetime.combine(s.join_date, datetime.min.time())

            return self._to_detail(
                s,
                user=user,
                hostel_name=hostel.name if hostel else "",
                assigned_by=assigned_by,
                assigned_by_name=assigned_by_name,
                assigned_date=assigned_date,
            )

    # Listing
    def list_supervisors_for_hostel(
        self,
        hostel_id: UUID,
        params: PaginationParams,
        *,
        status: Optional[SupervisorStatus] = None,
    ) -> PaginatedResponse[SupervisorListItem]:
        with UnitOfWork(self._session_factory) as uow:
            sup_repo = self._get_supervisor_repo(uow)
            user_repo = self._get_user_repo(uow)
            hostel_repo = self._get_hostel_repo(uow)

            supervisors = sup_repo.list_for_hostel(hostel_id, status=status)
            hostel = hostel_repo.get(hostel_id)
            hostel_name = hostel.name if hostel else ""

            items: List[SupervisorListItem] = []
            for s in supervisors:
                user = user_repo.get(s.user_id)
                if not user:
                    continue
                items.append(self._to_list_item(s, user=user, hostel_name=hostel_name))

            total = len(items)
            start = params.offset
            end = start + params.limit
            page_items = items[start:end]

            return PaginatedResponse[SupervisorListItem].create(
                items=page_items,
                total_items=total,
                page=params.page,
                page_size=params.page_size,
            )

# --- File: D:\Last Github Push\Last\HOStel-back\app\services\supervisor\__init__.py ---
# app/services/supervisor/__init__.py
"""
Supervisor-related services.

- SupervisorService:
    Core CRUD, listing, and detail for supervisors.

- SupervisorAssignmentService:
    Assign / revoke supervisors to hostels (multi-hostel support).

- SupervisorPermissionsService:
    Manage supervisor permissions and perform permission checks.

- SupervisorDashboardService:
    Supervisor dashboard aggregation (complaints, maintenance, attendance, etc.).

- SupervisorPerformanceService:
    Performance metrics & reports based on analytics tables.

- SupervisorActivityService:
    Activity log listing, details, and summaries for supervisors.
"""

from .supervisor_service import SupervisorService
from .supervisor_assignment_service import SupervisorAssignmentService
from .supervisor_permissions_service import SupervisorPermissionsService
from .supervisor_dashboard_service import SupervisorDashboardService
from .supervisor_performance_service import SupervisorPerformanceService
from .supervisor_activity_service import SupervisorActivityService

__all__ = [
    "SupervisorService",
    "SupervisorAssignmentService",
    "SupervisorPermissionsService",
    "SupervisorDashboardService",
    "SupervisorPerformanceService",
    "SupervisorActivityService",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\services\supervisor\__pycache__ =====
