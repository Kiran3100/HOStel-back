### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\deps.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\__init__.py ---
Below is a structured, file-by-file summary. Paths are shown relative to app/schemas.

app/schemas/__init__.py
Empty package initializer; exists to mark app.schemas as a Python package.
Admin Schemas (app/schemas/admin)
admin/admin_hostel_assignment.py
Schemas for linking admins to hostels and managing their assignment:
AdminHostelAssignment: response model for a single admin–hostel assignment (permissions, primary hostel, revoke info).
AssignmentCreate, AssignmentUpdate: create/update payloads for one assignment.
BulkAssignment: assign an admin to multiple hostels at once.
RevokeAssignment: payload to revoke an assignment with reason.
AssignmentList: aggregate assignments for a given admin.
HostelAdminList, HostelAdminItem: list admins associated with a given hostel.
admin/admin_override.py
Schemas for admins overriding supervisor decisions:
AdminOverrideRequest: payload describing the override (who, what entity, original vs override action, reason).
OverrideLog: response/log entry for one override.
OverrideReason: predefined override reasons.
OverrideSummary, SupervisorOverrideStats: summarized override metrics by period, type, supervisor, hostel.
admin/admin_permissions.py
Fine-grained permission model for admins:
AdminPermissions: boolean flags for many admin capabilities (rooms, students, fees, supervisors, financials, etc.).
PermissionMatrix, RolePermissions: role-based permission mapping for the system.
PermissionCheck: result of checking whether a user has a specific permission in a hostel.
admin/hostel_context.py
Multi-hostel “active context” management for admins:
HostelContext: current active hostel and quick stats for that session.
HostelSwitchRequest: request to switch active hostel.
ActiveHostelResponse: response after switching context.
ContextHistory, ContextSwitch: history of hostel context switches.
admin/hostel_selector.py
Data models backing a hostel selector UI:
HostelSelectorResponse, HostelSelectorItem: list and per-hostel cards for selection (occupancy, tasks, favorites, permissions).
RecentHostels, RecentHostelItem: recently accessed hostels.
FavoriteHostels, FavoriteHostelItem: favorite hostels list.
UpdateFavoriteRequest: add/remove favorite.
admin/multi_hostel_dashboard.py
Unified multi-hostel dashboard models:
MultiHostelDashboard: top-level dashboard for an admin managing several hostels.
AggregatedStats: cross-hostel metrics (occupancy, revenue, complaints, maintenance).
HostelQuickStats: per-hostel key stats and health status.
CrossHostelComparison, TopPerformer, BottomPerformer, HostelMetricComparison: cross-hostel comparisons and rankings.
HostelTaskSummary: per-hostel task counts by priority.
admin/__init__.py
Re-exports core admin-related schemas for convenient import:
Assignments, context switching, selector, dashboard, overrides, permissions.
Analytics Schemas (app/schemas/analytics)
analytics/booking_analytics.py
Analytics around bookings:
BookingKPI: aggregate counts & rates (conversion, cancellation, lead time).
BookingTrendPoint: time-series point with booking & revenue per day.
BookingFunnel: funnel metrics from page views to confirmations.
CancellationAnalytics: cancellation-specific stats and reasons.
BookingAnalyticsSummary: top-level booking analytics for a hostel/period.
analytics/complaint_analytics.py (dashboard-level)
Summary models for complaint analytics:
ComplaintKPI: high-level metrics (open/resolved, SLA compliance, escalation).
ComplaintTrend, ComplaintTrendPoint: trend over time.
CategoryBreakdown: per-category stats.
ComplaintDashboard: consolidated complaint dashboard payload.
analytics/custom_reports.py
Custom report builder schemas:
CustomReportField, CustomReportFilter: define fields/filters.
CustomReportRequest: specify module, fields, filters, grouping, sorting, output format.
CustomReportDefinition: saved report configuration.
CustomReportResult: generic tabular report output with summary/charts.
analytics/dashboard_analytics.py
General KPI and dashboard metrics:
KPIResponse: flexible KPI card representation.
QuickStats: high-level quick stats.
DashboardMetrics: combined KPIs, timeseries (revenue, occupancy, bookings, complaints).
TimeseriesPoint: generic timeseries value.
RoleSpecificDashboard: sections per role with cards and KPIs.
analytics/financial_analytics.py
Financial analytics for hostels/platform:
RevenueBreakdown, ExpenseBreakdown.
ProfitAndLossReport: P&L for given scope and period.
CashflowSummary, CashflowPoint.
FinancialReport: aggregate financial report with ratios and per-student/bed metrics.
analytics/occupancy_analytics.py
Occupancy-focused analytics:
OccupancyKPI, OccupancyTrendPoint: summary and daily occupancy.
ForecastData, ForecastPoint: future occupancy forecasts.
OccupancyByRoomType, OccupancyReport: full occupancy report including breakdowns and optional forecast.
analytics/platform_analytics.py
Platform-wide (multi-tenant) analytics:
PlatformMetrics: counts of hostels, users, DAU, sessions, etc.
GrowthMetrics, MonthlyMetric: hostels, revenue, users growth over time.
PlatformUsageAnalytics: API traffic, error rates, latency, resource usage.
analytics/supervisor_analytics.py
Supervisor performance analytics:
SupervisorKPI: workload & performance per supervisor.
SupervisorTrendPoint: performance over time.
SupervisorDashboardAnalytics: dashboard payload for one supervisor.
SupervisorComparison: compare multiple supervisors.
analytics/visitor_analytics.py
Visitor behavior and funnel:
VisitorFunnel: visits → registrations → bookings with conversion rates.
TrafficSourceAnalytics: per-source visits and conversion.
VisitorBehaviorAnalytics: search & engagement patterns.
analytics/__init__.py
Re-exports core analytics models by category (dashboard, financial, occupancy, complaints, visitor, booking, supervisor, platform, custom reports).
Announcement Schemas (app/schemas/announcement)
announcement/announcement_base.py
Core models for announcements:
AnnouncementBase: shared attributes (title, content, category, priority, targeting, attachments, expiry).
AnnouncementCreate: adds creator and delivery channel flags.
AnnouncementUpdate: partial update including publish state.
announcement/announcement_response.py
Read models for announcements:
AnnouncementResponse: basic list item with counts.
AnnouncementDetail: detailed view including targeting, approvals, delivery times, engagement.
AnnouncementList, AnnouncementListItem: list + summary metrics.
announcement/announcement_filters.py
Filtering, searching, exporting announcements:
AnnouncementFilterParams, SearchRequest: query & search parameters.
ArchiveRequest: bulk archival criteria.
AnnouncementExportRequest: export options (format, included info).
announcement/announcement_targeting.py
Audience targeting configurations:
TargetingConfig, AudienceSelection: describe who should receive an announcement.
TargetRooms, TargetFloors, IndividualTargeting: specialized targeting.
TargetingSummary: counts and breakdown for recipients.
BulkTargeting: multiple targeting rules and combine mode.
announcement/announcement_scheduling.py
Scheduling and recurrence:
ScheduleRequest, ScheduleConfig: schedule single announcement with optional expiry.
RecurringAnnouncement: recurring series (daily/weekly/monthly).
ScheduleUpdate, ScheduleCancel, PublishNow.
ScheduledAnnouncementsList, ScheduledAnnouncementItem: list future schedules.
announcement/announcement_approval.py
Approval workflow for announcements:
ApprovalRequest, ApprovalResponse, RejectionRequest.
ApprovalWorkflow: current approval status and timeline.
SupervisorApprovalQueue, PendingApprovalItem: queue of pending approvals.
BulkApproval: approve/reject multiple at once.
announcement/announcement_delivery.py
Delivery configuration and status:
DeliveryConfig, DeliveryChannels: channels and batch strategies.
DeliveryStatus, DeliveryReport, ChannelDeliveryStats, FailedDelivery.
BatchDelivery: batch processing progress.
RetryDelivery: retry failed deliveries.
announcement/announcement_tracking.py
Engagement tracking:
ReadReceipt (+ response).
AcknowledgmentTracking, PendingAcknowledgment, AcknowledgmentRequest.
EngagementMetrics, ReadingTime.
AnnouncementAnalytics: comprehensive analytics combining delivery & engagement.
announcement/__init__.py
Re-exports key announcement schemas: base, response, targeting, scheduling, approval, delivery, tracking, filters.
Attendance Schemas (app/schemas/attendance)
attendance/attendance_base.py
Core attendance record model:
AttendanceBase: single-day attendance for a student.
AttendanceCreate, AttendanceUpdate: create/update payloads with optional geo/device info on create.
BulkAttendanceCreate, SingleAttendanceRecord: bulk marking structure.
attendance/attendance_response.py
Response models:
AttendanceResponse: list item with names, status, times.
AttendanceDetail: full attendance record with student info, mode, location, timestamps.
AttendanceListItem: minimal list row.
DailyAttendanceSummary: summarized statistics per day.
attendance/attendance_record.py
Higher-level commands:
AttendanceRecordRequest: simple per-student mark.
BulkAttendanceRequest: bulk mark with per-student overrides.
AttendanceCorrection: correction payload for existing record.
QuickAttendanceMarkAll: mark all present with exceptions.
attendance/attendance_filters.py
Filtering and export:
AttendanceFilterParams: hostels, students, dates, statuses, modes.
DateRangeRequest: simple validated date range.
AttendanceExportRequest: export options by format and grouping.
attendance/attendance_policy.py
Policy configuration and violations:
AttendancePolicy: hostel-specific thresholds and notifications.
PolicyConfig: calculation and leave-handling rules.
PolicyUpdate: partial changes to policy.
PolicyViolation: record of a violation instance.
attendance/attendance_alert.py
Alerts on attendance anomalies:
AttendanceAlert: alert log (low attendance, late, patterns).
AlertConfig: hostel-level alert settings.
AlertTrigger: manual trigger payload.
AlertAcknowledgment, AlertList, AlertSummary: acknowledging & summarizing alerts.
attendance/attendance_report.py
Reporting and trend analysis:
AttendanceReport: full report for a student/hostel over a period with summary, daily records, trends.
AttendanceSummary: overall stats and streaks.
DailyAttendanceRecord: per-day detail.
TrendAnalysis, WeeklyAttendance, MonthlyComparison: trends and comparisons.
MonthlyReport, StudentMonthlySummary.
AttendanceComparison, ComparisonItem: comparative attendance across entities.
attendance/__init__.py
Re-exports core attendance models (base, response, record, report, policy, alert, filters).
Audit Schemas (app/schemas/audit)
audit/admin_override_log.py
Audit logs specifically for admin overrides:
AdminOverrideBase, AdminOverrideCreate: base and create payload mirroring DB.
AdminOverrideLogResponse, AdminOverrideDetail: summarized and detailed views.
AdminOverrideSummary, AdminOverrideTimelinePoint: stats and timeline aggregation.
audit/audit_log_base.py
Generic audit log entry:
AuditLogBase, AuditLogCreate: base audit schema for all modules (action, category, entity, old/new values, request context).
audit/audit_log_response.py
Response views for generic audit logs:
AuditLogResponse: list item.
AuditLogDetail: includes old/new value snapshots.
audit/audit_filters.py
Filter criteria for querying audit logs:
AuditFilterParams: filter by user, role, hostel, entity, action, time range, paging.
audit/audit_reports.py
Reporting over audit logs:
AuditSummary, UserActivitySummary.
EntityChangeSummary, EntityChangeRecord, EntityChangeHistory.
AuditReport: top-level report with summaries by entity type.
audit/supervisor_activity_log.py
Supervisor-specific activity logging:
SupervisorActivityBase, SupervisorActivityCreate: create entries for actions by supervisors.
SupervisorActivityLogResponse, SupervisorActivityDetail.
SupervisorActivityFilter: filtering/paging.
SupervisorActivitySummary, SupervisorActivityTimelinePoint: aggregated stats.
audit/__init__.py
Re-exports generic audit, supervisor activity, and admin override log schemas.
Auth Schemas (app/schemas/auth)
auth/login.py
Login and JWT token data:
LoginRequest, PhoneLoginRequest.
TokenData: payload encoded into JWT.
LoginResponse, UserLoginInfo: tokens + basic user info.
auth/otp.py
OTP (One-Time Password) flows:
OTPGenerateRequest: generate for email/phone with purpose.
OTPVerifyRequest, OTPResponse, OTPVerifyResponse.
ResendOTPRequest.
Includes validator ensuring at least email or phone is supplied.
auth/password.py
Password reset/change and strength:
PasswordResetRequest, PasswordResetConfirm (with matching & strength validation).
PasswordChangeRequest, PasswordChangeResponse.
PasswordStrengthCheck, PasswordStrengthResponse.
auth/register.py
Registration and verification:
RegisterRequest: user creation payload with role, gender, DOB and password validation.
RegisterResponse.
VerifyEmailRequest, VerifyPhoneRequest, ResendVerificationRequest.
auth/social_auth.py
Social login via Google/Facebook:
SocialAuthRequest, GoogleAuthRequest, FacebookAuthRequest.
SocialAuthResponse, SocialUserInfo: tokens + user info.
SocialProfileData: structured profile returned from providers.
auth/token.py
Token management:
Token, TokenPayload: access/refresh representation and JWT claims.
RefreshTokenRequest, RefreshTokenResponse.
TokenValidationRequest, TokenValidationResponse.
RevokeTokenRequest, LogoutRequest.
auth/__init__.py
Re-exports main auth-related schemas: login, registration, tokens, password, OTP, social auth.
Booking Schemas (app/schemas/booking)
booking/booking_base.py
Core booking model:
BookingBase: requested room type, dates, pricing, extras, source.
Validates total_amount against (quoted_rent_monthly * stay_duration_months).
BookingCreate: embeds guest and contact details for a new booking.
BookingUpdate: modify booking attributes/status.
booking/booking_response.py
Read models:
BookingResponse: summary item.
BookingDetail: full booking details incl. hostel info, assignment, status history, cancellation, conversion, payment.
BookingListItem: list card with urgency flag.
BookingConfirmation: confirmation payload for guest.
booking/booking_request.py
Alternate booking entry points:
GuestInformation: nested guest data.
BookingRequest: more structured public booking API with validator checking future check-in date.
BookingInquiry: lighter-weight inquiry model.
QuickBookingRequest: minimal booking variant.
booking/booking_approval.py
Booking approval/rejection workflows:
BookingApprovalRequest: assign room/bed, confirm pricing, require advance.
ApprovalResponse: approval results (amounts, payment next steps).
RejectionRequest: structured rejection reasons and alternatives.
BulkApprovalRequest, ApprovalSettings: automated approvals config.
booking/booking_assignment.py
Room/bed assignment for bookings:
RoomAssignment, BedAssignment: assignment records.
AssignmentRequest, BulkAssignmentRequest, SingleAssignment: payloads for assigning/reassigning.
AssignmentResponse.
ReassignmentRequest.
booking/booking_calendar.py
Booking calendar and availability:
CalendarView, DayBookings, BookingEvent, CalendarEvent: day-wise events and bookings.
AvailabilityCalendar, DayAvailability: per-day availability tracking.
booking/booking_cancellation.py
Cancellation logic:
CancellationRequest, CancellationResponse.
RefundCalculation, CancellationPolicy, CancellationCharge.
BulkCancellation for multiple bookings.
booking/booking_conversion.py
Converting bookings into students:
ConvertToStudentRequest, ConversionResponse.
ConversionChecklist, ChecklistItem.
BulkConversion, ConversionRollback.
booking/booking_modification.py
Modifications after booking:
ModificationRequest, ModificationResponse.
Specific requests: DateChangeRequest, DurationChangeRequest, RoomTypeChangeRequest.
ModificationApproval for admin to approve/deny modifications.
booking/booking_filters.py
Filters, search, export, analytics:
BookingFilterParams, BookingSearchRequest, BookingSortOptions.
BookingExportRequest: export format & fields.
BookingAnalyticsRequest: time-grouped analytics.
booking/booking_waitlist.py
Waitlist handling when full:
WaitlistRequest, WaitlistResponse.
WaitlistStatus: per-visitor queue status.
WaitlistNotification, WaitlistConversion, WaitlistCancellation.
WaitlistManagement, WaitlistEntry: admin view & operations.
booking/__init__.py
Re-exports major booking-related schemas.
Common Schemas (app/schemas/common)
common/base.py
Base Pydantic configurations and mixins:
BaseSchema: standard config (from_orm-like, enum handling, JSON encoders).
TimestampMixin, SoftDeleteMixin, UUIDMixin.
BaseDBSchema: DB entity with ID + timestamps.
BaseCreateSchema, BaseUpdateSchema, BaseResponseSchema, BaseFilterSchema.
common/enums.py
Centralized enums for:
Roles, gender, hostel/room/bed status, booking, payment (type/method/status), complaints, maintenance, attendance, leaves, announcements, meal/dietary prefs, OTP and audit categories, subscription, student/supervisor statuses, review/referral/reward statuses, notifications, devices, search/inquiry/waitlist sources, charge types, and others.
common/filters.py
Reusable filter models:
DateRangeFilter, DateTimeRangeFilter, TimeRangeFilter.
PriceRangeFilter, NumericRangeFilter.
SearchFilter, SortOptions, StatusFilter, LocationFilter, MultiSelectFilter, BooleanFilter, TextSearchFilter.
Includes validators for consistent min/max and start/end semantics.
common/mixins.py
Small mixin models for reuse:
AddressMixin, ContactMixin, LocationMixin, MediaMixin.
EmergencyContactMixin, AuditMixin, ApprovalMixin, SEOMixin.
common/pagination.py
Pagination utilities:
PaginationParams, PaginationMeta, PaginatedResponse[T] with create helper.
CursorPaginationParams, CursorPaginationMeta, CursorPaginatedResponse[T] for cursor-based pagination.
common/response.py
Standardized API response wrappers:
SuccessResponse[T], ErrorDetail, ErrorResponse, MessageResponse.
BulkOperationResponse.
Specialized error responses: ValidationErrorResponse, NotFoundResponse, UnauthorizedResponse, ForbiddenResponse, ConflictResponse, RateLimitResponse.
common/__init__.py
Re-exports core base types, many enums, pagination, response, and basic filter types for convenience.
Complaint Schemas (app/schemas/complaint)
complaint/complaint_base.py
Core complaint model:
ComplaintBase: hostel, raiser, category, priority, location, attachments.
ComplaintCreate.
ComplaintUpdate: mutable fields and status.
ComplaintStatusUpdate: explicitly update status with notes.
complaint/complaint_response.py
Read models:
ComplaintResponse: list item with SLA/age info.
ComplaintDetail: full complaint lifecycle, assignment, escalation, override, resolution, feedback.
ComplaintListItem: simplified listing.
ComplaintSummary: dashboard summary counts and averages.
complaint/complaint_assignment.py
Assignment to staff:
AssignmentRequest, AssignmentResponse.
ReassignmentRequest, BulkAssignment, UnassignRequest.
complaint/complaint_resolution.py
Resolution/closure:
ResolutionRequest, ResolutionResponse, ResolutionUpdate.
ReopenRequest, CloseRequest.
complaint/complaint_escalation.py
Escalation handling:
EscalationRequest, EscalationResponse.
EscalationHistory, EscalationEntry.
AutoEscalationRule: SLA-based escalation settings.
complaint/complaint_feedback.py
Post-resolution feedback:
FeedbackRequest, FeedbackResponse.
FeedbackSummary: entity-level stats.
FeedbackAnalysis, RatingTrendPoint.
complaint/complaint_comments.py
Comments and mentions:
CommentCreate, CommentResponse, CommentList.
CommentUpdate, CommentDelete.
MentionNotification: mention alerts.
complaint/complaint_filters.py
Filtering/search/export:
ComplaintFilterParams, ComplaintSearchRequest, ComplaintSortOptions.
ComplaintExportRequest: export format and fields.
complaint/complaint_analytics.py (under complaint folder)
Complaint-specific analytics variants (parallel to analytics module but more detailed for this domain):
ComplaintAnalytics, ResolutionMetrics, CategoryAnalysis, CategoryMetrics, ComplaintTrendPoint.
StaffPerformance, ComplaintHeatmap, RoomComplaintCount.
complaint/__init__.py
Re-exports main complaint schemas.
Fee Structure Schemas (app/schemas/fee_structure)
fee_structure/fee_base.py
Base fee configuration:
FeeStructureBase: per-hostel/per-room-type fee attributes including mess and utilities (with ChargeType).
FeeStructureCreate, FeeStructureUpdate.
fee_structure/fee_config.py
Fee calculation configuration:
ChargesBreakdown: computed components (rent, mess, utilities).
FeeConfiguration: final configuration used to calculate total fees for a case.
fee_structure/fee_response.py
Read models:
FeeStructureResponse: one fee row.
FeeDetail: summarized first-month and recurring totals for a room type.
FeeStructureList: all structures for a hostel.
fee_structure/__init__.py
Re-exports base, response, and config schemas.
File Schemas (app/schemas/file)
file/file_upload.py
Generic upload initialization and completion:
FileUploadInitRequest, FileUploadInitResponse: for pre-signed URLs or similar.
FileUploadCompleteRequest: notify backend upload completed.
file/file_response.py
File metadata and listing:
FileMetadata: type, size, tags, custom metadata.
FileInfo: full record with ownership, URLs, audit.
FileURL: simple URL + expiry.
FileListResponse: basic paginated-ish listing.
file/image_upload.py
Image-specific uploads:
ImageUploadInitRequest: constraints and usage context.
ImageVariant, ImageUploadInitResponse: planned/generated variants.
ImageProcessingResult.
file/document_upload.py
Document uploads:
DocumentUploadInitRequest, DocumentUploadInitResponse.
DocumentValidationResult: backend validation outcome.
DocumentInfo, DocumentList: document-level views and verification flags.
file/__init__.py
Re-exports key file, image, and document upload/response types.
Hostel Schemas (app/schemas/hostel)
hostel/hostel_base.py
Base hostel definition:
HostelBase: details, address, contact, hostel type, pricing, amenities, rules, policies, SEO-like fields.
Validators for slug formatting and list cleanup.
HostelCreate: creation variant with required fields.
HostelUpdate: partial updates.
HostelMediaUpdate, HostelSEOUpdate: targeted updates.
hostel/hostel_response.py
Hostels for internal/admin views:
HostelResponse: basic card with status and key metrics.
HostelDetail: full internal details including capacity, policies, media, SEO, flags.
HostelListItem: minimal list representation.
HostelStats: aggregated stats for occupancy, revenue, complaints, bookings, reviews.
hostel/hostel_public.py
Public-facing hostel representations:
PublicHostelCard: listing card for visitors.
PublicHostelProfile: full public profile with ratings, policies, media, room types.
PublicRoomType: specific room type pricing and availability.
PublicHostelList: results with filters summary.
hostel/hostel_admin.py
Admin-specific view and settings:
HostelAdminView: summary for admins with status, stats, subscription, performance.
HostelSettings: configuration toggles (booking, payments, attendance, notifications, mess).
HostelVisibilityUpdate, HostelCapacityUpdate, HostelStatusUpdate.
hostel/hostel_analytics.py
Hostel-level analytics (duplicate name but distinct from /analytics):
HostelAnalytics: aggregate occupancy, revenue, bookings, complaints, reviews for a hostel over period.
Submodels: OccupancyAnalytics, OccupancyDataPoint, RevenueAnalytics, RevenueDataPoint, BookingAnalytics, BookingDataPoint, ComplaintAnalytics, ReviewAnalytics, RatingDataPoint.
HostelOccupancyStats, RoomTypeOccupancy, HostelRevenueStats, MonthlyRevenue, AnalyticsRequest.
hostel/hostel_filter.py
Filter, sorting, advanced filters, bulk filters for hostels:
HostelFilterParams, HostelSortOptions, AdvancedFilters, BulkFilterParams.
hostel/hostel_search.py
Search request/response, facets for hostels:
HostelSearchRequest: rich filters and sorting.
HostelSearchResponse: with facets and filters summary.
SearchFacets, FacetItem, PriceRangeFacet, RatingFacet.
HostelSearchFilters: extra advanced filters (gender, facilities, rules, date).
hostel/hostel_comparison.py
Hostel comparison tool:
HostelComparisonRequest: up to 4 hostels IDs.
ComparisonResult, ComparisonItem: detailed per-hostel comparison attributes.
RoomTypeComparison.
ComparisonSummary, PriceComparison, AmenityComparison.
hostel/__init__.py
Re-exports base, public/admin, search/filter, analytics, and comparison models.
Inquiry Schemas (app/schemas/inquiry)
inquiry/inquiry_base.py
Base visitor inquiry:
InquiryBase: contact info, preferences, message, source, status.
InquiryCreate: create payload.
inquiry/inquiry_response.py
Read models:
InquiryResponse: basic list item.
InquiryDetail: full view with status, contact details, notes.
InquiryListItem: minimal list representation.
inquiry/inquiry_status.py
Status changes and assignment:
InquiryStatusUpdate: change status with optional notes.
InquiryAssignment: assign to admin/staff.
InquiryTimelineEntry: tracks lifecycle.
inquiry/__init__.py
Exposes base, response, and status schemas.
Leave Schemas (app/schemas/leave)
leave/leave_base.py
Base leave application:
LeaveBase: type, dates, total_days, reason, contacts, document URL, with validator for total_days consistency.
LeaveCreate, LeaveUpdate.
leave/leave_application.py
Student-facing leave flows:
LeaveApplicationRequest: simplified submission.
LeaveCancellationRequest: request to cancel an existing leave.
leave/leave_approval.py
Approval workflow:
LeaveApprovalRequest: supervisor/admin approval or rejection.
LeaveApprovalResponse: updated status and metadata.
leave/leave_balance.py
Leave balances:
LeaveBalance: per-type counts.
LeaveBalanceSummary: overall annual summary per student.
leave/leave_response.py
Read models:
LeaveResponse: list item.
LeaveDetail: detailed record with approval/rejection, reasons, cancellations.
LeaveListItem: compact listing.
leave/__init__.py
Re-exports main leave schemas.
Maintenance Schemas (app/schemas/maintenance)
maintenance/maintenance_base.py
Base maintenance request:
MaintenanceBase: hostel, requester, category, priority, issue type, location, photos.
MaintenanceCreate.
MaintenanceUpdate: status and cost updates.
MaintenanceStatusUpdate.
maintenance/maintenance_response.py
Read models:
MaintenanceResponse: list item summary.
MaintenanceDetail: full lifecycle, assignment, vendor, costs, photos, QC, preventive fields.
RequestListItem, MaintenanceSummary: admin list and summary metrics.
maintenance/maintenance_request.py
Request submission flows:
MaintenanceRequest: simple request model.
RequestSubmission: richer supervisor submission including estimated cost, vendor, days.
EmergencyRequest: emergency incident details.
maintenance/maintenance_assignment.py
Task/vendor assignment:
TaskAssignment: record of assignment to staff.
VendorAssignment, AssignmentUpdate, BulkAssignment.
AssignmentHistory, AssignmentEntry.
maintenance/maintenance_approval.py
Cost approval:
ApprovalRequest, ApprovalResponse.
ThresholdConfig: cost thresholds for approvals.
ApprovalWorkflow.
RejectionRequest.
maintenance/maintenance_completion.py
Completion and QC:
CompletionRequest: work done, materials used, costs, timeline.
MaterialItem.
QualityCheck, ChecklistItem.
CompletionResponse, CompletionCertificate.
maintenance/maintenance_cost.py
Cost tracking and budgets:
CostTracking: per-request financial breakdown.
BudgetAllocation, CategoryBudget.
ExpenseReport, MonthlyExpense, ExpenseItem.
VendorInvoice, InvoiceLineItem.
CostAnalysis: trends and ratios.
maintenance/maintenance_filters.py
Filtering and exports:
MaintenanceFilterParams, SearchRequest.
MaintenanceExportRequest.
maintenance/maintenance_schedule.py
Preventive maintenance:
PreventiveSchedule, ScheduleCreate, ScheduleUpdate.
ScheduleChecklistItem.
RecurrenceConfig.
ScheduleExecution, ChecklistResult.
ScheduleHistory, ExecutionHistoryItem.
maintenance/maintenance_analytics.py
Maintenance analytics:
MaintenanceAnalytics: high-level stats, costs, performance, trends.
TrendPoint, CostTrendPoint.
CategoryBreakdown.
VendorPerformance.
maintenance/__init__.py
Re-exports core maintenance-related schemas (base, response, request, assignment, approval, completion, schedule, cost, filters, analytics). Note: PerformanceMetrics is imported but not defined here (potential missing/typo).
Mess Schemas (app/schemas/mess)
mess/mess_menu_base.py
Base mess menu definition:
MessMenuBase: meals per day, times, special flags, dietary options.
MessMenuCreate: adds created_by.
MessMenuUpdate: partial updates.
mess/mess_menu_response.py
Read models:
MenuResponse: basic daily menu card with rating and publish status.
MenuDetail: full details with times, dietary options, approvals, ratings.
WeeklyMenu, DailyMenuSummary, MonthlyMenu: aggregated menu structures.
TodayMenu: simplified daily menu for students.
mess/meal_items.py
Meal items and dietary details:
MealItems, MenuItem: define items and dietary flags/allergens.
DietaryOptions: hostel-level options and customization flags.
NutritionalInfo: macros/micros for items.
ItemMasterList, ItemCategory: master menu catalog.
mess/menu_approval.py
Menu approval:
MenuApprovalRequest, MenuApprovalResponse.
ApprovalWorkflow.
BulkApproval.
mess/menu_duplication.py
Menu duplication and bulk creation:
DuplicateMenuRequest, DuplicateResponse.
BulkMenuCreate: generate menus across a date range from templates/patterns.
CrossHostelDuplication.
mess/menu_feedback.py
Menu feedback & quality:
FeedbackRequest, FeedbackResponse.
RatingsSummary, QualityMetrics, ItemRating.
FeedbackAnalysis: sentiment and recommendations.
mess/menu_planning.py
Planning tools:
MenuPlanRequest, WeeklyPlan, DailyMenuPlan, MonthlyPlan.
SpecialMenu, SpecialDayMenu.
MenuTemplate, MenuSuggestion.
mess/__init__.py
Re-exports menu base/response, meal items, planning, feedback, approval, duplication.
Notification Schemas (app/schemas/notification)
notification/notification_base.py
Generic notification model:
NotificationBase: recipients, type, content, priority, schedule, metadata.
NotificationCreate, NotificationUpdate.
MarkAsRead, BulkMarkAsRead, NotificationDelete.
notification/notification_response.py
Notification response & listing:
NotificationResponse, NotificationDetail.
NotificationList, NotificationListItem.
UnreadCount, NotificationSummary.
notification/notification_template.py
Templates for notifications:
TemplateCreate, TemplateUpdate, TemplateResponse.
VariableMapping, TemplatePreview, TemplatePreviewResponse, TemplateList, TemplateCategory.
notification/email_notification.py
Email-specific sending:
EmailRequest, EmailConfig.
EmailTracking, EmailTemplate, BulkEmailRequest, EmailStats.
notification/sms_notification.py
SMS-specific sending:
SMSRequest, SMSConfig.
DeliveryStatus, SMSTemplate, BulkSMSRequest, SMSStats.
notification/push_notification.py
Push notifications and devices:
PushRequest, PushConfig.
DeviceToken, DeviceRegistration, DeviceUnregistration.
PushTemplate, PushDeliveryStatus, PushStats.
notification/notification_queue.py
Queue and batch processing:
QueueStatus, QueuedNotification, BatchProcessing, QueueStats.
notification/notification_preferences.py
User-level preferences:
UserPreferences, ChannelPreferences with EmailPreferences, SMSPreferences, PushPreferences.
FrequencySettings.
PreferenceUpdate, UnsubscribeRequest.
notification/notification_routing.py
Routing configurations:
RoutingConfig, RoutingRule.
HierarchicalRouting, EscalationRouting, EscalationLevel.
NotificationRoute.
notification/__init__.py
Re-exports base, responses, templates, channels, queue, preferences, routing.
Payment Schemas (app/schemas/payment)
payment/payment_base.py
Base payment schema:
PaymentBase: payer, hostel, type, amount, period, method, due_date.
PaymentCreate: adds transaction and collector.
PaymentUpdate: status, timestamps, failure, receipt info.
payment/payment_response.py
Payment read models:
PaymentResponse: list card summarizing payment.
PaymentDetail: full payment record with relationships, gateway data, refunds, reminders.
PaymentReceipt: printable receipt info.
PaymentListItem, PaymentSummary: summary for student/hostel.
payment/payment_request.py
Payment initiation and manual logging:
PaymentRequest: for online gateway payments.
PaymentInitiation: response with gateway order/token.
ManualPaymentRequest: cash/cheque/bank_transfer recording.
BulkPaymentRequest, SinglePaymentRecord.
payment/payment_gateway.py
Gateway integration:
GatewayRequest, GatewayResponse: order creation and gateway state.
GatewayWebhook, GatewayCallback: incoming webhook and handling.
GatewayRefundRequest, GatewayRefundResponse.
payment/payment_refund.py
Refund lifecycle:
RefundRequest, RefundResponse.
RefundStatus, RefundApproval, RefundList, RefundListItem.
payment/payment_ledger.py
Ledger/statement:
LedgerEntry, LedgerSummary, AccountStatement.
TransactionHistory, TransactionItem.
BalanceAdjustment, WriteOff.
payment/payment_reminder.py
Payment reminder configuration & logs:
ReminderConfig.
ReminderLog, SendReminderRequest, ReminderBatch, ReminderStats.
payment/payment_schedule.py
Recurring payment schedules:
PaymentSchedule, ScheduleCreate, ScheduleUpdate.
ScheduleGeneration, ScheduledPaymentGenerated.
BulkScheduleCreate, ScheduleSuspension.
payment/payment_filters.py
Filtering/report/export:
PaymentFilterParams, PaymentSearchRequest.
PaymentReportRequest: grouped report generation options.
PaymentExportRequest: export fields and format.
payment/__init__.py
Re-exports major payment, gateway, refund, schedule, reminder, ledger, and filter models.
Referral Schemas (app/schemas/referral)
referral/referral_base.py
Core referral record:
ReferralBase: program, referrer, referee identifiers, referral code, status.
ReferralCreate.
referral/referral_code.py
Referral code management:
ReferralCodeGenerate, ReferralCodeResponse.
CodeValidationRequest, CodeValidationResponse.
referral/referral_program_base.py
Referral program definition:
ReferralProgramBase: reward types/amounts, thresholds, validity.
ProgramCreate, ProgramUpdate.
referral/referral_program_response.py
Read-only program responses:
ProgramResponse, ProgramList.
referral/referral_response.py
Referral record read models:
ReferralResponse: details about one referral + reward statuses.
ReferralStats: per-user aggregated stats.
referral/referral_rewards.py
Reward configuration and payouts:
RewardConfig: min payout & methods.
RewardTracking: per-user accumulated rewards.
PayoutRequest, PayoutRequestResponse.
referral/__init__.py
(Empty) initializer; no exports defined in snippet.
Review Schemas (app/schemas/review)
review/review_base.py
Base review model:
ReviewBase: hostel, reviewer, ratings (overall + aspects), text, photos.
Rounds overall rating to nearest 0.5.
ReviewCreate, ReviewUpdate.
review/review_response.py
Read models:
ReviewResponse: basic review list card.
ReviewDetail: full content, ratings, moderation flags, hostel response.
HostelResponseDetail.
ReviewListItem: trimmed list view.
ReviewSummary: summary for a hostel.
review/review_submission.py
Public submission flows:
ReviewSubmissionRequest: visitor submission including verification, detailed ratings, photos, recommendations, stay details, guidelines agreement.
DetailedRatings.
VerifiedReview: marking/recording verified reviews.
ReviewGuidelines.
ReviewEligibility: logic to check if user can submit/edit.
review/review_filters.py
Filtering/search/export:
ReviewFilterParams, SearchRequest, SortOptions.
ReviewExportRequest.
review/review_moderation.py
Moderation workflow:
ModerationRequest, ModerationResponse.
ModerationQueue, PendingReview.
ApprovalWorkflow, BulkModeration, ModerationStats.
review/review_voting.py
Helpfulness voting:
VoteRequest, VoteResponse.
HelpfulnessScore.
VoteHistory, VoteHistoryItem, RemoveVote.
review/review_response_schema.py
Hostel/owner responses to reviews:
HostelResponseCreate, OwnerResponse, ResponseUpdate.
ResponseGuidelines, ResponseStats.
review/review_analytics.py
Analytics for reviews:
ReviewAnalytics, RatingDistribution, TrendAnalysis, MonthlyRating.
SentimentAnalysis, AspectAnalysis, CompetitorComparison.
review/__init__.py
Re-exports core review, submission, moderation, voting, hostel response, filters, and analytics.
Room Schemas (app/schemas/room)
room/room_base.py
Base room definition:
RoomBase: hostel, number, type, capacity, pricing, specifications, amenities, availability flags, media.
RoomCreate.
RoomUpdate, BulkRoomCreate.
RoomPricingUpdate, RoomStatusUpdate.
room/room_response.py
Room read models:
RoomResponse: summary.
RoomDetail: full details including beds.
BedDetail.
RoomListItem.
RoomWithBeds, BedInfo.
RoomOccupancyStats.
room/bed_base.py
Bed management:
BedBase, BedCreate, BedUpdate.
BulkBedCreate.
BedAssignmentRequest, BedReleaseRequest.
room/bed_response.py
Bed read models:
BedResponse: single bed record.
BedAvailability.
BedAssignment.
BedHistory, BedAssignmentHistory.
room/room_availability.py
Availability checking/calendar:
RoomAvailabilityRequest, AvailabilityResponse.
AvailableRoom.
AvailabilityCalendar, DayAvailability, BookingInfo.
room/__init__.py
Re-exports core room and bed schemas plus availability.
Search Schemas (app/schemas/search)
search/search_analytics.py
Stats around search terms:
SearchTermStats: counts, avg results, zero-result stats.
SearchAnalytics: aggregated metrics and lists of top and zero-result terms.
search/search_autocomplete.py
Autocomplete:
AutocompleteRequest: prefix-based request.
Suggestion, AutocompleteResponse.
search/search_filters.py
Simple filter blocks:
PriceFilter, RatingFilter, AmenityFilter.
search/search_request.py
Search API request shapes:
BasicSearchRequest.
AdvancedSearchRequest: multiple filters, geo radius, sort, pagination.
search/search_response.py
Search results:
SearchResultItem: attaches a score to PublicHostelCard.
FacetBucket, FacetedSearchResponse.
search/search_sort.py
Sort criteria:
SortCriteria: simple sort-by and order.
search/__init__.py
Empty initializer (no exports shown).
Student Schemas (app/schemas/student)
student/student_base.py
Base student model (hostel context):
StudentBase: linking user to hostel, room, bed; guardian, institutional or employment info; dates; finances; mess and dietary details, with validation for checkout after check-in.
StudentCreate: includes optional origin booking.
StudentUpdate: partial updates including status.
student/student_response.py
Read models:
StudentResponse: list view summarizing status and key fields.
StudentDetail: full profile including guardian, institution, employment, financials, documents.
StudentProfile: public-facing minimal profile.
StudentListItem: admin list row.
StudentFinancialInfo: detailed financials.
StudentContactInfo: contact/guardian/emergency info.
student/student_profile.py
Student profile (as extension of user):
StudentProfileCreate, StudentProfileUpdate: for initial capture and updates (guardian, institution, employment, preferences).
StudentDocuments, DocumentInfo: document management.
DocumentUploadRequest, DocumentVerificationRequest.
StudentPreferences: toggles on mess, notifications, privacy.
student/student_dashboard.py
Student dashboard view:
StudentDashboard: overview.
StudentFinancialSummary, AttendanceSummary, StudentStats.
RecentPayment, RecentComplaint, PendingLeave, RecentAnnouncement, TodayMessMenu.
student/student_filters.py
Filtering/search/bulk ops:
StudentFilterParams, StudentSearchRequest, StudentSortOptions.
StudentExportRequest, StudentBulkActionRequest.
student/student_room_history.py
Room history and transfers:
RoomHistoryResponse, RoomHistoryItem.
RoomTransferRequest, RoomTransferApproval, RoomTransferStatus.
BulkRoomTransfer, SingleTransfer.
student/__init__.py
Re-exports primary base, response, profile, room history, dashboard, and filter schemas.
Subscription Schemas (app/schemas/subscription)
subscription/subscription_plan_base.py
Plan definition:
SubscriptionPlanBase: plan name, type, pricing, feature flags, limits, visibility.
PlanCreate, PlanUpdate.
subscription/subscription_plan_response.py
Plan read models:
PlanResponse.
PlanFeatures: user-friendly feature labels.
PlanComparison: cross-plan feature matrix.
subscription/subscription_base.py
Hostel subscription instance:
SubscriptionBase: which hostel, which plan, billing cycle, period, auto-renew, status.
SubscriptionCreate: adds optional trial.
SubscriptionUpdate.
subscription/subscription_response.py
Subscription read models:
SubscriptionResponse: details for one subscription.
BillingHistoryItem, BillingHistory: historical billing info.
subscription/subscription_billing.py
Billing & invoicing:
BillingCycleInfo.
GenerateInvoiceRequest, InvoiceInfo.
subscription/subscription_cancellation.py
Cancellation:
CancellationRequest, CancellationResponse.
subscription/commission.py
Booking commission logic:
CommissionConfig: global defaults and per-plan overrides.
BookingCommissionResponse.
CommissionSummary.
subscription/subscription_upgrade.py
Upgrade/downgrade:
UpgradeRequest, UpgradePreview, DowngradeRequest.
subscription/__init__.py
(Empty) initializer; no explicit exports shown.
Supervisor Schemas (app/schemas/supervisor)
supervisor/supervisor_base.py
Base supervisor model:
SupervisorBase: relationship to user and hostel, employment details.
SupervisorCreate: includes assigner and initial permissions.
SupervisorUpdate.
SupervisorStatusUpdate.
SupervisorReassignment.
supervisor/supervisor_response.py
Read models:
SupervisorResponse.
SupervisorDetail: full details including permissions and performance metrics.
SupervisorListItem, SupervisorSummary.
supervisor/supervisor_profile.py
Supervisor profile and employment summary:
SupervisorProfile: aggregated view with employment, permissions, performance.
SupervisorEmployment.
PerformanceSummary.
SupervisorProfileUpdate: self-editable fields.
supervisor/supervisor_permissions.py
Supervisor permissions:
SupervisorPermissions: boolean flags and thresholds across many modules.
PermissionUpdate: generic update by key, with validation.
PermissionCheckRequest, PermissionCheckResponse.
BulkPermissionUpdate.
PermissionTemplate, ApplyPermissionTemplate.
supervisor/supervisor_assignment.py
Assignment to hostels:
SupervisorAssignment: response model.
AssignmentRequest, AssignmentUpdate.
RevokeAssignmentRequest, AssignmentTransfer.
supervisor/supervisor_activity.py
Activity logs & analytics (distinct from audit version):
SupervisorActivityLog: list item response.
ActivityDetail, ActivitySummary, TopActivity, ActivityTimelinePoint.
ActivityFilterParams.
ActivityExportRequest.
supervisor/supervisor_dashboard.py
Supervisor dashboard:
SupervisorDashboard, DashboardMetrics, TaskSummary.
RecentComplaintItem, RecentMaintenanceItem, PendingLeaveItem.
TodaySchedule, ScheduledMaintenanceItem, ScheduledMeeting, DashboardAlert.
QuickActions, QuickAction.
supervisor/supervisor_performance.py
Performance metrics & reviews:
PerformanceMetrics, PerformanceReport.
ComplaintPerformance, AttendancePerformance, MaintenancePerformance.
PerformanceTrendPoint, PeerComparison, MetricComparison, PeriodComparison.
PerformanceReview, PerformanceReviewResponse.
PerformanceGoal, PerformanceGoalProgress.
supervisor/__init__.py
Re-exports key supervisor base, response, profile, permissions, assignment, activity, dashboard, and performance schemas.
User Schemas (app/schemas/user)
user/user_base.py
Base user model:
UserBase: email, phone, full name, role, gender, DOB, profile image; age validator.
UserCreate: adds password with strength validation.
UserUpdate.
UserAddressUpdate, UserEmergencyContactUpdate (via mixins).
user/user_profile.py
Profile updates:
ProfileUpdate: personal and address fields.
ProfileImageUpdate.
ContactInfoUpdate.
NotificationPreferencesUpdate: top-level toggles for per-user notifications.
user/user_response.py
User read models:
UserResponse: basic info.
UserDetail: extended info including address and verification states.
UserListItem: admin list.
UserProfile: public profile.
user/user_session.py
Sessions management:
UserSession: DB record for sessions.
SessionInfo, ActiveSessionsList.
RevokeSessionRequest, RevokeAllSessionsRequest.
user/__init__.py
Re-exports user base, responses, profile updates, and session schemas.
Visitor Schemas (app/schemas/visitor)
visitor/visitor_base.py
Base visitor profile:
VisitorBase: preferences (room type, budget, cities, amenities), favorites, notification preferences.
VisitorCreate, VisitorUpdate.
visitor/visitor_response.py
Visitor read models:
VisitorResponse: summary of preferences and stats.
VisitorProfile: public info.
VisitorDetail: full visitor activity and preferences.
visitor/visitor_preferences.py
Detailed preferences & saved searches:
VisitorPreferences: comprehensive preference model and notification triggers; budget validator.
PreferenceUpdate.
SearchPreferences, SavedSearch.
visitor/visitor_dashboard.py
Visitor dashboard:
VisitorDashboard: high-level overview.
SavedHostels, SavedHostelItem.
BookingHistory, BookingHistoryItem.
RecentSearch, RecentlyViewedHostel, RecommendedHostel.
PriceDropAlert, AvailabilityAlert.
visitor/visitor_favorites.py
Favorites/wishlist:
FavoriteRequest, FavoritesList, FavoriteHostelItem, FavoriteUpdate, FavoritesExport, FavoriteComparison.
visitor/__init__.py
Re-exports core visitor base, response, preferences, dashboard, and favorites schemas.



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1 =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\router.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\admin =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\admin\assignments.py ---
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.admin.admin_hostel_assignment import (
    AdminHostelAssignment,
    AssignmentCreate,
    AssignmentUpdate,
    BulkAssignment,
    RevokeAssignment,
    AssignmentList,
    HostelAdminList,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.admin import AdminHostelAssignmentService

router = APIRouter(prefix="/assignments")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


# -------- Admin → Hostels -------- #


@router.get(
    "/admins/{admin_id}",
    response_model=AssignmentList,
    summary="List hostel assignments for an admin",
)
async def list_admin_assignments(
    admin_id: UUID = Path(..., description="Admin ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentList:
    """
    Return all hostel assignments for a given admin, including primary flags and permissions.
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.list_assignments_for_admin(admin_id=admin_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/admins/{admin_id}",
    response_model=AdminHostelAssignment,
    status_code=status.HTTP_201_CREATED,
    summary="Assign an admin to a hostel",
)
async def create_admin_assignment(
    admin_id: UUID,
    payload: AssignmentCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> AdminHostelAssignment:
    """
    Create a single admin↔hostel assignment.

    Enforces:
    - Uniqueness per (admin, hostel)
    - At most one primary hostel per admin
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.create_assignment(admin_id=admin_id, data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/admins/{admin_id}/{assignment_id}",
    response_model=AdminHostelAssignment,
    summary="Update admin↔hostel assignment",
)
async def update_admin_assignment(
    admin_id: UUID,
    assignment_id: UUID,
    payload: AssignmentUpdate,
    uow: UnitOfWork = Depends(get_uow),
) -> AdminHostelAssignment:
    """
    Update assignment metadata (permissions, primary flag, etc.).
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.update_assignment(
            admin_id=admin_id,
            assignment_id=assignment_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/admins/{admin_id}/bulk",
    response_model=List[AdminHostelAssignment],
    summary="Bulk assign admin to multiple hostels",
)
async def bulk_assign_admin(
    admin_id: UUID,
    payload: BulkAssignment,
    uow: UnitOfWork = Depends(get_uow),
) -> List[AdminHostelAssignment]:
    """
    Bulk-assign an admin to multiple hostels in one call.
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.bulk_assign(admin_id=admin_id, data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/admins/{admin_id}/{assignment_id}/revoke",
    response_model=AdminHostelAssignment,
    summary="Revoke admin↔hostel assignment",
)
async def revoke_admin_assignment(
    admin_id: UUID,
    assignment_id: UUID,
    payload: RevokeAssignment,
    uow: UnitOfWork = Depends(get_uow),
) -> AdminHostelAssignment:
    """
    Revoke an assignment with a reason; typically marks it inactive and records revoked_date.
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.revoke_assignment(
            admin_id=admin_id,
            assignment_id=assignment_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


# -------- Hostel → Admins -------- #


@router.get(
    "/hostels/{hostel_id}",
    response_model=HostelAdminList,
    summary="List admins for a hostel",
)
async def list_hostel_admins(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> HostelAdminList:
    """
    List all admins assigned to a given hostel, with metadata.
    """
    service = AdminHostelAssignmentService(uow)
    try:
        return service.list_admins_for_hostel(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\admin\dashboard.py ---
from __future__ import annotations

from datetime import date
from fastapi import APIRouter, Depends, HTTPException, Query, status

from api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.analytics.platform_analytics import (
    PlatformMetrics,
    GrowthMetrics,
    PlatformUsageAnalytics,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.admin import SuperAdminDashboardService

router = APIRouter(prefix="/dashboard")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/platform/metrics/latest",
    response_model=PlatformMetrics,
    summary="Get latest platform-wide metrics (super admin)",
)
async def get_latest_platform_metrics(
    uow: UnitOfWork = Depends(get_uow),
) -> PlatformMetrics:
    """
    Fetch the latest platform-level metrics snapshot.

    Backed by SuperAdminDashboardService.
    """
    service = SuperAdminDashboardService(uow)
    try:
        return service.get_latest_platform_metrics()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/platform/growth",
    response_model=GrowthMetrics,
    summary="Get growth metrics for a period (super admin)",
)
async def get_growth_metrics(
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> GrowthMetrics:
    """
    Fetch growth metrics (hostels, revenue, users) for the given period.
    """
    service = SuperAdminDashboardService(uow)
    try:
        return service.get_growth_metrics(period_start=period_start, period_end=period_end)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/platform/usage/latest",
    response_model=PlatformUsageAnalytics,
    summary="Get latest platform usage analytics (super admin)",
)
async def get_latest_platform_usage(
    uow: UnitOfWork = Depends(get_uow),
) -> PlatformUsageAnalytics:
    """
    Fetch the latest API/platform usage analytics snapshot.
    """
    service = SuperAdminDashboardService(uow)
    try:
        return service.get_latest_platform_usage()
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\admin\hostels.py ---
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.hostel.hostel_base import HostelCreate, HostelUpdate
from app.schemas.hostel.hostel_response import HostelResponse, HostelDetail
from app.schemas.hostel.hostel_filter import HostelFilterParams
from app.services.common.unit_of_work import UnitOfWork
from app.services.hostel import HostelService

router = APIRouter(prefix="/hostels")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "",
    response_model=List[HostelResponse],
    summary="List hostels (admin view)",
)
async def list_hostels(
    filters: HostelFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> List[HostelResponse]:
    """
    List hostels for admin users.

    Uses HostelService.list_hostels with HostelFilterParams.
    """
    service = HostelService(uow)
    try:
        return service.list_hostels(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "",
    response_model=HostelDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new hostel",
)
async def create_hostel(
    payload: HostelCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> HostelDetail:
    """
    Create a new hostel.

    Ensures slug uniqueness and applies default flags.
    """
    service = HostelService(uow)
    try:
        return service.create_hostel(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{hostel_id}",
    response_model=HostelDetail,
    summary="Get hostel details (admin)",
)
async def get_hostel(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> HostelDetail:
    """
    Retrieve detailed hostel information for admin users.
    """
    service = HostelService(uow)
    try:
        return service.get_hostel(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{hostel_id}",
    response_model=HostelDetail,
    summary="Update a hostel (admin)",
)
async def update_hostel(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: HostelUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> HostelDetail:
    """
    Partially update hostel fields.

    Delegates to HostelService.update_hostel.
    """
    service = HostelService(uow)
    try:
        return service.update_hostel(hostel_id=hostel_id, data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\admin\multi_hostel.py ---
from __future__ import annotations

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from api.deps import get_uow, get_current_active_user
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.models.core import User
from app.schemas.admin.multi_hostel_dashboard import MultiHostelDashboard
from app.services.common.unit_of_work import UnitOfWork
from app.services.admin import MultiHostelDashboardService

router = APIRouter(prefix="/multi-hostel")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/dashboard",
    response_model=MultiHostelDashboard,
    summary="Get multi-hostel dashboard for an admin",
)
async def get_multi_hostel_dashboard(
    admin_id: Optional[UUID] = Query(
        None,
        description="Admin ID (optional; if omitted, resolved from current user)",
    ),
    current_user: User = Depends(get_current_active_user),
    uow: UnitOfWork = Depends(get_uow),
) -> MultiHostelDashboard:
    """
    Build a consolidated dashboard for an admin managing multiple hostels.

    If `admin_id` is not provided, it is derived from the current user's admin profile.
    """
    # Derive admin_id from current user if not explicitly provided
    if admin_id is None:
        admin_profile = getattr(current_user, "admin_profile", None)
        if admin_profile is None:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Current user is not an admin",
            )
        admin_id = admin_profile.id

    service = MultiHostelDashboardService(uow)
    try:
        return service.get_dashboard(admin_id=admin_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\admin\overrides.py ---
from __future__ import annotations

from datetime import date
from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.admin.admin_override import (
    AdminOverrideRequest,
    OverrideLog,
    OverrideSummary,
    SupervisorOverrideStats,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.admin import AdminOverrideService

router = APIRouter(prefix="/overrides")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "",
    response_model=OverrideLog,
    status_code=status.HTTP_201_CREATED,
    summary="Create an admin override",
)
async def create_admin_override(
    payload: AdminOverrideRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> OverrideLog:
    """
    Record an admin override of a supervisor decision.

    Also expected to create generic audit entries internally.
    """
    service = AdminOverrideService(uow)
    try:
        return service.create_override(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/entity/{entity_type}/{entity_id}",
    response_model=List[OverrideLog],
    summary="List overrides for a specific entity",
)
async def list_overrides_for_entity(
    entity_type: str = Path(..., description="Entity type (complaint, maintenance, leave, etc.)"),
    entity_id: UUID = Path(..., description="Entity ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> List[OverrideLog]:
    """
    Fetch all overrides applied to a particular entity.
    """
    service = AdminOverrideService(uow)
    try:
        return service.list_overrides_for_entity(entity_type=entity_type, entity_id=entity_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/summary",
    response_model=OverrideSummary,
    summary="Get override summary for a period",
)
async def get_override_summary(
    hostel_id: Optional[UUID] = Query(None, description="Filter by hostel"),
    supervisor_id: Optional[UUID] = Query(None, description="Filter by supervisor"),
    start_date: Optional[date] = Query(None, description="Start date (inclusive)"),
    end_date: Optional[date] = Query(None, description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> OverrideSummary:
    """
    Summarize overrides over a period, optionally filtered by hostel/supervisor.
    """
    service = AdminOverrideService(uow)
    try:
        return service.get_override_summary(
            hostel_id=hostel_id,
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/supervisors/{supervisor_id}/stats",
    response_model=SupervisorOverrideStats,
    summary="Get override stats for a supervisor",
)
async def get_supervisor_override_stats(
    supervisor_id: UUID = Path(..., description="Supervisor ID"),
    start_date: Optional[date] = Query(None),
    end_date: Optional[date] = Query(None),
    uow: UnitOfWork = Depends(get_uow),
) -> SupervisorOverrideStats:
    """
    Supervisor-specific override statistics (counts, types, trends).
    """
    service = AdminOverrideService(uow)
    try:
        return service.get_supervisor_override_stats(
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\admin\permissions.py ---
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api.deps import get_uow
from app.core.exceptions import (
    ServiceError,
    NotFoundError,
    ValidationError,
    ConflictError,
)
from app.schemas.admin.admin_permissions import (
    PermissionMatrix,
    RolePermissions,
    PermissionCheck,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.admin import PermissionMatrixService

router = APIRouter(prefix="/permissions")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/matrix",
    response_model=PermissionMatrix,
    summary="Get global role→permissions matrix",
)
async def get_permission_matrix(
    uow: UnitOfWork = Depends(get_uow),
) -> PermissionMatrix:
    """
    Fetch the current role→permissions matrix.

    Backed by PermissionMatrixService.
    """
    service = PermissionMatrixService(uow)
    try:
        return service.get_matrix()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/matrix",
    response_model=PermissionMatrix,
    summary="Update global role→permissions matrix",
)
async def update_permission_matrix(
    payload: PermissionMatrix,
    uow: UnitOfWork = Depends(get_uow),
) -> PermissionMatrix:
    """
    Replace the stored permission matrix.

    Should typically be restricted to super admins.
    """
    service = PermissionMatrixService(uow)
    try:
        return service.update_matrix(matrix=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/roles/{role_name}",
    response_model=RolePermissions,
    summary="Get permissions for a specific role",
)
async def get_role_permissions(
    role_name: str = Path(..., description="Role name (e.g. HOSTEL_ADMIN)"),
    uow: UnitOfWork = Depends(get_uow),
) -> RolePermissions:
    """
    Fetch the permissions assigned to a specific role.
    """
    service = PermissionMatrixService(uow)
    try:
        return service.get_role_permissions(role_name=role_name)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/check",
    response_model=PermissionCheck,
    summary="Check if a principal has a permission in a hostel",
)
async def check_permission(
    payload: PermissionCheck,
    uow: UnitOfWork = Depends(get_uow),
) -> PermissionCheck:
    """
    Check a single permission for a principal in the context of a hostel.

    Uses PermissionMatrixService.check_permission which bridges into RBACService.
    """
    service = PermissionMatrixService(uow)
    try:
        return service.check_permission(check=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\admin\__init__.py ---
from __future__ import annotations

from fastapi import APIRouter

from . import dashboard
from . import hostels
from . import assignments
from . import permissions
from . import overrides
from . import multi_hostel

router = APIRouter(prefix="/admin")

router.include_router(dashboard.router, tags=["Admin - Dashboard"])
router.include_router(hostels.router, tags=["Admin - Hostels"])
router.include_router(assignments.router, tags=["Admin - Assignments"])
router.include_router(permissions.router, tags=["Admin - Permissions"])
router.include_router(overrides.router, tags=["Admin - Overrides"])
router.include_router(multi_hostel.router, tags=["Admin - Multi-Hostel"])

__all__ = ["router"]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\analytics =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\analytics\bookings.py ---
from __future__ import annotations

from datetime import date
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.booking_analytics import BookingAnalyticsSummary
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingAnalyticsService

router = APIRouter(prefix="/bookings")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/summary",
    response_model=BookingAnalyticsSummary,
    summary="Get booking analytics for a hostel",
)
async def get_booking_analytics(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> BookingAnalyticsSummary:
    """
    Produce hostel booking analytics: KPIs, daily trends, funnel, cancellations, source conversions.
    """
    service = BookingAnalyticsService(uow)
    try:
        return service.get_booking_analytics(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\analytics\complaints.py ---
from __future__ import annotations

from datetime import date
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.complaint_analytics import ComplaintDashboard
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import ComplaintAnalyticsService

router = APIRouter(prefix="/complaints")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/dashboard",
    response_model=ComplaintDashboard,
    summary="Get complaint analytics dashboard for a hostel",
)
async def get_complaint_dashboard(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> ComplaintDashboard:
    """
    Compute complaint KPIs, trends, and category/priority breakdowns for a hostel.
    """
    service = ComplaintAnalyticsService(uow)
    try:
        return service.get_hostel_complaint_dashboard(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\analytics\custom.py ---
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.custom_reports import (
    CustomReportRequest,
    CustomReportResult,
    CustomReportDefinition,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import CustomReportService

router = APIRouter(prefix="/custom")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/run",
    response_model=CustomReportResult,
    summary="Run a custom analytics report",
)
async def run_custom_report(
    payload: CustomReportRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> CustomReportResult:
    """
    Execute a schema-driven custom report over payments, bookings, complaints, attendance, etc.
    """
    service = CustomReportService(uow)
    try:
        return service.run_report(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/definitions",
    response_model=CustomReportDefinition,
    status_code=status.HTTP_201_CREATED,
    summary="Create a saved custom report definition",
)
async def create_report_definition(
    payload: CustomReportDefinition,
    uow: UnitOfWork = Depends(get_uow),
) -> CustomReportDefinition:
    """
    Create and store a custom report definition for later reuse.
    """
    service = CustomReportService(uow)
    try:
        return service.create_definition(definition=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/definitions",
    response_model=List[CustomReportDefinition],
    summary="List saved custom report definitions",
)
async def list_report_definitions(
    uow: UnitOfWork = Depends(get_uow),
) -> List[CustomReportDefinition]:
    """
    List all saved custom report definitions (optionally, you may extend with filters).
    """
    service = CustomReportService(uow)
    try:
        return service.list_definitions()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/definitions/{report_id}",
    response_model=CustomReportDefinition,
    summary="Get a specific report definition",
)
async def get_report_definition(
    report_id: UUID = Path(..., description="Report definition ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> CustomReportDefinition:
    """
    Retrieve a specific custom report definition.
    """
    service = CustomReportService(uow)
    try:
        return service.get_definition(report_id=report_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.delete(
    "/definitions/{report_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete a report definition",
)
async def delete_report_definition(
    report_id: UUID = Path(..., description="Report definition ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> None:
    """
    Delete a saved custom report definition.
    """
    service = CustomReportService(uow)
    try:
        service.delete_definition(report_id=report_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\analytics\dashboard.py ---
from __future__ import annotations

from datetime import date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.dashboard_analytics import DashboardMetrics as DashboardMetricsSchema
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import DashboardAnalyticsService

router = APIRouter(prefix="/dashboard")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "",
    response_model=DashboardMetricsSchema,
    summary="Get dashboard metrics snapshot for a scope",
)
async def get_dashboard_metrics(
    scope_type: str = Query(..., description="Scope type: hostel | platform | admin"),
    scope_id: Optional[UUID] = Query(
        None,
        description="Scope ID (hostel_id or admin_id); null for platform scope",
    ),
    period_start: Optional[date] = Query(
        None,
        description="Start date (inclusive). If omitted, service will choose a default window.",
    ),
    period_end: Optional[date] = Query(
        None,
        description="End date (inclusive). If omitted, service will choose a default window.",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> DashboardMetricsSchema:
    """
    Fetch a pre-aggregated dashboard metrics snapshot for the given scope.

    Backed by DashboardAnalyticsService which wraps `analytics_dashboard_metrics`.
    """
    service = DashboardAnalyticsService(uow)
    try:
        return service.get_dashboard_metrics(
            scope_type=scope_type,
            scope_id=scope_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\analytics\financial.py ---
from __future__ import annotations

from datetime import date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.financial_analytics import FinancialReport
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import FinancialAnalyticsService

router = APIRouter(prefix="/financial")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/report",
    response_model=FinancialReport,
    summary="Get financial analytics report",
)
async def get_financial_report(
    scope_type: str = Query(
        "hostel",
        description="Scope type: hostel | platform | admin (default hostel)",
    ),
    scope_id: Optional[UUID] = Query(
        None,
        description="Scope ID (hostel_id, admin_id, or null for platform-wide)",
    ),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> FinancialReport:
    """
    Compute a financial analytics report for the given scope and period.

    Includes revenue, expenses, P&L, cashflow, and collection/overdue ratios.
    """
    service = FinancialAnalyticsService(uow)
    try:
        return service.get_financial_report(
            scope_type=scope_type,
            scope_id=scope_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\analytics\occupancy.py ---
from __future__ import annotations

from datetime import date
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.occupancy_analytics import OccupancyReport
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import OccupancyAnalyticsService

router = APIRouter(prefix="/occupancy")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/report",
    response_model=OccupancyReport,
    summary="Get occupancy report for a hostel",
)
async def get_occupancy_report(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> OccupancyReport:
    """
    Build an occupancy report for the given hostel and period.

    Includes KPIs, daily trend, and occupancy by room type.
    """
    service = OccupancyAnalyticsService(uow)
    try:
        return service.get_occupancy_report(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\analytics\platform.py ---
from __future__ import annotations

from datetime import date
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.platform_analytics import (
    PlatformMetrics,
    GrowthMetrics,
    PlatformUsageAnalytics,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import PlatformAnalyticsService

router = APIRouter(prefix="/platform")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/metrics/latest",
    response_model=PlatformMetrics,
    summary="Get latest platform metrics",
)
async def get_latest_platform_metrics(
    uow: UnitOfWork = Depends(get_uow),
) -> PlatformMetrics:
    """
    Fetch latest platform-wide metrics (tenants, users, load, etc.).
    """
    service = PlatformAnalyticsService(uow)
    try:
        return service.get_latest_metrics()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/growth",
    response_model=GrowthMetrics,
    summary="Get platform growth metrics for a period",
)
async def get_growth_metrics(
    period_start: date = Query(...),
    period_end: date = Query(...),
    uow: UnitOfWork = Depends(get_uow),
) -> GrowthMetrics:
    """
    Fetch growth metrics (hostels, revenue, users) for the given period.
    """
    service = PlatformAnalyticsService(uow)
    try:
        return service.get_growth_metrics(period_start=period_start, period_end=period_end)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/usage/latest",
    response_model=PlatformUsageAnalytics,
    summary="Get latest platform usage analytics",
)
async def get_latest_platform_usage(
    uow: UnitOfWork = Depends(get_uow),
) -> PlatformUsageAnalytics:
    """
    Fetch latest API/platform usage statistics (traffic, error rates, latency).
    """
    service = PlatformAnalyticsService(uow)
    try:
        return service.get_latest_usage()
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\analytics\supervisors.py ---
from __future__ import annotations

from datetime import date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.supervisor_analytics import (
    SupervisorDashboardAnalytics,
    SupervisorComparison,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import SupervisorAnalyticsService

router = APIRouter(prefix="/supervisors")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/{supervisor_id}/dashboard",
    response_model=SupervisorDashboardAnalytics,
    summary="Get supervisor performance dashboard",
)
async def get_supervisor_dashboard(
    supervisor_id: UUID = Path(..., description="Supervisor ID"),
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: date = Query(...),
    period_end: date = Query(...),
    uow: UnitOfWork = Depends(get_uow),
) -> SupervisorDashboardAnalytics:
    """
    Build a performance dashboard for a specific supervisor at a hostel.
    """
    service = SupervisorAnalyticsService(uow)
    try:
        return service.get_supervisor_dashboard(
            supervisor_id=supervisor_id,
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/comparison",
    response_model=SupervisorComparison,
    summary="Compare supervisors within a hostel",
)
async def compare_supervisors(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: date = Query(...),
    period_end: date = Query(...),
    uow: UnitOfWork = Depends(get_uow),
) -> SupervisorComparison:
    """
    Compare supervisors on performance metrics within a given hostel and period.
    """
    service = SupervisorAnalyticsService(uow)
    try:
        return service.get_supervisor_comparison(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\analytics\visitors.py ---
from __future__ import annotations

from datetime import date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.visitor_analytics import (
    VisitorFunnel,
    TrafficSourceAnalytics,
    VisitorBehaviorAnalytics as VisitorBehaviorAnalyticsSchema,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.analytics import VisitorAnalyticsService

router = APIRouter(prefix="/visitors")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/funnel",
    response_model=VisitorFunnel,
    summary="Get visitor funnel analytics",
)
async def get_visitor_funnel(
    hostel_id: Optional[UUID] = Query(None, description="Optional hostel filter"),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> VisitorFunnel:
    """
    Return high-level funnel metrics: visits → registrations → bookings.
    """
    service = VisitorAnalyticsService(uow)
    try:
        return service.get_funnel(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/traffic",
    response_model=TrafficSourceAnalytics,
    summary="Get traffic source analytics",
)
async def get_traffic_sources(
    hostel_id: Optional[UUID] = Query(None, description="Optional hostel filter"),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> TrafficSourceAnalytics:
    """
    Return per-source traffic and conversion analytics.
    """
    service = VisitorAnalyticsService(uow)
    try:
        return service.get_traffic_sources(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/behavior/{visitor_id}",
    response_model=VisitorBehaviorAnalyticsSchema,
    summary="Get aggregated behavior analytics for a visitor",
)
async def get_visitor_behavior(
    visitor_id: UUID = Path(..., description="Visitor ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> VisitorBehaviorAnalyticsSchema:
    """
    Return aggregated behavior metrics for a specific visitor.
    """
    service = VisitorAnalyticsService(uow)
    try:
        return service.get_visitor_behavior(visitor_id=visitor_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\analytics\__init__.py ---
from __future__ import annotations

from fastapi import APIRouter

from . import dashboard
from . import financial
from . import occupancy
from . import complaints
from . import visitors
from . import bookings
from . import supervisors
from . import platform
from . import custom

router = APIRouter(prefix="/analytics")

router.include_router(dashboard.router, tags=["Analytics - Dashboard"])
router.include_router(financial.router, tags=["Analytics - Financial"])
router.include_router(occupancy.router, tags=["Analytics - Occupancy"])
router.include_router(complaints.router, tags=["Analytics - Complaints"])
router.include_router(visitors.router, tags=["Analytics - Visitors"])
router.include_router(bookings.router, tags=["Analytics - Bookings"])
router.include_router(supervisors.router, tags=["Analytics - Supervisors"])
router.include_router(platform.router, tags=["Analytics - Platform"])
router.include_router(custom.router, tags=["Analytics - Custom Reports"])

__all__ = ["router"]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\announcements =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\announcements\announcements.py ---
# api/v1/announcements/announcements.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.announcement.announcement_base import AnnouncementCreate, AnnouncementUpdate
from app.schemas.announcement.announcement_response import (
    AnnouncementDetail,
    AnnouncementList,
)
from app.schemas.announcement.announcement_filters import (
    AnnouncementFilterParams,
    ArchiveRequest,
)
from app.schemas.common.response import BulkOperationResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.announcement import AnnouncementService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "",
    response_model=AnnouncementList,
    summary="List announcements",
)
async def list_announcements(
    filters: AnnouncementFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> AnnouncementList:
    """
    List announcements using filter/search parameters.

    Typical filters include hostel, category, priority, publish state, and date range.
    """
    service = AnnouncementService(uow)
    try:
        return service.list_announcements(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "",
    response_model=AnnouncementDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new announcement",
)
async def create_announcement(
    payload: AnnouncementCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> AnnouncementDetail:
    """
    Create a new announcement.

    Handles targeting, scheduling fields, and initial publish flags as part
    of the create payload.
    """
    service = AnnouncementService(uow)
    try:
        return service.create_announcement(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}",
    response_model=AnnouncementDetail,
    summary="Get announcement details",
)
async def get_announcement(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AnnouncementDetail:
    """
    Retrieve full details for a single announcement.
    """
    service = AnnouncementService(uow)
    try:
        return service.get_announcement(announcement_id=announcement_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{announcement_id}",
    response_model=AnnouncementDetail,
    summary="Update an announcement",
)
async def update_announcement(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: AnnouncementUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AnnouncementDetail:
    """
    Partially update announcement fields (content, category, priority, targeting,
    scheduling, publish flags, etc.).
    """
    service = AnnouncementService(uow)
    try:
        return service.update_announcement(
            announcement_id=announcement_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/archive",
    response_model=BulkOperationResponse,
    summary="Archive announcements in bulk",
)
async def archive_announcements(
    payload: ArchiveRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> BulkOperationResponse:
    """
    Archive announcements based on the supplied criteria.

    Typically used to bulk-archive old or expired announcements.
    """
    service = AnnouncementService(uow)
    try:
        return service.archive_announcements(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\announcements\approval.py ---
# api/v1/announcements/approval.py
from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.announcement.announcement_approval import (
    ApprovalRequest,
    ApprovalResponse,
    RejectionRequest,
    ApprovalWorkflow,
    SupervisorApprovalQueue,
    BulkApproval,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.announcement import AnnouncementService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/{announcement_id}/approval/request",
    response_model=ApprovalWorkflow,
    status_code=status.HTTP_200_OK,
    summary="Request approval for an announcement",
)
async def request_approval(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: ApprovalRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalWorkflow:
    """
    Mark an announcement as requiring approval and create/update its approval workflow.
    """
    service = AnnouncementService(uow)
    try:
        return service.request_approval(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{announcement_id}/approval/approve",
    response_model=ApprovalResponse,
    summary="Approve an announcement",
)
async def approve_announcement(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: ApprovalRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalResponse:
    """
    Approve an announcement (typically by a supervisor/admin).
    """
    service = AnnouncementService(uow)
    try:
        return service.approve_announcement(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{announcement_id}/approval/reject",
    response_model=ApprovalResponse,
    summary="Reject an announcement",
)
async def reject_announcement(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: RejectionRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalResponse:
    """
    Reject an announcement with a structured rejection reason and notes.
    """
    service = AnnouncementService(uow)
    try:
        return service.reject_announcement(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/approvals/pending",
    response_model=SupervisorApprovalQueue,
    summary="List pending announcement approvals",
)
async def list_pending_approvals(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    approver_id: Optional[UUID] = Query(
        None,
        description="Optional approver/supervisor filter",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> SupervisorApprovalQueue:
    """
    List pending announcement approvals, typically grouped by approver/supervisor.
    """
    service = AnnouncementService(uow)
    try:
        return service.list_pending_approvals(
            hostel_id=hostel_id,
            approver_id=approver_id,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/approvals/bulk",
    response_model=List[ApprovalResponse],
    summary="Bulk approve/reject announcements",
)
async def bulk_approve_announcements(
    payload: BulkApproval,
    uow: UnitOfWork = Depends(get_uow),
) -> List[ApprovalResponse]:
    """
    Bulk approval/rejection of multiple announcements in one call.
    """
    service = AnnouncementService(uow)
    try:
        return service.bulk_approve(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\announcements\delivery.py ---
# api/v1/announcements/delivery.py
from __future__ import annotations

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api import deps
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.announcement.announcement_delivery import (
    DeliveryConfig,
    DeliveryStatus,
    DeliveryReport,
    RetryDelivery,
    BatchDelivery,
)
from app.services.announcement import AnnouncementDeliveryService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/{announcement_id}/delivery/config",
    response_model=DeliveryConfig,
    summary="Get delivery configuration for an announcement",
)
async def get_delivery_config(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    delivery_service: Annotated[
        AnnouncementDeliveryService,
        Depends(deps.get_announcement_delivery_service),
    ] = ...,  # type: ignore[assignment]
) -> DeliveryConfig:
    """
    Return the delivery configuration (channels, batching, etc.) for an announcement.
    """
    try:
        return delivery_service.get_config(announcement_id=announcement_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/{announcement_id}/delivery/config",
    response_model=DeliveryConfig,
    summary="Update delivery configuration for an announcement",
)
async def update_delivery_config(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: DeliveryConfig = ...,
    delivery_service: Annotated[
        AnnouncementDeliveryService,
        Depends(deps.get_announcement_delivery_service),
    ] = ...,  # type: ignore[assignment]
) -> DeliveryConfig:
    """
    Update the delivery configuration (channels, batching strategy, etc.) for an announcement.
    """
    try:
        return delivery_service.update_config(
            announcement_id=announcement_id,
            config=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}/delivery/status",
    response_model=DeliveryStatus,
    summary="Get delivery status for an announcement",
)
async def get_delivery_status(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    delivery_service: Annotated[
        AnnouncementDeliveryService,
        Depends(deps.get_announcement_delivery_service),
    ] = ...,  # type: ignore[assignment]
) -> DeliveryStatus:
    """
    Return high-level delivery status across channels (queued, in-progress, completed, failed).
    """
    try:
        return delivery_service.get_status(announcement_id=announcement_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}/delivery/report",
    response_model=DeliveryReport,
    summary="Get detailed delivery report for an announcement",
)
async def get_delivery_report(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    delivery_service: Annotated[
        AnnouncementDeliveryService,
        Depends(deps.get_announcement_delivery_service),
    ] = ...,  # type: ignore[assignment]
) -> DeliveryReport:
    """
    Return a delivery report with per-channel stats, failed deliveries, and other metadata.
    """
    try:
        return delivery_service.get_report(announcement_id=announcement_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{announcement_id}/delivery/retry",
    response_model=BatchDelivery,
    status_code=status.HTTP_200_OK,
    summary="Retry failed deliveries for an announcement",
)
async def retry_failed_deliveries(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: RetryDelivery = ...,
    delivery_service: Annotated[
        AnnouncementDeliveryService,
        Depends(deps.get_announcement_delivery_service),
    ] = ...,  # type: ignore[assignment]
) -> BatchDelivery:
    """
    Retry failed deliveries for an announcement, possibly limited to selected channels or
    recipient subsets.
    """
    try:
        return delivery_service.retry_failed(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\announcements\scheduling.py ---
# api/v1/announcements/scheduling.py
from __future__ import annotations

from datetime import date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.announcement.announcement_scheduling import (
    ScheduleRequest,
    ScheduleUpdate,
    ScheduleCancel,
    PublishNow,
    ScheduleConfig,
    ScheduledAnnouncementsList,
)
from app.schemas.announcement.announcement_response import AnnouncementDetail
from app.services.common.unit_of_work import UnitOfWork
from app.services.announcement import AnnouncementService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/{announcement_id}/schedule",
    response_model=ScheduleConfig,
    status_code=status.HTTP_200_OK,
    summary="Schedule an announcement",
)
async def schedule_announcement(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: ScheduleRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ScheduleConfig:
    """
    Schedule a single announcement with optional expiry and recurrence.
    """
    service = AnnouncementService(uow)
    try:
        return service.schedule_announcement(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{announcement_id}/schedule",
    response_model=ScheduleConfig,
    summary="Update announcement schedule",
)
async def update_announcement_schedule(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: ScheduleUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ScheduleConfig:
    """
    Update scheduling details (publish time, expiry, recurrence) for an announcement.
    """
    service = AnnouncementService(uow)
    try:
        return service.update_schedule(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{announcement_id}/schedule/cancel",
    response_model=ScheduleConfig,
    summary="Cancel announcement schedule",
)
async def cancel_announcement_schedule(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: ScheduleCancel = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ScheduleConfig:
    """
    Cancel the active schedule for an announcement (the announcement itself is
    not deleted).
    """
    service = AnnouncementService(uow)
    try:
        return service.cancel_schedule(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{announcement_id}/publish-now",
    response_model=AnnouncementDetail,
    summary="Publish an announcement immediately",
)
async def publish_now(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: PublishNow = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AnnouncementDetail:
    """
    Publish an announcement immediately, bypassing any future scheduled publish time.
    """
    service = AnnouncementService(uow)
    try:
        return service.publish_now(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/scheduled",
    response_model=ScheduledAnnouncementsList,
    summary="List scheduled announcements",
)
async def list_scheduled_announcements(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    start_date: Optional[date] = Query(
        None,
        description="Optional start of date window (inclusive)",
    ),
    end_date: Optional[date] = Query(
        None,
        description="Optional end of date window (inclusive)",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> ScheduledAnnouncementsList:
    """
    List upcoming scheduled announcements, optionally filtered by hostel and date range.
    """
    service = AnnouncementService(uow)
    try:
        return service.list_scheduled_announcements(
            hostel_id=hostel_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\announcements\targeting.py ---
# api/v1/announcements/targeting.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.announcement.announcement_targeting import (
    TargetingConfig,
    TargetingSummary,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.announcement import AnnouncementService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/{announcement_id}/targeting",
    response_model=TargetingConfig,
    summary="Get audience targeting configuration for an announcement",
)
async def get_targeting_config(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> TargetingConfig:
    """
    Fetch the current audience targeting configuration for a given announcement.
    """
    service = AnnouncementService(uow)
    try:
        return service.get_targeting_config(announcement_id=announcement_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/{announcement_id}/targeting",
    response_model=TargetingConfig,
    summary="Update audience targeting for an announcement",
)
async def update_targeting_config(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: TargetingConfig = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> TargetingConfig:
    """
    Replace the audience targeting configuration for an announcement.

    The service is expected to recompute derived counts as needed.
    """
    service = AnnouncementService(uow)
    try:
        return service.update_targeting_config(
            announcement_id=announcement_id,
            config=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}/targeting/summary",
    response_model=TargetingSummary,
    summary="Get targeting summary for an announcement",
)
async def get_targeting_summary(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> TargetingSummary:
    """
    Return a summary of the targeted audience: total recipients and breakdown
    by audience segments (rooms, floors, students, etc.).
    """
    service = AnnouncementService(uow)
    try:
        return service.get_targeting_summary(announcement_id=announcement_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\announcements\tracking.py ---
# api/v1/announcements/tracking.py
from __future__ import annotations

from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api import deps
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.announcement.announcement_tracking import (
    ReadReceipt,
    AcknowledgmentRequest,
    AcknowledgmentTracking,
    PendingAcknowledgment,
    EngagementMetrics,
    AnnouncementAnalytics,
)
from app.services.announcement import AnnouncementTrackingService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/{announcement_id}/read",
    response_model=ReadReceipt,
    status_code=status.HTTP_200_OK,
    summary="Record a read receipt for an announcement",
)
async def record_read_receipt(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: ReadReceipt = ...,
    tracking_service: Annotated[
        AnnouncementTrackingService,
        Depends(deps.get_announcement_tracking_service),
    ] = ...,  # type: ignore[assignment]
) -> ReadReceipt:
    """
    Record that a recipient has read the announcement (for engagement tracking).
    """
    try:
        return tracking_service.record_read_receipt(
            announcement_id=announcement_id,
            receipt=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{announcement_id}/acknowledge",
    response_model=AcknowledgmentTracking,
    status_code=status.HTTP_200_OK,
    summary="Record an acknowledgment for an announcement",
)
async def acknowledge_announcement(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    payload: AcknowledgmentRequest = ...,
    tracking_service: Annotated[
        AnnouncementTrackingService,
        Depends(deps.get_announcement_tracking_service),
    ] = ...,  # type: ignore[assignment]
) -> AcknowledgmentTracking:
    """
    Record a formal acknowledgment from a recipient for an announcement.
    """
    try:
        return tracking_service.record_acknowledgment(
            announcement_id=announcement_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}/acknowledgments/pending",
    response_model=PendingAcknowledgment,
    summary="Get pending acknowledgments for an announcement",
)
async def get_pending_acknowledgments(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    tracking_service: Annotated[
        AnnouncementTrackingService,
        Depends(deps.get_announcement_tracking_service),
    ] = ...,  # type: ignore[assignment]
) -> PendingAcknowledgment:
    """
    Return information about recipients who have not yet acknowledged the announcement.
    """
    try:
        return tracking_service.get_pending_acknowledgments(
            announcement_id=announcement_id,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}/engagement",
    response_model=EngagementMetrics,
    summary="Get engagement metrics for an announcement",
)
async def get_engagement_metrics(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    tracking_service: Annotated[
        AnnouncementTrackingService,
        Depends(deps.get_announcement_tracking_service),
    ] = ...,  # type: ignore[assignment]
) -> EngagementMetrics:
    """
    Return engagement metrics such as open/read rates, acknowledgment rates,
    and basic reading-time statistics.
    """
    try:
        return tracking_service.get_engagement_metrics(
            announcement_id=announcement_id,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{announcement_id}/analytics",
    response_model=AnnouncementAnalytics,
    summary="Get full analytics for an announcement",
)
async def get_announcement_analytics(
    announcement_id: UUID = Path(..., description="Announcement ID"),
    tracking_service: Annotated[
        AnnouncementTrackingService,
        Depends(deps.get_announcement_tracking_service),
    ] = ...,  # type: ignore[assignment]
) -> AnnouncementAnalytics:
    """
    Return comprehensive analytics for an announcement, combining delivery and
    engagement data.
    """
    try:
        return tracking_service.get_announcement_analytics(
            announcement_id=announcement_id,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\announcements\__init__.py ---
# api/v1/announcements/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import announcements
from . import targeting
from . import scheduling
from . import approval
from . import delivery
from . import tracking

router = APIRouter(prefix="/announcements")

router.include_router(announcements.router, tags=["Announcements - Core"])
router.include_router(targeting.router, tags=["Announcements - Targeting"])
router.include_router(scheduling.router, tags=["Announcements - Scheduling"])
router.include_router(approval.router, tags=["Announcements - Approval"])
router.include_router(delivery.router, tags=["Announcements - Delivery"])
router.include_router(tracking.router, tags=["Announcements - Tracking"])

__all__ = ["router"]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\attendance =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\attendance\alerts.py ---
# api/v1/attendance/alerts.py
from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.attendance.attendance_alert import (
    AlertConfig,
    AlertTrigger,
    AttendanceAlert,
    AlertAcknowledgment,
    AlertList,
    AlertSummary,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.attendance import AttendanceAlertService

router = APIRouter(prefix="/alerts")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/config/{hostel_id}",
    response_model=AlertConfig,
    summary="Get attendance alert configuration for a hostel",
)
async def get_alert_config(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AlertConfig:
    """
    Fetch the alert configuration (thresholds, channels, patterns) for a hostel.
    """
    service = AttendanceAlertService(uow)
    try:
        return service.get_alert_config(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/config/{hostel_id}",
    response_model=AlertConfig,
    summary="Update attendance alert configuration for a hostel",
)
async def update_alert_config(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: AlertConfig = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AlertConfig:
    """
    Update the alert configuration for a hostel.
    """
    service = AttendanceAlertService(uow)
    try:
        return service.update_alert_config(
            hostel_id=hostel_id,
            config=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/trigger",
    response_model=AttendanceAlert,
    status_code=status.HTTP_201_CREATED,
    summary="Trigger an attendance alert manually",
)
async def trigger_alert(
    payload: AlertTrigger,
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceAlert:
    """
    Manually trigger an attendance alert (e.g., low attendance, anomaly).
    """
    service = AttendanceAlertService(uow)
    try:
        return service.trigger_alert(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{alert_id}/acknowledge",
    response_model=AlertAcknowledgment,
    status_code=status.HTTP_200_OK,
    summary="Acknowledge an attendance alert",
)
async def acknowledge_alert(
    alert_id: UUID = Path(..., description="Alert ID"),
    payload: AlertAcknowledgment = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AlertAcknowledgment:
    """
    Acknowledge that an alert has been seen/handled.
    """
    service = AttendanceAlertService(uow)
    try:
        return service.acknowledge_alert(
            alert_id=alert_id,
            acknowledgment=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "",
    response_model=AlertList,
    summary="List attendance alerts",
)
async def list_alerts(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> AlertList:
    """
    List attendance alerts, optionally filtered by hostel.
    """
    service = AttendanceAlertService(uow)
    try:
        return service.list_alerts(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/summary",
    response_model=AlertSummary,
    summary="Get attendance alert summary",
)
async def get_alert_summary(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> AlertSummary:
    """
    Get summarized statistics for attendance alerts (counts, types, trends).
    """
    service = AttendanceAlertService(uow)
    try:
        return service.get_alert_summary(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\attendance\attendance.py ---
# api/v1/attendance/attendance.py
from __future__ import annotations

from datetime import date
from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.attendance.attendance_base import AttendanceCreate, AttendanceUpdate
from app.schemas.attendance.attendance_response import (
    AttendanceResponse,
    AttendanceDetail,
    DailyAttendanceSummary,
)
from app.schemas.attendance.attendance_filters import AttendanceFilterParams
from app.services.common.unit_of_work import UnitOfWork
from app.services.attendance import AttendanceService

router = APIRouter(prefix="/records")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "",
    response_model=List[AttendanceResponse],
    summary="List attendance records",
)
async def list_attendance_records(
    filters: AttendanceFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> List[AttendanceResponse]:
    """
    List attendance records using filters (hostel, student, date range, status, mode, etc.).
    """
    service = AttendanceService(uow)
    try:
        return service.list_attendance(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "",
    response_model=AttendanceDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create an attendance record",
)
async def create_attendance_record(
    payload: AttendanceCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceDetail:
    """
    Create a single attendance record.
    """
    service = AttendanceService(uow)
    try:
        return service.create_attendance(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{attendance_id}",
    response_model=AttendanceDetail,
    summary="Get attendance record details",
)
async def get_attendance_record(
    attendance_id: UUID = Path(..., description="Attendance record ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceDetail:
    """
    Retrieve full details for a specific attendance record.
    """
    service = AttendanceService(uow)
    try:
        return service.get_attendance(attendance_id=attendance_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{attendance_id}",
    response_model=AttendanceDetail,
    summary="Update an attendance record",
)
async def update_attendance_record(
    attendance_id: UUID = Path(..., description="Attendance record ID"),
    payload: AttendanceUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceDetail:
    """
    Partially update an attendance record (times, status, notes, etc.).
    """
    service = AttendanceService(uow)
    try:
        return service.update_attendance(
            attendance_id=attendance_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/summary",
    response_model=DailyAttendanceSummary,
    summary="Get daily attendance summary for a hostel",
)
async def get_daily_hostel_summary(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    day: date = Query(..., description="Date for the summary (YYYY-MM-DD)"),
    uow: UnitOfWork = Depends(get_uow),
) -> DailyAttendanceSummary:
    """
    Get summarized attendance statistics for a hostel on a specific day.
    """
    service = AttendanceService(uow)
    try:
        return service.get_daily_summary(
            hostel_id=hostel_id,
            day=day,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\attendance\bulk.py ---
# api/v1/attendance/bulk.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.attendance.attendance_base import BulkAttendanceCreate
from app.schemas.common.response import BulkOperationResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.attendance import AttendanceService

router = APIRouter(prefix="/bulk")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/create",
    response_model=BulkOperationResponse,
    status_code=status.HTTP_200_OK,
    summary="Bulk create attendance records",
)
async def bulk_create_attendance(
    payload: BulkAttendanceCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> BulkOperationResponse:
    """
    Bulk-create attendance records from a structured list of records.
    """
    service = AttendanceService(uow)
    try:
        return service.bulk_create_attendance(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\attendance\policy.py ---
# api/v1/attendance/policy.py
from __future__ import annotations

from datetime import date
from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.attendance.attendance_policy import (
    AttendancePolicy,
    PolicyUpdate,
    PolicyViolation,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.attendance import AttendancePolicyService

router = APIRouter(prefix="/policy")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/hostels/{hostel_id}",
    response_model=AttendancePolicy,
    summary="Get attendance policy for a hostel",
)
async def get_attendance_policy(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AttendancePolicy:
    """
    Fetch the current attendance policy configuration for a hostel.
    """
    service = AttendancePolicyService(uow)
    try:
        return service.get_policy(hostel_id=hostel_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/hostels/{hostel_id}",
    response_model=AttendancePolicy,
    summary="Update attendance policy for a hostel",
)
async def update_attendance_policy(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    payload: PolicyUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AttendancePolicy:
    """
    Update the attendance policy for a hostel.
    """
    service = AttendancePolicyService(uow)
    try:
        return service.update_policy(
            hostel_id=hostel_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/students/{student_id}/violations",
    response_model=List[PolicyViolation],
    summary="Evaluate policy violations for a student",
)
async def get_policy_violations_for_student(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    student_id: UUID = Path(..., description="Student ID"),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> List[PolicyViolation]:
    """
    Evaluate attendance policy violations for a student over a given period.
    """
    service = AttendancePolicyService(uow)
    try:
        return service.evaluate_violations(
            hostel_id=hostel_id,
            student_id=student_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\attendance\record.py ---
# api/v1/attendance/record.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.attendance.attendance_record import (
    AttendanceRecordRequest,
    BulkAttendanceRequest,
    AttendanceCorrection,
    QuickAttendanceMarkAll,
)
from app.schemas.attendance.attendance_response import AttendanceDetail
from app.schemas.common.response import BulkOperationResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.attendance import AttendanceService

router = APIRouter(prefix="/mark")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "/single",
    response_model=AttendanceDetail,
    status_code=status.HTTP_200_OK,
    summary="Mark attendance for a single student",
)
async def mark_single_attendance(
    payload: AttendanceRecordRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceDetail:
    """
    Mark attendance for a single student on a given day.
    """
    service = AttendanceService(uow)
    try:
        return service.mark_attendance(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=BulkOperationResponse,
    status_code=status.HTTP_200_OK,
    summary="Bulk mark attendance",
)
async def bulk_mark_attendance(
    payload: BulkAttendanceRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> BulkOperationResponse:
    """
    Bulk mark attendance for many students in one call.
    """
    service = AttendanceService(uow)
    try:
        return service.bulk_mark_attendance(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/correction",
    response_model=AttendanceDetail,
    status_code=status.HTTP_200_OK,
    summary="Correct an existing attendance record",
)
async def correct_attendance(
    payload: AttendanceCorrection,
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceDetail:
    """
    Apply a correction to an existing attendance record (status/time updates, etc.).
    """
    service = AttendanceService(uow)
    try:
        return service.correct_attendance(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/mark-all",
    response_model=BulkOperationResponse,
    status_code=status.HTTP_200_OK,
    summary="Quick mark all present with exceptions",
)
async def quick_mark_all(
    payload: QuickAttendanceMarkAll,
    uow: UnitOfWork = Depends(get_uow),
) -> BulkOperationResponse:
    """
    Quickly mark all students present, with specific exceptions (absent/late/etc.).
    """
    service = AttendanceService(uow)
    try:
        return service.quick_mark_all(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\attendance\reports.py ---
# api/v1/attendance/reports.py
from __future__ import annotations

from datetime import date
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.attendance.attendance_report import (
    AttendanceReport,
    MonthlyReport,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.attendance import AttendanceReportService

router = APIRouter(prefix="/reports")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "/students/{student_id}",
    response_model=AttendanceReport,
    summary="Get attendance report for a student",
)
async def get_student_attendance_report(
    student_id: UUID = Path(..., description="Student ID"),
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> AttendanceReport:
    """
    Generate a detailed attendance report for a student in a hostel over a period.
    """
    service = AttendanceReportService(uow)
    try:
        return service.get_student_report(
            student_id=student_id,
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/monthly",
    response_model=MonthlyReport,
    summary="Get monthly hostel attendance report",
)
async def get_hostel_monthly_attendance_report(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    year: int = Query(..., ge=2000, description="Year (e.g. 2025)"),
    month: int = Query(..., ge=1, le=12, description="Month (1-12)"),
    uow: UnitOfWork = Depends(get_uow),
) -> MonthlyReport:
    """
    Generate a monthly attendance report for a hostel, aggregated across students.
    """
    service = AttendanceReportService(uow)
    try:
        return service.get_hostel_monthly_report(
            hostel_id=hostel_id,
            year=year,
            month=month,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\attendance\__init__.py ---
# api/v1/attendance/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import attendance
from . import record
from . import bulk
from . import reports
from . import policy
from . import alerts

router = APIRouter(prefix="/attendance")

router.include_router(attendance.router, tags=["Attendance - Records"])
router.include_router(record.router, tags=["Attendance - Marking"])
router.include_router(bulk.router, tags=["Attendance - Bulk"])
router.include_router(reports.router, tags=["Attendance - Reports"])
router.include_router(policy.router, tags=["Attendance - Policy"])
router.include_router(alerts.router, tags=["Attendance - Alerts"])

__all__ = ["router"]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\audit =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\audit\activity.py ---
# api/v1/audit/activity.py
from __future__ import annotations

from datetime import date
from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.audit.supervisor_activity_log import (
    SupervisorActivityCreate,
    SupervisorActivityLogResponse,
    SupervisorActivityDetail,
    SupervisorActivityFilter,
    SupervisorActivitySummary,
    SupervisorActivityTimelinePoint,
)
from app.schemas.common.pagination import PaginatedResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.audit import SupervisorActivityService

router = APIRouter(prefix="/activity")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "",
    response_model=SupervisorActivityDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Log supervisor activity",
)
async def log_supervisor_activity(
    payload: SupervisorActivityCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> SupervisorActivityDetail:
    """
    Create a new supervisor activity log entry.
    """
    service = SupervisorActivityService(uow)
    try:
        return service.log_activity(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "",
    response_model=PaginatedResponse[SupervisorActivityLogResponse],
    summary="List supervisor activity logs",
)
async def list_supervisor_activity(
    filters: SupervisorActivityFilter = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[SupervisorActivityLogResponse]:
    """
    List supervisor activity logs with filters (hostel, supervisor, category, date range)
    and pagination.
    """
    service = SupervisorActivityService(uow)
    try:
        return service.list_activity(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{activity_id}",
    response_model=SupervisorActivityDetail,
    summary="Get supervisor activity details",
)
async def get_supervisor_activity(
    activity_id: UUID = Path(..., description="Supervisor activity log ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> SupervisorActivityDetail:
    """
    Retrieve details for a specific supervisor activity log entry.
    """
    service = SupervisorActivityService(uow)
    try:
        return service.get_activity(activity_id=activity_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/summary",
    response_model=SupervisorActivitySummary,
    summary="Get supervisor activity summary",
)
async def get_supervisor_activity_summary(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Filter by hostel ID",
    ),
    supervisor_id: Optional[UUID] = Query(
        None,
        description="Filter by supervisor ID",
    ),
    start_date: Optional[date] = Query(
        None,
        description="Start date (inclusive)",
    ),
    end_date: Optional[date] = Query(
        None,
        description="End date (inclusive)",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> SupervisorActivitySummary:
    """
    Summarize supervisor activity over a period (counts, categories, types, etc.).
    """
    service = SupervisorActivityService(uow)
    try:
        return service.get_summary(
            hostel_id=hostel_id,
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/timeline",
    response_model=List[SupervisorActivityTimelinePoint],
    summary="Get supervisor activity timeline",
)
async def get_supervisor_activity_timeline(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Filter by hostel ID",
    ),
    supervisor_id: Optional[UUID] = Query(
        None,
        description="Filter by supervisor ID",
    ),
    start_date: Optional[date] = Query(
        None,
        description="Start date (inclusive)",
    ),
    end_date: Optional[date] = Query(
        None,
        description="End date (inclusive)",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> List[SupervisorActivityTimelinePoint]:
    """
    Return timeline points for supervisor activity for visualization/analysis.
    """
    service = SupervisorActivityService(uow)
    try:
        return service.get_timeline(
            hostel_id=hostel_id,
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\audit\logs.py ---
# api/v1/audit/logs.py
from __future__ import annotations

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.audit.audit_log_base import AuditLogCreate
from app.schemas.audit.audit_log_response import AuditLogResponse, AuditLogDetail
from app.schemas.audit.audit_filters import AuditFilterParams
from app.schemas.audit.audit_reports import EntityChangeHistory
from app.schemas.common.pagination import PaginatedResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.audit import AuditLogService, EntityHistoryService

router = APIRouter(prefix="/logs")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.post(
    "",
    response_model=AuditLogDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create an audit log entry",
)
async def create_audit_log(
    payload: AuditLogCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> AuditLogDetail:
    """
    Create a new audit log entry.

    In most cases, business services log actions internally, but this endpoint
    can be used for manual/debug logging or integrations.
    """
    service = AuditLogService(uow)
    try:
        return service.log_action(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "",
    response_model=PaginatedResponse[AuditLogResponse],
    summary="List audit logs with filters",
)
async def list_audit_logs(
    filters: AuditFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[AuditLogResponse]:
    """
    List audit logs with flexible filters (user, role, hostel, entity, action, time range)
    and pagination parameters.
    """
    service = AuditLogService(uow)
    try:
        return service.list_logs(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{log_id}",
    response_model=AuditLogDetail,
    summary="Get audit log details",
)
async def get_audit_log(
    log_id: UUID = Path(..., description="Audit log ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AuditLogDetail:
    """
    Retrieve detailed information for a single audit log entry.
    """
    service = AuditLogService(uow)
    try:
        return service.get_log(log_id=log_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/entity/{entity_type}/{entity_id}/history",
    response_model=EntityChangeHistory,
    summary="Get change history for an entity",
)
async def get_entity_change_history(
    entity_type: str = Path(..., description="Entity type (e.g. hostel, student, complaint)"),
    entity_id: UUID = Path(..., description="Entity ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> EntityChangeHistory:
    """
    Build a change history for a specific entity from its audit log entries.
    """
    service = EntityHistoryService(uow)
    try:
        return service.get_entity_history(
            entity_type=entity_type,
            entity_id=entity_id,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\audit\overrides.py ---
# api/v1/audit/overrides.py
from __future__ import annotations

from datetime import date
from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.audit.admin_override_log import (
    AdminOverrideLogResponse,
    AdminOverrideDetail,
    AdminOverrideSummary,
    AdminOverrideTimelinePoint,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.audit import AdminOverrideAuditService

router = APIRouter(prefix="/overrides")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "",
    response_model=List[AdminOverrideLogResponse],
    summary="List admin overrides (audit)",
)
async def list_admin_overrides(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Filter by hostel ID",
    ),
    supervisor_id: Optional[UUID] = Query(
        None,
        description="Filter by supervisor ID",
    ),
    entity_type: Optional[str] = Query(
        None,
        description="Filter by entity type (complaint, maintenance, leave, etc.)",
    ),
    entity_id: Optional[UUID] = Query(
        None,
        description="Filter by entity ID",
    ),
    start_date: Optional[date] = Query(
        None,
        description="Start date (inclusive)",
    ),
    end_date: Optional[date] = Query(
        None,
        description="End date (inclusive)",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> List[AdminOverrideLogResponse]:
    """
    List admin overrides with optional filters for hostel, supervisor, entity, and period.
    """
    service = AdminOverrideAuditService(uow)
    try:
        return service.list_overrides(
            hostel_id=hostel_id,
            supervisor_id=supervisor_id,
            entity_type=entity_type,
            entity_id=entity_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{override_id}",
    response_model=AdminOverrideDetail,
    summary="Get admin override details",
)
async def get_admin_override(
    override_id: UUID = Path(..., description="Override record ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> AdminOverrideDetail:
    """
    Retrieve a detailed view of a specific admin override record.
    """
    service = AdminOverrideAuditService(uow)
    try:
        return service.get_override_detail(override_id=override_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/summary",
    response_model=AdminOverrideSummary,
    summary="Get summary of admin overrides",
)
async def get_admin_override_summary(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Filter by hostel ID",
    ),
    supervisor_id: Optional[UUID] = Query(
        None,
        description="Filter by supervisor ID",
    ),
    start_date: Optional[date] = Query(
        None,
        description="Start date (inclusive)",
    ),
    end_date: Optional[date] = Query(
        None,
        description="End date (inclusive)",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> AdminOverrideSummary:
    """
    Summarize admin overrides over a period, grouped by type, hostel, and supervisor.
    """
    service = AdminOverrideAuditService(uow)
    try:
        return service.get_summary(
            hostel_id=hostel_id,
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/timeline",
    response_model=List[AdminOverrideTimelinePoint],
    summary="Get admin override timeline",
)
async def get_admin_override_timeline(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Filter by hostel ID",
    ),
    supervisor_id: Optional[UUID] = Query(
        None,
        description="Filter by supervisor ID",
    ),
    start_date: Optional[date] = Query(
        None,
        description="Start date (inclusive)",
    ),
    end_date: Optional[date] = Query(
        None,
        description="End date (inclusive)",
    ),
    uow: UnitOfWork = Depends(get_uow),
) -> List[AdminOverrideTimelinePoint]:
    """
    Return a timeline of admin overrides across a period for visualization/analysis.
    """
    service = AdminOverrideAuditService(uow)
    try:
        return service.get_timeline(
            hostel_id=hostel_id,
            supervisor_id=supervisor_id,
            start_date=start_date,
            end_date=end_date,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\audit\reports.py ---
# api/v1/audit/reports.py
from __future__ import annotations

from datetime import date
from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.audit.audit_reports import (
    AuditReport,
    UserActivitySummary,
    EntityChangeSummary,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.reporting import AuditReportingService

router = APIRouter(prefix="/reports")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc),
        )
    if isinstance(exc, ValidationError):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc),
        )
    if isinstance(exc, ConflictError):
        return HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(exc),
        )
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=str(exc),
    )


@router.get(
    "",
    response_model=AuditReport,
    summary="Get overall audit report",
)
async def get_audit_report(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    user_id: Optional[UUID] = Query(
        None,
        description="Optional user filter",
    ),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> AuditReport:
    """
    Return an overall audit report for the given period, aggregating audit logs,
    overrides, and supervisor activities by entity type and category.
    """
    service = AuditReportingService(uow)
    try:
        return service.get_audit_report(
            hostel_id=hostel_id,
            user_id=user_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/user-activity",
    response_model=UserActivitySummary,
    summary="Get user activity summary",
)
async def get_user_activity_summary(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    user_id: Optional[UUID] = Query(
        None,
        description="User ID to summarize activity for",
    ),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> UserActivitySummary:
    """
    Summarize user activity over a period (counts of actions, categories, etc.).
    """
    service = AuditReportingService(uow)
    try:
        return service.get_user_activity_summary(
            hostel_id=hostel_id,
            user_id=user_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/entities",
    response_model=List[EntityChangeSummary],
    summary="Get entity change summaries",
)
async def get_entity_change_summaries(
    hostel_id: Optional[UUID] = Query(
        None,
        description="Optional hostel filter",
    ),
    entity_type: Optional[str] = Query(
        None,
        description="Optional entity type filter (hostel, room, student, etc.)",
    ),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> List[EntityChangeSummary]:
    """
    Summarize changes per entity type over a period (counts, categories).
    """
    service = AuditReportingService(uow)
    try:
        return service.get_entity_change_summaries(
            hostel_id=hostel_id,
            entity_type=entity_type,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\audit\__init__.py ---
# api/v1/audit/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import logs
from . import overrides
from . import activity
from . import reports

router = APIRouter(prefix="/audit")

router.include_router(logs.router, tags=["Audit - Logs"])
router.include_router(overrides.router, tags=["Audit - Admin Overrides"])
router.include_router(activity.router, tags=["Audit - Supervisor Activity"])
router.include_router(reports.router, tags=["Audit - Reports"])

__all__ = ["router"]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\auth =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\auth\login.py ---
# api/v1/auth/login.py
from __future__ import annotations

from typing import Annotated

from fastapi import APIRouter, Depends, HTTPException, Request, status

from api import deps
from app.schemas.auth.login import (
    LoginRequest,
    PhoneLoginRequest,
    LoginResponse,
)
from app.services.auth import AuthService

router = APIRouter()


@router.post("/login", response_model=LoginResponse, status_code=status.HTTP_200_OK)
async def login_with_email(
    payload: LoginRequest,
    request: Request,
    auth_service: Annotated[AuthService, Depends(deps.get_auth_service)],
) -> LoginResponse:
    """
    Email/password login.

    Returns:
    - access_token
    - refresh_token
    - user info
    """
    ip_address = request.client.host if request.client else None
    user_agent = request.headers.get("User-Agent")

    return auth_service.login(
        payload,
        ip_address=ip_address,
        user_agent=user_agent,
    )


@router.post(
    "/login/phone",
    response_model=LoginResponse,
    status_code=status.HTTP_200_OK,
)
async def login_with_phone(
    payload: PhoneLoginRequest,
    request: Request,
    auth_service: Annotated[AuthService, Depends(deps.get_auth_service)],
) -> LoginResponse:
    """
    Phone/password login.
    """
    ip_address = request.client.host if request.client else None
    user_agent = request.headers.get("User-Agent")

    return auth_service.login_with_phone(
        payload,
        ip_address=ip_address,
        user_agent=user_agent,
    )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\auth\otp.py ---
# api/v1/auth/otp.py
from __future__ import annotations

from typing import Annotated

from fastapi import APIRouter, Depends, status

from api import deps
from app.schemas.auth.otp import (
    OTPGenerateRequest,
    OTPVerifyRequest,
    OTPResponse,
    OTPVerifyResponse,
)
from app.services.auth import OTPService

router = APIRouter()


@router.post(
    "/otp/send",
    response_model=OTPResponse,
    status_code=status.HTTP_200_OK,
)
async def send_otp(
    payload: OTPGenerateRequest,
    otp_service: Annotated[OTPService, Depends(deps.get_otp_service)],
) -> OTPResponse:
    """
    Generate an OTP for email/phone/user_id.

    This only stores the OTP; caller is responsible for actually
    sending it via email/SMS using the notification system.
    """
    return otp_service.generate(payload)


@router.post(
    "/otp/verify",
    response_model=OTPVerifyResponse,
    status_code=status.HTTP_200_OK,
)
async def verify_otp(
    payload: OTPVerifyRequest,
    otp_service: Annotated[OTPService, Depends(deps.get_otp_service)],
) -> OTPVerifyResponse:
    """
    Verify an OTP code previously generated by /otp/send.
    """
    return otp_service.verify(payload)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\auth\password.py ---
# api/v1/auth/password.py
from __future__ import annotations

from typing import Annotated

from fastapi import APIRouter, Depends, Request, status

from api import deps
from app.schemas.auth.password import (
    PasswordChangeRequest,
    PasswordChangeResponse,
    PasswordStrengthCheck,
    PasswordStrengthResponse,
)
from app.services.auth import PasswordService

router = APIRouter()


@router.post(
    "/password/change",
    response_model=PasswordChangeResponse,
    status_code=status.HTTP_200_OK,
)
async def change_password(
    payload: PasswordChangeRequest,
    request: Request,
    password_service: Annotated[PasswordService, Depends(deps.get_password_service)],
    current_user=Depends(deps.get_current_user),
) -> PasswordChangeResponse:
    """
    Change password for the currently authenticated user.
    """
    ip_address = request.client.host if request.client else None
    user_agent = request.headers.get("User-Agent")

    return password_service.change_password(
        user_id=current_user.id,
        data=payload,
        ip_address=ip_address,
        user_agent=user_agent,
    )


@router.post(
    "/password/strength",
    response_model=PasswordStrengthResponse,
    status_code=status.HTTP_200_OK,
)
async def evaluate_password_strength(
    payload: PasswordStrengthCheck,
    password_service: Annotated[PasswordService, Depends(deps.get_password_service)],
) -> PasswordStrengthResponse:
    """
    Simple password strength evaluation helper.
    """
    return password_service.evaluate_strength(payload)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\auth\register.py ---
# api/v1/auth/register.py
from __future__ import annotations

from typing import Annotated

from fastapi import APIRouter, Depends, status

from api import deps
from app.schemas.auth.register import (
    RegisterRequest,
    RegisterResponse,
)
from app.services.auth import RegistrationService

router = APIRouter()


@router.post(
    "/register",
    response_model=RegisterResponse,
    status_code=status.HTTP_201_CREATED,
)
async def register_visitor(
    payload: RegisterRequest,
    registration_service: Annotated[RegistrationService, Depends(deps.get_registration_service)],
) -> RegisterResponse:
    """
    Public visitor registration.

    Only VISITOR role is allowed here; other roles must be created by admins.
    """
    return registration_service.register(payload)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\auth\social.py ---
# api/v1/auth/social.py
from __future__ import annotations

from typing import Annotated

from fastapi import APIRouter, Depends, HTTPException, status

from api import deps
from app.schemas.auth.social_auth import (
    GoogleAuthRequest,
    FacebookAuthRequest,
    SocialAuthResponse,
)
from app.services.auth import SocialAuthService

router = APIRouter()


@router.post(
    "/google",
    response_model=SocialAuthResponse,
    status_code=status.HTTP_200_OK,
)
async def authenticate_with_google(
    payload: GoogleAuthRequest,
    social_auth_service: Annotated[SocialAuthService, Depends(deps.get_social_auth_service)],
) -> SocialAuthResponse:
    """
    Google social login.

    Currently a stub in the service layer and will raise NotImplementedError
    until the integration is implemented.
    """
    try:
        return social_auth_service.authenticate_with_google(payload)
    except NotImplementedError:
        raise HTTPException(
            status_code=status.HTTP_501_NOT_IMPLEMENTED,
            detail="Google OAuth integration is not configured",
        )


@router.post(
    "/facebook",
    response_model=SocialAuthResponse,
    status_code=status.HTTP_200_OK,
)
async def authenticate_with_facebook(
    payload: FacebookAuthRequest,
    social_auth_service: Annotated[SocialAuthService, Depends(deps.get_social_auth_service)],
) -> SocialAuthResponse:
    """
    Facebook social login.

    Currently a stub in the service layer and will raise NotImplementedError
    until the integration is implemented.
    """
    try:
        return social_auth_service.authenticate_with_facebook(payload)
    except NotImplementedError:
        raise HTTPException(
            status_code=status.HTTP_501_NOT_IMPLEMENTED,
            detail="Facebook OAuth integration is not configured",
        )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\auth\token.py ---
# api/v1/auth/token.py
from __future__ import annotations

from typing import Annotated

from fastapi import APIRouter, Depends, status

from api import deps
from app.schemas.auth.token import (
    RefreshTokenRequest,
    RefreshTokenResponse,
)
from app.services.auth import AuthService

router = APIRouter()


@router.post(
    "/token/refresh",
    response_model=RefreshTokenResponse,
    status_code=status.HTTP_200_OK,
)
async def refresh_access_token(
    payload: RefreshTokenRequest,
    auth_service: Annotated[AuthService, Depends(deps.get_auth_service)],
) -> RefreshTokenResponse:
    """
    Exchange a refresh token for a new access (and refresh) token.
    """
    return auth_service.refresh_token(payload)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\auth\__init__.py ---
# api/v1/auth/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import login, register, token, password, otp, social

router = APIRouter(prefix="/auth", tags=["auth"])

router.include_router(login.router)
router.include_router(register.router)
router.include_router(token.router)
router.include_router(password.router)
router.include_router(otp.router)
router.include_router(social.router)

__all__ = ["router"]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\bookings =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\bookings\analytics.py ---
# api/v1/bookings/analytics.py
from __future__ import annotations

from datetime import date
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.analytics.booking_analytics import BookingAnalyticsSummary
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingAnalyticsService

router = APIRouter(prefix="/analytics")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/summary",
    response_model=BookingAnalyticsSummary,
    summary="Get booking analytics summary for a hostel",
)
async def get_booking_analytics_summary(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> BookingAnalyticsSummary:
    """
    Produce booking analytics for a hostel: KPIs, daily trends, funnel, cancellations,
    and source conversions.
    """
    service = BookingAnalyticsService(uow)
    try:
        return service.get_booking_analytics(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\bookings\approval.py ---
# api/v1/bookings/approval.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_approval import (
    BookingApprovalRequest,
    ApprovalResponse,
    RejectionRequest,
    BulkApprovalRequest,
    ApprovalSettings,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingApprovalService

router = APIRouter(prefix="/approval")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/bookings/{booking_id}/approve",
    response_model=ApprovalResponse,
    summary="Approve a booking",
)
async def approve_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: BookingApprovalRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalResponse:
    """
    Approve a booking, confirm pricing, and optionally require advance payment.
    """
    service = BookingApprovalService(uow)
    try:
        return service.approve_booking(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bookings/{booking_id}/reject",
    response_model=ApprovalResponse,
    summary="Reject a booking",
)
async def reject_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: RejectionRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalResponse:
    """
    Reject a booking with structured rejection reasons and potential alternatives.
    """
    service = BookingApprovalService(uow)
    try:
        return service.reject_booking(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=List[ApprovalResponse],
    summary="Bulk approve/reject bookings",
)
async def bulk_approve_bookings(
    payload: BulkApprovalRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> List[ApprovalResponse]:
    """
    Bulk approve or reject multiple bookings in a single request.
    """
    service = BookingApprovalService(uow)
    try:
        return service.bulk_approve(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/settings",
    response_model=ApprovalSettings,
    summary="Get booking approval settings",
)
async def get_approval_settings(
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalSettings:
    """
    Get automated approval settings (thresholds, rules).
    """
    service = BookingApprovalService(uow)
    try:
        return service.get_settings()
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.put(
    "/settings",
    response_model=ApprovalSettings,
    summary="Update booking approval settings",
)
async def update_approval_settings(
    payload: ApprovalSettings,
    uow: UnitOfWork = Depends(get_uow),
) -> ApprovalSettings:
    """
    Update automated approval settings.
    """
    service = BookingApprovalService(uow)
    try:
        return service.update_settings(settings=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\bookings\assignment.py ---
# api/v1/bookings/assignment.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_assignment import (
    AssignmentRequest,
    BulkAssignmentRequest,
    ReassignmentRequest,
    AssignmentResponse,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingService

router = APIRouter(prefix="/assignments")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/{booking_id}",
    response_model=AssignmentResponse,
    status_code=status.HTTP_200_OK,
    summary="Assign room/bed for a booking",
)
async def assign_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: AssignmentRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentResponse:
    """
    Assign a room and optionally a bed to a booking.
    """
    service = BookingService(uow)
    try:
        return service.assign_booking(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=List[AssignmentResponse],
    summary="Bulk assign rooms/beds for bookings",
)
async def bulk_assign_bookings(
    payload: BulkAssignmentRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> List[AssignmentResponse]:
    """
    Bulk assign rooms/beds to multiple bookings.
    """
    service = BookingService(uow)
    try:
        return service.bulk_assign_bookings(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{booking_id}/reassign",
    response_model=AssignmentResponse,
    summary="Reassign room/bed for a booking",
)
async def reassign_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: ReassignmentRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> AssignmentResponse:
    """
    Reassign a booking to a new room/bed.
    """
    service = BookingService(uow)
    try:
        return service.reassign_booking(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\bookings\bookings.py ---
# api/v1/bookings/bookings.py
from __future__ import annotations

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_base import BookingCreate, BookingUpdate
from app.schemas.booking.booking_response import (
    BookingDetail,
    BookingListItem,
    BookingConfirmation,
)
from app.schemas.booking.booking_filters import (
    BookingFilterParams,
    BookingSearchRequest,
)
from app.schemas.common.pagination import PaginatedResponse
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingService

router = APIRouter()


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "",
    response_model=PaginatedResponse[BookingListItem],
    summary="List bookings",
)
async def list_bookings(
    filters: BookingFilterParams = Depends(),
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[BookingListItem]:
    """
    List bookings using flexible filters (hostel, status, date range, source, etc.)
    with pagination and sorting.
    """
    service = BookingService(uow)
    try:
        return service.list_bookings(filters=filters)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "",
    response_model=BookingDetail,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new booking",
)
async def create_booking(
    payload: BookingCreate,
    uow: UnitOfWork = Depends(get_uow),
) -> BookingDetail:
    """
    Create a new booking (internal/admin or system-side).

    Validates amounts and requested room type using BookingCreate.
    """
    service = BookingService(uow)
    try:
        return service.create_booking(data=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{booking_id}",
    response_model=BookingDetail,
    summary="Get booking details",
)
async def get_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> BookingDetail:
    """
    Retrieve detailed booking information including hostel, amounts, status history,
    and assignment (if any).
    """
    service = BookingService(uow)
    try:
        return service.get_booking(booking_id=booking_id)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.patch(
    "/{booking_id}",
    response_model=BookingDetail,
    summary="Update a booking",
)
async def update_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: BookingUpdate = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> BookingDetail:
    """
    Partially update a booking (dates, duration, notes, status, etc.).
    """
    service = BookingService(uow)
    try:
        return service.update_booking(
            booking_id=booking_id,
            data=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/search",
    response_model=PaginatedResponse[BookingListItem],
    summary="Search bookings",
)
async def search_bookings(
    payload: BookingSearchRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> PaginatedResponse[BookingListItem]:
    """
    Structured booking search endpoint (richer than simple filters),
    e.g. multi-field search, complex status/date logic.
    """
    service = BookingService(uow)
    try:
        return service.search_bookings(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/{booking_id}/confirmation",
    response_model=BookingConfirmation,
    summary="Get booking confirmation payload",
)
async def get_booking_confirmation(
    booking_id: UUID = Path(..., description="Booking ID"),
    uow: UnitOfWork = Depends(get_uow),
) -> BookingConfirmation:
    """
    Retrieve a confirmation payload for the booking (for emails/PDF, guest view).
    """
    service = BookingService(uow)
    try:
        return service.get_confirmation(booking_id=booking_id)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\bookings\calendar.py ---
# api/v1/bookings/calendar.py
from __future__ import annotations

from datetime import date
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_calendar import (
    CalendarView,
    AvailabilityCalendar,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingCalendarService

router = APIRouter(prefix="/calendar")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.get(
    "/hostels/{hostel_id}",
    response_model=CalendarView,
    summary="Get hostel booking calendar",
)
async def get_hostel_calendar(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> CalendarView:
    """
    Build a booking calendar view for a hostel (check-in/out events per day).
    """
    service = BookingCalendarService(uow)
    try:
        return service.get_hostel_calendar(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/rooms/{room_id}",
    response_model=CalendarView,
    summary="Get room booking calendar",
)
async def get_room_calendar(
    room_id: UUID = Path(..., description="Room ID"),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> CalendarView:
    """
    Build a booking calendar view for a specific room.
    """
    service = BookingCalendarService(uow)
    try:
        return service.get_room_calendar(
            room_id=room_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/hostels/{hostel_id}/availability",
    response_model=AvailabilityCalendar,
    summary="Get hostel availability calendar",
)
async def get_hostel_availability_calendar(
    hostel_id: UUID = Path(..., description="Hostel ID"),
    period_start: date = Query(..., description="Start date (inclusive)"),
    period_end: date = Query(..., description="End date (inclusive)"),
    uow: UnitOfWork = Depends(get_uow),
) -> AvailabilityCalendar:
    """
    Return an availability calendar for a hostel, showing available beds per day.
    """
    service = BookingCalendarService(uow)
    try:
        return service.get_availability_calendar(
            hostel_id=hostel_id,
            period_start=period_start,
            period_end=period_end,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\bookings\cancellation.py ---
# api/v1/bookings/cancellation.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_cancellation import (
    CancellationRequest,
    CancellationResponse,
    RefundCalculation,
    BulkCancellation,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingCancellationService

router = APIRouter(prefix="/cancellation")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/bookings/{booking_id}/preview",
    response_model=RefundCalculation,
    summary="Preview cancellation refund for a booking",
)
async def preview_cancellation(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: CancellationRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> RefundCalculation:
    """
    Preview refund and charges for a potential cancellation without applying it.
    """
    service = BookingCancellationService(uow)
    try:
        return service.preview_cancellation(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bookings/{booking_id}",
    response_model=CancellationResponse,
    summary="Cancel a booking",
)
async def cancel_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: CancellationRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> CancellationResponse:
    """
    Cancel a booking and optionally trigger refund execution.
    """
    service = BookingCancellationService(uow)
    try:
        return service.cancel_booking(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=List[CancellationResponse],
    summary="Bulk cancel bookings",
)
async def bulk_cancel_bookings(
    payload: BulkCancellation,
    uow: UnitOfWork = Depends(get_uow),
) -> List[CancellationResponse]:
    """
    Bulk cancel multiple bookings and compute/apply refunds.
    """
    service = BookingCancellationService(uow)
    try:
        return service.bulk_cancel(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\bookings\conversion.py ---
# api/v1/bookings/conversion.py
from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_conversion import (
    ConvertToStudentRequest,
    ConversionResponse,
    BulkConversion,
    ConversionRollback,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingConversionService

router = APIRouter(prefix="/conversion")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/bookings/{booking_id}",
    response_model=ConversionResponse,
    summary="Convert booking into student",
)
async def convert_booking(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: ConvertToStudentRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ConversionResponse:
    """
    Convert a confirmed booking into a student profile and assign a bed.
    """
    service = BookingConversionService(uow)
    try:
        return service.convert_booking(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bulk",
    response_model=List[ConversionResponse],
    summary="Bulk convert bookings into students",
)
async def bulk_convert_bookings(
    payload: BulkConversion,
    uow: UnitOfWork = Depends(get_uow),
) -> List[ConversionResponse]:
    """
    Bulk convert multiple bookings into students.
    """
    service = BookingConversionService(uow)
    try:
        return service.bulk_convert(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/rollback",
    response_model=ConversionResponse,
    summary="Rollback a booking conversion",
)
async def rollback_conversion(
    payload: ConversionRollback,
    uow: UnitOfWork = Depends(get_uow),
) -> ConversionResponse:
    """
    Rollback a prior conversion (if allowed), reverting student/bed assignment.
    """
    service = BookingConversionService(uow)
    try:
        return service.rollback_conversion(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\bookings\modification.py ---
# api/v1/bookings/modification.py
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_modification import (
    ModificationRequest,
    ModificationResponse,
)
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingModificationService

router = APIRouter(prefix="/modification")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "/bookings/{booking_id}/preview",
    response_model=ModificationResponse,
    summary="Preview booking modification",
)
async def preview_modification(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: ModificationRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ModificationResponse:
    """
    Preview the impact (price, duration) of modifying a booking.
    """
    service = BookingModificationService(uow)
    try:
        return service.preview_modification(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/bookings/{booking_id}/apply",
    response_model=ModificationResponse,
    summary="Apply booking modification",
)
async def apply_modification(
    booking_id: UUID = Path(..., description="Booking ID"),
    payload: ModificationRequest = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> ModificationResponse:
    """
    Apply a modification to a booking (after optional approval).
    """
    service = BookingModificationService(uow)
    try:
        return service.apply_modification(
            booking_id=booking_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\bookings\waitlist.py ---
# api/v1/bookings/waitlist.py
from __future__ import annotations

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Path, Query, status

from api.deps import get_uow
from app.core.exceptions import ServiceError, NotFoundError, ValidationError, ConflictError
from app.schemas.booking.booking_waitlist import (
    WaitlistRequest,
    WaitlistResponse,
    WaitlistStatus,
    WaitlistNotification,
    WaitlistConversion,
    WaitlistCancellation,
    WaitlistManagement,
)
from app.schemas.common.enums import RoomType
from app.services.common.unit_of_work import UnitOfWork
from app.services.booking import BookingWaitlistService

router = APIRouter(prefix="/waitlist")


def _map_service_error(exc: ServiceError) -> HTTPException:
    if isinstance(exc, NotFoundError):
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(exc))
    if isinstance(exc, ValidationError):
        return HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(exc))
    if isinstance(exc, ConflictError):
        return HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(exc))
    return HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc))


@router.post(
    "",
    response_model=WaitlistResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Add visitor to booking waitlist",
)
async def add_to_waitlist(
    payload: WaitlistRequest,
    uow: UnitOfWork = Depends(get_uow),
) -> WaitlistResponse:
    """
    Add a visitor to the waitlist for a hostel/room type.
    """
    service = BookingWaitlistService(uow)
    try:
        return service.add_to_waitlist(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/cancel",
    response_model=WaitlistResponse,
    summary="Cancel a waitlist entry",
)
async def cancel_waitlist_entry(
    payload: WaitlistCancellation,
    uow: UnitOfWork = Depends(get_uow),
) -> WaitlistResponse:
    """
    Cancel an existing waitlist entry.
    """
    service = BookingWaitlistService(uow)
    try:
        return service.cancel_waitlist(request=payload)
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "",
    response_model=WaitlistManagement,
    summary="List waitlist entries for a hostel",
)
async def list_waitlist_for_hostel(
    hostel_id: UUID = Query(..., description="Hostel ID"),
    room_type: Optional[RoomType] = Query(None, description="Optional room type filter"),
    uow: UnitOfWork = Depends(get_uow),
) -> WaitlistManagement:
    """
    List waitlist entries for a hostel (optionally filtered by room type).
    """
    service = BookingWaitlistService(uow)
    try:
        return service.list_waitlist_for_hostel(
            hostel_id=hostel_id,
            room_type=room_type,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{entry_id}/notify",
    response_model=WaitlistResponse,
    summary="Notify a waitlist entry about availability",
)
async def notify_waitlist_entry(
    entry_id: UUID = Path(..., description="Waitlist entry ID"),
    payload: WaitlistNotification = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> WaitlistResponse:
    """
    Mark that a waitlisted visitor has been notified of availability.
    """
    service = BookingWaitlistService(uow)
    try:
        return service.notify_availability(
            entry_id=entry_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.post(
    "/{entry_id}/convert",
    response_model=WaitlistResponse,
    summary="Convert a waitlist entry into a booking",
)
async def convert_waitlist_entry(
    entry_id: UUID = Path(..., description="Waitlist entry ID"),
    payload: WaitlistConversion = ...,
    uow: UnitOfWork = Depends(get_uow),
) -> WaitlistResponse:
    """
    Mark a waitlist entry as converted (booking created) or declined.
    """
    service = BookingWaitlistService(uow)
    try:
        return service.mark_converted(
            entry_id=entry_id,
            request=payload,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)


@router.get(
    "/status",
    response_model=WaitlistStatus,
    summary="Get waitlist status for a visitor",
)
async def get_waitlist_status(
    visitor_id: UUID = Query(..., description="Visitor ID"),
    hostel_id: UUID = Query(..., description="Hostel ID"),
    room_type: Optional[RoomType] = Query(None, description="Optional room type filter"),
    uow: UnitOfWork = Depends(get_uow),
) -> WaitlistStatus:
    """
    Get current waitlist status for a visitor at a hostel (and optional room type).
    """
    service = BookingWaitlistService(uow)
    try:
        return service.get_status(
            visitor_id=visitor_id,
            hostel_id=hostel_id,
            room_type=room_type,
        )
    except ServiceError as exc:
        raise _map_service_error(exc)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\bookings\__init__.py ---
# api/v1/bookings/__init__.py
from __future__ import annotations

from fastapi import APIRouter

from . import bookings
from . import approval
from . import calendar
from . import assignment
from . import cancellation
from . import modification
from . import waitlist
from . import conversion
from . import analytics

router = APIRouter(prefix="/bookings")

router.include_router(bookings.router, tags=["Bookings - Core"])
router.include_router(approval.router, tags=["Bookings - Approval"])
router.include_router(calendar.router, tags=["Bookings - Calendar"])
router.include_router(assignment.router, tags=["Bookings - Assignment"])
router.include_router(cancellation.router, tags=["Bookings - Cancellation"])
router.include_router(modification.router, tags=["Bookings - Modification"])
router.include_router(waitlist.router, tags=["Bookings - Waitlist"])
router.include_router(conversion.router, tags=["Bookings - Conversion"])
router.include_router(analytics.router, tags=["Bookings - Analytics"])

__all__ = ["router"]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\complaints =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\complaints\analytics.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\complaints\assignment.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\complaints\comments.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\complaints\complaints.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\complaints\escalation.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\complaints\feedback.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\complaints\resolution.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\complaints\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\fee_structures =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\fee_structures\config.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\fee_structures\fees.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\fee_structures\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\files =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\files\documents.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\files\images.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\files\upload.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\files\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\hostels =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\hostels\analytics.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\hostels\comparison.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\hostels\details.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\hostels\hostels.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\hostels\public.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\hostels\search.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\hostels\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\inquiries =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\inquiries\inquiries.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\inquiries\status.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\inquiries\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\leaves =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\leaves\apply.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\leaves\approval.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\leaves\balance.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\leaves\leaves.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\leaves\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\maintenance =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\maintenance\analytics.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\maintenance\approval.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\maintenance\assignment.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\maintenance\completion.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\maintenance\cost.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\maintenance\requests.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\maintenance\schedule.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\maintenance\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\mess =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\mess\approval.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\mess\duplicate.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\mess\feedback.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\mess\menu.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\mess\planning.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\mess\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\notifications =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\notifications\notifications.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\notifications\preferences.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\notifications\send.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\notifications\templates.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\notifications\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\payments =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\payments\gateway.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\payments\initiate.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\payments\ledger.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\payments\payments.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\payments\receipt.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\payments\refunds.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\payments\reminders.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\payments\schedule.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\payments\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\referrals =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\referrals\codes.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\referrals\programs.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\referrals\referrals.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\referrals\rewards.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\referrals\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\reviews =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\reviews\analytics.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\reviews\moderation.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\reviews\response.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\reviews\reviews.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\reviews\submission.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\reviews\voting.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\reviews\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\rooms =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\rooms\assignment.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\rooms\availability.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\rooms\beds.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\rooms\rooms.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\rooms\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\search =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\search\analytics.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\search\autocomplete.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\search\search.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\search\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\students =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\students\dashboard.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\students\finance.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\students\profile.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\students\room_history.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\students\search.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\students\students.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\students\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\subscriptions =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\subscriptions\billing.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\subscriptions\cancellation.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\subscriptions\commission.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\subscriptions\plans.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\subscriptions\subscriptions.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\subscriptions\upgrade.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\subscriptions\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\supervisors =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\supervisors\activity.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\supervisors\assignments.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\supervisors\dashboard.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\supervisors\performance.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\supervisors\permissions.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\supervisors\supervisors.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\supervisors\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\users =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\users\activity.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\users\me.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\users\profile.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\users\sessions.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\users\__init__.py ---



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\visitors =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\visitors\dashboard.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\visitors\favorites.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\visitors\preferences.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\visitors\profile.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\visitors\search.py ---


# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\api\v1\visitors\__init__.py ---

