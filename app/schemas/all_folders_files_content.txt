### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\__init__.py ---



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\admin =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\admin_hostel_assignment.py ---
"""
Enhanced admin-hostel assignment schemas with comprehensive validation and performance optimizations.

Provides robust assignment management with audit trails, bulk operations,
and detailed permission tracking for multi-hostel administration.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional, Union
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import PermissionLevel

__all__ = [
    "AdminHostelAssignment",
    "AssignmentCreate",
    "AssignmentUpdate",
    "BulkAssignment",
    "RevokeAssignment",
    "AssignmentList",
    "HostelAdminList",
    "HostelAdminItem",
]


class AdminHostelAssignment(BaseResponseSchema):
    """
    Enhanced admin-hostel assignment with comprehensive tracking and analytics.
    
    Provides complete assignment information including permissions, activity tracking,
    and performance metrics for effective multi-hostel management.
    """
    
    # Core assignment identifiers
    assignment_id: UUID = Field(..., description="Unique assignment identifier")
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")
    
    # Hostel information
    hostel_id: UUID = Field(..., description="Assigned hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city location")
    hostel_type: str = Field(..., description="Hostel type (boys/girls/co-ed)")
    
    # Assignment metadata
    assigned_by: Optional[UUID] = Field(None, description="Admin who created this assignment")
    assigned_by_name: Optional[str] = Field(None, description="Name of assigning admin")
    assigned_date: date = Field(..., description="Date assignment was created")
    
    # Permission configuration
    permission_level: PermissionLevel = Field(..., description="Overall permission level")
    permissions: Dict[str, Union[bool, int, str]] = Field(
        default_factory=dict,
        description="Granular permissions for this hostel assignment"
    )
    
    # Assignment status
    is_active: bool = Field(True, description="Assignment is currently active")
    is_primary: bool = Field(False, description="Primary hostel for this admin")
    
    # Revocation tracking
    revoked_date: Optional[date] = Field(None, description="Date assignment was revoked")
    revoked_by: Optional[UUID] = Field(None, description="Admin who revoked assignment")
    revoke_reason: Optional[str] = Field(None, description="Reason for revocation")
    
    # Activity and performance tracking
    last_accessed: Optional[datetime] = Field(None, description="Last access timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    total_session_time_minutes: int = Field(0, ge=0, description="Total time spent in hostel")
    
    # Performance metrics
    decisions_made: int = Field(0, ge=0, description="Total decisions made for this hostel")
    avg_response_time_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average response time for this hostel"
    )
    satisfaction_score: Optional[Decimal] = Field(
        None, ge=0, le=5, description="Admin satisfaction score for this hostel"
    )

    @computed_field
    @property
    def assignment_duration_days(self) -> int:
        """Calculate total assignment duration in days."""
        end_date = self.revoked_date or date.today()
        return max(0, (end_date - self.assigned_date).days)

    @computed_field
    @property
    def is_recently_accessed(self) -> bool:
        """Check if hostel was accessed within last 24 hours."""
        if not self.last_accessed:
            return False
        hours_since_access = (datetime.utcnow() - self.last_accessed).total_seconds() / 3600
        return hours_since_access <= 24

    @computed_field
    @property
    def permission_summary(self) -> str:
        """Generate human-readable permission summary."""
        level_descriptions = {
            PermissionLevel.FULL_ACCESS: "Full Administrative Access",
            PermissionLevel.LIMITED_ACCESS: "Limited Access with Restrictions",
            PermissionLevel.VIEW_ONLY: "Read-Only Access"
        }
        return level_descriptions.get(self.permission_level, "Unknown Access Level")

    @computed_field
    @property
    def activity_level(self) -> str:
        """Categorize admin activity level for this hostel."""
        if self.access_count == 0:
            return "No Activity"
        elif self.access_count < 10:
            return "Low Activity"
        elif self.access_count < 50:
            return "Moderate Activity"
        elif self.access_count < 100:
            return "High Activity"
        else:
            return "Very High Activity"

    @computed_field
    @property
    def avg_session_duration_minutes(self) -> Decimal:
        """Calculate average session duration."""
        if self.access_count == 0:
            return Decimal("0.00")
        return Decimal(self.total_session_time_minutes / self.access_count).quantize(Decimal("0.01"))


class AssignmentCreate(BaseCreateSchema):
    """
    Enhanced assignment creation with comprehensive validation.
    
    Supports flexible permission configuration and proper validation
    for different access levels and assignment scenarios.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID to assign")
    hostel_id: UUID = Field(..., description="Hostel ID for assignment")
    
    permission_level: PermissionLevel = Field(
        PermissionLevel.FULL_ACCESS,
        description="Permission level for this assignment"
    )
    
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None,
        description="Specific permissions (required for LIMITED_ACCESS level)"
    )
    
    is_primary: bool = Field(False, description="Set as primary hostel for admin")
    
    # Assignment metadata
    assignment_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Administrative notes about this assignment"
    )
    effective_date: Optional[date] = Field(
        None,
        description="Effective date for assignment (defaults to today)"
    )
    
    # Notification preferences
    notify_admin: bool = Field(True, description="Send notification to admin about assignment")
    send_welcome_email: bool = Field(True, description="Send welcome email with hostel details")

    @model_validator(mode="after")
    def validate_assignment_requirements(self) -> "AssignmentCreate":
        """Validate assignment-specific business rules."""
        # Require permissions for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS:
            if not self.permissions:
                raise ValueError(
                    "Specific permissions are required when permission_level is LIMITED_ACCESS"
                )
            if not isinstance(self.permissions, dict) or len(self.permissions) == 0:
                raise ValueError("Permissions must be a non-empty dictionary for LIMITED_ACCESS")
        
        # Validate effective date
        if self.effective_date:
            if self.effective_date < date.today():
                # Allow past dates for historical assignments but validate reasonableness
                days_past = (date.today() - self.effective_date).days
                if days_past > 365:  # More than 1 year in past
                    raise ValueError("Effective date cannot be more than 1 year in the past")
            elif self.effective_date > date.today():
                # Allow future dates for scheduled assignments
                days_future = (self.effective_date - date.today()).days
                if days_future > 90:  # More than 3 months in future
                    raise ValueError("Effective date cannot be more than 90 days in the future")
        
        return self

    @field_validator("permissions")
    @classmethod
    def validate_permissions_structure(
        cls, v: Optional[Dict[str, Union[bool, int, str]]]
    ) -> Optional[Dict[str, Union[bool, int, str]]]:
        """Validate permissions dictionary structure and values."""
        if v is None:
            return None
        
        # Define valid permission keys
        valid_permission_keys = {
            "can_manage_rooms", "can_manage_students", "can_approve_bookings",
            "can_manage_fees", "can_view_financials", "can_manage_supervisors",
            "can_override_decisions", "can_export_data", "can_delete_records",
            "can_manage_hostel_settings", "can_view_analytics", "can_manage_announcements"
        }
        
        # Validate each permission
        for key, value in v.items():
            if key not in valid_permission_keys:
                raise ValueError(f"Invalid permission key: {key}")
            
            # Validate value types
            if not isinstance(value, (bool, int, str)):
                raise ValueError(f"Invalid permission value type for {key}: {type(value)}")
            
            # Validate specific permission constraints
            if key.endswith("_threshold") and isinstance(value, (int, float)):
                if value < 0:
                    raise ValueError(f"Threshold values must be non-negative: {key}")
        
        return v

    @field_validator("assignment_notes")
    @classmethod
    def validate_assignment_notes(cls, v: Optional[str]) -> Optional[str]:
        """Validate and clean assignment notes."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Remove excessive whitespace
            v = " ".join(v.split())
        return v


class AssignmentUpdate(BaseUpdateSchema):
    """
    Enhanced assignment update with selective field modifications.
    
    Allows partial updates while maintaining data consistency
    and proper validation for permission changes.
    """
    
    permission_level: Optional[PermissionLevel] = Field(
        None, description="Updated permission level"
    )
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None, description="Updated specific permissions"
    )
    is_primary: Optional[bool] = Field(None, description="Update primary hostel status")
    is_active: Optional[bool] = Field(None, description="Update assignment active status")
    
    assignment_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Updated assignment notes"
    )
    
    # Update metadata
    update_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for this update"
    )

    @model_validator(mode="after")
    def validate_update_consistency(self) -> "AssignmentUpdate":
        """Validate update field consistency and business rules."""
        # Ensure permissions are provided for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS:
            if self.permissions is None:
                raise ValueError(
                    "Permissions must be specified when updating to LIMITED_ACCESS level"
                )
        
        # Validate that at least one field is being updated
        update_fields = [
            self.permission_level, self.permissions, self.is_primary,
            self.is_active, self.assignment_notes
        ]
        if all(field is None for field in update_fields):
            raise ValueError("At least one field must be specified for update")
        
        return self

    # Reuse permission validation from AssignmentCreate
    _validate_permissions = field_validator("permissions")(
        AssignmentCreate.validate_permissions_structure.__func__
    )


class BulkAssignment(BaseCreateSchema):
    """
    Enhanced bulk assignment with comprehensive validation and options.
    
    Supports efficient batch operations while maintaining data integrity
    and providing flexible assignment strategies.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID for all assignments")
    hostel_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of hostel IDs for bulk assignment (max 50)"
    )
    
    permission_level: PermissionLevel = Field(
        PermissionLevel.FULL_ACCESS,
        description="Permission level for all assignments"
    )
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None,
        description="Permissions applied to all assignments"
    )
    
    primary_hostel_id: Optional[UUID] = Field(
        None,
        description="Which hostel should be set as primary (must be in hostel_ids)"
    )
    
    # Bulk operation strategies
    skip_existing: bool = Field(
        True,
        description="Skip hostels where admin already has active assignment"
    )
    update_existing: bool = Field(
        False,
        description="Update existing assignments with new permissions"
    )
    force_primary: bool = Field(
        False,
        description="Force primary hostel change even if admin has existing primary"
    )
    
    # Metadata and notifications
    bulk_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Notes applied to all assignments in this bulk operation"
    )
    notify_admin: bool = Field(True, description="Send notification about bulk assignment")
    send_summary_email: bool = Field(True, description="Send summary email after completion")

    @field_validator("hostel_ids")
    @classmethod
    def validate_unique_hostel_ids(cls, v: List[UUID]) -> List[UUID]:
        """Ensure hostel IDs are unique and validate list size."""
        if len(v) != len(set(v)):
            raise ValueError("Hostel IDs must be unique in bulk assignment")
        
        if len(v) > 50:
            raise ValueError("Cannot assign more than 50 hostels in a single bulk operation")
        
        return v

    @model_validator(mode="after")
    def validate_bulk_assignment_logic(self) -> "BulkAssignment":
        """Validate bulk assignment business logic and constraints."""
        # Validate primary hostel selection
        if self.primary_hostel_id and self.primary_hostel_id not in self.hostel_ids:
            raise ValueError("Primary hostel ID must be included in the hostel_ids list")
        
        # Validate operation strategy
        if self.skip_existing and self.update_existing:
            raise ValueError(
                "Cannot both skip_existing and update_existing. Choose one strategy."
            )
        
        # Validate permissions for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS and not self.permissions:
            raise ValueError(
                "Permissions must be specified for LIMITED_ACCESS level in bulk assignment"
            )
        
        return self

    # Reuse permission validation
    _validate_permissions = field_validator("permissions")(
        AssignmentCreate.validate_permissions_structure.__func__
    )


class RevokeAssignment(BaseCreateSchema):
    """
    Enhanced assignment revocation with comprehensive audit trail.
    
    Provides detailed revocation tracking with proper validation
    and support for different revocation scenarios.
    """
    
    assignment_id: UUID = Field(..., description="Assignment ID to revoke")
    revoke_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for assignment revocation"
    )
    
    # Revocation timing and options
    effective_date: Optional[date] = Field(
        None,
        description="Effective revocation date (defaults to today)"
    )
    immediate_revocation: bool = Field(
        True,
        description="Revoke immediately or schedule for effective_date"
    )
    
    # Transition management
    transfer_to_admin_id: Optional[UUID] = Field(
        None,
        description="Transfer responsibilities to another admin"
    )
    handover_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Handover notes for responsibility transfer"
    )
    
    # Notification preferences
    notify_affected_admin: bool = Field(True, description="Notify admin being revoked")
    notify_hostel_supervisors: bool = Field(True, description="Notify hostel supervisors")
    
    # Data retention
    retain_access_logs: bool = Field(True, description="Retain access logs for audit")
    archive_permissions: bool = Field(True, description="Archive permission history")

    @field_validator("revoke_reason")
    @classmethod
    def validate_revoke_reason(cls, v: str) -> str:
        """Validate and normalize revocation reason."""
        reason = v.strip()
        if len(reason) < 10:
            raise ValueError("Revocation reason must be at least 10 characters")
        
        # Remove excessive whitespace
        reason = " ".join(reason.split())
        return reason

    @field_validator("effective_date")
    @classmethod
    def validate_effective_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate revocation effective date."""
        if v is not None:
            today = date.today()
            
            # Allow past dates for historical revocations
            if v < today:
                days_past = (today - v).days
                if days_past > 30:  # More than 30 days in past
                    raise ValueError("Effective date cannot be more than 30 days in the past")
            
            # Allow future dates for scheduled revocations
            elif v > today:
                days_future = (v - today).days
                if days_future > 90:  # More than 90 days in future
                    raise ValueError("Effective date cannot be more than 90 days in the future")
        
        return v

    @model_validator(mode="after")
    def validate_revocation_logic(self) -> "RevokeAssignment":
        """Validate revocation business logic."""
        # Validate transfer requirements
        if self.transfer_to_admin_id:
            if not self.handover_notes:
                raise ValueError(
                    "Handover notes are required when transferring to another admin"
                )
        
        # Validate immediate vs scheduled revocation
        if not self.immediate_revocation and not self.effective_date:
            raise ValueError(
                "Effective date must be specified for non-immediate revocation"
            )
        
        if self.immediate_revocation and self.effective_date and self.effective_date != date.today():
            raise ValueError(
                "Immediate revocation cannot have future effective date"
            )
        
        return self


class AssignmentList(BaseSchema):
    """
    Enhanced assignment list with comprehensive admin overview.
    
    Provides aggregated view of all assignments for an admin
    with summary statistics and quick access information.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")
    
    # Assignment statistics
    total_hostels: int = Field(..., ge=0, description="Total hostels assigned")
    active_hostels: int = Field(..., ge=0, description="Currently active assignments")
    inactive_hostels: int = Field(..., ge=0, description="Inactive assignments")
    
    # Primary hostel information
    primary_hostel_id: Optional[UUID] = Field(None, description="Primary hostel ID")
    primary_hostel_name: Optional[str] = Field(None, description="Primary hostel name")
    
    # Activity summary
    last_activity: Optional[datetime] = Field(None, description="Last activity across all hostels")
    total_access_count: int = Field(0, ge=0, description="Total access count across hostels")
    
    # Assignment details
    assignments: List[AdminHostelAssignment] = Field(
        default_factory=list,
        description="Detailed assignment information"
    )
    
    # Performance metrics
    avg_response_time_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average response time across all hostels"
    )
    total_decisions_made: int = Field(0, ge=0, description="Total decisions across hostels")

    @computed_field
    @property
    def assignment_utilization_rate(self) -> Decimal:
        """Calculate assignment utilization rate."""
        if self.total_hostels == 0:
            return Decimal("0.00")
        return Decimal((self.active_hostels / self.total_hostels * 100)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def most_active_hostel(self) -> Optional[str]:
        """Identify most active hostel by access count."""
        if not self.assignments:
            return None
        
        most_active = max(self.assignments, key=lambda x: x.access_count)
        return most_active.hostel_name if most_active.access_count > 0 else None

    @computed_field
    @property
    def permission_distribution(self) -> Dict[str, int]:
        """Calculate distribution of permission levels."""
        distribution = {level.value: 0 for level in PermissionLevel}
        
        for assignment in self.assignments:
            if assignment.is_active:
                distribution[assignment.permission_level.value] += 1
        
        return distribution


class HostelAdminList(BaseSchema):
    """
    Enhanced hostel admin list with comprehensive hostel overview.
    
    Provides detailed view of all admins assigned to a specific hostel
    with their permissions and activity levels.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")
    
    # Admin statistics
    total_admins: int = Field(..., ge=0, description="Total assigned admins")
    active_admins: int = Field(..., ge=0, description="Currently active admin assignments")
    
    # Primary admin information
    primary_admin_id: Optional[UUID] = Field(None, description="Primary admin ID")
    primary_admin_name: Optional[str] = Field(None, description="Primary admin name")
    
    # Coverage information
    coverage_24x7: bool = Field(False, description="24x7 admin coverage available")
    last_admin_activity: Optional[datetime] = Field(None, description="Last admin activity")
    
    # Admin details
    admins: List["HostelAdminItem"] = Field(
        default_factory=list,
        description="Detailed admin assignment information"
    )

    @computed_field
    @property
    def admin_coverage_score(self) -> Decimal:
        """Calculate admin coverage adequacy score."""
        if self.total_admins == 0:
            return Decimal("0.00")
        
        # Base score from admin count (max 50 points)
        count_score = min(self.total_admins * 25, 50)
        
        # Activity score (max 30 points)
        activity_score = 30 if self.active_admins > 0 else 0
        
        # Coverage score (max 20 points)
        coverage_score = 20 if self.coverage_24x7 else 10
        
        total_score = count_score + activity_score + coverage_score
        return Decimal(str(total_score)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def permission_coverage(self) -> Dict[str, bool]:
        """Check if all critical permissions are covered by at least one admin."""
        critical_permissions = [
            "can_manage_students", "can_approve_bookings", "can_manage_fees",
            "can_override_decisions", "can_manage_supervisors"
        ]
        
        coverage = {}
        for permission in critical_permissions:
            coverage[permission] = any(
                admin.permission_level == PermissionLevel.FULL_ACCESS or
                admin.has_specific_permission(permission)
                for admin in self.admins
                if admin.is_active
            )
        
        return coverage


class HostelAdminItem(BaseSchema):
    """
    Enhanced admin item with detailed assignment information.
    
    Represents individual admin assignment within hostel admin list
    with comprehensive permission and activity tracking.
    """
    
    # Admin identification
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")
    
    # Assignment details
    assignment_id: UUID = Field(..., description="Assignment ID")
    permission_level: PermissionLevel = Field(..., description="Permission level")
    is_primary: bool = Field(False, description="Primary admin for this hostel")
    is_active: bool = Field(True, description="Assignment is active")
    
    # Assignment metadata
    assigned_date: date = Field(..., description="Assignment creation date")
    assigned_by_name: Optional[str] = Field(None, description="Name of assigning admin")
    
    # Activity tracking
    last_active: Optional[datetime] = Field(None, description="Last activity timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    avg_session_duration_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average session duration"
    )
    
    # Performance metrics
    decisions_made: int = Field(0, ge=0, description="Total decisions made")
    response_time_avg_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average response time"
    )
    
    # Specific permissions (for limited access)
    specific_permissions: Dict[str, Union[bool, int, str]] = Field(
        default_factory=dict,
        description="Specific permissions for limited access admins"
    )

    @computed_field
    @property
    def assignment_duration_days(self) -> int:
        """Calculate assignment duration in days."""
        return (date.today() - self.assigned_date).days

    @computed_field
    @property
    def activity_status(self) -> str:
        """Determine admin activity status."""
        if not self.last_active:
            return "Never Active"
        
        hours_since_activity = (datetime.utcnow() - self.last_active).total_seconds() / 3600
        
        if hours_since_activity <= 1:
            return "Online"
        elif hours_since_activity <= 24:
            return "Recently Active"
        elif hours_since_activity <= 168:  # 1 week
            return "Active This Week"
        else:
            return "Inactive"

    @computed_field
    @property
    def permission_summary(self) -> str:
        """Generate human-readable permission summary."""
        if self.permission_level == PermissionLevel.FULL_ACCESS:
            return "Full Administrative Access"
        elif self.permission_level == PermissionLevel.LIMITED_ACCESS:
            perm_count = len([p for p in self.specific_permissions.values() if p is True])
            return f"Limited Access ({perm_count} permissions)"
        else:
            return "View Only Access"

    def has_specific_permission(self, permission_key: str) -> bool:
        """Check if admin has a specific permission."""
        if self.permission_level == PermissionLevel.FULL_ACCESS:
            return True
        elif self.permission_level == PermissionLevel.LIMITED_ACCESS:
            return self.specific_permissions.get(permission_key, False) is True
        else:
            return False

    @computed_field
    @property
    def performance_score(self) -> Decimal:
        """Calculate overall performance score for this admin-hostel assignment."""
        score = Decimal("0.00")
        
        # Activity score (40 points max)
        if self.access_count > 0:
            activity_score = min(self.access_count * 2, 40)
            score += Decimal(str(activity_score))
        
        # Decision making score (30 points max)
        if self.decisions_made > 0:
            decision_score = min(self.decisions_made * 3, 30)
            score += Decimal(str(decision_score))
        
        # Response time score (30 points max)
        if self.response_time_avg_minutes:
            # Better response time = higher score
            # Assuming 30 minutes or less is excellent (30 points)
            # More than 120 minutes is poor (0 points)
            response_minutes = float(self.response_time_avg_minutes)
            if response_minutes <= 30:
                response_score = 30
            elif response_minutes >= 120:
                response_score = 0
            else:
                # Linear interpolation
                response_score = 30 * (1 - (response_minutes - 30) / 90)
            score += Decimal(str(response_score))
        
        return score.quantize(Decimal("0.01"))

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\admin_override.py ---
"""
Admin override schemas for supervisor decision management.

Provides structured requests and logs for admin overrides of supervisor actions,
with comprehensive analytics and audit trail support.

Key Improvements:
- Enhanced validation with detailed error messages
- Better type safety and null handling
- Optimized computed properties
- Improved documentation
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "AdminOverrideRequest",
    "OverrideLog",
    "OverrideReason",
    "OverrideSummary",
    "SupervisorOverrideStats",
]


# Constants
VALID_OVERRIDE_TYPES = {
    "complaint_reassignment",
    "complaint_closure",
    "maintenance_approval",
    "maintenance_rejection",
    "fee_waiver",
    "booking_override",
    "student_action",
    "policy_exception",
}

VALID_ENTITY_TYPES = {
    "complaint",
    "maintenance_request",
    "booking",
    "fee_transaction",
    "student_record",
    "policy_violation",
}

VALID_TRENDS = {"increasing", "decreasing", "stable"}
VALID_SUPERVISOR_TRENDS = {"improving", "declining", "stable"}

MIN_REASON_LENGTH = 20
MAX_REASON_LENGTH = 1000


class AdminOverrideRequest(BaseCreateSchema):
    """
    Request to override supervisor decision with comprehensive validation.

    Ensures all override requests are properly documented and justified
    with appropriate context and reasoning.
    """

    supervisor_id: Optional[UUID] = Field(
        None, description="Supervisor whose action is being overridden"
    )
    hostel_id: UUID = Field(..., description="Hostel where override occurs")

    override_type: str = Field(
        ...,
        description="Type of override (complaint_reassignment, maintenance_approval, etc.)",
    )

    entity_type: str = Field(
        ..., description="Type of entity (complaint, maintenance_request, etc.)"
    )
    entity_id: UUID = Field(..., description="ID of entity being modified")

    reason: str = Field(
        ...,
        min_length=MIN_REASON_LENGTH,
        max_length=MAX_REASON_LENGTH,
        description="Detailed reason for override",
    )

    # Original and new values
    original_action: Optional[Dict[str, Any]] = Field(
        None, description="Original supervisor action"
    )
    override_action: Dict[str, Any] = Field(..., description="Admin's override action")

    # Notification
    notify_supervisor: bool = Field(True, description="Notify supervisor of override")

    @field_validator("reason")
    @classmethod
    def normalize_reason(cls, v: str) -> str:
        """Normalize and validate reason text."""
        text = " ".join(v.strip().split())
        if len(text) < MIN_REASON_LENGTH:
            raise ValueError(
                f"Reason must be at least {MIN_REASON_LENGTH} characters after normalization"
            )

        # Check for placeholder text
        placeholder_phrases = [
            "override",
            "because",
            "admin decision",
            "test",
            "no reason",
        ]
        if text.lower() in placeholder_phrases:
            raise ValueError(
                "Please provide a specific, meaningful reason for the override"
            )

        return text

    @field_validator("override_type")
    @classmethod
    def validate_override_type(cls, v: str) -> str:
        """Validate and normalize override type."""
        normalized = v.strip().lower()
        if normalized not in VALID_OVERRIDE_TYPES:
            raise ValueError(
                f"Invalid override type: '{v}'. Valid types: {', '.join(sorted(VALID_OVERRIDE_TYPES))}"
            )
        return normalized

    @field_validator("entity_type")
    @classmethod
    def validate_entity_type(cls, v: str) -> str:
        """Validate and normalize entity type."""
        normalized = v.strip().lower()
        if normalized not in VALID_ENTITY_TYPES:
            raise ValueError(
                f"Invalid entity type: '{v}'. Valid types: {', '.join(sorted(VALID_ENTITY_TYPES))}"
            )
        return normalized

    @field_validator("override_action")
    @classmethod
    def validate_override_action(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        """Validate override action is not empty."""
        if not v:
            raise ValueError("Override action cannot be empty")
        return v

    @model_validator(mode="after")
    def validate_supervisor_requirement(self) -> "AdminOverrideRequest":
        """Validate supervisor_id is required for certain override types."""
        supervisor_required_types = {
            "complaint_reassignment",
            "complaint_closure",
            "maintenance_approval",
            "maintenance_rejection",
        }

        if self.override_type in supervisor_required_types and not self.supervisor_id:
            raise ValueError(
                f"supervisor_id is required for override type: {self.override_type}"
            )

        return self


class OverrideLog(BaseResponseSchema):
    """
    Override log entry with comprehensive tracking.

    Maintains complete audit trail of all override actions
    for accountability and analysis.
    """

    admin_id: UUID = Field(..., description="Admin who performed override")
    admin_name: str = Field(..., min_length=1, description="Admin full name")
    supervisor_id: Optional[UUID] = Field(None, description="Affected supervisor ID")
    supervisor_name: Optional[str] = Field(None, description="Affected supervisor name")

    hostel_id: UUID = Field(..., description="Hostel where override occurred")
    hostel_name: str = Field(..., min_length=1, description="Hostel name")

    override_type: str = Field(..., description="Type of override")
    entity_type: str = Field(..., description="Type of entity")
    entity_id: UUID = Field(..., description="Entity ID")

    reason: str = Field(..., description="Override reason")

    original_action: Optional[Dict[str, Any]] = Field(
        None, description="Original supervisor action"
    )
    override_action: Dict[str, Any] = Field(..., description="Override action taken")

    created_at: datetime = Field(..., description="Override timestamp")

    @computed_field
    @property
    def short_reason(self) -> str:
        """Shortened reason for list displays."""
        max_length = 80
        if len(self.reason) <= max_length:
            return self.reason
        return self.reason[: max_length - 3] + "..."

    @computed_field
    @property
    def override_category(self) -> str:
        """Categorize override by entity type."""
        category_map = {
            "complaint": "Complaint Management",
            "maintenance_request": "Maintenance Operations",
            "booking": "Booking Management",
            "fee_transaction": "Financial Operations",
            "student_record": "Student Management",
            "policy_violation": "Policy Enforcement",
        }
        return category_map.get(self.entity_type, "Other")

    @computed_field
    @property
    def hours_since_override(self) -> int:
        """Calculate hours since override occurred."""
        delta = datetime.utcnow() - self.created_at
        return int(delta.total_seconds() // 3600)


class OverrideReason(BaseSchema):
    """
    Predefined override reasons for standardization.

    Provides common override reasons to ensure consistency
    and facilitate analytics.
    """

    reason_code: str = Field(..., min_length=1, description="Unique reason code")
    reason_text: str = Field(..., min_length=10, description="Reason description")
    category: str = Field(..., min_length=1, description="Reason category")
    requires_detailed_explanation: bool = Field(
        ..., description="Whether detailed explanation is required"
    )

    @field_validator("reason_code")
    @classmethod
    def validate_reason_code(cls, v: str) -> str:
        """Validate and normalize reason code."""
        code = v.strip().upper()
        if not code:
            raise ValueError("Reason code cannot be empty")
        # Ensure alphanumeric with underscores
        if not code.replace("_", "").isalnum():
            raise ValueError(
                "Reason code must contain only letters, numbers, and underscores"
            )
        return code


class OverrideSummary(BaseSchema):
    """
    Summary of admin overrides for a specific period.

    Provides aggregated view of override patterns and trends
    for management oversight and decision-making.
    """

    admin_id: UUID = Field(..., description="Admin user ID")
    period_start: date = Field(..., description="Summary period start date")
    period_end: date = Field(..., description="Summary period end date")

    total_overrides: int = Field(..., ge=0, description="Total overrides in period")

    # By type
    overrides_by_type: Dict[str, int] = Field(
        default_factory=dict, description="Breakdown by override type"
    )

    # By supervisor
    overrides_by_supervisor: Dict[UUID, int] = Field(
        default_factory=dict, description="Breakdown by supervisor"
    )

    # By hostel
    overrides_by_hostel: Dict[UUID, int] = Field(
        default_factory=dict, description="Breakdown by hostel"
    )

    # Trend
    override_trend: str = Field(
        ..., pattern="^(increasing|decreasing|stable)$", description="Override trend"
    )

    @computed_field
    @property
    def average_overrides_per_day(self) -> Decimal:
        """Average overrides per day in the period."""
        days = max(1, (self.period_end - self.period_start).days)
        avg = Decimal(self.total_overrides) / Decimal(days)
        return avg.quantize(Decimal("0.01"))

    @computed_field
    @property
    def most_overridden_supervisor(self) -> Optional[UUID]:
        """Identify supervisor with most overrides."""
        if not self.overrides_by_supervisor:
            return None
        return max(self.overrides_by_supervisor, key=self.overrides_by_supervisor.get)

    @computed_field
    @property
    def most_common_override_type(self) -> Optional[str]:
        """Identify most common override type."""
        if not self.overrides_by_type:
            return None
        return max(self.overrides_by_type, key=self.overrides_by_type.get)

    @computed_field
    @property
    def override_concentration(self) -> Decimal:
        """
        Calculate override concentration (0-100).
        Higher values indicate overrides concentrated on few supervisors.
        """
        if not self.overrides_by_supervisor or self.total_overrides == 0:
            return Decimal("0.00")

        # Calculate Herfindahl-Hirschman Index (HHI) simplified
        supervisor_counts = list(self.overrides_by_supervisor.values())
        shares = [
            (count / self.total_overrides) ** 2 for count in supervisor_counts
        ]
        hhi = sum(shares) * 100

        return Decimal(str(hhi)).quantize(Decimal("0.01"))

    @field_validator("override_trend")
    @classmethod
    def validate_trend(cls, v: str) -> str:
        """Validate trend value."""
        if v not in VALID_TRENDS:
            raise ValueError(
                f"Invalid trend value: '{v}'. Must be one of: {', '.join(VALID_TRENDS)}"
            )
        return v

    @model_validator(mode="after")
    def validate_period_dates(self) -> "OverrideSummary":
        """Validate period dates are logical."""
        if self.period_end < self.period_start:
            raise ValueError("period_end must be after period_start")

        if (self.period_end - self.period_start).days > 365:
            raise ValueError("Summary period cannot exceed 365 days")

        return self


class SupervisorOverrideStats(BaseSchema):
    """
    Override statistics for a specific supervisor.

    Provides detailed override metrics to identify patterns
    and areas for supervisor development or support.
    """

    supervisor_id: UUID = Field(..., description="Supervisor user ID")
    supervisor_name: str = Field(..., min_length=1, description="Supervisor full name")

    total_actions: int = Field(..., ge=0, description="Total actions taken by supervisor")
    total_overrides: int = Field(..., ge=0, description="Total actions overridden")
    override_rate: Decimal = Field(
        ..., ge=0, le=100, description="Percentage of actions overridden"
    )

    # By type
    overrides_by_type: Dict[str, int] = Field(
        default_factory=dict, description="Breakdown by override type"
    )

    # Common reasons
    common_override_reasons: List[str] = Field(
        default_factory=list, description="Most common override reasons"
    )

    # Trend
    recent_trend: str = Field(
        ...,
        pattern="^(improving|declining|stable)$",
        description="Recent trend in override rate",
    )

    @computed_field
    @property
    def is_concerning(self) -> bool:
        """Whether override rate is concerning (> 10%)."""
        return float(self.override_rate) > 10.0

    @computed_field
    @property
    def performance_indicator(self) -> str:
        """Overall performance indicator based on override rate."""
        rate = float(self.override_rate)
        if rate <= 5:
            return "Excellent"
        elif rate <= 10:
            return "Good"
        elif rate <= 20:
            return "Needs Improvement"
        else:
            return "Critical"

    @computed_field
    @property
    def most_overridden_category(self) -> Optional[str]:
        """Identify category with most overrides."""
        if not self.overrides_by_type:
            return None
        return max(self.overrides_by_type, key=self.overrides_by_type.get)

    @field_validator("override_rate")
    @classmethod
    def validate_override_rate(cls, v: Decimal) -> Decimal:
        """Validate override rate is within bounds."""
        if v < 0 or v > 100:
            raise ValueError("Override rate must be between 0 and 100")
        return v.quantize(Decimal("0.01"))

    @field_validator("recent_trend")
    @classmethod
    def validate_trend(cls, v: str) -> str:
        """Validate trend value."""
        if v not in VALID_SUPERVISOR_TRENDS:
            raise ValueError(
                f"Invalid trend: '{v}'. Must be one of: {', '.join(VALID_SUPERVISOR_TRENDS)}"
            )
        return v

    @model_validator(mode="after")
    def validate_stats_consistency(self) -> "SupervisorOverrideStats":
        """Validate statistical consistency."""
        if self.total_overrides > self.total_actions:
            raise ValueError("total_overrides cannot exceed total_actions")

        # Validate override rate calculation
        if self.total_actions > 0:
            calculated_rate = Decimal(self.total_overrides) / Decimal(
                self.total_actions
            ) * 100
            calculated_rate = calculated_rate.quantize(Decimal("0.01"))

            # Allow small rounding difference
            if abs(calculated_rate - self.override_rate) > Decimal("0.1"):
                raise ValueError(
                    f"override_rate {self.override_rate} doesn't match calculated rate {calculated_rate}"
                )

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\admin_permissions.py ---
"""
Admin permission schemas for hostel-level access control.

Defines comprehensive permission structures and role mappings
for fine-grained authorization and access management.

Key Improvements:
- Type-safe permission definitions
- Enhanced validation
- Better defaults and documentation
- Cleaner structure
"""

from __future__ import annotations

from typing import Dict, List, Optional, Set
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import UserRole

__all__ = [
    "AdminPermissions",
    "PermissionMatrix",
    "RolePermissions",
    "PermissionCheck",
]


# Permission categories for organization
ROOM_PERMISSIONS = {"can_manage_rooms", "can_manage_beds"}
STUDENT_PERMISSIONS = {
    "can_manage_students",
    "can_check_in_students",
    "can_check_out_students",
}
BOOKING_PERMISSIONS = {"can_approve_bookings", "can_manage_waitlist"}
FEE_PERMISSIONS = {"can_manage_fees", "can_process_payments", "can_issue_refunds"}
SUPERVISOR_PERMISSIONS = {
    "can_manage_supervisors",
    "can_configure_supervisor_permissions",
    "can_override_supervisor_actions",
}
FINANCIAL_PERMISSIONS = {"can_view_financials", "can_export_financial_data"}
HOSTEL_PERMISSIONS = {
    "can_manage_hostel_settings",
    "can_manage_hostel_profile",
    "can_toggle_public_visibility",
}
DATA_PERMISSIONS = {"can_delete_records", "can_export_data", "can_import_data"}

ALL_PERMISSION_KEYS: Set[str] = (
    ROOM_PERMISSIONS
    | STUDENT_PERMISSIONS
    | BOOKING_PERMISSIONS
    | FEE_PERMISSIONS
    | SUPERVISOR_PERMISSIONS
    | FINANCIAL_PERMISSIONS
    | HOSTEL_PERMISSIONS
    | DATA_PERMISSIONS
)


class AdminPermissions(BaseSchema):
    """
    Admin-specific permissions for a hostel.

    Provides granular control over admin capabilities with
    sensible defaults and comprehensive coverage of all admin functions.
    """

    # Room management
    can_manage_rooms: bool = Field(True, description="Can create/edit/delete rooms")
    can_manage_beds: bool = Field(True, description="Can manage bed assignments")

    # Student management
    can_manage_students: bool = Field(True, description="Can add/edit/remove students")
    can_check_in_students: bool = Field(True, description="Can check-in students")
    can_check_out_students: bool = Field(True, description="Can check-out students")

    # Booking management
    can_approve_bookings: bool = Field(True, description="Can approve/reject bookings")
    can_manage_waitlist: bool = Field(True, description="Can manage waitlist")

    # Fee management
    can_manage_fees: bool = Field(True, description="Can configure fee structures")
    can_process_payments: bool = Field(True, description="Can process manual payments")
    can_issue_refunds: bool = Field(True, description="Can issue refunds")

    # Supervisor management
    can_manage_supervisors: bool = Field(True, description="Can assign/remove supervisors")
    can_configure_supervisor_permissions: bool = Field(
        True, description="Can modify supervisor permissions"
    )
    can_override_supervisor_actions: bool = Field(
        True, description="Can override supervisor decisions"
    )

    # Financial access
    can_view_financials: bool = Field(True, description="Can view financial reports")
    can_export_financial_data: bool = Field(
        True, description="Can export financial data"
    )

    # Hostel configuration
    can_manage_hostel_settings: bool = Field(
        True, description="Can modify hostel settings"
    )
    can_manage_hostel_profile: bool = Field(
        True, description="Can edit public hostel profile"
    )
    can_toggle_public_visibility: bool = Field(
        True, description="Can make hostel public/private"
    )

    # Data management
    can_delete_records: bool = Field(
        False, description="Can permanently delete records"
    )
    can_export_data: bool = Field(True, description="Can export data")
    can_import_data: bool = Field(True, description="Can bulk import data")

    def has_permission(self, permission_key: str) -> bool:
        """Check if specific permission is granted."""
        if permission_key not in ALL_PERMISSION_KEYS:
            return False
        return bool(getattr(self, permission_key, False))

    def get_granted_permissions(self) -> List[str]:
        """Get list of all granted permissions."""
        return [key for key in ALL_PERMISSION_KEYS if self.has_permission(key)]

    def get_denied_permissions(self) -> List[str]:
        """Get list of all denied permissions."""
        return [key for key in ALL_PERMISSION_KEYS if not self.has_permission(key)]

    @property
    def permission_count(self) -> int:
        """Count of granted permissions."""
        return len(self.get_granted_permissions())

    @property
    def has_full_access(self) -> bool:
        """Check if has all permissions."""
        return self.permission_count == len(ALL_PERMISSION_KEYS)

    @property
    def has_limited_access(self) -> bool:
        """Check if has limited permissions."""
        return 0 < self.permission_count < len(ALL_PERMISSION_KEYS)

    @property
    def has_no_access(self) -> bool:
        """Check if has no permissions."""
        return self.permission_count == 0


class PermissionMatrix(BaseSchema):
    """
    Permission matrix showing capabilities for each role.

    Provides comprehensive mapping of roles to permissions
    for authorization and UI rendering.
    """

    permissions: Dict[UserRole, List[str]] = Field(
        ..., description="Map of role to list of permission keys"
    )

    @field_validator("permissions")
    @classmethod
    def validate_permissions(cls, v: Dict[UserRole, List[str]]) -> Dict[UserRole, List[str]]:
        """Validate permission keys are valid."""
        for role, perms in v.items():
            invalid_perms = set(perms) - ALL_PERMISSION_KEYS
            if invalid_perms:
                raise ValueError(
                    f"Invalid permissions for role {role.value}: {', '.join(invalid_perms)}"
                )
        return v

    def get_role_permissions(self, role: UserRole) -> List[str]:
        """Get permissions for a specific role."""
        return self.permissions.get(role, [])

    def role_has_permission(self, role: UserRole, permission_key: str) -> bool:
        """Check if role has specific permission."""
        return permission_key in self.permissions.get(role, [])


class RolePermissions(BaseSchema):
    """
    Permissions for a specific role with metadata.

    Provides detailed information about role capabilities
    with descriptions for documentation and UI display.
    """

    role: UserRole = Field(..., description="User role")
    permissions: List[str] = Field(..., description="List of permission keys")
    description: str = Field(..., min_length=10, description="Role description")

    @field_validator("permissions")
    @classmethod
    def validate_permissions(cls, v: List[str]) -> List[str]:
        """Validate all permission keys are valid."""
        invalid = set(v) - ALL_PERMISSION_KEYS
        if invalid:
            raise ValueError(
                f"Invalid permission keys: {', '.join(invalid)}. "
                f"Valid keys: {', '.join(sorted(ALL_PERMISSION_KEYS))}"
            )
        # Remove duplicates while preserving order
        seen = set()
        unique_perms = []
        for perm in v:
            if perm not in seen:
                seen.add(perm)
                unique_perms.append(perm)
        return unique_perms

    @property
    def permission_categories(self) -> Dict[str, List[str]]:
        """Organize permissions by category."""
        categories = {
            "Room Management": [],
            "Student Management": [],
            "Booking Management": [],
            "Fee Management": [],
            "Supervisor Management": [],
            "Financial Access": [],
            "Hostel Configuration": [],
            "Data Management": [],
        }

        for perm in self.permissions:
            if perm in ROOM_PERMISSIONS:
                categories["Room Management"].append(perm)
            elif perm in STUDENT_PERMISSIONS:
                categories["Student Management"].append(perm)
            elif perm in BOOKING_PERMISSIONS:
                categories["Booking Management"].append(perm)
            elif perm in FEE_PERMISSIONS:
                categories["Fee Management"].append(perm)
            elif perm in SUPERVISOR_PERMISSIONS:
                categories["Supervisor Management"].append(perm)
            elif perm in FINANCIAL_PERMISSIONS:
                categories["Financial Access"].append(perm)
            elif perm in HOSTEL_PERMISSIONS:
                categories["Hostel Configuration"].append(perm)
            elif perm in DATA_PERMISSIONS:
                categories["Data Management"].append(perm)

        # Remove empty categories
        return {k: v for k, v in categories.items() if v}


class PermissionCheck(BaseSchema):
    """
    Permission check request and result.

    Used to verify if a user has specific permission
    with detailed reasoning for access decisions.
    """

    user_id: UUID = Field(..., description="User ID to check")
    hostel_id: UUID = Field(..., description="Hostel ID context")
    permission_key: str = Field(..., description="Permission key to check")

    has_permission: bool = Field(..., description="Whether user has permission")
    reason: Optional[str] = Field(None, description="Reason if permission denied")

    @field_validator("permission_key")
    @classmethod
    def validate_permission_key(cls, v: str) -> str:
        """Validate permission key is valid."""
        value = v.strip()
        if not value:
            raise ValueError("permission_key cannot be empty")

        if value not in ALL_PERMISSION_KEYS:
            raise ValueError(
                f"Invalid permission key: '{value}'. "
                f"Valid keys: {', '.join(sorted(ALL_PERMISSION_KEYS))}"
            )

        return value

    @model_validator(mode="after")
    def validate_reason_requirement(self) -> "PermissionCheck":
        """Validate reason is provided when permission is denied."""
        if not self.has_permission and not self.reason:
            raise ValueError("reason is required when permission is denied")
        return self

    @property
    def access_status(self) -> str:
        """Get human-readable access status."""
        return "Granted" if self.has_permission else "Denied"

    @property
    def permission_category(self) -> str:
        """Get category of checked permission."""
        if self.permission_key in ROOM_PERMISSIONS:
            return "Room Management"
        elif self.permission_key in STUDENT_PERMISSIONS:
            return "Student Management"
        elif self.permission_key in BOOKING_PERMISSIONS:
            return "Booking Management"
        elif self.permission_key in FEE_PERMISSIONS:
            return "Fee Management"
        elif self.permission_key in SUPERVISOR_PERMISSIONS:
            return "Supervisor Management"
        elif self.permission_key in FINANCIAL_PERMISSIONS:
            return "Financial Access"
        elif self.permission_key in HOSTEL_PERMISSIONS:
            return "Hostel Configuration"
        elif self.permission_key in DATA_PERMISSIONS:
            return "Data Management"
        else:
            return "Unknown"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\admin ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\admin =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\admin_hostel_assignment.py ---
"""
Enhanced admin-hostel assignment schemas with comprehensive validation and performance optimizations.

Provides robust assignment management with audit trails, bulk operations,
and detailed permission tracking for multi-hostel administration.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional, Union
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import PermissionLevel

__all__ = [
    "AdminHostelAssignment",
    "AssignmentCreate",
    "AssignmentUpdate",
    "BulkAssignment",
    "RevokeAssignment",
    "AssignmentList",
    "HostelAdminList",
    "HostelAdminItem",
]


class AdminHostelAssignment(BaseResponseSchema):
    """
    Enhanced admin-hostel assignment with comprehensive tracking and analytics.
    
    Provides complete assignment information including permissions, activity tracking,
    and performance metrics for effective multi-hostel management.
    """
    
    # Core assignment identifiers
    assignment_id: UUID = Field(..., description="Unique assignment identifier")
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")
    
    # Hostel information
    hostel_id: UUID = Field(..., description="Assigned hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city location")
    hostel_type: str = Field(..., description="Hostel type (boys/girls/co-ed)")
    
    # Assignment metadata
    assigned_by: Optional[UUID] = Field(None, description="Admin who created this assignment")
    assigned_by_name: Optional[str] = Field(None, description="Name of assigning admin")
    assigned_date: date = Field(..., description="Date assignment was created")
    
    # Permission configuration
    permission_level: PermissionLevel = Field(..., description="Overall permission level")
    permissions: Dict[str, Union[bool, int, str]] = Field(
        default_factory=dict,
        description="Granular permissions for this hostel assignment"
    )
    
    # Assignment status
    is_active: bool = Field(True, description="Assignment is currently active")
    is_primary: bool = Field(False, description="Primary hostel for this admin")
    
    # Revocation tracking
    revoked_date: Optional[date] = Field(None, description="Date assignment was revoked")
    revoked_by: Optional[UUID] = Field(None, description="Admin who revoked assignment")
    revoke_reason: Optional[str] = Field(None, description="Reason for revocation")
    
    # Activity and performance tracking
    last_accessed: Optional[datetime] = Field(None, description="Last access timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    total_session_time_minutes: int = Field(0, ge=0, description="Total time spent in hostel")
    
    # Performance metrics
    decisions_made: int = Field(0, ge=0, description="Total decisions made for this hostel")
    avg_response_time_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average response time for this hostel"
    )
    satisfaction_score: Optional[Decimal] = Field(
        None, ge=0, le=5, description="Admin satisfaction score for this hostel"
    )

    @computed_field
    @property
    def assignment_duration_days(self) -> int:
        """Calculate total assignment duration in days."""
        end_date = self.revoked_date or date.today()
        return max(0, (end_date - self.assigned_date).days)

    @computed_field
    @property
    def is_recently_accessed(self) -> bool:
        """Check if hostel was accessed within last 24 hours."""
        if not self.last_accessed:
            return False
        hours_since_access = (datetime.utcnow() - self.last_accessed).total_seconds() / 3600
        return hours_since_access <= 24

    @computed_field
    @property
    def permission_summary(self) -> str:
        """Generate human-readable permission summary."""
        level_descriptions = {
            PermissionLevel.FULL_ACCESS: "Full Administrative Access",
            PermissionLevel.LIMITED_ACCESS: "Limited Access with Restrictions",
            PermissionLevel.VIEW_ONLY: "Read-Only Access"
        }
        return level_descriptions.get(self.permission_level, "Unknown Access Level")

    @computed_field
    @property
    def activity_level(self) -> str:
        """Categorize admin activity level for this hostel."""
        if self.access_count == 0:
            return "No Activity"
        elif self.access_count < 10:
            return "Low Activity"
        elif self.access_count < 50:
            return "Moderate Activity"
        elif self.access_count < 100:
            return "High Activity"
        else:
            return "Very High Activity"

    @computed_field
    @property
    def avg_session_duration_minutes(self) -> Decimal:
        """Calculate average session duration."""
        if self.access_count == 0:
            return Decimal("0.00")
        return Decimal(self.total_session_time_minutes / self.access_count).quantize(Decimal("0.01"))


class AssignmentCreate(BaseCreateSchema):
    """
    Enhanced assignment creation with comprehensive validation.
    
    Supports flexible permission configuration and proper validation
    for different access levels and assignment scenarios.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID to assign")
    hostel_id: UUID = Field(..., description="Hostel ID for assignment")
    
    permission_level: PermissionLevel = Field(
        PermissionLevel.FULL_ACCESS,
        description="Permission level for this assignment"
    )
    
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None,
        description="Specific permissions (required for LIMITED_ACCESS level)"
    )
    
    is_primary: bool = Field(False, description="Set as primary hostel for admin")
    
    # Assignment metadata
    assignment_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Administrative notes about this assignment"
    )
    effective_date: Optional[date] = Field(
        None,
        description="Effective date for assignment (defaults to today)"
    )
    
    # Notification preferences
    notify_admin: bool = Field(True, description="Send notification to admin about assignment")
    send_welcome_email: bool = Field(True, description="Send welcome email with hostel details")

    @model_validator(mode="after")
    def validate_assignment_requirements(self) -> "AssignmentCreate":
        """Validate assignment-specific business rules."""
        # Require permissions for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS:
            if not self.permissions:
                raise ValueError(
                    "Specific permissions are required when permission_level is LIMITED_ACCESS"
                )
            if not isinstance(self.permissions, dict) or len(self.permissions) == 0:
                raise ValueError("Permissions must be a non-empty dictionary for LIMITED_ACCESS")
        
        # Validate effective date
        if self.effective_date:
            if self.effective_date < date.today():
                # Allow past dates for historical assignments but validate reasonableness
                days_past = (date.today() - self.effective_date).days
                if days_past > 365:  # More than 1 year in past
                    raise ValueError("Effective date cannot be more than 1 year in the past")
            elif self.effective_date > date.today():
                # Allow future dates for scheduled assignments
                days_future = (self.effective_date - date.today()).days
                if days_future > 90:  # More than 3 months in future
                    raise ValueError("Effective date cannot be more than 90 days in the future")
        
        return self

    @field_validator("permissions")
    @classmethod
    def validate_permissions_structure(
        cls, v: Optional[Dict[str, Union[bool, int, str]]]
    ) -> Optional[Dict[str, Union[bool, int, str]]]:
        """Validate permissions dictionary structure and values."""
        if v is None:
            return None
        
        # Define valid permission keys
        valid_permission_keys = {
            "can_manage_rooms", "can_manage_students", "can_approve_bookings",
            "can_manage_fees", "can_view_financials", "can_manage_supervisors",
            "can_override_decisions", "can_export_data", "can_delete_records",
            "can_manage_hostel_settings", "can_view_analytics", "can_manage_announcements"
        }
        
        # Validate each permission
        for key, value in v.items():
            if key not in valid_permission_keys:
                raise ValueError(f"Invalid permission key: {key}")
            
            # Validate value types
            if not isinstance(value, (bool, int, str)):
                raise ValueError(f"Invalid permission value type for {key}: {type(value)}")
            
            # Validate specific permission constraints
            if key.endswith("_threshold") and isinstance(value, (int, float)):
                if value < 0:
                    raise ValueError(f"Threshold values must be non-negative: {key}")
        
        return v

    @field_validator("assignment_notes")
    @classmethod
    def validate_assignment_notes(cls, v: Optional[str]) -> Optional[str]:
        """Validate and clean assignment notes."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Remove excessive whitespace
            v = " ".join(v.split())
        return v


class AssignmentUpdate(BaseUpdateSchema):
    """
    Enhanced assignment update with selective field modifications.
    
    Allows partial updates while maintaining data consistency
    and proper validation for permission changes.
    """
    
    permission_level: Optional[PermissionLevel] = Field(
        None, description="Updated permission level"
    )
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None, description="Updated specific permissions"
    )
    is_primary: Optional[bool] = Field(None, description="Update primary hostel status")
    is_active: Optional[bool] = Field(None, description="Update assignment active status")
    
    assignment_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Updated assignment notes"
    )
    
    # Update metadata
    update_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for this update"
    )

    @model_validator(mode="after")
    def validate_update_consistency(self) -> "AssignmentUpdate":
        """Validate update field consistency and business rules."""
        # Ensure permissions are provided for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS:
            if self.permissions is None:
                raise ValueError(
                    "Permissions must be specified when updating to LIMITED_ACCESS level"
                )
        
        # Validate that at least one field is being updated
        update_fields = [
            self.permission_level, self.permissions, self.is_primary,
            self.is_active, self.assignment_notes
        ]
        if all(field is None for field in update_fields):
            raise ValueError("At least one field must be specified for update")
        
        return self

    # Reuse permission validation from AssignmentCreate
    _validate_permissions = field_validator("permissions")(
        AssignmentCreate.validate_permissions_structure.__func__
    )


class BulkAssignment(BaseCreateSchema):
    """
    Enhanced bulk assignment with comprehensive validation and options.
    
    Supports efficient batch operations while maintaining data integrity
    and providing flexible assignment strategies.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID for all assignments")
    hostel_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of hostel IDs for bulk assignment (max 50)"
    )
    
    permission_level: PermissionLevel = Field(
        PermissionLevel.FULL_ACCESS,
        description="Permission level for all assignments"
    )
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None,
        description="Permissions applied to all assignments"
    )
    
    primary_hostel_id: Optional[UUID] = Field(
        None,
        description="Which hostel should be set as primary (must be in hostel_ids)"
    )
    
    # Bulk operation strategies
    skip_existing: bool = Field(
        True,
        description="Skip hostels where admin already has active assignment"
    )
    update_existing: bool = Field(
        False,
        description="Update existing assignments with new permissions"
    )
    force_primary: bool = Field(
        False,
        description="Force primary hostel change even if admin has existing primary"
    )
    
    # Metadata and notifications
    bulk_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Notes applied to all assignments in this bulk operation"
    )
    notify_admin: bool = Field(True, description="Send notification about bulk assignment")
    send_summary_email: bool = Field(True, description="Send summary email after completion")

    @field_validator("hostel_ids")
    @classmethod
    def validate_unique_hostel_ids(cls, v: List[UUID]) -> List[UUID]:
        """Ensure hostel IDs are unique and validate list size."""
        if len(v) != len(set(v)):
            raise ValueError("Hostel IDs must be unique in bulk assignment")
        
        if len(v) > 50:
            raise ValueError("Cannot assign more than 50 hostels in a single bulk operation")
        
        return v

    @model_validator(mode="after")
    def validate_bulk_assignment_logic(self) -> "BulkAssignment":
        """Validate bulk assignment business logic and constraints."""
        # Validate primary hostel selection
        if self.primary_hostel_id and self.primary_hostel_id not in self.hostel_ids:
            raise ValueError("Primary hostel ID must be included in the hostel_ids list")
        
        # Validate operation strategy
        if self.skip_existing and self.update_existing:
            raise ValueError(
                "Cannot both skip_existing and update_existing. Choose one strategy."
            )
        
        # Validate permissions for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS and not self.permissions:
            raise ValueError(
                "Permissions must be specified for LIMITED_ACCESS level in bulk assignment"
            )
        
        return self

    # Reuse permission validation
    _validate_permissions = field_validator("permissions")(
        AssignmentCreate.validate_permissions_structure.__func__
    )


class RevokeAssignment(BaseCreateSchema):
    """
    Enhanced assignment revocation with comprehensive audit trail.
    
    Provides detailed revocation tracking with proper validation
    and support for different revocation scenarios.
    """
    
    assignment_id: UUID = Field(..., description="Assignment ID to revoke")
    revoke_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for assignment revocation"
    )
    
    # Revocation timing and options
    effective_date: Optional[date] = Field(
        None,
        description="Effective revocation date (defaults to today)"
    )
    immediate_revocation: bool = Field(
        True,
        description="Revoke immediately or schedule for effective_date"
    )
    
    # Transition management
    transfer_to_admin_id: Optional[UUID] = Field(
        None,
        description="Transfer responsibilities to another admin"
    )
    handover_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Handover notes for responsibility transfer"
    )
    
    # Notification preferences
    notify_affected_admin: bool = Field(True, description="Notify admin being revoked")
    notify_hostel_supervisors: bool = Field(True, description="Notify hostel supervisors")
    
    # Data retention
    retain_access_logs: bool = Field(True, description="Retain access logs for audit")
    archive_permissions: bool = Field(True, description="Archive permission history")

    @field_validator("revoke_reason")
    @classmethod
    def validate_revoke_reason(cls, v: str) -> str:
        """Validate and normalize revocation reason."""
        reason = v.strip()
        if len(reason) < 10:
            raise ValueError("Revocation reason must be at least 10 characters")
        
        # Remove excessive whitespace
        reason = " ".join(reason.split())
        return reason

    @field_validator("effective_date")
    @classmethod
    def validate_effective_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate revocation effective date."""
        if v is not None:
            today = date.today()
            
            # Allow past dates for historical revocations
            if v < today:
                days_past = (today - v).days
                if days_past > 30:  # More than 30 days in past
                    raise ValueError("Effective date cannot be more than 30 days in the past")
            
            # Allow future dates for scheduled revocations
            elif v > today:
                days_future = (v - today).days
                if days_future > 90:  # More than 90 days in future
                    raise ValueError("Effective date cannot be more than 90 days in the future")
        
        return v

    @model_validator(mode="after")
    def validate_revocation_logic(self) -> "RevokeAssignment":
        """Validate revocation business logic."""
        # Validate transfer requirements
        if self.transfer_to_admin_id:
            if not self.handover_notes:
                raise ValueError(
                    "Handover notes are required when transferring to another admin"
                )
        
        # Validate immediate vs scheduled revocation
        if not self.immediate_revocation and not self.effective_date:
            raise ValueError(
                "Effective date must be specified for non-immediate revocation"
            )
        
        if self.immediate_revocation and self.effective_date and self.effective_date != date.today():
            raise ValueError(
                "Immediate revocation cannot have future effective date"
            )
        
        return self


class AssignmentList(BaseSchema):
    """
    Enhanced assignment list with comprehensive admin overview.
    
    Provides aggregated view of all assignments for an admin
    with summary statistics and quick access information.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")
    
    # Assignment statistics
    total_hostels: int = Field(..., ge=0, description="Total hostels assigned")
    active_hostels: int = Field(..., ge=0, description="Currently active assignments")
    inactive_hostels: int = Field(..., ge=0, description="Inactive assignments")
    
    # Primary hostel information
    primary_hostel_id: Optional[UUID] = Field(None, description="Primary hostel ID")
    primary_hostel_name: Optional[str] = Field(None, description="Primary hostel name")
    
    # Activity summary
    last_activity: Optional[datetime] = Field(None, description="Last activity across all hostels")
    total_access_count: int = Field(0, ge=0, description="Total access count across hostels")
    
    # Assignment details
    assignments: List[AdminHostelAssignment] = Field(
        default_factory=list,
        description="Detailed assignment information"
    )
    
    # Performance metrics
    avg_response_time_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average response time across all hostels"
    )
    total_decisions_made: int = Field(0, ge=0, description="Total decisions across hostels")

    @computed_field
    @property
    def assignment_utilization_rate(self) -> Decimal:
        """Calculate assignment utilization rate."""
        if self.total_hostels == 0:
            return Decimal("0.00")
        return Decimal((self.active_hostels / self.total_hostels * 100)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def most_active_hostel(self) -> Optional[str]:
        """Identify most active hostel by access count."""
        if not self.assignments:
            return None
        
        most_active = max(self.assignments, key=lambda x: x.access_count)
        return most_active.hostel_name if most_active.access_count > 0 else None

    @computed_field
    @property
    def permission_distribution(self) -> Dict[str, int]:
        """Calculate distribution of permission levels."""
        distribution = {level.value: 0 for level in PermissionLevel}
        
        for assignment in self.assignments:
            if assignment.is_active:
                distribution[assignment.permission_level.value] += 1
        
        return distribution


class HostelAdminList(BaseSchema):
    """
    Enhanced hostel admin list with comprehensive hostel overview.
    
    Provides detailed view of all admins assigned to a specific hostel
    with their permissions and activity levels.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")
    
    # Admin statistics
    total_admins: int = Field(..., ge=0, description="Total assigned admins")
    active_admins: int = Field(..., ge=0, description="Currently active admin assignments")
    
    # Primary admin information
    primary_admin_id: Optional[UUID] = Field(None, description="Primary admin ID")
    primary_admin_name: Optional[str] = Field(None, description="Primary admin name")
    
    # Coverage information
    coverage_24x7: bool = Field(False, description="24x7 admin coverage available")
    last_admin_activity: Optional[datetime] = Field(None, description="Last admin activity")
    
    # Admin details
    admins: List["HostelAdminItem"] = Field(
        default_factory=list,
        description="Detailed admin assignment information"
    )

    @computed_field
    @property
    def admin_coverage_score(self) -> Decimal:
        """Calculate admin coverage adequacy score."""
        if self.total_admins == 0:
            return Decimal("0.00")
        
        # Base score from admin count (max 50 points)
        count_score = min(self.total_admins * 25, 50)
        
        # Activity score (max 30 points)
        activity_score = 30 if self.active_admins > 0 else 0
        
        # Coverage score (max 20 points)
        coverage_score = 20 if self.coverage_24x7 else 10
        
        total_score = count_score + activity_score + coverage_score
        return Decimal(str(total_score)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def permission_coverage(self) -> Dict[str, bool]:
        """Check if all critical permissions are covered by at least one admin."""
        critical_permissions = [
            "can_manage_students", "can_approve_bookings", "can_manage_fees",
            "can_override_decisions", "can_manage_supervisors"
        ]
        
        coverage = {}
        for permission in critical_permissions:
            coverage[permission] = any(
                admin.permission_level == PermissionLevel.FULL_ACCESS or
                admin.has_specific_permission(permission)
                for admin in self.admins
                if admin.is_active
            )
        
        return coverage


class HostelAdminItem(BaseSchema):
    """
    Enhanced admin item with detailed assignment information.
    
    Represents individual admin assignment within hostel admin list
    with comprehensive permission and activity tracking.
    """
    
    # Admin identification
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")
    
    # Assignment details
    assignment_id: UUID = Field(..., description="Assignment ID")
    permission_level: PermissionLevel = Field(..., description="Permission level")
    is_primary: bool = Field(False, description="Primary admin for this hostel")
    is_active: bool = Field(True, description="Assignment is active")
    
    # Assignment metadata
    assigned_date: date = Field(..., description="Assignment creation date")
    assigned_by_name: Optional[str] = Field(None, description="Name of assigning admin")
    
    # Activity tracking
    last_active: Optional[datetime] = Field(None, description="Last activity timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    avg_session_duration_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average session duration"
    )
    
    # Performance metrics
    decisions_made: int = Field(0, ge=0, description="Total decisions made")
    response_time_avg_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average response time"
    )
    
    # Specific permissions (for limited access)
    specific_permissions: Dict[str, Union[bool, int, str]] = Field(
        default_factory=dict,
        description="Specific permissions for limited access admins"
    )

    @computed_field
    @property
    def assignment_duration_days(self) -> int:
        """Calculate assignment duration in days."""
        return (date.today() - self.assigned_date).days

    @computed_field
    @property
    def activity_status(self) -> str:
        """Determine admin activity status."""
        if not self.last_active:
            return "Never Active"
        
        hours_since_activity = (datetime.utcnow() - self.last_active).total_seconds() / 3600
        
        if hours_since_activity <= 1:
            return "Online"
        elif hours_since_activity <= 24:
            return "Recently Active"
        elif hours_since_activity <= 168:  # 1 week
            return "Active This Week"
        else:
            return "Inactive"

    @computed_field
    @property
    def permission_summary(self) -> str:
        """Generate human-readable permission summary."""
        if self.permission_level == PermissionLevel.FULL_ACCESS:
            return "Full Administrative Access"
        elif self.permission_level == PermissionLevel.LIMITED_ACCESS:
            perm_count = len([p for p in self.specific_permissions.values() if p is True])
            return f"Limited Access ({perm_count} permissions)"
        else:
            return "View Only Access"

    def has_specific_permission(self, permission_key: str) -> bool:
        """Check if admin has a specific permission."""
        if self.permission_level == PermissionLevel.FULL_ACCESS:
            return True
        elif self.permission_level == PermissionLevel.LIMITED_ACCESS:
            return self.specific_permissions.get(permission_key, False) is True
        else:
            return False

    @computed_field
    @property
    def performance_score(self) -> Decimal:
        """Calculate overall performance score for this admin-hostel assignment."""
        score = Decimal("0.00")
        
        # Activity score (40 points max)
        if self.access_count > 0:
            activity_score = min(self.access_count * 2, 40)
            score += Decimal(str(activity_score))
        
        # Decision making score (30 points max)
        if self.decisions_made > 0:
            decision_score = min(self.decisions_made * 3, 30)
            score += Decimal(str(decision_score))
        
        # Response time score (30 points max)
        if self.response_time_avg_minutes:
            # Better response time = higher score
            # Assuming 30 minutes or less is excellent (30 points)
            # More than 120 minutes is poor (0 points)
            response_minutes = float(self.response_time_avg_minutes)
            if response_minutes <= 30:
                response_score = 30
            elif response_minutes >= 120:
                response_score = 0
            else:
                # Linear interpolation
                response_score = 30 * (1 - (response_minutes - 30) / 90)
            score += Decimal(str(response_score))
        
        return score.quantize(Decimal("0.01"))

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\admin_override.py ---
"""
Admin override schemas for supervisor decision management.

Provides structured requests and logs for admin overrides of supervisor actions,
with comprehensive analytics and audit trail support.

Key Improvements:
- Enhanced validation with detailed error messages
- Better type safety and null handling
- Optimized computed properties
- Improved documentation
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "AdminOverrideRequest",
    "OverrideLog",
    "OverrideReason",
    "OverrideSummary",
    "SupervisorOverrideStats",
]


# Constants
VALID_OVERRIDE_TYPES = {
    "complaint_reassignment",
    "complaint_closure",
    "maintenance_approval",
    "maintenance_rejection",
    "fee_waiver",
    "booking_override",
    "student_action",
    "policy_exception",
}

VALID_ENTITY_TYPES = {
    "complaint",
    "maintenance_request",
    "booking",
    "fee_transaction",
    "student_record",
    "policy_violation",
}

VALID_TRENDS = {"increasing", "decreasing", "stable"}
VALID_SUPERVISOR_TRENDS = {"improving", "declining", "stable"}

MIN_REASON_LENGTH = 20
MAX_REASON_LENGTH = 1000


class AdminOverrideRequest(BaseCreateSchema):
    """
    Request to override supervisor decision with comprehensive validation.

    Ensures all override requests are properly documented and justified
    with appropriate context and reasoning.
    """

    supervisor_id: Optional[UUID] = Field(
        None, description="Supervisor whose action is being overridden"
    )
    hostel_id: UUID = Field(..., description="Hostel where override occurs")

    override_type: str = Field(
        ...,
        description="Type of override (complaint_reassignment, maintenance_approval, etc.)",
    )

    entity_type: str = Field(
        ..., description="Type of entity (complaint, maintenance_request, etc.)"
    )
    entity_id: UUID = Field(..., description="ID of entity being modified")

    reason: str = Field(
        ...,
        min_length=MIN_REASON_LENGTH,
        max_length=MAX_REASON_LENGTH,
        description="Detailed reason for override",
    )

    # Original and new values
    original_action: Optional[Dict[str, Any]] = Field(
        None, description="Original supervisor action"
    )
    override_action: Dict[str, Any] = Field(..., description="Admin's override action")

    # Notification
    notify_supervisor: bool = Field(True, description="Notify supervisor of override")

    @field_validator("reason")
    @classmethod
    def normalize_reason(cls, v: str) -> str:
        """Normalize and validate reason text."""
        text = " ".join(v.strip().split())
        if len(text) < MIN_REASON_LENGTH:
            raise ValueError(
                f"Reason must be at least {MIN_REASON_LENGTH} characters after normalization"
            )

        # Check for placeholder text
        placeholder_phrases = [
            "override",
            "because",
            "admin decision",
            "test",
            "no reason",
        ]
        if text.lower() in placeholder_phrases:
            raise ValueError(
                "Please provide a specific, meaningful reason for the override"
            )

        return text

    @field_validator("override_type")
    @classmethod
    def validate_override_type(cls, v: str) -> str:
        """Validate and normalize override type."""
        normalized = v.strip().lower()
        if normalized not in VALID_OVERRIDE_TYPES:
            raise ValueError(
                f"Invalid override type: '{v}'. Valid types: {', '.join(sorted(VALID_OVERRIDE_TYPES))}"
            )
        return normalized

    @field_validator("entity_type")
    @classmethod
    def validate_entity_type(cls, v: str) -> str:
        """Validate and normalize entity type."""
        normalized = v.strip().lower()
        if normalized not in VALID_ENTITY_TYPES:
            raise ValueError(
                f"Invalid entity type: '{v}'. Valid types: {', '.join(sorted(VALID_ENTITY_TYPES))}"
            )
        return normalized

    @field_validator("override_action")
    @classmethod
    def validate_override_action(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        """Validate override action is not empty."""
        if not v:
            raise ValueError("Override action cannot be empty")
        return v

    @model_validator(mode="after")
    def validate_supervisor_requirement(self) -> "AdminOverrideRequest":
        """Validate supervisor_id is required for certain override types."""
        supervisor_required_types = {
            "complaint_reassignment",
            "complaint_closure",
            "maintenance_approval",
            "maintenance_rejection",
        }

        if self.override_type in supervisor_required_types and not self.supervisor_id:
            raise ValueError(
                f"supervisor_id is required for override type: {self.override_type}"
            )

        return self


class OverrideLog(BaseResponseSchema):
    """
    Override log entry with comprehensive tracking.

    Maintains complete audit trail of all override actions
    for accountability and analysis.
    """

    admin_id: UUID = Field(..., description="Admin who performed override")
    admin_name: str = Field(..., min_length=1, description="Admin full name")
    supervisor_id: Optional[UUID] = Field(None, description="Affected supervisor ID")
    supervisor_name: Optional[str] = Field(None, description="Affected supervisor name")

    hostel_id: UUID = Field(..., description="Hostel where override occurred")
    hostel_name: str = Field(..., min_length=1, description="Hostel name")

    override_type: str = Field(..., description="Type of override")
    entity_type: str = Field(..., description="Type of entity")
    entity_id: UUID = Field(..., description="Entity ID")

    reason: str = Field(..., description="Override reason")

    original_action: Optional[Dict[str, Any]] = Field(
        None, description="Original supervisor action"
    )
    override_action: Dict[str, Any] = Field(..., description="Override action taken")

    created_at: datetime = Field(..., description="Override timestamp")

    @computed_field
    @property
    def short_reason(self) -> str:
        """Shortened reason for list displays."""
        max_length = 80
        if len(self.reason) <= max_length:
            return self.reason
        return self.reason[: max_length - 3] + "..."

    @computed_field
    @property
    def override_category(self) -> str:
        """Categorize override by entity type."""
        category_map = {
            "complaint": "Complaint Management",
            "maintenance_request": "Maintenance Operations",
            "booking": "Booking Management",
            "fee_transaction": "Financial Operations",
            "student_record": "Student Management",
            "policy_violation": "Policy Enforcement",
        }
        return category_map.get(self.entity_type, "Other")

    @computed_field
    @property
    def hours_since_override(self) -> int:
        """Calculate hours since override occurred."""
        delta = datetime.utcnow() - self.created_at
        return int(delta.total_seconds() // 3600)


class OverrideReason(BaseSchema):
    """
    Predefined override reasons for standardization.

    Provides common override reasons to ensure consistency
    and facilitate analytics.
    """

    reason_code: str = Field(..., min_length=1, description="Unique reason code")
    reason_text: str = Field(..., min_length=10, description="Reason description")
    category: str = Field(..., min_length=1, description="Reason category")
    requires_detailed_explanation: bool = Field(
        ..., description="Whether detailed explanation is required"
    )

    @field_validator("reason_code")
    @classmethod
    def validate_reason_code(cls, v: str) -> str:
        """Validate and normalize reason code."""
        code = v.strip().upper()
        if not code:
            raise ValueError("Reason code cannot be empty")
        # Ensure alphanumeric with underscores
        if not code.replace("_", "").isalnum():
            raise ValueError(
                "Reason code must contain only letters, numbers, and underscores"
            )
        return code


class OverrideSummary(BaseSchema):
    """
    Summary of admin overrides for a specific period.

    Provides aggregated view of override patterns and trends
    for management oversight and decision-making.
    """

    admin_id: UUID = Field(..., description="Admin user ID")
    period_start: date = Field(..., description="Summary period start date")
    period_end: date = Field(..., description="Summary period end date")

    total_overrides: int = Field(..., ge=0, description="Total overrides in period")

    # By type
    overrides_by_type: Dict[str, int] = Field(
        default_factory=dict, description="Breakdown by override type"
    )

    # By supervisor
    overrides_by_supervisor: Dict[UUID, int] = Field(
        default_factory=dict, description="Breakdown by supervisor"
    )

    # By hostel
    overrides_by_hostel: Dict[UUID, int] = Field(
        default_factory=dict, description="Breakdown by hostel"
    )

    # Trend
    override_trend: str = Field(
        ..., pattern="^(increasing|decreasing|stable)$", description="Override trend"
    )

    @computed_field
    @property
    def average_overrides_per_day(self) -> Decimal:
        """Average overrides per day in the period."""
        days = max(1, (self.period_end - self.period_start).days)
        avg = Decimal(self.total_overrides) / Decimal(days)
        return avg.quantize(Decimal("0.01"))

    @computed_field
    @property
    def most_overridden_supervisor(self) -> Optional[UUID]:
        """Identify supervisor with most overrides."""
        if not self.overrides_by_supervisor:
            return None
        return max(self.overrides_by_supervisor, key=self.overrides_by_supervisor.get)

    @computed_field
    @property
    def most_common_override_type(self) -> Optional[str]:
        """Identify most common override type."""
        if not self.overrides_by_type:
            return None
        return max(self.overrides_by_type, key=self.overrides_by_type.get)

    @computed_field
    @property
    def override_concentration(self) -> Decimal:
        """
        Calculate override concentration (0-100).
        Higher values indicate overrides concentrated on few supervisors.
        """
        if not self.overrides_by_supervisor or self.total_overrides == 0:
            return Decimal("0.00")

        # Calculate Herfindahl-Hirschman Index (HHI) simplified
        supervisor_counts = list(self.overrides_by_supervisor.values())
        shares = [
            (count / self.total_overrides) ** 2 for count in supervisor_counts
        ]
        hhi = sum(shares) * 100

        return Decimal(str(hhi)).quantize(Decimal("0.01"))

    @field_validator("override_trend")
    @classmethod
    def validate_trend(cls, v: str) -> str:
        """Validate trend value."""
        if v not in VALID_TRENDS:
            raise ValueError(
                f"Invalid trend value: '{v}'. Must be one of: {', '.join(VALID_TRENDS)}"
            )
        return v

    @model_validator(mode="after")
    def validate_period_dates(self) -> "OverrideSummary":
        """Validate period dates are logical."""
        if self.period_end < self.period_start:
            raise ValueError("period_end must be after period_start")

        if (self.period_end - self.period_start).days > 365:
            raise ValueError("Summary period cannot exceed 365 days")

        return self


class SupervisorOverrideStats(BaseSchema):
    """
    Override statistics for a specific supervisor.

    Provides detailed override metrics to identify patterns
    and areas for supervisor development or support.
    """

    supervisor_id: UUID = Field(..., description="Supervisor user ID")
    supervisor_name: str = Field(..., min_length=1, description="Supervisor full name")

    total_actions: int = Field(..., ge=0, description="Total actions taken by supervisor")
    total_overrides: int = Field(..., ge=0, description="Total actions overridden")
    override_rate: Decimal = Field(
        ..., ge=0, le=100, description="Percentage of actions overridden"
    )

    # By type
    overrides_by_type: Dict[str, int] = Field(
        default_factory=dict, description="Breakdown by override type"
    )

    # Common reasons
    common_override_reasons: List[str] = Field(
        default_factory=list, description="Most common override reasons"
    )

    # Trend
    recent_trend: str = Field(
        ...,
        pattern="^(improving|declining|stable)$",
        description="Recent trend in override rate",
    )

    @computed_field
    @property
    def is_concerning(self) -> bool:
        """Whether override rate is concerning (> 10%)."""
        return float(self.override_rate) > 10.0

    @computed_field
    @property
    def performance_indicator(self) -> str:
        """Overall performance indicator based on override rate."""
        rate = float(self.override_rate)
        if rate <= 5:
            return "Excellent"
        elif rate <= 10:
            return "Good"
        elif rate <= 20:
            return "Needs Improvement"
        else:
            return "Critical"

    @computed_field
    @property
    def most_overridden_category(self) -> Optional[str]:
        """Identify category with most overrides."""
        if not self.overrides_by_type:
            return None
        return max(self.overrides_by_type, key=self.overrides_by_type.get)

    @field_validator("override_rate")
    @classmethod
    def validate_override_rate(cls, v: Decimal) -> Decimal:
        """Validate override rate is within bounds."""
        if v < 0 or v > 100:
            raise ValueError("Override rate must be between 0 and 100")
        return v.quantize(Decimal("0.01"))

    @field_validator("recent_trend")
    @classmethod
    def validate_trend(cls, v: str) -> str:
        """Validate trend value."""
        if v not in VALID_SUPERVISOR_TRENDS:
            raise ValueError(
                f"Invalid trend: '{v}'. Must be one of: {', '.join(VALID_SUPERVISOR_TRENDS)}"
            )
        return v

    @model_validator(mode="after")
    def validate_stats_consistency(self) -> "SupervisorOverrideStats":
        """Validate statistical consistency."""
        if self.total_overrides > self.total_actions:
            raise ValueError("total_overrides cannot exceed total_actions")

        # Validate override rate calculation
        if self.total_actions > 0:
            calculated_rate = Decimal(self.total_overrides) / Decimal(
                self.total_actions
            ) * 100
            calculated_rate = calculated_rate.quantize(Decimal("0.01"))

            # Allow small rounding difference
            if abs(calculated_rate - self.override_rate) > Decimal("0.1"):
                raise ValueError(
                    f"override_rate {self.override_rate} doesn't match calculated rate {calculated_rate}"
                )

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\admin_permissions.py ---
"""
Admin permission schemas for hostel-level access control.

Defines comprehensive permission structures and role mappings
for fine-grained authorization and access management.

Key Improvements:
- Type-safe permission definitions
- Enhanced validation
- Better defaults and documentation
- Cleaner structure
"""

from __future__ import annotations

from typing import Dict, List, Optional, Set
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import UserRole

__all__ = [
    "AdminPermissions",
    "PermissionMatrix",
    "RolePermissions",
    "PermissionCheck",
]


# Permission categories for organization
ROOM_PERMISSIONS = {"can_manage_rooms", "can_manage_beds"}
STUDENT_PERMISSIONS = {
    "can_manage_students",
    "can_check_in_students",
    "can_check_out_students",
}
BOOKING_PERMISSIONS = {"can_approve_bookings", "can_manage_waitlist"}
FEE_PERMISSIONS = {"can_manage_fees", "can_process_payments", "can_issue_refunds"}
SUPERVISOR_PERMISSIONS = {
    "can_manage_supervisors",
    "can_configure_supervisor_permissions",
    "can_override_supervisor_actions",
}
FINANCIAL_PERMISSIONS = {"can_view_financials", "can_export_financial_data"}
HOSTEL_PERMISSIONS = {
    "can_manage_hostel_settings",
    "can_manage_hostel_profile",
    "can_toggle_public_visibility",
}
DATA_PERMISSIONS = {"can_delete_records", "can_export_data", "can_import_data"}

ALL_PERMISSION_KEYS: Set[str] = (
    ROOM_PERMISSIONS
    | STUDENT_PERMISSIONS
    | BOOKING_PERMISSIONS
    | FEE_PERMISSIONS
    | SUPERVISOR_PERMISSIONS
    | FINANCIAL_PERMISSIONS
    | HOSTEL_PERMISSIONS
    | DATA_PERMISSIONS
)


class AdminPermissions(BaseSchema):
    """
    Admin-specific permissions for a hostel.

    Provides granular control over admin capabilities with
    sensible defaults and comprehensive coverage of all admin functions.
    """

    # Room management
    can_manage_rooms: bool = Field(True, description="Can create/edit/delete rooms")
    can_manage_beds: bool = Field(True, description="Can manage bed assignments")

    # Student management
    can_manage_students: bool = Field(True, description="Can add/edit/remove students")
    can_check_in_students: bool = Field(True, description="Can check-in students")
    can_check_out_students: bool = Field(True, description="Can check-out students")

    # Booking management
    can_approve_bookings: bool = Field(True, description="Can approve/reject bookings")
    can_manage_waitlist: bool = Field(True, description="Can manage waitlist")

    # Fee management
    can_manage_fees: bool = Field(True, description="Can configure fee structures")
    can_process_payments: bool = Field(True, description="Can process manual payments")
    can_issue_refunds: bool = Field(True, description="Can issue refunds")

    # Supervisor management
    can_manage_supervisors: bool = Field(True, description="Can assign/remove supervisors")
    can_configure_supervisor_permissions: bool = Field(
        True, description="Can modify supervisor permissions"
    )
    can_override_supervisor_actions: bool = Field(
        True, description="Can override supervisor decisions"
    )

    # Financial access
    can_view_financials: bool = Field(True, description="Can view financial reports")
    can_export_financial_data: bool = Field(
        True, description="Can export financial data"
    )

    # Hostel configuration
    can_manage_hostel_settings: bool = Field(
        True, description="Can modify hostel settings"
    )
    can_manage_hostel_profile: bool = Field(
        True, description="Can edit public hostel profile"
    )
    can_toggle_public_visibility: bool = Field(
        True, description="Can make hostel public/private"
    )

    # Data management
    can_delete_records: bool = Field(
        False, description="Can permanently delete records"
    )
    can_export_data: bool = Field(True, description="Can export data")
    can_import_data: bool = Field(True, description="Can bulk import data")

    def has_permission(self, permission_key: str) -> bool:
        """Check if specific permission is granted."""
        if permission_key not in ALL_PERMISSION_KEYS:
            return False
        return bool(getattr(self, permission_key, False))

    def get_granted_permissions(self) -> List[str]:
        """Get list of all granted permissions."""
        return [key for key in ALL_PERMISSION_KEYS if self.has_permission(key)]

    def get_denied_permissions(self) -> List[str]:
        """Get list of all denied permissions."""
        return [key for key in ALL_PERMISSION_KEYS if not self.has_permission(key)]

    @property
    def permission_count(self) -> int:
        """Count of granted permissions."""
        return len(self.get_granted_permissions())

    @property
    def has_full_access(self) -> bool:
        """Check if has all permissions."""
        return self.permission_count == len(ALL_PERMISSION_KEYS)

    @property
    def has_limited_access(self) -> bool:
        """Check if has limited permissions."""
        return 0 < self.permission_count < len(ALL_PERMISSION_KEYS)

    @property
    def has_no_access(self) -> bool:
        """Check if has no permissions."""
        return self.permission_count == 0


class PermissionMatrix(BaseSchema):
    """
    Permission matrix showing capabilities for each role.

    Provides comprehensive mapping of roles to permissions
    for authorization and UI rendering.
    """

    permissions: Dict[UserRole, List[str]] = Field(
        ..., description="Map of role to list of permission keys"
    )

    @field_validator("permissions")
    @classmethod
    def validate_permissions(cls, v: Dict[UserRole, List[str]]) -> Dict[UserRole, List[str]]:
        """Validate permission keys are valid."""
        for role, perms in v.items():
            invalid_perms = set(perms) - ALL_PERMISSION_KEYS
            if invalid_perms:
                raise ValueError(
                    f"Invalid permissions for role {role.value}: {', '.join(invalid_perms)}"
                )
        return v

    def get_role_permissions(self, role: UserRole) -> List[str]:
        """Get permissions for a specific role."""
        return self.permissions.get(role, [])

    def role_has_permission(self, role: UserRole, permission_key: str) -> bool:
        """Check if role has specific permission."""
        return permission_key in self.permissions.get(role, [])


class RolePermissions(BaseSchema):
    """
    Permissions for a specific role with metadata.

    Provides detailed information about role capabilities
    with descriptions for documentation and UI display.
    """

    role: UserRole = Field(..., description="User role")
    permissions: List[str] = Field(..., description="List of permission keys")
    description: str = Field(..., min_length=10, description="Role description")

    @field_validator("permissions")
    @classmethod
    def validate_permissions(cls, v: List[str]) -> List[str]:
        """Validate all permission keys are valid."""
        invalid = set(v) - ALL_PERMISSION_KEYS
        if invalid:
            raise ValueError(
                f"Invalid permission keys: {', '.join(invalid)}. "
                f"Valid keys: {', '.join(sorted(ALL_PERMISSION_KEYS))}"
            )
        # Remove duplicates while preserving order
        seen = set()
        unique_perms = []
        for perm in v:
            if perm not in seen:
                seen.add(perm)
                unique_perms.append(perm)
        return unique_perms

    @property
    def permission_categories(self) -> Dict[str, List[str]]:
        """Organize permissions by category."""
        categories = {
            "Room Management": [],
            "Student Management": [],
            "Booking Management": [],
            "Fee Management": [],
            "Supervisor Management": [],
            "Financial Access": [],
            "Hostel Configuration": [],
            "Data Management": [],
        }

        for perm in self.permissions:
            if perm in ROOM_PERMISSIONS:
                categories["Room Management"].append(perm)
            elif perm in STUDENT_PERMISSIONS:
                categories["Student Management"].append(perm)
            elif perm in BOOKING_PERMISSIONS:
                categories["Booking Management"].append(perm)
            elif perm in FEE_PERMISSIONS:
                categories["Fee Management"].append(perm)
            elif perm in SUPERVISOR_PERMISSIONS:
                categories["Supervisor Management"].append(perm)
            elif perm in FINANCIAL_PERMISSIONS:
                categories["Financial Access"].append(perm)
            elif perm in HOSTEL_PERMISSIONS:
                categories["Hostel Configuration"].append(perm)
            elif perm in DATA_PERMISSIONS:
                categories["Data Management"].append(perm)

        # Remove empty categories
        return {k: v for k, v in categories.items() if v}


class PermissionCheck(BaseSchema):
    """
    Permission check request and result.

    Used to verify if a user has specific permission
    with detailed reasoning for access decisions.
    """

    user_id: UUID = Field(..., description="User ID to check")
    hostel_id: UUID = Field(..., description="Hostel ID context")
    permission_key: str = Field(..., description="Permission key to check")

    has_permission: bool = Field(..., description="Whether user has permission")
    reason: Optional[str] = Field(None, description="Reason if permission denied")

    @field_validator("permission_key")
    @classmethod
    def validate_permission_key(cls, v: str) -> str:
        """Validate permission key is valid."""
        value = v.strip()
        if not value:
            raise ValueError("permission_key cannot be empty")

        if value not in ALL_PERMISSION_KEYS:
            raise ValueError(
                f"Invalid permission key: '{value}'. "
                f"Valid keys: {', '.join(sorted(ALL_PERMISSION_KEYS))}"
            )

        return value

    @model_validator(mode="after")
    def validate_reason_requirement(self) -> "PermissionCheck":
        """Validate reason is provided when permission is denied."""
        if not self.has_permission and not self.reason:
            raise ValueError("reason is required when permission is denied")
        return self

    @property
    def access_status(self) -> str:
        """Get human-readable access status."""
        return "Granted" if self.has_permission else "Denied"

    @property
    def permission_category(self) -> str:
        """Get category of checked permission."""
        if self.permission_key in ROOM_PERMISSIONS:
            return "Room Management"
        elif self.permission_key in STUDENT_PERMISSIONS:
            return "Student Management"
        elif self.permission_key in BOOKING_PERMISSIONS:
            return "Booking Management"
        elif self.permission_key in FEE_PERMISSIONS:
            return "Fee Management"
        elif self.permission_key in SUPERVISOR_PERMISSIONS:
            return "Supervisor Management"
        elif self.permission_key in FINANCIAL_PERMISSIONS:
            return "Financial Access"
        elif self.permission_key in HOSTEL_PERMISSIONS:
            return "Hostel Configuration"
        elif self.permission_key in DATA_PERMISSIONS:
            return "Data Management"
        else:
            return "Unknown"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\hostel_context.py ---
"""
Enhanced hostel context management for multi-hostel admin operations.

Provides robust context switching, session tracking, and history management
for seamless multi-hostel administration with comprehensive audit trails.

Key Improvements:
- Optimized computed properties with better performance
- Enhanced validation with clearer error messages
- Better session management logic
- Improved type safety and null handling
- Comprehensive metrics calculation
"""

from __future__ import annotations

from datetime import datetime, timedelta, date
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "HostelContext",
    "HostelSwitchRequest",
    "ActiveHostelResponse",
    "ContextHistory",
    "ContextSwitch",
]


# Constants
STALE_SESSION_MINUTES = 30
RECENT_ACCESS_HOURS = 24
MAX_RETURN_URL_LENGTH = 500
MAX_SWITCH_REASON_LENGTH = 200
MIN_PRODUCTIVE_SESSION_MINUTES = 5
EXCELLENT_ACTIONS_PER_MINUTE = 0.5

HEALTH_SCORE_WEIGHTS = {
    "occupancy": 0.4,
    "tasks": 0.3,
    "alerts": 0.3,
}

ACTIVITY_TRIGGERS = {
    "manual",
    "automatic",
    "notification",
    "alert",
    "scheduled",
}


class HostelContext(BaseSchema):
    """
    Enhanced current hostel context for multi-hostel admin with real-time metrics.

    Maintains active hostel state with comprehensive permission information,
    session tracking, and quick access to relevant statistics.
    """

    # Admin and context identifiers
    admin_id: UUID = Field(..., description="Admin user ID")
    context_id: UUID = Field(..., description="Unique context session ID")

    # Active hostel information
    active_hostel_id: UUID = Field(..., description="Currently active hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Active hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city location")
    hostel_type: str = Field(..., description="Hostel type classification")

    # Permission information for active hostel
    permission_level: str = Field(..., description="Permission level for active hostel")
    permissions: dict = Field(
        default_factory=dict, description="Detailed permissions for active hostel"
    )

    # Context session tracking
    context_started_at: datetime = Field(..., description="Context session start time")
    last_accessed_at: datetime = Field(..., description="Last activity timestamp")
    session_duration_minutes: int = Field(0, ge=0, description="Current session duration")

    # Quick statistics for active hostel
    total_students: int = Field(0, ge=0, description="Total students in active hostel")
    active_students: int = Field(0, ge=0, description="Currently active students")
    occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Current occupancy rate"
    )

    # Pending tasks and alerts
    pending_tasks: int = Field(0, ge=0, description="Pending tasks count")
    urgent_alerts: int = Field(0, ge=0, description="Urgent alerts count")
    unread_notifications: int = Field(0, ge=0, description="Unread notifications count")

    # Revenue snapshot
    revenue_this_month: Decimal = Field(
        Decimal("0.00"), ge=0, description="Revenue for current month"
    )
    outstanding_payments: Decimal = Field(
        Decimal("0.00"), ge=0, description="Outstanding payment amount"
    )

    # Context metadata
    previous_hostel_id: Optional[UUID] = Field(None, description="Previously active hostel")
    switch_count: int = Field(0, ge=0, description="Number of context switches in session")

    @computed_field
    @property
    def session_active_duration(self) -> str:
        """Calculate and format active session duration."""
        duration = datetime.utcnow() - self.context_started_at

        total_seconds = int(duration.total_seconds())
        hours = total_seconds // 3600
        minutes = (total_seconds % 3600) // 60

        if hours > 0:
            return f"{hours}h {minutes}m"
        else:
            return f"{minutes}m"

    @computed_field
    @property
    def context_health_score(self) -> Decimal:
        """Calculate context health score based on hostel metrics."""
        score = Decimal("0.00")

        # Occupancy contribution (40 points)
        occupancy_score = self.occupancy_percentage * Decimal(str(HEALTH_SCORE_WEIGHTS["occupancy"]))
        score += occupancy_score

        # Task management (30 points)
        task_weight = Decimal(str(HEALTH_SCORE_WEIGHTS["tasks"] * 100))
        if self.pending_tasks == 0:
            score += task_weight
        elif self.pending_tasks <= 5:
            score += task_weight * Decimal("0.67")
        elif self.pending_tasks <= 10:
            score += task_weight * Decimal("0.33")

        # Alert status (30 points)
        alert_weight = Decimal(str(HEALTH_SCORE_WEIGHTS["alerts"] * 100))
        if self.urgent_alerts == 0:
            score += alert_weight
        elif self.urgent_alerts <= 2:
            score += alert_weight * Decimal("0.5")

        return score.quantize(Decimal("0.01"))

    @computed_field
    @property
    def requires_attention(self) -> bool:
        """Determine if active hostel requires immediate attention."""
        return (
            self.urgent_alerts > 0
            or self.pending_tasks > 10
            or self.occupancy_percentage < Decimal("50.00")
            or self.outstanding_payments > self.revenue_this_month
        )

    @computed_field
    @property
    def is_stale_session(self) -> bool:
        """Check if context session is stale (no activity for 30+ minutes)."""
        inactive_duration = datetime.utcnow() - self.last_accessed_at
        return inactive_duration > timedelta(minutes=STALE_SESSION_MINUTES)

    @computed_field
    @property
    def attention_priority(self) -> str:
        """Determine attention priority level."""
        if self.urgent_alerts > 5:
            return "Critical"
        elif self.urgent_alerts > 0 or self.pending_tasks > 20:
            return "High"
        elif self.pending_tasks > 10 or self.occupancy_percentage < Decimal("60.00"):
            return "Medium"
        else:
            return "Low"

    @field_validator("hostel_type")
    @classmethod
    def validate_hostel_type(cls, v: str) -> str:
        """Validate hostel type."""
        valid_types = {"boys", "girls", "co-ed", "coed", "mixed"}
        normalized = v.strip().lower()
        if normalized not in valid_types:
            raise ValueError(f"Invalid hostel type: {v}")
        return "co-ed" if normalized in {"coed", "mixed"} else normalized

    @model_validator(mode="after")
    def validate_session_consistency(self) -> "HostelContext":
        """Validate session timing consistency."""
        if self.last_accessed_at < self.context_started_at:
            raise ValueError("last_accessed_at cannot be before context_started_at")

        # Calculate expected duration
        expected_duration = int(
            (self.last_accessed_at - self.context_started_at).total_seconds() / 60
        )

        # Allow some tolerance for concurrent updates
        if abs(expected_duration - self.session_duration_minutes) > 5:
            # Log warning but don't raise error
            pass

        return self


class HostelSwitchRequest(BaseCreateSchema):
    """
    Enhanced hostel context switch request with validation and options.

    Supports seamless context switching with proper validation,
    session management, and optional data refresh preferences.
    """

    hostel_id: UUID = Field(..., description="Target hostel ID to switch to")

    # Switch preferences
    save_current_session: bool = Field(
        True, description="Save current session state before switching"
    )
    refresh_dashboard: bool = Field(
        True, description="Refresh dashboard data after switch"
    )
    load_pending_tasks: bool = Field(
        True, description="Load pending tasks for new context"
    )

    # Navigation context
    return_url: Optional[str] = Field(
        None, max_length=MAX_RETURN_URL_LENGTH, description="URL to navigate to after switch"
    )
    switch_reason: Optional[str] = Field(
        None, max_length=MAX_SWITCH_REASON_LENGTH, description="Reason for context switch (for analytics)"
    )

    @field_validator("return_url")
    @classmethod
    def validate_return_url(cls, v: Optional[str]) -> Optional[str]:
        """Validate return URL format."""
        if v is not None:
            v = v.strip()
            if not v:
                return None

            # Basic URL validation
            if not v.startswith(("/", "http://", "https://")):
                raise ValueError(
                    "Invalid return URL format. Must start with /, http://, or https://"
                )

            # Prevent potential XSS
            dangerous_patterns = ["javascript:", "data:", "vbscript:"]
            if any(pattern in v.lower() for pattern in dangerous_patterns):
                raise ValueError("Return URL contains potentially dangerous content")

        return v

    @field_validator("switch_reason")
    @classmethod
    def validate_switch_reason(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize switch reason."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            v = " ".join(v.split())  # Normalize whitespace
        return v


class ActiveHostelResponse(BaseSchema):
    """
    Enhanced response after successful hostel context switch.

    Provides comprehensive information about the newly active hostel
    with permissions, statistics, and navigation guidance.
    """

    # Context identifiers
    admin_id: UUID = Field(..., description="Admin user ID")
    context_id: UUID = Field(..., description="New context session ID")

    # Previous and current hostel information
    previous_hostel_id: Optional[UUID] = Field(None, description="Previous active hostel ID")
    previous_hostel_name: Optional[str] = Field(None, description="Previous hostel name")

    active_hostel_id: UUID = Field(..., description="Newly active hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Active hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")

    # Permission configuration for new context
    permission_level: str = Field(..., description="Permission level for new hostel")
    permissions: dict = Field(default_factory=dict, description="Detailed permissions")

    # Context timing
    switched_at: datetime = Field(..., description="Context switch timestamp")
    previous_session_duration_minutes: Optional[int] = Field(
        None, ge=0, description="Duration of previous session"
    )

    # Quick statistics for new hostel
    total_students: int = Field(0, ge=0, description="Total students")
    occupancy_percentage: Decimal = Field(Decimal("0.00"), ge=0, le=100)
    pending_tasks: int = Field(0, ge=0, description="Pending tasks")
    urgent_alerts: int = Field(0, ge=0, description="Urgent alerts")

    # Response metadata
    message: str = Field(..., min_length=1, description="Success message")
    dashboard_url: Optional[str] = Field(None, description="Dashboard URL for new context")

    # Navigation suggestions
    suggested_actions: List[str] = Field(
        default_factory=list, description="Suggested next actions based on hostel state"
    )

    @computed_field
    @property
    def switch_summary(self) -> str:
        """Generate human-readable switch summary."""
        if self.previous_hostel_name:
            return f"Switched from {self.previous_hostel_name} to {self.hostel_name}"
        else:
            return f"Activated context for {self.hostel_name}"

    @computed_field
    @property
    def requires_immediate_action(self) -> bool:
        """Check if new context requires immediate action."""
        return self.urgent_alerts > 0 or self.pending_tasks > 5

    @computed_field
    @property
    def hostel_health_indicator(self) -> str:
        """Generate health indicator for newly active hostel."""
        if self.urgent_alerts > 0:
            return "critical"
        elif self.pending_tasks > 10:
            return "warning"
        elif self.occupancy_percentage < Decimal("60.00"):
            return "attention"
        else:
            return "healthy"

    @computed_field
    @property
    def priority_level(self) -> int:
        """Calculate priority level (1-5, where 5 is highest)."""
        if self.urgent_alerts > 5:
            return 5
        elif self.urgent_alerts > 0:
            return 4
        elif self.pending_tasks > 10:
            return 3
        elif self.pending_tasks > 5:
            return 2
        else:
            return 1

    @model_validator(mode="after")
    def populate_suggested_actions(self) -> "ActiveHostelResponse":
        """Populate suggested actions based on hostel state."""
        if not self.suggested_actions:
            actions = []

            if self.urgent_alerts > 0:
                actions.append(f"Review {self.urgent_alerts} urgent alerts")

            if self.pending_tasks > 10:
                actions.append(f"Process {self.pending_tasks} pending tasks")

            if self.occupancy_percentage < Decimal("50.00"):
                actions.append("Review low occupancy and marketing strategy")

            if self.occupancy_percentage > Decimal("95.00"):
                actions.append("Check waitlist for high occupancy")

            if not actions:
                actions.append("Dashboard is up to date")

            self.suggested_actions = actions

        return self


class ContextSwitch(BaseSchema):
    """
    Enhanced individual context switch record with comprehensive tracking.

    Represents a single hostel context switch with timing, reason,
    and session metrics for analytics and audit purposes.
    """

    # Switch identification
    switch_id: UUID = Field(..., description="Unique switch record ID")
    admin_id: UUID = Field(..., description="Admin user ID")

    # Source and destination hostels
    from_hostel_id: Optional[UUID] = Field(None, description="Source hostel ID")
    from_hostel_name: Optional[str] = Field(None, description="Source hostel name")
    to_hostel_id: UUID = Field(..., description="Destination hostel ID")
    to_hostel_name: str = Field(..., min_length=1, description="Destination hostel name")

    # Switch timing
    switched_at: datetime = Field(..., description="Switch timestamp")
    session_duration_minutes: Optional[int] = Field(
        None, ge=0, description="Duration spent in previous hostel (if applicable)"
    )

    # Switch context
    switch_reason: Optional[str] = Field(None, description="Reason for switch")
    triggered_by: str = Field(
        "manual",
        description="What triggered the switch (manual, automatic, notification, alert, scheduled)",
    )

    # Activity metrics during session
    actions_performed: int = Field(0, ge=0, description="Actions performed in session")
    decisions_made: int = Field(0, ge=0, description="Decisions made in session")

    # Navigation context
    source_page: Optional[str] = Field(None, description="Page where switch was initiated")
    destination_page: Optional[str] = Field(None, description="Landing page after switch")

    @computed_field
    @property
    def session_productivity_score(self) -> Decimal:
        """Calculate productivity score for the session."""
        if self.session_duration_minutes is None or self.session_duration_minutes == 0:
            return Decimal("0.00")

        # Calculate actions per minute
        actions_per_minute = Decimal(self.actions_performed) / Decimal(
            self.session_duration_minutes
        )

        # Score based on actions per minute (capped at 100)
        score = min(
            (actions_per_minute / Decimal(str(EXCELLENT_ACTIONS_PER_MINUTE))) * 100, 100
        )

        return Decimal(str(score)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def was_productive_session(self) -> bool:
        """Determine if session was productive (made meaningful progress)."""
        if self.session_duration_minutes is None:
            return False

        # Consider productive if:
        # - At least 5 minutes AND at least 1 action OR
        # - At least 1 decision made
        return (
            self.session_duration_minutes >= MIN_PRODUCTIVE_SESSION_MINUTES
            and self.actions_performed > 0
        ) or self.decisions_made > 0

    @computed_field
    @property
    def switch_type_description(self) -> str:
        """Generate human-readable switch type description."""
        type_map = {
            "manual": "User-initiated switch",
            "automatic": "Automatic context switch",
            "notification": "Triggered by notification",
            "alert": "Triggered by alert",
            "scheduled": "Scheduled context switch",
        }
        return type_map.get(self.triggered_by, "Unknown switch type")

    @computed_field
    @property
    def efficiency_rating(self) -> str:
        """Rate session efficiency."""
        score = float(self.session_productivity_score)

        if score >= 80:
            return "Excellent"
        elif score >= 60:
            return "Good"
        elif score >= 40:
            return "Fair"
        elif score > 0:
            return "Poor"
        else:
            return "No Activity"

    @field_validator("triggered_by")
    @classmethod
    def validate_triggered_by(cls, v: str) -> str:
        """Validate trigger type."""
        normalized = v.strip().lower()
        if normalized not in ACTIVITY_TRIGGERS:
            raise ValueError(
                f"Invalid trigger type: '{v}'. Valid types: {', '.join(ACTIVITY_TRIGGERS)}"
            )
        return normalized


class ContextHistory(BaseSchema):
    """
    Enhanced context switch history with analytics and insights.

    Provides comprehensive historical view of all context switches
    with usage patterns, productivity metrics, and recommendations.
    """

    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., min_length=1, description="Admin full name")

    # History period
    history_start: datetime = Field(..., description="History period start")
    history_end: datetime = Field(..., description="History period end")

    # Switch records
    switches: List[ContextSwitch] = Field(
        default_factory=list, description="Chronological list of context switches"
    )

    # Aggregate statistics
    total_switches: int = Field(0, ge=0, description="Total number of switches")
    unique_hostels_accessed: int = Field(0, ge=0, description="Unique hostels accessed")
    total_session_time_minutes: int = Field(
        0, ge=0, description="Total time across all sessions"
    )

    # Most accessed hostel
    most_accessed_hostel_id: Optional[UUID] = Field(
        None, description="Most frequently accessed hostel"
    )
    most_accessed_hostel_name: Optional[str] = Field(
        None, description="Most accessed hostel name"
    )
    most_accessed_count: int = Field(0, ge=0, description="Access count for most accessed hostel")

    # Usage patterns
    avg_session_duration_minutes: Decimal = Field(
        Decimal("0.00"), ge=0, description="Average session duration"
    )
    avg_switches_per_day: Decimal = Field(
        Decimal("0.00"), ge=0, description="Average switches per day"
    )

    # Productivity metrics
    total_actions_performed: int = Field(0, ge=0, description="Total actions across all sessions")
    total_decisions_made: int = Field(0, ge=0, description="Total decisions across all sessions")
    productivity_score: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Overall productivity score"
    )

    @computed_field
    @property
    def history_duration_days(self) -> int:
        """Calculate history period duration in days."""
        duration = (self.history_end - self.history_start).days
        return max(1, duration)

    @computed_field
    @property
    def switch_frequency_pattern(self) -> str:
        """Determine switch frequency pattern."""
        switches_per_day = float(self.avg_switches_per_day)

        if switches_per_day < 2:
            return "Low Frequency"
        elif switches_per_day < 5:
            return "Moderate Frequency"
        elif switches_per_day < 10:
            return "High Frequency"
        else:
            return "Very High Frequency"

    @computed_field
    @property
    def session_efficiency_score(self) -> Decimal:
        """Calculate session efficiency score."""
        if self.total_switches == 0:
            return Decimal("0.00")

        # Calculate average actions per switch
        avg_actions = Decimal(self.total_actions_performed) / Decimal(self.total_switches)

        # Calculate average decisions per switch
        avg_decisions = Decimal(self.total_decisions_made) / Decimal(self.total_switches)

        # Combined efficiency score
        efficiency = (avg_actions * Decimal("0.6") + avg_decisions * Decimal("0.4")) * 10

        return Decimal(str(min(float(efficiency), 100))).quantize(Decimal("0.01"))

    @computed_field
    @property
    def hostel_focus_distribution(self) -> str:
        """Determine hostel focus distribution pattern."""
        if self.unique_hostels_accessed == 0:
            return "No Activity"

        if self.total_switches == 0:
            return "No Activity"

        # Calculate concentration: how focused admin is on specific hostels
        concentration_ratio = self.most_accessed_count / self.total_switches

        if concentration_ratio > 0.7:
            return "Highly Focused (70%+ on one hostel)"
        elif concentration_ratio > 0.5:
            return "Moderately Focused (50-70% on one hostel)"
        else:
            return "Distributed (Balanced across hostels)"

    @computed_field
    @property
    def recommendations(self) -> List[str]:
        """Generate context usage recommendations based on patterns."""
        recommendations = []

        # High switch frequency recommendation
        if float(self.avg_switches_per_day) > 10:
            recommendations.append(
                "Consider consolidating tasks to reduce frequent context switching"
            )

        # Short session duration recommendation
        if float(self.avg_session_duration_minutes) < 10 and self.total_switches > 5:
            recommendations.append(
                "Average session duration is short; consider focusing on one hostel at a time"
            )

        # Low productivity recommendation
        if float(self.productivity_score) < 50 and self.total_switches > 10:
            recommendations.append(
                "Productivity could be improved by spending more time per hostel session"
            )

        # Balanced usage recommendation
        if self.unique_hostels_accessed > 5:
            concentration_ratio = (
                self.most_accessed_count / self.total_switches if self.total_switches > 0 else 0
            )
            if concentration_ratio < 0.3:
                recommendations.append(
                    "You're managing many hostels; consider delegating to improve efficiency"
                )

        # High efficiency praise
        if float(self.productivity_score) > 80:
            recommendations.append("Excellent productivity! Keep up the good work")

        return recommendations if recommendations else ["Usage patterns are healthy"]

    @model_validator(mode="after")
    def validate_history_consistency(self) -> "ContextHistory":
        """Validate history data consistency."""
        if self.history_end < self.history_start:
            raise ValueError("history_end must be after history_start")

        # Validate switch count matches switches list
        if len(self.switches) != self.total_switches:
            # This might be due to pagination, so log but don't error
            pass

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\hostel_selector.py ---
"""
Enhanced hostel selector UI schemas with comprehensive filtering and organization.

Provides optimized schemas for hostel selection dropdown/sidebar with quick stats,
favorites management, and recent access tracking for improved user experience.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "HostelSelectorResponse",
    "HostelSelectorItem",
    "RecentHostels",
    "RecentHostelItem",
    "FavoriteHostels",
    "FavoriteHostelItem",
    "UpdateFavoriteRequest",
]


class HostelSelectorItem(BaseSchema):
    """
    Enhanced individual hostel item in selector with comprehensive quick view.
    
    Provides essential hostel information with visual indicators,
    quick statistics, and status information for efficient selection.
    """
    
    # Hostel identification
    hostel_id: UUID = Field(..., description="Hostel unique identifier")
    hostel_name: str = Field(..., description="Hostel display name")
    hostel_city: str = Field(..., description="Hostel city location")
    hostel_type: str = Field(..., description="Hostel type (boys/girls/co-ed)")
    hostel_address: Optional[str] = Field(None, description="Short address for display")
    
    # Visual indicators and flags
    is_active: bool = Field(True, description="Currently active hostel in context")
    is_primary: bool = Field(False, description="Primary hostel for this admin")
    is_favorite: bool = Field(False, description="Marked as favorite by admin")
    is_recently_accessed: bool = Field(False, description="Accessed in last 24 hours")
    
    # Quick statistics for decision making
    occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Current occupancy rate"
    )
    total_students: int = Field(0, ge=0, description="Total student count")
    available_beds: int = Field(0, ge=0, description="Available beds count")
    
    # Alert indicators
    pending_bookings: int = Field(0, ge=0, description="Pending booking requests")
    pending_complaints: int = Field(0, ge=0, description="Open complaints")
    urgent_tasks: int = Field(0, ge=0, description="Urgent tasks count")
    
    # Permission summary
    permission_level: str = Field(..., description="Admin permission level for this hostel")
    can_manage: bool = Field(True, description="Has management permissions")
    
    # Activity tracking
    last_accessed: Optional[datetime] = Field(None, description="Last access timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    
    # Display customization
    display_order: int = Field(0, description="Custom display order")
    custom_label: Optional[str] = Field(None, description="Custom label/nickname for hostel")

    @computed_field
    @property
    def requires_attention(self) -> bool:
        """Determine if hostel requires immediate attention."""
        return (
            self.urgent_tasks > 0 or
            self.pending_complaints > 5 or
            self.occupancy_percentage < Decimal("50.00")
        )

    @computed_field
    @property
    def notification_badge_count(self) -> int:
        """Calculate notification badge count for visual indicator."""
        return self.pending_bookings + self.urgent_tasks

    @computed_field
    @property
    def status_indicator_color(self) -> str:
        """Determine status indicator color for UI."""
        if self.urgent_tasks > 0:
            return "red"  # Critical
        elif self.pending_complaints > 5 or self.occupancy_percentage < Decimal("50.00"):
            return "yellow"  # Warning
        else:
            return "green"  # Good

    @computed_field
    @property
    def display_label(self) -> str:
        """Get display label (custom or default)."""
        return self.custom_label if self.custom_label else self.hostel_name

    @computed_field
    @property
    def quick_summary(self) -> str:
        """Generate quick summary text for tooltip."""
        return (
            f"{int(self.occupancy_percentage)}% occupied  "
            f"{self.total_students} students  "
            f"{self.available_beds} beds available"
        )


class HostelSelectorResponse(BaseSchema):
    """
    Enhanced hostel selector dropdown/sidebar response with organized data.
    
    Provides complete hostel list with categorization, recent access,
    favorites, and intelligent sorting for optimal user experience.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID")
    total_hostels: int = Field(..., ge=0, description="Total hostels managed")
    active_hostels: int = Field(..., ge=0, description="Active hostel assignments")
    
    # Active context
    active_hostel_id: Optional[UUID] = Field(None, description="Currently active hostel ID")
    active_hostel_name: Optional[str] = Field(None, description="Currently active hostel name")
    
    # Organized hostel lists
    hostels: List[HostelSelectorItem] = Field(
        default_factory=list,
        description="All hostels with details"
    )
    
    # Quick access lists (IDs for reference)
    recent_hostel_ids: List[UUID] = Field(
        default_factory=list,
        max_length=10,
        description="Recently accessed hostel IDs (max 10)"
    )
    favorite_hostel_ids: List[UUID] = Field(
        default_factory=list,
        description="Favorite hostel IDs"
    )
    primary_hostel_id: Optional[UUID] = Field(None, description="Primary hostel ID")
    
    # Hostel requiring attention
    attention_required_ids: List[UUID] = Field(
        default_factory=list,
        description="Hostels requiring immediate attention"
    )
    
    # Summary statistics
    total_pending_tasks: int = Field(0, ge=0, description="Total pending tasks across all hostels")
    total_urgent_alerts: int = Field(0, ge=0, description="Total urgent alerts")
    avg_occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Average occupancy across hostels"
    )

    @computed_field
    @property
    def has_critical_alerts(self) -> bool:
        """Check if any hostel has critical alerts."""
        return len(self.attention_required_ids) > 0

    @computed_field
    @property
    def hostels_by_category(self) -> dict:
        """Organize hostels by category for UI grouping."""
        return {
            "primary": [h for h in self.hostels if h.is_primary],
            "favorites": [h for h in self.hostels if h.is_favorite],
            "recent": [h for h in self.hostels if h.hostel_id in self.recent_hostel_ids[:5]],
            "attention_required": [h for h in self.hostels if h.requires_attention],
            "others": [
                h for h in self.hostels
                if not (h.is_primary or h.is_favorite or h.hostel_id in self.recent_hostel_ids[:5])
            ]
        }

    @computed_field
    @property
    def selector_summary(self) -> str:
        """Generate summary text for selector header."""
        if self.active_hostel_name:
            return f"Managing {self.total_hostels} hostels  Active: {self.active_hostel_name}"
        else:
            return f"Managing {self.total_hostels} hostels"


class RecentHostelItem(BaseSchema):
    """
    Enhanced recent hostel item with access patterns.
    
    Tracks recent hostel access with frequency and recency metrics
    for intelligent sorting and quick access recommendations.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")
    
    # Access tracking
    last_accessed: datetime = Field(..., description="Last access timestamp")
    access_count: int = Field(..., ge=1, description="Total access count")
    access_count_last_7_days: int = Field(0, ge=0, description="Access count in last 7 days")
    access_count_last_30_days: int = Field(0, ge=0, description="Access count in last 30 days")
    
    # Session metrics
    avg_session_duration_minutes: Decimal = Field(
        Decimal("0.00"), ge=0, description="Average session duration"
    )
    total_session_time_minutes: int = Field(0, ge=0, description="Total session time")
    
    # Quick stats for recent access
    last_occupancy: Decimal = Field(Decimal("0.00"), ge=0, le=100)
    pending_tasks_on_last_visit: int = Field(0, ge=0)

    @computed_field
    @property
    def hours_since_access(self) -> int:
        """Calculate hours since last access."""
        delta = datetime.utcnow() - self.last_accessed
        return int(delta.total_seconds() // 3600)

    @computed_field
    @property
    def access_frequency_score(self) -> Decimal:
        """Calculate access frequency score for ranking."""
        # Recent access gets higher score
        recency_score = max(0, 100 - self.hours_since_access)
        
        # Frequency score based on 7-day access
        frequency_score = min(self.access_count_last_7_days * 10, 100)
        
        # Combined score (60% frequency, 40% recency)
        total_score = (frequency_score * 0.6) + (recency_score * 0.4)
        
        return Decimal(str(total_score)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_frequent(self) -> bool:
        """Determine if this is a frequently accessed hostel."""
        return self.access_count_last_7_days >= 5


class RecentHostels(BaseSchema):
    """
    Enhanced recent hostels list with intelligent sorting.
    
    Provides recently accessed hostels sorted by access patterns
    with analytics for usage optimization recommendations.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID")
    
    hostels: List[RecentHostelItem] = Field(
        default_factory=list,
        max_length=20,
        description="Recently accessed hostels (max 20)"
    )
    
    # Summary metrics
    total_recent_hostels: int = Field(0, ge=0, description="Total recent hostels count")
    most_frequent_hostel_id: Optional[UUID] = Field(None, description="Most frequently accessed hostel")
    
    # Time range for recent access
    tracking_period_days: int = Field(30, ge=1, description="Tracking period in days")

    @computed_field
    @property
    def access_pattern_summary(self) -> str:
        """Generate access pattern summary."""
        if not self.hostels:
            return "No recent access"
        
        frequent_count = sum(1 for h in self.hostels if h.is_frequent)
        
        if frequent_count > 0:
            return f"{frequent_count} frequently accessed  {len(self.hostels)} total recent"
        else:
            return f"{len(self.hostels)} hostels accessed recently"


class FavoriteHostelItem(BaseSchema):
    """
    Enhanced favorite hostel item with customization options.
    
    Supports hostel favorites with custom labels, notes,
    and priority ordering for personalized quick access.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")
    
    # Favorite metadata
    added_to_favorites: datetime = Field(..., description="Timestamp when added to favorites")
    custom_label: Optional[str] = Field(
        None, max_length=100, description="Custom label/nickname for hostel"
    )
    notes: Optional[str] = Field(
        None, max_length=500, description="Personal notes about hostel"
    )
    display_order: int = Field(0, description="Custom display order priority")
    
    # Quick stats
    current_occupancy: Decimal = Field(Decimal("0.00"), ge=0, le=100)
    pending_items: int = Field(0, ge=0, description="Total pending items count")
    
    # Access tracking for favorites
    last_accessed: Optional[datetime] = Field(None, description="Last access timestamp")
    access_count_since_favorited: int = Field(0, ge=0)

    @computed_field
    @property
    def days_in_favorites(self) -> int:
        """Calculate days since added to favorites."""
        delta = datetime.utcnow() - self.added_to_favorites
        return delta.days

    @computed_field
    @property
    def display_name(self) -> str:
        """Get display name (custom label or hostel name)."""
        return self.custom_label if self.custom_label else self.hostel_name

    @computed_field
    @property
    def is_recently_accessed(self) -> bool:
        """Check if accessed in last 24 hours."""
        if not self.last_accessed:
            return False
        hours_since = (datetime.utcnow() - self.last_accessed).total_seconds() / 3600
        return hours_since <= 24


class FavoriteHostels(BaseSchema):
    """
    Enhanced favorites list with organization and management.
    
    Provides organized favorites with custom ordering,
    labels, and quick access to frequently used hostels.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID")
    
    hostels: List[FavoriteHostelItem] = Field(
        default_factory=list,
        description="Favorite hostels sorted by display_order"
    )
    
    total_favorites: int = Field(0, ge=0, description="Total favorite hostels count")
    max_favorites_allowed: int = Field(20, ge=1, description="Maximum favorites allowed")

    @computed_field
    @property
    def can_add_more(self) -> bool:
        """Check if more favorites can be added."""
        return self.total_favorites < self.max_favorites_allowed

    @computed_field
    @property
    def favorites_by_city(self) -> dict:
        """Group favorites by city."""
        grouped = {}
        for hostel in self.hostels:
            city = hostel.hostel_city
            if city not in grouped:
                grouped[city] = []
            grouped[city].append(hostel)
        return grouped


class UpdateFavoriteRequest(BaseCreateSchema):
    """
    Enhanced favorite update request with comprehensive customization.
    
    Supports adding/removing favorites with custom labels,
    notes, and display order preferences.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID to add/remove from favorites")
    is_favorite: bool = Field(..., description="True to add, False to remove")
    
    # Customization options (only used when is_favorite=True)
    custom_label: Optional[str] = Field(
        None,
        max_length=100,
        description="Custom label/nickname for hostel"
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Personal notes about this hostel"
    )
    display_order: Optional[int] = Field(
        None,
        ge=0,
        description="Custom display order (0 = highest priority)"
    )

    @field_validator("custom_label", "notes")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize text fields."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Normalize whitespace
            v = " ".join(v.split())
        return v

    @model_validator(mode="after")
    def validate_customization_logic(self) -> "UpdateFavoriteRequest":
        """Validate that customization is only provided when adding to favorites."""
        if not self.is_favorite:
            # Clear customization fields when removing from favorites
            if any([self.custom_label, self.notes, self.display_order is not None]):
                # Silently ignore customization when removing
                self.custom_label = None
                self.notes = None
                self.display_order = None
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\multi_hostel_dashboard.py ---
"""
Enhanced admin-hostel assignment schemas with comprehensive validation and performance optimizations.

Provides robust assignment management with audit trails, bulk operations,
and detailed permission tracking for multi-hostel administration.

Key Improvements:
- Optimized computed properties with caching
- Enhanced validation with better error messages
- Improved type hints and documentation
- Performance optimizations for large datasets
- Better separation of concerns
"""

from __future__ import annotations

from datetime import date, datetime, timedelta
from decimal import Decimal
from typing import Any, Dict, List, Optional, Set, Union
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import PermissionLevel

__all__ = [
    "AdminHostelAssignment",
    "AssignmentCreate",
    "AssignmentUpdate",
    "BulkAssignment",
    "RevokeAssignment",
    "AssignmentList",
    "HostelAdminList",
    "HostelAdminItem",
]


# Constants for validation
VALID_PERMISSION_KEYS: Set[str] = {
    "can_manage_rooms",
    "can_manage_students",
    "can_approve_bookings",
    "can_manage_fees",
    "can_view_financials",
    "can_manage_supervisors",
    "can_override_decisions",
    "can_export_data",
    "can_delete_records",
    "can_manage_hostel_settings",
    "can_view_analytics",
    "can_manage_announcements",
}

MAX_PAST_DAYS_ASSIGNMENT = 365
MAX_FUTURE_DAYS_ASSIGNMENT = 90
MAX_PAST_DAYS_REVOCATION = 30
MAX_FUTURE_DAYS_REVOCATION = 90
MAX_BULK_HOSTELS = 50
MAX_FAVORITES = 20
MAX_RECENT_HISTORY = 20

PERMISSION_LEVEL_DESCRIPTIONS = {
    PermissionLevel.FULL_ACCESS: "Full Administrative Access",
    PermissionLevel.LIMITED_ACCESS: "Limited Access with Restrictions",
    PermissionLevel.VIEW_ONLY: "Read-Only Access",
}

ACTIVITY_THRESHOLDS = {
    "no_activity": 0,
    "low": 10,
    "moderate": 50,
    "high": 100,
}


class AdminHostelAssignment(BaseResponseSchema):
    """
    Enhanced admin-hostel assignment with comprehensive tracking and analytics.

    Provides complete assignment information including permissions, activity tracking,
    and performance metrics for effective multi-hostel management.
    """

    # Core assignment identifiers
    assignment_id: UUID = Field(..., description="Unique assignment identifier")
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., min_length=1, description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")

    # Hostel information
    hostel_id: UUID = Field(..., description="Assigned hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city location")
    hostel_type: str = Field(..., description="Hostel type (boys/girls/co-ed)")

    # Assignment metadata
    assigned_by: Optional[UUID] = Field(
        None, description="Admin who created this assignment"
    )
    assigned_by_name: Optional[str] = Field(None, description="Name of assigning admin")
    assigned_date: date = Field(..., description="Date assignment was created")

    # Permission configuration
    permission_level: PermissionLevel = Field(..., description="Overall permission level")
    permissions: Dict[str, Union[bool, int, str]] = Field(
        default_factory=dict,
        description="Granular permissions for this hostel assignment",
    )

    # Assignment status
    is_active: bool = Field(True, description="Assignment is currently active")
    is_primary: bool = Field(False, description="Primary hostel for this admin")

    # Revocation tracking
    revoked_date: Optional[date] = Field(None, description="Date assignment was revoked")
    revoked_by: Optional[UUID] = Field(None, description="Admin who revoked assignment")
    revoke_reason: Optional[str] = Field(None, description="Reason for revocation")

    # Activity and performance tracking
    last_accessed: Optional[datetime] = Field(None, description="Last access timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    total_session_time_minutes: int = Field(
        0, ge=0, description="Total time spent in hostel"
    )

    # Performance metrics
    decisions_made: int = Field(0, ge=0, description="Total decisions made for this hostel")
    avg_response_time_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average response time for this hostel"
    )
    satisfaction_score: Optional[Decimal] = Field(
        None, ge=0, le=5, description="Admin satisfaction score for this hostel"
    )

    @computed_field
    @property
    def assignment_duration_days(self) -> int:
        """Calculate total assignment duration in days."""
        end_date = self.revoked_date or date.today()
        duration = (end_date - self.assigned_date).days
        return max(0, duration)

    @computed_field
    @property
    def is_recently_accessed(self) -> bool:
        """Check if hostel was accessed within last 24 hours."""
        if not self.last_accessed:
            return False
        hours_since_access = (datetime.utcnow() - self.last_accessed).total_seconds() / 3600
        return hours_since_access <= 24

    @computed_field
    @property
    def permission_summary(self) -> str:
        """Generate human-readable permission summary."""
        return PERMISSION_LEVEL_DESCRIPTIONS.get(
            self.permission_level, "Unknown Access Level"
        )

    @computed_field
    @property
    def activity_level(self) -> str:
        """Categorize admin activity level for this hostel."""
        if self.access_count == 0:
            return "No Activity"
        elif self.access_count < ACTIVITY_THRESHOLDS["low"]:
            return "Low Activity"
        elif self.access_count < ACTIVITY_THRESHOLDS["moderate"]:
            return "Moderate Activity"
        elif self.access_count < ACTIVITY_THRESHOLDS["high"]:
            return "High Activity"
        else:
            return "Very High Activity"

    @computed_field
    @property
    def avg_session_duration_minutes(self) -> Decimal:
        """Calculate average session duration."""
        if self.access_count == 0:
            return Decimal("0.00")
        avg = Decimal(self.total_session_time_minutes) / Decimal(self.access_count)
        return avg.quantize(Decimal("0.01"))

    @field_validator("admin_email")
    @classmethod
    def validate_email_format(cls, v: str) -> str:
        """Validate email format."""
        v = v.strip().lower()
        if "@" not in v or "." not in v.split("@")[1]:
            raise ValueError("Invalid email format")
        return v

    @field_validator("hostel_type")
    @classmethod
    def validate_hostel_type(cls, v: str) -> str:
        """Validate and normalize hostel type."""
        valid_types = {"boys", "girls", "co-ed", "coed", "mixed"}
        normalized = v.strip().lower()
        if normalized not in valid_types:
            raise ValueError(
                f"Invalid hostel type. Must be one of: {', '.join(valid_types)}"
            )
        # Normalize co-ed variations
        return "co-ed" if normalized in {"coed", "mixed"} else normalized


class AssignmentCreate(BaseCreateSchema):
    """
    Enhanced assignment creation with comprehensive validation.

    Supports flexible permission configuration and proper validation
    for different access levels and assignment scenarios.
    """

    admin_id: UUID = Field(..., description="Admin user ID to assign")
    hostel_id: UUID = Field(..., description="Hostel ID for assignment")

    permission_level: PermissionLevel = Field(
        PermissionLevel.FULL_ACCESS, description="Permission level for this assignment"
    )

    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None, description="Specific permissions (required for LIMITED_ACCESS level)"
    )

    is_primary: bool = Field(False, description="Set as primary hostel for admin")

    # Assignment metadata
    assignment_notes: Optional[str] = Field(
        None, max_length=1000, description="Administrative notes about this assignment"
    )
    effective_date: Optional[date] = Field(
        None, description="Effective date for assignment (defaults to today)"
    )

    # Notification preferences
    notify_admin: bool = Field(
        True, description="Send notification to admin about assignment"
    )
    send_welcome_email: bool = Field(
        True, description="Send welcome email with hostel details"
    )

    @model_validator(mode="after")
    def validate_assignment_requirements(self) -> "AssignmentCreate":
        """Validate assignment-specific business rules."""
        # Require permissions for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS:
            if not self.permissions:
                raise ValueError(
                    "Specific permissions are required when permission_level is LIMITED_ACCESS"
                )
            if not isinstance(self.permissions, dict) or len(self.permissions) == 0:
                raise ValueError(
                    "Permissions must be a non-empty dictionary for LIMITED_ACCESS"
                )

        # Validate effective date
        if self.effective_date:
            today = date.today()
            if self.effective_date < today:
                days_past = (today - self.effective_date).days
                if days_past > MAX_PAST_DAYS_ASSIGNMENT:
                    raise ValueError(
                        f"Effective date cannot be more than {MAX_PAST_DAYS_ASSIGNMENT} days in the past"
                    )
            elif self.effective_date > today:
                days_future = (self.effective_date - today).days
                if days_future > MAX_FUTURE_DAYS_ASSIGNMENT:
                    raise ValueError(
                        f"Effective date cannot be more than {MAX_FUTURE_DAYS_ASSIGNMENT} days in the future"
                    )

        return self

    @field_validator("permissions")
    @classmethod
    def validate_permissions_structure(
        cls, v: Optional[Dict[str, Union[bool, int, str]]]
    ) -> Optional[Dict[str, Union[bool, int, str]]]:
        """Validate permissions dictionary structure and values."""
        if v is None:
            return None

        # Validate each permission
        for key, value in v.items():
            if key not in VALID_PERMISSION_KEYS:
                raise ValueError(
                    f"Invalid permission key: '{key}'. Valid keys: {', '.join(sorted(VALID_PERMISSION_KEYS))}"
                )

            # Validate value types
            if not isinstance(value, (bool, int, str)):
                raise ValueError(
                    f"Invalid permission value type for '{key}': {type(value).__name__}. "
                    f"Expected bool, int, or str"
                )

            # Validate specific permission constraints
            if key.endswith("_threshold") and isinstance(value, (int, float)):
                if value < 0:
                    raise ValueError(
                        f"Threshold values must be non-negative: '{key}' = {value}"
                    )

        return v

    @field_validator("assignment_notes")
    @classmethod
    def validate_assignment_notes(cls, v: Optional[str]) -> Optional[str]:
        """Validate and clean assignment notes."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Remove excessive whitespace
            v = " ".join(v.split())
        return v


class AssignmentUpdate(BaseUpdateSchema):
    """
    Enhanced assignment update with selective field modifications.

    Allows partial updates while maintaining data consistency
    and proper validation for permission changes.
    """

    permission_level: Optional[PermissionLevel] = Field(
        None, description="Updated permission level"
    )
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None, description="Updated specific permissions"
    )
    is_primary: Optional[bool] = Field(None, description="Update primary hostel status")
    is_active: Optional[bool] = Field(None, description="Update assignment active status")

    assignment_notes: Optional[str] = Field(
        None, max_length=1000, description="Updated assignment notes"
    )

    # Update metadata
    update_reason: Optional[str] = Field(
        None, max_length=500, description="Reason for this update"
    )

    @model_validator(mode="after")
    def validate_update_consistency(self) -> "AssignmentUpdate":
        """Validate update field consistency and business rules."""
        # Ensure permissions are provided for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS:
            if self.permissions is None:
                raise ValueError(
                    "Permissions must be specified when updating to LIMITED_ACCESS level"
                )

        # Validate that at least one field is being updated
        update_fields = [
            self.permission_level,
            self.permissions,
            self.is_primary,
            self.is_active,
            self.assignment_notes,
            self.update_reason,
        ]
        if all(field is None for field in update_fields):
            raise ValueError("At least one field must be specified for update")

        return self

    # Reuse permission validation from AssignmentCreate
    _validate_permissions = field_validator("permissions")(
        AssignmentCreate.validate_permissions_structure.__func__
    )

    @field_validator("assignment_notes", "update_reason")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize text fields."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            v = " ".join(v.split())
        return v


class BulkAssignment(BaseCreateSchema):
    """
    Enhanced bulk assignment with comprehensive validation and options.

    Supports efficient batch operations while maintaining data integrity
    and providing flexible assignment strategies.
    """

    admin_id: UUID = Field(..., description="Admin user ID for all assignments")
    hostel_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=MAX_BULK_HOSTELS,
        description=f"List of hostel IDs for bulk assignment (max {MAX_BULK_HOSTELS})",
    )

    permission_level: PermissionLevel = Field(
        PermissionLevel.FULL_ACCESS, description="Permission level for all assignments"
    )
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None, description="Permissions applied to all assignments"
    )

    primary_hostel_id: Optional[UUID] = Field(
        None, description="Which hostel should be set as primary (must be in hostel_ids)"
    )

    # Bulk operation strategies
    skip_existing: bool = Field(
        True, description="Skip hostels where admin already has active assignment"
    )
    update_existing: bool = Field(
        False, description="Update existing assignments with new permissions"
    )
    force_primary: bool = Field(
        False, description="Force primary hostel change even if admin has existing primary"
    )

    # Metadata and notifications
    bulk_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Notes applied to all assignments in this bulk operation",
    )
    notify_admin: bool = Field(True, description="Send notification about bulk assignment")
    send_summary_email: bool = Field(
        True, description="Send summary email after completion"
    )

    @field_validator("hostel_ids")
    @classmethod
    def validate_unique_hostel_ids(cls, v: List[UUID]) -> List[UUID]:
        """Ensure hostel IDs are unique and validate list size."""
        if len(v) != len(set(v)):
            duplicates = [item for item in v if v.count(item) > 1]
            raise ValueError(
                f"Hostel IDs must be unique in bulk assignment. Duplicates found: {duplicates}"
            )

        if len(v) > MAX_BULK_HOSTELS:
            raise ValueError(
                f"Cannot assign more than {MAX_BULK_HOSTELS} hostels in a single bulk operation"
            )

        return v

    @model_validator(mode="after")
    def validate_bulk_assignment_logic(self) -> "BulkAssignment":
        """Validate bulk assignment business logic and constraints."""
        # Validate primary hostel selection
        if self.primary_hostel_id and self.primary_hostel_id not in self.hostel_ids:
            raise ValueError(
                "Primary hostel ID must be included in the hostel_ids list"
            )

        # Validate operation strategy
        if self.skip_existing and self.update_existing:
            raise ValueError(
                "Cannot both skip_existing and update_existing. Choose one strategy."
            )

        # Validate permissions for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS and not self.permissions:
            raise ValueError(
                "Permissions must be specified for LIMITED_ACCESS level in bulk assignment"
            )

        return self

    # Reuse permission validation
    _validate_permissions = field_validator("permissions")(
        AssignmentCreate.validate_permissions_structure.__func__
    )

    @field_validator("bulk_notes")
    @classmethod
    def validate_bulk_notes(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize bulk notes."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            v = " ".join(v.split())
        return v


class RevokeAssignment(BaseCreateSchema):
    """
    Enhanced assignment revocation with comprehensive audit trail.

    Provides detailed revocation tracking with proper validation
    and support for different revocation scenarios.
    """

    assignment_id: UUID = Field(..., description="Assignment ID to revoke")
    revoke_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for assignment revocation",
    )

    # Revocation timing and options
    effective_date: Optional[date] = Field(
        None, description="Effective revocation date (defaults to today)"
    )
    immediate_revocation: bool = Field(
        True, description="Revoke immediately or schedule for effective_date"
    )

    # Transition management
    transfer_to_admin_id: Optional[UUID] = Field(
        None, description="Transfer responsibilities to another admin"
    )
    handover_notes: Optional[str] = Field(
        None, max_length=1000, description="Handover notes for responsibility transfer"
    )

    # Notification preferences
    notify_affected_admin: bool = Field(True, description="Notify admin being revoked")
    notify_hostel_supervisors: bool = Field(
        True, description="Notify hostel supervisors"
    )

    # Data retention
    retain_access_logs: bool = Field(True, description="Retain access logs for audit")
    archive_permissions: bool = Field(True, description="Archive permission history")

    @field_validator("revoke_reason")
    @classmethod
    def validate_revoke_reason(cls, v: str) -> str:
        """Validate and normalize revocation reason."""
        reason = v.strip()
        if len(reason) < 10:
            raise ValueError("Revocation reason must be at least 10 characters")

        # Remove excessive whitespace
        reason = " ".join(reason.split())

        # Check for placeholder text
        placeholder_phrases = ["test", "no reason", "n/a", "none", "na"]
        if reason.lower() in placeholder_phrases:
            raise ValueError(
                "Please provide a meaningful revocation reason, not a placeholder"
            )

        return reason

    @field_validator("effective_date")
    @classmethod
    def validate_effective_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate revocation effective date."""
        if v is not None:
            today = date.today()

            # Allow past dates for historical revocations
            if v < today:
                days_past = (today - v).days
                if days_past > MAX_PAST_DAYS_REVOCATION:
                    raise ValueError(
                        f"Effective date cannot be more than {MAX_PAST_DAYS_REVOCATION} days in the past"
                    )

            # Allow future dates for scheduled revocations
            elif v > today:
                days_future = (v - today).days
                if days_future > MAX_FUTURE_DAYS_REVOCATION:
                    raise ValueError(
                        f"Effective date cannot be more than {MAX_FUTURE_DAYS_REVOCATION} days in the future"
                    )

        return v

    @model_validator(mode="after")
    def validate_revocation_logic(self) -> "RevokeAssignment":
        """Validate revocation business logic."""
        # Validate transfer requirements
        if self.transfer_to_admin_id:
            if not self.handover_notes:
                raise ValueError(
                    "Handover notes are required when transferring to another admin"
                )
            if len(self.handover_notes.strip()) < 20:
                raise ValueError(
                    "Handover notes must be at least 20 characters for proper transition"
                )

        # Validate immediate vs scheduled revocation
        if not self.immediate_revocation and not self.effective_date:
            raise ValueError(
                "Effective date must be specified for non-immediate revocation"
            )

        if (
            self.immediate_revocation
            and self.effective_date
            and self.effective_date != date.today()
        ):
            raise ValueError("Immediate revocation cannot have future effective date")

        return self

    @field_validator("handover_notes")
    @classmethod
    def validate_handover_notes(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize handover notes."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            v = " ".join(v.split())
        return v


class AssignmentList(BaseSchema):
    """
    Enhanced assignment list with comprehensive admin overview.

    Provides aggregated view of all assignments for an admin
    with summary statistics and quick access information.
    """

    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., min_length=1, description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")

    # Assignment statistics
    total_hostels: int = Field(..., ge=0, description="Total hostels assigned")
    active_hostels: int = Field(..., ge=0, description="Currently active assignments")
    inactive_hostels: int = Field(..., ge=0, description="Inactive assignments")

    # Primary hostel information
    primary_hostel_id: Optional[UUID] = Field(None, description="Primary hostel ID")
    primary_hostel_name: Optional[str] = Field(None, description="Primary hostel name")

    # Activity summary
    last_activity: Optional[datetime] = Field(
        None, description="Last activity across all hostels"
    )
    total_access_count: int = Field(0, ge=0, description="Total access count across hostels")

    # Assignment details
    assignments: List[AdminHostelAssignment] = Field(
        default_factory=list, description="Detailed assignment information"
    )

    # Performance metrics
    avg_response_time_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average response time across all hostels"
    )
    total_decisions_made: int = Field(0, ge=0, description="Total decisions across hostels")

    @computed_field
    @property
    def assignment_utilization_rate(self) -> Decimal:
        """Calculate assignment utilization rate."""
        if self.total_hostels == 0:
            return Decimal("0.00")
        rate = Decimal(self.active_hostels) / Decimal(self.total_hostels) * 100
        return rate.quantize(Decimal("0.01"))

    @computed_field
    @property
    def most_active_hostel(self) -> Optional[str]:
        """Identify most active hostel by access count."""
        if not self.assignments:
            return None

        most_active = max(self.assignments, key=lambda x: x.access_count, default=None)
        if most_active and most_active.access_count > 0:
            return most_active.hostel_name
        return None

    @computed_field
    @property
    def permission_distribution(self) -> Dict[str, int]:
        """Calculate distribution of permission levels."""
        distribution = {level.value: 0 for level in PermissionLevel}

        for assignment in self.assignments:
            if assignment.is_active:
                distribution[assignment.permission_level.value] += 1

        return distribution

    @model_validator(mode="after")
    def validate_statistics_consistency(self) -> "AssignmentList":
        """Validate that statistics are consistent with assignments."""
        if self.total_hostels != len(self.assignments):
            # This is a warning, not an error - could be pagination
            pass

        active_count = sum(1 for a in self.assignments if a.is_active)
        if self.active_hostels != active_count:
            # Log inconsistency but don't raise error
            pass

        return self


class HostelAdminList(BaseSchema):
    """
    Enhanced hostel admin list with comprehensive hostel overview.

    Provides detailed view of all admins assigned to a specific hostel
    with their permissions and activity levels.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")

    # Admin statistics
    total_admins: int = Field(..., ge=0, description="Total assigned admins")
    active_admins: int = Field(..., ge=0, description="Currently active admin assignments")

    # Primary admin information
    primary_admin_id: Optional[UUID] = Field(None, description="Primary admin ID")
    primary_admin_name: Optional[str] = Field(None, description="Primary admin name")

    # Coverage information
    coverage_24x7: bool = Field(False, description="24x7 admin coverage available")
    last_admin_activity: Optional[datetime] = Field(
        None, description="Last admin activity"
    )

    # Admin details
    admins: List["HostelAdminItem"] = Field(
        default_factory=list, description="Detailed admin assignment information"
    )

    @computed_field
    @property
    def admin_coverage_score(self) -> Decimal:
        """Calculate admin coverage adequacy score."""
        if self.total_admins == 0:
            return Decimal("0.00")

        # Base score from admin count (max 50 points)
        count_score = min(self.total_admins * 25, 50)

        # Activity score (max 30 points)
        activity_score = 30 if self.active_admins > 0 else 0

        # Coverage score (max 20 points)
        coverage_score = 20 if self.coverage_24x7 else 10

        total_score = count_score + activity_score + coverage_score
        return Decimal(str(total_score)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def permission_coverage(self) -> Dict[str, bool]:
        """Check if all critical permissions are covered by at least one admin."""
        critical_permissions = [
            "can_manage_students",
            "can_approve_bookings",
            "can_manage_fees",
            "can_override_decisions",
            "can_manage_supervisors",
        ]

        coverage = {}
        for permission in critical_permissions:
            coverage[permission] = any(
                admin.permission_level == PermissionLevel.FULL_ACCESS
                or admin.has_specific_permission(permission)
                for admin in self.admins
                if admin.is_active
            )

        return coverage

    @computed_field
    @property
    def coverage_gaps(self) -> List[str]:
        """Identify permission coverage gaps."""
        coverage = self.permission_coverage
        return [perm for perm, covered in coverage.items() if not covered]


class HostelAdminItem(BaseSchema):
    """
    Enhanced admin item with detailed assignment information.

    Represents individual admin assignment within hostel admin list
    with comprehensive permission and activity tracking.
    """

    # Admin identification
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., min_length=1, description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")

    # Assignment details
    assignment_id: UUID = Field(..., description="Assignment ID")
    permission_level: PermissionLevel = Field(..., description="Permission level")
    is_primary: bool = Field(False, description="Primary admin for this hostel")
    is_active: bool = Field(True, description="Assignment is active")

    # Assignment metadata
    assigned_date: date = Field(..., description="Assignment creation date")
    assigned_by_name: Optional[str] = Field(None, description="Name of assigning admin")

    # Activity tracking
    last_active: Optional[datetime] = Field(None, description="Last activity timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    avg_session_duration_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average session duration"
    )

    # Performance metrics
    decisions_made: int = Field(0, ge=0, description="Total decisions made")
    response_time_avg_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average response time"
    )

    # Specific permissions (for limited access)
    specific_permissions: Dict[str, Union[bool, int, str]] = Field(
        default_factory=dict, description="Specific permissions for limited access admins"
    )

    @computed_field
    @property
    def assignment_duration_days(self) -> int:
        """Calculate assignment duration in days."""
        duration = (date.today() - self.assigned_date).days
        return max(0, duration)

    @computed_field
    @property
    def activity_status(self) -> str:
        """Determine admin activity status."""
        if not self.last_active:
            return "Never Active"

        hours_since_activity = (
            datetime.utcnow() - self.last_active
        ).total_seconds() / 3600

        if hours_since_activity <= 1:
            return "Online"
        elif hours_since_activity <= 24:
            return "Recently Active"
        elif hours_since_activity <= 168:  # 1 week
            return "Active This Week"
        else:
            return "Inactive"

    @computed_field
    @property
    def permission_summary(self) -> str:
        """Generate human-readable permission summary."""
        if self.permission_level == PermissionLevel.FULL_ACCESS:
            return "Full Administrative Access"
        elif self.permission_level == PermissionLevel.LIMITED_ACCESS:
            perm_count = sum(
                1 for p in self.specific_permissions.values() if p is True
            )
            return f"Limited Access ({perm_count} permissions)"
        else:
            return "View Only Access"

    def has_specific_permission(self, permission_key: str) -> bool:
        """Check if admin has a specific permission."""
        if self.permission_level == PermissionLevel.FULL_ACCESS:
            return True
        elif self.permission_level == PermissionLevel.LIMITED_ACCESS:
            return self.specific_permissions.get(permission_key, False) is True
        else:
            return False

    @computed_field
    @property
    def performance_score(self) -> Decimal:
        """Calculate overall performance score for this admin-hostel assignment."""
        score = Decimal("0.00")

        # Activity score (40 points max)
        if self.access_count > 0:
            activity_score = min(self.access_count * 2, 40)
            score += Decimal(str(activity_score))

        # Decision making score (30 points max)
        if self.decisions_made > 0:
            decision_score = min(self.decisions_made * 3, 30)
            score += Decimal(str(decision_score))

        # Response time score (30 points max)
        if self.response_time_avg_minutes:
            response_minutes = float(self.response_time_avg_minutes)
            if response_minutes <= 30:
                response_score = 30
            elif response_minutes >= 120:
                response_score = 0
            else:
                # Linear interpolation
                response_score = 30 * (1 - (response_minutes - 30) / 90)
            score += Decimal(str(response_score))

        return score.quantize(Decimal("0.01"))

    @computed_field
    @property
    def needs_attention(self) -> bool:
        """Determine if this admin assignment needs attention."""
        # Low performance score
        if self.performance_score < Decimal("30.00"):
            return True

        # No activity in last 7 days for active assignment
        if self.is_active and self.last_active:
            days_inactive = (datetime.utcnow() - self.last_active).days
            if days_inactive > 7:
                return True

        # Low activity count for long-term assignment
        if self.assignment_duration_days > 30 and self.access_count < 10:
            return True

        return False

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\__init__.py ---
from __future__ import annotations

from app.schemas.admin.admin_hostel_assignment import (
    AdminHostelAssignment,
    AssignmentCreate,
    AssignmentList,
    AssignmentUpdate,
    BulkAssignment,
    HostelAdminItem,
    HostelAdminList,
    RevokeAssignment,
)
from app.schemas.admin.admin_override import (
    AdminOverrideRequest,
    OverrideLog,
    OverrideReason,
    OverrideSummary,
    SupervisorOverrideStats,
)
from app.schemas.admin.admin_permissions import (
    AdminPermissions,
    PermissionCheck,
    PermissionMatrix,
    RolePermissions,
)
from app.schemas.admin.hostel_context import (
    ActiveHostelResponse,
    ContextHistory,
    ContextSwitch,
    HostelContext,
    HostelSwitchRequest,
)
from app.schemas.admin.hostel_selector import (
    FavoriteHostelItem,
    FavoriteHostels,
    HostelSelectorItem,
    HostelSelectorResponse,
    RecentHostelItem,
    RecentHostels,
    UpdateFavoriteRequest,
)
from app.schemas.admin.multi_hostel_dashboard import (
    AggregatedStats,
    BottomPerformer,
    CrossHostelComparison,
    HostelMetricComparison,
    HostelQuickStats,
    HostelTaskSummary,
    MultiHostelDashboard,
    TopPerformer,
)

__all__ = [
    # Hostel Assignment Management
    "AdminHostelAssignment",
    "AssignmentCreate",
    "AssignmentUpdate",
    "BulkAssignment",
    "RevokeAssignment",
    "AssignmentList",
    "HostelAdminList",
    "HostelAdminItem",
    
    # Hostel Context Management
    "HostelContext",
    "HostelSwitchRequest",
    "ActiveHostelResponse",
    "ContextHistory",
    "ContextSwitch",
    
    # Hostel Selector UI
    "HostelSelectorResponse",
    "HostelSelectorItem",
    "RecentHostels",
    "RecentHostelItem",
    "FavoriteHostels",
    "FavoriteHostelItem",
    "UpdateFavoriteRequest",
    
    # Multi-Hostel Dashboard
    "MultiHostelDashboard",
    "AggregatedStats",
    "HostelQuickStats",
    "CrossHostelComparison",
    "TopPerformer",
    "BottomPerformer",
    "HostelMetricComparison",
    "HostelTaskSummary",
    
    # Admin Override System
    "AdminOverrideRequest",
    "OverrideLog",
    "OverrideReason",
    "OverrideSummary",
    "SupervisorOverrideStats",
    
    # Admin Permissions
    "AdminPermissions",
    "PermissionMatrix",
    "RolePermissions",
    "PermissionCheck",
]


# Package metadata
__author__ = "Hostel Management System Team"
__description__ = "Admin management schemas for multi-hostel operations"


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\__pycache__ =====


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\hostel_context.py ---
"""
Enhanced hostel context management for multi-hostel admin operations.

Provides robust context switching, session tracking, and history management
for seamless multi-hostel administration with comprehensive audit trails.

Key Improvements:
- Optimized computed properties with better performance
- Enhanced validation with clearer error messages
- Better session management logic
- Improved type safety and null handling
- Comprehensive metrics calculation
"""

from __future__ import annotations

from datetime import datetime, timedelta, date
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "HostelContext",
    "HostelSwitchRequest",
    "ActiveHostelResponse",
    "ContextHistory",
    "ContextSwitch",
]


# Constants
STALE_SESSION_MINUTES = 30
RECENT_ACCESS_HOURS = 24
MAX_RETURN_URL_LENGTH = 500
MAX_SWITCH_REASON_LENGTH = 200
MIN_PRODUCTIVE_SESSION_MINUTES = 5
EXCELLENT_ACTIONS_PER_MINUTE = 0.5

HEALTH_SCORE_WEIGHTS = {
    "occupancy": 0.4,
    "tasks": 0.3,
    "alerts": 0.3,
}

ACTIVITY_TRIGGERS = {
    "manual",
    "automatic",
    "notification",
    "alert",
    "scheduled",
}


class HostelContext(BaseSchema):
    """
    Enhanced current hostel context for multi-hostel admin with real-time metrics.

    Maintains active hostel state with comprehensive permission information,
    session tracking, and quick access to relevant statistics.
    """

    # Admin and context identifiers
    admin_id: UUID = Field(..., description="Admin user ID")
    context_id: UUID = Field(..., description="Unique context session ID")

    # Active hostel information
    active_hostel_id: UUID = Field(..., description="Currently active hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Active hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city location")
    hostel_type: str = Field(..., description="Hostel type classification")

    # Permission information for active hostel
    permission_level: str = Field(..., description="Permission level for active hostel")
    permissions: dict = Field(
        default_factory=dict, description="Detailed permissions for active hostel"
    )

    # Context session tracking
    context_started_at: datetime = Field(..., description="Context session start time")
    last_accessed_at: datetime = Field(..., description="Last activity timestamp")
    session_duration_minutes: int = Field(0, ge=0, description="Current session duration")

    # Quick statistics for active hostel
    total_students: int = Field(0, ge=0, description="Total students in active hostel")
    active_students: int = Field(0, ge=0, description="Currently active students")
    occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Current occupancy rate"
    )

    # Pending tasks and alerts
    pending_tasks: int = Field(0, ge=0, description="Pending tasks count")
    urgent_alerts: int = Field(0, ge=0, description="Urgent alerts count")
    unread_notifications: int = Field(0, ge=0, description="Unread notifications count")

    # Revenue snapshot
    revenue_this_month: Decimal = Field(
        Decimal("0.00"), ge=0, description="Revenue for current month"
    )
    outstanding_payments: Decimal = Field(
        Decimal("0.00"), ge=0, description="Outstanding payment amount"
    )

    # Context metadata
    previous_hostel_id: Optional[UUID] = Field(None, description="Previously active hostel")
    switch_count: int = Field(0, ge=0, description="Number of context switches in session")

    @computed_field
    @property
    def session_active_duration(self) -> str:
        """Calculate and format active session duration."""
        duration = datetime.utcnow() - self.context_started_at

        total_seconds = int(duration.total_seconds())
        hours = total_seconds // 3600
        minutes = (total_seconds % 3600) // 60

        if hours > 0:
            return f"{hours}h {minutes}m"
        else:
            return f"{minutes}m"

    @computed_field
    @property
    def context_health_score(self) -> Decimal:
        """Calculate context health score based on hostel metrics."""
        score = Decimal("0.00")

        # Occupancy contribution (40 points)
        occupancy_score = self.occupancy_percentage * Decimal(str(HEALTH_SCORE_WEIGHTS["occupancy"]))
        score += occupancy_score

        # Task management (30 points)
        task_weight = Decimal(str(HEALTH_SCORE_WEIGHTS["tasks"] * 100))
        if self.pending_tasks == 0:
            score += task_weight
        elif self.pending_tasks <= 5:
            score += task_weight * Decimal("0.67")
        elif self.pending_tasks <= 10:
            score += task_weight * Decimal("0.33")

        # Alert status (30 points)
        alert_weight = Decimal(str(HEALTH_SCORE_WEIGHTS["alerts"] * 100))
        if self.urgent_alerts == 0:
            score += alert_weight
        elif self.urgent_alerts <= 2:
            score += alert_weight * Decimal("0.5")

        return score.quantize(Decimal("0.01"))

    @computed_field
    @property
    def requires_attention(self) -> bool:
        """Determine if active hostel requires immediate attention."""
        return (
            self.urgent_alerts > 0
            or self.pending_tasks > 10
            or self.occupancy_percentage < Decimal("50.00")
            or self.outstanding_payments > self.revenue_this_month
        )

    @computed_field
    @property
    def is_stale_session(self) -> bool:
        """Check if context session is stale (no activity for 30+ minutes)."""
        inactive_duration = datetime.utcnow() - self.last_accessed_at
        return inactive_duration > timedelta(minutes=STALE_SESSION_MINUTES)

    @computed_field
    @property
    def attention_priority(self) -> str:
        """Determine attention priority level."""
        if self.urgent_alerts > 5:
            return "Critical"
        elif self.urgent_alerts > 0 or self.pending_tasks > 20:
            return "High"
        elif self.pending_tasks > 10 or self.occupancy_percentage < Decimal("60.00"):
            return "Medium"
        else:
            return "Low"

    @field_validator("hostel_type")
    @classmethod
    def validate_hostel_type(cls, v: str) -> str:
        """Validate hostel type."""
        valid_types = {"boys", "girls", "co-ed", "coed", "mixed"}
        normalized = v.strip().lower()
        if normalized not in valid_types:
            raise ValueError(f"Invalid hostel type: {v}")
        return "co-ed" if normalized in {"coed", "mixed"} else normalized

    @model_validator(mode="after")
    def validate_session_consistency(self) -> "HostelContext":
        """Validate session timing consistency."""
        if self.last_accessed_at < self.context_started_at:
            raise ValueError("last_accessed_at cannot be before context_started_at")

        # Calculate expected duration
        expected_duration = int(
            (self.last_accessed_at - self.context_started_at).total_seconds() / 60
        )

        # Allow some tolerance for concurrent updates
        if abs(expected_duration - self.session_duration_minutes) > 5:
            # Log warning but don't raise error
            pass

        return self


class HostelSwitchRequest(BaseCreateSchema):
    """
    Enhanced hostel context switch request with validation and options.

    Supports seamless context switching with proper validation,
    session management, and optional data refresh preferences.
    """

    hostel_id: UUID = Field(..., description="Target hostel ID to switch to")

    # Switch preferences
    save_current_session: bool = Field(
        True, description="Save current session state before switching"
    )
    refresh_dashboard: bool = Field(
        True, description="Refresh dashboard data after switch"
    )
    load_pending_tasks: bool = Field(
        True, description="Load pending tasks for new context"
    )

    # Navigation context
    return_url: Optional[str] = Field(
        None, max_length=MAX_RETURN_URL_LENGTH, description="URL to navigate to after switch"
    )
    switch_reason: Optional[str] = Field(
        None, max_length=MAX_SWITCH_REASON_LENGTH, description="Reason for context switch (for analytics)"
    )

    @field_validator("return_url")
    @classmethod
    def validate_return_url(cls, v: Optional[str]) -> Optional[str]:
        """Validate return URL format."""
        if v is not None:
            v = v.strip()
            if not v:
                return None

            # Basic URL validation
            if not v.startswith(("/", "http://", "https://")):
                raise ValueError(
                    "Invalid return URL format. Must start with /, http://, or https://"
                )

            # Prevent potential XSS
            dangerous_patterns = ["javascript:", "data:", "vbscript:"]
            if any(pattern in v.lower() for pattern in dangerous_patterns):
                raise ValueError("Return URL contains potentially dangerous content")

        return v

    @field_validator("switch_reason")
    @classmethod
    def validate_switch_reason(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize switch reason."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            v = " ".join(v.split())  # Normalize whitespace
        return v


class ActiveHostelResponse(BaseSchema):
    """
    Enhanced response after successful hostel context switch.

    Provides comprehensive information about the newly active hostel
    with permissions, statistics, and navigation guidance.
    """

    # Context identifiers
    admin_id: UUID = Field(..., description="Admin user ID")
    context_id: UUID = Field(..., description="New context session ID")

    # Previous and current hostel information
    previous_hostel_id: Optional[UUID] = Field(None, description="Previous active hostel ID")
    previous_hostel_name: Optional[str] = Field(None, description="Previous hostel name")

    active_hostel_id: UUID = Field(..., description="Newly active hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Active hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")

    # Permission configuration for new context
    permission_level: str = Field(..., description="Permission level for new hostel")
    permissions: dict = Field(default_factory=dict, description="Detailed permissions")

    # Context timing
    switched_at: datetime = Field(..., description="Context switch timestamp")
    previous_session_duration_minutes: Optional[int] = Field(
        None, ge=0, description="Duration of previous session"
    )

    # Quick statistics for new hostel
    total_students: int = Field(0, ge=0, description="Total students")
    occupancy_percentage: Decimal = Field(Decimal("0.00"), ge=0, le=100)
    pending_tasks: int = Field(0, ge=0, description="Pending tasks")
    urgent_alerts: int = Field(0, ge=0, description="Urgent alerts")

    # Response metadata
    message: str = Field(..., min_length=1, description="Success message")
    dashboard_url: Optional[str] = Field(None, description="Dashboard URL for new context")

    # Navigation suggestions
    suggested_actions: List[str] = Field(
        default_factory=list, description="Suggested next actions based on hostel state"
    )

    @computed_field
    @property
    def switch_summary(self) -> str:
        """Generate human-readable switch summary."""
        if self.previous_hostel_name:
            return f"Switched from {self.previous_hostel_name} to {self.hostel_name}"
        else:
            return f"Activated context for {self.hostel_name}"

    @computed_field
    @property
    def requires_immediate_action(self) -> bool:
        """Check if new context requires immediate action."""
        return self.urgent_alerts > 0 or self.pending_tasks > 5

    @computed_field
    @property
    def hostel_health_indicator(self) -> str:
        """Generate health indicator for newly active hostel."""
        if self.urgent_alerts > 0:
            return "critical"
        elif self.pending_tasks > 10:
            return "warning"
        elif self.occupancy_percentage < Decimal("60.00"):
            return "attention"
        else:
            return "healthy"

    @computed_field
    @property
    def priority_level(self) -> int:
        """Calculate priority level (1-5, where 5 is highest)."""
        if self.urgent_alerts > 5:
            return 5
        elif self.urgent_alerts > 0:
            return 4
        elif self.pending_tasks > 10:
            return 3
        elif self.pending_tasks > 5:
            return 2
        else:
            return 1

    @model_validator(mode="after")
    def populate_suggested_actions(self) -> "ActiveHostelResponse":
        """Populate suggested actions based on hostel state."""
        if not self.suggested_actions:
            actions = []

            if self.urgent_alerts > 0:
                actions.append(f"Review {self.urgent_alerts} urgent alerts")

            if self.pending_tasks > 10:
                actions.append(f"Process {self.pending_tasks} pending tasks")

            if self.occupancy_percentage < Decimal("50.00"):
                actions.append("Review low occupancy and marketing strategy")

            if self.occupancy_percentage > Decimal("95.00"):
                actions.append("Check waitlist for high occupancy")

            if not actions:
                actions.append("Dashboard is up to date")

            self.suggested_actions = actions

        return self


class ContextSwitch(BaseSchema):
    """
    Enhanced individual context switch record with comprehensive tracking.

    Represents a single hostel context switch with timing, reason,
    and session metrics for analytics and audit purposes.
    """

    # Switch identification
    switch_id: UUID = Field(..., description="Unique switch record ID")
    admin_id: UUID = Field(..., description="Admin user ID")

    # Source and destination hostels
    from_hostel_id: Optional[UUID] = Field(None, description="Source hostel ID")
    from_hostel_name: Optional[str] = Field(None, description="Source hostel name")
    to_hostel_id: UUID = Field(..., description="Destination hostel ID")
    to_hostel_name: str = Field(..., min_length=1, description="Destination hostel name")

    # Switch timing
    switched_at: datetime = Field(..., description="Switch timestamp")
    session_duration_minutes: Optional[int] = Field(
        None, ge=0, description="Duration spent in previous hostel (if applicable)"
    )

    # Switch context
    switch_reason: Optional[str] = Field(None, description="Reason for switch")
    triggered_by: str = Field(
        "manual",
        description="What triggered the switch (manual, automatic, notification, alert, scheduled)",
    )

    # Activity metrics during session
    actions_performed: int = Field(0, ge=0, description="Actions performed in session")
    decisions_made: int = Field(0, ge=0, description="Decisions made in session")

    # Navigation context
    source_page: Optional[str] = Field(None, description="Page where switch was initiated")
    destination_page: Optional[str] = Field(None, description="Landing page after switch")

    @computed_field
    @property
    def session_productivity_score(self) -> Decimal:
        """Calculate productivity score for the session."""
        if self.session_duration_minutes is None or self.session_duration_minutes == 0:
            return Decimal("0.00")

        # Calculate actions per minute
        actions_per_minute = Decimal(self.actions_performed) / Decimal(
            self.session_duration_minutes
        )

        # Score based on actions per minute (capped at 100)
        score = min(
            (actions_per_minute / Decimal(str(EXCELLENT_ACTIONS_PER_MINUTE))) * 100, 100
        )

        return Decimal(str(score)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def was_productive_session(self) -> bool:
        """Determine if session was productive (made meaningful progress)."""
        if self.session_duration_minutes is None:
            return False

        # Consider productive if:
        # - At least 5 minutes AND at least 1 action OR
        # - At least 1 decision made
        return (
            self.session_duration_minutes >= MIN_PRODUCTIVE_SESSION_MINUTES
            and self.actions_performed > 0
        ) or self.decisions_made > 0

    @computed_field
    @property
    def switch_type_description(self) -> str:
        """Generate human-readable switch type description."""
        type_map = {
            "manual": "User-initiated switch",
            "automatic": "Automatic context switch",
            "notification": "Triggered by notification",
            "alert": "Triggered by alert",
            "scheduled": "Scheduled context switch",
        }
        return type_map.get(self.triggered_by, "Unknown switch type")

    @computed_field
    @property
    def efficiency_rating(self) -> str:
        """Rate session efficiency."""
        score = float(self.session_productivity_score)

        if score >= 80:
            return "Excellent"
        elif score >= 60:
            return "Good"
        elif score >= 40:
            return "Fair"
        elif score > 0:
            return "Poor"
        else:
            return "No Activity"

    @field_validator("triggered_by")
    @classmethod
    def validate_triggered_by(cls, v: str) -> str:
        """Validate trigger type."""
        normalized = v.strip().lower()
        if normalized not in ACTIVITY_TRIGGERS:
            raise ValueError(
                f"Invalid trigger type: '{v}'. Valid types: {', '.join(ACTIVITY_TRIGGERS)}"
            )
        return normalized


class ContextHistory(BaseSchema):
    """
    Enhanced context switch history with analytics and insights.

    Provides comprehensive historical view of all context switches
    with usage patterns, productivity metrics, and recommendations.
    """

    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., min_length=1, description="Admin full name")

    # History period
    history_start: datetime = Field(..., description="History period start")
    history_end: datetime = Field(..., description="History period end")

    # Switch records
    switches: List[ContextSwitch] = Field(
        default_factory=list, description="Chronological list of context switches"
    )

    # Aggregate statistics
    total_switches: int = Field(0, ge=0, description="Total number of switches")
    unique_hostels_accessed: int = Field(0, ge=0, description="Unique hostels accessed")
    total_session_time_minutes: int = Field(
        0, ge=0, description="Total time across all sessions"
    )

    # Most accessed hostel
    most_accessed_hostel_id: Optional[UUID] = Field(
        None, description="Most frequently accessed hostel"
    )
    most_accessed_hostel_name: Optional[str] = Field(
        None, description="Most accessed hostel name"
    )
    most_accessed_count: int = Field(0, ge=0, description="Access count for most accessed hostel")

    # Usage patterns
    avg_session_duration_minutes: Decimal = Field(
        Decimal("0.00"), ge=0, description="Average session duration"
    )
    avg_switches_per_day: Decimal = Field(
        Decimal("0.00"), ge=0, description="Average switches per day"
    )

    # Productivity metrics
    total_actions_performed: int = Field(0, ge=0, description="Total actions across all sessions")
    total_decisions_made: int = Field(0, ge=0, description="Total decisions across all sessions")
    productivity_score: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Overall productivity score"
    )

    @computed_field
    @property
    def history_duration_days(self) -> int:
        """Calculate history period duration in days."""
        duration = (self.history_end - self.history_start).days
        return max(1, duration)

    @computed_field
    @property
    def switch_frequency_pattern(self) -> str:
        """Determine switch frequency pattern."""
        switches_per_day = float(self.avg_switches_per_day)

        if switches_per_day < 2:
            return "Low Frequency"
        elif switches_per_day < 5:
            return "Moderate Frequency"
        elif switches_per_day < 10:
            return "High Frequency"
        else:
            return "Very High Frequency"

    @computed_field
    @property
    def session_efficiency_score(self) -> Decimal:
        """Calculate session efficiency score."""
        if self.total_switches == 0:
            return Decimal("0.00")

        # Calculate average actions per switch
        avg_actions = Decimal(self.total_actions_performed) / Decimal(self.total_switches)

        # Calculate average decisions per switch
        avg_decisions = Decimal(self.total_decisions_made) / Decimal(self.total_switches)

        # Combined efficiency score
        efficiency = (avg_actions * Decimal("0.6") + avg_decisions * Decimal("0.4")) * 10

        return Decimal(str(min(float(efficiency), 100))).quantize(Decimal("0.01"))

    @computed_field
    @property
    def hostel_focus_distribution(self) -> str:
        """Determine hostel focus distribution pattern."""
        if self.unique_hostels_accessed == 0:
            return "No Activity"

        if self.total_switches == 0:
            return "No Activity"

        # Calculate concentration: how focused admin is on specific hostels
        concentration_ratio = self.most_accessed_count / self.total_switches

        if concentration_ratio > 0.7:
            return "Highly Focused (70%+ on one hostel)"
        elif concentration_ratio > 0.5:
            return "Moderately Focused (50-70% on one hostel)"
        else:
            return "Distributed (Balanced across hostels)"

    @computed_field
    @property
    def recommendations(self) -> List[str]:
        """Generate context usage recommendations based on patterns."""
        recommendations = []

        # High switch frequency recommendation
        if float(self.avg_switches_per_day) > 10:
            recommendations.append(
                "Consider consolidating tasks to reduce frequent context switching"
            )

        # Short session duration recommendation
        if float(self.avg_session_duration_minutes) < 10 and self.total_switches > 5:
            recommendations.append(
                "Average session duration is short; consider focusing on one hostel at a time"
            )

        # Low productivity recommendation
        if float(self.productivity_score) < 50 and self.total_switches > 10:
            recommendations.append(
                "Productivity could be improved by spending more time per hostel session"
            )

        # Balanced usage recommendation
        if self.unique_hostels_accessed > 5:
            concentration_ratio = (
                self.most_accessed_count / self.total_switches if self.total_switches > 0 else 0
            )
            if concentration_ratio < 0.3:
                recommendations.append(
                    "You're managing many hostels; consider delegating to improve efficiency"
                )

        # High efficiency praise
        if float(self.productivity_score) > 80:
            recommendations.append("Excellent productivity! Keep up the good work")

        return recommendations if recommendations else ["Usage patterns are healthy"]

    @model_validator(mode="after")
    def validate_history_consistency(self) -> "ContextHistory":
        """Validate history data consistency."""
        if self.history_end < self.history_start:
            raise ValueError("history_end must be after history_start")

        # Validate switch count matches switches list
        if len(self.switches) != self.total_switches:
            # This might be due to pagination, so log but don't error
            pass

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\hostel_selector.py ---
"""
Enhanced hostel selector UI schemas with comprehensive filtering and organization.

Provides optimized schemas for hostel selection dropdown/sidebar with quick stats,
favorites management, and recent access tracking for improved user experience.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "HostelSelectorResponse",
    "HostelSelectorItem",
    "RecentHostels",
    "RecentHostelItem",
    "FavoriteHostels",
    "FavoriteHostelItem",
    "UpdateFavoriteRequest",
]


class HostelSelectorItem(BaseSchema):
    """
    Enhanced individual hostel item in selector with comprehensive quick view.
    
    Provides essential hostel information with visual indicators,
    quick statistics, and status information for efficient selection.
    """
    
    # Hostel identification
    hostel_id: UUID = Field(..., description="Hostel unique identifier")
    hostel_name: str = Field(..., description="Hostel display name")
    hostel_city: str = Field(..., description="Hostel city location")
    hostel_type: str = Field(..., description="Hostel type (boys/girls/co-ed)")
    hostel_address: Optional[str] = Field(None, description="Short address for display")
    
    # Visual indicators and flags
    is_active: bool = Field(True, description="Currently active hostel in context")
    is_primary: bool = Field(False, description="Primary hostel for this admin")
    is_favorite: bool = Field(False, description="Marked as favorite by admin")
    is_recently_accessed: bool = Field(False, description="Accessed in last 24 hours")
    
    # Quick statistics for decision making
    occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Current occupancy rate"
    )
    total_students: int = Field(0, ge=0, description="Total student count")
    available_beds: int = Field(0, ge=0, description="Available beds count")
    
    # Alert indicators
    pending_bookings: int = Field(0, ge=0, description="Pending booking requests")
    pending_complaints: int = Field(0, ge=0, description="Open complaints")
    urgent_tasks: int = Field(0, ge=0, description="Urgent tasks count")
    
    # Permission summary
    permission_level: str = Field(..., description="Admin permission level for this hostel")
    can_manage: bool = Field(True, description="Has management permissions")
    
    # Activity tracking
    last_accessed: Optional[datetime] = Field(None, description="Last access timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    
    # Display customization
    display_order: int = Field(0, description="Custom display order")
    custom_label: Optional[str] = Field(None, description="Custom label/nickname for hostel")

    @computed_field
    @property
    def requires_attention(self) -> bool:
        """Determine if hostel requires immediate attention."""
        return (
            self.urgent_tasks > 0 or
            self.pending_complaints > 5 or
            self.occupancy_percentage < Decimal("50.00")
        )

    @computed_field
    @property
    def notification_badge_count(self) -> int:
        """Calculate notification badge count for visual indicator."""
        return self.pending_bookings + self.urgent_tasks

    @computed_field
    @property
    def status_indicator_color(self) -> str:
        """Determine status indicator color for UI."""
        if self.urgent_tasks > 0:
            return "red"  # Critical
        elif self.pending_complaints > 5 or self.occupancy_percentage < Decimal("50.00"):
            return "yellow"  # Warning
        else:
            return "green"  # Good

    @computed_field
    @property
    def display_label(self) -> str:
        """Get display label (custom or default)."""
        return self.custom_label if self.custom_label else self.hostel_name

    @computed_field
    @property
    def quick_summary(self) -> str:
        """Generate quick summary text for tooltip."""
        return (
            f"{int(self.occupancy_percentage)}% occupied  "
            f"{self.total_students} students  "
            f"{self.available_beds} beds available"
        )


class HostelSelectorResponse(BaseSchema):
    """
    Enhanced hostel selector dropdown/sidebar response with organized data.
    
    Provides complete hostel list with categorization, recent access,
    favorites, and intelligent sorting for optimal user experience.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID")
    total_hostels: int = Field(..., ge=0, description="Total hostels managed")
    active_hostels: int = Field(..., ge=0, description="Active hostel assignments")
    
    # Active context
    active_hostel_id: Optional[UUID] = Field(None, description="Currently active hostel ID")
    active_hostel_name: Optional[str] = Field(None, description="Currently active hostel name")
    
    # Organized hostel lists
    hostels: List[HostelSelectorItem] = Field(
        default_factory=list,
        description="All hostels with details"
    )
    
    # Quick access lists (IDs for reference)
    recent_hostel_ids: List[UUID] = Field(
        default_factory=list,
        max_length=10,
        description="Recently accessed hostel IDs (max 10)"
    )
    favorite_hostel_ids: List[UUID] = Field(
        default_factory=list,
        description="Favorite hostel IDs"
    )
    primary_hostel_id: Optional[UUID] = Field(None, description="Primary hostel ID")
    
    # Hostel requiring attention
    attention_required_ids: List[UUID] = Field(
        default_factory=list,
        description="Hostels requiring immediate attention"
    )
    
    # Summary statistics
    total_pending_tasks: int = Field(0, ge=0, description="Total pending tasks across all hostels")
    total_urgent_alerts: int = Field(0, ge=0, description="Total urgent alerts")
    avg_occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Average occupancy across hostels"
    )

    @computed_field
    @property
    def has_critical_alerts(self) -> bool:
        """Check if any hostel has critical alerts."""
        return len(self.attention_required_ids) > 0

    @computed_field
    @property
    def hostels_by_category(self) -> dict:
        """Organize hostels by category for UI grouping."""
        return {
            "primary": [h for h in self.hostels if h.is_primary],
            "favorites": [h for h in self.hostels if h.is_favorite],
            "recent": [h for h in self.hostels if h.hostel_id in self.recent_hostel_ids[:5]],
            "attention_required": [h for h in self.hostels if h.requires_attention],
            "others": [
                h for h in self.hostels
                if not (h.is_primary or h.is_favorite or h.hostel_id in self.recent_hostel_ids[:5])
            ]
        }

    @computed_field
    @property
    def selector_summary(self) -> str:
        """Generate summary text for selector header."""
        if self.active_hostel_name:
            return f"Managing {self.total_hostels} hostels  Active: {self.active_hostel_name}"
        else:
            return f"Managing {self.total_hostels} hostels"


class RecentHostelItem(BaseSchema):
    """
    Enhanced recent hostel item with access patterns.
    
    Tracks recent hostel access with frequency and recency metrics
    for intelligent sorting and quick access recommendations.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")
    
    # Access tracking
    last_accessed: datetime = Field(..., description="Last access timestamp")
    access_count: int = Field(..., ge=1, description="Total access count")
    access_count_last_7_days: int = Field(0, ge=0, description="Access count in last 7 days")
    access_count_last_30_days: int = Field(0, ge=0, description="Access count in last 30 days")
    
    # Session metrics
    avg_session_duration_minutes: Decimal = Field(
        Decimal("0.00"), ge=0, description="Average session duration"
    )
    total_session_time_minutes: int = Field(0, ge=0, description="Total session time")
    
    # Quick stats for recent access
    last_occupancy: Decimal = Field(Decimal("0.00"), ge=0, le=100)
    pending_tasks_on_last_visit: int = Field(0, ge=0)

    @computed_field
    @property
    def hours_since_access(self) -> int:
        """Calculate hours since last access."""
        delta = datetime.utcnow() - self.last_accessed
        return int(delta.total_seconds() // 3600)

    @computed_field
    @property
    def access_frequency_score(self) -> Decimal:
        """Calculate access frequency score for ranking."""
        # Recent access gets higher score
        recency_score = max(0, 100 - self.hours_since_access)
        
        # Frequency score based on 7-day access
        frequency_score = min(self.access_count_last_7_days * 10, 100)
        
        # Combined score (60% frequency, 40% recency)
        total_score = (frequency_score * 0.6) + (recency_score * 0.4)
        
        return Decimal(str(total_score)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_frequent(self) -> bool:
        """Determine if this is a frequently accessed hostel."""
        return self.access_count_last_7_days >= 5


class RecentHostels(BaseSchema):
    """
    Enhanced recent hostels list with intelligent sorting.
    
    Provides recently accessed hostels sorted by access patterns
    with analytics for usage optimization recommendations.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID")
    
    hostels: List[RecentHostelItem] = Field(
        default_factory=list,
        max_length=20,
        description="Recently accessed hostels (max 20)"
    )
    
    # Summary metrics
    total_recent_hostels: int = Field(0, ge=0, description="Total recent hostels count")
    most_frequent_hostel_id: Optional[UUID] = Field(None, description="Most frequently accessed hostel")
    
    # Time range for recent access
    tracking_period_days: int = Field(30, ge=1, description="Tracking period in days")

    @computed_field
    @property
    def access_pattern_summary(self) -> str:
        """Generate access pattern summary."""
        if not self.hostels:
            return "No recent access"
        
        frequent_count = sum(1 for h in self.hostels if h.is_frequent)
        
        if frequent_count > 0:
            return f"{frequent_count} frequently accessed  {len(self.hostels)} total recent"
        else:
            return f"{len(self.hostels)} hostels accessed recently"


class FavoriteHostelItem(BaseSchema):
    """
    Enhanced favorite hostel item with customization options.
    
    Supports hostel favorites with custom labels, notes,
    and priority ordering for personalized quick access.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")
    
    # Favorite metadata
    added_to_favorites: datetime = Field(..., description="Timestamp when added to favorites")
    custom_label: Optional[str] = Field(
        None, max_length=100, description="Custom label/nickname for hostel"
    )
    notes: Optional[str] = Field(
        None, max_length=500, description="Personal notes about hostel"
    )
    display_order: int = Field(0, description="Custom display order priority")
    
    # Quick stats
    current_occupancy: Decimal = Field(Decimal("0.00"), ge=0, le=100)
    pending_items: int = Field(0, ge=0, description="Total pending items count")
    
    # Access tracking for favorites
    last_accessed: Optional[datetime] = Field(None, description="Last access timestamp")
    access_count_since_favorited: int = Field(0, ge=0)

    @computed_field
    @property
    def days_in_favorites(self) -> int:
        """Calculate days since added to favorites."""
        delta = datetime.utcnow() - self.added_to_favorites
        return delta.days

    @computed_field
    @property
    def display_name(self) -> str:
        """Get display name (custom label or hostel name)."""
        return self.custom_label if self.custom_label else self.hostel_name

    @computed_field
    @property
    def is_recently_accessed(self) -> bool:
        """Check if accessed in last 24 hours."""
        if not self.last_accessed:
            return False
        hours_since = (datetime.utcnow() - self.last_accessed).total_seconds() / 3600
        return hours_since <= 24


class FavoriteHostels(BaseSchema):
    """
    Enhanced favorites list with organization and management.
    
    Provides organized favorites with custom ordering,
    labels, and quick access to frequently used hostels.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID")
    
    hostels: List[FavoriteHostelItem] = Field(
        default_factory=list,
        description="Favorite hostels sorted by display_order"
    )
    
    total_favorites: int = Field(0, ge=0, description="Total favorite hostels count")
    max_favorites_allowed: int = Field(20, ge=1, description="Maximum favorites allowed")

    @computed_field
    @property
    def can_add_more(self) -> bool:
        """Check if more favorites can be added."""
        return self.total_favorites < self.max_favorites_allowed

    @computed_field
    @property
    def favorites_by_city(self) -> dict:
        """Group favorites by city."""
        grouped = {}
        for hostel in self.hostels:
            city = hostel.hostel_city
            if city not in grouped:
                grouped[city] = []
            grouped[city].append(hostel)
        return grouped


class UpdateFavoriteRequest(BaseCreateSchema):
    """
    Enhanced favorite update request with comprehensive customization.
    
    Supports adding/removing favorites with custom labels,
    notes, and display order preferences.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID to add/remove from favorites")
    is_favorite: bool = Field(..., description="True to add, False to remove")
    
    # Customization options (only used when is_favorite=True)
    custom_label: Optional[str] = Field(
        None,
        max_length=100,
        description="Custom label/nickname for hostel"
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Personal notes about this hostel"
    )
    display_order: Optional[int] = Field(
        None,
        ge=0,
        description="Custom display order (0 = highest priority)"
    )

    @field_validator("custom_label", "notes")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize text fields."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Normalize whitespace
            v = " ".join(v.split())
        return v

    @model_validator(mode="after")
    def validate_customization_logic(self) -> "UpdateFavoriteRequest":
        """Validate that customization is only provided when adding to favorites."""
        if not self.is_favorite:
            # Clear customization fields when removing from favorites
            if any([self.custom_label, self.notes, self.display_order is not None]):
                # Silently ignore customization when removing
                self.custom_label = None
                self.notes = None
                self.display_order = None
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\multi_hostel_dashboard.py ---
# --- File: app/schemas/admin/multi_hostel_dashboard.py ---
"""
Multihostel admin dashboard schemas.

Provides aggregated portfolio statistics, perhostel quick stats,
and crosshostel comparisons for the multihostel admin dashboard.

Key points:
- No assignment CRUD here (that lives in admin_hostel_assignment.py)
- Focused on readonly dashboard views and analytics
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import PermissionLevel

__all__ = [
    "MultiHostelDashboard",
    "AggregatedStats",
    "HostelQuickStats",
    "CrossHostelComparison",
    "TopPerformer",
    "BottomPerformer",
    "HostelMetricComparison",
    "HostelTaskSummary",
]


# ---------------------------------------------------------------------------
# Helpers / constants
# ---------------------------------------------------------------------------

def _normalize_hostel_type(value: str) -> str:
    """Normalize hostel type to canonical values and validate."""
    valid_types = {"boys", "girls", "co-ed", "coed", "mixed"}
    normalized = value.strip().lower()
    if normalized not in valid_types:
        raise ValueError(
            f"Invalid hostel type '{value}'. Must be one of: {', '.join(sorted(valid_types))}"
        )
    # Normalize co-ed variants
    return "co-ed" if normalized in {"coed", "mixed"} else normalized


ATTENTION_LOW_OCCUPANCY = Decimal("50.00")
ATTENTION_PENDING_TASKS = 20
ATTENTION_URGENT_ALERTS = 5


# ---------------------------------------------------------------------------
# Perhostel quick stats
# ---------------------------------------------------------------------------

class HostelQuickStats(BaseSchema):
    """
    Quick statistics for a single hostel in the multihostel dashboard.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type (boys/girls/co-ed)")

    # Assignment / access info for current admin
    is_primary: bool = Field(False, description="Primary hostel for this admin")
    permission_level: PermissionLevel = Field(
        ..., description="Admin permission level for this hostel"
    )
    has_management_access: bool = Field(
        True,
        description="Admin has management-level capabilities for this hostel",
    )

    # Capacity / occupancy
    total_students: int = Field(0, ge=0, description="Total students currently in hostel")
    capacity: int = Field(0, ge=0, description="Total bed capacity")
    occupancy_percentage: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        le=100,
        description="Current occupancy percentage",
    )
    available_beds: int = Field(0, ge=0, description="Available beds count")

    # Operational workload
    pending_tasks: int = Field(0, ge=0, description="Pending tasks")
    urgent_alerts: int = Field(0, ge=0, description="Urgent alerts")
    pending_bookings: int = Field(0, ge=0, description="Pending booking requests")
    open_complaints: int = Field(0, ge=0, description="Open complaints")

    # Financials
    revenue_this_month: Decimal = Field(
        Decimal("0.00"), ge=0, description="Revenue collected this month"
    )
    outstanding_payments: Decimal = Field(
        Decimal("0.00"), ge=0, description="Outstanding (due) amount"
    )

    # Satisfaction / quality signals
    avg_student_rating: Optional[Decimal] = Field(
        None, ge=0, le=5, description="Average student rating for this hostel"
    )
    admin_satisfaction_score: Optional[Decimal] = Field(
        None, ge=0, le=5, description="Internal satisfaction score for this hostel"
    )

    # Activity from this admin
    last_activity: Optional[datetime] = Field(
        None, description="Last time this admin interacted with this hostel"
    )
    access_count: int = Field(0, ge=0, description="Total accesses by this admin")

    @field_validator("hostel_type")
    @classmethod
    def validate_hostel_type(cls, v: str) -> str:
        return _normalize_hostel_type(v)

    @computed_field
    @property
    def financial_risk(self) -> bool:
        """Whether outstanding payments exceed current month revenue."""
        return self.outstanding_payments > self.revenue_this_month

    @computed_field
    @property
    def requires_attention(self) -> bool:
        """
        Whether this hostel should be highlighted as needing attention
        on the multihostel dashboard.
        """
        return (
            self.urgent_alerts > 0
            or self.pending_tasks > ATTENTION_PENDING_TASKS
            or self.open_complaints > 10
            or self.occupancy_percentage < ATTENTION_LOW_OCCUPANCY
            or self.financial_risk
        )

    @computed_field
    @property
    def status_indicator(self) -> str:
        """
        Highlevel status indicator for UI (critical/warning/normal).
        """
        if self.urgent_alerts > ATTENTION_URGENT_ALERTS or self.open_complaints > 20:
            return "critical"
        if (
            self.urgent_alerts > 0
            or self.pending_tasks > ATTENTION_PENDING_TASKS
            or self.open_complaints > 10
            or self.occupancy_percentage < ATTENTION_LOW_OCCUPANCY
        ):
            return "warning"
        return "normal"

    @computed_field
    @property
    def occupancy_status(self) -> str:
        """Humanreadable occupancy status."""
        if self.occupancy_percentage < Decimal("40.00"):
            return "Underutilized"
        elif self.occupancy_percentage < Decimal("90.00"):
            return "Healthy"
        else:
            return "Near Full"

    @computed_field
    @property
    def hours_since_last_activity(self) -> Optional[int]:
        """Hours since this admin last interacted with this hostel."""
        if not self.last_activity:
            return None
        delta = datetime.utcnow() - self.last_activity
        return int(delta.total_seconds() // 3600)


# ---------------------------------------------------------------------------
# Aggregated / portfolio stats
# ---------------------------------------------------------------------------

class AggregatedStats(BaseSchema):
    """
    Aggregated statistics across all hostels managed by the admin.
    """

    admin_id: UUID = Field(..., description="Admin user ID")

    total_hostels: int = Field(..., ge=0, description="Total hostels assigned")
    active_hostels: int = Field(..., ge=0, description="Hostels with active assignments")

    total_students: int = Field(0, ge=0, description="Total students across hostels")
    active_students: int = Field(0, ge=0, description="Active/checkedin students")
    total_capacity: int = Field(0, ge=0, description="Total bed capacity")

    avg_occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Average occupancy across hostels"
    )

    total_pending_tasks: int = Field(0, ge=0, description="Total pending tasks")
    total_urgent_alerts: int = Field(0, ge=0, description="Total urgent alerts")
    total_open_complaints: int = Field(0, ge=0, description="Total open complaints")

    total_revenue_this_month: Decimal = Field(
        Decimal("0.00"), ge=0, description="Total revenue this month"
    )
    total_outstanding_payments: Decimal = Field(
        Decimal("0.00"), ge=0, description="Total outstanding payments"
    )

    avg_student_rating: Optional[Decimal] = Field(
        None, ge=0, le=5, description="Average student rating across hostels"
    )
    avg_admin_satisfaction_score: Optional[Decimal] = Field(
        None, ge=0, le=5, description="Average internal satisfaction score"
    )

    @computed_field
    @property
    def hostel_utilization_rate(self) -> Decimal:
        """Percentage of hostels that are actively managed."""
        if self.total_hostels == 0:
            return Decimal("0.00")
        rate = Decimal(self.active_hostels) / Decimal(self.total_hostels) * 100
        return rate.quantize(Decimal("0.01"))

    @computed_field
    @property
    def student_occupancy_rate(self) -> Decimal:
        """Overall bed occupancy rate across the portfolio."""
        if self.total_capacity == 0:
            return Decimal("0.00")
        rate = Decimal(self.active_students) / Decimal(self.total_capacity) * 100
        return rate.quantize(Decimal("0.01"))

    @computed_field
    @property
    def has_critical_issues(self) -> bool:
        """Whether the portfolio has clearly critical issues."""
        return (
            self.total_urgent_alerts > 0
            or self.total_open_complaints > 20
            or self.total_pending_tasks > 100
        )

    @computed_field
    @property
    def financial_health_indicator(self) -> str:
        """Basic financial health indicator."""
        if self.total_revenue_this_month == 0 and self.total_outstanding_payments == 0:
            return "neutral"
        if self.total_outstanding_payments > self.total_revenue_this_month:
            return "at_risk"
        if self.total_outstanding_payments > self.total_revenue_this_month * Decimal("0.5"):
            return "watch"
        return "healthy"

    @model_validator(mode="after")
    def validate_consistency(self) -> "AggregatedStats":
        """Basic consistency checks on aggregated counts."""
        if self.active_hostels > self.total_hostels:
            raise ValueError("active_hostels cannot exceed total_hostels")
        if self.active_students > self.total_students:
            raise ValueError("active_students cannot exceed total_students")
        if self.total_students > self.total_capacity and self.total_capacity > 0:
            # Allow, but this is suspicious; don't raise to avoid breaking clients.
            pass
        return self


# ---------------------------------------------------------------------------
# Task summary
# ---------------------------------------------------------------------------

class HostelTaskSummary(BaseSchema):
    """
    Portfoliowide task summary for the dashboard.
    """

    total_tasks: int = Field(0, ge=0, description="Total tasks in the selected period")
    pending_tasks: int = Field(0, ge=0, description="Currently pending tasks")
    overdue_tasks: int = Field(0, ge=0, description="Overdue tasks")
    urgent_tasks: int = Field(0, ge=0, description="Urgent tasks")
    completed_today: int = Field(0, ge=0, description="Tasks completed today")

    # Optional breakdown by hostel
    tasks_by_hostel: Dict[UUID, int] = Field(
        default_factory=dict, description="Total tasks per hostel (optional)"
    )

    @computed_field
    @property
    def pending_ratio(self) -> Decimal:
        """Percentage of tasks that are pending."""
        if self.total_tasks == 0:
            return Decimal("0.00")
        ratio = Decimal(self.pending_tasks) / Decimal(self.total_tasks) * 100
        return ratio.quantize(Decimal("0.01"))

    @computed_field
    @property
    def overdue_ratio(self) -> Decimal:
        """Percentage of tasks that are overdue."""
        if self.total_tasks == 0:
            return Decimal("0.00")
        ratio = Decimal(self.overdue_tasks) / Decimal(self.total_tasks) * 100
        return ratio.quantize(Decimal("0.01"))

    @computed_field
    @property
    def health_status(self) -> str:
        """Highlevel health indicator based on task backlog."""
        if self.urgent_tasks == 0 and self.overdue_tasks == 0:
            return "good"
        if self.urgent_tasks > 20 or self.overdue_ratio > Decimal("25.00"):
            return "critical"
        if self.urgent_tasks > 0 or self.overdue_ratio > Decimal("10.00"):
            return "attention"
        return "good"

    @model_validator(mode="after")
    def validate_counts(self) -> "HostelTaskSummary":
        """Ensure basic numeric consistency."""
        if self.pending_tasks > self.total_tasks:
            raise ValueError("pending_tasks cannot exceed total_tasks")
        if self.overdue_tasks > self.total_tasks:
            raise ValueError("overdue_tasks cannot exceed total_tasks")
        return self


# ---------------------------------------------------------------------------
# Top / bottom performers
# ---------------------------------------------------------------------------

class TopPerformer(BaseSchema):
    """
    Top performing hostel in a given dimension.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")

    performance_score: Decimal = Field(
        ..., ge=0, le=100, description="Composite performance score (0100)"
    )
    rank: int = Field(..., ge=1, description="Rank among hostels")
    key_metric: str = Field(..., min_length=1, description="Primary metric driving this ranking")
    key_metric_value: Optional[Decimal] = Field(
        None, description="Value of the primary metric (e.g. occupancy %)"
    )

    @field_validator("hostel_type")
    @classmethod
    def validate_hostel_type(cls, v: str) -> str:
        return _normalize_hostel_type(v)

    @computed_field
    @property
    def label(self) -> str:
        """Convenient display label."""
        return f"#{self.rank} {self.hostel_name}"


class BottomPerformer(BaseSchema):
    """
    Bottom performing hostel in a given dimension.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., min_length=1, description="Hostel name")
    hostel_city: str = Field(..., min_length=1, description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")

    performance_score: Decimal = Field(
        ..., ge=0, le=100, description="Composite performance score (0100)"
    )
    rank: int = Field(..., ge=1, description="Rank among hostels (1 = worst)")
    key_metric: str = Field(..., min_length=1, description="Primary metric driving this ranking")
    key_metric_value: Optional[Decimal] = Field(
        None, description="Value of the primary metric (e.g. complaints count)"
    )

    @field_validator("hostel_type")
    @classmethod
    def validate_hostel_type(cls, v: str) -> str:
        return _normalize_hostel_type(v)

    @computed_field
    @property
    def label(self) -> str:
        """Convenient display label."""
        return f"#{self.rank} {self.hostel_name}"


# ---------------------------------------------------------------------------
# Metric comparison
# ---------------------------------------------------------------------------

class HostelMetricComparison(BaseSchema):
    """
    Comparison of a single metric across hostels (best/worst vs portfolio average).
    """

    metric_name: str = Field(..., min_length=1, description="Metric name (e.g. occupancy)")
    unit: str = Field(..., min_length=1, description="Display unit (%, count, currency, etc.)")

    portfolio_average: Decimal = Field(
        Decimal("0.00"), description="Portfoliowide average for this metric"
    )

    best_hostel_id: Optional[UUID] = Field(None, description="Best performing hostel ID")
    best_hostel_name: Optional[str] = Field(None, description="Best performing hostel name")
    best_value: Optional[Decimal] = Field(
        None, description="Best value for the metric (direction depends on metric)"
    )

    worst_hostel_id: Optional[UUID] = Field(None, description="Worst performing hostel ID")
    worst_hostel_name: Optional[str] = Field(None, description="Worst performing hostel name")
    worst_value: Optional[Decimal] = Field(
        None, description="Worst value for the metric (direction depends on metric)"
    )

    @computed_field
    @property
    def spread(self) -> Decimal:
        """Absolute spread between best and worst values."""
        if self.best_value is None or self.worst_value is None:
            return Decimal("0.00")
        diff = abs(Decimal(self.best_value) - Decimal(self.worst_value))
        return diff.quantize(Decimal("0.01"))

    @computed_field
    @property
    def variation_index(self) -> Decimal:
        """
        Relative variation vs portfolio average (percentage).
        Higher = more variation between hostels for this metric.
        """
        if self.portfolio_average == 0 or self.spread == 0:
            return Decimal("0.00")
        ratio = self.spread / abs(self.portfolio_average) * 100
        return ratio.quantize(Decimal("0.01"))


# ---------------------------------------------------------------------------
# Crosshostel comparison wrapper
# ---------------------------------------------------------------------------

class CrossHostelComparison(BaseSchema):
    """
    Crosshostel comparison section for the dashboard, containing
    metric comparisons and top/bottom performers.
    """

    metrics: List[HostelMetricComparison] = Field(
        default_factory=list, description="Permetric comparisons"
    )
    top_performers: List[TopPerformer] = Field(
        default_factory=list, description="Top performing hostels"
    )
    bottom_performers: List[BottomPerformer] = Field(
        default_factory=list, description="Bottom performing hostels"
    )

    @computed_field
    @property
    def has_significant_variation(self) -> bool:
        """
        Whether any metric shows large variation across hostels.
        """
        return any(m.variation_index > Decimal("20.00") for m in self.metrics)

    @computed_field
    @property
    def metrics_by_name(self) -> Dict[str, HostelMetricComparison]:
        """Index metrics by name for quicker lookup in clients."""
        return {m.metric_name: m for m in self.metrics}


# ---------------------------------------------------------------------------
# Root multihostel dashboard schema
# ---------------------------------------------------------------------------

class MultiHostelDashboard(BaseResponseSchema):
    """
    Root schema for the multihostel admin dashboard response.
    """

    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., min_length=1, description="Admin full name")

    generated_at: datetime = Field(
        default_factory=datetime.utcnow, description="Timestamp when dashboard was generated"
    )

    period_start: date = Field(..., description="Start of reporting period")
    period_end: date = Field(..., description="End of reporting period (inclusive)")

    # Portfoliolevel aggregates
    aggregated_stats: AggregatedStats = Field(
        ..., description="Aggregated statistics across all hostels"
    )

    # Perhostel quick stats
    hostels: List[HostelQuickStats] = Field(
        default_factory=list, description="Quick stats for each hostel"
    )

    # Tasks / workload
    task_summary: HostelTaskSummary = Field(
        ..., description="Portfoliowide task summary"
    )

    # Comparisons / rankings
    cross_hostel_comparison: Optional[CrossHostelComparison] = Field(
        None, description="Crosshostel comparisons and rankings"
    )

    # UI helpers
    active_hostel_id: Optional[UUID] = Field(
        None, description="Hostel currently focused in UI (optional)"
    )

    @computed_field
    @property
    def period_days(self) -> int:
        """Length of the reporting period in days (at least 1)."""
        days = (self.period_end - self.period_start).days + 1
        return max(1, days)

    @computed_field
    @property
    def hostels_requiring_attention(self) -> List[UUID]:
        """IDs of hostels that require attention."""
        return [h.hostel_id for h in self.hostels if h.requires_attention]

    @computed_field
    @property
    def total_critical_hostels(self) -> int:
        """Number of hostels in warning/critical state."""
        return len(self.hostels_requiring_attention)

    @computed_field
    @property
    def overall_attention_level(self) -> str:
        """
        Overall portfolio attention level based on how many hostels
        are in a concerning state.
        """
        n = self.total_critical_hostels
        if n == 0:
            return "low"
        if n <= 2:
            return "medium"
        if n <= 5:
            return "high"
        return "critical"

    @model_validator(mode="after")
    def validate_period(self) -> "MultiHostelDashboard":
        """Validate reporting period and basic consistency."""
        if self.period_end < self.period_start:
            raise ValueError("period_end must be on or after period_start")

        # Optional soft check: aggregated_stats.total_hostels vs hostels list
        if self.aggregated_stats.total_hostels and self.hostels:
            # Don't hardfail, but this is a useful invariant to watch.
            if self.aggregated_stats.total_hostels < len(self.hostels):
                # Could log a warning in application code.
                pass

        if self.aggregated_stats.admin_id != self.admin_id:
            # Ensure we didn't accidentally mix data for different admins
            raise ValueError("aggregated_stats.admin_id must match admin_id")

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\__init__.py ---
from __future__ import annotations

from app.schemas.admin.admin_hostel_assignment import (
    AdminHostelAssignment,
    AssignmentCreate,
    AssignmentList,
    AssignmentUpdate,
    BulkAssignment,
    HostelAdminItem,
    HostelAdminList,
    RevokeAssignment,
)
from app.schemas.admin.admin_override import (
    AdminOverrideRequest,
    OverrideLog,
    OverrideReason,
    OverrideSummary,
    SupervisorOverrideStats,
)
from app.schemas.admin.admin_permissions import (
    AdminPermissions,
    PermissionCheck,
    PermissionMatrix,
    RolePermissions,
)
from app.schemas.admin.hostel_context import (
    ActiveHostelResponse,
    ContextHistory,
    ContextSwitch,
    HostelContext,
    HostelSwitchRequest,
)
from app.schemas.admin.hostel_selector import (
    FavoriteHostelItem,
    FavoriteHostels,
    HostelSelectorItem,
    HostelSelectorResponse,
    RecentHostelItem,
    RecentHostels,
    UpdateFavoriteRequest,
)
from app.schemas.admin.multi_hostel_dashboard import (
    AggregatedStats,
    BottomPerformer,
    CrossHostelComparison,
    HostelMetricComparison,
    HostelQuickStats,
    HostelTaskSummary,
    MultiHostelDashboard,
    TopPerformer,
)

__all__ = [
    # Hostel Assignment Management
    "AdminHostelAssignment",
    "AssignmentCreate",
    "AssignmentUpdate",
    "BulkAssignment",
    "RevokeAssignment",
    "AssignmentList",
    "HostelAdminList",
    "HostelAdminItem",
    
    # Hostel Context Management
    "HostelContext",
    "HostelSwitchRequest",
    "ActiveHostelResponse",
    "ContextHistory",
    "ContextSwitch",
    
    # Hostel Selector UI
    "HostelSelectorResponse",
    "HostelSelectorItem",
    "RecentHostels",
    "RecentHostelItem",
    "FavoriteHostels",
    "FavoriteHostelItem",
    "UpdateFavoriteRequest",
    
    # Multi-Hostel Dashboard
    "MultiHostelDashboard",
    "AggregatedStats",
    "HostelQuickStats",
    "CrossHostelComparison",
    "TopPerformer",
    "BottomPerformer",
    "HostelMetricComparison",
    "HostelTaskSummary",
    
    # Admin Override System
    "AdminOverrideRequest",
    "OverrideLog",
    "OverrideReason",
    "OverrideSummary",
    "SupervisorOverrideStats",
    
    # Admin Permissions
    "AdminPermissions",
    "PermissionMatrix",
    "RolePermissions",
    "PermissionCheck",
]


# Package metadata
__author__ = "Hostel Management System Team"
__description__ = "Admin management schemas for multi-hostel operations"


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\all_folders_files_content.txt ---
### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\analytics ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\analytics =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\analytics\booking_analytics.py ---
"""
Booking analytics schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import List, Dict, Optional

from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import BookingStatus, BookingSource
from app.schemas.common.filters import DateRangeFilter


class BookingKPI(BaseSchema):
    """Key metrics for bookings"""
    hostel_id: Optional[UUID] = None
    hostel_name: Optional[str] = None

    total_bookings: int
    confirmed_bookings: int
    cancelled_bookings: int
    rejected_bookings: int

    booking_conversion_rate: Decimal
    cancellation_rate: Decimal
    average_lead_time_days: Decimal  # between booking and check-in


class BookingTrendPoint(BaseSchema):
    """Booking trend point"""
    date: date
    total_bookings: int
    confirmed: int
    cancelled: int
    rejected: int
    revenue_for_day: Decimal


class BookingFunnel(BaseSchema):
    """Booking funnel analytics"""
    period: DateRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    # Steps in funnel
    hostel_page_views: int
    booking_form_starts: int
    booking_submissions: int
    bookings_confirmed: int

    # Conversion
    view_to_start_rate: Decimal
    start_to_submit_rate: Decimal
    submit_to_confirm_rate: Decimal
    view_to_confirm_rate: Decimal


class CancellationAnalytics(BaseSchema):
    """Analytics around cancellations"""
    period: DateRangeFilter
    total_cancellations: int
    cancellation_rate: Decimal

    cancellations_by_reason: Dict[str, int] = Field(default_factory=dict)
    cancellations_by_status: Dict[BookingStatus, int] = Field(default_factory=dict)

    # Timing
    average_time_before_check_in_cancelled_days: Decimal


class BookingAnalyticsSummary(BaseSchema):
    """Top-level booking analytics"""
    hostel_id: Optional[UUID] = None
    hostel_name: Optional[str] = None

    period: DateRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    kpi: BookingKPI
    trend: List[BookingTrendPoint] = Field(default_factory=list)

    funnel: BookingFunnel
    cancellations: CancellationAnalytics

    # By source
    bookings_by_source: Dict[BookingSource, int] = Field(default_factory=dict)
    conversion_rate_by_source: Dict[BookingSource, Decimal] = Field(default_factory=dict)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\analytics\complaint_analytics.py ---
"""
High-level complaint analytics schemas (dashboard aggregation)
"""
from datetime import date, datetime
from decimal import Decimal
from typing import List, Dict, Optional

from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter


class ComplaintKPI(BaseSchema):
    """Complaint key performance indicators"""
    hostel_id: Optional[UUID] = None
    hostel_name: Optional[str] = None

    total_complaints: int
    open_complaints: int
    resolved_complaints: int
    closed_complaints: int

    average_resolution_time_hours: Decimal
    sla_compliance_rate: Decimal
    escalation_rate: Decimal
    reopen_rate: Decimal


class ComplaintTrend(BaseSchema):
    """Trend over time for complaints"""
    period: DateRangeFilter
    points: List["ComplaintTrendPoint"] = Field(default_factory=list)


class ComplaintTrendPoint(BaseSchema):
    """Complaint trend point"""
    date: date
    total_complaints: int
    open_complaints: int
    resolved_complaints: int
    escalated: int
    sla_breached: int


class CategoryBreakdown(BaseSchema):
    """Complaints by category"""
    category: str
    count: int
    percentage_of_total: Decimal
    average_resolution_time_hours: Decimal


class ComplaintDashboard(BaseSchema):
    """Complaint dashboard analytics"""
    hostel_id: Optional[UUID] = None
    hostel_name: Optional[str] = None

    period: DateRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    kpi: ComplaintKPI
    trend: ComplaintTrend
    by_category: List[CategoryBreakdown] = Field(default_factory=list)
    by_priority: Dict[str, int] = Field(default_factory=dict)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\analytics\custom_reports.py ---
"""
Custom report builder schemas
"""
from datetime import datetime
from typing import Dict, List, Optional, Any
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema
from app.schemas.common.filters import DateRangeFilter


class CustomReportFilter(BaseSchema):
    """Filter definition for custom report"""
    field_name: str
    operator: str = Field(
        ..., description="eq, ne, gt, lt, gte, lte, in, contains, between, etc."
    )
    value: Any
    value_to: Optional[Any] = Field(None, description="Second value for between, range")


class CustomReportField(BaseSchema):
    """Field included in custom report"""
    field_name: str
    display_label: Optional[str] = None
    aggregation: Optional[str] = Field(
        None, description="sum, avg, min, max, count, none"
    )


class CustomReportRequest(BaseCreateSchema):
    """Generate a custom report"""
    report_name: str = Field(..., min_length=3, max_length=255)
    module: str = Field(
        ...,
        description="Which module: bookings, payments, complaints, attendance, etc.",
    )

    period: Optional[DateRangeFilter] = None

    # Fields
    fields: List[CustomReportField] = Field(..., min_items=1)

    # Filters
    filters: List[CustomReportFilter] = Field(default_factory=list)

    # Grouping
    group_by: Optional[List[str]] = Field(
        None, description="List of field names to group by"
    )

    # Sorting
    sort_by: Optional[str] = None
    sort_order: Optional[str] = Field("asc", pattern="^(asc|desc)$")

    # Output
    format: str = Field("table", pattern="^(table|csv|excel|json)$")
    include_summary: bool = Field(True)
    include_charts: bool = Field(False)


class CustomReportDefinition(BaseSchema):
    """Saved custom report definition"""
    id: UUID
    owner_id: UUID
    report_name: str
    module: str

    period: Optional[DateRangeFilter] = None
    fields: List[CustomReportField]
    filters: List[CustomReportFilter]
    group_by: Optional[List[str]] = None

    # Sharing
    is_public: bool = Field(False)
    shared_with_user_ids: List[UUID] = Field(default_factory=list)

    created_at: datetime
    updated_at: datetime


class CustomReportResult(BaseSchema):
    """Result of running custom report"""
    report_id: Optional[UUID] = None
    report_name: str

    generated_at: datetime = Field(default_factory=datetime.utcnow)

    # Data
    rows: List[Dict[str, Any]] = Field(default_factory=list)
    total_rows: int

    # Summary (aggregations)
    summary: Optional[Dict[str, Any]] = None

    # Charts data (if requested)
    charts: Optional[Dict[str, Any]] = None

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\analytics\dashboard_analytics.py ---
"""
Dashboard-level analytics schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional, Dict

from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter


class KPIResponse(BaseSchema):
    """Single KPI item for dashboard"""
    name: str = Field(..., description="KPI name, e.g., 'Total Revenue'")
    value: Decimal | int | float = Field(..., description="KPI numeric value")
    unit: Optional[str] = Field(None, description="Unit, e.g., 'INR', '%', 'students'")
    trend_direction: Optional[str] = Field(
        None,
        pattern="^(up|down|stable)$",
        description="Trend indicator vs previous period",
    )
    trend_percentage: Optional[Decimal] = Field(
        None, description="Change vs previous period in %"
    )
    target_value: Optional[Decimal] = Field(None, description="Target/goal value")
    good_when: Optional[str] = Field(
        None,
        description="Interpretation rule, e.g. 'higher_is_better', 'lower_is_better'",
    )


class QuickStats(BaseSchema):
    """Quick statistics for main dashboard cards"""
    total_hostels: int
    active_hostels: int
    total_students: int
    active_students: int
    total_visitors: int

    todays_check_ins: int
    todays_check_outs: int

    open_complaints: int
    pending_maintenance: int

    todays_revenue: Decimal
    monthly_revenue: Decimal
    outstanding_payments: Decimal


class DashboardMetrics(BaseSchema):
    """Aggregated dashboard metrics for a given scope (hostel or platform)"""
    scope_type: str = Field(..., pattern="^(hostel|platform|admin)$")
    scope_id: Optional[UUID] = Field(
        None, description="Hostel ID or admin ID if scope_type is not 'platform'"
    )

    period: DateRangeFilter = Field(..., description="Analysis period")
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    # KPIs
    kpis: List[KPIResponse] = Field(default_factory=list)

    # Quick stats
    quick_stats: QuickStats

    # Time series for charts
    revenue_timeseries: List["TimeseriesPoint"] = Field(default_factory=list)
    occupancy_timeseries: List["TimeseriesPoint"] = Field(default_factory=list)
    booking_timeseries: List["TimeseriesPoint"] = Field(default_factory=list)
    complaint_timeseries: List["TimeseriesPoint"] = Field(default_factory=list)


class TimeseriesPoint(BaseSchema):
    """Generic timeseries data point"""
    date: date
    value: Decimal | int | float


class RoleSpecificDashboard(BaseSchema):
    """Dashboard sections per role"""
    role: str = Field(..., pattern="^(super_admin|hostel_admin|supervisor)$")
    cards: Dict[str, QuickStats] = Field(
        default_factory=dict, description="Section name -> QuickStats"
    )
    kpis: Dict[str, List[KPIResponse]] = Field(
        default_factory=dict, description="Section name -> list of KPIs"
    )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\analytics\financial_analytics.py ---
"""
Financial analytics schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import List, Dict, Optional

from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter


class RevenueBreakdown(BaseSchema):
    """Revenue breakdown by type/category"""
    total_revenue: Decimal
    booking_revenue: Decimal
    rent_revenue: Decimal
    mess_revenue: Decimal
    other_revenue: Decimal

    revenue_by_hostel: Dict[UUID, Decimal] = Field(
        default_factory=dict, description="Hostel ID -> revenue"
    )
    revenue_by_payment_type: Dict[str, Decimal] = Field(
        default_factory=dict, description="PaymentType -> revenue"
    )


class ExpenseBreakdown(BaseSchema):
    """Expense breakdown by category"""
    total_expenses: Decimal
    maintenance_expenses: Decimal
    staff_expenses: Decimal
    utility_expenses: Decimal
    other_expenses: Decimal

    expenses_by_hostel: Dict[UUID, Decimal] = Field(
        default_factory=dict, description="Hostel ID -> expenses"
    )
    expenses_by_category: Dict[str, Decimal] = Field(
        default_factory=dict, description="Category -> expenses"
    )


class ProfitAndLossReport(BaseSchema):
    """P&L report for a hostel or platform"""
    scope_type: str = Field(..., pattern="^(hostel|platform)$")
    scope_id: Optional[UUID] = None

    period: DateRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    # Revenue & expense
    revenue: RevenueBreakdown
    expenses: ExpenseBreakdown

    # Calculated
    gross_profit: Decimal
    net_profit: Decimal
    profit_margin_percentage: Decimal


class CashflowSummary(BaseSchema):
    """Cashflow summary"""
    scope_type: str = Field(..., pattern="^(hostel|platform)$")
    scope_id: Optional[UUID] = None

    period: DateRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    opening_balance: Decimal
    closing_balance: Decimal

    inflows: Decimal
    outflows: Decimal

    inflow_breakdown: Dict[str, Decimal] = Field(default_factory=dict)
    outflow_breakdown: Dict[str, Decimal] = Field(default_factory=dict)

    cashflow_timeseries: List["CashflowPoint"] = Field(default_factory=list)


class CashflowPoint(BaseSchema):
    """Cashflow timeseries point"""
    date: date
    inflow: Decimal
    outflow: Decimal
    net_flow: Decimal


class FinancialReport(BaseSchema):
    """Top-level financial analytics response"""
    scope_type: str
    scope_id: Optional[UUID] = None

    period: DateRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    pnl_report: ProfitAndLossReport
    cashflow: CashflowSummary

    # Ratios
    collection_rate: Decimal = Field(..., description="% of billed amount collected")
    overdue_ratio: Decimal = Field(..., description="% of amount that is overdue")
    avg_revenue_per_student: Decimal
    avg_revenue_per_bed: Decimal

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\analytics\occupancy_analytics.py ---
"""
Occupancy analytics schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import List, Dict, Optional

from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter


class OccupancyKPI(BaseSchema):
    """Key occupancy metrics"""
    hostel_id: Optional[UUID] = None
    hostel_name: Optional[str] = None

    current_occupancy_percentage: Decimal
    average_occupancy_percentage: Decimal
    peak_occupancy_percentage: Decimal
    low_occupancy_percentage: Decimal

    total_beds: int
    occupied_beds: int
    available_beds: int


class OccupancyTrendPoint(BaseSchema):
    """Occupancy over time point"""
    date: date
    occupancy_percentage: Decimal
    occupied_beds: int
    total_beds: int


class ForecastData(BaseSchema):
    """Occupancy forecast data"""
    forecast_horizon_days: int
    forecast_points: List["ForecastPoint"] = Field(default_factory=list)
    model_used: Optional[str] = Field(
        None, description="e.g., 'moving_average', 'arima', 'simple_extrapolation'"
    )
    confidence_interval: Optional[Decimal] = Field(
        None, description="Confidence interval for forecast in %"
    )


class ForecastPoint(BaseSchema):
    """Single forecast point"""
    date: date
    forecasted_occupancy_percentage: Decimal
    forecasted_occupied_beds: int


class OccupancyByRoomType(BaseSchema):
    """Occupancy distribution by room type"""
    room_type: str
    total_beds: int
    occupied_beds: int
    occupancy_percentage: Decimal


class OccupancyReport(BaseSchema):
    """Complete occupancy analytics"""
    hostel_id: Optional[UUID] = None
    hostel_name: Optional[str] = None

    period: DateRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    kpi: OccupancyKPI

    # Trends
    daily_trend: List[OccupancyTrendPoint] = Field(default_factory=list)

    # Breakdown
    by_room_type: List[OccupancyByRoomType] = Field(default_factory=list)
    by_floor: Dict[int, OccupancyKPI] = Field(default_factory=dict)

    # Forecast
    forecast: Optional[ForecastData] = None

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\analytics\platform_analytics.py ---
"""
Platform-wide analytics (super admin)
"""
from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List

from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter


class PlatformMetrics(BaseSchema):
    """High-level platform metrics"""
    period: DateRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    # Tenants
    total_hostels: int
    active_hostels: int
    hostels_on_trial: int

    # Users
    total_users: int
    total_students: int
    total_supervisors: int
    total_admins: int
    total_visitors: int

    # Load
    avg_daily_active_users: int
    peak_concurrent_sessions: int


class GrowthMetrics(BaseSchema):
    """Growth metrics over time"""
    period: DateRangeFilter

    # Hostels
    new_hostels: int
    churned_hostels: int
    net_hostel_growth: int

    # Revenue
    total_revenue: Decimal
    revenue_growth_rate: Decimal

    # Users
    new_users: int
    user_growth_rate: Decimal

    # Charts
    monthly_revenue: List["MonthlyMetric"] = Field(default_factory=list)
    monthly_new_hostels: List["MonthlyMetric"] = Field(default_factory=list)
    monthly_new_users: List["MonthlyMetric"] = Field(default_factory=list)


class MonthlyMetric(BaseSchema):
    """Monthly metric point"""
    month: str  # YYYY-MM
    value: Decimal | int | float


class PlatformUsageAnalytics(BaseSchema):
    """Platform usage analytics"""
    period: DateRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    # Traffic
    total_requests: int
    avg_requests_per_minute: Decimal
    api_error_rate: Decimal

    # By endpoint group
    requests_by_module: Dict[str, int] = Field(
        default_factory=dict, description="module -> request count"
    )

    # Latency
    avg_response_time_ms: Decimal
    p95_response_time_ms: Decimal
    p99_response_time_ms: Decimal

    # Resource usage (if tracked)
    avg_cpu_usage_percent: Optional[Decimal] = None
    avg_memory_usage_percent: Optional[Decimal] = None

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\analytics\supervisor_analytics.py ---
"""
Supervisor analytics schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter


class SupervisorKPI(BaseSchema):
    """Supervisor KPI metrics (aggregated)"""
    supervisor_id: UUID
    supervisor_name: str
    hostel_id: UUID
    hostel_name: str

    period: DateRangeFilter

    # Workload
    complaints_assigned: int
    complaints_resolved: int
    maintenance_requests_created: int
    maintenance_requests_completed: int
    attendance_records_marked: int

    # Performance
    avg_complaint_resolution_time_hours: Decimal
    avg_maintenance_completion_time_hours: Decimal
    complaint_sla_compliance_rate: Decimal
    maintenance_sla_compliance_rate: Decimal

    student_feedback_score: Optional[Decimal] = Field(
        None, description="Average rating from student feedback"
    )

    overall_performance_score: Decimal = Field(
        ..., ge=0, le=100, description="Composite performance score"
    )


class SupervisorTrendPoint(BaseSchema):
    """Trend point for supervisor performance"""
    period_label: str
    complaints_resolved: int
    maintenance_completed: int
    performance_score: Decimal


class SupervisorDashboardAnalytics(BaseSchema):
    """Supervisor dashboard analytics"""
    supervisor_id: UUID
    supervisor_name: str
    hostel_id: UUID
    hostel_name: str

    period: DateRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    kpi: SupervisorKPI
    trend: List[SupervisorTrendPoint] = Field(default_factory=list)

    # Breakdown
    complaints_by_category: Dict[str, int] = Field(default_factory=dict)
    maintenance_by_category: Dict[str, int] = Field(default_factory=dict)


class SupervisorComparison(BaseSchema):
    """Compare supervisors within hostel or platform"""
    scope_type: str = Field(..., pattern="^(hostel|platform)$")
    hostel_id: Optional[UUID] = None

    period: DateRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    supervisors: List[SupervisorKPI] = Field(default_factory=list)

    # Rankings
    ranked_by_performance: List[UUID] = Field(default_factory=list)
    ranked_by_resolution_speed: List[UUID] = Field(default_factory=list)
    ranked_by_feedback_score: List[UUID] = Field(default_factory=list)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\analytics\visitor_analytics.py ---
"""
Visitor & funnel analytics schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import SearchSource
from app.schemas.common.filters import DateRangeFilter


class VisitorFunnel(BaseSchema):
    """Visitor funnel from views  registration  booking"""
    period: DateRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    # Counts
    total_visits: int
    unique_visitors: int
    registrations: int
    bookings: int

    # Conversion rates
    visit_to_registration_rate: Decimal
    registration_to_booking_rate: Decimal
    visit_to_booking_rate: Decimal

    # Drop-off points
    dropped_after_search: int
    dropped_after_hostel_view: int
    dropped_after_booking_start: int


class TrafficSourceAnalytics(BaseSchema):
    """Traffic sources for visitor acquisition"""
    period: DateRangeFilter
    total_visits: int

    visits_by_source: Dict[SearchSource, int] = Field(default_factory=dict)
    registrations_by_source: Dict[SearchSource, int] = Field(default_factory=dict)
    bookings_by_source: Dict[SearchSource, int] = Field(default_factory=dict)

    # Conversion by source
    visit_to_booking_rate_by_source: Dict[SearchSource, Decimal] = Field(
        default_factory=dict
    )


class VisitorBehaviorAnalytics(BaseSchema):
    """Behavior analytics for visitors"""
    period: DateRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)

    # Search behavior
    average_searches_per_session: Decimal
    average_filters_used: Decimal
    most_searched_cities: List[str] = Field(default_factory=list)
    most_filtered_amenities: List[str] = Field(default_factory=list)

    # Engagement
    average_hostels_viewed_per_session: Decimal
    average_time_on_hostel_page_seconds: Decimal
    comparison_tool_usage_rate: Decimal

    # Exit pages
    common_exit_reasons: List[str] = Field(default_factory=list)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\analytics\__init__.py ---
"""
Analytics schemas package
"""

from app.schemas.analytics.dashboard_analytics import (
    DashboardMetrics,
    KPIResponse,
    QuickStats,
)
from app.schemas.analytics.financial_analytics import (
    FinancialReport,
    RevenueBreakdown,
    ExpenseBreakdown,
    ProfitAndLossReport,
    CashflowSummary,
)
from app.schemas.analytics.occupancy_analytics import (
    OccupancyReport,
    OccupancyKPI,
    OccupancyTrendPoint,
    ForecastData,
)
from app.schemas.analytics.complaint_analytics import (
    ComplaintKPI,
    ComplaintDashboard,
    ComplaintTrend,
)
from app.schemas.analytics.visitor_analytics import (
    VisitorFunnel,
    TrafficSourceAnalytics,
    VisitorBehaviorAnalytics,
)
from app.schemas.analytics.booking_analytics import (
    BookingFunnel,
    BookingKPI,
    BookingTrendPoint,
    CancellationAnalytics,
)
from app.schemas.analytics.supervisor_analytics import (
    SupervisorKPI,
    SupervisorDashboardAnalytics,
    SupervisorComparison,
)
from app.schemas.analytics.platform_analytics import (
    PlatformMetrics,
    GrowthMetrics,
    PlatformUsageAnalytics,
)
from app.schemas.analytics.custom_reports import (
    CustomReportRequest,
    CustomReportDefinition,
    CustomReportResult,
)

__all__ = [
    # Dashboard
    "DashboardMetrics",
    "KPIResponse",
    "QuickStats",
    # Financial
    "FinancialReport",
    "RevenueBreakdown",
    "ExpenseBreakdown",
    "ProfitAndLossReport",
    "CashflowSummary",
    # Occupancy
    "OccupancyReport",
    "OccupancyKPI",
    "OccupancyTrendPoint",
    "ForecastData",
    # Complaints
    "ComplaintKPI",
    "ComplaintDashboard",
    "ComplaintTrend",
    # Visitor
    "VisitorFunnel",
    "TrafficSourceAnalytics",
    "VisitorBehaviorAnalytics",
    # Booking
    "BookingFunnel",
    "BookingKPI",
    "BookingTrendPoint",
    "CancellationAnalytics",
    # Supervisor
    "SupervisorKPI",
    "SupervisorDashboardAnalytics",
    "SupervisorComparison",
    # Platform
    "PlatformMetrics",
    "GrowthMetrics",
    "PlatformUsageAnalytics",
    # Custom reports
    "CustomReportRequest",
    "CustomReportDefinition",
    "CustomReportResult",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\booking_analytics.py ---
# --- File: app/schemas/analytics/booking_analytics.py ---
"""
Booking analytics schemas with enhanced validation and type safety.

This module provides comprehensive analytics for booking operations including:
- Key Performance Indicators (KPIs)
- Trend analysis
- Conversion funnels
- Cancellation analytics
- Source-based metrics
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, computed_field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import BookingStatus, BookingSource
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "BookingKPI",
    "BookingTrendPoint",
    "BookingFunnel",
    "CancellationAnalytics",
    "BookingAnalyticsSummary",
    "BookingSourceMetrics",
]


class BookingKPI(BaseSchema):
    """
    Key Performance Indicators for booking operations.
    
    Provides essential metrics including total bookings, conversion rates,
    and cancellation statistics for a specific hostel or platform-wide.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel identifier. None indicates platform-wide metrics"
    )
    hostel_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Hostel name for display purposes"
    )
    
    # Booking counts
    total_bookings: int = Field(
        ...,
        ge=0,
        description="Total number of bookings in the period"
    )
    confirmed_bookings: int = Field(
        ...,
        ge=0,
        description="Number of confirmed bookings"
    )
    cancelled_bookings: int = Field(
        ...,
        ge=0,
        description="Number of cancelled bookings"
    )
    rejected_bookings: int = Field(
        ...,
        ge=0,
        description="Number of rejected bookings"
    )
    pending_bookings: int = Field(
        0,
        ge=0,
        description="Number of pending bookings awaiting approval"
    )
    
    # Performance metrics
    booking_conversion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of bookings that were confirmed"
    )
    cancellation_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of bookings that were cancelled"
    )
    average_lead_time_days: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average days between booking creation and check-in date"
    )
    
    @field_validator("confirmed_bookings", "cancelled_bookings", "rejected_bookings", "pending_bookings")
    @classmethod
    def validate_booking_counts(cls, v: int, info) -> int:
        """Validate that individual booking counts don't exceed total."""
        if "total_bookings" in info.data:
            total = info.data["total_bookings"]
            if v > total:
                raise ValueError(
                    f"{info.field_name} ({v}) cannot exceed total_bookings ({total})"
                )
        return v
    
    @field_validator("booking_conversion_rate", "cancellation_rate")
    @classmethod
    def validate_percentage(cls, v: Decimal) -> Decimal:
        """Ensure percentages are within valid range."""
        if not (0 <= v <= 100):
            raise ValueError("Percentage must be between 0 and 100")
        return round(v, 2)
    
    @computed_field
    @property
    def approval_rate(self) -> Decimal:
        """Calculate approval rate (confirmed / (confirmed + rejected))."""
        denominator = self.confirmed_bookings + self.rejected_bookings
        if denominator == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.confirmed_bookings) / Decimal(denominator)) * 100,
            2
        )
    
    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate (non-pending / total)."""
        if self.total_bookings == 0:
            return Decimal("0.00")
        completed = self.total_bookings - self.pending_bookings
        return round(
            (Decimal(completed) / Decimal(self.total_bookings)) * 100,
            2
        )


class BookingTrendPoint(BaseSchema):
    """
    Single data point in booking trend analysis.
    
    Represents booking metrics for a specific date, enabling
    time-series visualization and trend analysis.
    """
    
    date: date = Field(
        ...,
        description="Date of the data point"
    )
    total_bookings: int = Field(
        ...,
        ge=0,
        description="Total bookings on this date"
    )
    confirmed: int = Field(
        ...,
        ge=0,
        description="Confirmed bookings on this date"
    )
    cancelled: int = Field(
        ...,
        ge=0,
        description="Cancelled bookings on this date"
    )
    rejected: int = Field(
        ...,
        ge=0,
        description="Rejected bookings on this date"
    )
    pending: int = Field(
        0,
        ge=0,
        description="Pending bookings on this date"
    )
    revenue_for_day: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total revenue generated on this date"
    )
    
    @field_validator("confirmed", "cancelled", "rejected", "pending")
    @classmethod
    def validate_counts(cls, v: int, info) -> int:
        """Validate that status counts don't exceed total."""
        if "total_bookings" in info.data:
            total = info.data["total_bookings"]
            if v > total:
                raise ValueError(
                    f"{info.field_name} ({v}) cannot exceed total_bookings ({total})"
                )
        return v
    
    @computed_field
    @property
    def conversion_rate(self) -> Decimal:
        """Calculate conversion rate for this date."""
        if self.total_bookings == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.confirmed) / Decimal(self.total_bookings)) * 100,
            2
        )


class BookingFunnel(BaseSchema):
    """
    Booking conversion funnel analytics.
    
    Tracks user journey from hostel page views through to confirmed bookings,
    providing insights into conversion bottlenecks.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Time period for funnel analysis"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when this report was generated"
    )
    
    # Funnel stages
    hostel_page_views: int = Field(
        ...,
        ge=0,
        description="Total hostel detail page views"
    )
    booking_form_starts: int = Field(
        ...,
        ge=0,
        description="Users who started the booking form"
    )
    booking_submissions: int = Field(
        ...,
        ge=0,
        description="Completed booking form submissions"
    )
    bookings_confirmed: int = Field(
        ...,
        ge=0,
        description="Final confirmed bookings"
    )
    
    # Conversion rates
    view_to_start_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Conversion rate from page view to form start (%)"
    )
    start_to_submit_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Conversion rate from form start to submission (%)"
    )
    submit_to_confirm_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Conversion rate from submission to confirmation (%)"
    )
    view_to_confirm_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall conversion rate from view to confirmation (%)"
    )
    
    @field_validator(
        "booking_form_starts",
        "booking_submissions",
        "bookings_confirmed"
    )
    @classmethod
    def validate_funnel_progression(cls, v: int, info) -> int:
        """Validate that funnel stages progress logically."""
        field_name = info.field_name
        
        if field_name == "booking_form_starts" and "hostel_page_views" in info.data:
            if v > info.data["hostel_page_views"]:
                raise ValueError(
                    "booking_form_starts cannot exceed hostel_page_views"
                )
        elif field_name == "booking_submissions" and "booking_form_starts" in info.data:
            if v > info.data["booking_form_starts"]:
                raise ValueError(
                    "booking_submissions cannot exceed booking_form_starts"
                )
        elif field_name == "bookings_confirmed" and "booking_submissions" in info.data:
            if v > info.data["booking_submissions"]:
                raise ValueError(
                    "bookings_confirmed cannot exceed booking_submissions"
                )
        
        return v
    
    @computed_field
    @property
    def total_drop_offs(self) -> int:
        """Calculate total number of users who dropped off."""
        return self.hostel_page_views - self.bookings_confirmed
    
    @computed_field
    @property
    def largest_drop_off_stage(self) -> str:
        """Identify the stage with largest drop-off."""
        drop_offs = {
            "view_to_start": self.hostel_page_views - self.booking_form_starts,
            "start_to_submit": self.booking_form_starts - self.booking_submissions,
            "submit_to_confirm": self.booking_submissions - self.bookings_confirmed,
        }
        return max(drop_offs, key=drop_offs.get)


class CancellationAnalytics(BaseSchema):
    """
    Detailed analytics for booking cancellations.
    
    Provides insights into cancellation patterns, reasons,
    and timing to help reduce cancellation rates.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    total_cancellations: int = Field(
        ...,
        ge=0,
        description="Total number of cancellations in period"
    )
    cancellation_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Cancellation rate as percentage of total bookings"
    )
    
    # Breakdown by reason
    cancellations_by_reason: Dict[str, int] = Field(
        default_factory=dict,
        description="Cancellation count grouped by reason"
    )
    cancellations_by_status: Dict[str, int] = Field(
        default_factory=dict,
        description="Cancellation count grouped by original booking status"
    )
    
    # Timing analysis
    average_time_before_check_in_cancelled_days: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average days before check-in when cancellations occur"
    )
    cancellations_within_24h: int = Field(
        0,
        ge=0,
        description="Cancellations made within 24 hours of check-in"
    )
    cancellations_within_week: int = Field(
        0,
        ge=0,
        description="Cancellations made within 1 week of check-in"
    )
    
    @field_validator("cancellations_by_reason", "cancellations_by_status")
    @classmethod
    def validate_breakdown_totals(cls, v: Dict[str, int], info) -> Dict[str, int]:
        """Ensure breakdown totals match overall total."""
        if v and "total_cancellations" in info.data:
            breakdown_total = sum(v.values())
            total_cancellations = info.data["total_cancellations"]
            # Allow some tolerance for rounding or filtering
            if breakdown_total > total_cancellations:
                raise ValueError(
                    f"Breakdown total ({breakdown_total}) exceeds "
                    f"total_cancellations ({total_cancellations})"
                )
        return v
    
    @computed_field
    @property
    def top_cancellation_reason(self) -> Optional[str]:
        """Identify the most common cancellation reason."""
        if not self.cancellations_by_reason:
            return None
        return max(
            self.cancellations_by_reason,
            key=self.cancellations_by_reason.get
        )
    
    @computed_field
    @property
    def early_cancellation_rate(self) -> Decimal:
        """Calculate percentage of cancellations made >7 days before check-in."""
        if self.total_cancellations == 0:
            return Decimal("0.00")
        early = self.total_cancellations - self.cancellations_within_week
        return round(
            (Decimal(early) / Decimal(self.total_cancellations)) * 100,
            2
        )


class BookingSourceMetrics(BaseSchema):
    """
    Metrics for a specific booking source.
    
    Tracks performance of individual booking channels
    to optimize marketing and acquisition strategies.
    """
    
    source: BookingSource = Field(
        ...,
        description="Booking source"
    )
    total_bookings: int = Field(
        ...,
        ge=0,
        description="Total bookings from this source"
    )
    confirmed_bookings: int = Field(
        ...,
        ge=0,
        description="Confirmed bookings from this source"
    )
    conversion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Conversion rate for this source (%)"
    )
    total_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total revenue generated from this source"
    )
    average_booking_value: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average revenue per booking from this source"
    )
    
    @computed_field
    @property
    def revenue_per_confirmed_booking(self) -> Decimal:
        """Calculate average revenue per confirmed booking."""
        if self.confirmed_bookings == 0:
            return Decimal("0.00")
        return round(
            self.total_revenue / Decimal(self.confirmed_bookings),
            2
        )


class BookingAnalyticsSummary(BaseSchema):
    """
    Comprehensive booking analytics summary.
    
    Consolidates all booking metrics, trends, and analytics
    into a single comprehensive report.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel identifier. None for platform-wide analytics"
    )
    hostel_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Core metrics
    kpi: BookingKPI = Field(
        ...,
        description="Key performance indicators"
    )
    trend: List[BookingTrendPoint] = Field(
        default_factory=list,
        description="Daily trend data points"
    )
    
    # Funnel and cancellations
    funnel: BookingFunnel = Field(
        ...,
        description="Booking conversion funnel analysis"
    )
    cancellations: CancellationAnalytics = Field(
        ...,
        description="Cancellation analytics"
    )
    
    # Source analysis
    bookings_by_source: Dict[str, int] = Field(
        default_factory=dict,
        description="Booking count by source"
    )
    source_metrics: List[BookingSourceMetrics] = Field(
        default_factory=list,
        description="Detailed metrics for each booking source"
    )
    
    # Legacy field for backward compatibility
    conversion_rate_by_source: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Conversion rate by source (deprecated: use source_metrics)"
    )
    
    @field_validator("trend")
    @classmethod
    def validate_trend_chronological(
        cls,
        v: List[BookingTrendPoint]
    ) -> List[BookingTrendPoint]:
        """Ensure trend points are in chronological order."""
        if len(v) > 1:
            dates = [point.date for point in v]
            if dates != sorted(dates):
                raise ValueError("Trend points must be in chronological order")
        return v
    
    @computed_field
    @property
    def best_performing_source(self) -> Optional[BookingSource]:
        """Identify the booking source with highest conversion rate."""
        if not self.source_metrics:
            return None
        best = max(
            self.source_metrics,
            key=lambda x: x.conversion_rate
        )
        return best.source
    
    @computed_field
    @property
    def highest_revenue_source(self) -> Optional[BookingSource]:
        """Identify the booking source with highest total revenue."""
        if not self.source_metrics:
            return None
        best = max(
            self.source_metrics,
            key=lambda x: x.total_revenue
        )
        return best.source
    
    def get_trend_summary(self) -> Dict[str, any]:
        """
        Generate a summary of booking trends.
        
        Returns:
            Dictionary containing trend insights like growth rate,
            peak booking date, etc.
        """
        if not self.trend:
            return {}
        
        total_bookings = [point.total_bookings for point in self.trend]
        revenues = [float(point.revenue_for_day) for point in self.trend]
        
        peak_date = max(self.trend, key=lambda x: x.total_bookings).date
        best_revenue_date = max(self.trend, key=lambda x: x.revenue_for_day).date
        
        return {
            "peak_booking_date": peak_date,
            "peak_bookings": max(total_bookings),
            "best_revenue_date": best_revenue_date,
            "best_revenue": max(revenues),
            "average_daily_bookings": round(
                sum(total_bookings) / len(total_bookings), 2
            ),
            "average_daily_revenue": round(
                sum(revenues) / len(revenues), 2
            ),
        }

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\complaint_analytics.py ---
# --- File: app/schemas/analytics/complaint_analytics.py ---
"""
Complaint analytics schemas with enhanced metrics and validation.

Provides comprehensive analytics for complaint management including:
- Service level metrics (SLA compliance, resolution time)
- Trend analysis and forecasting
- Category and priority breakdowns
- Performance benchmarking
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, computed_field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import ComplaintStatus, ComplaintCategory, Priority
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "ComplaintKPI",
    "ComplaintTrendPoint",
    "ComplaintTrend",
    "CategoryBreakdown",
    "PriorityBreakdown",
    "ComplaintDashboard",
    "SLAMetrics",
]


class SLAMetrics(BaseSchema):
    """
    Service Level Agreement metrics for complaint handling.
    
    Tracks compliance with defined service level targets
    and identifies areas needing improvement.
    """
    
    total_with_sla: int = Field(
        ...,
        ge=0,
        description="Total complaints with defined SLA"
    )
    met_sla: int = Field(
        ...,
        ge=0,
        description="Complaints resolved within SLA"
    )
    breached_sla: int = Field(
        ...,
        ge=0,
        description="Complaints that breached SLA"
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of complaints meeting SLA"
    )
    average_sla_buffer_hours: Decimal = Field(
        ...,
        decimal_places=2,
        description="Average time buffer (positive) or breach (negative) in hours"
    )
    
    @field_validator("met_sla", "breached_sla")
    @classmethod
    def validate_sla_counts(cls, v: int, info) -> int:
        """Validate SLA counts don't exceed total."""
        if "total_with_sla" in info.data and v > info.data["total_with_sla"]:
            raise ValueError(f"{info.field_name} cannot exceed total_with_sla")
        return v
    
    @computed_field
    @property
    def at_risk_count(self) -> int:
        """Complaints currently at risk of SLA breach (estimated as 20% of total)."""
        return max(0, int(self.total_with_sla * 0.2))


class ComplaintKPI(BaseSchema):
    """
    Key Performance Indicators for complaint management.
    
    Provides comprehensive metrics on complaint volumes, resolution efficiency,
    and service quality for a specific hostel or platform-wide.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel identifier. None indicates platform-wide metrics"
    )
    hostel_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Hostel name for display"
    )
    
    # Volume metrics
    total_complaints: int = Field(
        ...,
        ge=0,
        description="Total complaints in the period"
    )
    open_complaints: int = Field(
        ...,
        ge=0,
        description="Currently open complaints"
    )
    in_progress_complaints: int = Field(
        0,
        ge=0,
        description="Complaints currently being worked on"
    )
    resolved_complaints: int = Field(
        ...,
        ge=0,
        description="Resolved complaints in the period"
    )
    closed_complaints: int = Field(
        ...,
        ge=0,
        description="Closed complaints in the period"
    )
    
    # Performance metrics
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average time to resolve complaints in hours"
    )
    median_resolution_time_hours: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Median resolution time in hours"
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of complaints resolved within SLA"
    )
    escalation_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of complaints escalated"
    )
    reopen_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of resolved complaints that were reopened"
    )
    
    # First response time
    average_first_response_time_hours: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Average time to first response in hours"
    )
    
    # Customer satisfaction
    average_satisfaction_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average customer satisfaction score (1-5)"
    )
    
    @field_validator(
        "open_complaints",
        "in_progress_complaints",
        "resolved_complaints",
        "closed_complaints"
    )
    @classmethod
    def validate_complaint_counts(cls, v: int, info) -> int:
        """Validate individual counts are reasonable."""
        if "total_complaints" in info.data:
            total = info.data["total_complaints"]
            if v > total and info.field_name != "open_complaints":
                # open_complaints can exceed total as it includes historical
                raise ValueError(
                    f"{info.field_name} ({v}) should not exceed total_complaints ({total})"
                )
        return v
    
    @computed_field
    @property
    def resolution_rate(self) -> Decimal:
        """Calculate percentage of total complaints that have been resolved."""
        if self.total_complaints == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.resolved_complaints) / Decimal(self.total_complaints)) * 100,
            2
        )
    
    @computed_field
    @property
    def backlog(self) -> int:
        """Calculate current complaint backlog."""
        return self.open_complaints + self.in_progress_complaints
    
    @computed_field
    @property
    def efficiency_score(self) -> Decimal:
        """
        Calculate overall efficiency score (0-100).
        
        Combines resolution rate, SLA compliance, and low reopen rate.
        """
        weights = {
            "resolution": 0.4,
            "sla": 0.4,
            "reopen": 0.2
        }
        
        resolution_score = self.resolution_rate
        sla_score = self.sla_compliance_rate
        reopen_score = 100 - self.reopen_rate  # Lower is better
        
        score = (
            resolution_score * Decimal(str(weights["resolution"])) +
            sla_score * Decimal(str(weights["sla"])) +
            reopen_score * Decimal(str(weights["reopen"]))
        )
        
        return round(score, 2)


class ComplaintTrendPoint(BaseSchema):
    """
    Single data point in complaint trend analysis.
    
    Represents complaint metrics for a specific date,
    enabling time-series visualization.
    """
    
    date: date = Field(
        ...,
        description="Date of the data point"
    )
    total_complaints: int = Field(
        ...,
        ge=0,
        description="Total complaints on this date"
    )
    open_complaints: int = Field(
        ...,
        ge=0,
        description="Open complaints on this date"
    )
    resolved_complaints: int = Field(
        ...,
        ge=0,
        description="Resolved complaints on this date"
    )
    escalated: int = Field(
        ...,
        ge=0,
        description="Escalated complaints on this date"
    )
    sla_breached: int = Field(
        ...,
        ge=0,
        description="SLA breaches on this date"
    )
    
    @field_validator("escalated", "sla_breached")
    @classmethod
    def validate_subset_counts(cls, v: int, info) -> int:
        """Validate that subset counts don't exceed total."""
        if "total_complaints" in info.data and v > info.data["total_complaints"]:
            raise ValueError(
                f"{info.field_name} ({v}) cannot exceed total_complaints"
            )
        return v
    
    @computed_field
    @property
    def resolution_rate(self) -> Decimal:
        """Calculate resolution rate for this date."""
        if self.total_complaints == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.resolved_complaints) / Decimal(self.total_complaints)) * 100,
            2
        )


class ComplaintTrend(BaseSchema):
    """
    Time-series trend analysis for complaints.
    
    Provides historical data points and trend indicators
    for complaint volume and resolution patterns.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    points: List[ComplaintTrendPoint] = Field(
        default_factory=list,
        description="Chronological data points"
    )
    
    @field_validator("points")
    @classmethod
    def validate_chronological_order(
        cls,
        v: List[ComplaintTrendPoint]
    ) -> List[ComplaintTrendPoint]:
        """Ensure trend points are in chronological order."""
        if len(v) > 1:
            dates = [point.date for point in v]
            if dates != sorted(dates):
                raise ValueError("Trend points must be in chronological order")
        return v
    
    @computed_field
    @property
    def trend_direction(self) -> str:
        """
        Determine overall trend direction.
        
        Returns:
            'increasing', 'decreasing', or 'stable'
        """
        if len(self.points) < 2:
            return "stable"
        
        first_half = self.points[:len(self.points)//2]
        second_half = self.points[len(self.points)//2:]
        
        first_avg = sum(p.total_complaints for p in first_half) / len(first_half)
        second_avg = sum(p.total_complaints for p in second_half) / len(second_half)
        
        change_percent = ((second_avg - first_avg) / first_avg * 100) if first_avg > 0 else 0
        
        if change_percent > 10:
            return "increasing"
        elif change_percent < -10:
            return "decreasing"
        return "stable"
    
    @computed_field
    @property
    def peak_complaint_date(self) -> Optional[date]:
        """Identify date with highest complaint volume."""
        if not self.points:
            return None
        return max(self.points, key=lambda x: x.total_complaints).date


class CategoryBreakdown(BaseSchema):
    """
    Complaint breakdown by category.
    
    Provides insights into complaint distribution and
    resolution efficiency by category.
    """
    
    category: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Complaint category"
    )
    count: int = Field(
        ...,
        ge=0,
        description="Number of complaints in this category"
    )
    percentage_of_total: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of total complaints"
    )
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average resolution time for this category in hours"
    )
    resolved_count: int = Field(
        0,
        ge=0,
        description="Number of resolved complaints in this category"
    )
    open_count: int = Field(
        0,
        ge=0,
        description="Number of open complaints in this category"
    )
    
    @field_validator("resolved_count", "open_count")
    @classmethod
    def validate_status_counts(cls, v: int, info) -> int:
        """Validate status counts don't exceed category total."""
        if "count" in info.data and v > info.data["count"]:
            raise ValueError(f"{info.field_name} cannot exceed count")
        return v
    
    @computed_field
    @property
    def resolution_rate(self) -> Decimal:
        """Calculate resolution rate for this category."""
        if self.count == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.resolved_count) / Decimal(self.count)) * 100,
            2
        )


class PriorityBreakdown(BaseSchema):
    """
    Complaint breakdown by priority level.
    
    Helps identify resource allocation needs based on
    complaint urgency distribution.
    """
    
    priority: Priority = Field(
        ...,
        description="Priority level"
    )
    count: int = Field(
        ...,
        ge=0,
        description="Number of complaints at this priority"
    )
    percentage_of_total: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of total complaints"
    )
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average resolution time for this priority"
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="SLA compliance rate for this priority level"
    )
    
    @computed_field
    @property
    def priority_score(self) -> int:
        """Get numeric priority score for sorting (higher = more urgent)."""
        priority_scores = {
            Priority.LOW: 1,
            Priority.MEDIUM: 2,
            Priority.HIGH: 3,
            Priority.URGENT: 4,
            Priority.CRITICAL: 5,
        }
        return priority_scores.get(self.priority, 0)


class ComplaintDashboard(BaseSchema):
    """
    Comprehensive complaint dashboard analytics.
    
    Consolidates all complaint metrics, trends, and breakdowns
    into a single actionable dashboard view.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel identifier. None for platform-wide analytics"
    )
    hostel_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Core metrics
    kpi: ComplaintKPI = Field(
        ...,
        description="Key performance indicators"
    )
    sla_metrics: SLAMetrics = Field(
        ...,
        description="Service level agreement metrics"
    )
    trend: ComplaintTrend = Field(
        ...,
        description="Time-series trend analysis"
    )
    
    # Breakdowns
    by_category: List[CategoryBreakdown] = Field(
        default_factory=list,
        description="Breakdown by complaint category"
    )
    by_priority: List[PriorityBreakdown] = Field(
        default_factory=list,
        description="Breakdown by priority level"
    )
    
    # Legacy support
    by_priority_dict: Dict[str, int] = Field(
        default_factory=dict,
        description="Priority counts as dict (deprecated: use by_priority)"
    )
    
    @field_validator("by_category")
    @classmethod
    def validate_category_percentages(
        cls,
        v: List[CategoryBreakdown]
    ) -> List[CategoryBreakdown]:
        """Validate that category percentages sum to ~100%."""
        if v:
            total_percentage = sum(cat.percentage_of_total for cat in v)
            # Allow 1% tolerance for rounding
            if not (99 <= total_percentage <= 101):
                raise ValueError(
                    f"Category percentages should sum to 100%, got {total_percentage}%"
                )
        return v
    
    @computed_field
    @property
    def most_common_category(self) -> Optional[str]:
        """Identify the most common complaint category."""
        if not self.by_category:
            return None
        return max(self.by_category, key=lambda x: x.count).category
    
    @computed_field
    @property
    def slowest_category(self) -> Optional[str]:
        """Identify category with slowest average resolution time."""
        if not self.by_category:
            return None
        return max(
            self.by_category,
            key=lambda x: x.average_resolution_time_hours
        ).category
    
    @computed_field
    @property
    def high_priority_percentage(self) -> Decimal:
        """Calculate percentage of high/urgent/critical priority complaints."""
        if not self.by_priority:
            return Decimal("0.00")
        
        high_priorities = [
            Priority.HIGH,
            Priority.URGENT,
            Priority.CRITICAL
        ]
        high_count = sum(
            p.count for p in self.by_priority
            if p.priority in high_priorities
        )
        total = sum(p.count for p in self.by_priority)
        
        if total == 0:
            return Decimal("0.00")
        
        return round((Decimal(high_count) / Decimal(total)) * 100, 2)
    
    def get_actionable_insights(self) -> List[str]:
        """
        Generate actionable insights based on analytics.
        
        Returns:
            List of insight strings highlighting areas needing attention.
        """
        insights = []
        
        # SLA compliance check
        if self.sla_metrics.sla_compliance_rate < 80:
            insights.append(
                f"SLA compliance at {self.sla_metrics.sla_compliance_rate}% "
                "- consider resource allocation"
            )
        
        # Backlog check
        if self.kpi.backlog > 50:
            insights.append(
                f"High backlog of {self.kpi.backlog} complaints - "
                "prioritize resolution efforts"
            )
        
        # Reopen rate check
        if self.kpi.reopen_rate > 15:
            insights.append(
                f"High reopen rate of {self.kpi.reopen_rate}% - "
                "review resolution quality"
            )
        
        # Trend check
        if self.trend.trend_direction == "increasing":
            insights.append(
                "Complaint volume trending upward - "
                "investigate root causes"
            )
        
        # Category focus
        if self.most_common_category:
            insights.append(
                f"Most complaints in '{self.most_common_category}' category - "
                "consider preventive measures"
            )
        
        return insights

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\custom_reports.py ---
# --- File: app/schemas/analytics/custom_reports.py ---
"""
Custom report builder schemas with advanced filtering and aggregation.

Provides flexible report generation capabilities allowing users to:
- Define custom fields and aggregations
- Apply complex filters
- Group and sort data
- Generate reports in multiple formats
- Share and save report definitions
"""

from datetime import datetime
from typing import Any, Dict, List, Optional, Union
from enum import Enum

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "FilterOperator",
    "AggregationType",
    "ReportFormat",
    "ReportModule",
    "CustomReportFilter",
    "CustomReportField",
    "CustomReportRequest",
    "CustomReportDefinition",
    "CustomReportResult",
    "ReportExportRequest",
    "ReportSchedule",
]


class FilterOperator(str, Enum):
    """Supported filter operators for custom reports."""
    
    # Comparison
    EQUALS = "eq"
    NOT_EQUALS = "ne"
    GREATER_THAN = "gt"
    GREATER_THAN_OR_EQUAL = "gte"
    LESS_THAN = "lt"
    LESS_THAN_OR_EQUAL = "lte"
    
    # Set operations
    IN = "in"
    NOT_IN = "not_in"
    
    # String operations
    CONTAINS = "contains"
    NOT_CONTAINS = "not_contains"
    STARTS_WITH = "starts_with"
    ENDS_WITH = "ends_with"
    
    # Range operations
    BETWEEN = "between"
    
    # Null checks
    IS_NULL = "is_null"
    IS_NOT_NULL = "is_not_null"
    
    # Date operations
    DATE_EQUALS = "date_eq"
    DATE_BEFORE = "date_before"
    DATE_AFTER = "date_after"


class AggregationType(str, Enum):
    """Supported aggregation types."""
    
    SUM = "sum"
    AVERAGE = "avg"
    MINIMUM = "min"
    MAXIMUM = "max"
    COUNT = "count"
    COUNT_DISTINCT = "count_distinct"
    NONE = "none"  # No aggregation


class ReportFormat(str, Enum):
    """Output format for reports."""
    
    TABLE = "table"
    CSV = "csv"
    EXCEL = "excel"
    JSON = "json"
    PDF = "pdf"


class ReportModule(str, Enum):
    """Available modules for custom reports."""
    
    BOOKINGS = "bookings"
    PAYMENTS = "payments"
    COMPLAINTS = "complaints"
    MAINTENANCE = "maintenance"
    ATTENDANCE = "attendance"
    STUDENTS = "students"
    HOSTELS = "hostels"
    ROOMS = "rooms"
    USERS = "users"
    ANNOUNCEMENTS = "announcements"
    REVIEWS = "reviews"


class CustomReportFilter(BaseSchema):
    """
    Filter definition for custom reports.
    
    Defines a single filter condition that can be applied
    to narrow down report data.
    """
    
    field_name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Field name to filter on"
    )
    operator: FilterOperator = Field(
        ...,
        description="Filter operator"
    )
    value: Union[str, int, float, bool, List[Any], None] = Field(
        ...,
        description="Filter value"
    )
    value_to: Optional[Union[str, int, float, None]] = Field(
        None,
        description="Second value for BETWEEN operator"
    )
    case_sensitive: bool = Field(
        False,
        description="Whether string comparison is case-sensitive"
    )
    
    @model_validator(mode="after")
    def validate_operator_value_compatibility(self) -> "CustomReportFilter":
        """Validate that operator and value are compatible."""
        
        # BETWEEN requires value_to
        if self.operator == FilterOperator.BETWEEN and self.value_to is None:
            raise ValueError("BETWEEN operator requires value_to")
        
        # IN/NOT_IN require list values
        if self.operator in [FilterOperator.IN, FilterOperator.NOT_IN]:
            if not isinstance(self.value, list):
                raise ValueError(f"{self.operator} requires a list value")
        
        # NULL checks don't need values
        if self.operator in [FilterOperator.IS_NULL, FilterOperator.IS_NOT_NULL]:
            if self.value is not None:
                raise ValueError(f"{self.operator} should not have a value")
        
        return self
    
    @computed_field
    @property
    def filter_display(self) -> str:
        """Generate human-readable filter description."""
        if self.operator == FilterOperator.BETWEEN:
            return f"{self.field_name} between {self.value} and {self.value_to}"
        elif self.operator in [FilterOperator.IN, FilterOperator.NOT_IN]:
            return f"{self.field_name} {self.operator.value} ({len(self.value)} items)"
        elif self.operator in [FilterOperator.IS_NULL, FilterOperator.IS_NOT_NULL]:
            return f"{self.field_name} {self.operator.value}"
        else:
            return f"{self.field_name} {self.operator.value} {self.value}"


class CustomReportField(BaseSchema):
    """
    Field definition for custom reports.
    
    Defines a field to include in the report with optional
    aggregation and custom display label.
    """
    
    field_name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Database field name"
    )
    display_label: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Custom display label for the field"
    )
    aggregation: AggregationType = Field(
        AggregationType.NONE,
        description="Aggregation function to apply"
    )
    format_string: Optional[str] = Field(
        None,
        max_length=50,
        description="Format string for display (e.g., '%.2f' for decimals)"
    )
    
    @field_validator("display_label")
    @classmethod
    def set_default_label(cls, v: Optional[str], info) -> str:
        """Set default display label from field name if not provided."""
        if v is None and "field_name" in info.data:
            # Convert snake_case to Title Case
            return info.data["field_name"].replace("_", " ").title()
        return v
    
    @computed_field
    @property
    def effective_label(self) -> str:
        """Get the effective display label."""
        if self.display_label:
            return self.display_label
        return self.field_name.replace("_", " ").title()


class CustomReportRequest(BaseCreateSchema):
    """
    Request schema for generating a custom report.
    
    Defines all parameters needed to generate a custom report
    including fields, filters, grouping, and output format.
    """
    
    report_name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Descriptive name for the report"
    )
    module: ReportModule = Field(
        ...,
        description="Module/entity to report on"
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Optional report description"
    )
    
    # Time period
    period: Optional[DateRangeFilter] = Field(
        None,
        description="Optional date range filter"
    )
    
    # Fields to include
    fields: List[CustomReportField] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Fields to include in the report"
    )
    
    # Filters
    filters: List[CustomReportFilter] = Field(
        default_factory=list,
        max_length=20,
        description="Filter conditions to apply"
    )
    
    # Grouping and aggregation
    group_by: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Field names to group by"
    )
    
    # Sorting
    sort_by: Optional[str] = Field(
        None,
        max_length=100,
        description="Field name to sort by"
    )
    sort_order: str = Field(
        "asc",
        pattern="^(asc|desc)$",
        description="Sort order: asc or desc"
    )
    
    # Pagination
    limit: Optional[int] = Field(
        None,
        ge=1,
        le=10000,
        description="Maximum number of rows to return"
    )
    offset: int = Field(
        0,
        ge=0,
        description="Number of rows to skip"
    )
    
    # Output options
    format: ReportFormat = Field(
        ReportFormat.TABLE,
        description="Output format"
    )
    include_summary: bool = Field(
        True,
        description="Include summary statistics"
    )
    include_charts: bool = Field(
        False,
        description="Include chart data/recommendations"
    )
    include_totals: bool = Field(
        True,
        description="Include column totals where applicable"
    )
    
    @field_validator("sort_order")
    @classmethod
    def normalize_sort_order(cls, v: str) -> str:
        """Normalize sort order to lowercase."""
        return v.lower()
    
    @model_validator(mode="after")
    def validate_grouping_and_aggregation(self) -> "CustomReportRequest":
        """Validate that grouping is compatible with aggregations."""
        
        if self.group_by:
            # When grouping, at least one field should have aggregation
            has_aggregation = any(
                field.aggregation != AggregationType.NONE
                for field in self.fields
            )
            
            # All non-aggregated fields should be in group_by
            for field in self.fields:
                if field.aggregation == AggregationType.NONE:
                    if field.field_name not in self.group_by:
                        raise ValueError(
                            f"Field '{field.field_name}' must be in group_by "
                            "or have an aggregation when grouping is used"
                        )
        
        return self
    
    @model_validator(mode="after")
    def validate_sort_field(self) -> "CustomReportRequest":
        """Validate sort field exists in selected fields."""
        
        if self.sort_by:
            field_names = [f.field_name for f in self.fields]
            if self.sort_by not in field_names:
                raise ValueError(
                    f"sort_by field '{self.sort_by}' must be included in fields"
                )
        
        return self
    
    def to_sql_hint(self) -> str:
        """
        Generate a SQL-like representation for debugging.
        
        Returns:
            SQL-like string representation of the report query.
        """
        field_str = ", ".join(
            f"{f.aggregation.value}({f.field_name})" if f.aggregation != AggregationType.NONE
            else f.field_name
            for f in self.fields
        )
        
        sql = f"SELECT {field_str} FROM {self.module.value}"
        
        if self.filters:
            filter_str = " AND ".join(f.filter_display for f in self.filters)
            sql += f" WHERE {filter_str}"
        
        if self.group_by:
            sql += f" GROUP BY {', '.join(self.group_by)}"
        
        if self.sort_by:
            sql += f" ORDER BY {self.sort_by} {self.sort_order.upper()}"
        
        if self.limit:
            sql += f" LIMIT {self.limit}"
        
        if self.offset:
            sql += f" OFFSET {self.offset}"
        
        return sql


class CustomReportDefinition(BaseResponseSchema):
    """
    Saved custom report definition.
    
    Represents a stored report configuration that can be
    reused and shared among users.
    """
    
    id: UUID = Field(
        ...,
        description="Report definition unique identifier"
    )
    owner_id: UUID = Field(
        ...,
        description="User who created the report"
    )
    report_name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Report name"
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Report description"
    )
    module: ReportModule = Field(
        ...,
        description="Report module"
    )
    
    # Report configuration
    period: Optional[DateRangeFilter] = None
    fields: List[CustomReportField] = Field(..., min_length=1)
    filters: List[CustomReportFilter] = Field(default_factory=list)
    group_by: Optional[List[str]] = None
    sort_by: Optional[str] = None
    sort_order: str = Field("asc", pattern="^(asc|desc)$")
    
    # Sharing and permissions
    is_public: bool = Field(
        False,
        description="Whether report is publicly accessible"
    )
    is_template: bool = Field(
        False,
        description="Whether this is a system template"
    )
    shared_with_user_ids: List[UUID] = Field(
        default_factory=list,
        description="User IDs with access to this report"
    )
    shared_with_role: Optional[str] = Field(
        None,
        description="Role with access to this report"
    )
    
    # Usage tracking
    run_count: int = Field(
        0,
        ge=0,
        description="Number of times this report has been run"
    )
    last_run_at: Optional[datetime] = Field(
        None,
        description="Timestamp of last execution"
    )
    
    # Timestamps
    created_at: datetime = Field(
        ...,
        description="Creation timestamp"
    )
    updated_at: datetime = Field(
        ...,
        description="Last update timestamp"
    )
    
    @computed_field
    @property
    def is_shared(self) -> bool:
        """Check if report is shared with anyone."""
        return (
            self.is_public or
            bool(self.shared_with_user_ids) or
            self.shared_with_role is not None
        )
    
    @computed_field
    @property
    def complexity_score(self) -> int:
        """
        Calculate report complexity score (0-100).
        
        Based on number of fields, filters, grouping, etc.
        """
        score = 0
        score += min(len(self.fields) * 5, 25)  # Fields: max 25
        score += min(len(self.filters) * 10, 30)  # Filters: max 30
        score += 20 if self.group_by else 0  # Grouping: 20
        score += min(len(self.group_by or []) * 5, 15)  # Group fields: max 15
        score += 10 if any(f.aggregation != AggregationType.NONE for f in self.fields) else 0
        
        return min(score, 100)


class CustomReportResult(BaseSchema):
    """
    Result of executing a custom report.
    
    Contains the generated data, summary statistics,
    and optional chart data.
    """
    
    report_id: Optional[UUID] = Field(
        None,
        description="Report definition ID if using saved report"
    )
    report_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Report name"
    )
    module: ReportModule = Field(
        ...,
        description="Report module"
    )
    
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    execution_time_ms: Optional[int] = Field(
        None,
        ge=0,
        description="Query execution time in milliseconds"
    )
    
    # Result data
    rows: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Report data rows"
    )
    total_rows: int = Field(
        ...,
        ge=0,
        description="Total number of rows (may exceed returned rows if paginated)"
    )
    returned_rows: int = Field(
        ...,
        ge=0,
        description="Number of rows actually returned"
    )
    
    # Column metadata
    columns: List[CustomReportField] = Field(
        default_factory=list,
        description="Column definitions"
    )
    
    # Summary statistics
    summary: Optional[Dict[str, Any]] = Field(
        None,
        description="Aggregated summary statistics"
    )
    column_totals: Optional[Dict[str, Any]] = Field(
        None,
        description="Column-wise totals"
    )
    
    # Chart data
    charts: Optional[Dict[str, Any]] = Field(
        None,
        description="Suggested chart configurations and data"
    )
    
    # Metadata
    filters_applied: List[CustomReportFilter] = Field(
        default_factory=list,
        description="Filters that were applied"
    )
    grouping_applied: Optional[List[str]] = Field(
        None,
        description="Grouping fields that were applied"
    )
    
    @field_validator("returned_rows")
    @classmethod
    def validate_returned_rows(cls, v: int, info) -> int:
        """Validate returned_rows matches actual row count."""
        if "rows" in info.data and v != len(info.data["rows"]):
            raise ValueError(
                f"returned_rows ({v}) must match length of rows ({len(info.data['rows'])})"
            )
        return v
    
    @computed_field
    @property
    def is_paginated(self) -> bool:
        """Check if results are paginated."""
        return self.total_rows > self.returned_rows
    
    @computed_field
    @property
    def has_data(self) -> bool:
        """Check if report returned any data."""
        return self.returned_rows > 0
    
    def get_export_filename(self, format: ReportFormat) -> str:
        """
        Generate appropriate filename for export.
        
        Args:
            format: Export format
            
        Returns:
            Suggested filename with appropriate extension
        """
        # Sanitize report name
        safe_name = "".join(
            c if c.isalnum() or c in ('-', '_') else '_'
            for c in self.report_name
        )
        
        timestamp = self.generated_at.strftime("%Y%m%d_%H%M%S")
        extension = format.value
        
        return f"{safe_name}_{timestamp}.{extension}"


class ReportExportRequest(BaseSchema):
    """Request to export a report in specific format."""
    
    report_result_id: Optional[UUID] = Field(
        None,
        description="ID of cached report result to export"
    )
    format: ReportFormat = Field(
        ...,
        description="Export format"
    )
    include_metadata: bool = Field(
        True,
        description="Include report metadata in export"
    )
    include_filters: bool = Field(
        True,
        description="Include applied filters in export"
    )
    include_summary: bool = Field(
        True,
        description="Include summary in export"
    )


class ReportSchedule(BaseSchema):
    """Schedule configuration for recurring report generation."""
    
    report_id: UUID = Field(
        ...,
        description="Report definition to run"
    )
    schedule_name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Schedule name"
    )
    
    # Schedule configuration
    frequency: str = Field(
        ...,
        pattern="^(daily|weekly|monthly|quarterly)$",
        description="Report frequency"
    )
    time_of_day: str = Field(
        ...,
        pattern="^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Time to run (HH:MM format, 24-hour)"
    )
    day_of_week: Optional[int] = Field(
        None,
        ge=0,
        le=6,
        description="Day of week for weekly reports (0=Monday)"
    )
    day_of_month: Optional[int] = Field(
        None,
        ge=1,
        le=31,
        description="Day of month for monthly reports"
    )
    
    # Delivery configuration
    recipients: List[str] = Field(
        ...,
        min_length=1,
        description="Email addresses to send report to"
    )
    format: ReportFormat = Field(
        ReportFormat.PDF,
        description="Report format for delivery"
    )
    
    # Status
    is_active: bool = Field(
        True,
        description="Whether schedule is active"
    )
    last_run_at: Optional[datetime] = Field(
        None,
        description="Last execution timestamp"
    )
    next_run_at: Optional[datetime] = Field(
        None,
        description="Next scheduled execution"
    )
    
    @field_validator("recipients")
    @classmethod
    def validate_email_format(cls, v: List[str]) -> List[str]:
        """Basic email format validation."""
        import re
        email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
        
        for email in v:
            if not email_pattern.match(email):
                raise ValueError(f"Invalid email format: {email}")
        
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\dashboard_analytics.py ---
# --- File: app/schemas/analytics/dashboard_analytics.py ---
"""
Dashboard-level analytics schemas with role-based views.

Provides comprehensive dashboard metrics including:
- Key Performance Indicators (KPIs)
- Quick statistics for dashboard cards
- Time-series data for charts
- Role-specific dashboard configurations
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional, Union

from pydantic import Field, field_validator, computed_field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import UserRole
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "KPIResponse",
    "QuickStats",
    "TimeseriesPoint",
    "DashboardMetrics",
    "RoleSpecificDashboard",
    "AlertNotification",
    "DashboardWidget",
]


class KPIResponse(BaseSchema):
    """
    Single Key Performance Indicator for dashboard display.
    
    Represents a measurable metric with trend information,
    targets, and interpretation guidelines.
    """
    
    name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="KPI display name"
    )
    key: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Unique identifier key for the KPI"
    )
    value: Union[Decimal, int, float] = Field(
        ...,
        description="Current KPI value"
    )
    unit: Optional[str] = Field(
        None,
        max_length=20,
        description="Unit of measurement (e.g., 'INR', '%', 'students')"
    )
    
    # Trend analysis
    trend_direction: Optional[str] = Field(
        None,
        pattern="^(up|down|stable)$",
        description="Trend indicator vs previous period"
    )
    trend_percentage: Optional[Decimal] = Field(
        None,
        description="Percentage change vs previous period"
    )
    previous_value: Optional[Union[Decimal, int, float]] = Field(
        None,
        description="Value from previous period for comparison"
    )
    
    # Target and context
    target_value: Optional[Decimal] = Field(
        None,
        description="Target/goal value for this KPI"
    )
    good_when: Optional[str] = Field(
        None,
        pattern="^(higher_is_better|lower_is_better|closer_to_target)$",
        description="Interpretation rule for the KPI"
    )
    
    # Display hints
    format_pattern: Optional[str] = Field(
        None,
        max_length=50,
        description="Format pattern for display (e.g., '%.2f')"
    )
    icon: Optional[str] = Field(
        None,
        max_length=50,
        description="Icon identifier for UI"
    )
    color: Optional[str] = Field(
        None,
        pattern="^#[0-9A-Fa-f]{6}$",
        description="Hex color code for UI theming"
    )
    
    @field_validator("trend_percentage")
    @classmethod
    def validate_trend_percentage(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round trend percentage to 2 decimal places."""
        if v is not None:
            return round(v, 2)
        return v
    
    @computed_field
    @property
    def is_on_target(self) -> Optional[bool]:
        """Check if current value meets target."""
        if self.target_value is None:
            return None
        
        if self.good_when == "higher_is_better":
            return float(self.value) >= float(self.target_value)
        elif self.good_when == "lower_is_better":
            return float(self.value) <= float(self.target_value)
        elif self.good_when == "closer_to_target":
            # Within 5% of target is considered on-target
            tolerance = float(self.target_value) * 0.05
            return abs(float(self.value) - float(self.target_value)) <= tolerance
        
        return None
    
    @computed_field
    @property
    def performance_status(self) -> str:
        """
        Get performance status: 'excellent', 'good', 'warning', 'critical'.
        """
        if self.target_value is None or self.good_when is None:
            return "unknown"
        
        value_float = float(self.value)
        target_float = float(self.target_value)
        
        if self.good_when == "higher_is_better":
            ratio = value_float / target_float if target_float > 0 else 0
            if ratio >= 1.1:
                return "excellent"
            elif ratio >= 1.0:
                return "good"
            elif ratio >= 0.9:
                return "warning"
            else:
                return "critical"
        
        elif self.good_when == "lower_is_better":
            ratio = target_float / value_float if value_float > 0 else float('inf')
            if ratio >= 1.1:
                return "excellent"
            elif ratio >= 1.0:
                return "good"
            elif ratio >= 0.9:
                return "warning"
            else:
                return "critical"
        
        elif self.good_when == "closer_to_target":
            deviation = abs(value_float - target_float) / target_float if target_float > 0 else 0
            if deviation <= 0.05:
                return "excellent"
            elif deviation <= 0.10:
                return "good"
            elif deviation <= 0.20:
                return "warning"
            else:
                return "critical"
        
        return "unknown"
    
    def format_value(self) -> str:
        """Format value for display using format_pattern."""
        if self.format_pattern:
            try:
                return self.format_pattern % float(self.value)
            except (ValueError, TypeError):
                pass
        
        # Default formatting
        if self.unit == "%":
            return f"{float(self.value):.2f}%"
        elif self.unit == "INR":
            return f"{float(self.value):,.2f}"
        else:
            return f"{self.value}"


class QuickStats(BaseSchema):
    """
    Quick statistics for dashboard cards.
    
    Provides snapshot metrics for immediate visibility
    into system state and operations.
    """
    
    # Hostel metrics
    total_hostels: int = Field(
        ...,
        ge=0,
        description="Total number of hostels in system"
    )
    active_hostels: int = Field(
        ...,
        ge=0,
        description="Number of active hostels"
    )
    
    # Student metrics
    total_students: int = Field(
        ...,
        ge=0,
        description="Total registered students"
    )
    active_students: int = Field(
        ...,
        ge=0,
        description="Currently active students"
    )
    
    # Visitor metrics
    total_visitors: int = Field(
        0,
        ge=0,
        description="Total registered visitors"
    )
    active_visitors: int = Field(
        0,
        ge=0,
        description="Currently active visitors"
    )
    
    # Daily operations
    todays_check_ins: int = Field(
        ...,
        ge=0,
        description="Check-ins scheduled for today"
    )
    todays_check_outs: int = Field(
        ...,
        ge=0,
        description="Check-outs scheduled for today"
    )
    
    # Issues and maintenance
    open_complaints: int = Field(
        ...,
        ge=0,
        description="Currently open complaints"
    )
    urgent_complaints: int = Field(
        0,
        ge=0,
        description="Urgent/critical complaints"
    )
    pending_maintenance: int = Field(
        ...,
        ge=0,
        description="Pending maintenance requests"
    )
    overdue_maintenance: int = Field(
        0,
        ge=0,
        description="Overdue maintenance requests"
    )
    
    # Financial metrics
    todays_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Revenue collected today"
    )
    monthly_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Revenue for current month"
    )
    outstanding_payments: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total outstanding payment amount"
    )
    overdue_payments: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Overdue payment amount"
    )
    
    @field_validator(
        "active_hostels",
        "active_students",
        "active_visitors"
    )
    @classmethod
    def validate_active_counts(cls, v: int, info) -> int:
        """Validate active counts don't exceed totals."""
        field_name = info.field_name
        
        if field_name == "active_hostels" and "total_hostels" in info.data:
            if v > info.data["total_hostels"]:
                raise ValueError("active_hostels cannot exceed total_hostels")
        elif field_name == "active_students" and "total_students" in info.data:
            if v > info.data["total_students"]:
                raise ValueError("active_students cannot exceed total_students")
        elif field_name == "active_visitors" and "total_visitors" in info.data:
            if v > info.data["total_visitors"]:
                raise ValueError("active_visitors cannot exceed total_visitors")
        
        return v
    
    @computed_field
    @property
    def occupancy_rate(self) -> Decimal:
        """Calculate approximate occupancy rate."""
        if self.total_students == 0:
            return Decimal("0.00")
        # Simplified calculation - would need total bed count for accuracy
        return round(
            (Decimal(self.active_students) / Decimal(self.total_students)) * 100,
            2
        )
    
    @computed_field
    @property
    def complaint_urgency_rate(self) -> Decimal:
        """Calculate percentage of urgent complaints."""
        if self.open_complaints == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.urgent_complaints) / Decimal(self.open_complaints)) * 100,
            2
        )
    
    @computed_field
    @property
    def payment_collection_health(self) -> str:
        """Assess payment collection health."""
        if self.outstanding_payments == 0:
            return "excellent"
        
        overdue_ratio = (
            self.overdue_payments / self.outstanding_payments
            if self.outstanding_payments > 0
            else 0
        )
        
        if overdue_ratio <= 0.1:
            return "good"
        elif overdue_ratio <= 0.25:
            return "warning"
        else:
            return "critical"


class TimeseriesPoint(BaseSchema):
    """
    Single data point in a time series.
    """

    date_: date = Field(
        ...,
        description="Date of the data point"
    )
    value: Union[Decimal, int, float] = Field(
        ...,
        description="Metric value"
    )
    label: Optional[str] = Field(
        None,
        max_length=100,
        description="Optional label for this point"
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description="Additional metadata for this point"
    )

    @computed_field
    @property
    def formatted_date(self) -> str:
        """Get formatted date string."""
        return self.date_.strftime("%Y-%m-%d")



class AlertNotification(BaseSchema):
    """Dashboard alert notification."""
    
    id: UUID = Field(
        ...,
        description="Alert identifier"
    )
    severity: str = Field(
        ...,
        pattern="^(info|warning|error|critical)$",
        description="Alert severity level"
    )
    title: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Alert title"
    )
    message: str = Field(
        ...,
        min_length=1,
        max_length=1000,
        description="Alert message"
    )
    action_url: Optional[str] = Field(
        None,
        max_length=500,
        description="URL for alert action"
    )
    action_label: Optional[str] = Field(
        None,
        max_length=100,
        description="Label for action button"
    )
    created_at: datetime = Field(
        ...,
        description="Alert creation time"
    )
    expires_at: Optional[datetime] = Field(
        None,
        description="Alert expiration time"
    )
    is_dismissed: bool = Field(
        False,
        description="Whether alert has been dismissed"
    )
    
    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if alert is still active."""
        if self.is_dismissed:
            return False
        if self.expires_at and datetime.utcnow() > self.expires_at:
            return False
        return True


class DashboardWidget(BaseSchema):
    """Configuration for a dashboard widget."""
    
    widget_id: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Unique widget identifier"
    )
    widget_type: str = Field(
        ...,
        pattern="^(kpi|chart|table|list|stat)$",
        description="Widget type"
    )
    title: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Widget title"
    )
    position: int = Field(
        ...,
        ge=0,
        description="Display position/order"
    )
    size: str = Field(
        "medium",
        pattern="^(small|medium|large|full)$",
        description="Widget size"
    )
    data_source: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Data source identifier"
    )
    refresh_interval_seconds: Optional[int] = Field(
        None,
        ge=10,
        description="Auto-refresh interval in seconds"
    )
    is_visible: bool = Field(
        True,
        description="Whether widget is visible"
    )


class DashboardMetrics(BaseSchema):
    """
    Aggregated dashboard metrics for a given scope.
    
    Provides comprehensive analytics tailored to specific
    scope (hostel, platform, or admin).
    """
    
    scope_type: str = Field(
        ...,
        pattern="^(hostel|platform|admin)$",
        description="Scope of the dashboard"
    )
    scope_id: Optional[UUID] = Field(
        None,
        description="Hostel ID or admin ID if applicable"
    )
    scope_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Display name for the scope"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Dashboard generation timestamp"
    )
    
    # Core metrics
    kpis: List[KPIResponse] = Field(
        default_factory=list,
        description="Key performance indicators"
    )
    quick_stats: QuickStats = Field(
        ...,
        description="Quick statistics for dashboard cards"
    )
    
    # Time series data for charts
    revenue_timeseries: List[TimeseriesPoint] = Field(
        default_factory=list,
        description="Revenue over time"
    )
    occupancy_timeseries: List[TimeseriesPoint] = Field(
        default_factory=list,
        description="Occupancy rate over time"
    )
    booking_timeseries: List[TimeseriesPoint] = Field(
        default_factory=list,
        description="Bookings over time"
    )
    complaint_timeseries: List[TimeseriesPoint] = Field(
        default_factory=list,
        description="Complaints over time"
    )
    
    # Alerts and notifications
    alerts: List[AlertNotification] = Field(
        default_factory=list,
        description="Active alerts for this dashboard"
    )
    
    # Custom widgets
    widgets: List[DashboardWidget] = Field(
        default_factory=list,
        description="Custom dashboard widgets"
    )
    
    @field_validator(
        "revenue_timeseries",
        "occupancy_timeseries",
        "booking_timeseries",
        "complaint_timeseries"
    )
    @classmethod
    def validate_timeseries_chronological(
        cls,
        v: List[TimeseriesPoint]
    ) -> List[TimeseriesPoint]:
        """Ensure timeseries data is in chronological order."""
        if len(v) > 1:
            dates = [point.date for point in v]
            if dates != sorted(dates):
                raise ValueError("Timeseries points must be in chronological order")
        return v
    
    @computed_field
    @property
    def active_alert_count(self) -> int:
        """Count of active alerts."""
        return sum(1 for alert in self.alerts if alert.is_active)
    
    @computed_field
    @property
    def critical_alert_count(self) -> int:
        """Count of critical active alerts."""
        return sum(
            1 for alert in self.alerts
            if alert.is_active and alert.severity == "critical"
        )
    
    def get_kpi_by_key(self, key: str) -> Optional[KPIResponse]:
        """Retrieve a specific KPI by its key."""
        for kpi in self.kpis:
            if kpi.key == key:
                return kpi
        return None
    
    def get_trending_kpis(self) -> List[KPIResponse]:
        """Get KPIs that are trending (up or down)."""
        return [
            kpi for kpi in self.kpis
            if kpi.trend_direction and kpi.trend_direction != "stable"
        ]
    
    def get_off_target_kpis(self) -> List[KPIResponse]:
        """Get KPIs that are not meeting targets."""
        return [
            kpi for kpi in self.kpis
            if kpi.is_on_target is False
        ]


class RoleSpecificDashboard(BaseSchema):
    """
    Role-specific dashboard configuration and data.
    
    Provides customized dashboard views based on user role,
    showing only relevant metrics and actions.
    """
    
    role: UserRole = Field(
        ...,
        description="User role for this dashboard"
    )
    user_id: UUID = Field(
        ...,
        description="User identifier"
    )
    user_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="User display name"
    )
    
    # Section-based organization
    sections: List[str] = Field(
        default_factory=list,
        description="Dashboard section identifiers"
    )
    
    # Metrics organized by section
    metrics_by_section: Dict[str, DashboardMetrics] = Field(
        default_factory=dict,
        description="Section name -> Dashboard metrics"
    )
    
    # Quick stats organized by section
    stats_by_section: Dict[str, QuickStats] = Field(
        default_factory=dict,
        description="Section name -> Quick stats"
    )
    
    # KPIs organized by section
    kpis_by_section: Dict[str, List[KPIResponse]] = Field(
        default_factory=dict,
        description="Section name -> KPI list"
    )
    
    # Permissions
    accessible_features: List[str] = Field(
        default_factory=list,
        description="List of features accessible to this role"
    )
    
    # Preferences
    default_section: Optional[str] = Field(
        None,
        description="Default section to display"
    )
    layout_preferences: Optional[Dict[str, Any]] = Field(
        None,
        description="User's layout preferences"
    )
    
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Dashboard generation timestamp"
    )
    
    @computed_field
    @property
    def total_kpi_count(self) -> int:
        """Total number of KPIs across all sections."""
        return sum(len(kpis) for kpis in self.kpis_by_section.values())
    
    @computed_field
    @property
    def has_critical_alerts(self) -> bool:
        """Check if any section has critical alerts."""
        for metrics in self.metrics_by_section.values():
            if metrics.critical_alert_count > 0:
                return True
        return False
    
    def get_section_metrics(self, section_name: str) -> Optional[DashboardMetrics]:
        """Get metrics for a specific section."""
        return self.metrics_by_section.get(section_name)
    
    def get_all_alerts(self) -> List[AlertNotification]:
        """Get all alerts from all sections."""
        all_alerts = []
        for metrics in self.metrics_by_section.values():
            all_alerts.extend(metrics.alerts)
        
        # Sort by severity and creation time
        severity_order = {"critical": 0, "error": 1, "warning": 2, "info": 3}
        return sorted(
            all_alerts,
            key=lambda x: (severity_order.get(x.severity, 999), x.created_at),
            reverse=True
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\financial_analytics.py ---
# --- File: app/schemas/analytics/financial_analytics.py ---
"""
Financial analytics schemas with comprehensive P&L and cashflow tracking.

Provides detailed financial analytics including:
- Revenue and expense breakdowns
- Profit & Loss statements
- Cashflow analysis and forecasting
- Financial ratios and metrics
- Budget vs. actual comparisons
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from enum import Enum

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import PaymentType
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "RevenueCategory",
    "ExpenseCategory",
    "RevenueBreakdown",
    "ExpenseBreakdown",
    "ProfitAndLossReport",
    "CashflowPoint",
    "CashflowSummary",
    "FinancialRatios",
    "BudgetComparison",
    "FinancialReport",
    "TaxSummary",
]


class RevenueCategory(str, Enum):
    """Revenue categories for financial reporting."""
    
    BOOKING = "booking"
    RENT = "rent"
    MESS = "mess"
    UTILITIES = "utilities"
    LATE_FEES = "late_fees"
    SECURITY_DEPOSIT = "security_deposit"
    OTHER = "other"


class ExpenseCategory(str, Enum):
    """Expense categories for financial reporting."""
    
    MAINTENANCE = "maintenance"
    STAFF_SALARIES = "staff_salaries"
    UTILITIES = "utilities"
    SUPPLIES = "supplies"
    MARKETING = "marketing"
    ADMINISTRATIVE = "administrative"
    DEPRECIATION = "depreciation"
    INSURANCE = "insurance"
    TAXES = "taxes"
    OTHER = "other"


class RevenueBreakdown(BaseSchema):
    """
    Detailed breakdown of revenue by source and type.
    
    Provides granular visibility into revenue streams
    for financial analysis and planning.
    """
    
    # Total revenue
    total_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total revenue for the period"
    )
    
    # Revenue by type
    booking_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Revenue from new bookings"
    )
    rent_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly/periodic rent revenue"
    )
    mess_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Mess/food service revenue"
    )
    utility_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Utility charges collected"
    )
    late_fee_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Late payment fees"
    )
    other_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Other miscellaneous revenue"
    )
    
    # Breakdown by hostel
    revenue_by_hostel: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Revenue mapped by hostel ID"
    )
    
    # Breakdown by payment type
    revenue_by_payment_type: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Revenue by PaymentType category"
    )
    
    # Collection metrics
    billed_amount: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Total amount billed in period"
    )
    collected_amount: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Amount actually collected"
    )
    pending_amount: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Amount pending collection"
    )
    
    @model_validator(mode="after")
    def validate_revenue_totals(self) -> "RevenueBreakdown":
        """Validate that component revenues sum to total."""
        component_sum = (
            self.booking_revenue +
            self.rent_revenue +
            self.mess_revenue +
            self.utility_revenue +
            self.late_fee_revenue +
            self.other_revenue
        )
        
        # Allow 0.01 tolerance for rounding
        if abs(component_sum - self.total_revenue) > Decimal("0.01"):
            raise ValueError(
                f"Component revenues ({component_sum}) must sum to "
                f"total_revenue ({self.total_revenue})"
            )
        
        return self
    
    @computed_field
    @property
    def collection_rate(self) -> Decimal:
        """Calculate collection rate percentage."""
        if self.billed_amount == 0:
            return Decimal("100.00")
        return round(
            (self.collected_amount / self.billed_amount) * 100,
            2
        )
    
    @computed_field
    @property
    def primary_revenue_source(self) -> str:
        """Identify the largest revenue source."""
        sources = {
            "booking": self.booking_revenue,
            "rent": self.rent_revenue,
            "mess": self.mess_revenue,
            "utilities": self.utility_revenue,
            "late_fees": self.late_fee_revenue,
            "other": self.other_revenue,
        }
        return max(sources, key=sources.get)
    
    @computed_field
    @property
    def revenue_concentration_risk(self) -> str:
        """
        Assess revenue concentration risk.
        
        Returns:
            'low', 'medium', or 'high' based on revenue diversification
        """
        if self.total_revenue == 0:
            return "unknown"
        
        # Calculate percentage from largest source
        largest_source_pct = (
            float(max(
                self.booking_revenue,
                self.rent_revenue,
                self.mess_revenue
            )) / float(self.total_revenue) * 100
        )
        
        if largest_source_pct >= 70:
            return "high"
        elif largest_source_pct >= 50:
            return "medium"
        else:
            return "low"


class ExpenseBreakdown(BaseSchema):
    """
    Detailed breakdown of expenses by category.
    
    Provides granular visibility into cost structure
    for financial control and optimization.
    """
    
    # Total expenses
    total_expenses: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total expenses for the period"
    )
    
    # Expense by category
    maintenance_expenses: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Maintenance and repair expenses"
    )
    staff_expenses: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Staff salaries and benefits"
    )
    utility_expenses: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Utility expenses (electricity, water, etc.)"
    )
    supply_expenses: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Supplies and consumables"
    )
    marketing_expenses: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Marketing and advertising expenses"
    )
    administrative_expenses: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Administrative and overhead expenses"
    )
    other_expenses: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Other miscellaneous expenses"
    )
    
    # Breakdown by hostel
    expenses_by_hostel: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Expenses mapped by hostel ID"
    )
    
    # Breakdown by category (detailed)
    expenses_by_category: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Expenses by ExpenseCategory"
    )
    
    # Fixed vs. Variable
    fixed_expenses: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Fixed expenses (rent, salaries, etc.)"
    )
    variable_expenses: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Variable expenses (utilities, supplies, etc.)"
    )
    
    @model_validator(mode="after")
    def validate_expense_totals(self) -> "ExpenseBreakdown":
        """Validate that component expenses sum to total."""
        component_sum = (
            self.maintenance_expenses +
            self.staff_expenses +
            self.utility_expenses +
            self.supply_expenses +
            self.marketing_expenses +
            self.administrative_expenses +
            self.other_expenses
        )
        
        # Allow 0.01 tolerance for rounding
        if abs(component_sum - self.total_expenses) > Decimal("0.01"):
            raise ValueError(
                f"Component expenses ({component_sum}) must sum to "
                f"total_expenses ({self.total_expenses})"
            )
        
        return self
    
    @computed_field
    @property
    def largest_expense_category(self) -> str:
        """Identify the largest expense category."""
        categories = {
            "maintenance": self.maintenance_expenses,
            "staff": self.staff_expenses,
            "utilities": self.utility_expenses,
            "supplies": self.supply_expenses,
            "marketing": self.marketing_expenses,
            "administrative": self.administrative_expenses,
            "other": self.other_expenses,
        }
        return max(categories, key=categories.get)
    
    @computed_field
    @property
    def expense_ratio_staff(self) -> Decimal:
        """Calculate staff expense as percentage of total."""
        if self.total_expenses == 0:
            return Decimal("0.00")
        return round(
            (self.staff_expenses / self.total_expenses) * 100,
            2
        )


class FinancialRatios(BaseSchema):
    """
    Key financial ratios and metrics.
    
    Provides analytical ratios for financial health assessment
    and performance benchmarking.
    """
    
    # Profitability ratios
    gross_profit_margin: Decimal = Field(
        ...,
        decimal_places=2,
        description="Gross profit margin percentage"
    )
    net_profit_margin: Decimal = Field(
        ...,
        decimal_places=2,
        description="Net profit margin percentage"
    )
    return_on_revenue: Decimal = Field(
        ...,
        decimal_places=2,
        description="Return on revenue percentage"
    )
    
    # Efficiency ratios
    operating_expense_ratio: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Operating expenses as % of revenue"
    )
    revenue_per_bed: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average revenue per bed"
    )
    revenue_per_student: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average revenue per student"
    )
    
    # Collection ratios
    collection_efficiency: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Collection efficiency percentage"
    )
    days_sales_outstanding: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Average days to collect payment"
    )
    
    # Cost control
    variable_cost_ratio: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Variable costs as % of revenue"
    )
    fixed_cost_ratio: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Fixed costs as % of revenue"
    )
    
    @computed_field
    @property
    def profitability_status(self) -> str:
        """Assess overall profitability status."""
        if self.net_profit_margin >= 20:
            return "excellent"
        elif self.net_profit_margin >= 10:
            return "good"
        elif self.net_profit_margin >= 0:
            return "moderate"
        else:
            return "loss"


class BudgetComparison(BaseSchema):
    """
    Budget vs. actual comparison.
    
    Compares actual financial performance against
    budgeted targets for variance analysis.
    """
    
    category: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Budget category (revenue/expense type)"
    )
    budgeted_amount: Decimal = Field(
        ...,
        decimal_places=2,
        description="Budgeted amount for the period"
    )
    actual_amount: Decimal = Field(
        ...,
        decimal_places=2,
        description="Actual amount for the period"
    )
    variance_amount: Decimal = Field(
        ...,
        decimal_places=2,
        description="Variance (actual - budgeted)"
    )
    variance_percentage: Decimal = Field(
        ...,
        decimal_places=2,
        description="Variance as percentage of budget"
    )
    
    @computed_field
    @property
    def is_favorable(self) -> bool:
        """
        Determine if variance is favorable.
        
        For revenue: actual > budgeted is favorable
        For expenses: actual < budgeted is favorable
        """
        # Assume revenue categories have positive variance when favorable
        # This should be contextualized by the caller
        return self.variance_amount >= 0
    
    @computed_field
    @property
    def variance_severity(self) -> str:
        """Assess severity of budget variance."""
        abs_variance_pct = abs(float(self.variance_percentage))
        
        if abs_variance_pct <= 5:
            return "minor"
        elif abs_variance_pct <= 15:
            return "moderate"
        elif abs_variance_pct <= 30:
            return "significant"
        else:
            return "critical"


class TaxSummary(BaseSchema):
    """
    Tax-related summary for financial reporting.
    
    Provides tax liability and compliance information.
    """
    
    taxable_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Revenue subject to taxation"
    )
    tax_exempt_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Tax-exempt revenue"
    )
    
    # Tax liabilities
    gst_collected: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="GST collected from customers"
    )
    gst_paid: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="GST paid on expenses"
    )
    gst_payable: Decimal = Field(
        0,
        decimal_places=2,
        description="Net GST payable (collected - paid)"
    )
    
    tds_deducted: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="TDS deducted at source"
    )
    
    estimated_income_tax: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Estimated income tax liability"
    )
    
    @computed_field
    @property
    def effective_tax_rate(self) -> Decimal:
        """Calculate effective tax rate."""
        if self.taxable_revenue == 0:
            return Decimal("0.00")
        
        total_tax = self.gst_payable + self.estimated_income_tax
        return round(
            (total_tax / self.taxable_revenue) * 100,
            2
        )


class ProfitAndLossReport(BaseSchema):
    """
    Profit & Loss (P&L) statement.
    
    Comprehensive income statement showing revenue,
    expenses, and profitability for a period.
    """
    
    scope_type: str = Field(
        ...,
        pattern="^(hostel|platform)$",
        description="Scope of the P&L report"
    )
    scope_id: Optional[UUID] = Field(
        None,
        description="Hostel ID if scope is hostel"
    )
    scope_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Display name for the scope"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Reporting period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Revenue and expenses
    revenue: RevenueBreakdown = Field(
        ...,
        description="Revenue breakdown"
    )
    expenses: ExpenseBreakdown = Field(
        ...,
        description="Expense breakdown"
    )
    
    # Calculated values
    gross_profit: Decimal = Field(
        ...,
        decimal_places=2,
        description="Gross profit (revenue - direct costs)"
    )
    operating_profit: Decimal = Field(
        ...,
        decimal_places=2,
        description="Operating profit (gross profit - operating expenses)"
    )
    net_profit: Decimal = Field(
        ...,
        decimal_places=2,
        description="Net profit after all expenses"
    )
    
    # Margins
    gross_profit_margin: Decimal = Field(
        ...,
        decimal_places=2,
        description="Gross profit margin percentage"
    )
    operating_profit_margin: Decimal = Field(
        ...,
        decimal_places=2,
        description="Operating profit margin percentage"
    )
    net_profit_margin: Decimal = Field(
        ...,
        decimal_places=2,
        description="Net profit margin percentage"
    )
    
    # Legacy field
    profit_margin_percentage: Decimal = Field(
        ...,
        decimal_places=2,
        description="Profit margin percentage (deprecated: use net_profit_margin)"
    )
    
    # Financial ratios
    ratios: Optional[FinancialRatios] = Field(
        None,
        description="Key financial ratios"
    )
    
    # Tax information
    tax_summary: Optional[TaxSummary] = Field(
        None,
        description="Tax-related summary"
    )
    
    # Budget comparison
    budget_comparisons: List[BudgetComparison] = Field(
        default_factory=list,
        description="Budget vs. actual comparisons"
    )
    
    @model_validator(mode="after")
    def validate_profit_calculations(self) -> "ProfitAndLossReport":
        """Validate profit calculations are consistent."""
        
        # Gross profit should be revenue - cost of goods sold
        # For simplicity, assuming gross profit equals revenue - variable costs
        expected_gross = self.revenue.total_revenue - self.expenses.variable_expenses
        if abs(self.gross_profit - expected_gross) > Decimal("0.01"):
            # Log warning but don't fail - calculations may vary by implementation
            pass
        
        # Net profit should be revenue - total expenses
        expected_net = self.revenue.total_revenue - self.expenses.total_expenses
        if abs(self.net_profit - expected_net) > Decimal("0.01"):
            raise ValueError(
                f"Net profit ({self.net_profit}) should equal "
                f"revenue ({self.revenue.total_revenue}) - "
                f"expenses ({self.expenses.total_expenses})"
            )
        
        return self
    
    @computed_field
    @property
    def is_profitable(self) -> bool:
        """Check if the period was profitable."""
        return self.net_profit > 0
    
    @computed_field
    @property
    def break_even_revenue(self) -> Decimal:
        """
        Calculate break-even revenue.
        
        Revenue needed to cover all expenses.
        """
        return self.expenses.total_expenses
    
    @computed_field
    @property
    def revenue_above_break_even(self) -> Decimal:
        """Calculate revenue above break-even point."""
        return max(
            Decimal("0.00"),
            self.revenue.total_revenue - self.break_even_revenue
        )
    
    def get_performance_summary(self) -> Dict[str, any]:
        """
        Generate performance summary.
        
        Returns:
            Dictionary with key performance insights
        """
        return {
            "is_profitable": self.is_profitable,
            "profitability_status": self.ratios.profitability_status if self.ratios else "unknown",
            "net_profit": float(self.net_profit),
            "net_profit_margin": float(self.net_profit_margin),
            "revenue_growth_needed": (
                0 if self.is_profitable
                else float(self.break_even_revenue - self.revenue.total_revenue)
            ),
            "largest_revenue_source": self.revenue.primary_revenue_source,
            "largest_expense_category": self.expenses.largest_expense_category,
            "collection_rate": float(self.revenue.collection_rate),
        }


class CashflowPoint(BaseSchema):
    """
    Single data point in cashflow time series.
    
    Represents cash movements for a specific date.
    """
    
    date: date = Field(
        ...,
        description="Date of cashflow point"
    )
    inflow: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Cash inflow for the day"
    )
    outflow: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Cash outflow for the day"
    )
    net_flow: Decimal = Field(
        ...,
        decimal_places=2,
        description="Net cashflow (inflow - outflow)"
    )
    balance: Decimal = Field(
        ...,
        decimal_places=2,
        description="Cumulative balance after this transaction"
    )
    
    @model_validator(mode="after")
    def validate_net_flow(self) -> "CashflowPoint":
        """Validate net flow calculation."""
        expected_net = self.inflow - self.outflow
        if abs(self.net_flow - expected_net) > Decimal("0.01"):
            raise ValueError(
                f"Net flow ({self.net_flow}) should equal "
                f"inflow ({self.inflow}) - outflow ({self.outflow})"
            )
        return self
    
    @computed_field
    @property
    def is_positive_flow(self) -> bool:
        """Check if net flow is positive."""
        return self.net_flow > 0


class CashflowSummary(BaseSchema):
    """
    Cashflow summary and analysis.
    
    Provides comprehensive view of cash movements,
    working capital, and liquidity position.
    """
    
    scope_type: str = Field(
        ...,
        pattern="^(hostel|platform)$",
        description="Scope of cashflow analysis"
    )
    scope_id: Optional[UUID] = Field(
        None,
        description="Hostel ID if scope is hostel"
    )
    scope_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Display name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Balances
    opening_balance: Decimal = Field(
        ...,
        decimal_places=2,
        description="Cash balance at start of period"
    )
    closing_balance: Decimal = Field(
        ...,
        decimal_places=2,
        description="Cash balance at end of period"
    )
    
    # Totals
    total_inflows: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total cash inflows during period"
    )
    total_outflows: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total cash outflows during period"
    )
    net_cashflow: Decimal = Field(
        ...,
        decimal_places=2,
        description="Net cashflow for the period"
    )
    
    # Legacy fields
    inflows: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total inflows (deprecated: use total_inflows)"
    )
    outflows: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total outflows (deprecated: use total_outflows)"
    )
    
    # Breakdowns
    inflow_breakdown: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Inflows by category"
    )
    outflow_breakdown: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Outflows by category"
    )
    
    # Time series
    cashflow_timeseries: List[CashflowPoint] = Field(
        default_factory=list,
        description="Daily cashflow data points"
    )
    
    # Liquidity metrics
    average_daily_balance: Decimal = Field(
        0,
        decimal_places=2,
        description="Average daily cash balance"
    )
    minimum_balance: Decimal = Field(
        0,
        decimal_places=2,
        description="Minimum balance during period"
    )
    maximum_balance: Decimal = Field(
        0,
        decimal_places=2,
        description="Maximum balance during period"
    )
    
    @model_validator(mode="after")
    def validate_cashflow_consistency(self) -> "CashflowSummary":
        """Validate cashflow calculations are consistent."""
        
        # Net cashflow should equal closing - opening
        expected_net = self.closing_balance - self.opening_balance
        if abs(self.net_cashflow - expected_net) > Decimal("0.01"):
            raise ValueError(
                f"Net cashflow ({self.net_cashflow}) should equal "
                f"closing ({self.closing_balance}) - opening ({self.opening_balance})"
            )
        
        # Net cashflow should also equal inflows - outflows
        expected_net_2 = self.total_inflows - self.total_outflows
        if abs(self.net_cashflow - expected_net_2) > Decimal("0.01"):
            raise ValueError(
                f"Net cashflow ({self.net_cashflow}) should equal "
                f"inflows ({self.total_inflows}) - outflows ({self.total_outflows})"
            )
        
        return self
    
    @field_validator("cashflow_timeseries")
    @classmethod
    def validate_chronological_order(
        cls,
        v: List[CashflowPoint]
    ) -> List[CashflowPoint]:
        """Ensure cashflow points are chronological."""
        if len(v) > 1:
            dates = [point.date for point in v]
            if dates != sorted(dates):
                raise ValueError("Cashflow points must be in chronological order")
        return v
    
    @computed_field
    @property
    def cashflow_health(self) -> str:
        """Assess overall cashflow health."""
        if self.closing_balance < 0:
            return "critical"
        elif self.net_cashflow < 0:
            return "warning"
        elif self.net_cashflow > self.total_outflows * Decimal("0.2"):
            return "excellent"
        else:
            return "good"
    
    @computed_field
    @property
    def burn_rate_days(self) -> Optional[int]:
        """
        Calculate runway in days based on current burn rate.
        
        Returns:
            Number of days until cash runs out at current rate,
            or None if cashflow is positive
        """
        if self.net_cashflow >= 0:
            return None
        
        if len(self.cashflow_timeseries) == 0:
            return None
        
        # Calculate average daily burn
        days = len(self.cashflow_timeseries)
        daily_burn = abs(self.net_cashflow / Decimal(days))
        
        if daily_burn == 0:
            return None
        
        return int(self.closing_balance / daily_burn)
    
    @computed_field
    @property
    def operating_cash_ratio(self) -> Decimal:
        """Calculate operating cash flow ratio."""
        if self.total_outflows == 0:
            return Decimal("0.00")
        return round(
            (self.total_inflows / self.total_outflows) * 100,
            2
        )


class FinancialReport(BaseSchema):
    """
    Comprehensive financial report.
    
    Consolidates P&L, cashflow, and key financial metrics
    into a single comprehensive financial statement.
    """
    
    scope_type: str = Field(
        ...,
        pattern="^(hostel|platform)$",
        description="Report scope"
    )
    scope_id: Optional[UUID] = Field(
        None,
        description="Hostel ID if applicable"
    )
    scope_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Display name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Reporting period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Core financial statements
    pnl_report: ProfitAndLossReport = Field(
        ...,
        description="Profit & Loss statement"
    )
    cashflow: CashflowSummary = Field(
        ...,
        description="Cashflow analysis"
    )
    
    # Key metrics
    collection_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of billed amount collected"
    )
    overdue_ratio: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of amount that is overdue"
    )
    avg_revenue_per_student: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average revenue per student"
    )
    avg_revenue_per_bed: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average revenue per bed"
    )
    
    # Operational metrics
    occupancy_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average occupancy rate during period"
    )
    average_daily_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Average daily rate (ADR) charged"
    )
    
    # Year-over-year comparison
    revenue_growth_yoy: Optional[Decimal] = Field(
        None,
        decimal_places=2,
        description="Year-over-year revenue growth percentage"
    )
    profit_growth_yoy: Optional[Decimal] = Field(
        None,
        decimal_places=2,
        description="Year-over-year profit growth percentage"
    )
    
    @computed_field
    @property
    def financial_health_score(self) -> Decimal:
        """
        Calculate overall financial health score (0-100).
        
        Based on profitability, cashflow, and collection metrics.
        """
        score = Decimal("0.00")
        
        # Profitability (40 points)
        if self.pnl_report.is_profitable:
            profit_margin = self.pnl_report.net_profit_margin
            if profit_margin >= 20:
                score += Decimal("40")
            elif profit_margin >= 10:
                score += Decimal("30")
            elif profit_margin >= 5:
                score += Decimal("20")
            else:
                score += Decimal("10")
        
        # Cashflow (30 points)
        if self.cashflow.cashflow_health == "excellent":
            score += Decimal("30")
        elif self.cashflow.cashflow_health == "good":
            score += Decimal("20")
        elif self.cashflow.cashflow_health == "warning":
            score += Decimal("10")
        
        # Collections (30 points)
        if self.collection_rate >= 95:
            score += Decimal("30")
        elif self.collection_rate >= 85:
            score += Decimal("20")
        elif self.collection_rate >= 75:
            score += Decimal("10")
        
        return round(score, 2)
    
    @computed_field
    @property
    def performance_grade(self) -> str:
        """Get letter grade for financial performance."""
        score = float(self.financial_health_score)
        
        if score >= 90:
            return "A+"
        elif score >= 80:
            return "A"
        elif score >= 70:
            return "B"
        elif score >= 60:
            return "C"
        elif score >= 50:
            return "D"
        else:
            return "F"
    
    def get_executive_summary(self) -> Dict[str, any]:
        """
        Generate executive summary of financial performance.
        
        Returns:
            Dictionary with key insights for executive review
        """
        return {
            "period": {
                "start": self.period.start_date,
                "end": self.period.end_date,
            },
            "revenue": {
                "total": float(self.pnl_report.revenue.total_revenue),
                "growth_yoy": float(self.revenue_growth_yoy) if self.revenue_growth_yoy else None,
                "per_student": float(self.avg_revenue_per_student),
                "collection_rate": float(self.collection_rate),
            },
            "profitability": {
                "net_profit": float(self.pnl_report.net_profit),
                "margin": float(self.pnl_report.net_profit_margin),
                "status": self.pnl_report.ratios.profitability_status if self.pnl_report.ratios else "unknown",
            },
            "cashflow": {
                "closing_balance": float(self.cashflow.closing_balance),
                "net_flow": float(self.cashflow.net_cashflow),
                "health": self.cashflow.cashflow_health,
            },
            "overall": {
                "health_score": float(self.financial_health_score),
                "grade": self.performance_grade,
            },
        }

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\occupancy_analytics.py ---
# --- File: app/schemas/analytics/occupancy_analytics.py ---
"""
Occupancy analytics schemas with forecasting capabilities.

Provides detailed occupancy metrics including:
- Current and historical occupancy rates
- Room type and floor-wise breakdowns
- Occupancy trends and patterns
- Predictive forecasting
- Capacity utilization analysis
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from enum import Enum

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import RoomType
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "ForecastModel",
    "OccupancyKPI",
    "OccupancyTrendPoint",
    "OccupancyByRoomType",
    "OccupancyByFloor",
    "ForecastPoint",
    "ForecastData",
    "SeasonalPattern",
    "OccupancyReport",
]


class ForecastModel(str, Enum):
    """Forecasting model types."""
    
    MOVING_AVERAGE = "moving_average"
    EXPONENTIAL_SMOOTHING = "exponential_smoothing"
    ARIMA = "arima"
    LINEAR_REGRESSION = "linear_regression"
    SIMPLE_EXTRAPOLATION = "simple_extrapolation"
    ML_BASED = "ml_based"


class OccupancyKPI(BaseSchema):
    """
    Key occupancy metrics and performance indicators.
    
    Provides comprehensive occupancy statistics for capacity
    planning and performance monitoring.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel identifier. None for platform-wide metrics"
    )
    hostel_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    # Current state
    current_occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Current occupancy rate"
    )
    
    # Period averages
    average_occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average occupancy rate over the period"
    )
    peak_occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Peak occupancy rate in the period"
    )
    low_occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Lowest occupancy rate in the period"
    )
    
    # Capacity metrics
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total bed capacity"
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Currently occupied beds"
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Currently available beds"
    )
    reserved_beds: int = Field(
        0,
        ge=0,
        description="Beds reserved but not yet occupied"
    )
    maintenance_beds: int = Field(
        0,
        ge=0,
        description="Beds under maintenance"
    )
    
    # Utilization metrics
    utilization_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Actual utilization rate (occupied / available)"
    )
    turnover_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Bed turnover rate (check-ins + check-outs)"
    )
    
    @field_validator("occupied_beds", "available_beds", "reserved_beds", "maintenance_beds")
    @classmethod
    def validate_bed_counts(cls, v: int, info) -> int:
        """Validate bed counts are consistent with total."""
        if "total_beds" in info.data:
            total = info.data["total_beds"]
            if v > total:
                raise ValueError(f"{info.field_name} cannot exceed total_beds")
        return v
    
    @model_validator(mode="after")
    def validate_bed_allocation(self) -> "OccupancyKPI":
        """Validate that bed allocation is consistent."""
        allocated = (
            self.occupied_beds +
            self.available_beds +
            self.maintenance_beds
        )
        
        # Allow some flexibility for concurrent updates
        if allocated > self.total_beds + 1:
            raise ValueError(
                f"Allocated beds ({allocated}) exceeds total_beds ({self.total_beds})"
            )
        
        return self
    
    @computed_field
    @property
    def occupancy_status(self) -> str:
        """
        Classify occupancy status.
        
        Returns:
            'high', 'optimal', 'low', or 'critical'
        """
        rate = float(self.current_occupancy_percentage)
        
        if rate >= 90:
            return "high"
        elif rate >= 70:
            return "optimal"
        elif rate >= 50:
            return "moderate"
        elif rate >= 30:
            return "low"
        else:
            return "critical"
    
    @computed_field
    @property
    def capacity_pressure(self) -> Decimal:
        """
        Calculate capacity pressure score (0-100).
        
        Higher score indicates higher pressure on capacity.
        """
        if self.total_beds == 0:
            return Decimal("0.00")
        
        # Consider both current occupancy and reserved beds
        pressure_beds = self.occupied_beds + self.reserved_beds
        pressure_rate = (Decimal(pressure_beds) / Decimal(self.total_beds)) * 100
        
        return round(min(pressure_rate, Decimal("100.00")), 2)
    
    @computed_field
    @property
    def vacancy_rate(self) -> Decimal:
        """Calculate vacancy rate."""
        return round(Decimal("100.00") - self.current_occupancy_percentage, 2)


class OccupancyTrendPoint(BaseSchema):
    """
    Single data point in occupancy trend analysis.
    
    Represents occupancy metrics for a specific date.
    """
    
    date: date = Field(
        ...,
        description="Date of the data point"
    )
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Occupancy rate for this date"
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Number of occupied beds"
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds available"
    )
    check_ins: int = Field(
        0,
        ge=0,
        description="Number of check-ins on this date"
    )
    check_outs: int = Field(
        0,
        ge=0,
        description="Number of check-outs on this date"
    )
    
    @field_validator("occupied_beds")
    @classmethod
    def validate_occupied_beds(cls, v: int, info) -> int:
        """Validate occupied beds don't exceed total."""
        if "total_beds" in info.data and v > info.data["total_beds"]:
            raise ValueError("occupied_beds cannot exceed total_beds")
        return v
    
    @computed_field
    @property
    def net_change(self) -> int:
        """Calculate net change in occupancy for the day."""
        return self.check_ins - self.check_outs


class OccupancyByRoomType(BaseSchema):
    """
    Occupancy breakdown by room type.
    
    Provides granular occupancy metrics for each room type
    to identify optimization opportunities.
    """
    
    room_type: RoomType = Field(
        ...,
        description="Room type category"
    )
    room_type_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Human-readable room type name"
    )
    
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total rooms of this type"
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds in this room type"
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Occupied beds in this room type"
    )
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Occupancy rate for this room type"
    )
    
    # Revenue metrics
    average_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Average rate charged for this room type"
    )
    revenue_generated: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Total revenue from this room type"
    )
    
    @field_validator("occupied_beds")
    @classmethod
    def validate_occupied_beds(cls, v: int, info) -> int:
        """Validate occupied beds don't exceed total."""
        if "total_beds" in info.data and v > info.data["total_beds"]:
            raise ValueError("occupied_beds cannot exceed total_beds")
        return v
    
    @computed_field
    @property
    def available_beds(self) -> int:
        """Calculate available beds."""
        return self.total_beds - self.occupied_beds
    
    @computed_field
    @property
    def revenue_per_bed(self) -> Optional[Decimal]:
        """Calculate revenue per bed."""
        if self.revenue_generated is None or self.total_beds == 0:
            return None
        return round(self.revenue_generated / Decimal(self.total_beds), 2)


class OccupancyByFloor(BaseSchema):
    """
    Occupancy breakdown by floor.
    
    Provides floor-wise occupancy metrics for facility management.
    """
    
    floor_number: int = Field(
        ...,
        description="Floor number"
    )
    floor_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Floor name/identifier"
    )
    
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total rooms on this floor"
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds on this floor"
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Occupied beds on this floor"
    )
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Occupancy rate for this floor"
    )
    
    @field_validator("occupied_beds")
    @classmethod
    def validate_occupied_beds(cls, v: int, info) -> int:
        """Validate occupied beds don't exceed total."""
        if "total_beds" in info.data and v > info.data["total_beds"]:
            raise ValueError("occupied_beds cannot exceed total_beds")
        return v


class ForecastPoint(BaseSchema):
    """
    Single forecast data point.
    
    Represents predicted occupancy for a future date.
    """
    
    date: date = Field(
        ...,
        description="Forecast date"
    )
    forecasted_occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Predicted occupancy rate"
    )
    forecasted_occupied_beds: int = Field(
        ...,
        ge=0,
        description="Predicted number of occupied beds"
    )
    
    # Confidence intervals
    lower_bound: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Lower confidence bound"
    )
    upper_bound: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Upper confidence bound"
    )
    confidence_level: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Confidence level (e.g., 95%)"
    )
    
    @model_validator(mode="after")
    def validate_bounds(self) -> "ForecastPoint":
        """Validate confidence bounds are reasonable."""
        if self.lower_bound is not None and self.upper_bound is not None:
            if self.lower_bound > self.forecasted_occupancy_percentage:
                raise ValueError("lower_bound cannot exceed forecasted value")
            if self.upper_bound < self.forecasted_occupancy_percentage:
                raise ValueError("upper_bound cannot be less than forecasted value")
            if self.lower_bound > self.upper_bound:
                raise ValueError("lower_bound cannot exceed upper_bound")
        
        return self


class SeasonalPattern(BaseSchema):
    """
    Identified seasonal occupancy pattern.
    
    Describes recurring occupancy patterns for planning.
    """
    
    pattern_name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Pattern identifier (e.g., 'Summer Peak', 'Winter Low')"
    )
    start_month: int = Field(
        ...,
        ge=1,
        le=12,
        description="Starting month of the pattern"
    )
    end_month: int = Field(
        ...,
        ge=1,
        le=12,
        description="Ending month of the pattern"
    )
    average_occupancy: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average occupancy during this pattern"
    )
    occupancy_variance: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Variance in occupancy during this pattern"
    )
    confidence: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Confidence in pattern identification"
    )
    
    @computed_field
    @property
    def is_high_season(self) -> bool:
        """Check if this is a high-occupancy season."""
        return self.average_occupancy >= 80


class ForecastData(BaseSchema):
    """
    Occupancy forecast data with model information.
    
    Provides predicted occupancy with metadata about
    the forecasting methodology and confidence.
    """
    
    forecast_horizon_days: int = Field(
        ...,
        ge=1,
        le=365,
        description="Number of days forecasted into the future"
    )
    forecast_points: List[ForecastPoint] = Field(
        ...,
        min_length=1,
        description="Forecast data points"
    )
    
    # Model information
    model_used: ForecastModel = Field(
        ...,
        description="Forecasting model used"
    )
    model_accuracy: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Historical model accuracy percentage"
    )
    confidence_interval: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Confidence interval for forecasts (e.g., 95%)"
    )
    
    # Training data info
    training_data_start: Optional[date] = Field(
        None,
        description="Start date of training data"
    )
    training_data_end: Optional[date] = Field(
        None,
        description="End date of training data"
    )
    training_samples: Optional[int] = Field(
        None,
        ge=0,
        description="Number of data points used for training"
    )
    
    # Seasonality
    seasonal_patterns: List[SeasonalPattern] = Field(
        default_factory=list,
        description="Identified seasonal patterns"
    )
    
    # Metadata
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Forecast generation timestamp"
    )
    last_updated: Optional[datetime] = Field(
        None,
        description="Last update timestamp"
    )
    
    @field_validator("forecast_points")
    @classmethod
    def validate_forecast_chronological(
        cls,
        v: List[ForecastPoint]
    ) -> List[ForecastPoint]:
        """Ensure forecast points are in chronological order."""
        if len(v) > 1:
            dates = [point.date for point in v]
            if dates != sorted(dates):
                raise ValueError("Forecast points must be in chronological order")
        return v
    
    @model_validator(mode="after")
    def validate_horizon_matches_points(self) -> "ForecastData":
        """Validate forecast horizon matches number of points."""
        if self.forecast_points:
            # Allow some tolerance
            if abs(len(self.forecast_points) - self.forecast_horizon_days) > 1:
                raise ValueError(
                    f"Number of forecast points ({len(self.forecast_points)}) "
                    f"should match horizon ({self.forecast_horizon_days})"
                )
        return self
    
    @computed_field
    @property
    def average_forecasted_occupancy(self) -> Decimal:
        """Calculate average forecasted occupancy."""
        if not self.forecast_points:
            return Decimal("0.00")
        
        total = sum(p.forecasted_occupancy_percentage for p in self.forecast_points)
        return round(total / len(self.forecast_points), 2)
    
    @computed_field
    @property
    def peak_forecasted_date(self) -> Optional[date]:
        """Identify date with highest forecasted occupancy."""
        if not self.forecast_points:
            return None
        return max(
            self.forecast_points,
            key=lambda x: x.forecasted_occupancy_percentage
        ).date
    
    @computed_field
    @property
    def low_forecasted_date(self) -> Optional[date]:
        """Identify date with lowest forecasted occupancy."""
        if not self.forecast_points:
            return None
        return min(
            self.forecast_points,
            key=lambda x: x.forecasted_occupancy_percentage
        ).date


class OccupancyReport(BaseSchema):
    """
    Comprehensive occupancy analytics report.
    
    Consolidates current metrics, historical trends,
    breakdowns, and forecasts into a complete occupancy view.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel identifier. None for platform-wide report"
    )
    hostel_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Core metrics
    kpi: OccupancyKPI = Field(
        ...,
        description="Key performance indicators"
    )
    
    # Trends
    daily_trend: List[OccupancyTrendPoint] = Field(
        default_factory=list,
        description="Daily occupancy trend data"
    )
    
    # Breakdowns
    by_room_type: List[OccupancyByRoomType] = Field(
        default_factory=list,
        description="Occupancy by room type"
    )
    by_floor: List[OccupancyByFloor] = Field(
        default_factory=list,
        description="Occupancy by floor"
    )
    
    # Legacy support
    by_floor_dict: Dict[int, OccupancyKPI] = Field(
        default_factory=dict,
        description="Floor occupancy dict (deprecated: use by_floor)"
    )
    
    # Forecast
    forecast: Optional[ForecastData] = Field(
        None,
        description="Occupancy forecast"
    )
    
    # Seasonal patterns
    seasonal_patterns: List[SeasonalPattern] = Field(
        default_factory=list,
        description="Identified seasonal patterns"
    )
    
    @field_validator("daily_trend")
    @classmethod
    def validate_trend_chronological(
        cls,
        v: List[OccupancyTrendPoint]
    ) -> List[OccupancyTrendPoint]:
        """Ensure trend points are chronological."""
        if len(v) > 1:
            dates = [point.date for point in v]
            if dates != sorted(dates):
                raise ValueError("Trend points must be in chronological order")
        return v
    
    @computed_field
    @property
    def best_performing_room_type(self) -> Optional[RoomType]:
        """Identify room type with highest occupancy."""
        if not self.by_room_type:
            return None
        return max(
            self.by_room_type,
            key=lambda x: x.occupancy_percentage
        ).room_type
    
    @computed_field
    @property
    def worst_performing_room_type(self) -> Optional[RoomType]:
        """Identify room type with lowest occupancy."""
        if not self.by_room_type:
            return None
        return min(
            self.by_room_type,
            key=lambda x: x.occupancy_percentage
        ).room_type
    
    @computed_field
    @property
    def occupancy_trend_direction(self) -> str:
        """
        Determine overall trend direction.
        
        Returns:
            'increasing', 'decreasing', or 'stable'
        """
        if len(self.daily_trend) < 2:
            return "stable"
        
        first_half = self.daily_trend[:len(self.daily_trend)//2]
        second_half = self.daily_trend[len(self.daily_trend)//2:]
        
        first_avg = sum(
            p.occupancy_percentage for p in first_half
        ) / len(first_half)
        second_avg = sum(
            p.occupancy_percentage for p in second_half
        ) / len(second_half)
        
        change = float(second_avg - first_avg)
        
        if change > 5:
            return "increasing"
        elif change < -5:
            return "decreasing"
        return "stable"
    
    def get_optimization_insights(self) -> List[str]:
        """
        Generate actionable optimization insights.
        
        Returns:
            List of insight strings for improving occupancy
        """
        insights = []
        
        # Overall occupancy check
        if self.kpi.current_occupancy_percentage < 60:
            insights.append(
                f"Current occupancy at {self.kpi.current_occupancy_percentage}% - "
                "consider targeted marketing campaigns"
            )
        
        # Room type performance
        if self.worst_performing_room_type:
            worst = next(
                (rt for rt in self.by_room_type
                 if rt.room_type == self.worst_performing_room_type),
                None
            )
            if worst and worst.occupancy_percentage < 50:
                insights.append(
                    f"{worst.room_type.value} rooms at {worst.occupancy_percentage}% - "
                    "consider pricing adjustments or promotions"
                )
        
        # Capacity pressure
        if self.kpi.capacity_pressure > 85:
            insights.append(
                f"Capacity pressure at {self.kpi.capacity_pressure}% - "
                "consider expansion or waitlist management"
            )
        
        # Trend analysis
        if self.occupancy_trend_direction == "decreasing":
            insights.append(
                "Occupancy trending downward - investigate causes and take corrective action"
            )
        
        # Forecast insights
        if self.forecast and self.forecast.average_forecasted_occupancy < 60:
            insights.append(
                f"Forecasted occupancy at {self.forecast.average_forecasted_occupancy}% - "
                "plan ahead for low season"
            )
        
        return insights

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\platform_analytics.py ---
# --- File: app/schemas/analytics/platform_analytics.py ---
"""
Platform-wide analytics schemas for super admin oversight.

Provides comprehensive platform metrics including:
- Multi-tenant statistics
- Growth metrics and trends
- Platform usage analytics
- System performance metrics
- Revenue aggregation across tenants
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from enum import Enum

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import SubscriptionPlan, SubscriptionStatus
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "TenantStatus",
    "PlatformMetrics",
    "MonthlyMetric",
    "GrowthMetrics",
    "TenantMetrics",
    "PlatformUsageAnalytics",
    "SystemHealthMetrics",
    "RevenueMetrics",
    "ChurnAnalysis",
]


class TenantStatus(str, Enum):
    """Tenant (hostel) status categories."""
    
    TRIAL = "trial"
    ACTIVE = "active"
    SUSPENDED = "suspended"
    CHURNED = "churned"
    INACTIVE = "inactive"


class TenantMetrics(BaseSchema):
    """
    Metrics for a single tenant (hostel).
    
    Provides individual tenant performance data for
    platform-level aggregation and analysis.
    """
    
    tenant_id: UUID = Field(
        ...,
        description="Hostel/tenant unique identifier"
    )
    tenant_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Tenant display name"
    )
    
    # Subscription info
    subscription_plan: SubscriptionPlan = Field(
        ...,
        description="Current subscription plan"
    )
    subscription_status: SubscriptionStatus = Field(
        ...,
        description="Subscription status"
    )
    subscription_start_date: date = Field(
        ...,
        description="Subscription start date"
    )
    subscription_mrr: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly recurring revenue from this tenant"
    )
    
    # Usage metrics
    total_students: int = Field(
        ...,
        ge=0,
        description="Total students in this hostel"
    )
    active_students: int = Field(
        ...,
        ge=0,
        description="Active students"
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total bed capacity"
    )
    occupancy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Current occupancy rate"
    )
    
    # Activity metrics
    last_login: Optional[datetime] = Field(
        None,
        description="Last admin login timestamp"
    )
    daily_active_users: int = Field(
        0,
        ge=0,
        description="Daily active users (last 24h)"
    )
    monthly_active_users: int = Field(
        0,
        ge=0,
        description="Monthly active users (last 30 days)"
    )
    
    # Health indicators
    payment_status: str = Field(
        ...,
        pattern="^(current|overdue|suspended)$",
        description="Payment status"
    )
    health_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall tenant health score"
    )
    churn_risk_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Churn risk score (higher = higher risk)"
    )
    
    @field_validator("active_students")
    @classmethod
    def validate_active_students(cls, v: int, info) -> int:
        """Validate active students don't exceed total."""
        if "total_students" in info.data and v > info.data["total_students"]:
            raise ValueError("active_students cannot exceed total_students")
        return v
    
    @computed_field
    @property
    def is_at_risk(self) -> bool:
        """Check if tenant is at risk of churning."""
        return self.churn_risk_score >= 70
    
    @computed_field
    @property
    def revenue_per_bed(self) -> Decimal:
        """Calculate revenue per bed."""
        if self.total_beds == 0:
            return Decimal("0.00")
        return round(self.subscription_mrr / Decimal(self.total_beds), 2)
    
    @computed_field
    @property
    def engagement_status(self) -> str:
        """Assess tenant engagement level."""
        if self.last_login is None:
            return "inactive"
        
        days_since_login = (datetime.utcnow() - self.last_login).days
        
        if days_since_login <= 1:
            return "highly_active"
        elif days_since_login <= 7:
            return "active"
        elif days_since_login <= 30:
            return "moderate"
        else:
            return "low"


class PlatformMetrics(BaseSchema):
    """
    High-level platform metrics across all tenants.
    
    Provides aggregate statistics for platform monitoring
    and strategic decision-making.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Reporting period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Tenant metrics
    total_hostels: int = Field(
        ...,
        ge=0,
        description="Total registered hostels"
    )
    active_hostels: int = Field(
        ...,
        ge=0,
        description="Currently active hostels"
    )
    hostels_on_trial: int = Field(
        ...,
        ge=0,
        description="Hostels on trial period"
    )
    suspended_hostels: int = Field(
        0,
        ge=0,
        description="Suspended hostels"
    )
    churned_hostels: int = Field(
        0,
        ge=0,
        description="Churned hostels in period"
    )
    
    # User metrics
    total_users: int = Field(
        ...,
        ge=0,
        description="Total registered users across platform"
    )
    total_students: int = Field(
        ...,
        ge=0,
        description="Total students"
    )
    total_supervisors: int = Field(
        ...,
        ge=0,
        description="Total supervisors"
    )
    total_admins: int = Field(
        ...,
        ge=0,
        description="Total hostel admins"
    )
    total_visitors: int = Field(
        0,
        ge=0,
        description="Total visitors/prospects"
    )
    
    # Engagement metrics
    avg_daily_active_users: int = Field(
        ...,
        ge=0,
        description="Average daily active users"
    )
    avg_monthly_active_users: int = Field(
        0,
        ge=0,
        description="Average monthly active users"
    )
    peak_concurrent_sessions: int = Field(
        0,
        ge=0,
        description="Peak concurrent sessions in period"
    )
    
    # Capacity metrics
    total_beds_platform: int = Field(
        0,
        ge=0,
        description="Total bed capacity across all hostels"
    )
    total_occupied_beds: int = Field(
        0,
        ge=0,
        description="Total occupied beds platform-wide"
    )
    platform_occupancy_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Platform-wide occupancy rate"
    )
    
    @field_validator(
        "active_hostels",
        "hostels_on_trial",
        "suspended_hostels"
    )
    @classmethod
    def validate_hostel_counts(cls, v: int, info) -> int:
        """Validate hostel segment counts."""
        if "total_hostels" in info.data:
            total = info.data["total_hostels"]
            # Allow some flexibility as counts may overlap during transitions
            if v > total:
                raise ValueError(f"{info.field_name} cannot exceed total_hostels")
        return v
    
    @computed_field
    @property
    def activation_rate(self) -> Decimal:
        """Calculate percentage of hostels that are active."""
        if self.total_hostels == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.active_hostels) / Decimal(self.total_hostels)) * 100,
            2
        )
    
    @computed_field
    @property
    def trial_conversion_potential(self) -> int:
        """Estimate potential conversions from trial hostels."""
        # Assume 60% trial conversion rate
        return int(self.hostels_on_trial * 0.6)
    
    @computed_field
    @property
    def user_growth_rate(self) -> Optional[Decimal]:
        """Calculate user growth rate if previous period data available."""
        # This would need previous period data - placeholder
        return None


class MonthlyMetric(BaseSchema):
    """
    Monthly metric data point for trend analysis.
    
    Represents a single metric value for a specific month.
    """
    
    month: str = Field(
        ...,
        pattern=r"^\d{4}-(0[1-9]|1[0-2])$",
        description="Month in YYYY-MM format"
    )
    value: Union[Decimal, int, float] = Field(
        ...,
        description="Metric value for the month"
    )
    label: Optional[str] = Field(
        None,
        max_length=100,
        description="Optional display label"
    )
    
    @computed_field
    @property
    def month_name(self) -> str:
        """Get human-readable month name."""
        try:
            year, month = self.month.split("-")
            dt = datetime(int(year), int(month), 1)
            return dt.strftime("%B %Y")
        except (ValueError, AttributeError):
            return self.month


class GrowthMetrics(BaseSchema):
    """
    Growth metrics and trends over time.
    
    Provides detailed growth analysis across key dimensions
    for strategic planning and investor reporting.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    
    # Hostel growth
    new_hostels: int = Field(
        ...,
        ge=0,
        description="New hostels added in period"
    )
    churned_hostels: int = Field(
        ...,
        ge=0,
        description="Hostels churned in period"
    )
    net_hostel_growth: int = Field(
        ...,
        description="Net change in hostel count"
    )
    hostel_growth_rate: Decimal = Field(
        ...,
        decimal_places=2,
        description="Hostel growth rate percentage"
    )
    
    # Revenue growth
    total_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total revenue for period"
    )
    previous_period_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Revenue from previous period"
    )
    revenue_growth_amount: Decimal = Field(
        ...,
        decimal_places=2,
        description="Absolute revenue growth"
    )
    revenue_growth_rate: Decimal = Field(
        ...,
        decimal_places=2,
        description="Revenue growth rate percentage"
    )
    
    # User growth
    new_users: int = Field(
        ...,
        ge=0,
        description="New users registered in period"
    )
    churned_users: int = Field(
        0,
        ge=0,
        description="Users churned in period"
    )
    net_user_growth: int = Field(
        ...,
        description="Net change in user count"
    )
    user_growth_rate: Decimal = Field(
        ...,
        decimal_places=2,
        description="User growth rate percentage"
    )
    
    # MRR (Monthly Recurring Revenue) growth
    current_mrr: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Current monthly recurring revenue"
    )
    previous_mrr: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Previous period MRR"
    )
    mrr_growth_rate: Decimal = Field(
        ...,
        decimal_places=2,
        description="MRR growth rate percentage"
    )
    
    # Time series data
    monthly_revenue: List[MonthlyMetric] = Field(
        default_factory=list,
        description="Monthly revenue trend"
    )
    monthly_new_hostels: List[MonthlyMetric] = Field(
        default_factory=list,
        description="Monthly new hostel acquisitions"
    )
    monthly_new_users: List[MonthlyMetric] = Field(
        default_factory=list,
        description="Monthly new user registrations"
    )
    monthly_mrr: List[MonthlyMetric] = Field(
        default_factory=list,
        description="Monthly MRR trend"
    )
    
    @model_validator(mode="after")
    def validate_growth_calculations(self) -> "GrowthMetrics":
        """Validate growth calculations are consistent."""
        
        # Net hostel growth
        expected_net = self.new_hostels - self.churned_hostels
        if self.net_hostel_growth != expected_net:
            raise ValueError(
                f"net_hostel_growth ({self.net_hostel_growth}) should equal "
                f"new_hostels ({self.new_hostels}) - churned_hostels ({self.churned_hostels})"
            )
        
        # Revenue growth
        expected_revenue_growth = self.total_revenue - self.previous_period_revenue
        if abs(self.revenue_growth_amount - expected_revenue_growth) > Decimal("0.01"):
            raise ValueError(
                "revenue_growth_amount should equal total_revenue - previous_period_revenue"
            )
        
        return self
    
    @computed_field
    @property
    def is_growing(self) -> bool:
        """Check if platform is growing across key metrics."""
        return (
            self.net_hostel_growth > 0 and
            self.revenue_growth_rate > 0 and
            self.user_growth_rate > 0
        )
    
    @computed_field
    @property
    def growth_health_score(self) -> Decimal:
        """
        Calculate overall growth health score (0-100).
        
        Weighted combination of hostel, revenue, and user growth.
        """
        weights = {
            "hostel": Decimal("0.3"),
            "revenue": Decimal("0.5"),
            "user": Decimal("0.2"),
        }
        
        # Normalize growth rates to 0-100 scale
        hostel_score = min(max(self.hostel_growth_rate, Decimal("0")), Decimal("100"))
        revenue_score = min(max(self.revenue_growth_rate, Decimal("0")), Decimal("100"))
        user_score = min(max(self.user_growth_rate, Decimal("0")), Decimal("100"))
        
        score = (
            hostel_score * weights["hostel"] +
            revenue_score * weights["revenue"] +
            user_score * weights["user"]
        )
        
        return round(score, 2)
    
    @computed_field
    @property
    def compound_annual_growth_rate(self) -> Optional[Decimal]:
        """
        Calculate CAGR if sufficient historical data available.
        
        Requires at least 12 months of revenue data.
        """
        if len(self.monthly_revenue) < 12:
            return None
        
        beginning_value = float(self.monthly_revenue[0].value)
        ending_value = float(self.monthly_revenue[-1].value)
        periods = len(self.monthly_revenue) / 12  # Convert to years
        
        if beginning_value <= 0 or periods <= 0:
            return None
        
        cagr = ((ending_value / beginning_value) ** (1 / periods) - 1) * 100
        return round(Decimal(str(cagr)), 2)


class ChurnAnalysis(BaseSchema):
    """
    Customer churn analysis and prediction.
    
    Provides insights into churn patterns and at-risk tenants.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    
    # Churn metrics
    churned_count: int = Field(
        ...,
        ge=0,
        description="Number of churned tenants in period"
    )
    churn_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Churn rate percentage"
    )
    revenue_churned: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="MRR lost to churn"
    )
    
    # Churn reasons
    churn_reasons: Dict[str, int] = Field(
        default_factory=dict,
        description="Churn count by reason"
    )
    
    # At-risk analysis
    at_risk_count: int = Field(
        ...,
        ge=0,
        description="Number of tenants at risk of churning"
    )
    at_risk_tenants: List[TenantMetrics] = Field(
        default_factory=list,
        description="Details of at-risk tenants"
    )
    
    # Retention metrics
    retention_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Retention rate percentage"
    )
    
    @computed_field
    @property
    def top_churn_reason(self) -> Optional[str]:
        """Identify most common churn reason."""
        if not self.churn_reasons:
            return None
        return max(self.churn_reasons, key=self.churn_reasons.get)
    
    @computed_field
    @property
    def churn_risk_status(self) -> str:
        """Assess overall churn risk status."""
        if self.churn_rate <= 3:
            return "low"
        elif self.churn_rate <= 7:
            return "moderate"
        elif self.churn_rate <= 12:
            return "high"
        else:
            return "critical"


class SystemHealthMetrics(BaseSchema):
    """
    Platform system health and performance metrics.
    
    Tracks technical performance, reliability, and capacity.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Monitoring period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Availability
    uptime_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=4,
        description="System uptime percentage"
    )
    downtime_minutes: int = Field(
        ...,
        ge=0,
        description="Total downtime in minutes"
    )
    incident_count: int = Field(
        0,
        ge=0,
        description="Number of incidents in period"
    )
    
    # Performance
    average_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average API response time in milliseconds"
    )
    p50_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="50th percentile response time"
    )
    p95_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="95th percentile response time"
    )
    p99_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="99th percentile response time"
    )
    
    # Error rates
    error_rate_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=4,
        description="Overall error rate percentage"
    )
    server_error_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=4,
        description="5xx error rate percentage"
    )
    client_error_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=4,
        description="4xx error rate percentage"
    )
    
    # Resource utilization
    avg_cpu_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average CPU usage percentage"
    )
    peak_cpu_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Peak CPU usage"
    )
    avg_memory_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average memory usage percentage"
    )
    peak_memory_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Peak memory usage"
    )
    
    # Database performance
    avg_db_query_time_ms: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Average database query time"
    )
    slow_query_count: Optional[int] = Field(
        None,
        ge=0,
        description="Number of slow queries (>1s)"
    )
    
    @computed_field
    @property
    def health_status(self) -> str:
        """Overall system health status."""
        if self.uptime_percentage >= 99.9 and self.error_rate_percentage <= 0.1:
            return "excellent"
        elif self.uptime_percentage >= 99.5 and self.error_rate_percentage <= 0.5:
            return "good"
        elif self.uptime_percentage >= 99.0 and self.error_rate_percentage <= 1.0:
            return "fair"
        else:
            return "poor"
    
    @computed_field
    @property
    def performance_grade(self) -> str:
        """Performance grade based on response times."""
        avg_time = float(self.average_response_time_ms)
        
        if avg_time <= 100:
            return "A"
        elif avg_time <= 200:
            return "B"
        elif avg_time <= 500:
            return "C"
        elif avg_time <= 1000:
            return "D"
        else:
            return "F"


class RevenueMetrics(BaseSchema):
    """
    Platform-wide revenue metrics and analysis.
    
    Aggregates revenue data across all tenants for
    financial planning and reporting.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Revenue period"
    )
    
    # Total revenue
    total_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total platform revenue"
    )
    subscription_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Revenue from subscriptions"
    )
    transaction_fees: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Revenue from transaction fees"
    )
    other_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Other revenue sources"
    )
    
    # MRR metrics
    mrr: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly Recurring Revenue"
    )
    arr: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Annual Recurring Revenue"
    )
    
    # Revenue by plan
    revenue_by_plan: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Revenue breakdown by subscription plan"
    )
    
    # Customer metrics
    arpu: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average Revenue Per User (monthly)"
    )
    ltv: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Lifetime Value estimate"
    )
    
    # Cohort analysis
    new_customer_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Revenue from new customers"
    )
    expansion_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Revenue from upgrades/expansion"
    )
    churned_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Revenue lost to churn"
    )
    
    @computed_field
    @property
    def revenue_diversity_score(self) -> Decimal:
        """
        Calculate revenue diversification score (0-100).
        
        Higher score indicates better diversification across plans.
        """
        if not self.revenue_by_plan or self.total_revenue == 0:
            return Decimal("0.00")
        
        # Calculate Herfindahl index (lower = more diverse)
        total = float(self.total_revenue)
        herfindahl = sum(
            (float(rev) / total) ** 2
            for rev in self.revenue_by_plan.values()
        )
        
        # Convert to 0-100 scale (invert so higher is better)
        diversity = (1 - herfindahl) * 100
        return round(Decimal(str(diversity)), 2)
    
    @computed_field
    @property
    def net_new_mrr(self) -> Decimal:
        """Calculate net new MRR."""
        return (
            self.new_customer_revenue +
            self.expansion_revenue -
            self.churned_revenue
        )


class PlatformUsageAnalytics(BaseSchema):
    """
    Platform usage and engagement analytics.
    
    Tracks how tenants and users interact with the platform
    for product optimization and support planning.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Traffic metrics
    total_requests: int = Field(
        ...,
        ge=0,
        description="Total API requests in period"
    )
    unique_sessions: int = Field(
        ...,
        ge=0,
        description="Unique user sessions"
    )
    avg_requests_per_minute: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average requests per minute"
    )
    peak_requests_per_minute: int = Field(
        0,
        ge=0,
        description="Peak requests per minute"
    )
    
    # Error tracking
    api_error_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=4,
        description="API error rate percentage"
    )
    total_errors: int = Field(
        0,
        ge=0,
        description="Total error count"
    )
    
    # Module usage
    requests_by_module: Dict[str, int] = Field(
        default_factory=dict,
        description="Request count by module/feature"
    )
    
    # Feature adoption
    feature_adoption_rates: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Adoption rate by feature (%)"
    )
    
    # Performance
    avg_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average response time"
    )
    p95_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="95th percentile response time"
    )
    p99_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="99th percentile response time"
    )
    
    # Resource usage
    avg_cpu_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average CPU usage"
    )
    avg_memory_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average memory usage"
    )
    
    # Storage
    total_storage_used_gb: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Total storage used in GB"
    )
    avg_storage_per_tenant_gb: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Average storage per tenant"
    )
    
    @computed_field
    @property
    def most_used_module(self) -> Optional[str]:
        """Identify most frequently used module."""
        if not self.requests_by_module:
            return None
        return max(self.requests_by_module, key=self.requests_by_module.get)
    
    @computed_field
    @property
    def least_adopted_features(self) -> List[str]:
        """Identify features with low adoption (< 20%)."""
        return [
            feature for feature, rate in self.feature_adoption_rates.items()
            if rate < 20
        ]
    
    @computed_field
    @property
    def platform_health_indicator(self) -> str:
        """Overall platform health indicator."""
        if (
            self.api_error_rate <= 0.1 and
            float(self.avg_response_time_ms) <= 200
        ):
            return "healthy"
        elif (
            self.api_error_rate <= 0.5 and
            float(self.avg_response_time_ms) <= 500
        ):
            return "stable"
        elif (
            self.api_error_rate <= 1.0 and
            float(self.avg_response_time_ms) <= 1000
        ):
            return "degraded"
        else:
            return "critical"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\supervisor_analytics.py ---
# --- File: app/schemas/analytics/supervisor_analytics.py ---
"""
Supervisor analytics schemas for performance tracking.

Provides comprehensive supervisor metrics including:
- Individual performance KPIs
- Workload distribution
- Resolution efficiency
- Comparative benchmarking
- Student feedback integration
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "SupervisorKPI",
    "SupervisorTrendPoint",
    "SupervisorDashboardAnalytics",
    "SupervisorComparison",
    "SupervisorWorkload",
    "SupervisorPerformanceRating",
    "TeamAnalytics",
]


class SupervisorWorkload(BaseSchema):
    """
    Supervisor workload metrics.
    
    Tracks task distribution and capacity utilization
    for resource planning and balancing.
    """
    
    # Current workload
    active_complaints: int = Field(
        ...,
        ge=0,
        description="Currently assigned complaints"
    )
    active_maintenance: int = Field(
        ...,
        ge=0,
        description="Currently assigned maintenance tasks"
    )
    pending_tasks: int = Field(
        ...,
        ge=0,
        description="Total pending tasks"
    )
    
    # Capacity
    max_capacity: int = Field(
        ...,
        ge=1,
        description="Maximum concurrent task capacity"
    )
    current_utilization: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Current capacity utilization percentage"
    )
    
    # Task types
    urgent_tasks: int = Field(
        0,
        ge=0,
        description="Number of urgent/critical tasks"
    )
    overdue_tasks: int = Field(
        0,
        ge=0,
        description="Number of overdue tasks"
    )
    
    @computed_field
    @property
    def available_capacity(self) -> int:
        """Calculate available capacity."""
        return max(0, self.max_capacity - self.pending_tasks)
    
    @computed_field
    @property
    def workload_status(self) -> str:
        """Assess workload status."""
        if self.current_utilization >= 100:
            return "overloaded"
        elif self.current_utilization >= 80:
            return "high"
        elif self.current_utilization >= 50:
            return "moderate"
        else:
            return "low"


class SupervisorPerformanceRating(BaseSchema):
    """
    Performance rating breakdown.
    
    Provides detailed scoring across multiple performance dimensions.
    """
    
    # Individual ratings
    efficiency_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Task completion efficiency (0-100)"
    )
    quality_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Work quality score (0-100)"
    )
    responsiveness_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Response time score (0-100)"
    )
    student_satisfaction_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Student feedback score (0-100)"
    )
    reliability_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Reliability and consistency score (0-100)"
    )
    
    # Overall rating
    overall_rating: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Weighted overall performance rating"
    )
    
    @computed_field
    @property
    def performance_grade(self) -> str:
        """Get letter grade for overall performance."""
        rating = float(self.overall_rating)
        
        if rating >= 90:
            return "A"
        elif rating >= 80:
            return "B"
        elif rating >= 70:
            return "C"
        elif rating >= 60:
            return "D"
        else:
            return "F"
    
    @computed_field
    @property
    def strengths(self) -> List[str]:
        """Identify performance strengths (scores >= 85)."""
        scores = {
            "efficiency": self.efficiency_score,
            "quality": self.quality_score,
            "responsiveness": self.responsiveness_score,
            "student_satisfaction": self.student_satisfaction_score,
            "reliability": self.reliability_score,
        }
        return [name for name, score in scores.items() if score >= 85]
    
    @computed_field
    @property
    def improvement_areas(self) -> List[str]:
        """Identify areas needing improvement (scores < 70)."""
        scores = {
            "efficiency": self.efficiency_score,
            "quality": self.quality_score,
            "responsiveness": self.responsiveness_score,
            "student_satisfaction": self.student_satisfaction_score,
            "reliability": self.reliability_score,
        }
        return [name for name, score in scores.items() if score < 70]


class SupervisorKPI(BaseSchema):
    """
    Key Performance Indicators for supervisor.
    
    Comprehensive performance metrics for individual supervisor
    assessment and development planning.
    """
    
    supervisor_id: UUID = Field(
        ...,
        description="Supervisor unique identifier"
    )
    supervisor_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Supervisor name"
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier"
    )
    hostel_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Performance period"
    )
    
    # Workload metrics
    complaints_assigned: int = Field(
        ...,
        ge=0,
        description="Total complaints assigned in period"
    )
    complaints_resolved: int = Field(
        ...,
        ge=0,
        description="Complaints successfully resolved"
    )
    complaints_pending: int = Field(
        0,
        ge=0,
        description="Currently pending complaints"
    )
    
    maintenance_requests_created: int = Field(
        ...,
        ge=0,
        description="Maintenance requests created"
    )
    maintenance_requests_completed: int = Field(
        ...,
        ge=0,
        description="Maintenance requests completed"
    )
    maintenance_pending: int = Field(
        0,
        ge=0,
        description="Currently pending maintenance"
    )
    
    attendance_records_marked: int = Field(
        ...,
        ge=0,
        description="Attendance records marked"
    )
    
    # Performance metrics
    avg_complaint_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average time to resolve complaints (hours)"
    )
    avg_first_response_time_hours: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Average time to first response (hours)"
    )
    avg_maintenance_completion_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average maintenance completion time (hours)"
    )
    
    # SLA compliance
    complaint_sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Complaint SLA compliance percentage"
    )
    maintenance_sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Maintenance SLA compliance percentage"
    )
    
    # Quality metrics
    reopened_complaints: int = Field(
        0,
        ge=0,
        description="Number of complaints reopened"
    )
    escalated_complaints: int = Field(
        0,
        ge=0,
        description="Number of complaints escalated"
    )
    
    # Feedback
    student_feedback_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average student rating (1-5 scale)"
    )
    feedback_count: int = Field(
        0,
        ge=0,
        description="Number of feedback responses received"
    )
    
    # Overall performance
    overall_performance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Composite performance score (0-100)"
    )
    
    # Workload
    workload: Optional[SupervisorWorkload] = Field(
        None,
        description="Current workload metrics"
    )
    
    # Performance ratings
    performance_rating: Optional[SupervisorPerformanceRating] = Field(
        None,
        description="Detailed performance ratings"
    )
    
    @field_validator("complaints_resolved")
    @classmethod
    def validate_resolved_complaints(cls, v: int, info) -> int:
        """Validate resolved count doesn't exceed assigned."""
        if "complaints_assigned" in info.data and v > info.data["complaints_assigned"]:
            # Allow slight excess for complaints from previous periods
            if v > info.data["complaints_assigned"] * 1.2:
                raise ValueError(
                    "complaints_resolved significantly exceeds complaints_assigned"
                )
        return v
    
    @computed_field
    @property
    def complaint_resolution_rate(self) -> Decimal:
        """Calculate complaint resolution rate percentage."""
        if self.complaints_assigned == 0:
            return Decimal("100.00")
        return round(
            (Decimal(self.complaints_resolved) / Decimal(self.complaints_assigned)) * 100,
            2
        )
    
    @computed_field
    @property
    def maintenance_completion_rate(self) -> Decimal:
        """Calculate maintenance completion rate percentage."""
        if self.maintenance_requests_created == 0:
            return Decimal("100.00")
        return round(
            (Decimal(self.maintenance_requests_completed) / 
             Decimal(self.maintenance_requests_created)) * 100,
            2
        )
    
    @computed_field
    @property
    def reopen_rate(self) -> Decimal:
        """Calculate complaint reopen rate."""
        if self.complaints_resolved == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.reopened_complaints) / Decimal(self.complaints_resolved)) * 100,
            2
        )
    
    @computed_field
    @property
    def performance_status(self) -> str:
        """Overall performance status classification."""
        score = float(self.overall_performance_score)
        
        if score >= 85:
            return "excellent"
        elif score >= 70:
            return "good"
        elif score >= 60:
            return "satisfactory"
        elif score >= 50:
            return "needs_improvement"
        else:
            return "unsatisfactory"


class SupervisorTrendPoint(BaseSchema):
    """
    Performance trend data point.
    
    Tracks supervisor performance metrics over time
    for trend analysis and progress monitoring.
    """
    
    period_label: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Period identifier (e.g., 'Week 1', '2024-01')"
    )
    period_start: date = Field(
        ...,
        description="Period start date"
    )
    period_end: date = Field(
        ...,
        description="Period end date"
    )
    
    complaints_resolved: int = Field(
        ...,
        ge=0,
        description="Complaints resolved in period"
    )
    maintenance_completed: int = Field(
        ...,
        ge=0,
        description="Maintenance completed in period"
    )
    performance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Performance score for period"
    )
    student_feedback_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Student feedback score"
    )
    
    @computed_field
    @property
    def total_tasks_completed(self) -> int:
        """Total tasks completed in period."""
        return self.complaints_resolved + self.maintenance_completed


class SupervisorDashboardAnalytics(BaseSchema):
    """
    Supervisor dashboard analytics.
    
    Personalized dashboard view for supervisor performance
    monitoring and self-assessment.
    """
    
    supervisor_id: UUID = Field(
        ...,
        description="Supervisor identifier"
    )
    supervisor_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Supervisor name"
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier"
    )
    hostel_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Dashboard period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Dashboard generation timestamp"
    )
    
    # Core metrics
    kpi: SupervisorKPI = Field(
        ...,
        description="Key performance indicators"
    )
    
    # Trend analysis
    trend: List[SupervisorTrendPoint] = Field(
        default_factory=list,
        description="Performance trend over time"
    )
    
    # Breakdowns
    complaints_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaint count by category"
    )
    maintenance_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Maintenance count by category"
    )
    
    # Goals and targets
    monthly_target_tasks: Optional[int] = Field(
        None,
        ge=0,
        description="Monthly task completion target"
    )
    target_achievement_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Percentage of target achieved"
    )
    
    @field_validator("trend")
    @classmethod
    def validate_trend_chronological(
        cls,
        v: List[SupervisorTrendPoint]
    ) -> List[SupervisorTrendPoint]:
        """Ensure trend points are chronological."""
        if len(v) > 1:
            dates = [point.period_start for point in v]
            if dates != sorted(dates):
                raise ValueError("Trend points must be in chronological order")
        return v
    
    @computed_field
    @property
    def most_common_complaint_category(self) -> Optional[str]:
        """Identify most frequent complaint category."""
        if not self.complaints_by_category:
            return None
        return max(self.complaints_by_category, key=self.complaints_by_category.get)
    
    @computed_field
    @property
    def improvement_trend(self) -> str:
        """Analyze performance improvement trend."""
        if len(self.trend) < 2:
            return "insufficient_data"
        
        scores = [float(point.performance_score) for point in self.trend]
        first_half_avg = sum(scores[:len(scores)//2]) / (len(scores)//2)
        second_half_avg = sum(scores[len(scores)//2:]) / (len(scores) - len(scores)//2)
        
        change = second_half_avg - first_half_avg
        
        if change > 5:
            return "improving"
        elif change < -5:
            return "declining"
        else:
            return "stable"


class SupervisorComparison(BaseSchema):
    """
    Comparative analysis of supervisors.
    
    Enables benchmarking and identification of top performers
    within a hostel or across the platform.
    """
    
    scope_type: str = Field(
        ...,
        pattern="^(hostel|platform)$",
        description="Comparison scope"
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID if scope is hostel"
    )
    hostel_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Comparison period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Supervisor metrics
    supervisors: List[SupervisorKPI] = Field(
        ...,
        min_length=1,
        description="List of supervisor KPIs"
    )
    
    # Rankings
    ranked_by_performance: List[UUID] = Field(
        ...,
        description="Supervisor IDs ranked by overall performance"
    )
    ranked_by_resolution_speed: List[UUID] = Field(
        ...,
        description="Supervisor IDs ranked by resolution speed"
    )
    ranked_by_feedback_score: List[UUID] = Field(
        ...,
        description="Supervisor IDs ranked by student feedback"
    )
    ranked_by_sla_compliance: List[UUID] = Field(
        default_factory=list,
        description="Supervisor IDs ranked by SLA compliance"
    )
    
    # Statistics
    avg_performance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average performance score across all supervisors"
    )
    avg_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average resolution time across all supervisors"
    )
    avg_sla_compliance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average SLA compliance rate"
    )
    
    @field_validator(
        "ranked_by_performance",
        "ranked_by_resolution_speed",
        "ranked_by_feedback_score",
        "ranked_by_sla_compliance"
    )
    @classmethod
    def validate_ranking_completeness(cls, v: List[UUID], info) -> List[UUID]:
        """Validate rankings include all supervisors."""
        if "supervisors" in info.data:
            supervisor_ids = {s.supervisor_id for s in info.data["supervisors"]}
            ranking_ids = set(v)
            
            # Allow for some supervisors to be excluded from certain rankings
            # (e.g., no feedback score available)
            if info.field_name != "ranked_by_feedback_score":
                if ranking_ids != supervisor_ids:
                    # Only warn, don't fail
                    pass
        
        return v
    
    @computed_field
    @property
    def top_performer(self) -> Optional[UUID]:
        """Get ID of top performing supervisor."""
        if not self.ranked_by_performance:
            return None
        return self.ranked_by_performance[0]
    
    @computed_field
    @property
    def performance_variance(self) -> Decimal:
        """Calculate variance in performance scores."""
        if not self.supervisors:
            return Decimal("0.00")
        
        scores = [float(s.overall_performance_score) for s in self.supervisors]
        mean = sum(scores) / len(scores)
        variance = sum((x - mean) ** 2 for x in scores) / len(scores)
        
        return round(Decimal(str(variance)), 2)
    
    def get_supervisor_rank(self, supervisor_id: UUID, metric: str = "performance") -> Optional[int]:
        """
        Get rank of specific supervisor for a metric.
        
        Args:
            supervisor_id: Supervisor to rank
            metric: Metric to rank by ('performance', 'resolution_speed', 'feedback', 'sla')
            
        Returns:
            Rank (1-indexed) or None if not found
        """
        ranking_map = {
            "performance": self.ranked_by_performance,
            "resolution_speed": self.ranked_by_resolution_speed,
            "feedback": self.ranked_by_feedback_score,
            "sla": self.ranked_by_sla_compliance,
        }
        
        ranking = ranking_map.get(metric)
        if not ranking:
            return None
        
        try:
            return ranking.index(supervisor_id) + 1
        except ValueError:
            return None


class TeamAnalytics(BaseSchema):
    """
    Team-level analytics for supervisor groups.
    
    Aggregates supervisor metrics at team/hostel level
    for management oversight.
    """
    
    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier"
    )
    hostel_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Team composition
    total_supervisors: int = Field(
        ...,
        ge=0,
        description="Total number of supervisors"
    )
    active_supervisors: int = Field(
        ...,
        ge=0,
        description="Currently active supervisors"
    )
    
    # Aggregate metrics
    total_tasks_assigned: int = Field(
        ...,
        ge=0,
        description="Total tasks assigned to team"
    )
    total_tasks_completed: int = Field(
        ...,
        ge=0,
        description="Total tasks completed by team"
    )
    team_completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Team completion rate percentage"
    )
    
    # Performance
    avg_team_performance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average team performance score"
    )
    avg_team_sla_compliance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average team SLA compliance"
    )
    
    # Workload distribution
    workload_balance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Workload distribution balance score (100 = perfectly balanced)"
    )
    
    # Individual contributions
    top_performers: List[UUID] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 performing supervisor IDs"
    )
    
    @computed_field
    @property
    def team_efficiency(self) -> str:
        """Assess overall team efficiency."""
        if self.avg_team_performance_score >= 85:
            return "high"
        elif self.avg_team_performance_score >= 70:
            return "moderate"
        else:
            return "low"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\visitor_analytics.py ---
# --- File: app/schemas/analytics/visitor_analytics.py ---
"""
Visitor and funnel analytics schemas for marketing optimization.

Provides comprehensive visitor behavior analysis including:
- Acquisition funnel tracking
- Traffic source analysis
- Visitor behavior patterns
- Conversion optimization insights
- Search and engagement metrics
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from enum import Enum

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import SearchSource
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "FunnelStage",
    "VisitorFunnel",
    "TrafficSourceMetrics",
    "TrafficSourceAnalytics",
    "SearchBehavior",
    "EngagementMetrics",
    "VisitorBehaviorAnalytics",
    "ConversionPathAnalysis",
]


class FunnelStage(str, Enum):
    """Visitor journey funnel stages."""
    
    VISIT = "visit"
    SEARCH = "search"
    VIEW_HOSTEL = "view_hostel"
    COMPARE = "compare"
    REGISTER = "register"
    BOOK = "book"
    CONFIRM = "confirm"


class TrafficSourceMetrics(BaseSchema):
    """
    Metrics for a specific traffic source.
    
    Provides detailed performance data for individual
    acquisition channels to optimize marketing spend.
    """
    
    source: SearchSource = Field(
        ...,
        description="Traffic source"
    )
    source_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Human-readable source name"
    )
    
    # Volume metrics
    visits: int = Field(
        ...,
        ge=0,
        description="Total visits from this source"
    )
    unique_visitors: int = Field(
        ...,
        ge=0,
        description="Unique visitors from this source"
    )
    page_views: int = Field(
        ...,
        ge=0,
        description="Total page views from this source"
    )
    
    # Engagement metrics
    avg_session_duration_seconds: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average session duration"
    )
    avg_pages_per_session: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average pages viewed per session"
    )
    bounce_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Bounce rate percentage"
    )
    
    # Conversion metrics
    registrations: int = Field(
        ...,
        ge=0,
        description="User registrations from this source"
    )
    bookings: int = Field(
        ...,
        ge=0,
        description="Bookings from this source"
    )
    confirmed_bookings: int = Field(
        ...,
        ge=0,
        description="Confirmed bookings from this source"
    )
    
    # Conversion rates
    visit_to_registration_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Visit to registration conversion rate"
    )
    visit_to_booking_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Visit to booking conversion rate"
    )
    registration_to_booking_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Registration to booking conversion rate"
    )
    
    # Revenue metrics
    total_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Total revenue from this source"
    )
    revenue_per_visit: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Average revenue per visit"
    )
    
    # Cost metrics (if available)
    marketing_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Marketing cost for this source"
    )
    cost_per_acquisition: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Cost per booking acquisition"
    )
    roi: Optional[Decimal] = Field(
        None,
        decimal_places=2,
        description="Return on investment percentage"
    )
    
    @field_validator("unique_visitors")
    @classmethod
    def validate_unique_visitors(cls, v: int, info) -> int:
        """Validate unique visitors don't exceed total visits."""
        if "visits" in info.data and v > info.data["visits"]:
            raise ValueError("unique_visitors cannot exceed visits")
        return v
    
    @field_validator("registrations", "bookings", "confirmed_bookings")
    @classmethod
    def validate_conversion_counts(cls, v: int, info) -> int:
        """Validate conversion counts are reasonable."""
        if "visits" in info.data and v > info.data["visits"]:
            # Allow slight excess for cross-session conversions
            if v > info.data["visits"] * 1.1:
                raise ValueError(f"{info.field_name} significantly exceeds visits")
        return v
    
    @computed_field
    @property
    def engagement_score(self) -> Decimal:
        """
        Calculate engagement score (0-100).
        
        Based on session duration, pages per session, and bounce rate.
        """
        # Normalize metrics to 0-100 scale
        duration_score = min(float(self.avg_session_duration_seconds) / 300 * 100, 100)
        pages_score = min(float(self.avg_pages_per_session) / 10 * 100, 100)
        bounce_score = 100 - float(self.bounce_rate)
        
        # Weighted average
        score = (duration_score * 0.4 + pages_score * 0.3 + bounce_score * 0.3)
        return round(Decimal(str(score)), 2)
    
    @computed_field
    @property
    def quality_score(self) -> Decimal:
        """
        Calculate source quality score (0-100).
        
        Combines engagement and conversion metrics.
        """
        engagement = float(self.engagement_score)
        conversion = float(self.visit_to_booking_rate) * 10  # Scale to 0-100
        
        score = (engagement * 0.4 + conversion * 0.6)
        return round(Decimal(str(min(score, 100))), 2)


class VisitorFunnel(BaseSchema):
    """
    Visitor acquisition and conversion funnel.
    
    Tracks visitor journey from initial visit through
    to confirmed booking with drop-off analysis.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Funnel analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Funnel stages
    total_visits: int = Field(
        ...,
        ge=0,
        description="Total website visits"
    )
    unique_visitors: int = Field(
        ...,
        ge=0,
        description="Unique visitors"
    )
    searches_performed: int = Field(
        ...,
        ge=0,
        description="Number of searches performed"
    )
    hostel_views: int = Field(
        ...,
        ge=0,
        description="Hostel detail page views"
    )
    comparisons_made: int = Field(
        0,
        ge=0,
        description="Comparison tool uses"
    )
    registrations: int = Field(
        ...,
        ge=0,
        description="User registrations"
    )
    booking_starts: int = Field(
        ...,
        ge=0,
        description="Booking form starts"
    )
    bookings: int = Field(
        ...,
        ge=0,
        description="Booking submissions"
    )
    confirmed_bookings: int = Field(
        0,
        ge=0,
        description="Confirmed bookings"
    )
    
    # Conversion rates
    visit_to_search_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Visit to search conversion rate"
    )
    search_to_view_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Search to hostel view conversion rate"
    )
    view_to_registration_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Hostel view to registration rate"
    )
    registration_to_booking_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Registration to booking rate"
    )
    booking_to_confirm_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Booking to confirmation rate"
    )
    visit_to_booking_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall visit to booking conversion rate"
    )
    
    # Drop-off analysis
    dropped_after_search: int = Field(
        ...,
        ge=0,
        description="Visitors who left after searching"
    )
    dropped_after_hostel_view: int = Field(
        ...,
        ge=0,
        description="Visitors who left after viewing hostel"
    )
    dropped_after_booking_start: int = Field(
        ...,
        ge=0,
        description="Visitors who abandoned booking form"
    )
    
    @field_validator(
        "unique_visitors",
        "searches_performed",
        "hostel_views",
        "registrations",
        "bookings"
    )
    @classmethod
    def validate_funnel_progression(cls, v: int, info) -> int:
        """Validate funnel stages progress logically."""
        # Note: We allow some flexibility as users may skip stages
        # or stages may be tracked across multiple sessions
        return v
    
    @computed_field
    @property
    def total_drop_offs(self) -> int:
        """Calculate total visitors who dropped off."""
        return self.total_visits - self.confirmed_bookings
    
    @computed_field
    @property
    def largest_drop_off_stage(self) -> str:
        """Identify stage with largest drop-off."""
        drop_offs = {
            "after_search": self.dropped_after_search,
            "after_view": self.dropped_after_hostel_view,
            "after_booking_start": self.dropped_after_booking_start,
        }
        
        if not any(drop_offs.values()):
            return "none"
        
        return max(drop_offs, key=drop_offs.get)
    
    @computed_field
    @property
    def funnel_efficiency_score(self) -> Decimal:
        """
        Calculate overall funnel efficiency (0-100).
        
        Based on conversion rates at each stage.
        """
        rates = [
            float(self.visit_to_search_rate),
            float(self.search_to_view_rate),
            float(self.view_to_registration_rate),
            float(self.registration_to_booking_rate),
            float(self.booking_to_confirm_rate),
        ]
        
        # Geometric mean for compound conversion
        if any(r == 0 for r in rates):
            return Decimal("0.00")
        
        product = 1
        for rate in rates:
            product *= (rate / 100)
        
        efficiency = (product ** (1/len(rates))) * 100
        return round(Decimal(str(efficiency)), 2)


class TrafficSourceAnalytics(BaseSchema):
    """
    Comprehensive traffic source analysis.
    
    Aggregates and compares performance across all
    traffic acquisition channels.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    total_visits: int = Field(
        ...,
        ge=0,
        description="Total visits across all sources"
    )
    
    # Source breakdowns
    visits_by_source: Dict[str, int] = Field(
        default_factory=dict,
        description="Visit count by source"
    )
    registrations_by_source: Dict[str, int] = Field(
        default_factory=dict,
        description="Registration count by source"
    )
    bookings_by_source: Dict[str, int] = Field(
        default_factory=dict,
        description="Booking count by source"
    )
    
    # Conversion rates
    visit_to_booking_rate_by_source: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Visit to booking conversion rate by source"
    )
    
    # Detailed metrics per source
    source_metrics: List[TrafficSourceMetrics] = Field(
        default_factory=list,
        description="Detailed metrics for each source"
    )
    
    @computed_field
    @property
    def best_converting_source(self) -> Optional[SearchSource]:
        """Identify source with highest conversion rate."""
        if not self.source_metrics:
            return None
        return max(
            self.source_metrics,
            key=lambda x: x.visit_to_booking_rate
        ).source
    
    @computed_field
    @property
    def highest_volume_source(self) -> Optional[SearchSource]:
        """Identify source with highest visit volume."""
        if not self.source_metrics:
            return None
        return max(
            self.source_metrics,
            key=lambda x: x.visits
        ).source
    
    @computed_field
    @property
    def best_roi_source(self) -> Optional[SearchSource]:
        """Identify source with best ROI."""
        sources_with_roi = [
            s for s in self.source_metrics
            if s.roi is not None
        ]
        
        if not sources_with_roi:
            return None
        
        return max(sources_with_roi, key=lambda x: x.roi).source


class SearchBehavior(BaseSchema):
    """
    Search behavior analytics.
    
    Analyzes how visitors search for hostels to improve
    search experience and SEO.
    """
    
    # Search volume
    total_searches: int = Field(
        ...,
        ge=0,
        description="Total number of searches"
    )
    unique_searchers: int = Field(
        ...,
        ge=0,
        description="Unique users who searched"
    )
    avg_searches_per_session: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average searches per session"
    )
    
    # Search patterns
    most_searched_cities: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Top 10 most searched cities"
    )
    most_searched_keywords: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Top 20 search keywords"
    )
    
    # Filter usage
    avg_filters_used: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average number of filters applied"
    )
    most_filtered_amenities: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Top 10 filtered amenities"
    )
    most_common_price_range: Optional[str] = Field(
        None,
        max_length=50,
        description="Most common price range filter"
    )
    
    # Search quality
    avg_results_per_search: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average results returned per search"
    )
    zero_result_searches: int = Field(
        0,
        ge=0,
        description="Number of searches with zero results"
    )
    zero_result_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of searches with no results"
    )
    
    @computed_field
    @property
    def search_effectiveness_score(self) -> Decimal:
        """
        Calculate search effectiveness score (0-100).
        
        Based on result relevance and zero-result rate.
        """
        # Lower zero-result rate is better
        result_score = 100 - float(self.zero_result_rate)
        
        # More results indicate better coverage
        coverage_score = min(float(self.avg_results_per_search) / 10 * 100, 100)
        
        score = (result_score * 0.7 + coverage_score * 0.3)
        return round(Decimal(str(score)), 2)


class EngagementMetrics(BaseSchema):
    """
    Visitor engagement metrics.
    
    Measures depth and quality of visitor interaction
    with the platform.
    """
    
    # Page engagement
    avg_hostels_viewed_per_session: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average hostel pages viewed per session"
    )
    avg_time_on_hostel_page_seconds: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average time spent on hostel detail page"
    )
    avg_pages_per_session: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average pages viewed per session"
    )
    
    # Feature usage
    comparison_tool_usage_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of sessions using comparison tool"
    )
    review_read_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of visitors who read reviews"
    )
    photo_gallery_usage_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage using photo gallery"
    )
    
    # Interaction depth
    avg_review_pages_viewed: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Average review pages viewed"
    )
    avg_photos_viewed: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Average photos viewed per hostel"
    )
    
    # Call-to-action engagement
    inquiry_form_views: int = Field(
        0,
        ge=0,
        description="Number of inquiry form views"
    )
    inquiry_submissions: int = Field(
        0,
        ge=0,
        description="Number of inquiry submissions"
    )
    inquiry_conversion_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Inquiry form conversion rate"
    )
    
    @computed_field
    @property
    def engagement_level(self) -> str:
        """Classify overall engagement level."""
        score = (
            min(float(self.avg_hostels_viewed_per_session) / 5, 1) * 30 +
            min(float(self.avg_time_on_hostel_page_seconds) / 180, 1) * 30 +
            float(self.comparison_tool_usage_rate) * 0.2 +
            float(self.review_read_rate) * 0.2
        )
        
        if score >= 70:
            return "high"
        elif score >= 40:
            return "moderate"
        else:
            return "low"


class VisitorBehaviorAnalytics(BaseSchema):
    """
    Comprehensive visitor behavior analytics.
    
    Consolidates search, engagement, and exit behavior
    for complete visitor insight.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Search behavior
    search_behavior: SearchBehavior = Field(
        ...,
        description="Search behavior metrics"
    )
    
    # Engagement
    engagement: EngagementMetrics = Field(
        ...,
        description="Engagement metrics"
    )
    
    # Exit behavior
    common_exit_pages: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Top 10 exit pages"
    )
    common_exit_reasons: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Common reasons for exit (from surveys/feedback)"
    )
    bounce_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall bounce rate"
    )
    
    # Session metrics
    avg_session_duration_seconds: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average session duration"
    )
    return_visitor_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of return visitors"
    )
    
    @computed_field
    @property
    def visitor_quality_score(self) -> Decimal:
        """
        Calculate overall visitor quality score (0-100).
        
        Combines engagement, search effectiveness, and retention.
        """
        engagement_level_scores = {
            "high": 100,
            "moderate": 60,
            "low": 30,
        }
        
        engagement_score = engagement_level_scores.get(
            self.engagement.engagement_level,
            50
        )
        search_score = float(self.search_behavior.search_effectiveness_score)
        retention_score = float(self.return_visitor_rate)
        
        score = (
            engagement_score * 0.5 +
            search_score * 0.3 +
            retention_score * 0.2
        )
        
        return round(Decimal(str(score)), 2)
    
    def get_optimization_recommendations(self) -> List[str]:
        """
        Generate actionable optimization recommendations.
        
        Returns:
            List of recommendation strings
        """
        recommendations = []
        
        # Search optimization
        if self.search_behavior.zero_result_rate > 10:
            recommendations.append(
                f"High zero-result search rate ({self.search_behavior.zero_result_rate}%) - "
                "improve search coverage or query handling"
            )
        
        # Engagement optimization
        if self.engagement.engagement_level == "low":
            recommendations.append(
                "Low visitor engagement - consider improving content quality "
                "and visual appeal"
            )
        
        # Exit optimization
        if self.bounce_rate > 60:
            recommendations.append(
                f"High bounce rate ({self.bounce_rate}%) - "
                "optimize landing pages and initial user experience"
            )
        
        # Feature adoption
        if self.engagement.comparison_tool_usage_rate < 20:
            recommendations.append(
                "Low comparison tool usage - make feature more prominent"
            )
        
        # Session duration
        if float(self.avg_session_duration_seconds) < 60:
            recommendations.append(
                "Short session duration - improve content engagement "
                "and reduce friction"
            )
        
        return recommendations


class ConversionPathAnalysis(BaseSchema):
    """
    Conversion path and attribution analysis.
    
    Tracks multi-touch visitor journeys to understand
    conversion attribution.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    
    # Path metrics
    avg_touches_before_conversion: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average touchpoints before booking"
    )
    avg_days_to_conversion: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average days from first visit to booking"
    )
    
    # Common paths
    top_conversion_paths: List[List[str]] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 conversion paths (sequences of pages/actions)"
    )
    
    # Attribution
    first_touch_attribution: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Revenue attributed to first touch by source"
    )
    last_touch_attribution: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Revenue attributed to last touch by source"
    )
    
    @computed_field
    @property
    def conversion_complexity(self) -> str:
        """Assess conversion path complexity."""
        touches = float(self.avg_touches_before_conversion)
        
        if touches <= 2:
            return "simple"
        elif touches <= 5:
            return "moderate"
        else:
            return "complex"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\__init__.py ---
# --- File: app/schemas/analytics/__init__.py ---
"""
Analytics schemas package.

Comprehensive analytics module providing schemas for:
- Dashboard and KPI metrics
- Financial reporting (P&L, cashflow)
- Occupancy forecasting
- Complaint tracking
- Visitor funnel analysis
- Booking analytics
- Supervisor performance
- Platform-wide metrics
- Custom report generation
"""

# Dashboard analytics
from app.schemas.analytics.dashboard_analytics import (
    DashboardMetrics,
    KPIResponse,
    QuickStats,
    TimeseriesPoint,
    RoleSpecificDashboard,
    AlertNotification,
    DashboardWidget,
)

# Financial analytics
from app.schemas.analytics.financial_analytics import (
    FinancialReport,
    RevenueBreakdown,
    ExpenseBreakdown,
    ProfitAndLossReport,
    CashflowSummary,
    CashflowPoint,
    FinancialRatios,
    BudgetComparison,
    TaxSummary,
)

# Occupancy analytics
from app.schemas.analytics.occupancy_analytics import (
    OccupancyReport,
    OccupancyKPI,
    OccupancyTrendPoint,
    OccupancyByRoomType,
    OccupancyByFloor,
    ForecastData,
    ForecastPoint,
    SeasonalPattern,
)

# Complaint analytics
from app.schemas.analytics.complaint_analytics import (
    ComplaintKPI,
    ComplaintDashboard,
    ComplaintTrend,
    ComplaintTrendPoint,
    CategoryBreakdown,
    PriorityBreakdown,
    SLAMetrics,
)

# Visitor analytics
from app.schemas.analytics.visitor_analytics import (
    VisitorFunnel,
    TrafficSourceAnalytics,
    TrafficSourceMetrics,
    VisitorBehaviorAnalytics,
    SearchBehavior,
    EngagementMetrics,
    ConversionPathAnalysis,
)

# Booking analytics
from app.schemas.analytics.booking_analytics import (
    BookingFunnel,
    BookingKPI,
    BookingTrendPoint,
    CancellationAnalytics,
    BookingAnalyticsSummary,
    BookingSourceMetrics,
)

# Supervisor analytics
from app.schemas.analytics.supervisor_analytics import (
    SupervisorKPI,
    SupervisorDashboardAnalytics,
    SupervisorComparison,
    SupervisorTrendPoint,
    SupervisorWorkload,
    SupervisorPerformanceRating,
    TeamAnalytics,
)

# Platform analytics
from app.schemas.analytics.platform_analytics import (
    PlatformMetrics,
    GrowthMetrics,
    PlatformUsageAnalytics,
    MonthlyMetric,
    TenantMetrics,
    ChurnAnalysis,
    SystemHealthMetrics,
    RevenueMetrics,
)

# Custom reports
from app.schemas.analytics.custom_reports import (
    CustomReportRequest,
    CustomReportDefinition,
    CustomReportResult,
    CustomReportFilter,
    CustomReportField,
    ReportExportRequest,
    ReportSchedule,
    FilterOperator,
    AggregationType,
    ReportFormat,
    ReportModule,
)

__all__ = [
    # Dashboard
    "DashboardMetrics",
    "KPIResponse",
    "QuickStats",
    "TimeseriesPoint",
    "RoleSpecificDashboard",
    "AlertNotification",
    "DashboardWidget",
    
    # Financial
    "FinancialReport",
    "RevenueBreakdown",
    "ExpenseBreakdown",
    "ProfitAndLossReport",
    "CashflowSummary",
    "CashflowPoint",
    "FinancialRatios",
    "BudgetComparison",
    "TaxSummary",
    
    # Occupancy
    "OccupancyReport",
    "OccupancyKPI",
    "OccupancyTrendPoint",
    "OccupancyByRoomType",
    "OccupancyByFloor",
    "ForecastData",
    "ForecastPoint",
    "SeasonalPattern",
    
    # Complaints
    "ComplaintKPI",
    "ComplaintDashboard",
    "ComplaintTrend",
    "ComplaintTrendPoint",
    "CategoryBreakdown",
    "PriorityBreakdown",
    "SLAMetrics",
    
    # Visitor
    "VisitorFunnel",
    "TrafficSourceAnalytics",
    "TrafficSourceMetrics",
    "VisitorBehaviorAnalytics",
    "SearchBehavior",
    "EngagementMetrics",
    "ConversionPathAnalysis",
    
    # Booking
    "BookingFunnel",
    "BookingKPI",
    "BookingTrendPoint",
    "CancellationAnalytics",
    "BookingAnalyticsSummary",
    "BookingSourceMetrics",
    
    # Supervisor
    "SupervisorKPI",
    "SupervisorDashboardAnalytics",
    "SupervisorComparison",
    "SupervisorTrendPoint",
    "SupervisorWorkload",
    "SupervisorPerformanceRating",
    "TeamAnalytics",
    
    # Platform
    "PlatformMetrics",
    "GrowthMetrics",
    "PlatformUsageAnalytics",
    "MonthlyMetric",
    "TenantMetrics",
    "ChurnAnalysis",
    "SystemHealthMetrics",
    "RevenueMetrics",
    
    # Custom reports
    "CustomReportRequest",
    "CustomReportDefinition",
    "CustomReportResult",
    "CustomReportFilter",
    "CustomReportField",
    "ReportExportRequest",
    "ReportSchedule",
    "FilterOperator",
    "AggregationType",
    "ReportFormat",
    "ReportModule",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\all_folders_files_content.txt ---
<<<<<<< Updated upstream
<<<<<<< Updated upstream
=======
>>>>>>> Stashed changes
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_approval.py ---
<<<<<<< Updated upstream
=======
### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\announcement ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\announcement =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\announcement\announcement_approval.py ---
>>>>>>> Stashed changes
=======
>>>>>>> Stashed changes
"""
Announcement approval schemas
"""
from datetime import datetime
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class ApprovalRequest(BaseCreateSchema):
    """Request approval for announcement (supervisor to admin)"""
    announcement_id: UUID
    
    # Justification
    approval_reason: Optional[str] = Field(None, max_length=500, description="Why approval needed")
    
    # Urgency
    is_urgent_request: bool = Field(False)


class ApprovalResponse(BaseSchema):
    """Approval response"""
    announcement_id: UUID
    
    approved: bool
    approved_by: UUID
    approved_by_name: str
    approved_at: datetime
    
    # Feedback
    approval_notes: Optional[str]
    
    # If approved, auto-publish?
    auto_published: bool
    
    message: str


class RejectionRequest(BaseCreateSchema):
    """Reject announcement"""
    announcement_id: UUID
    
    rejection_reason: str = Field(..., min_length=20, max_length=500)
    
    # Suggestions
    suggested_modifications: Optional[str] = Field(None, max_length=1000)


class ApprovalWorkflow(BaseSchema):
    """Approval workflow status"""
    announcement_id: UUID
    title: str
    
    requires_approval: bool
    approval_status: str = Field(
        ...,
        pattern="^(pending|approved|rejected|not_required)$"
    )
    
    # Submitted by
    created_by: UUID
    created_by_name: str
    created_by_role: str
    
    # Approval timeline
    submitted_for_approval_at: Optional[datetime]
    approved_rejected_at: Optional[datetime]
    
    # Current approver
    pending_with: Optional[UUID]
    pending_with_name: Optional[str]
    
    # Reason (if rejected)
    rejection_reason: Optional[str]


class SupervisorApprovalQueue(BaseSchema):
    """Supervisor's pending approvals"""
    supervisor_id: UUID
    supervisor_name: str
    
    total_pending: int
    urgent_pending: int
    
    pending_announcements: List["PendingApprovalItem"]


class PendingApprovalItem(BaseSchema):
    """Pending approval item"""
    announcement_id: UUID
    title: str
    category: str
    
    created_by: UUID
    created_by_name: str
    
    submitted_at: datetime
    is_urgent: bool
    
    # Preview
    content_preview: str = Field(..., description="First 200 chars")
    
    target_audience: str
    estimated_recipients: int


class BulkApproval(BaseCreateSchema):
    """Approve multiple announcements"""
    announcement_ids: List[UUID] = Field(..., min_items=1)
    
    approved: bool
    approval_notes: Optional[str] = None
    
    # Publish immediately after approval
    publish_immediately: bool = Field(True)

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_base.py ---
=======
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\announcement\announcement_base.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_base.py ---
>>>>>>> Stashed changes
"""
Announcement base schemas
"""
from datetime import datetime
from typing import List, Optional
from pydantic import Field, HttpUrl
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseUpdateSchema, BaseSchema
from app.schemas.common.enums import AnnouncementCategory, Priority, TargetAudience


class AnnouncementBase(BaseSchema):
    """Base announcement schema"""
    hostel_id: UUID = Field(..., description="Hostel ID")
    
    title: str = Field(..., min_length=5, max_length=255, description="Announcement title")
    content: str = Field(..., min_length=10, max_length=5000, description="Announcement content")
    
    category: AnnouncementCategory = Field(..., description="Announcement category")
    priority: Priority = Field(Priority.MEDIUM, description="Priority level")
    
    # Visibility
    is_urgent: bool = Field(False, description="Mark as urgent")
    is_pinned: bool = Field(False, description="Pin to top")
    
    # Target audience
    target_audience: TargetAudience = Field(TargetAudience.ALL, description="Target audience")
    target_room_ids: List[UUID] = Field(default_factory=list, description="Specific rooms")
    target_student_ids: List[UUID] = Field(default_factory=list, description="Specific students")
    target_floor_numbers: List[int] = Field(default_factory=list, description="Specific floors")
    
    # Attachments
    attachments: List[HttpUrl] = Field(default_factory=list, description="Attachment URLs")
    
    # Expiry
    expires_at: Optional[datetime] = Field(None, description="When announcement expires")


class AnnouncementCreate(AnnouncementBase, BaseCreateSchema):
    """Create announcement"""
    created_by: UUID = Field(..., description="Creator (admin/supervisor)")
    
    # Delivery settings
    send_email: bool = Field(False, description="Send email notification")
    send_sms: bool = Field(False, description="Send SMS notification")
    send_push: bool = Field(True, description="Send push notification")


class AnnouncementUpdate(BaseUpdateSchema):
    """Update announcement"""
    title: Optional[str] = Field(None, min_length=5, max_length=255)
    content: Optional[str] = Field(None, min_length=10, max_length=5000)
    category: Optional[AnnouncementCategory] = None
    priority: Optional[Priority] = None
    
    is_urgent: Optional[bool] = None
    is_pinned: Optional[bool] = None
    
    expires_at: Optional[datetime] = None
    
    # Publication
    is_published: Optional[bool] = None

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_delivery.py ---
=======
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\announcement\announcement_delivery.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_delivery.py ---
>>>>>>> Stashed changes
"""
Announcement delivery schemas
"""
from datetime import datetime
from typing import List, Optional, Dict
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class DeliveryConfig(BaseSchema):
    """Delivery configuration"""
    announcement_id: UUID
    
    # Channels
    channels: "DeliveryChannels"
    
    # Delivery strategy
    delivery_strategy: str = Field(
        "immediate",
        pattern="^(immediate|scheduled|batched)$"
    )
    
    # Batch settings (if batched)
    batch_size: Optional[int] = Field(None, ge=10, le=1000)
    batch_interval_minutes: Optional[int] = Field(None, ge=1, le=60)


class DeliveryChannels(BaseSchema):
    """Delivery channel settings"""
    email: bool = Field(False)
    sms: bool = Field(False)
    push: bool = Field(True)
    in_app: bool = Field(True)
    
    # Channel priority (for fallback)
    primary_channel: str = Field("push", pattern="^(email|sms|push|in_app)$")
    fallback_channels: List[str] = Field(default_factory=list)


class DeliveryStatus(BaseSchema):
    """Delivery status for announcement"""
    announcement_id: UUID
    
    total_recipients: int
    
    # By channel
    email_sent: int
    email_delivered: int
    email_failed: int
    
    sms_sent: int
    sms_delivered: int
    sms_failed: int
    
    push_sent: int
    push_delivered: int
    push_failed: int
    
    # Overall
    total_delivered: int
    total_failed: int
    delivery_rate: Decimal = Field(..., description="% successfully delivered")
    
    # Timeline
    delivery_started_at: Optional[datetime]
    delivery_completed_at: Optional[datetime]


class DeliveryReport(BaseSchema):
    """Detailed delivery report"""
    announcement_id: UUID
    title: str
    
    # Recipients
    total_recipients: int
    
    # By channel
    channel_breakdown: Dict[str, "ChannelDeliveryStats"]
    
    # By status
    delivered_count: int
    failed_count: int
    pending_count: int
    
    # Failed recipients
    failed_recipients: List["FailedDelivery"] = Field(default_factory=list)
    
    # Timeline
    delivery_duration_minutes: Optional[int]
    
    generated_at: datetime


class ChannelDeliveryStats(BaseSchema):
    """Delivery stats for specific channel"""
    channel: str
    
    sent: int
    delivered: int
    failed: int
    pending: int
    
    delivery_rate: Decimal
    average_delivery_time_seconds: Optional[Decimal]


class FailedDelivery(BaseSchema):
    """Failed delivery record"""
    recipient_id: UUID
    recipient_name: str
    recipient_contact: str
    
    channel: str
    failure_reason: str
    failed_at: datetime
    
    retry_attempted: bool
    retry_successful: Optional[bool]


class BatchDelivery(BaseSchema):
    """Batch delivery progress"""
    announcement_id: UUID
    
    total_batches: int
    completed_batches: int
    current_batch: int
    
    total_recipients: int
    processed_recipients: int
    
    estimated_completion: datetime
    
    status: str = Field(..., pattern="^(processing|completed|failed|paused)$")


class RetryDelivery(BaseCreateSchema):
    """Retry failed deliveries"""
    announcement_id: UUID
    
    # Retry options
    retry_failed_only: bool = Field(True)
    retry_channels: List[str] = Field(default_factory=list, description="Specific channels to retry")
    
    # Specific recipients
    recipient_ids: Optional[List[UUID]] = Field(None, description="Retry specific recipients only")

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_filters.py ---
=======
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\announcement\announcement_filters.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_filters.py ---
>>>>>>> Stashed changes
"""
Announcement filter schemas
"""
from datetime import date, datetime
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import AnnouncementCategory, Priority


class AnnouncementFilterParams(BaseFilterSchema):
    """Announcement filter parameters"""
    # Text search
    search: Optional[str] = Field(None, description="Search in title, content")
    
    # Hostel filter
    hostel_id: Optional[UUID] = None
    hostel_ids: Optional[List[UUID]] = None
    
    # Category
    category: Optional[AnnouncementCategory] = None
    categories: Optional[List[AnnouncementCategory]] = None
    
    # Priority
    priority: Optional[Priority] = None
    priorities: Optional[List[Priority]] = None
    
    # Status
    is_published: Optional[bool] = None
    is_urgent: Optional[bool] = None
    is_pinned: Optional[bool] = None
    
    # Creator
    created_by: Optional[UUID] = None
    created_by_role: Optional[str] = None
    
    # Date filters
    published_date_from: Optional[date] = None
    published_date_to: Optional[date] = None
    created_date_from: Optional[date] = None
    created_date_to: Optional[date] = None
    
    # Expiry
    active_only: Optional[bool] = Field(None, description="Only non-expired announcements")
    expired_only: Optional[bool] = None
    
    # Approval
    approval_pending: Optional[bool] = None


class SearchRequest(BaseFilterSchema):
    """Announcement search"""
    query: str = Field(..., min_length=1)
    hostel_id: Optional[UUID] = None
    
    search_in_title: bool = Field(True)
    search_in_content: bool = Field(True)
    
    category: Optional[AnnouncementCategory] = None
    
    page: int = Field(1, ge=1)
    page_size: int = Field(20, ge=1, le=100)


class ArchiveRequest(BaseCreateSchema):
    """Archive old announcements"""
    hostel_id: UUID
    
    # Archive criteria
    archive_before_date: date = Field(..., description="Archive announcements before this date")
    
    # Options
    archive_expired_only: bool = Field(True)
    archive_read_only: bool = Field(False, description="Archive only if all recipients read")
    
    # Exclusions
    exclude_pinned: bool = Field(True)
    exclude_important: bool = Field(True)


class AnnouncementExportRequest(BaseFilterSchema):
    """Export announcements"""
    hostel_id: UUID
    filters: Optional[AnnouncementFilterParams] = None
    
    format: str = Field("pdf", pattern="^(pdf|excel|csv)$")
    
    include_engagement_metrics: bool = Field(True)
    include_recipient_list: bool = Field(False)

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_response.py ---
=======
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\announcement\announcement_response.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_response.py ---
>>>>>>> Stashed changes
"""
Announcement response schemas
"""
from datetime import datetime
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import AnnouncementCategory, Priority


class AnnouncementResponse(BaseResponseSchema):
    """Announcement response"""
    hostel_id: UUID
    hostel_name: str
    
    title: str
    content: str
    
    category: AnnouncementCategory
    priority: Priority
    
    is_urgent: bool
    is_pinned: bool
    
    created_by: UUID
    created_by_name: str
    
    is_published: bool
    published_at: Optional[datetime]
    
    total_recipients: int
    read_count: int


class AnnouncementDetail(BaseResponseSchema):
    """Detailed announcement"""
    hostel_id: UUID
    hostel_name: str
    
    title: str
    content: str
    category: AnnouncementCategory
    priority: Priority
    
    is_urgent: bool
    is_pinned: bool
    
    # Target audience
    target_audience: str
    target_room_ids: List[UUID]
    target_student_ids: List[UUID]
    target_floor_numbers: List[int]
    
    # Attachments
    attachments: List[str]
    
    # Schedule
    scheduled_publish_at: Optional[datetime]
    published_at: Optional[datetime]
    expires_at: Optional[datetime]
    is_published: bool
    
    # Creation and approval
    created_by: UUID
    created_by_name: str
    created_by_role: str
    
    approved_by: Optional[UUID]
    approved_by_name: Optional[str]
    approved_at: Optional[datetime]
    requires_approval: bool
    
    # Delivery
    send_email: bool
    send_sms: bool
    send_push: bool
    
    email_sent_at: Optional[datetime]
    sms_sent_at: Optional[datetime]
    push_sent_at: Optional[datetime]
    
    # Tracking
    total_recipients: int
    read_count: int
    acknowledged_count: int
    
    # Engagement
    engagement_rate: Decimal = Field(..., description="% who read the announcement")


class AnnouncementList(BaseSchema):
    """List of announcements"""
    hostel_id: Optional[UUID] = None
    
    total_announcements: int
    active_announcements: int
    pinned_announcements: int
    
    announcements: List["AnnouncementListItem"]


class AnnouncementListItem(BaseSchema):
    """Announcement list item"""
    id: UUID
    title: str
    category: str
    priority: str
    
    is_urgent: bool
    is_pinned: bool
    
    created_by_name: str
    published_at: Optional[datetime]
    
    read_count: int
    total_recipients: int
    
    is_read: bool = Field(False, description="For student view")

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_scheduling.py ---
=======
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\announcement\announcement_scheduling.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_scheduling.py ---
>>>>>>> Stashed changes
"""
Announcement scheduling schemas
"""
from datetime import datetime
from typing import Optional
from pydantic import Field, field_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class ScheduleRequest(BaseCreateSchema):
    """Schedule announcement for later"""
    announcement_id: UUID
    
    scheduled_publish_at: datetime = Field(..., description="When to publish")
    
    # Auto-expire
    auto_expire: bool = Field(False)
    expire_after_hours: Optional[int] = Field(None, ge=1, le=720, description="Expire after N hours")
    
    @field_validator('scheduled_publish_at')
    @classmethod
    def validate_future_time(cls, v: datetime) -> datetime:
        """Ensure scheduled time is in future"""
        from datetime import datetime as dt
        if v <= dt.now():
            raise ValueError('Scheduled time must be in the future')
        return v


class ScheduleConfig(BaseSchema):
    """Schedule configuration"""
    announcement_id: UUID
    
    is_scheduled: bool
    scheduled_publish_at: Optional[datetime]
    
    # Recurrence
    is_recurring: bool = Field(False)
    recurrence_pattern: Optional[str] = Field(None, description="daily, weekly, monthly")
    
    # End condition
    recurrence_end_date: Optional[datetime] = None
    max_occurrences: Optional[int] = Field(None, ge=1)


class RecurringAnnouncement(BaseCreateSchema):
    """Create recurring announcement"""
    hostel_id: UUID
    
    title: str = Field(..., min_length=5, max_length=255)
    content: str = Field(..., min_length=10, max_length=5000)
    
    # Recurrence
    recurrence_pattern: str = Field(..., pattern="^(daily|weekly|monthly)$")
    start_date: datetime
    
    # End condition
    end_date: Optional[datetime] = None
    max_occurrences: Optional[int] = None
    
    # Days (for weekly)
    weekdays: Optional[List[int]] = Field(None, description="0=Monday, 6=Sunday")
    
    # Time
    publish_time: str = Field(..., description="HH:MM format")
    
    # Targeting
    target_audience: str
    target_room_ids: List[UUID] = Field(default_factory=list)


class ScheduleUpdate(BaseCreateSchema):
    """Update scheduled announcement"""
    announcement_id: UUID
    
    new_scheduled_time: datetime
    
    reason: Optional[str] = Field(None, max_length=500, description="Reason for rescheduling")


class ScheduleCancel(BaseCreateSchema):
    """Cancel scheduled announcement"""
    announcement_id: UUID
    
    cancellation_reason: str = Field(..., min_length=10, max_length=500)
    
    # Whether to delete or just unpublish
    delete_announcement: bool = Field(False)


class PublishNow(BaseCreateSchema):
    """Publish scheduled announcement immediately"""
    announcement_id: UUID
    
    override_schedule: bool = Field(True)


class ScheduledAnnouncementsList(BaseSchema):
    """List of scheduled announcements"""
    hostel_id: UUID
    
    total_scheduled: int
    upcoming_24h: int
    
    announcements: List["ScheduledAnnouncementItem"]


class ScheduledAnnouncementItem(BaseSchema):
    """Scheduled announcement item"""
    announcement_id: UUID
    title: str
    scheduled_for: datetime
    
    is_recurring: bool
    next_occurrence: Optional[datetime]
    
    target_audience: str
    estimated_recipients: int

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_targeting.py ---
=======
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\announcement\announcement_targeting.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_targeting.py ---
>>>>>>> Stashed changes
"""
Announcement targeting schemas
"""
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class TargetingConfig(BaseSchema):
    """Targeting configuration for announcement"""
    target_type: str = Field(
        ...,
        pattern="^(all|specific_rooms|specific_floors|specific_students|custom)$",
        description="Targeting type"
    )
    
    # Specific targets
    room_ids: List[UUID] = Field(default_factory=list)
    floor_numbers: List[int] = Field(default_factory=list)
    student_ids: List[UUID] = Field(default_factory=list)
    
    # Exclude
    exclude_student_ids: List[UUID] = Field(default_factory=list, description="Students to exclude")


class AudienceSelection(BaseCreateSchema):
    """Audience selection for announcement"""
    announcement_id: UUID
    
    # Selection criteria
    include_all: bool = Field(False)
    include_active_students: bool = Field(True)
    include_inactive_students: bool = Field(False)
    
    # Filters
    room_types: Optional[List[str]] = Field(None, description="Filter by room types")
    floors: Optional[List[int]] = None
    
    # Specific selection
    specific_room_ids: List[UUID] = Field(default_factory=list)
    specific_student_ids: List[UUID] = Field(default_factory=list)
    
    # Exclusions
    exclude_student_ids: List[UUID] = Field(default_factory=list)


class TargetRooms(BaseCreateSchema):
    """Target specific rooms"""
    announcement_id: UUID
    room_ids: List[UUID] = Field(..., min_items=1, description="Room IDs to target")
    
    # Include all students in these rooms
    include_all_students: bool = Field(True)


class TargetFloors(BaseCreateSchema):
    """Target specific floors"""
    announcement_id: UUID
    floor_numbers: List[int] = Field(..., min_items=1, description="Floor numbers")
    
    # Options
    include_all_rooms: bool = Field(True)


class IndividualTargeting(BaseCreateSchema):
    """Target individual students"""
    announcement_id: UUID
    student_ids: List[UUID] = Field(..., min_items=1, max_items=100, description="Student IDs")


class TargetingSummary(BaseSchema):
    """Summary of who will receive announcement"""
    announcement_id: UUID
    
    targeting_type: str
    
    # Counts
    total_recipients: int
    students_count: int
    rooms_count: int
    floors_count: int
    
    # Breakdown
    recipients_by_room: dict = Field(default_factory=dict, description="Room ID -> student count")
    recipients_by_floor: dict = Field(default_factory=dict, description="Floor -> student count")


class BulkTargeting(BaseCreateSchema):
    """Add multiple targeting rules"""
    announcement_id: UUID
    
    targeting_rules: List[TargetingConfig] = Field(..., min_items=1)
    
    # How to combine rules
    combine_mode: str = Field("union", pattern="^(union|intersection)$")

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_tracking.py ---
=======
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\announcement\announcement_tracking.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_tracking.py ---
>>>>>>> Stashed changes
"""
Announcement tracking schemas
"""
from datetime import datetime
from decimal import Decimal
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema


class ReadReceipt(BaseCreateSchema):
    """Mark announcement as read"""
    announcement_id: UUID
    student_id: UUID
    
    read_at: datetime = Field(default_factory=datetime.now)
    
    # Reading context
    reading_time_seconds: Optional[int] = Field(None, ge=0, description="Time spent reading")
    device_type: Optional[str] = Field(None, pattern="^(mobile|web|tablet)$")


class ReadReceiptResponse(BaseResponseSchema):
    """Read receipt response"""
    announcement_id: UUID
    student_id: UUID
    read_at: datetime
    
    # If acknowledgment is required
    requires_acknowledgment: bool
    acknowledged: bool


class AcknowledgmentTracking(BaseSchema):
    """Track acknowledgments for announcement"""
    announcement_id: UUID
    
    requires_acknowledgment: bool
    
    total_recipients: int
    acknowledged_count: int
    pending_acknowledgments: int
    
    acknowledgment_rate: Decimal = Field(..., description="% who acknowledged")
    
    # Students pending acknowledgment
    pending_students: List["PendingAcknowledgment"] = Field(default_factory=list)


class PendingAcknowledgment(BaseSchema):
    """Pending acknowledgment"""
    student_id: UUID
    student_name: str
    room_number: Optional[str]
    
    delivered_at: datetime
    read: bool
    read_at: Optional[datetime]


class AcknowledgmentRequest(BaseCreateSchema):
    """Submit acknowledgment"""
    announcement_id: UUID
    student_id: UUID
    
    acknowledged: bool = Field(True)
    acknowledgment_note: Optional[str] = Field(None, max_length=500)


class EngagementMetrics(BaseSchema):
    """Engagement metrics for announcement"""
    announcement_id: UUID
    title: str
    
    # Delivery
    total_recipients: int
    delivered_count: int
    delivery_rate: Decimal
    
    # Reading
    read_count: int
    read_rate: Decimal = Field(..., description="% who read")
    
    average_reading_time_seconds: Optional[Decimal]
    
    # Acknowledgment
    acknowledged_count: int
    acknowledgment_rate: Decimal
    
    # Timing
    average_time_to_read_hours: Optional[Decimal] = Field(
        None,
        description="Average time between delivery and reading"
    )
    
    # Engagement score
    engagement_score: Decimal = Field(..., ge=0, le=100, description="Overall engagement score")


class ReadingTime(BaseSchema):
    """Reading time analytics"""
    announcement_id: UUID
    
    # Statistics
    average_reading_time_seconds: Decimal
    median_reading_time_seconds: Decimal
    min_reading_time_seconds: int
    max_reading_time_seconds: int
    
    # Distribution
    quick_readers: int = Field(..., description="< 30 seconds")
    normal_readers: int = Field(..., description="30-120 seconds")
    thorough_readers: int = Field(..., description="> 120 seconds")


class AnnouncementAnalytics(BaseSchema):
    """Complete announcement analytics"""
    announcement_id: UUID
    title: str
    published_at: datetime
    
    # Delivery metrics
    delivery_metrics: DeliveryStatus
    
    # Engagement metrics
    engagement_metrics: EngagementMetrics
    
    # Reading patterns
    reading_by_hour: dict = Field(..., description="Hour -> read count")
    reading_by_day: dict = Field(..., description="Day -> read count")
    
    # Device breakdown
    reads_by_device: dict = Field(..., description="Device type -> count")

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\__init__.py ---
=======
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\announcement\__init__.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\__init__.py ---
>>>>>>> Stashed changes
"""
Announcement schemas package
"""
from app.schemas.announcement.announcement_base import (
    AnnouncementBase,
    AnnouncementCreate,
    AnnouncementUpdate
)
from app.schemas.announcement.announcement_response import (
    AnnouncementResponse,
    AnnouncementDetail,
    AnnouncementList
)
from app.schemas.announcement.announcement_targeting import (
    TargetingConfig,
    AudienceSelection,
    TargetRooms,
    TargetFloors
)
from app.schemas.announcement.announcement_scheduling import (
    ScheduleRequest,
    ScheduleConfig,
    RecurringAnnouncement
)
from app.schemas.announcement.announcement_approval import (
    ApprovalRequest,
    ApprovalWorkflow,
    SupervisorApprovalQueue
)
from app.schemas.announcement.announcement_delivery import (
    DeliveryConfig,
    DeliveryChannels,
    DeliveryStatus,
    DeliveryReport
)
from app.schemas.announcement.announcement_tracking import (
    ReadReceipt,
    AcknowledgmentTracking,
    EngagementMetrics
)
from app.schemas.announcement.announcement_filters import (
    AnnouncementFilterParams,
    SearchRequest,
    ArchiveRequest
)

__all__ = [
    # Base
    "AnnouncementBase",
    "AnnouncementCreate",
    "AnnouncementUpdate",
    
    # Response
    "AnnouncementResponse",
    "AnnouncementDetail",
    "AnnouncementList",
    
    # Targeting
    "TargetingConfig",
    "AudienceSelection",
    "TargetRooms",
    "TargetFloors",
    
    # Scheduling
    "ScheduleRequest",
    "ScheduleConfig",
    "RecurringAnnouncement",
    
    # Approval
    "ApprovalRequest",
    "ApprovalWorkflow",
    "SupervisorApprovalQueue",
    
    # Delivery
    "DeliveryConfig",
    "DeliveryChannels",
    "DeliveryStatus",
    "DeliveryReport",
    
    # Tracking
    "ReadReceipt",
    "AcknowledgmentTracking",
    "EngagementMetrics",
    
    # Filters
    "AnnouncementFilterParams",
    "SearchRequest",
    "ArchiveRequest",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_approval.py ---
# --- File: app/schemas/announcement/announcement_approval.py ---
"""
Announcement approval workflow schemas.

This module defines schemas for the approval process
when supervisors create announcements requiring admin approval.
"""

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "ApprovalStatus",
    "ApprovalRequest",
    "ApprovalResponse",
    "RejectionRequest",
    "ApprovalWorkflow",
    "SupervisorApprovalQueue",
    "PendingApprovalItem",
    "BulkApproval",
    "ApprovalHistory",
]


class ApprovalStatus(str, Enum):
    """Approval status enumeration."""
    
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    NOT_REQUIRED = "not_required"


class ApprovalRequest(BaseCreateSchema):
    """
    Request approval for an announcement.
    
    Submitted by supervisors when creating announcements
    that require admin approval.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID requiring approval",
    )
    requested_by: UUID = Field(
        ...,
        description="User requesting approval (supervisor)",
    )
    
    # Justification
    approval_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Justification for why approval is needed",
    )
    
    # Urgency
    is_urgent_request: bool = Field(
        False,
        description="Mark as urgent for prioritized review",
    )
    
    # Preferred approver (optional)
    preferred_approver_id: Optional[UUID] = Field(
        None,
        description="Preferred admin to review (optional)",
    )
    
    # Expected action
    auto_publish_on_approval: bool = Field(
        True,
        description="Automatically publish when approved",
    )


class ApprovalResponse(BaseSchema):
    """
    Response after approval/rejection decision.
    
    Contains the decision details and next steps.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    
    # Decision
    approved: bool = Field(
        ...,
        description="Whether the announcement was approved",
    )
    
    # Approver info
    approved_by: UUID = Field(
        ...,
        description="UUID of the approving/rejecting admin",
    )
    approved_by_name: str = Field(
        ...,
        description="Name of the admin",
    )
    approved_at: datetime = Field(
        ...,
        description="Decision timestamp",
    )
    
    # Feedback
    approval_notes: Optional[str] = Field(
        None,
        description="Notes from the approver",
    )
    
    # Publication status
    auto_published: bool = Field(
        ...,
        description="Whether announcement was auto-published",
    )
    published_at: Optional[datetime] = Field(
        None,
        description="Publication timestamp if published",
    )
    
    # Response message
    message: str = Field(
        ...,
        description="Human-readable response message",
    )


class RejectionRequest(BaseCreateSchema):
    """
    Reject an announcement with feedback.
    
    Provides reason and suggestions for improvement.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID to reject",
    )
    rejected_by: UUID = Field(
        ...,
        description="Admin rejecting the announcement",
    )
    
    rejection_reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Detailed reason for rejection (20-500 chars)",
    )
    
    # Constructive feedback
    suggested_modifications: Optional[str] = Field(
        None,
        max_length=1000,
        description="Suggestions for improving the announcement",
    )
    
    # Allow resubmission
    allow_resubmission: bool = Field(
        True,
        description="Whether creator can resubmit after modifications",
    )


class ApprovalWorkflow(BaseSchema):
    """
    Complete approval workflow status.
    
    Shows the current state of an announcement's approval process.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    title: str = Field(
        ...,
        description="Announcement title",
    )
    
    # Approval requirement
    requires_approval: bool = Field(
        ...,
        description="Whether approval is required",
    )
    approval_status: ApprovalStatus = Field(
        ...,
        description="Current approval status",
    )
    
    # Creator info
    created_by: UUID = Field(
        ...,
        description="Creator UUID",
    )
    created_by_name: str = Field(
        ...,
        description="Creator name",
    )
    created_by_role: str = Field(
        ...,
        description="Creator role (supervisor/admin)",
    )
    
    # Timeline
    submitted_for_approval_at: Optional[datetime] = Field(
        None,
        description="When submitted for approval",
    )
    approved_rejected_at: Optional[datetime] = Field(
        None,
        description="When decision was made",
    )
    
    # Current approver (if pending)
    pending_with: Optional[UUID] = Field(
        None,
        description="Admin currently reviewing (if assigned)",
    )
    pending_with_name: Optional[str] = Field(
        None,
        description="Reviewing admin's name",
    )
    
    # Decision details
    decision_by: Optional[UUID] = Field(
        None,
        description="Admin who made the decision",
    )
    decision_by_name: Optional[str] = Field(
        None,
        description="Decision maker's name",
    )
    
    # Rejection details (if rejected)
    rejection_reason: Optional[str] = Field(
        None,
        description="Rejection reason if rejected",
    )
    suggested_modifications: Optional[str] = Field(
        None,
        description="Suggested changes if rejected",
    )
    can_resubmit: bool = Field(
        True,
        description="Whether resubmission is allowed",
    )
    
    # Timing metrics
    time_pending_hours: Optional[float] = Field(
        None,
        ge=0,
        description="Hours in pending state",
    )


class PendingApprovalItem(BaseSchema):
    """
    Pending approval item for queue display.
    
    Lightweight schema for approval queue lists.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    title: str = Field(
        ...,
        description="Announcement title",
    )
    category: str = Field(
        ...,
        description="Announcement category",
    )
    
    # Creator
    created_by: UUID = Field(
        ...,
        description="Creator UUID",
    )
    created_by_name: str = Field(
        ...,
        description="Creator name",
    )
    
    # Timing
    submitted_at: datetime = Field(
        ...,
        description="Submission timestamp",
    )
    is_urgent: bool = Field(
        ...,
        description="Urgent flag",
    )
    
    # Preview
    content_preview: str = Field(
        ...,
        max_length=200,
        description="First 200 characters of content",
    )
    
    # Targeting
    target_audience: str = Field(
        ...,
        description="Target audience type",
    )
    estimated_recipients: int = Field(
        ...,
        ge=0,
        description="Estimated recipient count",
    )
    
    # Age
    hours_pending: float = Field(
        ...,
        ge=0,
        description="Hours in pending state",
    )


class SupervisorApprovalQueue(BaseSchema):
    """
    Supervisor's view of their pending approvals.
    
    Shows all announcements submitted by a supervisor
    and their current approval status.
    """
    
    supervisor_id: UUID = Field(
        ...,
        description="Supervisor UUID",
    )
    supervisor_name: str = Field(
        ...,
        description="Supervisor name",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel UUID",
    )
    
    # Counts
    total_pending: int = Field(
        ...,
        ge=0,
        description="Total pending approvals",
    )
    urgent_pending: int = Field(
        ...,
        ge=0,
        description="Urgent items pending",
    )
    approved_today: int = Field(
        0,
        ge=0,
        description="Items approved today",
    )
    rejected_today: int = Field(
        0,
        ge=0,
        description="Items rejected today",
    )
    
    # Items
    pending_announcements: list[PendingApprovalItem] = Field(
        default_factory=list,
        description="Pending approval items",
    )
    
    # Average response time
    avg_approval_time_hours: Optional[float] = Field(
        None,
        ge=0,
        description="Average approval response time",
    )


class BulkApproval(BaseCreateSchema):
    """
    Approve or reject multiple announcements at once.
    
    Used for batch operations in admin interfaces.
    """
    
    announcement_ids: list[UUID] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Announcement UUIDs to process (1-50)",
    )
    
    # Decision
    approved: bool = Field(
        ...,
        description="Approve (True) or reject (False)",
    )
    decided_by: UUID = Field(
        ...,
        description="Admin making the decision",
    )
    
    # Notes
    approval_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Notes for the decision",
    )
    
    # For rejections
    rejection_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Rejection reason (required if rejecting)",
    )
    
    # Publication
    publish_immediately: bool = Field(
        True,
        description="Publish approved announcements immediately",
    )
    
    @field_validator("announcement_ids")
    @classmethod
    def validate_unique_ids(cls, v: list[UUID]) -> list[UUID]:
        """Ensure no duplicate IDs."""
        if len(v) != len(set(v)):
            raise ValueError("Duplicate announcement IDs not allowed")
        return v
    
    @model_validator(mode="after")
    def validate_rejection_reason(self) -> "BulkApproval":
        """Require rejection reason when rejecting."""
        if not self.approved and not self.rejection_reason:
            raise ValueError("rejection_reason required when rejecting")
        return self


class ApprovalHistory(BaseSchema):
    """
    Approval history entry for audit trail.
    
    Records each action in the approval workflow.
    """
    
    id: UUID = Field(
        ...,
        description="History entry UUID",
    )
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    
    # Action
    action: str = Field(
        ...,
        description="Action taken (submitted/approved/rejected/resubmitted)",
    )
    previous_status: Optional[ApprovalStatus] = Field(
        None,
        description="Status before action",
    )
    new_status: ApprovalStatus = Field(
        ...,
        description="Status after action",
    )
    
    # Actor
    performed_by: UUID = Field(
        ...,
        description="User who performed the action",
    )
    performed_by_name: str = Field(
        ...,
        description="Actor's name",
    )
    performed_by_role: str = Field(
        ...,
        description="Actor's role",
    )
    
    # Details
    notes: Optional[str] = Field(
        None,
        description="Additional notes",
    )
    
    # Timestamp
    performed_at: datetime = Field(
        ...,
        description="When action was performed",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_base.py ---
# --- File: app/schemas/announcement/announcement_base.py ---
"""
Base announcement schemas for creation and updates.

This module defines foundational schemas for announcements with
comprehensive validation and targeting capabilities.
"""

from __future__ import annotations

from datetime import datetime
from typing import Optional
from uuid import UUID

from pydantic import (
    Field,
    HttpUrl,
    field_validator,
    model_validator,
)

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import (
    AnnouncementCategory,
    Priority,
    TargetAudience,
)

__all__ = [
    "AnnouncementBase",
    "AnnouncementCreate",
    "AnnouncementUpdate",
    "AnnouncementPublish",
    "AnnouncementUnpublish",
]


class AnnouncementBase(BaseSchema):
    """
    Base announcement schema with common fields.
    
    Contains all shared fields for announcement operations
    with comprehensive validation rules.
    """
    
    hostel_id: UUID = Field(
        ...,
        description="UUID of the hostel this announcement belongs to",
    )
    
    # Content
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Announcement title (5-255 characters)",
        examples=["Important: Maintenance Schedule Update"],
    )
    content: str = Field(
        ...,
        min_length=10,
        max_length=5000,
        description="Announcement content/body (10-5000 characters)",
    )
    
    # Classification
    category: AnnouncementCategory = Field(
        ...,
        description="Announcement category for organization",
    )
    priority: Priority = Field(
        Priority.MEDIUM,
        description="Priority level affecting display order",
    )
    
    # Visibility flags
    is_urgent: bool = Field(
        False,
        description="Mark as urgent for highlighted display",
    )
    is_pinned: bool = Field(
        False,
        description="Pin to top of announcement list",
    )
    
    # Target audience configuration
    target_audience: TargetAudience = Field(
        TargetAudience.ALL,
        description="Target audience type",
    )
    target_room_ids: list[UUID] = Field(
        default_factory=list,
        description="Specific room UUIDs when targeting specific rooms",
    )
    target_student_ids: list[UUID] = Field(
        default_factory=list,
        description="Specific student UUIDs for individual targeting",
    )
    target_floor_numbers: list[int] = Field(
        default_factory=list,
        description="Specific floor numbers when targeting floors",
    )
    
    # Attachments
    attachments: list[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="Attachment URLs (max 10)",
    )
    
    # Expiry
    expires_at: Optional[datetime] = Field(
        None,
        description="When the announcement expires and becomes inactive",
    )
    
    @field_validator("title")
    @classmethod
    def validate_title(cls, v: str) -> str:
        """Normalize and validate title."""
        # Strip and normalize whitespace
        normalized = " ".join(v.split())
        if len(normalized) < 5:
            raise ValueError("Title must be at least 5 characters after normalization")
        return normalized
    
    @field_validator("content")
    @classmethod
    def validate_content(cls, v: str) -> str:
        """Validate and clean content."""
        stripped = v.strip()
        if len(stripped) < 10:
            raise ValueError("Content must be at least 10 characters")
        return stripped
    
    @field_validator("target_floor_numbers")
    @classmethod
    def validate_floor_numbers(cls, v: list[int]) -> list[int]:
        """Validate floor numbers are positive and unique."""
        if v:
            if any(f < 0 for f in v):
                raise ValueError("Floor numbers must be non-negative")
            if len(v) != len(set(v)):
                raise ValueError("Duplicate floor numbers not allowed")
        return sorted(v)
    
    @field_validator("expires_at")
    @classmethod
    def validate_expiry(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Ensure expiry is in the future."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Expiry date must be in the future")
        return v
    
    @model_validator(mode="after")
    def validate_targeting(self) -> "AnnouncementBase":
        """Validate targeting configuration is consistent."""
        audience = self.target_audience
        
        if audience == TargetAudience.SPECIFIC_ROOMS and not self.target_room_ids:
            raise ValueError(
                "target_room_ids required when target_audience is SPECIFIC_ROOMS"
            )
        
        if audience == TargetAudience.SPECIFIC_FLOORS and not self.target_floor_numbers:
            raise ValueError(
                "target_floor_numbers required when target_audience is SPECIFIC_FLOORS"
            )
        
        if audience == TargetAudience.INDIVIDUAL and not self.target_student_ids:
            raise ValueError(
                "target_student_ids required when target_audience is INDIVIDUAL"
            )
        
        # Clear irrelevant targeting when audience is ALL
        if audience == TargetAudience.ALL:
            self.target_room_ids = []
            self.target_student_ids = []
            self.target_floor_numbers = []
        
        return self


class AnnouncementCreate(AnnouncementBase, BaseCreateSchema):
    """
    Schema for creating a new announcement.
    
    Includes creator information and delivery settings.
    """
    
    created_by: UUID = Field(
        ...,
        description="UUID of the user creating the announcement (admin/supervisor)",
    )
    
    # Delivery channel settings
    send_email: bool = Field(
        False,
        description="Send email notification to recipients",
    )
    send_sms: bool = Field(
        False,
        description="Send SMS notification to recipients",
    )
    send_push: bool = Field(
        True,
        description="Send push notification to recipients",
    )
    
    # Scheduling
    scheduled_publish_at: Optional[datetime] = Field(
        None,
        description="Schedule for future publication (None = immediate)",
    )
    
    # Acknowledgment settings
    requires_acknowledgment: bool = Field(
        False,
        description="Whether recipients must acknowledge reading",
    )
    acknowledgment_deadline: Optional[datetime] = Field(
        None,
        description="Deadline for acknowledgment if required",
    )
    
    @field_validator("scheduled_publish_at")
    @classmethod
    def validate_schedule(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Ensure scheduled time is in the future."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Scheduled publish time must be in the future")
        return v
    
    @model_validator(mode="after")
    def validate_acknowledgment(self) -> "AnnouncementCreate":
        """Validate acknowledgment settings."""
        if self.requires_acknowledgment:
            if self.acknowledgment_deadline is None:
                raise ValueError(
                    "acknowledgment_deadline required when requires_acknowledgment is True"
                )
            if self.acknowledgment_deadline <= datetime.utcnow():
                raise ValueError("Acknowledgment deadline must be in the future")
            if self.expires_at and self.acknowledgment_deadline > self.expires_at:
                raise ValueError(
                    "Acknowledgment deadline cannot be after announcement expiry"
                )
        return self
    
    @model_validator(mode="after")
    def validate_at_least_one_channel(self) -> "AnnouncementCreate":
        """Ensure at least one delivery channel is enabled."""
        if not any([self.send_email, self.send_sms, self.send_push]):
            raise ValueError("At least one delivery channel must be enabled")
        return self


class AnnouncementUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing announcement.
    
    All fields are optional for partial updates.
    Published announcements have restricted update capabilities.
    """
    
    title: Optional[str] = Field(
        None,
        min_length=5,
        max_length=255,
        description="Updated announcement title",
    )
    content: Optional[str] = Field(
        None,
        min_length=10,
        max_length=5000,
        description="Updated announcement content",
    )
    category: Optional[AnnouncementCategory] = Field(
        None,
        description="Updated category",
    )
    priority: Optional[Priority] = Field(
        None,
        description="Updated priority level",
    )
    
    # Visibility
    is_urgent: Optional[bool] = Field(
        None,
        description="Update urgent flag",
    )
    is_pinned: Optional[bool] = Field(
        None,
        description="Update pinned flag",
    )
    
    # Expiry
    expires_at: Optional[datetime] = Field(
        None,
        description="Updated expiry datetime",
    )
    
    # Attachments
    attachments: Optional[list[HttpUrl]] = Field(
        None,
        max_length=10,
        description="Updated attachment list",
    )
    
    # Note: Targeting cannot be updated after creation
    # Note: Delivery channels cannot be changed after creation
    
    @field_validator("title")
    @classmethod
    def validate_title(cls, v: Optional[str]) -> Optional[str]:
        """Normalize title if provided."""
        if v is not None:
            normalized = " ".join(v.split())
            if len(normalized) < 5:
                raise ValueError("Title must be at least 5 characters")
            return normalized
        return v
    
    @field_validator("expires_at")
    @classmethod
    def validate_expiry(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Ensure expiry is in the future."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Expiry date must be in the future")
        return v
    
    @model_validator(mode="after")
    def validate_has_updates(self) -> "AnnouncementUpdate":
        """Ensure at least one field is being updated."""
        update_fields = [
            "title", "content", "category", "priority",
            "is_urgent", "is_pinned", "expires_at", "attachments"
        ]
        if not any(getattr(self, field) is not None for field in update_fields):
            raise ValueError("At least one field must be provided for update")
        return self


class AnnouncementPublish(BaseCreateSchema):
    """
    Schema for publishing a draft announcement.
    
    Allows immediate or scheduled publication.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="UUID of the announcement to publish",
    )
    published_by: UUID = Field(
        ...,
        description="UUID of the user publishing",
    )
    publish_immediately: bool = Field(
        True,
        description="Publish now or schedule for later",
    )
    scheduled_publish_at: Optional[datetime] = Field(
        None,
        description="Scheduled publication time if not immediate",
    )
    
    @model_validator(mode="after")
    def validate_publish_time(self) -> "AnnouncementPublish":
        """Validate publication timing."""
        if not self.publish_immediately and not self.scheduled_publish_at:
            raise ValueError(
                "scheduled_publish_at required when publish_immediately is False"
            )
        if self.scheduled_publish_at and self.scheduled_publish_at <= datetime.utcnow():
            raise ValueError("Scheduled publish time must be in the future")
        return self


class AnnouncementUnpublish(BaseCreateSchema):
    """
    Schema for unpublishing an announcement.
    
    Makes the announcement invisible but preserves it.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="UUID of the announcement to unpublish",
    )
    unpublished_by: UUID = Field(
        ...,
        description="UUID of the user unpublishing",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for unpublishing",
    )
    notify_recipients: bool = Field(
        False,
        description="Notify recipients about the unpublishing",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_delivery.py ---
# --- File: app/schemas/announcement/announcement_delivery.py ---
"""
Announcement delivery schemas.

This module defines schemas for managing announcement delivery
across multiple channels (email, SMS, push, in-app).
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "DeliveryChannel",
    "DeliveryStrategy",
    "DeliveryState",
    "DeliveryConfig",
    "DeliveryChannels",
    "DeliveryStatus",
    "DeliveryReport",
    "ChannelDeliveryStats",
    "FailedDelivery",
    "BatchDelivery",
    "RetryDelivery",
]


class DeliveryChannel(str, Enum):
    """Delivery channel enumeration."""
    
    EMAIL = "email"
    SMS = "sms"
    PUSH = "push"
    IN_APP = "in_app"


class DeliveryStrategy(str, Enum):
    """Delivery strategy enumeration."""
    
    IMMEDIATE = "immediate"
    SCHEDULED = "scheduled"
    BATCHED = "batched"


class DeliveryState(str, Enum):
    """Delivery state enumeration."""
    
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    PAUSED = "paused"
    CANCELLED = "cancelled"


class DeliveryChannels(BaseSchema):
    """
    Delivery channel configuration.
    
    Defines which channels to use and their priorities.
    """
    
    email: bool = Field(
        False,
        description="Enable email delivery",
    )
    sms: bool = Field(
        False,
        description="Enable SMS delivery",
    )
    push: bool = Field(
        True,
        description="Enable push notification delivery",
    )
    in_app: bool = Field(
        True,
        description="Enable in-app notification",
    )
    
    # Channel priority for fallback
    primary_channel: DeliveryChannel = Field(
        DeliveryChannel.PUSH,
        description="Primary delivery channel",
    )
    fallback_channels: list[DeliveryChannel] = Field(
        default_factory=list,
        description="Fallback channels if primary fails",
    )
    
    @model_validator(mode="after")
    def validate_channels(self) -> "DeliveryChannels":
        """Ensure at least one channel is enabled."""
        if not any([self.email, self.sms, self.push, self.in_app]):
            raise ValueError("At least one delivery channel must be enabled")
        
        # Validate primary channel is enabled
        channel_map = {
            DeliveryChannel.EMAIL: self.email,
            DeliveryChannel.SMS: self.sms,
            DeliveryChannel.PUSH: self.push,
            DeliveryChannel.IN_APP: self.in_app,
        }
        
        if not channel_map.get(self.primary_channel, False):
            raise ValueError(
                f"Primary channel '{self.primary_channel.value}' is not enabled"
            )
        
        # Validate fallback channels are enabled
        for channel in self.fallback_channels:
            if not channel_map.get(channel, False):
                raise ValueError(
                    f"Fallback channel '{channel.value}' is not enabled"
                )
        
        return self


class DeliveryConfig(BaseSchema):
    """
    Complete delivery configuration for announcement.
    
    Defines how and when to deliver the announcement.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    
    # Channels
    channels: DeliveryChannels = Field(
        ...,
        description="Channel configuration",
    )
    
    # Delivery strategy
    delivery_strategy: DeliveryStrategy = Field(
        DeliveryStrategy.IMMEDIATE,
        description="Delivery timing strategy",
    )
    
    # Batch settings (if batched)
    batch_size: Optional[int] = Field(
        None,
        ge=10,
        le=1000,
        description="Recipients per batch (10-1000)",
    )
    batch_interval_minutes: Optional[int] = Field(
        None,
        ge=1,
        le=60,
        description="Minutes between batches (1-60)",
    )
    
    # Rate limiting
    max_per_minute: Optional[int] = Field(
        None,
        ge=1,
        le=10000,
        description="Maximum deliveries per minute",
    )
    
    # Retry settings
    max_retries: int = Field(
        3,
        ge=0,
        le=10,
        description="Maximum retry attempts for failed deliveries",
    )
    retry_delay_minutes: int = Field(
        5,
        ge=1,
        le=60,
        description="Minutes between retries",
    )
    
    @model_validator(mode="after")
    def validate_batch_settings(self) -> "DeliveryConfig":
        """Validate batch settings when using batched strategy."""
        if self.delivery_strategy == DeliveryStrategy.BATCHED:
            if not self.batch_size:
                raise ValueError(
                    "batch_size required for batched delivery strategy"
                )
        return self


class ChannelDeliveryStats(BaseSchema):
    """
    Delivery statistics for a specific channel.
    
    Provides detailed metrics for channel performance.
    """
    
    channel: DeliveryChannel = Field(
        ...,
        description="Delivery channel",
    )
    
    # Counts
    sent: int = Field(
        ...,
        ge=0,
        description="Number sent",
    )
    
    delivered: int = Field(
        ...,
        ge=0,
        description="Number successfully delivered",
    )
    failed: int = Field(
        ...,
        ge=0,
        description="Number failed",
    )
    pending: int = Field(
        ...,
        ge=0,
        description="Number pending",
    )
    bounced: int = Field(
        0,
        ge=0,
        description="Number bounced (email)",
    )
    
    # Rates
    delivery_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Delivery success rate percentage",
    )
    
    # Timing
    average_delivery_time_seconds: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average time to deliver in seconds",
    )
    fastest_delivery_seconds: Optional[int] = Field(
        None,
        ge=0,
        description="Fastest delivery time",
    )
    slowest_delivery_seconds: Optional[int] = Field(
        None,
        ge=0,
        description="Slowest delivery time",
    )


class DeliveryStatus(BaseSchema):
    """
    Current delivery status for announcement.
    
    Real-time status of delivery progress across all channels.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    
    # Overall status
    state: DeliveryState = Field(
        ...,
        description="Overall delivery state",
    )
    
    # Total counts
    total_recipients: int = Field(
        ...,
        ge=0,
        description="Total recipients",
    )
    total_delivered: int = Field(
        ...,
        ge=0,
        description="Total successfully delivered",
    )
    total_failed: int = Field(
        ...,
        ge=0,
        description="Total failed",
    )
    total_pending: int = Field(
        ...,
        ge=0,
        description="Total pending",
    )
    
    # By channel
    email_sent: int = Field(
        0,
        ge=0,
        description="Emails sent",
    )
    email_delivered: int = Field(
        0,
        ge=0,
        description="Emails delivered",
    )
    email_failed: int = Field(
        0,
        ge=0,
        description="Emails failed",
    )
    
    sms_sent: int = Field(
        0,
        ge=0,
        description="SMS sent",
    )
    sms_delivered: int = Field(
        0,
        ge=0,
        description="SMS delivered",
    )
    sms_failed: int = Field(
        0,
        ge=0,
        description="SMS failed",
    )
    
    push_sent: int = Field(
        0,
        ge=0,
        description="Push notifications sent",
    )
    push_delivered: int = Field(
        0,
        ge=0,
        description="Push notifications delivered",
    )
    push_failed: int = Field(
        0,
        ge=0,
        description="Push notifications failed",
    )
    
    in_app_sent: int = Field(
        0,
        ge=0,
        description="In-app notifications sent",
    )
    in_app_delivered: int = Field(
        0,
        ge=0,
        description="In-app notifications delivered",
    )
    
    # Rates
    delivery_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall delivery rate percentage",
    )
    
    # Timeline
    delivery_started_at: Optional[datetime] = Field(
        None,
        description="When delivery started",
    )
    delivery_completed_at: Optional[datetime] = Field(
        None,
        description="When delivery completed",
    )
    last_activity_at: Optional[datetime] = Field(
        None,
        description="Last delivery activity timestamp",
    )
    
    # Progress (for batched delivery)
    progress_percentage: Decimal = Field(
        Decimal("0"),
        ge=0,
        le=100,
        description="Delivery progress percentage",
    )
    estimated_completion: Optional[datetime] = Field(
        None,
        description="Estimated completion time",
    )


class FailedDelivery(BaseSchema):
    """
    Failed delivery record for troubleshooting.
    
    Contains details about why delivery failed.
    """
    
    id: UUID = Field(
        ...,
        description="Failed delivery record UUID",
    )
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    
    # Recipient info
    recipient_id: UUID = Field(
        ...,
        description="Recipient student UUID",
    )
    recipient_name: str = Field(
        ...,
        description="Recipient name",
    )
    recipient_contact: str = Field(
        ...,
        description="Contact info used (email/phone)",
    )
    
    # Failure details
    channel: DeliveryChannel = Field(
        ...,
        description="Channel that failed",
    )
    failure_reason: str = Field(
        ...,
        description="Reason for failure",
    )
    failure_code: Optional[str] = Field(
        None,
        description="Error code if available",
    )
    failed_at: datetime = Field(
        ...,
        description="Failure timestamp",
    )
    
    # Retry info
    retry_count: int = Field(
        0,
        ge=0,
        description="Number of retry attempts",
    )
    retry_attempted: bool = Field(
        False,
        description="Whether retry was attempted",
    )
    retry_successful: Optional[bool] = Field(
        None,
        description="Whether retry succeeded",
    )
    last_retry_at: Optional[datetime] = Field(
        None,
        description="Last retry timestamp",
    )
    next_retry_at: Optional[datetime] = Field(
        None,
        description="Next scheduled retry",
    )
    
    # Resolution
    is_resolved: bool = Field(
        False,
        description="Whether issue is resolved",
    )
    resolution_notes: Optional[str] = Field(
        None,
        description="Resolution notes",
    )


class DeliveryReport(BaseSchema):
    """
    Comprehensive delivery report for announcement.
    
    Full analytics on delivery performance.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    title: str = Field(
        ...,
        description="Announcement title",
    )
    
    # Overall metrics
    total_recipients: int = Field(
        ...,
        ge=0,
        description="Total recipients",
    )
    delivered_count: int = Field(
        ...,
        ge=0,
        description="Successfully delivered",
    )
    failed_count: int = Field(
        ...,
        ge=0,
        description="Failed deliveries",
    )
    pending_count: int = Field(
        ...,
        ge=0,
        description="Pending deliveries",
    )
    
    # Rates
    overall_delivery_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall delivery success rate",
    )
    
    # By channel breakdown
    channel_breakdown: dict[str, ChannelDeliveryStats] = Field(
        default_factory=dict,
        description="Stats per delivery channel",
    )
    
    # Failed recipients (limited list)
    failed_recipients: list[FailedDelivery] = Field(
        default_factory=list,
        max_length=100,
        description="Failed delivery records (max 100)",
    )
    has_more_failures: bool = Field(
        False,
        description="Whether there are more failures not shown",
    )
    total_failures: int = Field(
        0,
        ge=0,
        description="Total number of failures",
    )
    
    # Timeline
    delivery_started_at: Optional[datetime] = Field(
        None,
        description="Delivery start time",
    )
    delivery_completed_at: Optional[datetime] = Field(
        None,
        description="Delivery completion time",
    )
    delivery_duration_minutes: Optional[int] = Field(
        None,
        ge=0,
        description="Total delivery duration in minutes",
    )
    
    # Report metadata
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp",
    )


class BatchDelivery(BaseSchema):
    """
    Batch delivery progress tracking.
    
    Shows progress of batched delivery operations.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    
    # Batch info
    total_batches: int = Field(
        ...,
        ge=1,
        description="Total number of batches",
    )
    completed_batches: int = Field(
        ...,
        ge=0,
        description="Completed batches",
    )
    current_batch: int = Field(
        ...,
        ge=0,
        description="Currently processing batch",
    )
    batch_size: int = Field(
        ...,
        ge=1,
        description="Recipients per batch",
    )
    
    # Recipient counts
    total_recipients: int = Field(
        ...,
        ge=0,
        description="Total recipients",
    )
    processed_recipients: int = Field(
        ...,
        ge=0,
        description="Recipients processed so far",
    )
    
    # Current batch stats
    current_batch_sent: int = Field(
        0,
        ge=0,
        description="Sent in current batch",
    )
    current_batch_failed: int = Field(
        0,
        ge=0,
        description="Failed in current batch",
    )
    
    # Timing
    started_at: datetime = Field(
        ...,
        description="Batch delivery start time",
    )
    estimated_completion: Optional[datetime] = Field(
        None,
        description="Estimated completion time",
    )
    
    # Status
    status: DeliveryState = Field(
        ...,
        description="Current batch delivery status",
    )
    
    # Control
    is_paused: bool = Field(
        False,
        description="Whether batch delivery is paused",
    )
    pause_reason: Optional[str] = Field(
        None,
        description="Reason for pause if paused",
    )


class RetryDelivery(BaseCreateSchema):
    """
    Retry failed deliveries for an announcement.
    
    Allows selective retry of failed delivery attempts.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    initiated_by: UUID = Field(
        ...,
        description="User initiating the retry",
    )
    
    # Retry scope
    retry_failed_only: bool = Field(
        True,
        description="Only retry failed deliveries",
    )
    retry_channels: list[DeliveryChannel] = Field(
        default_factory=list,
        description="Specific channels to retry (empty = all)",
    )
    
    # Specific recipients
    recipient_ids: Optional[list[UUID]] = Field(
        None,
        description="Retry specific recipients only",
    )
    
    # Retry settings
    max_retry_attempts: int = Field(
        1,
        ge=1,
        le=5,
        description="Maximum retry attempts (1-5)",
    )
    use_fallback_channels: bool = Field(
        True,
        description="Use fallback channels if primary fails again",
    )
    
    # Timing
    delay_minutes: int = Field(
        0,
        ge=0,
        le=60,
        description="Delay before starting retry (0-60 minutes)",
    )
    
    @field_validator("recipient_ids")
    @classmethod
    def validate_recipient_ids(
        cls, v: Optional[list[UUID]]
    ) -> Optional[list[UUID]]:
        """Ensure recipient IDs are unique."""
        if v:
            if len(v) != len(set(v)):
                raise ValueError("Duplicate recipient IDs not allowed")
            if len(v) > 1000:
                raise ValueError("Maximum 1000 recipients per retry request")
        return v


class DeliveryPause(BaseCreateSchema):
    """
    Pause ongoing delivery.
    
    Temporarily stops batch delivery processing.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    paused_by: UUID = Field(
        ...,
        description="User pausing delivery",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for pausing (10-500 chars)",
    )
    
    # Resume settings
    auto_resume: bool = Field(
        False,
        description="Automatically resume after duration",
    )
    resume_after_minutes: Optional[int] = Field(
        None,
        ge=5,
        le=1440,
        description="Minutes until auto-resume (5-1440)",
    )
    
    @model_validator(mode="after")
    def validate_auto_resume(self) -> "DeliveryPause":
        """Validate auto-resume settings."""
        if self.auto_resume and not self.resume_after_minutes:
            raise ValueError(
                "resume_after_minutes required when auto_resume is True"
            )
        return self


class DeliveryResume(BaseCreateSchema):
    """
    Resume paused delivery.
    
    Continues batch delivery from where it stopped.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    resumed_by: UUID = Field(
        ...,
        description="User resuming delivery",
    )
    
    # Resume options
    skip_failed: bool = Field(
        False,
        description="Skip previously failed recipients",
    )
    restart_current_batch: bool = Field(
        False,
        description="Restart current batch from beginning",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_filters.py ---
# --- File: app/schemas/announcement/announcement_filters.py ---
"""
Announcement filter and search schemas.

This module defines schemas for filtering, searching,
and exporting announcements.
"""

from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseFilterSchema
from app.schemas.common.enums import AnnouncementCategory, Priority

__all__ = [
    "ExportFormat",
    "AnnouncementSortField",
    "AnnouncementFilterParams",
    "SearchRequest",
    "ArchiveRequest",
    "AnnouncementExportRequest",
    "BulkDeleteRequest",
    "AnnouncementStatsRequest",
]


class ExportFormat(str, Enum):
    """Export format enumeration."""
    
    PDF = "pdf"
    EXCEL = "excel"
    CSV = "csv"
    JSON = "json"


class AnnouncementSortField(str, Enum):
    """Sort field enumeration."""
    
    CREATED_AT = "created_at"
    UPDATED_AT = "updated_at"
    PUBLISHED_AT = "published_at"
    TITLE = "title"
    PRIORITY = "priority"
    ENGAGEMENT_RATE = "engagement_rate"
    READ_COUNT = "read_count"


class AnnouncementFilterParams(BaseFilterSchema):
    """
    Comprehensive announcement filter parameters.
    
    Supports filtering by various criteria for announcement lists.
    """
    
    # Text search
    search: Optional[str] = Field(
        None,
        min_length=2,
        max_length=100,
        description="Search in title and content",
    )
    
    # Hostel filter
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by single hostel",
    )
    hostel_ids: Optional[list[UUID]] = Field(
        None,
        max_length=50,
        description="Filter by multiple hostels",
    )
    
    # Category filter
    category: Optional[AnnouncementCategory] = Field(
        None,
        description="Filter by single category",
    )
    categories: Optional[list[AnnouncementCategory]] = Field(
        None,
        description="Filter by multiple categories",
    )
    exclude_categories: Optional[list[AnnouncementCategory]] = Field(
        None,
        description="Exclude specific categories",
    )
    
    # Priority filter
    priority: Optional[Priority] = Field(
        None,
        description="Filter by single priority",
    )
    priorities: Optional[list[Priority]] = Field(
        None,
        description="Filter by multiple priorities",
    )
    min_priority: Optional[Priority] = Field(
        None,
        description="Minimum priority level",
    )
    
    # Status filters
    is_published: Optional[bool] = Field(
        None,
        description="Filter by publication status",
    )
    is_urgent: Optional[bool] = Field(
        None,
        description="Filter by urgent flag",
    )
    is_pinned: Optional[bool] = Field(
        None,
        description="Filter by pinned flag",
    )
    requires_acknowledgment: Optional[bool] = Field(
        None,
        description="Filter by acknowledgment requirement",
    )
    
    # Creator filters
    created_by: Optional[UUID] = Field(
        None,
        description="Filter by creator UUID",
    )
    created_by_role: Optional[str] = Field(
        None,
        pattern=r"^(admin|supervisor|super_admin)$",
        description="Filter by creator role",
    )
    
    # Date filters
    published_date_from: Optional[date] = Field(
        None,
        description="Published on or after this date",
    )
    published_date_to: Optional[date] = Field(
        None,
        description="Published on or before this date",
    )
    created_date_from: Optional[date] = Field(
        None,
        description="Created on or after this date",
    )
    created_date_to: Optional[date] = Field(
        None,
        description="Created on or before this date",
    )
    
    # Expiry filters
    active_only: Optional[bool] = Field(
        None,
        description="Only non-expired announcements",
    )
    expired_only: Optional[bool] = Field(
        None,
        description="Only expired announcements",
    )
    expires_before: Optional[date] = Field(
        None,
        description="Expires before this date",
    )
    expires_after: Optional[date] = Field(
        None,
        description="Expires after this date",
    )
    
    # Approval filters
    approval_pending: Optional[bool] = Field(
        None,
        description="Filter by pending approval status",
    )
    approved_by: Optional[UUID] = Field(
        None,
        description="Filter by approver UUID",
    )
    
    # Engagement filters
    min_read_rate: Optional[int] = Field(
        None,
        ge=0,
        le=100,
        description="Minimum read rate percentage",
    )
    min_engagement_score: Optional[int] = Field(
        None,
        ge=0,
        le=100,
        description="Minimum engagement score",
    )
    
    # Sorting
    sort_by: AnnouncementSortField = Field(
        AnnouncementSortField.CREATED_AT,
        description="Field to sort by",
    )
    sort_order: str = Field(
        "desc",
        pattern=r"^(asc|desc)$",
        description="Sort order",
    )
    
    # Pagination
    page: int = Field(
        1,
        ge=1,
        description="Page number",
    )
    page_size: int = Field(
        20,
        ge=1,
        le=100,
        description="Items per page",
    )
    
    @field_validator("hostel_ids")
    @classmethod
    def validate_hostel_ids(cls, v: Optional[list[UUID]]) -> Optional[list[UUID]]:
        """Ensure unique hostel IDs."""
        if v and len(v) != len(set(v)):
            raise ValueError("Duplicate hostel IDs not allowed")
        return v
    
    @field_validator("published_date_to")
    @classmethod
    def validate_published_date_range(
        cls, v: Optional[date], info
    ) -> Optional[date]:
        """Validate date range."""
        from_date = info.data.get("published_date_from")
        if v and from_date and v < from_date:
            raise ValueError("published_date_to must be after published_date_from")
        return v
    
    @field_validator("created_date_to")
    @classmethod
    def validate_created_date_range(
        cls, v: Optional[date], info
    ) -> Optional[date]:
        """Validate date range."""
        from_date = info.data.get("created_date_from")
        if v and from_date and v < from_date:
            raise ValueError("created_date_to must be after created_date_from")
        return v
    
    @model_validator(mode="after")
    def validate_conflicting_filters(self) -> "AnnouncementFilterParams":
        """Check for conflicting filter combinations."""
        if self.active_only and self.expired_only:
            raise ValueError("Cannot use both active_only and expired_only")
        
        if self.hostel_id and self.hostel_ids:
            raise ValueError("Use either hostel_id or hostel_ids, not both")
        
        if self.category and self.categories:
            raise ValueError("Use either category or categories, not both")
        
        return self


class SearchRequest(BaseFilterSchema):
    """
    Full-text search request for announcements.
    
    Provides advanced search capabilities.
    """
    
    query: str = Field(
        ...,
        min_length=2,
        max_length=200,
        description="Search query string",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Limit search to specific hostel",
    )
    
    # Search scope
    search_in_title: bool = Field(
        True,
        description="Search in announcement titles",
    )
    search_in_content: bool = Field(
        True,
        description="Search in announcement content",
    )
    search_in_attachments: bool = Field(
        False,
        description="Search in attachment names",
    )
    
    # Filters
    category: Optional[AnnouncementCategory] = Field(
        None,
        description="Filter by category",
    )
    published_only: bool = Field(
        True,
        description="Only search published announcements",
    )
    
    # Date range
    date_from: Optional[date] = Field(
        None,
        description="Search from this date",
    )
    date_to: Optional[date] = Field(
        None,
        description="Search until this date",
    )
    
    # Pagination
    page: int = Field(
        1,
        ge=1,
        description="Page number",
    )
    page_size: int = Field(
        20,
        ge=1,
        le=100,
        description="Results per page",
    )
    
    # Result options
    highlight_matches: bool = Field(
        True,
        description="Highlight matching text in results",
    )
    
    @model_validator(mode="after")
    def validate_search_scope(self) -> "SearchRequest":
        """Ensure at least one search field is enabled."""
        if not any([
            self.search_in_title,
            self.search_in_content,
            self.search_in_attachments
        ]):
            raise ValueError("At least one search field must be enabled")
        return self


class ArchiveRequest(BaseCreateSchema):
    """
    Archive old announcements.
    
    Moves old announcements to archive storage.
    """
    
    hostel_id: UUID = Field(
        ...,
        description="Hostel UUID",
    )
    archived_by: UUID = Field(
        ...,
        description="User performing the archive",
    )
    
    # Archive criteria
    archive_before_date: date = Field(
        ...,
        description="Archive announcements published before this date",
    )
    
    # Options
    archive_expired_only: bool = Field(
        True,
        description="Only archive expired announcements",
    )
    archive_read_only: bool = Field(
        False,
        description="Only archive fully-read announcements (100% read rate)",
    )
    archive_acknowledged_only: bool = Field(
        False,
        description="Only archive fully-acknowledged announcements",
    )
    
    # Exclusions
    exclude_pinned: bool = Field(
        True,
        description="Don't archive pinned announcements",
    )
    exclude_urgent: bool = Field(
        False,
        description="Don't archive urgent announcements",
    )
    exclude_categories: Optional[list[AnnouncementCategory]] = Field(
        None,
        description="Categories to exclude from archiving",
    )
    
    # Preview mode
    dry_run: bool = Field(
        False,
        description="Preview what would be archived without archiving",
    )
    
    @field_validator("archive_before_date")
    @classmethod
    def validate_archive_date(cls, v: date) -> date:
        """Ensure archive date is in the past."""
        if v >= date.today():
            raise ValueError("Archive date must be in the past")
        return v


class AnnouncementExportRequest(BaseFilterSchema):
    """
    Export announcements to file.
    
    Generate downloadable exports in various formats.
    """
    
    hostel_id: UUID = Field(
        ...,
        description="Hostel UUID",
    )
    exported_by: UUID = Field(
        ...,
        description="User requesting export",
    )
    
    # Filters
    filters: Optional[AnnouncementFilterParams] = Field(
        None,
        description="Filter parameters for export",
    )
    
    # Format
    format: ExportFormat = Field(
        ExportFormat.PDF,
        description="Export file format",
    )
    
    # Content options
    include_content: bool = Field(
        True,
        description="Include full announcement content",
    )
    include_engagement_metrics: bool = Field(
        True,
        description="Include engagement metrics",
    )
    include_recipient_list: bool = Field(
        False,
        description="Include list of recipients",
    )
    include_read_receipts: bool = Field(
        False,
        description="Include read receipt details",
    )
    include_acknowledgments: bool = Field(
        False,
        description="Include acknowledgment details",
    )
    
    # Date range
    date_from: Optional[date] = Field(
        None,
        description="Export from this date",
    )
    date_to: Optional[date] = Field(
        None,
        description="Export until this date",
    )
    
    # Delivery
    send_to_email: Optional[str] = Field(
        None,
        description="Email address to send export (optional)",
    )
    
    @field_validator("date_to")
    @classmethod
    def validate_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate date range."""
        date_from = info.data.get("date_from")
        if v and date_from and v < date_from:
            raise ValueError("date_to must be after date_from")
        return v


class BulkDeleteRequest(BaseCreateSchema):
    """
    Bulk delete announcements.
    
    Permanently remove multiple announcements.
    """
    
    announcement_ids: list[UUID] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Announcement UUIDs to delete (1-100)",
    )
    deleted_by: UUID = Field(
        ...,
        description="User performing the deletion",
    )
    
    # Confirmation
    confirm_permanent: bool = Field(
        False,
        description="Confirm permanent deletion (required)",
    )
    
    # Options
    force_delete_published: bool = Field(
        False,
        description="Allow deletion of published announcements",
    )
    
    @field_validator("announcement_ids")
    @classmethod
    def validate_unique_ids(cls, v: list[UUID]) -> list[UUID]:
        """Ensure unique IDs."""
        if len(v) != len(set(v)):
            raise ValueError("Duplicate announcement IDs not allowed")
        return v
    
    @model_validator(mode="after")
    def validate_confirmation(self) -> "BulkDeleteRequest":
        """Require confirmation for bulk delete."""
        if not self.confirm_permanent:
            raise ValueError(
                "confirm_permanent must be True to proceed with deletion"
            )
        return self


class AnnouncementStatsRequest(BaseFilterSchema):
    """
    Request announcement statistics.
    
    Parameters for generating announcement analytics.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel UUID (None for all hostels)",
    )
    
    # Time range
    period_start: date = Field(
        ...,
        description="Statistics period start date",
    )
    period_end: date = Field(
        ...,
        description="Statistics period end date",
    )
    
    # Grouping
    group_by: str = Field(
        "day",
        pattern=r"^(hour|day|week|month)$",
        description="Time grouping for trends",
    )
    
    # Metrics to include
    include_category_breakdown: bool = Field(
        True,
        description="Include breakdown by category",
    )
    include_engagement_trends: bool = Field(
        True,
        description="Include engagement trends over time",
    )
    include_creator_stats: bool = Field(
        False,
        description="Include statistics by creator",
    )
    include_comparison: bool = Field(
        False,
        description="Include comparison with previous period",
    )
    
    @field_validator("period_end")
    @classmethod
    def validate_period(cls, v: date, info) -> date:
        """Validate period range."""
        period_start = info.data.get("period_start")
        if period_start and v < period_start:
            raise ValueError("period_end must be after period_start")
        
        # Limit to 1 year
        if period_start:
            days_diff = (v - period_start).days
            if days_diff > 365:
                raise ValueError("Period cannot exceed 1 year")
        
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_response.py ---
# --- File: app/schemas/announcement/announcement_response.py ---
"""
Announcement response schemas for API responses.

This module defines response schemas with varying levels of detail
for different use cases (list views, detail views, student views).
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import (
    AnnouncementCategory,
    Priority,
    TargetAudience,
)

__all__ = [
    "AnnouncementResponse",
    "AnnouncementDetail",
    "AnnouncementList",
    "AnnouncementListItem",
    "StudentAnnouncementView",
    "AnnouncementSummary",
]


class AnnouncementResponse(BaseResponseSchema):
    """
    Standard announcement response schema.
    
    Used for basic announcement information after creation
    or simple fetch operations.
    """
    
    # Hostel reference
    hostel_id: UUID = Field(
        ...,
        description="Associated hostel UUID",
    )
    hostel_name: str = Field(
        ...,
        description="Associated hostel name",
    )
    
    # Content
    title: str = Field(
        ...,
        description="Announcement title",
    )
    content: str = Field(
        ...,
        description="Announcement content/body",
    )
    
    # Classification
    category: AnnouncementCategory = Field(
        ...,
        description="Announcement category",
    )
    priority: Priority = Field(
        ...,
        description="Priority level",
    )
    
    # Visibility
    is_urgent: bool = Field(
        ...,
        description="Urgent flag",
    )
    is_pinned: bool = Field(
        ...,
        description="Pinned flag",
    )
    
    # Creator
    created_by: UUID = Field(
        ...,
        description="Creator UUID",
    )
    created_by_name: str = Field(
        ...,
        description="Creator name",
    )
    
    # Publication status
    is_published: bool = Field(
        ...,
        description="Publication status",
    )
    published_at: Optional[datetime] = Field(
        None,
        description="Publication timestamp",
    )
    
    # Basic metrics
    total_recipients: int = Field(
        ...,
        ge=0,
        description="Total number of recipients",
    )
    read_count: int = Field(
        ...,
        ge=0,
        description="Number of recipients who read",
    )
    
    @computed_field
    @property
    def read_percentage(self) -> float:
        """Calculate read percentage."""
        if self.total_recipients == 0:
            return 0.0
        return round((self.read_count / self.total_recipients) * 100, 2)
    
    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if announcement is currently active."""
        if not self.is_published:
            return False
        # Check expiry from parent class if available
        return True


class AnnouncementDetail(BaseResponseSchema):
    """
    Detailed announcement view with complete information.
    
    Used for individual announcement detail pages with full
    metadata, delivery, and engagement information.
    """
    
    # Hostel reference
    hostel_id: UUID = Field(
        ...,
        description="Associated hostel UUID",
    )
    hostel_name: str = Field(
        ...,
        description="Associated hostel name",
    )
    
    # Content
    title: str = Field(
        ...,
        description="Announcement title",
    )
    content: str = Field(
        ...,
        description="Announcement content/body",
    )
    category: AnnouncementCategory = Field(
        ...,
        description="Announcement category",
    )
    priority: Priority = Field(
        ...,
        description="Priority level",
    )
    
    # Visibility
    is_urgent: bool = Field(
        ...,
        description="Urgent flag",
    )
    is_pinned: bool = Field(
        ...,
        description="Pinned flag",
    )
    
    # Target audience
    target_audience: TargetAudience = Field(
        ...,
        description="Target audience type",
    )
    target_room_ids: list[UUID] = Field(
        default_factory=list,
        description="Targeted room UUIDs",
    )
    target_student_ids: list[UUID] = Field(
        default_factory=list,
        description="Targeted student UUIDs",
    )
    target_floor_numbers: list[int] = Field(
        default_factory=list,
        description="Targeted floor numbers",
    )
    
    # Attachments
    attachments: list[str] = Field(
        default_factory=list,
        description="Attachment URLs",
    )
    
    # Scheduling and expiry
    scheduled_publish_at: Optional[datetime] = Field(
        None,
        description="Scheduled publication time",
    )
    published_at: Optional[datetime] = Field(
        None,
        description="Actual publication time",
    )
    expires_at: Optional[datetime] = Field(
        None,
        description="Expiry timestamp",
    )
    is_published: bool = Field(
        ...,
        description="Publication status",
    )
    
    # Creator information
    created_by: UUID = Field(
        ...,
        description="Creator UUID",
    )
    created_by_name: str = Field(
        ...,
        description="Creator name",
    )
    created_by_role: str = Field(
        ...,
        description="Creator role (admin/supervisor)",
    )
    
    # Approval information
    requires_approval: bool = Field(
        ...,
        description="Whether approval was required",
    )
    approved_by: Optional[UUID] = Field(
        None,
        description="Approver UUID",
    )
    approved_by_name: Optional[str] = Field(
        None,
        description="Approver name",
    )
    approved_at: Optional[datetime] = Field(
        None,
        description="Approval timestamp",
    )
    
    # Delivery settings
    send_email: bool = Field(
        ...,
        description="Email notification enabled",
    )
    send_sms: bool = Field(
        ...,
        description="SMS notification enabled",
    )
    send_push: bool = Field(
        ...,
        description="Push notification enabled",
    )
    
    # Delivery timestamps
    email_sent_at: Optional[datetime] = Field(
        None,
        description="Email delivery timestamp",
    )
    sms_sent_at: Optional[datetime] = Field(
        None,
        description="SMS delivery timestamp",
    )
    push_sent_at: Optional[datetime] = Field(
        None,
        description="Push notification timestamp",
    )
    
    # Acknowledgment
    requires_acknowledgment: bool = Field(
        False,
        description="Whether acknowledgment is required",
    )
    acknowledgment_deadline: Optional[datetime] = Field(
        None,
        description="Acknowledgment deadline",
    )
    
    # Engagement metrics
    total_recipients: int = Field(
        ...,
        ge=0,
        description="Total recipients",
    )
    read_count: int = Field(
        ...,
        ge=0,
        description="Read count",
    )
    acknowledged_count: int = Field(
        0,
        ge=0,
        description="Acknowledgment count",
    )
    
    # Engagement rate
    engagement_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Engagement rate percentage",
    )
    
    @computed_field
    @property
    def is_expired(self) -> bool:
        """Check if announcement has expired."""
        if self.expires_at is None:
            return False
        return datetime.utcnow() > self.expires_at
    
    @computed_field
    @property
    def is_scheduled(self) -> bool:
        """Check if announcement is scheduled for future."""
        if self.scheduled_publish_at is None:
            return False
        return not self.is_published and self.scheduled_publish_at > datetime.utcnow()
    
    @computed_field
    @property
    def acknowledgment_rate(self) -> float:
        """Calculate acknowledgment rate."""
        if not self.requires_acknowledgment or self.total_recipients == 0:
            return 0.0
        return round((self.acknowledged_count / self.total_recipients) * 100, 2)
    
    @computed_field
    @property
    def pending_acknowledgments(self) -> int:
        """Calculate pending acknowledgments."""
        if not self.requires_acknowledgment:
            return 0
        return self.total_recipients - self.acknowledged_count
    
    @computed_field
    @property
    def days_until_expiry(self) -> Optional[int]:
        """Calculate days until expiry."""
        if self.expires_at is None:
            return None
        delta = self.expires_at - datetime.utcnow()
        return max(0, delta.days)


class AnnouncementListItem(BaseSchema):
    """
    Lightweight announcement schema for list views.
    
    Optimized for displaying announcements in tables and
    lists with minimal data transfer.
    """
    
    id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    hostel_id: UUID = Field(
        ...,
        description="Associated hostel UUID",
    )
    hostel_name: str = Field(
        ...,
        description="Associated hostel name",
    )
    
    # Content summary
    title: str = Field(
        ...,
        description="Announcement title",
    )
    category: AnnouncementCategory = Field(
        ...,
        description="Category",
    )
    priority: Priority = Field(
        ...,
        description="Priority",
    )
    
    # Visibility
    is_urgent: bool = Field(
        ...,
        description="Urgent flag",
    )
    is_pinned: bool = Field(
        ...,
        description="Pinned flag",
    )
    
    # Creator
    created_by_name: str = Field(
        ...,
        description="Creator name",
    )
    
    # Status
    is_published: bool = Field(
        ...,
        description="Publication status",
    )
    published_at: Optional[datetime] = Field(
        None,
        description="Publication timestamp",
    )
    expires_at: Optional[datetime] = Field(
        None,
        description="Expiry timestamp",
    )
    
    # Metrics
    read_count: int = Field(
        ...,
        ge=0,
        description="Read count",
    )
    total_recipients: int = Field(
        ...,
        ge=0,
        description="Total recipients",
    )
    
    # Timestamps
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )
    updated_at: datetime = Field(
        ...,
        description="Last update timestamp",
    )
    
    # For student view
    is_read: bool = Field(
        False,
        description="Whether current user has read (student view)",
    )
    
    @computed_field
    @property
    def read_percentage(self) -> float:
        """Calculate read percentage."""
        if self.total_recipients == 0:
            return 0.0
        return round((self.read_count / self.total_recipients) * 100, 2)
    
    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if announcement is active."""
        if not self.is_published:
            return False
        if self.expires_at and datetime.utcnow() > self.expires_at:
            return False
        return True
    
    @computed_field
    @property
    def display_priority(self) -> int:
        """
        Calculate display priority score for sorting.
        
        Higher score = higher display priority.
        """
        score = 0
        
        # Pinned announcements at top
        if self.is_pinned:
            score += 1000
        
        # Urgent announcements next
        if self.is_urgent:
            score += 500
        
        # Priority scoring
        priority_scores = {
            Priority.CRITICAL: 100,
            Priority.URGENT: 80,
            Priority.HIGH: 60,
            Priority.MEDIUM: 40,
            Priority.LOW: 20,
        }
        score += priority_scores.get(self.priority, 0)
        
        return score


class AnnouncementList(BaseSchema):
    """
    Paginated list of announcements with summary statistics.
    
    Used for announcement listing endpoints with aggregated
    metadata for the current filter context.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel UUID if filtered by hostel",
    )
    hostel_name: Optional[str] = Field(
        None,
        description="Hostel name if filtered by hostel",
    )
    
    # Counts
    total_announcements: int = Field(
        ...,
        ge=0,
        description="Total announcements matching filter",
    )
    active_announcements: int = Field(
        ...,
        ge=0,
        description="Currently active announcements",
    )
    pinned_announcements: int = Field(
        ...,
        ge=0,
        description="Pinned announcements count",
    )
    urgent_announcements: int = Field(
        ...,
        ge=0,
        description="Urgent announcements count",
    )
    
    # Pending actions
    pending_approval: int = Field(
        0,
        ge=0,
        description="Announcements pending approval",
    )
    scheduled_count: int = Field(
        0,
        ge=0,
        description="Scheduled for future publication",
    )
    
    # Items
    announcements: list[AnnouncementListItem] = Field(
        default_factory=list,
        description="List of announcements",
    )
    
    @computed_field
    @property
    def has_urgent(self) -> bool:
        """Check if there are any urgent announcements."""
        return self.urgent_announcements > 0


class StudentAnnouncementView(BaseSchema):
    """
    Student-optimized announcement view.
    
    Simplified view for student-facing interfaces with
    read status and acknowledgment information.
    """
    
    id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    title: str = Field(
        ...,
        description="Announcement title",
    )
    content: str = Field(
        ...,
        description="Announcement content",
    )
    category: AnnouncementCategory = Field(
        ...,
        description="Category",
    )
    priority: Priority = Field(
        ...,
        description="Priority",
    )
    
    # Visibility
    is_urgent: bool = Field(
        ...,
        description="Urgent flag",
    )
    is_pinned: bool = Field(
        ...,
        description="Pinned flag",
    )
    
    # Attachments
    attachments: list[str] = Field(
        default_factory=list,
        description="Attachment URLs",
    )
    
    # Creator
    created_by_name: str = Field(
        ...,
        description="Creator name",
    )
    
    # Timestamps
    published_at: datetime = Field(
        ...,
        description="Publication timestamp",
    )
    expires_at: Optional[datetime] = Field(
        None,
        description="Expiry timestamp",
    )
    
    # Student-specific fields
    is_read: bool = Field(
        False,
        description="Whether student has read",
    )
    read_at: Optional[datetime] = Field(
        None,
        description="When student read the announcement",
    )
    
    # Acknowledgment
    requires_acknowledgment: bool = Field(
        False,
        description="Whether acknowledgment is required",
    )
    is_acknowledged: bool = Field(
        False,
        description="Whether student has acknowledged",
    )
    acknowledged_at: Optional[datetime] = Field(
        None,
        description="Acknowledgment timestamp",
    )
    acknowledgment_deadline: Optional[datetime] = Field(
        None,
        description="Acknowledgment deadline",
    )
    
    @computed_field
    @property
    def acknowledgment_overdue(self) -> bool:
        """Check if acknowledgment is overdue."""
        if not self.requires_acknowledgment:
            return False
        if self.is_acknowledged:
            return False
        if self.acknowledgment_deadline is None:
            return False
        return datetime.utcnow() > self.acknowledgment_deadline
    
    @computed_field
    @property
    def requires_action(self) -> bool:
        """Check if student action is required."""
        if self.requires_acknowledgment and not self.is_acknowledged:
            return True
        return False


class AnnouncementSummary(BaseSchema):
    """
    Minimal announcement summary for notifications and previews.
    
    Contains just enough information for notification display.
    """
    
    id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    title: str = Field(
        ...,
        description="Announcement title",
    )
    category: AnnouncementCategory = Field(
        ...,
        description="Category",
    )
    priority: Priority = Field(
        ...,
        description="Priority",
    )
    is_urgent: bool = Field(
        ...,
        description="Urgent flag",
    )
    content_preview: str = Field(
        ...,
        max_length=200,
        description="First 200 characters of content",
    )
    published_at: datetime = Field(
        ...,
        description="Publication timestamp",
    )
    created_by_name: str = Field(
        ...,
        description="Creator name",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_scheduling.py ---
# --- File: app/schemas/announcement/announcement_scheduling.py ---
"""
Announcement scheduling schemas.

This module defines schemas for scheduling announcements,
including one-time and recurring schedules.
"""

from __future__ import annotations

from datetime import datetime, time
from enum import Enum
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import TargetAudience

__all__ = [
    "RecurrencePattern",
    "ScheduleStatus",
    "ScheduleRequest",
    "ScheduleConfig",
    "RecurringAnnouncement",
    "ScheduleUpdate",
    "ScheduleCancel",
    "PublishNow",
    "ScheduledAnnouncementsList",
    "ScheduledAnnouncementItem",
]


class RecurrencePattern(str, Enum):
    """Recurrence pattern enumeration."""
    
    DAILY = "daily"
    WEEKLY = "weekly"
    BIWEEKLY = "biweekly"
    MONTHLY = "monthly"


class ScheduleStatus(str, Enum):
    """Schedule status enumeration."""
    
    PENDING = "pending"
    PUBLISHED = "published"
    CANCELLED = "cancelled"
    FAILED = "failed"


class ScheduleRequest(BaseCreateSchema):
    """
    Schedule an announcement for later publication.
    
    Allows setting publication time and optional auto-expiry.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="UUID of the announcement to schedule",
    )
    scheduled_by: UUID = Field(
        ...,
        description="UUID of user scheduling the announcement",
    )
    
    scheduled_publish_at: datetime = Field(
        ...,
        description="When to publish the announcement",
    )
    
    # Auto-expire settings
    auto_expire: bool = Field(
        False,
        description="Automatically expire after specified duration",
    )
    expire_after_hours: Optional[int] = Field(
        None,
        ge=1,
        le=720,  # Max 30 days
        description="Hours after publication to auto-expire (1-720)",
    )
    
    # Timezone handling
    timezone: str = Field(
        "Asia/Kolkata",
        description="Timezone for scheduled time",
    )
    
    @field_validator("scheduled_publish_at")
    @classmethod
    def validate_future_time(cls, v: datetime) -> datetime:
        """Ensure scheduled time is in the future."""
        if v <= datetime.utcnow():
            raise ValueError("Scheduled time must be in the future")
        return v
    
    @model_validator(mode="after")
    def validate_expiry_settings(self) -> "ScheduleRequest":
        """Validate auto-expiry configuration."""
        if self.auto_expire and not self.expire_after_hours:
            raise ValueError(
                "expire_after_hours required when auto_expire is True"
            )
        return self


class ScheduleConfig(BaseSchema):
    """
    Complete schedule configuration for announcement.
    
    Shows current scheduling state including recurrence settings.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    
    # Basic schedule
    is_scheduled: bool = Field(
        ...,
        description="Whether announcement is scheduled",
    )
    scheduled_publish_at: Optional[datetime] = Field(
        None,
        description="Scheduled publication time",
    )
    schedule_status: ScheduleStatus = Field(
        ...,
        description="Current schedule status",
    )
    
    # Recurrence
    is_recurring: bool = Field(
        False,
        description="Whether this is a recurring announcement",
    )
    recurrence_pattern: Optional[RecurrencePattern] = Field(
        None,
        description="Recurrence pattern if recurring",
    )
    
    # End conditions
    recurrence_end_date: Optional[datetime] = Field(
        None,
        description="When recurrence ends",
    )
    max_occurrences: Optional[int] = Field(
        None,
        ge=1,
        description="Maximum number of occurrences",
    )
    occurrences_completed: int = Field(
        0,
        ge=0,
        description="Occurrences already published",
    )
    
    # Next occurrence
    next_publish_at: Optional[datetime] = Field(
        None,
        description="Next scheduled publication time",
    )
    
    # Audit
    scheduled_by: Optional[UUID] = Field(
        None,
        description="User who created the schedule",
    )
    scheduled_at: Optional[datetime] = Field(
        None,
        description="When schedule was created",
    )


class RecurringAnnouncement(BaseCreateSchema):
    """
    Create a recurring announcement.
    
    Announcements will be automatically published according
    to the recurrence pattern.
    """
    
    hostel_id: UUID = Field(
        ...,
        description="Hostel UUID",
    )
    created_by: UUID = Field(
        ...,
        description="Creator UUID",
    )
    
    # Content
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Announcement title",
    )
    content: str = Field(
        ...,
        min_length=10,
        max_length=5000,
        description="Announcement content",
    )
    
    # Recurrence settings
    recurrence_pattern: RecurrencePattern = Field(
        ...,
        description="How often to publish",
    )
    start_date: datetime = Field(
        ...,
        description="When to start recurring publications",
    )
    
    # End conditions (at least one required)
    end_date: Optional[datetime] = Field(
        None,
        description="When to stop recurring publications",
    )
    max_occurrences: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Maximum number of publications (1-365)",
    )
    
    # Weekly recurrence options
    weekdays: Optional[list[int]] = Field(
        None,
        description="Days of week for weekly recurrence (0=Monday, 6=Sunday)",
    )
    
    # Time settings
    publish_time: time = Field(
        ...,
        description="Time of day to publish (HH:MM)",
    )
    timezone: str = Field(
        "Asia/Kolkata",
        description="Timezone for publish time",
    )
    
    # Targeting
    target_audience: TargetAudience = Field(
        TargetAudience.ALL,
        description="Target audience",
    )
    target_room_ids: list[UUID] = Field(
        default_factory=list,
        description="Specific room UUIDs",
    )
    target_floor_numbers: list[int] = Field(
        default_factory=list,
        description="Specific floor numbers",
    )
    
    # Delivery
    send_push: bool = Field(
        True,
        description="Send push notifications",
    )
    send_email: bool = Field(
        False,
        description="Send email notifications",
    )
    
    @field_validator("start_date")
    @classmethod
    def validate_start_date(cls, v: datetime) -> datetime:
        """Ensure start date is in the future."""
        if v <= datetime.utcnow():
            raise ValueError("Start date must be in the future")
        return v
    
    @field_validator("end_date")
    @classmethod
    def validate_end_date(cls, v: Optional[datetime], info) -> Optional[datetime]:
        """Ensure end date is after start date."""
        start_date = info.data.get("start_date")
        if v and start_date and v <= start_date:
            raise ValueError("End date must be after start date")
        return v
    
    @field_validator("weekdays")
    @classmethod
    def validate_weekdays(cls, v: Optional[list[int]]) -> Optional[list[int]]:
        """Validate weekday values."""
        if v:
            if any(d < 0 or d > 6 for d in v):
                raise ValueError("Weekdays must be 0-6 (Monday-Sunday)")
            return sorted(set(v))
        return v
    
    @model_validator(mode="after")
    def validate_end_condition(self) -> "RecurringAnnouncement":
        """Ensure at least one end condition is specified."""
        if not self.end_date and not self.max_occurrences:
            raise ValueError(
                "Either end_date or max_occurrences must be specified"
            )
        return self
    
    @model_validator(mode="after")
    def validate_weekly_days(self) -> "RecurringAnnouncement":
        """Validate weekdays for weekly recurrence."""
        if self.recurrence_pattern == RecurrencePattern.WEEKLY:
            if not self.weekdays:
                raise ValueError(
                    "weekdays required for weekly recurrence pattern"
                )
        return self


class ScheduleUpdate(BaseCreateSchema):
    """
    Update scheduled announcement timing.
    
    Reschedule a pending announcement to a new time.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    updated_by: UUID = Field(
        ...,
        description="User making the update",
    )
    
    new_scheduled_time: datetime = Field(
        ...,
        description="New scheduled publication time",
    )
    
    reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for rescheduling",
    )
    
    @field_validator("new_scheduled_time")
    @classmethod
    def validate_future_time(cls, v: datetime) -> datetime:
        """Ensure new time is in the future."""
        if v <= datetime.utcnow():
            raise ValueError("New scheduled time must be in the future")
        return v


class ScheduleCancel(BaseCreateSchema):
    """
    Cancel a scheduled announcement.
    
    Prevents publication of a scheduled announcement.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    cancelled_by: UUID = Field(
        ...,
        description="User cancelling the schedule",
    )
    
    cancellation_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for cancellation (10-500 chars)",
    )
    
    # What to do with the announcement
    delete_announcement: bool = Field(
        False,
        description="Delete the announcement entirely (vs keeping as draft)",
    )
    
    # For recurring announcements
    cancel_all_future: bool = Field(
        True,
        description="Cancel all future occurrences (for recurring)",
    )


class PublishNow(BaseCreateSchema):
    """
    Publish a scheduled announcement immediately.
    
    Overrides the scheduled time and publishes now.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    published_by: UUID = Field(
        ...,
        description="User publishing the announcement",
    )
    
    override_schedule: bool = Field(
        True,
        description="Confirm override of existing schedule",
    )
    
    reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for immediate publication",
    )


class ScheduledAnnouncementItem(BaseSchema):
    """
    Scheduled announcement list item.
    
    Lightweight representation for scheduled announcement lists.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    title: str = Field(
        ...,
        description="Announcement title",
    )
    scheduled_for: datetime = Field(
        ...,
        description="Scheduled publication time",
    )
    
    # Recurrence info
    is_recurring: bool = Field(
        ...,
        description="Whether recurring",
    )
    recurrence_pattern: Optional[RecurrencePattern] = Field(
        None,
        description="Recurrence pattern",
    )
    next_occurrence: Optional[datetime] = Field(
        None,
        description="Next occurrence after this one",
    )
    occurrences_remaining: Optional[int] = Field(
        None,
        description="Remaining occurrences",
    )
    
    # Targeting summary
    target_audience: TargetAudience = Field(
        ...,
        description="Target audience",
    )
    estimated_recipients: int = Field(
        ...,
        ge=0,
        description="Estimated recipient count",
    )
    
    # Creator
    created_by_name: str = Field(
        ...,
        description="Creator name",
    )
    
    # Status
    schedule_status: ScheduleStatus = Field(
        ...,
        description="Current schedule status",
    )


class ScheduledAnnouncementsList(BaseSchema):
    """
    List of scheduled announcements.
    
    Includes summary statistics for the schedule queue.
    """
    
    hostel_id: UUID = Field(
        ...,
        description="Hostel UUID",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    
    # Counts
    total_scheduled: int = Field(
        ...,
        ge=0,
        description="Total scheduled announcements",
    )
    upcoming_24h: int = Field(
        ...,
        ge=0,
        description="Announcements scheduled within 24 hours",
    )
    recurring_count: int = Field(
        ...,
        ge=0,
        description="Number of recurring announcements",
    )
    
    # Items
    announcements: list[ScheduledAnnouncementItem] = Field(
        default_factory=list,
        description="Scheduled announcements",
    )
    
    # Next publication
    next_scheduled: Optional[datetime] = Field(
        None,
        description="Next scheduled publication time",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_targeting.py ---
# --- File: app/schemas/announcement/announcement_targeting.py ---
"""
Announcement targeting schemas for audience selection.

This module defines schemas for configuring and managing
announcement targeting rules and audience selection.
"""

from __future__ import annotations

from enum import Enum
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import RoomType

__all__ = [
    "TargetType",
    "CombineMode",
    "TargetingConfig",
    "AudienceSelection",
    "TargetRooms",
    "TargetFloors",
    "IndividualTargeting",
    "TargetingSummary",
    "BulkTargeting",
    "TargetingPreview",
]


class TargetType(str, Enum):
    """Targeting type enumeration."""
    
    ALL = "all"
    SPECIFIC_ROOMS = "specific_rooms"
    SPECIFIC_FLOORS = "specific_floors"
    SPECIFIC_STUDENTS = "specific_students"
    CUSTOM = "custom"


class CombineMode(str, Enum):
    """Rule combination mode."""
    
    UNION = "union"  # Recipients matching ANY rule
    INTERSECTION = "intersection"  # Recipients matching ALL rules


class TargetingConfig(BaseSchema):
    """
    Targeting configuration for announcement.
    
    Defines who should receive the announcement based
    on various targeting criteria.
    """
    
    target_type: TargetType = Field(
        ...,
        description="Type of targeting strategy",
    )
    
    # Specific targets
    room_ids: list[UUID] = Field(
        default_factory=list,
        description="Specific room UUIDs to target",
    )
    floor_numbers: list[int] = Field(
        default_factory=list,
        description="Specific floor numbers to target",
    )
    student_ids: list[UUID] = Field(
        default_factory=list,
        description="Specific student UUIDs to target",
    )
    
    # Exclusions
    exclude_student_ids: list[UUID] = Field(
        default_factory=list,
        description="Students to exclude from targeting",
    )
    exclude_room_ids: list[UUID] = Field(
        default_factory=list,
        description="Rooms to exclude from targeting",
    )
    
    @field_validator("floor_numbers")
    @classmethod
    def validate_floors(cls, v: list[int]) -> list[int]:
        """Validate and deduplicate floor numbers."""
        if v:
            if any(f < 0 for f in v):
                raise ValueError("Floor numbers must be non-negative")
            return sorted(set(v))
        return v
    
    @model_validator(mode="after")
    def validate_targeting_consistency(self) -> "TargetingConfig":
        """Validate targeting configuration consistency."""
        target_type = self.target_type
        
        if target_type == TargetType.SPECIFIC_ROOMS and not self.room_ids:
            raise ValueError("room_ids required for SPECIFIC_ROOMS targeting")
        
        if target_type == TargetType.SPECIFIC_FLOORS and not self.floor_numbers:
            raise ValueError("floor_numbers required for SPECIFIC_FLOORS targeting")
        
        if target_type == TargetType.SPECIFIC_STUDENTS and not self.student_ids:
            raise ValueError("student_ids required for SPECIFIC_STUDENTS targeting")
        
        # Check for overlap between targets and exclusions
        if self.student_ids and self.exclude_student_ids:
            overlap = set(self.student_ids) & set(self.exclude_student_ids)
            if overlap:
                raise ValueError(
                    f"Students cannot be both targeted and excluded: {overlap}"
                )
        
        if self.room_ids and self.exclude_room_ids:
            overlap = set(self.room_ids) & set(self.exclude_room_ids)
            if overlap:
                raise ValueError(
                    f"Rooms cannot be both targeted and excluded: {overlap}"
                )
        
        return self


class AudienceSelection(BaseCreateSchema):
    """
    Comprehensive audience selection for announcement.
    
    Provides granular control over recipient selection
    with various filtering options.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID to configure targeting for",
    )
    
    # Selection criteria
    include_all: bool = Field(
        False,
        description="Include all students in hostel",
    )
    include_active_students: bool = Field(
        True,
        description="Include students with active status",
    )
    include_inactive_students: bool = Field(
        False,
        description="Include students with inactive status",
    )
    include_notice_period_students: bool = Field(
        True,
        description="Include students in notice period",
    )
    
    # Filters
    room_types: Optional[list[RoomType]] = Field(
        None,
        description="Filter by room types",
    )
    floors: Optional[list[int]] = Field(
        None,
        description="Filter by floor numbers",
    )
    
    # Specific selection
    specific_room_ids: list[UUID] = Field(
        default_factory=list,
        description="Specifically include these rooms",
    )
    specific_student_ids: list[UUID] = Field(
        default_factory=list,
        description="Specifically include these students",
    )
    
    # Exclusions
    exclude_student_ids: list[UUID] = Field(
        default_factory=list,
        description="Specifically exclude these students",
    )
    exclude_room_ids: list[UUID] = Field(
        default_factory=list,
        description="Specifically exclude these rooms",
    )
    
    @field_validator("floors")
    @classmethod
    def validate_floors(cls, v: Optional[list[int]]) -> Optional[list[int]]:
        """Validate floor numbers."""
        if v:
            if any(f < 0 for f in v):
                raise ValueError("Floor numbers must be non-negative")
            return sorted(set(v))
        return v
    
    @model_validator(mode="after")
    def validate_selection(self) -> "AudienceSelection":
        """Validate audience selection is not empty."""
        has_selection = (
            self.include_all
            or self.specific_room_ids
            or self.specific_student_ids
            or self.floors
            or self.room_types
        )
        
        if not has_selection:
            raise ValueError(
                "At least one selection criteria must be specified"
            )
        
        return self


class TargetRooms(BaseCreateSchema):
    """
    Target specific rooms for announcement.
    
    Simple schema for room-based targeting.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    room_ids: list[UUID] = Field(
        ...,
        min_length=1,
        description="Room UUIDs to target (at least 1)",
    )
    
    # Options
    include_all_students: bool = Field(
        True,
        description="Include all students in these rooms",
    )
    exclude_checked_out: bool = Field(
        True,
        description="Exclude students who have checked out",
    )
    
    @field_validator("room_ids")
    @classmethod
    def validate_unique_rooms(cls, v: list[UUID]) -> list[UUID]:
        """Ensure room IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Duplicate room IDs not allowed")
        return v


class TargetFloors(BaseCreateSchema):
    """
    Target specific floors for announcement.
    
    Simple schema for floor-based targeting.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    floor_numbers: list[int] = Field(
        ...,
        min_length=1,
        description="Floor numbers to target (at least 1)",
    )
    
    # Options
    include_all_rooms: bool = Field(
        True,
        description="Include all rooms on these floors",
    )
    exclude_maintenance_rooms: bool = Field(
        True,
        description="Exclude rooms under maintenance",
    )
    
    @field_validator("floor_numbers")
    @classmethod
    def validate_floors(cls, v: list[int]) -> list[int]:
        """Validate and deduplicate floor numbers."""
        if any(f < 0 for f in v):
            raise ValueError("Floor numbers must be non-negative")
        unique_floors = sorted(set(v))
        if len(unique_floors) != len(v):
            # Deduplicated, return unique
            return unique_floors
        return v


class IndividualTargeting(BaseCreateSchema):
    """
    Target individual students for announcement.
    
    Used for direct communication to specific students.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    student_ids: list[UUID] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Student UUIDs to target (1-100)",
    )
    
    @field_validator("student_ids")
    @classmethod
    def validate_unique_students(cls, v: list[UUID]) -> list[UUID]:
        """Ensure student IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Duplicate student IDs not allowed")
        return v


class TargetingSummary(BaseSchema):
    """
    Summary of announcement targeting configuration.
    
    Shows who will receive the announcement based on
    current targeting rules.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    
    # Targeting type
    targeting_type: TargetType = Field(
        ...,
        description="Type of targeting used",
    )
    
    # Counts
    total_recipients: int = Field(
        ...,
        ge=0,
        description="Total number of recipients",
    )
    students_count: int = Field(
        ...,
        ge=0,
        description="Number of students targeted",
    )
    rooms_count: int = Field(
        ...,
        ge=0,
        description="Number of rooms targeted",
    )
    floors_count: int = Field(
        ...,
        ge=0,
        description="Number of floors targeted",
    )
    
    # Exclusion counts
    excluded_students_count: int = Field(
        0,
        ge=0,
        description="Number of students excluded",
    )
    
    # Breakdown
    recipients_by_room: dict[str, int] = Field(
        default_factory=dict,
        description="Room ID/number -> student count",
    )
    recipients_by_floor: dict[str, int] = Field(
        default_factory=dict,
        description="Floor number -> student count",
    )
    
    # Validation
    has_valid_recipients: bool = Field(
        ...,
        description="Whether there are any valid recipients",
    )
    validation_warnings: list[str] = Field(
        default_factory=list,
        description="Any warnings about targeting",
    )


class BulkTargeting(BaseCreateSchema):
    """
    Apply multiple targeting rules at once.
    
    Used for complex targeting scenarios requiring
    multiple rule combinations.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    
    targeting_rules: list[TargetingConfig] = Field(
        ...,
        min_length=1,
        max_length=10,
        description="Targeting rules to apply (1-10)",
    )
    
    # How to combine rules
    combine_mode: CombineMode = Field(
        CombineMode.UNION,
        description="How to combine multiple rules",
    )
    
    # Global exclusions (applied after combining)
    global_exclude_student_ids: list[UUID] = Field(
        default_factory=list,
        description="Students to exclude from final result",
    )
    
    @model_validator(mode="after")
    def validate_rules(self) -> "BulkTargeting":
        """Validate targeting rules don't conflict."""
        # Check for conflicting rules
        has_all = any(r.target_type == TargetType.ALL for r in self.targeting_rules)
        
        if has_all and len(self.targeting_rules) > 1:
            if self.combine_mode == CombineMode.INTERSECTION:
                raise ValueError(
                    "Cannot use INTERSECTION mode with 'all' targeting type"
                )
        
        return self


class TargetingPreview(BaseCreateSchema):
    """
    Request a preview of targeting results.
    
    Returns estimated recipient count without creating
    the announcement.
    """
    
    hostel_id: UUID = Field(
        ...,
        description="Hostel UUID",
    )
    targeting_config: TargetingConfig = Field(
        ...,
        description="Targeting configuration to preview",
    )
    
    # Preview options
    include_student_list: bool = Field(
        False,
        description="Include list of student IDs in preview",
    )
    max_preview_students: int = Field(
        50,
        ge=1,
        le=100,
        description="Maximum students to include in preview list",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\announcement_tracking.py ---
# --- File: app/schemas/announcement/announcement_tracking.py ---
"""
Announcement tracking and engagement schemas.

This module defines schemas for tracking read receipts,
acknowledgments, and engagement metrics.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
)

__all__ = [
    "DeviceType",
    "ReadReceipt",
    "ReadReceiptResponse",
    "AcknowledgmentRequest",
    "AcknowledgmentResponse",
    "AcknowledgmentTracking",
    "PendingAcknowledgment",
    "EngagementMetrics",
    "ReadingTime",
    "AnnouncementAnalytics",
    "StudentEngagement",
    "EngagementTrend",
]


class DeviceType(str, Enum):
    """Device type enumeration."""
    
    MOBILE = "mobile"
    WEB = "web"
    TABLET = "tablet"
    DESKTOP = "desktop"


class ReadReceipt(BaseCreateSchema):
    """
    Mark announcement as read by student.
    
    Records when and how a student viewed the announcement.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    student_id: UUID = Field(
        ...,
        description="Student UUID who read the announcement",
    )
    
    read_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When the announcement was read",
    )
    
    # Reading context
    reading_time_seconds: Optional[int] = Field(
        None,
        ge=0,
        le=3600,
        description="Time spent reading in seconds (max 1 hour)",
    )
    device_type: Optional[DeviceType] = Field(
        None,
        description="Device used to read",
    )
    
    # Scroll tracking (for long announcements)
    scroll_percentage: Optional[int] = Field(
        None,
        ge=0,
        le=100,
        description="How far user scrolled (0-100%)",
    )
    
    # Source
    source: str = Field(
        "app",
        pattern=r"^(app|email|push_notification|web)$",
        description="How user accessed the announcement",
    )


class ReadReceiptResponse(BaseResponseSchema):
    """
    Response after recording read receipt.
    
    Confirms the read was recorded and indicates next actions.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    student_id: UUID = Field(
        ...,
        description="Student UUID",
    )
    read_at: datetime = Field(
        ...,
        description="Read timestamp",
    )
    
    # If acknowledgment is required
    requires_acknowledgment: bool = Field(
        ...,
        description="Whether acknowledgment is required",
    )
    acknowledged: bool = Field(
        ...,
        description="Whether already acknowledged",
    )
    acknowledgment_deadline: Optional[datetime] = Field(
        None,
        description="Deadline for acknowledgment if required",
    )
    
    # Message
    message: str = Field(
        ...,
        description="Response message",
    )


class AcknowledgmentRequest(BaseCreateSchema):
    """
    Submit acknowledgment for announcement.
    
    Confirms student has read and understood the announcement.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    student_id: UUID = Field(
        ...,
        description="Student UUID",
    )
    
    acknowledged: bool = Field(
        True,
        description="Acknowledgment confirmation",
    )
    acknowledgment_note: Optional[str] = Field(
        None,
        max_length=500,
        description="Optional note from student",
    )
    
    # For announcements requiring specific action
    action_taken: Optional[str] = Field(
        None,
        max_length=500,
        description="Description of action taken if required",
    )


class AcknowledgmentResponse(BaseResponseSchema):
    """
    Response after acknowledgment submission.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    student_id: UUID = Field(
        ...,
        description="Student UUID",
    )
    acknowledged_at: datetime = Field(
        ...,
        description="Acknowledgment timestamp",
    )
    
    # Status
    on_time: bool = Field(
        ...,
        description="Whether acknowledged before deadline",
    )
    message: str = Field(
        ...,
        description="Response message",
    )


class PendingAcknowledgment(BaseSchema):
    """
    Student pending acknowledgment record.
    
    Used in lists of students who haven't acknowledged.
    """
    
    student_id: UUID = Field(
        ...,
        description="Student UUID",
    )
    student_name: str = Field(
        ...,
        description="Student name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Room number",
    )
    floor_number: Optional[int] = Field(
        None,
        description="Floor number",
    )
    
    # Delivery info
    delivered_at: datetime = Field(
        ...,
        description="When notification was delivered",
    )
    delivery_channel: str = Field(
        ...,
        description="Channel used for delivery",
    )
    
    # Read status
    is_read: bool = Field(
        ...,
        description="Whether announcement was read",
    )
    read_at: Optional[datetime] = Field(
        None,
        description="When announcement was read",
    )
    
    # Contact info for follow-up
    phone: Optional[str] = Field(
        None,
        description="Student phone for follow-up",
    )
    email: Optional[str] = Field(
        None,
        description="Student email for follow-up",
    )
    
    @computed_field
    @property
    def hours_since_delivery(self) -> float:
        """Hours since delivery."""
        delta = datetime.utcnow() - self.delivered_at
        return round(delta.total_seconds() / 3600, 2)


class AcknowledgmentTracking(BaseSchema):
    """
    Complete acknowledgment tracking for announcement.
    
    Overview of acknowledgment status and pending students.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    title: str = Field(
        ...,
        description="Announcement title",
    )
    
    # Requirement
    requires_acknowledgment: bool = Field(
        ...,
        description="Whether acknowledgment is required",
    )
    acknowledgment_deadline: Optional[datetime] = Field(
        None,
        description="Acknowledgment deadline",
    )
    
    # Counts
    total_recipients: int = Field(
        ...,
        ge=0,
        description="Total recipients",
    )
    acknowledged_count: int = Field(
        ...,
        ge=0,
        description="Number who acknowledged",
    )
    pending_acknowledgments: int = Field(
        ...,
        ge=0,
        description="Number pending acknowledgment",
    )
    
    # On-time tracking
    on_time_count: int = Field(
        0,
        ge=0,
        description="Acknowledged before deadline",
    )
    late_count: int = Field(
        0,
        ge=0,
        description="Acknowledged after deadline",
    )
    
    # Rates
    acknowledgment_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Acknowledgment rate percentage",
    )
    
    # Pending students list
    pending_students: list[PendingAcknowledgment] = Field(
        default_factory=list,
        description="Students pending acknowledgment",
    )
    
    # Time tracking
    average_time_to_acknowledge_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average hours to acknowledge",
    )
    
    @computed_field
    @property
    def is_deadline_passed(self) -> bool:
        """Check if acknowledgment deadline has passed."""
        if self.acknowledgment_deadline is None:
            return False
        return datetime.utcnow() > self.acknowledgment_deadline
    
    @computed_field
    @property
    def hours_until_deadline(self) -> Optional[float]:
        """Hours remaining until deadline."""
        if self.acknowledgment_deadline is None:
            return None
        delta = self.acknowledgment_deadline - datetime.utcnow()
        hours = delta.total_seconds() / 3600
        return round(max(0, hours), 2)


class EngagementMetrics(BaseSchema):
    """
    Comprehensive engagement metrics for announcement.
    
    Measures how recipients interacted with the announcement.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    title: str = Field(
        ...,
        description="Announcement title",
    )
    published_at: datetime = Field(
        ...,
        description="Publication timestamp",
    )
    
    # Delivery metrics
    total_recipients: int = Field(
        ...,
        ge=0,
        description="Total recipients",
    )
    delivered_count: int = Field(
        ...,
        ge=0,
        description="Successfully delivered",
    )
    delivery_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Delivery rate percentage",
    )
    
    # Reading metrics
    read_count: int = Field(
        ...,
        ge=0,
        description="Number who read",
    )
    read_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Read rate percentage",
    )
    
    # Reading depth
    average_reading_time_seconds: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average reading time",
    )
    average_scroll_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Average scroll depth",
    )
    
    # Acknowledgment metrics
    requires_acknowledgment: bool = Field(
        ...,
        description="Whether acknowledgment required",
    )
    acknowledged_count: int = Field(
        0,
        ge=0,
        description="Number who acknowledged",
    )
    acknowledgment_rate: Decimal = Field(
        Decimal("0"),
        ge=0,
        le=100,
        description="Acknowledgment rate percentage",
    )
    
    # Timing metrics
    average_time_to_read_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average hours from delivery to read",
    )
    average_time_to_acknowledge_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average hours from delivery to acknowledge",
    )
    
    # Engagement score
    engagement_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall engagement score (0-100)",
    )
    
    # Comparison
    is_above_average: Optional[bool] = Field(
        None,
        description="Whether engagement is above hostel average",
    )
    hostel_average_engagement: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Hostel average engagement score",
    )


class ReadingTime(BaseSchema):
    """
    Reading time analytics for announcement.
    
    Detailed analysis of how long recipients spent reading.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    
    # Basic stats
    total_readers: int = Field(
        ...,
        ge=0,
        description="Number of readers with time data",
    )
    
    # Statistics
    average_reading_time_seconds: Decimal = Field(
        ...,
        ge=0,
        description="Average reading time",
    )
    median_reading_time_seconds: Decimal = Field(
        ...,
        ge=0,
        description="Median reading time",
    )
    min_reading_time_seconds: int = Field(
        ...,
        ge=0,
        description="Minimum reading time",
    )
    max_reading_time_seconds: int = Field(
        ...,
        ge=0,
        description="Maximum reading time",
    )
    
    # Distribution
    quick_readers: int = Field(
        ...,
        ge=0,
        description="Read in < 30 seconds",
    )
    normal_readers: int = Field(
        ...,
        ge=0,
        description="Read in 30-120 seconds",
    )
    thorough_readers: int = Field(
        ...,
        ge=0,
        description="Read in > 120 seconds",
    )
    
    # Percentages
    quick_readers_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of quick readers",
    )
    normal_readers_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of normal readers",
    )
    thorough_readers_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of thorough readers",
    )


class StudentEngagement(BaseSchema):
    """
    Individual student engagement record.
    
    Tracks a specific student's interaction with announcement.
    """
    
    student_id: UUID = Field(
        ...,
        description="Student UUID",
    )
    student_name: str = Field(
        ...,
        description="Student name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Room number",
    )
    
    # Delivery
    delivered_at: Optional[datetime] = Field(
        None,
        description="Delivery timestamp",
    )
    delivery_channel: Optional[str] = Field(
        None,
        description="Delivery channel used",
    )
    
    # Reading
    is_read: bool = Field(
        ...,
        description="Whether read",
    )
    read_at: Optional[datetime] = Field(
        None,
        description="Read timestamp",
    )
    reading_time_seconds: Optional[int] = Field(
        None,
        description="Time spent reading",
    )
    device_type: Optional[DeviceType] = Field(
        None,
        description="Device used",
    )
    
    # Acknowledgment
    is_acknowledged: bool = Field(
        False,
        description="Whether acknowledged",
    )
    acknowledged_at: Optional[datetime] = Field(
        None,
        description="Acknowledgment timestamp",
    )
    acknowledgment_note: Optional[str] = Field(
        None,
        description="Student's acknowledgment note",
    )
    
    @computed_field
    @property
    def time_to_read_hours(self) -> Optional[float]:
        """Hours from delivery to read."""
        if self.delivered_at and self.read_at:
            delta = self.read_at - self.delivered_at
            return round(delta.total_seconds() / 3600, 2)
        return None


class EngagementTrend(BaseSchema):
    """
    Engagement trend over time.
    
    Shows how engagement changed over the announcement lifecycle.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    
    # Time range
    period_start: datetime = Field(
        ...,
        description="Analysis period start",
    )
    period_end: datetime = Field(
        ...,
        description="Analysis period end",
    )
    
    # Trend data
    reads_by_hour: dict[str, int] = Field(
        default_factory=dict,
        description="Reads per hour (ISO hour string -> count)",
    )
    reads_by_day: dict[str, int] = Field(
        default_factory=dict,
        description="Reads per day (ISO date string -> count)",
    )
    acknowledgments_by_hour: dict[str, int] = Field(
        default_factory=dict,
        description="Acknowledgments per hour",
    )
    
    # Peak times
    peak_reading_hour: Optional[str] = Field(
        None,
        description="Hour with most reads",
    )
    peak_reading_day: Optional[str] = Field(
        None,
        description="Day with most reads",
    )
    
    # Device breakdown
    reads_by_device: dict[str, int] = Field(
        default_factory=dict,
        description="Reads by device type",
    )
    
    # Source breakdown
    reads_by_source: dict[str, int] = Field(
        default_factory=dict,
        description="Reads by access source",
    )


class AnnouncementAnalytics(BaseSchema):
    """
    Complete analytics dashboard for announcement.
    
    Comprehensive view combining all metrics.
    """
    
    announcement_id: UUID = Field(
        ...,
        description="Announcement UUID",
    )
    title: str = Field(
        ...,
        description="Announcement title",
    )
    published_at: datetime = Field(
        ...,
        description="Publication timestamp",
    )
    
    # Core metrics
    engagement_metrics: EngagementMetrics = Field(
        ...,
        description="Engagement metrics",
    )
    
    # Reading patterns
    reading_time: ReadingTime = Field(
        ...,
        description="Reading time analytics",
    )
    
    # Trends
    engagement_trend: EngagementTrend = Field(
        ...,
        description="Engagement over time",
    )
    
    # Acknowledgment (if applicable)
    acknowledgment_tracking: Optional[AcknowledgmentTracking] = Field(
        None,
        description="Acknowledgment tracking if required",
    )
    
    # Top engaged students (for recognition)
    fastest_readers: list[StudentEngagement] = Field(
        default_factory=list,
        max_length=10,
        description="Top 10 fastest to read",
    )
    
    # Report metadata
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp",
    )
    data_freshness_minutes: int = Field(
        ...,
        ge=0,
        description="Minutes since last data update",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\__init__.py ---
# --- File: app/schemas/announcement/__init__.py ---
"""
Announcement schemas package.

This package provides comprehensive schemas for managing announcements
throughout their lifecycle - from creation to delivery and tracking.

Modules:
    announcement_base: Base schemas for creation and updates
    announcement_response: Response schemas for API responses
    announcement_targeting: Audience targeting configuration
    announcement_scheduling: Scheduling and recurrence
    announcement_approval: Approval workflow
    announcement_delivery: Delivery configuration and tracking
    announcement_tracking: Read receipts and engagement
    announcement_filters: Filtering, search, and export

Example Usage:
    from app.schemas.announcement import (
        AnnouncementCreate,
        AnnouncementResponse,
        DeliveryConfig,
    )
    
    # Create announcement
    announcement = AnnouncementCreate(
        hostel_id=hostel_uuid,
        title="Important Notice",
        content="Please be informed that...",
        category=AnnouncementCategory.GENERAL,
        created_by=admin_uuid,
    )
"""

from __future__ import annotations

# Base schemas
from app.schemas.announcement.announcement_base import (
    AnnouncementBase,
    AnnouncementCreate,
    AnnouncementPublish,
    AnnouncementUnpublish,
    AnnouncementUpdate,
)

# Response schemas
from app.schemas.announcement.announcement_response import (
    AnnouncementDetail,
    AnnouncementList,
    AnnouncementListItem,
    AnnouncementResponse,
    AnnouncementSummary,
    StudentAnnouncementView,
)

# Targeting schemas
from app.schemas.announcement.announcement_targeting import (
    AudienceSelection,
    BulkTargeting,
    CombineMode,
    IndividualTargeting,
    TargetFloors,
    TargetingConfig,
    TargetingPreview,
    TargetingSummary,
    TargetRooms,
    TargetType,
)

# Scheduling schemas
from app.schemas.announcement.announcement_scheduling import (
    PublishNow,
    RecurrencePattern,
    RecurringAnnouncement,
    ScheduleCancel,
    ScheduleConfig,
    ScheduledAnnouncementItem,
    ScheduledAnnouncementsList,
    ScheduleRequest,
    ScheduleStatus,
    ScheduleUpdate,
)

# Approval schemas
from app.schemas.announcement.announcement_approval import (
    ApprovalHistory,
    ApprovalRequest,
    ApprovalResponse,
    ApprovalStatus,
    ApprovalWorkflow,
    BulkApproval,
    PendingApprovalItem,
    RejectionRequest,
    SupervisorApprovalQueue,
)

# Delivery schemas
from app.schemas.announcement.announcement_delivery import (
    BatchDelivery,
    ChannelDeliveryStats,
    DeliveryChannel,
    DeliveryConfig,
    DeliveryChannels,
    DeliveryPause,
    DeliveryReport,
    DeliveryResume,
    DeliveryState,
    DeliveryStatus,
    DeliveryStrategy,
    FailedDelivery,
    RetryDelivery,
)

# Tracking schemas
from app.schemas.announcement.announcement_tracking import (
    AcknowledgmentRequest,
    AcknowledgmentResponse,
    AcknowledgmentTracking,
    AnnouncementAnalytics,
    DeviceType,
    EngagementMetrics,
    EngagementTrend,
    PendingAcknowledgment,
    ReadingTime,
    ReadReceipt,
    ReadReceiptResponse,
    StudentEngagement,
)

# Filter schemas
from app.schemas.announcement.announcement_filters import (
    AnnouncementExportRequest,
    AnnouncementFilterParams,
    AnnouncementSortField,
    AnnouncementStatsRequest,
    ArchiveRequest,
    BulkDeleteRequest,
    ExportFormat,
    SearchRequest,
)

__all__ = [
    # Base
    "AnnouncementBase",
    "AnnouncementCreate",
    "AnnouncementUpdate",
    "AnnouncementPublish",
    "AnnouncementUnpublish",
    
    # Response
    "AnnouncementResponse",
    "AnnouncementDetail",
    "AnnouncementList",
    "AnnouncementListItem",
    "StudentAnnouncementView",
    "AnnouncementSummary",
    
    # Targeting
    "TargetType",
    "CombineMode",
    "TargetingConfig",
    "AudienceSelection",
    "TargetRooms",
    "TargetFloors",
    "IndividualTargeting",
    "TargetingSummary",
    "BulkTargeting",
    "TargetingPreview",
    
    # Scheduling
    "RecurrencePattern",
    "ScheduleStatus",
    "ScheduleRequest",
    "ScheduleConfig",
    "RecurringAnnouncement",
    "ScheduleUpdate",
    "ScheduleCancel",
    "PublishNow",
    "ScheduledAnnouncementsList",
    "ScheduledAnnouncementItem",
    
    # Approval
    "ApprovalStatus",
    "ApprovalRequest",
    "ApprovalResponse",
    "RejectionRequest",
    "ApprovalWorkflow",
    "SupervisorApprovalQueue",
    "PendingApprovalItem",
    "BulkApproval",
    "ApprovalHistory",
    
    # Delivery
    "DeliveryChannel",
    "DeliveryStrategy",
    "DeliveryState",
    "DeliveryConfig",
    "DeliveryChannels",
    "DeliveryStatus",
    "DeliveryReport",
    "ChannelDeliveryStats",
    "FailedDelivery",
    "BatchDelivery",
    "RetryDelivery",
    "DeliveryPause",
    "DeliveryResume",
    
    # Tracking
    "DeviceType",
    "ReadReceipt",
    "ReadReceiptResponse",
    "AcknowledgmentRequest",
    "AcknowledgmentResponse",
    "AcknowledgmentTracking",
    "PendingAcknowledgment",
    "EngagementMetrics",
    "ReadingTime",
    "AnnouncementAnalytics",
    "StudentEngagement",
    "EngagementTrend",
    
    # Filters
    "ExportFormat",
    "AnnouncementSortField",
    "AnnouncementFilterParams",
    "SearchRequest",
    "ArchiveRequest",
    "AnnouncementExportRequest",
    "BulkDeleteRequest",
    "AnnouncementStatsRequest",
]

# Package version
__version__ = "1.0.0"


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\announcement\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_alert.py ---
"""
Attendance alert schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema


class AttendanceAlert(BaseResponseSchema):
    """Attendance alert"""
    alert_id: UUID
    hostel_id: UUID
    student_id: UUID
    student_name: str
    
    alert_type: str = Field(
        ...,
        pattern="^(low_attendance|consecutive_absences|late_entry|irregular_pattern)$"
    )
    
    severity: str = Field(..., pattern="^(low|medium|high|critical)$")
    
    # Alert details
    message: str
    details: dict = Field(..., description="Alert-specific details")
    
    # Triggered
    triggered_at: datetime
    triggered_by_rule: Optional[str] = None
    
    # Status
    acknowledged: bool = Field(False)
    acknowledged_by: Optional[UUID] = None
    acknowledged_at: Optional[datetime] = None
    
    # Actions taken
    actions_taken: List[str] = Field(default_factory=list)
    
    resolved: bool = Field(False)
    resolved_at: Optional[datetime] = None


class AlertConfig(BaseSchema):
    """Alert configuration"""
    hostel_id: UUID
    
    # Low attendance alerts
    enable_low_attendance_alerts: bool = Field(True)
    low_attendance_threshold: Decimal = Field(Decimal("75.00"), ge=0, le=100)
    
    # Consecutive absence alerts
    enable_consecutive_absence_alerts: bool = Field(True)
    consecutive_absence_threshold: int = Field(3, ge=1)
    
    # Late entry alerts
    enable_late_entry_alerts: bool = Field(True)
    late_entry_count_threshold: int = Field(5, description="Alert after N late entries in month")
    
    # Pattern detection
    enable_pattern_detection: bool = Field(False, description="Detect irregular patterns")
    
    # Notification settings
    notify_supervisor: bool = Field(True)
    notify_admin: bool = Field(True)
    notify_guardian: bool = Field(True)
    notify_student: bool = Field(True)
    
    # Escalation
    auto_escalate_after_days: int = Field(7, description="Auto-escalate unacknowledged alerts")


class AlertTrigger(BaseSchema):
    """Manual alert trigger"""
    student_id: UUID
    alert_type: str
    custom_message: str = Field(..., min_length=10, max_length=500)
    severity: str = Field("medium", pattern="^(low|medium|high|critical)$")


class AlertAcknowledgment(BaseCreateSchema):
    """Acknowledge alert"""
    alert_id: UUID
    acknowledged_by: UUID
    action_taken: str = Field(..., min_length=10, max_length=500)


class AlertList(BaseSchema):
    """List of alerts"""
    hostel_id: Optional[UUID] = None
    
    total_alerts: int
    unacknowledged_alerts: int
    critical_alerts: int
    
    alerts: List[AttendanceAlert]


class AlertSummary(BaseSchema):
    """Alert summary for dashboard"""
    hostel_id: UUID
    period_start: date
    period_end: date
    
    total_alerts: int
    
    # By type
    low_attendance_alerts: int
    consecutive_absence_alerts: int
    late_entry_alerts: int
    pattern_alerts: int
    
    # By severity
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    
    # Resolution
    acknowledged_count: int
    resolved_count: int
    pending_count: int

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_base.py ---
"""
Attendance base schemas
"""
from datetime import date, time
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseUpdateSchema, BaseSchema
from app.schemas.common.enums import AttendanceStatus, AttendanceMode


class AttendanceBase(BaseSchema):
    """Base attendance schema"""
    hostel_id: UUID = Field(..., description="Hostel ID")
    student_id: UUID = Field(..., description="Student ID")
    attendance_date: date = Field(..., description="Attendance date")
    
    check_in_time: Optional[time] = Field(None, description="Check-in time")
    check_out_time: Optional[time] = Field(None, description="Check-out time")
    
    status: AttendanceStatus = Field(AttendanceStatus.PRESENT, description="Attendance status")
    
    is_late: bool = Field(False, description="Late arrival")
    late_minutes: Optional[int] = Field(None, ge=0, description="Minutes late")
    
    attendance_mode: AttendanceMode = Field(AttendanceMode.MANUAL, description="How attendance was recorded")
    
    marked_by: UUID = Field(..., description="User who marked attendance (supervisor/admin)")
    supervisor_id: Optional[UUID] = Field(None, description="Supervisor who marked")
    
    notes: Optional[str] = Field(None, max_length=500, description="Additional notes")


class AttendanceCreate(AttendanceBase, BaseCreateSchema):
    """Create attendance record"""
    # Location data (for mobile app check-in)
    location_lat: Optional[Decimal] = Field(None, ge=-90, le=90)
    location_lng: Optional[Decimal] = Field(None, ge=-180, le=180)
    
    # Device info (for mobile app)
    device_info: Optional[dict] = None


class AttendanceUpdate(BaseUpdateSchema):
    """Update attendance record"""
    check_in_time: Optional[time] = None
    check_out_time: Optional[time] = None
    status: Optional[AttendanceStatus] = None
    is_late: Optional[bool] = None
    late_minutes: Optional[int] = None
    notes: Optional[str] = None


class BulkAttendanceCreate(BaseCreateSchema):
    """Bulk create attendance records"""
    hostel_id: UUID
    attendance_date: date
    
    records: List["SingleAttendanceRecord"] = Field(..., min_items=1, max_items=500)
    
    marked_by: UUID
    supervisor_id: Optional[UUID] = None


class SingleAttendanceRecord(BaseSchema):
    """Single attendance in bulk"""
    student_id: UUID
    status: AttendanceStatus = Field(AttendanceStatus.PRESENT)
    check_in_time: Optional[time] = None
    is_late: bool = Field(False)
    notes: Optional[str] = None

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_filters.py ---
"""
Attendance filter schemas
"""
from datetime import date
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import AttendanceStatus
from app.schemas.common.filters import DateRangeFilter


class AttendanceFilterParams(BaseFilterSchema):
    """Attendance filter parameters"""
    # Hostel filter
    hostel_id: Optional[UUID] = None
    hostel_ids: Optional[List[UUID]] = None
    
    # Student filter
    student_id: Optional[UUID] = None
    student_ids: Optional[List[UUID]] = None
    room_id: Optional[UUID] = None
    
    # Date range (required for most queries)
    date_from: Optional[date] = None
    date_to: Optional[date] = None
    
    # Status filter
    status: Optional[AttendanceStatus] = None
    statuses: Optional[List[AttendanceStatus]] = None
    
    # Late filter
    late_only: Optional[bool] = None
    
    # Marked by
    marked_by: Optional[UUID] = None
    supervisor_id: Optional[UUID] = None
    
    # Attendance mode
    attendance_mode: Optional[str] = None


class DateRangeRequest(BaseFilterSchema):
    """Simple date range request"""
    start_date: date = Field(..., description="Start date (inclusive)")
    end_date: date = Field(..., description="End date (inclusive)")
    
    @field_validator('end_date')
    @classmethod
    def validate_date_range(cls, v: date, info) -> date:
        if 'start_date' in info.data and v < info.data['start_date']:
            raise ValueError('end_date must be after or equal to start_date')
        return v


class AttendanceExportRequest(BaseFilterSchema):
    """Export attendance data"""
    hostel_id: UUID
    date_range: DateRangeFilter
    
    # Student filter
    student_ids: Optional[List[UUID]] = None
    
    # Format
    format: str = Field("csv", pattern="^(csv|excel|pdf)$")
    
    # Options
    include_summary: bool = Field(True)
    include_percentage: bool = Field(True)
    include_notes: bool = Field(False)
    group_by: str = Field("student", pattern="^(student|date|room)$")

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_policy.py ---
"""
Attendance policy schemas
"""
from datetime import time
from decimal import Decimal
from typing import Optional
from pydantic import Field, field_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseUpdateSchema, BaseResponseSchema


class AttendancePolicy(BaseResponseSchema):
    """Attendance policy configuration"""
    hostel_id: UUID
    hostel_name: str
    
    # Minimum requirements
    minimum_attendance_percentage: Decimal = Field(..., ge=0, le=100)
    
    # Late entry
    late_entry_threshold_minutes: int = Field(..., ge=0, description="Minutes after which marked as late")
    grace_days_per_month: int = Field(..., ge=0, description="Allowed late entries per month")
    
    # Absence alerts
    consecutive_absence_alert_days: int = Field(..., description="Alert after N consecutive absences")
    
    # Notifications
    notify_guardian_on_absence: bool = Field(True)
    notify_admin_on_low_attendance: bool = Field(True)
    low_attendance_threshold: Decimal = Field(Decimal("75.00"), ge=0, le=100)
    
    # Auto-marking
    auto_mark_absent_after_time: Optional[time] = Field(None, description="Auto mark absent if not checked in by this time")
    
    is_active: bool = Field(True)


class PolicyConfig(BaseSchema):
    """Policy configuration details"""
    # Attendance calculation
    calculation_period: str = Field("monthly", pattern="^(weekly|monthly|semester|yearly)$")
    
    # Leave handling
    count_leave_as_absent: bool = Field(False, description="Count approved leaves as absent")
    max_leaves_per_month: int = Field(3, ge=0)
    
    # Weekends
    include_weekends: bool = Field(False, description="Track attendance on weekends")
    weekend_days: List[str] = Field(default_factory=lambda: ["Saturday", "Sunday"])
    
    # Holidays
    exclude_holidays: bool = Field(True)
    
    # Penalties
    low_attendance_penalty: Optional[str] = None


class PolicyUpdate(BaseUpdateSchema):
    """Update attendance policy"""
    minimum_attendance_percentage: Optional[Decimal] = Field(None, ge=0, le=100)
    late_entry_threshold_minutes: Optional[int] = Field(None, ge=0)
    grace_days_per_month: Optional[int] = Field(None, ge=0)
    consecutive_absence_alert_days: Optional[int] = None
    
    notify_guardian_on_absence: Optional[bool] = None
    notify_admin_on_low_attendance: Optional[bool] = None
    low_attendance_threshold: Optional[Decimal] = Field(None, ge=0, le=100)
    
    auto_mark_absent_after_time: Optional[time] = None
    is_active: Optional[bool] = None


class PolicyViolation(BaseSchema):
    """Policy violation record"""
    student_id: UUID
    student_name: str
    hostel_id: UUID
    
    violation_type: str = Field(
        ...,
        pattern="^(low_attendance|consecutive_absences|excessive_late_entries)$"
    )
    
    # Details
    current_attendance_percentage: Optional[Decimal] = None
    consecutive_absences: Optional[int] = None
    late_entries_this_month: Optional[int] = None
    
    violation_date: date
    
    # Actions taken
    guardian_notified: bool
    admin_notified: bool
    warning_issued: bool
    
    notes: Optional[str] = None

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_record.py ---
"""
Attendance recording schemas
"""
from datetime import date, time
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema
from app.schemas.common.enums import AttendanceStatus


class AttendanceRecordRequest(BaseCreateSchema):
    """Record attendance for single student"""
    hostel_id: UUID
    student_id: UUID
    attendance_date: date
    
    status: AttendanceStatus = Field(AttendanceStatus.PRESENT)
    check_in_time: Optional[time] = None
    check_out_time: Optional[time] = None
    
    is_late: bool = Field(False)
    notes: Optional[str] = Field(None, max_length=500)


class BulkAttendanceRequest(BaseCreateSchema):
    """Mark attendance for multiple students at once"""
    hostel_id: UUID
    attendance_date: date
    
    # Default status for all (can be overridden per student)
    default_status: AttendanceStatus = Field(AttendanceStatus.PRESENT)
    
    # Student-specific records
    student_records: List["StudentAttendanceRecord"] = Field(..., min_items=1)
    
    # Metadata
    marked_by: UUID
    marking_mode: str = Field("manual", pattern="^(manual|biometric|qr_code|mobile_app)$")


class StudentAttendanceRecord(BaseSchema):
    """Individual student attendance in bulk operation"""
    student_id: UUID
    status: Optional[AttendanceStatus] = None  # If None, uses default_status
    check_in_time: Optional[time] = None
    is_late: Optional[bool] = None
    notes: Optional[str] = None


class AttendanceCorrection(BaseCreateSchema):
    """Correct previously marked attendance"""
    attendance_id: UUID
    
    # Corrected values
    corrected_status: AttendanceStatus
    corrected_check_in_time: Optional[time] = None
    corrected_check_out_time: Optional[time] = None
    
    correction_reason: str = Field(..., min_length=10, max_length=500)
    corrected_by: UUID


class QuickAttendanceMarkAll(BaseCreateSchema):
    """Quick mark all students as present"""
    hostel_id: UUID
    attendance_date: date
    
    # Exceptions
    absent_student_ids: List[UUID] = Field(default_factory=list)
    on_leave_student_ids: List[UUID] = Field(default_factory=list)
    
    marked_by: UUID

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_report.py ---
"""
Attendance reporting schemas
"""
from datetime import date
from decimal import Decimal
from typing import List, Dict, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter


class AttendanceReport(BaseSchema):
    """Comprehensive attendance report"""
    hostel_id: Optional[UUID] = None
    student_id: Optional[UUID] = None
    
    report_period: DateRangeFilter
    generated_at: datetime
    
    # Summary
    summary: "AttendanceSummary"
    
    # Detailed records
    daily_records: List["DailyAttendanceRecord"] = Field(default_factory=list)
    
    # Analysis
    trend_analysis: Optional["TrendAnalysis"] = None


class AttendanceSummary(BaseSchema):
    """Attendance summary statistics"""
    total_days: int
    total_present: int
    total_absent: int
    total_late: int
    total_on_leave: int
    total_half_day: int
    
    attendance_percentage: Decimal
    late_percentage: Decimal
    
    # Streaks
    current_present_streak: int
    longest_present_streak: int
    current_absent_streak: int
    
    # Status
    attendance_status: str = Field(
        ...,
        pattern="^(excellent|good|warning|critical)$",
        description="Based on attendance percentage"
    )
    
    meets_minimum_requirement: bool


class DailyAttendanceRecord(BaseSchema):
    """Daily attendance record for report"""
    date: date
    day_of_week: str
    
    status: str
    check_in_time: Optional[time]
    check_out_time: Optional[time]
    
    is_late: bool
    late_minutes: Optional[int]
    
    notes: Optional[str]


class TrendAnalysis(BaseSchema):
    """Attendance trend analysis"""
    period_start: date
    period_end: date
    
    # Weekly trend
    weekly_attendance: List["WeeklyAttendance"]
    
    # Monthly comparison
    monthly_comparison: Optional[List["MonthlyComparison"]] = None
    
    # Patterns
    most_absent_day: Optional[str] = Field(None, description="Day of week with most absences")
    attendance_improving: bool
    improvement_rate: Optional[Decimal] = None


class WeeklyAttendance(BaseSchema):
    """Weekly attendance summary"""
    week_number: int
    week_start_date: date
    week_end_date: date
    
    total_days: int
    present_days: int
    absent_days: int
    
    attendance_percentage: Decimal


class MonthlyComparison(BaseSchema):
    """Monthly attendance comparison"""
    month: str  # YYYY-MM format
    attendance_percentage: Decimal
    total_present: int
    total_absent: int


class MonthlyReport(BaseSchema):
    """Monthly attendance report"""
    hostel_id: UUID
    month: str  # YYYY-MM
    
    # Student-wise summary
    student_summaries: List["StudentMonthlySummary"]
    
    # Hostel-wide stats
    hostel_average_attendance: Decimal
    total_students: int
    students_meeting_requirement: int
    students_below_requirement: int


class StudentMonthlySummary(BaseSchema):
    """Monthly summary for individual student"""
    student_id: UUID
    student_name: str
    room_number: Optional[str]
    
    total_days: int
    present_days: int
    absent_days: int
    late_days: int
    on_leave_days: int
    
    attendance_percentage: Decimal
    meets_requirement: bool
    
    # Actions needed
    requires_attention: bool
    action_required: Optional[str] = None


class AttendanceComparison(BaseSchema):
    """Compare attendance across students/hostels"""
    comparison_type: str = Field(..., pattern="^(student|hostel|room)$")
    period: DateRangeFilter
    
    comparisons: List["ComparisonItem"]


class ComparisonItem(BaseSchema):
    """Individual comparison item"""
    entity_id: UUID
    entity_name: str
    
    attendance_percentage: Decimal
    total_present: int
    total_absent: int
    
    rank: int
    percentile: Decimal

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_response.py ---
"""
Attendance response schemas
"""
from datetime import date, time, datetime
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import AttendanceStatus, AttendanceMode


class AttendanceResponse(BaseResponseSchema):
    """Attendance response schema"""
    hostel_id: UUID
    hostel_name: str
    
    student_id: UUID
    student_name: str
    room_number: Optional[str]
    
    attendance_date: date
    check_in_time: Optional[time]
    check_out_time: Optional[time]
    
    status: AttendanceStatus
    is_late: bool
    late_minutes: Optional[int]
    
    marked_by: UUID
    marked_by_name: str


class AttendanceDetail(BaseResponseSchema):
    """Detailed attendance information"""
    hostel_id: UUID
    hostel_name: str
    
    student_id: UUID
    student_name: str
    student_email: str
    student_phone: str
    room_number: Optional[str]
    
    attendance_date: date
    check_in_time: Optional[time]
    check_out_time: Optional[time]
    
    status: AttendanceStatus
    is_late: bool
    late_minutes: Optional[int]
    
    attendance_mode: AttendanceMode
    
    marked_by: UUID
    marked_by_name: str
    supervisor_id: Optional[UUID]
    supervisor_name: Optional[str]
    
    notes: Optional[str]
    
    # Location (if mobile app)
    location_lat: Optional[Decimal]
    location_lng: Optional[Decimal]
    device_info: Optional[dict]
    
    # Metadata
    created_at: datetime
    updated_at: datetime


class AttendanceListItem(BaseSchema):
    """Attendance list item"""
    id: UUID
    student_name: str
    room_number: Optional[str]
    
    attendance_date: date
    status: AttendanceStatus
    
    check_in_time: Optional[time]
    is_late: bool
    
    marked_by_name: str


class DailyAttendanceSummary(BaseSchema):
    """Daily attendance summary"""
    hostel_id: UUID
    hostel_name: str
    date: date
    
    total_students: int
    total_present: int
    total_absent: int
    total_late: int
    total_on_leave: int
    
    attendance_percentage: Decimal
    
    marked_by: UUID
    marked_by_name: str
    marking_completed: bool
    marked_at: Optional[datetime]

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\__init__.py ---
"""
Attendance schemas package
"""
from app.schemas.attendance.attendance_base import (
    AttendanceBase,
    AttendanceCreate,
    AttendanceUpdate,
    BulkAttendanceCreate
)
from app.schemas.attendance.attendance_response import (
    AttendanceResponse,
    AttendanceDetail,
    AttendanceListItem
)
from app.schemas.attendance.attendance_record import (
    AttendanceRecordRequest,
    BulkAttendanceRequest,
    AttendanceCorrection
)
from app.schemas.attendance.attendance_report import (
    AttendanceReport,
    AttendanceSummary,
    TrendAnalysis,
    MonthlyReport
)
from app.schemas.attendance.attendance_policy import (
    AttendancePolicy,
    PolicyConfig,
    PolicyUpdate
)
from app.schemas.attendance.attendance_alert import (
    AttendanceAlert,
    AlertConfig,
    AlertTrigger
)
from app.schemas.attendance.attendance_filters import (
    AttendanceFilterParams,
    DateRangeRequest,
    AttendanceExportRequest
)

__all__ = [
    # Base
    "AttendanceBase",
    "AttendanceCreate",
    "AttendanceUpdate",
    "BulkAttendanceCreate",
    
    # Response
    "AttendanceResponse",
    "AttendanceDetail",
    "AttendanceListItem",
    
    # Record
    "AttendanceRecordRequest",
    "BulkAttendanceRequest",
    "AttendanceCorrection",
    
    # Report
    "AttendanceReport",
    "AttendanceSummary",
    "TrendAnalysis",
    "MonthlyReport",
    
    # Policy
    "AttendancePolicy",
    "PolicyConfig",
    "PolicyUpdate",
    
    # Alert
    "AttendanceAlert",
    "AlertConfig",
    "AlertTrigger",
    
    # Filters
    "AttendanceFilterParams",
    "DateRangeRequest",
    "AttendanceExportRequest",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_alert.py ---
# --- File: app/schemas/attendance/attendance_alert.py ---
"""
Attendance alert schemas for proactive monitoring.

Provides alert generation, configuration, and management schemas
for identifying and responding to attendance issues.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "AttendanceAlert",
    "AlertConfig",
    "AlertTrigger",
    "AlertAcknowledgment",
    "AlertList",
    "AlertSummary",
]


class AttendanceAlert(BaseResponseSchema):
    """
    Attendance alert record with tracking and resolution.
    
    Represents an automatically or manually triggered alert
    for attendance-related issues.
    """

    alert_id: UUID = Field(
        ...,
        description="Alert unique identifier",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Student room number",
    )

    # Alert classification
    alert_type: str = Field(
        ...,
        pattern=r"^(low_attendance|consecutive_absences|late_entry|irregular_pattern|policy_violation)$",
        description="Type of alert",
    )
    severity: str = Field(
        ...,
        pattern=r"^(low|medium|high|critical)$",
        description="Alert severity level",
    )
    category: str = Field(
        default="attendance",
        pattern=r"^(attendance|behavior|policy|system)$",
        description="Alert category",
    )

    # Alert content
    message: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Alert message for display",
    )
    details: Dict[str, any] = Field(
        ...,
        description="Alert-specific details (JSON)",
    )
    recommendation: Optional[str] = Field(
        None,
        max_length=500,
        description="Recommended action to resolve alert",
    )

    # Trigger information
    triggered_at: datetime = Field(
        ...,
        description="Alert trigger timestamp",
    )
    triggered_by_rule: Optional[str] = Field(
        None,
        description="Name of rule that triggered alert",
    )
    auto_generated: bool = Field(
        default=True,
        description="Whether alert was auto-generated",
    )
    manual_trigger_by: Optional[UUID] = Field(
        None,
        description="User ID if manually triggered",
    )

    # Acknowledgment
    acknowledged: bool = Field(
        False,
        description="Whether alert has been acknowledged",
    )
    acknowledged_by: Optional[UUID] = Field(
        None,
        description="User ID who acknowledged",
    )
    acknowledged_by_name: Optional[str] = Field(
        None,
        description="Name of user who acknowledged",
    )
    acknowledged_at: Optional[datetime] = Field(
        None,
        description="Acknowledgment timestamp",
    )
    acknowledgment_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Notes added during acknowledgment",
    )

    # Actions and resolution
    actions_taken: List[str] = Field(
        default_factory=list,
        description="List of actions taken in response",
    )
    assigned_to: Optional[UUID] = Field(
        None,
        description="User ID assigned to handle alert",
    )
    assigned_to_name: Optional[str] = Field(
        None,
        description="Name of assigned user",
    )
    resolved: bool = Field(
        False,
        description="Whether alert has been resolved",
    )
    resolved_at: Optional[datetime] = Field(
        None,
        description="Resolution timestamp",
    )
    resolved_by: Optional[UUID] = Field(
        None,
        description="User ID who resolved",
    )
    resolution_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Resolution details",
    )

    # Escalation
    escalated: bool = Field(
        default=False,
        description="Whether alert has been escalated",
    )
    escalated_at: Optional[datetime] = Field(
        None,
        description="Escalation timestamp",
    )
    escalation_level: int = Field(
        default=0,
        ge=0,
        le=5,
        description="Current escalation level",
    )

    # Notification tracking
    notifications_sent: List[Dict[str, any]] = Field(
        default_factory=list,
        description="Record of notifications sent",
    )

    @field_validator("message", "recommendation", "acknowledgment_notes", "resolution_notes")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_alert_status(self) -> "AttendanceAlert":
        """
        Validate alert status consistency.
        
        Ensures timestamps and user IDs are provided when status flags are set.
        """
        if self.acknowledged:
            if self.acknowledged_by is None:
                raise ValueError(
                    "acknowledged_by is required when alert is acknowledged"
                )
            if self.acknowledged_at is None:
                raise ValueError(
                    "acknowledged_at is required when alert is acknowledged"
                )

        if self.resolved:
            if self.resolved_at is None:
                raise ValueError(
                    "resolved_at is required when alert is resolved"
                )
            # Resolved alerts should be acknowledged first
            if not self.acknowledged:
                raise ValueError(
                    "Alert must be acknowledged before being resolved"
                )

        if self.escalated and self.escalated_at is None:
            raise ValueError(
                "escalated_at is required when alert is escalated"
            )

        if not self.auto_generated and self.manual_trigger_by is None:
            raise ValueError(
                "manual_trigger_by is required for manually triggered alerts"
            )

        return self


class AlertConfig(BaseSchema):
    """
    Alert configuration for attendance monitoring.
    
    Defines rules and thresholds for automatic alert generation
    and notification preferences.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )

    # Low attendance alerts
    enable_low_attendance_alerts: bool = Field(
        True,
        description="Enable low attendance alerts",
    )
    low_attendance_threshold: Decimal = Field(
        Decimal("75.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Attendance percentage threshold for alerts",
    )
    low_attendance_check_period: str = Field(
        "monthly",
        pattern=r"^(weekly|monthly|semester)$",
        description="Period for low attendance calculation",
    )

    # Consecutive absence alerts
    enable_consecutive_absence_alerts: bool = Field(
        True,
        description="Enable consecutive absence alerts",
    )
    consecutive_absence_threshold: int = Field(
        3,
        ge=1,
        le=30,
        description="Alert after N consecutive absences",
    )

    # Late entry alerts
    enable_late_entry_alerts: bool = Field(
        True,
        description="Enable late entry alerts",
    )
    late_entry_count_threshold: int = Field(
        5,
        ge=1,
        le=31,
        description="Alert after N late entries in evaluation period",
    )
    late_entry_evaluation_period: str = Field(
        "monthly",
        pattern=r"^(weekly|monthly)$",
        description="Period for late entry counting",
    )

    # Pattern detection
    enable_pattern_detection: bool = Field(
        False,
        description="Enable irregular pattern detection (AI/ML based)",
    )
    pattern_sensitivity: str = Field(
        "medium",
        pattern=r"^(low|medium|high)$",
        description="Sensitivity for pattern detection",
    )

    # Absence spike detection
    enable_absence_spike_alerts: bool = Field(
        default=True,
        description="Alert on sudden increase in absences",
    )
    absence_spike_threshold: int = Field(
        default=3,
        ge=2,
        description="Alert when absences increase by N in short period",
    )

    # Notification preferences
    notify_supervisor: bool = Field(
        True,
        description="Send alerts to supervisor",
    )
    notify_admin: bool = Field(
        True,
        description="Send alerts to admin",
    )
    notify_guardian: bool = Field(
        True,
        description="Send alerts to guardian",
    )
    notify_student: bool = Field(
        True,
        description="Send alerts to student",
    )

    # Notification channels
    notification_channels: List[str] = Field(
        default_factory=lambda: ["email", "push"],
        description="Notification delivery channels",
    )

    # Escalation settings
    auto_escalate_enabled: bool = Field(
        default=True,
        description="Enable automatic alert escalation",
    )
    auto_escalate_after_days: int = Field(
        7,
        ge=1,
        le=30,
        description="Auto-escalate unacknowledged alerts after N days",
    )
    max_escalation_level: int = Field(
        default=3,
        ge=1,
        le=5,
        description="Maximum escalation level",
    )

    # Alert suppression
    suppress_duplicate_alerts: bool = Field(
        default=True,
        description="Suppress duplicate alerts within time window",
    )
    duplicate_suppression_hours: int = Field(
        default=24,
        ge=1,
        le=168,
        description="Hours to suppress duplicate alerts",
    )

    # Working hours
    alert_only_during_hours: bool = Field(
        default=False,
        description="Only send alerts during specified hours",
    )
    alert_start_time: Optional[time] = Field(
        None,
        description="Start time for alert notifications",
    )
    alert_end_time: Optional[time] = Field(
        None,
        description="End time for alert notifications",
    )

    @field_validator("notification_channels")
    @classmethod
    def validate_channels(cls, v: List[str]) -> List[str]:
        """Validate notification channels are supported."""
        valid_channels = {"email", "sms", "push", "whatsapp"}
        for channel in v:
            if channel not in valid_channels:
                raise ValueError(f"Invalid notification channel: {channel}")
        return v

    @model_validator(mode="after")
    def validate_config_consistency(self) -> "AlertConfig":
        """Validate configuration consistency."""
        # Validate alert hours if enabled
        if self.alert_only_during_hours:
            if self.alert_start_time is None or self.alert_end_time is None:
                raise ValueError(
                    "alert_start_time and alert_end_time are required when alert_only_during_hours is True"
                )

        # At least one notification recipient should be enabled
        if not any([
            self.notify_supervisor,
            self.notify_admin,
            self.notify_guardian,
            self.notify_student,
        ]):
            raise ValueError(
                "At least one notification recipient must be enabled"
            )

        return self


class AlertTrigger(BaseCreateSchema):
    """
    Manual alert trigger request.
    
    Allows authorized users to manually create alerts for
    specific attendance concerns.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    alert_type: str = Field(
        ...,
        pattern=r"^(low_attendance|consecutive_absences|late_entry|irregular_pattern|custom)$",
        description="Type of alert to trigger",
    )
    severity: str = Field(
        "medium",
        pattern=r"^(low|medium|high|critical)$",
        description="Alert severity level",
    )
    custom_message: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Custom alert message",
    )
    details: Optional[Dict[str, any]] = Field(
        None,
        description="Additional alert details",
    )
    assign_to: Optional[UUID] = Field(
        None,
        description="User ID to assign alert to",
    )
    notify_immediately: bool = Field(
        default=True,
        description="Send notifications immediately",
    )
    triggered_by: UUID = Field(
        ...,
        description="User ID triggering the alert",
    )

    @field_validator("custom_message")
    @classmethod
    def validate_message(cls, v: str) -> str:
        """Validate and normalize message."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Message must be at least 10 characters")
        return v


class AlertAcknowledgment(BaseCreateSchema):
    """
    Acknowledge attendance alert.
    
    Records acknowledgment of an alert with action details.
    """

    alert_id: UUID = Field(
        ...,
        description="Alert unique identifier",
    )
    acknowledged_by: UUID = Field(
        ...,
        description="User ID acknowledging the alert",
    )
    action_taken: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Description of action taken",
    )
    assign_to: Optional[UUID] = Field(
        None,
        description="User ID to assign for follow-up",
    )
    mark_resolved: bool = Field(
        default=False,
        description="Mark alert as resolved",
    )
    additional_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional notes",
    )

    @field_validator("action_taken", "additional_notes")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            if isinstance(v, str) and len(v) < 10 and v == cls.model_fields.get("action_taken"):
                raise ValueError("action_taken must be at least 10 characters")
            return v if v else None
        return None


class AlertList(BaseSchema):
    """
    List of alerts with summary statistics.
    
    Provides paginated alert list with aggregate metrics.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel filter (if applicable)",
    )
    student_id: Optional[UUID] = Field(
        None,
        description="Student filter (if applicable)",
    )
    date_from: Optional[date] = Field(
        None,
        description="Filter alerts from this date",
    )
    date_to: Optional[date] = Field(
        None,
        description="Filter alerts to this date",
    )

    # Summary statistics
    total_alerts: int = Field(
        ...,
        ge=0,
        description="Total number of alerts",
    )
    unacknowledged_alerts: int = Field(
        ...,
        ge=0,
        description="Number of unacknowledged alerts",
    )
    unresolved_alerts: int = Field(
        ...,
        ge=0,
        description="Number of unresolved alerts",
    )
    critical_alerts: int = Field(
        ...,
        ge=0,
        description="Number of critical severity alerts",
    )
    escalated_alerts: int = Field(
        default=0,
        ge=0,
        description="Number of escalated alerts",
    )

    # Alert breakdown by type
    alerts_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Alert counts by type",
    )

    # Alert breakdown by severity
    alerts_by_severity: Dict[str, int] = Field(
        default_factory=dict,
        description="Alert counts by severity",
    )

    # Alert list
    alerts: List[AttendanceAlert] = Field(
        ...,
        description="List of alert records",
    )


class AlertSummary(BaseSchema):
    """
    Alert summary for dashboard display.
    
    Provides high-level overview of alerts for monitoring dashboards.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    period_start: date = Field(
        ...,
        description="Summary period start date",
    )
    period_end: date = Field(
        ...,
        description="Summary period end date",
    )

    # Overall counts
    total_alerts: int = Field(
        ...,
        ge=0,
        description="Total alerts in period",
    )
    new_alerts_today: int = Field(
        default=0,
        ge=0,
        description="Alerts triggered today",
    )

    # By type
    low_attendance_alerts: int = Field(
        ...,
        ge=0,
        description="Low attendance alerts",
    )
    consecutive_absence_alerts: int = Field(
        ...,
        ge=0,
        description="Consecutive absence alerts",
    )
    late_entry_alerts: int = Field(
        ...,
        ge=0,
        description="Late entry alerts",
    )
    pattern_alerts: int = Field(
        ...,
        ge=0,
        description="Irregular pattern alerts",
    )
    policy_violation_alerts: int = Field(
        default=0,
        ge=0,
        description="Policy violation alerts",
    )

    # By severity
    critical_count: int = Field(
        ...,
        ge=0,
        description="Critical alerts",
    )
    high_count: int = Field(
        ...,
        ge=0,
        description="High severity alerts",
    )
    medium_count: int = Field(
        ...,
        ge=0,
        description="Medium severity alerts",
    )
    low_count: int = Field(
        ...,
        ge=0,
        description="Low severity alerts",
    )

    # Status breakdown
    acknowledged_count: int = Field(
        ...,
        ge=0,
        description="Acknowledged alerts",
    )
    resolved_count: int = Field(
        ...,
        ge=0,
        description="Resolved alerts",
    )
    pending_count: int = Field(
        ...,
        ge=0,
        description="Pending/unacknowledged alerts",
    )
    escalated_count: int = Field(
        default=0,
        ge=0,
        description="Escalated alerts",
    )

    # Performance metrics
    average_resolution_time_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average time to resolve alerts (hours)",
    )
    average_acknowledgment_time_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average time to acknowledge alerts (hours)",
    )

    # Student impact
    students_with_alerts: int = Field(
        default=0,
        ge=0,
        description="Number of students with active alerts",
    )
    students_with_critical_alerts: int = Field(
        default=0,
        ge=0,
        description="Students with critical alerts",
    )

    # Trend indicator
    alert_trend: str = Field(
        default="stable",
        pattern=r"^(increasing|decreasing|stable)$",
        description="Alert volume trend",
    )

    @field_validator("period_end")
    @classmethod
    def validate_period(cls, v: date, info) -> date:
        """Validate period dates."""
        if "period_start" in info.data:
            if v < info.data["period_start"]:
                raise ValueError("period_end must be after period_start")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_base.py ---
# --- File: app/schemas/attendance/attendance_base.py ---
"""
Base attendance schemas with comprehensive validation and type safety.

This module provides foundational schemas for attendance tracking including
single and bulk operations with enhanced validation logic.
"""

from __future__ import annotations

from datetime import date, time
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import AttendanceMode, AttendanceStatus

__all__ = [
    "AttendanceBase",
    "AttendanceCreate",
    "AttendanceUpdate",
    "BulkAttendanceCreate",
    "SingleAttendanceRecord",
]


class AttendanceBase(BaseSchema):
    """
    Base attendance schema with core fields.
    
    Provides common attendance attributes used across create/update operations.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    attendance_date: date = Field(
        ...,
        description="Date of attendance record",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Student check-in time",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Student check-out time",
    )
    status: AttendanceStatus = Field(
        AttendanceStatus.PRESENT,
        description="Attendance status",
    )
    is_late: bool = Field(
        False,
        description="Whether student arrived late",
    )
    late_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,  # Max 24 hours
        description="Minutes late (if applicable)",
    )
    attendance_mode: AttendanceMode = Field(
        AttendanceMode.MANUAL,
        description="Method used to record attendance",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked the attendance",
    )
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Supervisor ID who verified/marked attendance",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes or comments",
    )

    @field_validator("attendance_date")
    @classmethod
    def validate_attendance_date(cls, v: date) -> date:
        """
        Validate attendance date is not in future.
        
        Attendance should only be marked for current or past dates.
        """
        if v > date.today():
            raise ValueError("Attendance cannot be marked for future dates")
        return v

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize notes by stripping whitespace."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_check_times(self) -> "AttendanceBase":
        """
        Validate check-in and check-out time consistency.
        
        Ensures:
        - Check-out time is after check-in time (if both provided)
        - Late status is consistent with late_minutes
        - Absent students don't have check-in times
        """
        # Validate check-out is after check-in
        if self.check_in_time and self.check_out_time:
            if self.check_out_time <= self.check_in_time:
                raise ValueError(
                    "Check-out time must be after check-in time"
                )

        # Validate late status consistency
        if self.is_late and self.late_minutes is None:
            raise ValueError(
                "late_minutes must be provided when is_late is True"
            )

        if not self.is_late and self.late_minutes is not None:
            if self.late_minutes > 0:
                raise ValueError(
                    "is_late must be True when late_minutes is provided"
                )

        # Absent students shouldn't have check-in times
        if self.status == AttendanceStatus.ABSENT:
            if self.check_in_time or self.check_out_time:
                raise ValueError(
                    "Absent students cannot have check-in or check-out times"
                )
            if self.is_late or self.late_minutes:
                raise ValueError(
                    "Absent students cannot be marked as late"
                )

        return self


class AttendanceCreate(AttendanceBase, BaseCreateSchema):
    """
    Create attendance record with location and device tracking.
    
    Extends base schema with mobile app specific fields for geo-location
    and device information tracking.
    """

    location_lat: Optional[Decimal] = Field(
        None,
        ge=-90,
        le=90,
        description="Latitude coordinate for mobile check-in",
    )
    location_lng: Optional[Decimal] = Field(
        None,
        ge=-180,
        le=180,
        description="Longitude coordinate for mobile check-in",
    )
    device_info: Optional[dict] = Field(
        None,
        description="Device information for mobile app check-ins",
    )

    @model_validator(mode="after")
    def validate_location_completeness(self) -> "AttendanceCreate":
        """
        Validate location coordinates are provided together.
        
        Both latitude and longitude must be provided or both must be None.
        """
        has_lat = self.location_lat is not None
        has_lng = self.location_lng is not None

        if has_lat != has_lng:
            raise ValueError(
                "Both latitude and longitude must be provided together"
            )

        return self


class AttendanceUpdate(BaseUpdateSchema):
    """
    Update attendance record with partial field updates.
    
    All fields are optional for flexible partial updates.
    """

    check_in_time: Optional[time] = Field(
        None,
        description="Updated check-in time",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Updated check-out time",
    )
    status: Optional[AttendanceStatus] = Field(
        None,
        description="Updated attendance status",
    )
    is_late: Optional[bool] = Field(
        None,
        description="Updated late status",
    )
    late_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Updated late minutes",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Updated notes",
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize notes by stripping whitespace."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_update_consistency(self) -> "AttendanceUpdate":
        """
        Validate consistency of update fields.
        
        Ensures late status and minutes are consistent when both are updated.
        """
        if self.is_late is not None and self.late_minutes is not None:
            if self.is_late and self.late_minutes == 0:
                raise ValueError(
                    "late_minutes must be greater than 0 when is_late is True"
                )
            if not self.is_late and self.late_minutes > 0:
                raise ValueError(
                    "is_late must be True when late_minutes is greater than 0"
                )

        return self


class SingleAttendanceRecord(BaseSchema):
    """
    Single attendance record for bulk operations.
    
    Lightweight schema used within bulk attendance creation.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    status: AttendanceStatus = Field(
        AttendanceStatus.PRESENT,
        description="Attendance status",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time",
    )
    is_late: bool = Field(
        False,
        description="Late arrival flag",
    )
    late_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Minutes late",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes",
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize notes by stripping whitespace."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_late_consistency(self) -> "SingleAttendanceRecord":
        """Validate late status and minutes consistency."""
        if self.is_late and self.late_minutes is None:
            raise ValueError(
                "late_minutes must be provided when is_late is True"
            )

        if not self.is_late and self.late_minutes is not None and self.late_minutes > 0:
            raise ValueError(
                "is_late must be True when late_minutes is provided"
            )

        # Absent students shouldn't be late
        if self.status == AttendanceStatus.ABSENT:
            if self.is_late or self.late_minutes:
                raise ValueError(
                    "Absent students cannot be marked as late"
                )

        return self


class BulkAttendanceCreate(BaseCreateSchema):
    """
    Bulk create multiple attendance records efficiently.
    
    Allows marking attendance for multiple students in a single operation
    with validation to prevent duplicate entries.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    attendance_date: date = Field(
        ...,
        description="Date for all attendance records",
    )
    records: List[SingleAttendanceRecord] = Field(
        ...,
        min_length=1,
        max_length=500,
        description="List of student attendance records",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked attendance",
    )
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Supervisor ID who verified attendance",
    )

    @field_validator("attendance_date")
    @classmethod
    def validate_attendance_date(cls, v: date) -> date:
        """Validate attendance date is not in future."""
        if v > date.today():
            raise ValueError("Attendance cannot be marked for future dates")
        return v

    @model_validator(mode="after")
    def validate_unique_students(self) -> "BulkAttendanceCreate":
        """
        Ensure no duplicate student IDs in bulk operation.
        
        Prevents multiple attendance records for same student on same date.
        """
        student_ids = [record.student_id for record in self.records]
        unique_ids = set(student_ids)

        if len(student_ids) != len(unique_ids):
            # Find duplicates
            seen = set()
            duplicates = []
            for student_id in student_ids:
                if student_id in seen:
                    duplicates.append(str(student_id))
                seen.add(student_id)

            raise ValueError(
                f"Duplicate student IDs found in bulk operation: {', '.join(duplicates)}"
            )

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_filters.py ---
# --- File: app/schemas/attendance/attendance_filters.py ---
"""
Attendance filter schemas for querying and exporting.

Provides comprehensive filtering capabilities with validation
for date ranges, status filters, and export configurations.
"""

from __future__ import annotations

from datetime import date
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import AttendanceMode, AttendanceStatus
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "AttendanceFilterParams",
    "DateRangeRequest",
    "AttendanceExportRequest",
]


class AttendanceFilterParams(BaseFilterSchema):
    """
    Comprehensive attendance filter parameters.
    
    Supports multi-dimensional filtering by hostel, student, date,
    status, and marking metadata.
    """

    # Hostel filters
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by specific hostel",
    )
    hostel_ids: Optional[List[UUID]] = Field(
        None,
        min_length=1,
        max_length=100,
        description="Filter by multiple hostels",
    )

    # Student filters
    student_id: Optional[UUID] = Field(
        None,
        description="Filter by specific student",
    )
    student_ids: Optional[List[UUID]] = Field(
        None,
        min_length=1,
        max_length=500,
        description="Filter by multiple students",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Filter by room",
    )
    room_ids: Optional[List[UUID]] = Field(
        None,
        min_length=1,
        max_length=100,
        description="Filter by multiple rooms",
    )

    # Date range filters
    date_from: Optional[date] = Field(
        None,
        description="Start date (inclusive)",
    )
    date_to: Optional[date] = Field(
        None,
        description="End date (inclusive)",
    )
    specific_date: Optional[date] = Field(
        None,
        description="Filter by specific date",
    )

    # Status filters
    status: Optional[AttendanceStatus] = Field(
        None,
        description="Filter by specific status",
    )
    statuses: Optional[List[AttendanceStatus]] = Field(
        None,
        min_length=1,
        description="Filter by multiple statuses",
    )
    exclude_statuses: Optional[List[AttendanceStatus]] = Field(
        None,
        min_length=1,
        description="Exclude specific statuses",
    )

    # Late filter
    late_only: Optional[bool] = Field(
        None,
        description="Filter only late arrivals (True) or exclude late (False)",
    )

    # Marking metadata
    marked_by: Optional[UUID] = Field(
        None,
        description="Filter by user who marked attendance",
    )
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Filter by supervisor",
    )
    attendance_mode: Optional[AttendanceMode] = Field(
        None,
        description="Filter by marking method",
    )

    # Advanced filters
    has_notes: Optional[bool] = Field(
        None,
        description="Filter records with/without notes",
    )
    has_location: Optional[bool] = Field(
        None,
        description="Filter records with/without location data",
    )

    @field_validator("date_to")
    @classmethod
    def validate_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate end date is after or equal to start date."""
        if v is not None and "date_from" in info.data:
            date_from = info.data["date_from"]
            if date_from is not None and v < date_from:
                raise ValueError("date_to must be after or equal to date_from")
        return v

    @model_validator(mode="after")
    def validate_filter_consistency(self) -> "AttendanceFilterParams":
        """
        Validate filter parameter consistency.
        
        Ensures:
        - Date filters are logically consistent
        - List filters are not empty
        - Conflicting filters are not used together
        """
        # Validate specific_date doesn't conflict with range
        if self.specific_date is not None:
            if self.date_from is not None or self.date_to is not None:
                raise ValueError(
                    "Cannot use specific_date with date_from/date_to"
                )

        # Validate status filters
        if self.status is not None and self.statuses is not None:
            raise ValueError(
                "Cannot use both status and statuses filters"
            )

        if self.statuses is not None and self.exclude_statuses is not None:
            overlap = set(self.statuses) & set(self.exclude_statuses)
            if overlap:
                raise ValueError(
                    "Cannot include and exclude the same statuses"
                )

        # Validate student filters
        if self.student_id is not None and self.student_ids is not None:
            raise ValueError(
                "Cannot use both student_id and student_ids filters"
            )

        # Validate hostel filters
        if self.hostel_id is not None and self.hostel_ids is not None:
            raise ValueError(
                "Cannot use both hostel_id and hostel_ids filters"
            )

        return self


class DateRangeRequest(BaseFilterSchema):
    """
    Simple date range request with validation.
    
    Used for reports and queries requiring date range specification.
    """

    start_date: date = Field(
        ...,
        description="Start date (inclusive)",
    )
    end_date: date = Field(
        ...,
        description="End date (inclusive)",
    )

    @field_validator("start_date")
    @classmethod
    def validate_start_date(cls, v: date) -> date:
        """Ensure start date is not too far in the past."""
        # Allow up to 5 years of historical data
        max_past_days = 365 * 5
        days_diff = (date.today() - v).days
        
        if days_diff > max_past_days:
            raise ValueError(
                f"start_date cannot be more than {max_past_days} days in the past"
            )
        
        return v

    @field_validator("end_date")
    @classmethod
    def validate_end_date(cls, v: date, info) -> date:
        """
        Validate end date constraints.
        
        Ensures:
        - End date is after or equal to start date
        - End date is not in future
        - Date range is reasonable (not too large)
        """
        # Validate not in future
        if v > date.today():
            raise ValueError("end_date cannot be in the future")

        # Validate against start date
        if "start_date" in info.data:
            start_date = info.data["start_date"]
            if v < start_date:
                raise ValueError("end_date must be after or equal to start_date")

            # Validate range is not too large (max 1 year)
            days_diff = (v - start_date).days
            if days_diff > 365:
                raise ValueError(
                    "Date range cannot exceed 365 days"
                )

        return v


class AttendanceExportRequest(BaseFilterSchema):
    """
    Export attendance data with format and options.
    
    Supports multiple export formats with customizable content
    and grouping options.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel to export data for",
    )
    date_range: DateRangeFilter = Field(
        ...,
        description="Date range for export",
    )

    # Student filters
    student_ids: Optional[List[UUID]] = Field(
        None,
        max_length=500,
        description="Export specific students only",
    )
    room_ids: Optional[List[UUID]] = Field(
        None,
        max_length=100,
        description="Export specific rooms only",
    )

    # Status filters
    statuses: Optional[List[AttendanceStatus]] = Field(
        None,
        description="Filter by attendance statuses",
    )
    include_late_only: bool = Field(
        False,
        description="Include only late arrivals",
    )

    # Format
    format: str = Field(
        "csv",
        pattern=r"^(csv|excel|pdf)$",
        description="Export format: csv, excel, or pdf",
    )

    # Content options
    include_summary: bool = Field(
        True,
        description="Include summary statistics",
    )
    include_percentage: bool = Field(
        True,
        description="Include attendance percentage calculations",
    )
    include_notes: bool = Field(
        False,
        description="Include notes column",
    )
    include_location: bool = Field(
        False,
        description="Include location data (if available)",
    )
    include_device_info: bool = Field(
        False,
        description="Include device information",
    )

    # Grouping and sorting
    group_by: str = Field(
        "student",
        pattern=r"^(student|date|room|status)$",
        description="Group records by: student, date, room, or status",
    )
    sort_by: str = Field(
        "date",
        pattern=r"^(date|student_name|room|status)$",
        description="Sort records by field",
    )
    sort_order: str = Field(
        "asc",
        pattern=r"^(asc|desc)$",
        description="Sort order: ascending or descending",
    )

    # Output options
    file_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Custom filename for export (without extension)",
    )
    include_timestamp: bool = Field(
        True,
        description="Include timestamp in filename",
    )

    @field_validator("file_name")
    @classmethod
    def validate_filename(cls, v: Optional[str]) -> Optional[str]:
        """Validate and sanitize filename."""
        if v is not None:
            # Remove invalid characters
            import re
            v = re.sub(r'[<>:"/\\|?*]', '', v)
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_export_config(self) -> "AttendanceExportRequest":
        """
        Validate export configuration consistency.
        
        Ensures compatible options are selected based on format.
        """
        # PDF-specific validations
        if self.format == "pdf":
            if self.group_by not in ["student", "date"]:
                raise ValueError(
                    "PDF format supports only 'student' or 'date' grouping"
                )

        # Validate date range
        if self.date_range.start_date and self.date_range.end_date:
            days_diff = (
                self.date_range.end_date - self.date_range.start_date
            ).days
            
            # Large exports might cause performance issues
            if days_diff > 365:
                raise ValueError(
                    "Export date range cannot exceed 365 days"
                )

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_policy.py ---
# --- File: app/schemas/attendance/attendance_policy.py ---
"""
Attendance policy configuration schemas.

Defines policy rules, thresholds, and violation tracking for
attendance management with comprehensive validation.
"""

from __future__ import annotations

from datetime import date, time
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema, BaseUpdateSchema

__all__ = [
    "AttendancePolicy",
    "PolicyConfig",
    "PolicyUpdate",
    "PolicyViolation",
]


class AttendancePolicy(BaseResponseSchema):
    """
    Attendance policy configuration for a hostel.
    
    Defines rules, thresholds, and automated behaviors for
    attendance tracking and enforcement.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )

    # Minimum requirements
    minimum_attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Minimum required attendance percentage",
    )

    # Late entry configuration
    late_entry_threshold_minutes: int = Field(
        ...,
        ge=0,
        le=240,
        description="Minutes after expected time to mark as late",
    )
    grace_period_minutes: int = Field(
        default=5,
        ge=0,
        le=30,
        description="Grace period before marking late",
    )
    grace_days_per_month: int = Field(
        ...,
        ge=0,
        le=31,
        description="Allowed late entries per month without penalty",
    )

    # Absence alerts
    consecutive_absence_alert_days: int = Field(
        ...,
        ge=1,
        le=30,
        description="Alert after N consecutive absences",
    )
    total_absence_alert_threshold: int = Field(
        default=10,
        ge=1,
        description="Alert after N total absences in period",
    )

    # Notification settings
    notify_guardian_on_absence: bool = Field(
        True,
        description="Send guardian notification on absence",
    )
    notify_admin_on_low_attendance: bool = Field(
        True,
        description="Send admin notification for low attendance",
    )
    notify_student_on_low_attendance: bool = Field(
        default=True,
        description="Send student notification for low attendance",
    )
    low_attendance_threshold: Decimal = Field(
        Decimal("75.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Threshold for low attendance notifications",
    )

    # Auto-marking configuration
    auto_mark_absent_enabled: bool = Field(
        default=False,
        description="Enable automatic absent marking",
    )
    auto_mark_absent_after_time: Optional[time] = Field(
        None,
        description="Auto mark absent if not checked in by this time",
    )

    # Weekend and holiday handling
    track_weekend_attendance: bool = Field(
        default=False,
        description="Track attendance on weekends",
    )
    track_holiday_attendance: bool = Field(
        default=False,
        description="Track attendance on holidays",
    )

    # Policy status
    is_active: bool = Field(
        True,
        description="Whether policy is currently active",
    )
    effective_from: Optional[date] = Field(
        None,
        description="Date from which policy is effective",
    )
    effective_until: Optional[date] = Field(
        None,
        description="Date until which policy is effective",
    )

    @field_validator("minimum_attendance_percentage", "low_attendance_threshold")
    @classmethod
    def round_percentage(cls, v: Decimal) -> Decimal:
        """Round percentage to 2 decimal places."""
        return round(v, 2)

    @model_validator(mode="after")
    def validate_policy_consistency(self) -> "AttendancePolicy":
        """
        Validate policy configuration consistency.
        
        Ensures:
        - Low attendance threshold is below minimum requirement
        - Effective dates are logical
        - Auto-mark time is set if enabled
        """
        # Low attendance threshold should be less than minimum
        if self.low_attendance_threshold > self.minimum_attendance_percentage:
            raise ValueError(
                "low_attendance_threshold should be less than minimum_attendance_percentage"
            )

        # Validate effective dates
        if self.effective_from and self.effective_until:
            if self.effective_until < self.effective_from:
                raise ValueError(
                    "effective_until must be after effective_from"
                )

        # Auto-mark validation
        if self.auto_mark_absent_enabled and self.auto_mark_absent_after_time is None:
            raise ValueError(
                "auto_mark_absent_after_time is required when auto_mark_absent_enabled is True"
            )

        return self


class PolicyConfig(BaseSchema):
    """
    Extended policy configuration with calculation rules.
    
    Defines how attendance is calculated and what factors are
    considered in the calculation.
    """

    # Calculation settings
    calculation_period: str = Field(
        "monthly",
        pattern=r"^(weekly|monthly|semester|yearly|custom)$",
        description="Period for attendance calculation",
    )
    custom_period_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Custom period length in days (if calculation_period is 'custom')",
    )

    # Leave handling
    count_leave_as_absent: bool = Field(
        False,
        description="Whether to count approved leaves as absent",
    )
    count_leave_as_present: bool = Field(
        True,
        description="Whether to count approved leaves as present",
    )
    max_leaves_per_month: int = Field(
        3,
        ge=0,
        le=31,
        description="Maximum allowed leaves per month",
    )
    max_leaves_per_semester: Optional[int] = Field(
        None,
        ge=0,
        description="Maximum allowed leaves per semester",
    )

    # Weekend configuration
    include_weekends: bool = Field(
        False,
        description="Include weekends in attendance tracking",
    )
    weekend_days: List[str] = Field(
        default_factory=lambda: ["Saturday", "Sunday"],
        description="Days considered as weekends",
    )

    # Holiday configuration
    exclude_holidays: bool = Field(
        True,
        description="Exclude holidays from attendance calculation",
    )
    auto_import_holidays: bool = Field(
        default=True,
        description="Automatically import regional holidays",
    )

    # Half-day handling
    half_day_weight: Decimal = Field(
        Decimal("0.5"),
        ge=0,
        le=1,
        description="Weight for half-day attendance (0.5 = half, 1.0 = full)",
    )

    # Late entry penalties
    apply_late_penalty: bool = Field(
        default=False,
        description="Apply penalty for late entries",
    )
    late_penalty_after_count: int = Field(
        default=5,
        ge=1,
        description="Apply penalty after N late entries in month",
    )
    late_penalty_type: str = Field(
        default="warning",
        pattern=r"^(warning|deduction|fine)$",
        description="Type of penalty for excessive late entries",
    )
    late_penalty_deduction_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Percentage to deduct for late penalty",
    )

    # Rounding rules
    round_percentage_to: int = Field(
        2,
        ge=0,
        le=4,
        description="Decimal places for percentage rounding",
    )
    rounding_mode: str = Field(
        "standard",
        pattern=r"^(up|down|standard)$",
        description="Rounding mode for attendance percentage",
    )

    @field_validator("weekend_days")
    @classmethod
    def validate_weekend_days(cls, v: List[str]) -> List[str]:
        """Validate weekend days are valid day names."""
        valid_days = {
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
            "Sunday",
        }
        for day in v:
            if day not in valid_days:
                raise ValueError(f"Invalid day name: {day}")
        return v

    @model_validator(mode="after")
    def validate_config_consistency(self) -> "PolicyConfig":
        """Validate configuration consistency."""
        # Can't count leave as both absent and present
        if self.count_leave_as_absent and self.count_leave_as_present:
            raise ValueError(
                "Leave cannot be counted as both absent and present"
            )

        # Custom period validation
        if self.calculation_period == "custom" and self.custom_period_days is None:
            raise ValueError(
                "custom_period_days is required when calculation_period is 'custom'"
            )

        # Late penalty validation
        if self.apply_late_penalty:
            if self.late_penalty_type == "deduction":
                if self.late_penalty_deduction_percentage is None:
                    raise ValueError(
                        "late_penalty_deduction_percentage is required for 'deduction' penalty type"
                    )

        return self


class PolicyUpdate(BaseUpdateSchema):
    """
    Update attendance policy with partial fields.
    
    All fields are optional for flexible policy updates.
    """

    minimum_attendance_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Updated minimum attendance percentage",
    )
    late_entry_threshold_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=240,
        description="Updated late entry threshold",
    )
    grace_period_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=30,
        description="Updated grace period",
    )
    grace_days_per_month: Optional[int] = Field(
        None,
        ge=0,
        le=31,
        description="Updated grace days per month",
    )
    consecutive_absence_alert_days: Optional[int] = Field(
        None,
        ge=1,
        le=30,
        description="Updated consecutive absence alert threshold",
    )
    notify_guardian_on_absence: Optional[bool] = None
    notify_admin_on_low_attendance: Optional[bool] = None
    notify_student_on_low_attendance: Optional[bool] = None
    low_attendance_threshold: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Updated low attendance threshold",
    )
    auto_mark_absent_enabled: Optional[bool] = None
    auto_mark_absent_after_time: Optional[time] = None
    track_weekend_attendance: Optional[bool] = None
    track_holiday_attendance: Optional[bool] = None
    is_active: Optional[bool] = None
    effective_from: Optional[date] = None
    effective_until: Optional[date] = None

    @field_validator(
        "minimum_attendance_percentage",
        "low_attendance_threshold",
    )
    @classmethod
    def round_percentage(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round percentage to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_update_consistency(self) -> "PolicyUpdate":
        """Validate update consistency when related fields are both provided."""
        # Validate thresholds if both are provided
        if (
            self.low_attendance_threshold is not None
            and self.minimum_attendance_percentage is not None
        ):
            if self.low_attendance_threshold > self.minimum_attendance_percentage:
                raise ValueError(
                    "low_attendance_threshold should be less than minimum_attendance_percentage"
                )

        # Validate effective dates if both provided
        if self.effective_from and self.effective_until:
            if self.effective_until < self.effective_from:
                raise ValueError(
                    "effective_until must be after effective_from"
                )

        return self


class PolicyViolation(BaseSchema):
    """
    Attendance policy violation record.
    
    Tracks instances where students violate attendance policies
    with details for corrective action.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Student room number",
    )

    # Violation details
    violation_type: str = Field(
        ...,
        pattern=r"^(low_attendance|consecutive_absences|excessive_late_entries|unauthorized_absence)$",
        description="Type of policy violation",
    )
    severity: str = Field(
        ...,
        pattern=r"^(low|medium|high|critical)$",
        description="Violation severity level",
    )

    # Metrics
    current_attendance_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Current attendance percentage",
    )
    required_attendance_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Required attendance percentage",
    )
    consecutive_absences: Optional[int] = Field(
        None,
        ge=0,
        description="Number of consecutive absences",
    )
    late_entries_this_month: Optional[int] = Field(
        None,
        ge=0,
        description="Late entries in current month",
    )
    total_absences_this_month: Optional[int] = Field(
        None,
        ge=0,
        description="Total absences in current month",
    )

    # Violation tracking
    violation_date: date = Field(
        ...,
        description="Date when violation was detected",
    )
    first_violation_date: Optional[date] = Field(
        None,
        description="Date of first related violation",
    )

    # Actions taken
    guardian_notified: bool = Field(
        ...,
        description="Guardian notification sent",
    )
    guardian_notified_at: Optional[datetime] = Field(
        None,
        description="Guardian notification timestamp",
    )
    admin_notified: bool = Field(
        ...,
        description="Admin notification sent",
    )
    admin_notified_at: Optional[datetime] = Field(
        None,
        description="Admin notification timestamp",
    )
    student_notified: bool = Field(
        default=False,
        description="Student notification sent",
    )
    warning_issued: bool = Field(
        ...,
        description="Formal warning issued",
    )
    warning_issued_at: Optional[datetime] = Field(
        None,
        description="Warning issue timestamp",
    )

    # Resolution
    resolved: bool = Field(
        default=False,
        description="Whether violation has been resolved",
    )
    resolved_at: Optional[datetime] = Field(
        None,
        description="Resolution timestamp",
    )
    resolution_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Notes about how violation was resolved",
    )

    # Additional context
    notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional notes about violation",
    )
    action_plan: Optional[str] = Field(
        None,
        max_length=1000,
        description="Planned corrective actions",
    )

    @field_validator("resolution_notes", "notes", "action_plan")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_violation_data(self) -> "PolicyViolation":
        """
        Validate violation data consistency.
        
        Ensures violation-specific metrics are provided based on type.
        """
        # Validate violation-specific requirements
        if self.violation_type == "low_attendance":
            if self.current_attendance_percentage is None:
                raise ValueError(
                    "current_attendance_percentage is required for low_attendance violation"
                )
            if self.required_attendance_percentage is None:
                raise ValueError(
                    "required_attendance_percentage is required for low_attendance violation"
                )

        if self.violation_type == "consecutive_absences":
            if self.consecutive_absences is None:
                raise ValueError(
                    "consecutive_absences is required for consecutive_absences violation"
                )

        if self.violation_type == "excessive_late_entries":
            if self.late_entries_this_month is None:
                raise ValueError(
                    "late_entries_this_month is required for excessive_late_entries violation"
                )

        # Resolution validation
        if self.resolved and self.resolved_at is None:
            raise ValueError(
                "resolved_at timestamp is required when violation is resolved"
            )

        # Notification timestamps
        if self.guardian_notified and self.guardian_notified_at is None:
            raise ValueError(
                "guardian_notified_at is required when guardian_notified is True"
            )

        if self.warning_issued and self.warning_issued_at is None:
            raise ValueError(
                "warning_issued_at is required when warning_issued is True"
            )

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_record.py ---
# --- File: app/schemas/attendance/attendance_record.py ---
"""
Attendance recording schemas with validation for various marking methods.

Provides schemas for single, bulk, correction, and quick attendance marking
operations with comprehensive validation logic.
"""

from __future__ import annotations

from datetime import date, time
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import AttendanceStatus, AttendanceMode

__all__ = [
    "AttendanceRecordRequest",
    "BulkAttendanceRequest",
    "StudentAttendanceRecord",
    "AttendanceCorrection",
    "QuickAttendanceMarkAll",
]


class AttendanceRecordRequest(BaseCreateSchema):
    """
    Record attendance for single student with validation.
    
    Used for individual attendance marking with comprehensive validation.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    attendance_date: date = Field(
        ...,
        description="Date of attendance",
    )
    status: AttendanceStatus = Field(
        AttendanceStatus.PRESENT,
        description="Attendance status",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time (required for PRESENT status)",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Check-out time",
    )
    is_late: bool = Field(
        False,
        description="Late arrival indicator",
    )
    late_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Minutes late (if applicable)",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes or remarks",
    )

    @field_validator("attendance_date")
    @classmethod
    def validate_date(cls, v: date) -> date:
        """Ensure attendance date is not in future."""
        if v > date.today():
            raise ValueError("Attendance date cannot be in the future")
        return v

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize and validate notes."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_attendance_logic(self) -> "AttendanceRecordRequest":
        """
        Validate attendance record consistency.
        
        Ensures:
        - Present students have check-in time
        - Absent students don't have check-in/out times
        - Late status matches late_minutes
        - Check-out is after check-in
        """
        # Present students should have check-in time
        if self.status == AttendanceStatus.PRESENT:
            if self.check_in_time is None:
                raise ValueError(
                    "check_in_time is required for PRESENT status"
                )

        # Absent students shouldn't have times
        if self.status == AttendanceStatus.ABSENT:
            if self.check_in_time or self.check_out_time:
                raise ValueError(
                    "Absent students cannot have check-in or check-out times"
                )
            if self.is_late or self.late_minutes:
                raise ValueError(
                    "Absent students cannot be marked as late"
                )

        # Validate check-out time
        if self.check_in_time and self.check_out_time:
            if self.check_out_time <= self.check_in_time:
                raise ValueError(
                    "check_out_time must be after check_in_time"
                )

        # Validate late status
        if self.is_late and self.late_minutes is None:
            raise ValueError(
                "late_minutes is required when is_late is True"
            )

        if not self.is_late and self.late_minutes is not None and self.late_minutes > 0:
            raise ValueError(
                "is_late must be True when late_minutes is greater than 0"
            )

        return self


class StudentAttendanceRecord(BaseSchema):
    """
    Individual student attendance record for bulk operations.
    
    Lightweight schema optimized for bulk processing with optional
    field overrides.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    status: Optional[AttendanceStatus] = Field(
        None,
        description="Attendance status (uses default_status if None)",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Check-out time",
    )
    is_late: Optional[bool] = Field(
        None,
        description="Late arrival indicator",
    )
    late_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Minutes late",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes",
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize notes."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_consistency(self) -> "StudentAttendanceRecord":
        """Validate consistency of provided fields."""
        # Validate check times
        if self.check_in_time and self.check_out_time:
            if self.check_out_time <= self.check_in_time:
                raise ValueError(
                    "check_out_time must be after check_in_time"
                )

        # Validate late status
        if self.is_late is not None and self.late_minutes is not None:
            if self.is_late and self.late_minutes == 0:
                raise ValueError(
                    "late_minutes must be greater than 0 when is_late is True"
                )

        # Absent students validation
        if self.status == AttendanceStatus.ABSENT:
            if self.check_in_time or self.check_out_time:
                raise ValueError(
                    "Absent students cannot have check-in or check-out times"
                )

        return self


class BulkAttendanceRequest(BaseCreateSchema):
    """
    Mark attendance for multiple students efficiently.
    
    Supports default status for all students with per-student overrides
    and duplicate prevention.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    attendance_date: date = Field(
        ...,
        description="Date for all attendance records",
    )
    default_status: AttendanceStatus = Field(
        AttendanceStatus.PRESENT,
        description="Default status applied to all students unless overridden",
    )
    student_records: List[StudentAttendanceRecord] = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Individual student attendance records",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked the attendance",
    )
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Supervisor ID who verified the attendance",
    )
    marking_mode: AttendanceMode = Field(
        AttendanceMode.MANUAL,
        description="Method used to record attendance",
    )

    @field_validator("attendance_date")
    @classmethod
    def validate_date(cls, v: date) -> date:
        """Validate attendance date is not in future."""
        if v > date.today():
            raise ValueError("Attendance date cannot be in the future")
        return v

    @model_validator(mode="after")
    def validate_unique_students(self) -> "BulkAttendanceRequest":
        """
        Ensure no duplicate student IDs in the request.
        
        Prevents multiple records for same student on same date.
        """
        student_ids = [record.student_id for record in self.student_records]
        unique_ids = set(student_ids)

        if len(student_ids) != len(unique_ids):
            # Identify duplicates for error message
            seen = set()
            duplicates = set()
            for student_id in student_ids:
                if student_id in seen:
                    duplicates.add(str(student_id))
                seen.add(student_id)

            raise ValueError(
                f"Duplicate student IDs not allowed: {', '.join(duplicates)}"
            )

        return self


class AttendanceCorrection(BaseCreateSchema):
    """
    Correct previously marked attendance with audit trail.
    
    Allows authorized users to correct attendance errors with
    mandatory reason documentation.
    """

    attendance_id: UUID = Field(
        ...,
        description="Attendance record ID to correct",
    )
    corrected_status: AttendanceStatus = Field(
        ...,
        description="Corrected attendance status",
    )
    corrected_check_in_time: Optional[time] = Field(
        None,
        description="Corrected check-in time",
    )
    corrected_check_out_time: Optional[time] = Field(
        None,
        description="Corrected check-out time",
    )
    corrected_is_late: Optional[bool] = Field(
        None,
        description="Corrected late status",
    )
    corrected_late_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Corrected late minutes",
    )
    correction_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for correction (mandatory for audit)",
    )
    corrected_by: UUID = Field(
        ...,
        description="User ID who made the correction",
    )

    @field_validator("correction_reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate correction reason is meaningful."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError(
                "Correction reason must be at least 10 characters"
            )
        return v

    @model_validator(mode="after")
    def validate_corrections(self) -> "AttendanceCorrection":
        """
        Validate corrected values consistency.
        
        Ensures corrected times and late status are logically consistent.
        """
        # Validate check times
        if self.corrected_check_in_time and self.corrected_check_out_time:
            if self.corrected_check_out_time <= self.corrected_check_in_time:
                raise ValueError(
                    "Corrected check-out time must be after check-in time"
                )

        # Validate late status
        if self.corrected_is_late is not None and self.corrected_late_minutes is not None:
            if self.corrected_is_late and self.corrected_late_minutes == 0:
                raise ValueError(
                    "Corrected late_minutes must be greater than 0 when is_late is True"
                )

        # Absent students shouldn't have times
        if self.corrected_status == AttendanceStatus.ABSENT:
            if self.corrected_check_in_time or self.corrected_check_out_time:
                raise ValueError(
                    "Absent students cannot have check-in or check-out times"
                )
            if self.corrected_is_late or self.corrected_late_minutes:
                raise ValueError(
                    "Absent students cannot be marked as late"
                )

        return self


class QuickAttendanceMarkAll(BaseCreateSchema):
    """
    Quick mark all students with exception handling.
    
    Efficiently marks all students as present with ability to specify
    exceptions (absent, on leave) for streamlined daily attendance.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    attendance_date: date = Field(
        ...,
        description="Date for attendance marking",
    )
    default_check_in_time: Optional[time] = Field(
        None,
        description="Default check-in time for all present students",
    )
    absent_student_ids: List[UUID] = Field(
        default_factory=list,
        max_length=500,
        description="Student IDs to mark as absent",
    )
    on_leave_student_ids: List[UUID] = Field(
        default_factory=list,
        max_length=500,
        description="Student IDs to mark as on leave",
    )
    late_student_ids: List[UUID] = Field(
        default_factory=list,
        max_length=500,
        description="Student IDs to mark as late",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked the attendance",
    )
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Supervisor ID who verified attendance",
    )

    @field_validator("attendance_date")
    @classmethod
    def validate_date(cls, v: date) -> date:
        """Validate attendance date is not in future."""
        if v > date.today():
            raise ValueError("Attendance date cannot be in the future")
        return v

    @model_validator(mode="after")
    def validate_no_overlapping_exceptions(self) -> "QuickAttendanceMarkAll":
        """
        Ensure students aren't in multiple exception lists.
        
        A student can only be in one exception category.
        """
        absent_set = set(self.absent_student_ids)
        leave_set = set(self.on_leave_student_ids)
        late_set = set(self.late_student_ids)

        # Check for overlaps
        overlap_absent_leave = absent_set & leave_set
        overlap_absent_late = absent_set & late_set
        overlap_leave_late = leave_set & late_set

        errors = []
        if overlap_absent_leave:
            errors.append(
                f"Students in both absent and leave lists: {', '.join(str(id) for id in overlap_absent_leave)}"
            )
        if overlap_absent_late:
            errors.append(
                f"Students in both absent and late lists: {', '.join(str(id) for id in overlap_absent_late)}"
            )
        if overlap_leave_late:
            errors.append(
                f"Students in both leave and late lists: {', '.join(str(id) for id in overlap_leave_late)}"
            )

        if errors:
            raise ValueError("; ".join(errors))

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_report.py ---
# --- File: app/schemas/attendance/attendance_report.py ---
"""
Attendance reporting schemas with analytics and trends.

Provides comprehensive reporting capabilities including summaries,
trends, comparisons, and multi-level aggregations.
"""

from __future__ import annotations

from datetime import date, datetime, time
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, computed_field, field_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import AttendanceStatus
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "AttendanceReport",
    "AttendanceSummary",
    "DailyAttendanceRecord",
    "TrendAnalysis",
    "WeeklyAttendance",
    "MonthlyComparison",
    "MonthlyReport",
    "StudentMonthlySummary",
    "AttendanceComparison",
    "ComparisonItem",
]


class AttendanceSummary(BaseSchema):
    """
    Comprehensive attendance summary statistics.
    
    Provides aggregated metrics, percentages, streaks, and status
    assessment for a given period.
    """

    total_days: int = Field(
        ...,
        ge=0,
        description="Total number of days in period",
    )
    total_present: int = Field(
        ...,
        ge=0,
        description="Total present days",
    )
    total_absent: int = Field(
        ...,
        ge=0,
        description="Total absent days",
    )
    total_late: int = Field(
        ...,
        ge=0,
        description="Total late arrivals",
    )
    total_on_leave: int = Field(
        ...,
        ge=0,
        description="Total days on leave",
    )
    total_half_day: int = Field(
        default=0,
        ge=0,
        description="Total half-day attendances",
    )
    attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall attendance percentage",
    )
    late_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of late arrivals",
    )

    # Streak tracking
    current_present_streak: int = Field(
        ...,
        ge=0,
        description="Current consecutive present days",
    )
    longest_present_streak: int = Field(
        ...,
        ge=0,
        description="Longest consecutive present streak in period",
    )
    current_absent_streak: int = Field(
        ...,
        ge=0,
        description="Current consecutive absent days",
    )
    longest_absent_streak: int = Field(
        default=0,
        ge=0,
        description="Longest consecutive absent streak in period",
    )

    # Status assessment
    attendance_status: str = Field(
        ...,
        pattern=r"^(excellent|good|warning|critical)$",
        description="Qualitative attendance assessment",
    )
    meets_minimum_requirement: bool = Field(
        ...,
        description="Whether attendance meets minimum policy requirement",
    )
    minimum_requirement_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Minimum required attendance percentage",
    )

    @field_validator("attendance_percentage", "late_percentage")
    @classmethod
    def round_percentage(cls, v: Decimal) -> Decimal:
        """Round percentages to 2 decimal places."""
        return round(v, 2)

    @computed_field
    @property
    def total_accounted_days(self) -> int:
        """Calculate total days with attendance recorded."""
        return (
            self.total_present
            + self.total_absent
            + self.total_late
            + self.total_on_leave
            + self.total_half_day
        )

    @computed_field
    @property
    def unrecorded_days(self) -> int:
        """Calculate days without attendance record."""
        return max(0, self.total_days - self.total_accounted_days)


class DailyAttendanceRecord(BaseSchema):
    """
    Individual daily attendance record for reports.
    
    Represents a single day's attendance with complete details
    for timeline views and detailed reports.
    """

    date: date = Field(
        ...,
        description="Attendance date",
    )
    day_of_week: str = Field(
        ...,
        description="Day name (Monday, Tuesday, etc.)",
    )
    status: AttendanceStatus = Field(
        ...,
        description="Attendance status",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Check-out time",
    )
    is_late: bool = Field(
        ...,
        description="Late arrival indicator",
    )
    late_minutes: Optional[int] = Field(
        None,
        ge=0,
        description="Minutes late",
    )
    notes: Optional[str] = Field(
        None,
        description="Additional notes or remarks",
    )
    is_holiday: bool = Field(
        default=False,
        description="Whether day was a holiday",
    )
    is_weekend: bool = Field(
        default=False,
        description="Whether day was a weekend",
    )

    @computed_field
    @property
    def status_display(self) -> str:
        """Human-readable status display."""
        return self.status.value.replace("_", " ").title()


class WeeklyAttendance(BaseSchema):
    """
    Weekly attendance aggregation.
    
    Provides week-level summary for trend analysis and reporting.
    """

    week_number: int = Field(
        ...,
        ge=1,
        le=53,
        description="Week number in year (ISO week)",
    )
    year: int = Field(
        ...,
        ge=2000,
        description="Year for the week",
    )
    week_start_date: date = Field(
        ...,
        description="Monday of the week",
    )
    week_end_date: date = Field(
        ...,
        description="Sunday of the week",
    )
    total_days: int = Field(
        ...,
        ge=0,
        le=7,
        description="Total working days in week",
    )
    present_days: int = Field(
        ...,
        ge=0,
        description="Days present",
    )
    absent_days: int = Field(
        ...,
        ge=0,
        description="Days absent",
    )
    late_days: int = Field(
        default=0,
        ge=0,
        description="Days marked late",
    )
    attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Weekly attendance percentage",
    )

    @field_validator("week_end_date")
    @classmethod
    def validate_week_dates(cls, v: date, info) -> date:
        """Validate week end date is after start date."""
        if "week_start_date" in info.data:
            if v < info.data["week_start_date"]:
                raise ValueError("week_end_date must be after week_start_date")
        return v


class MonthlyComparison(BaseSchema):
    """
    Monthly attendance comparison data.
    
    Used for month-over-month trend analysis and visualizations.
    """

    month: str = Field(
        ...,
        pattern=r"^\d{4}-(0[1-9]|1[0-2])$",
        description="Month in YYYY-MM format",
    )
    month_name: str = Field(
        ...,
        description="Month name (January, February, etc.)",
    )
    year: int = Field(
        ...,
        ge=2000,
        description="Year",
    )
    attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Monthly attendance percentage",
    )
    total_present: int = Field(
        ...,
        ge=0,
        description="Total present days",
    )
    total_absent: int = Field(
        ...,
        ge=0,
        description="Total absent days",
    )
    total_late: int = Field(
        default=0,
        ge=0,
        description="Total late days",
    )
    working_days: int = Field(
        ...,
        ge=0,
        description="Total working days in month",
    )

    @computed_field
    @property
    def trend_indicator(self) -> str:
        """Get trend indicator (up, down, stable) - requires comparison context."""
        # This would typically compare with previous month
        # Placeholder for illustration
        return "stable"


class TrendAnalysis(BaseSchema):
    """
    Attendance trend analysis over time.
    
    Provides insights into attendance patterns, improvements,
    and concerning trends.
    """

    period_start: date = Field(
        ...,
        description="Analysis period start date",
    )
    period_end: date = Field(
        ...,
        description="Analysis period end date",
    )
    
    # Weekly breakdown
    weekly_attendance: List[WeeklyAttendance] = Field(
        default_factory=list,
        description="Week-by-week attendance data",
    )
    
    # Monthly comparison
    monthly_comparison: Optional[List[MonthlyComparison]] = Field(
        None,
        description="Month-by-month comparison data",
    )
    
    # Pattern insights
    most_absent_day: Optional[str] = Field(
        None,
        description="Day of week with most absences",
    )
    most_present_day: Optional[str] = Field(
        None,
        description="Day of week with best attendance",
    )
    average_late_minutes: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average minutes late across period",
    )
    
    # Trend indicators
    attendance_improving: bool = Field(
        ...,
        description="Whether attendance is trending upward",
    )
    improvement_rate: Optional[Decimal] = Field(
        None,
        description="Rate of improvement (percentage points per month)",
    )
    trend_direction: str = Field(
        ...,
        pattern=r"^(improving|declining|stable)$",
        description="Overall trend direction",
    )
    
    # Predictive metrics
    projected_end_of_month_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Projected attendance percentage at month end",
    )

    @field_validator("period_end")
    @classmethod
    def validate_period(cls, v: date, info) -> date:
        """Validate period dates are logical."""
        if "period_start" in info.data:
            if v < info.data["period_start"]:
                raise ValueError("period_end must be after period_start")
        return v


class AttendanceReport(BaseSchema):
    """
    Comprehensive attendance report.
    
    Main report schema combining summary statistics, detailed records,
    and trend analysis.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID (if hostel-specific report)",
    )
    hostel_name: Optional[str] = Field(
        None,
        description="Hostel name",
    )
    student_id: Optional[UUID] = Field(
        None,
        description="Student ID (if student-specific report)",
    )
    student_name: Optional[str] = Field(
        None,
        description="Student name",
    )
    report_period: DateRangeFilter = Field(
        ...,
        description="Report date range",
    )
    generated_at: datetime = Field(
        ...,
        description="Report generation timestamp",
    )
    generated_by: Optional[UUID] = Field(
        None,
        description="User who generated the report",
    )
    
    # Core data
    summary: AttendanceSummary = Field(
        ...,
        description="Aggregated summary statistics",
    )
    daily_records: List[DailyAttendanceRecord] = Field(
        default_factory=list,
        description="Day-by-day attendance records",
    )
    
    # Analysis
    trend_analysis: Optional[TrendAnalysis] = Field(
        None,
        description="Trend analysis and insights",
    )
    
    # Metadata
    report_type: str = Field(
        default="standard",
        pattern=r"^(standard|detailed|summary|comparison)$",
        description="Type of report",
    )
    includes_weekends: bool = Field(
        default=False,
        description="Whether weekends are included",
    )
    includes_holidays: bool = Field(
        default=False,
        description="Whether holidays are included",
    )

    @computed_field
    @property
    def total_days_analyzed(self) -> int:
        """Total days included in analysis."""
        return len(self.daily_records)


class StudentMonthlySummary(BaseSchema):
    """
    Monthly attendance summary for individual student.
    
    Used in monthly reports to show per-student statistics.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Room number",
    )
    email: Optional[str] = Field(
        None,
        description="Student email",
    )
    phone: Optional[str] = Field(
        None,
        description="Student phone",
    )
    total_days: int = Field(
        ...,
        ge=0,
        description="Total working days in month",
    )
    present_days: int = Field(
        ...,
        ge=0,
        description="Days present",
    )
    absent_days: int = Field(
        ...,
        ge=0,
        description="Days absent",
    )
    late_days: int = Field(
        ...,
        ge=0,
        description="Days marked late",
    )
    on_leave_days: int = Field(
        ...,
        ge=0,
        description="Days on leave",
    )
    half_days: int = Field(
        default=0,
        ge=0,
        description="Half-day attendances",
    )
    attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Monthly attendance percentage",
    )
    meets_requirement: bool = Field(
        ...,
        description="Meets minimum attendance requirement",
    )
    
    # Action flags
    requires_attention: bool = Field(
        ...,
        description="Requires supervisor/admin attention",
    )
    action_required: Optional[str] = Field(
        None,
        description="Specific action needed (if any)",
    )
    
    # Additional metrics
    consecutive_absences: int = Field(
        default=0,
        ge=0,
        description="Current consecutive absent days",
    )
    improvement_from_last_month: Optional[Decimal] = Field(
        None,
        description="Percentage point change from last month",
    )

    @computed_field
    @property
    def status_indicator(self) -> str:
        """
        Get status indicator based on attendance.
        
        Returns: excellent, good, warning, or critical
        """
        percentage = float(self.attendance_percentage)
        if percentage >= 95:
            return "excellent"
        elif percentage >= 85:
            return "good"
        elif percentage >= 75:
            return "warning"
        else:
            return "critical"


class MonthlyReport(BaseSchema):
    """
    Comprehensive monthly attendance report for hostel.
    
    Aggregates all students' attendance for a given month with
    hostel-wide statistics.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    month: str = Field(
        ...,
        pattern=r"^\d{4}-(0[1-9]|1[0-2])$",
        description="Month in YYYY-MM format",
    )
    month_name: str = Field(
        ...,
        description="Month name",
    )
    year: int = Field(
        ...,
        ge=2000,
        description="Year",
    )
    working_days: int = Field(
        ...,
        ge=0,
        description="Total working days in month",
    )
    
    # Student summaries
    student_summaries: List[StudentMonthlySummary] = Field(
        ...,
        description="Per-student monthly summaries",
    )
    
    # Hostel-wide statistics
    hostel_average_attendance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average attendance across all students",
    )
    total_students: int = Field(
        ...,
        ge=0,
        description="Total number of students",
    )
    students_meeting_requirement: int = Field(
        ...,
        ge=0,
        description="Students meeting minimum requirement",
    )
    students_below_requirement: int = Field(
        ...,
        ge=0,
        description="Students below minimum requirement",
    )
    students_needing_attention: int = Field(
        default=0,
        ge=0,
        description="Students requiring attention",
    )
    
    # Additional metrics
    total_late_instances: int = Field(
        default=0,
        ge=0,
        description="Total late arrivals across all students",
    )
    average_late_percentage: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Average late percentage",
    )
    
    # Report metadata
    generated_at: datetime = Field(
        ...,
        description="Report generation timestamp",
    )
    generated_by: Optional[UUID] = Field(
        None,
        description="User who generated report",
    )

    @computed_field
    @property
    def compliance_rate(self) -> Decimal:
        """Calculate percentage of students meeting requirements."""
        if self.total_students == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.students_meeting_requirement) / Decimal(self.total_students) * 100,
            2,
        )


class ComparisonItem(BaseSchema):
    """
    Individual item in attendance comparison.
    
    Represents a single entity (student/hostel/room) in comparative analysis.
    """

    entity_id: UUID = Field(
        ...,
        description="Entity unique identifier",
    )
    entity_name: str = Field(
        ...,
        description="Entity name (student/hostel/room name)",
    )
    entity_type: str = Field(
        ...,
        pattern=r"^(student|hostel|room)$",
        description="Type of entity being compared",
    )
    attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Attendance percentage",
    )
    total_present: int = Field(
        ...,
        ge=0,
        description="Total present count",
    )
    total_absent: int = Field(
        ...,
        ge=0,
        description="Total absent count",
    )
    total_days: int = Field(
        ...,
        ge=0,
        description="Total days in comparison period",
    )
    rank: int = Field(
        ...,
        ge=1,
        description="Rank in comparison (1 = best)",
    )
    percentile: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentile ranking",
    )

    @computed_field
    @property
    def performance_indicator(self) -> str:
        """Get performance indicator based on percentile."""
        percentile_float = float(self.percentile)
        if percentile_float >= 90:
            return "top_performer"
        elif percentile_float >= 75:
            return "above_average"
        elif percentile_float >= 50:
            return "average"
        elif percentile_float >= 25:
            return "below_average"
        else:
            return "needs_improvement"


class AttendanceComparison(BaseSchema):
    """
    Comparative attendance analysis across entities.
    
    Enables benchmarking and performance comparison across
    students, hostels, or rooms.
    """

    comparison_type: str = Field(
        ...,
        pattern=r"^(student|hostel|room)$",
        description="Type of entities being compared",
    )
    period: DateRangeFilter = Field(
        ...,
        description="Comparison period",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID (for student/room comparisons)",
    )
    comparisons: List[ComparisonItem] = Field(
        ...,
        min_length=1,
        description="Comparison items sorted by rank",
    )
    
    # Statistical metrics
    average_attendance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Average attendance across all entities",
    )
    median_attendance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Median attendance",
    )
    highest_attendance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Highest attendance percentage",
    )
    lowest_attendance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Lowest attendance percentage",
    )
    standard_deviation: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Standard deviation of attendance",
    )
    
    # Report metadata
    generated_at: datetime = Field(
        ...,
        description="Comparison generation timestamp",
    )

    @field_validator("comparisons")
    @classmethod
    def validate_rankings(cls, v: List[ComparisonItem]) -> List[ComparisonItem]:
        """Validate rankings are sequential."""
        if v:
            ranks = sorted([item.rank for item in v])
            expected_ranks = list(range(1, len(v) + 1))
            if ranks != expected_ranks:
                raise ValueError("Comparison rankings must be sequential from 1")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\attendance_response.py ---
# --- File: app/schemas/attendance/attendance_response.py ---
"""
Attendance response schemas optimized for API responses.

Provides various response formats for attendance data including
detailed, summary, and list views with computed fields.
"""

from __future__ import annotations

from datetime import date, datetime, time
from decimal import Decimal
from typing import Optional

from pydantic import Field, computed_field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import AttendanceMode, AttendanceStatus

__all__ = [
    "AttendanceResponse",
    "AttendanceDetail",
    "AttendanceListItem",
    "DailyAttendanceSummary",
]


class AttendanceResponse(BaseResponseSchema):
    """
    Standard attendance response with essential information.
    
    Lightweight response schema for list views and basic queries.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Student room number",
    )
    attendance_date: date = Field(
        ...,
        description="Date of attendance",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Check-out time",
    )
    status: AttendanceStatus = Field(
        ...,
        description="Attendance status",
    )
    is_late: bool = Field(
        ...,
        description="Late arrival indicator",
    )
    late_minutes: Optional[int] = Field(
        None,
        description="Minutes late (if applicable)",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked attendance",
    )
    marked_by_name: str = Field(
        ...,
        description="Name of user who marked attendance",
    )

    @computed_field
    @property
    def status_display(self) -> str:
        """Human-readable status display."""
        status_map = {
            AttendanceStatus.PRESENT: "Present",
            AttendanceStatus.ABSENT: "Absent",
            AttendanceStatus.LATE: "Late",
            AttendanceStatus.ON_LEAVE: "On Leave",
            AttendanceStatus.HALF_DAY: "Half Day",
        }
        return status_map.get(self.status, self.status.value)


class AttendanceDetail(BaseResponseSchema):
    """
    Detailed attendance information with complete metadata.
    
    Comprehensive response including location data, device info,
    and audit trail for detailed views.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    student_email: str = Field(
        ...,
        description="Student email address",
    )
    student_phone: str = Field(
        ...,
        description="Student phone number",
    )
    room_number: Optional[str] = Field(
        None,
        description="Student room number",
    )
    attendance_date: date = Field(
        ...,
        description="Date of attendance",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Check-out time",
    )
    status: AttendanceStatus = Field(
        ...,
        description="Attendance status",
    )
    is_late: bool = Field(
        ...,
        description="Late arrival indicator",
    )
    late_minutes: Optional[int] = Field(
        None,
        description="Minutes late",
    )
    attendance_mode: AttendanceMode = Field(
        ...,
        description="Method of attendance recording",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked attendance",
    )
    marked_by_name: str = Field(
        ...,
        description="Name of user who marked attendance",
    )
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Supervisor ID who verified",
    )
    supervisor_name: Optional[str] = Field(
        None,
        description="Supervisor name",
    )
    notes: Optional[str] = Field(
        None,
        description="Additional notes",
    )
    location_lat: Optional[Decimal] = Field(
        None,
        description="Latitude (for mobile check-in)",
    )
    location_lng: Optional[Decimal] = Field(
        None,
        description="Longitude (for mobile check-in)",
    )
    device_info: Optional[dict] = Field(
        None,
        description="Device information (for mobile check-in)",
    )
    created_at: datetime = Field(
        ...,
        description="Record creation timestamp",
    )
    updated_at: datetime = Field(
        ...,
        description="Last update timestamp",
    )

    @computed_field
    @property
    def has_location_data(self) -> bool:
        """Check if location data is available."""
        return self.location_lat is not None and self.location_lng is not None

    @computed_field
    @property
    def marking_method(self) -> str:
        """Human-readable marking method."""
        method_map = {
            AttendanceMode.MANUAL: "Manual Entry",
            AttendanceMode.BIOMETRIC: "Biometric System",
            AttendanceMode.QR_CODE: "QR Code Scan",
            AttendanceMode.MOBILE_APP: "Mobile App",
        }
        return method_map.get(self.attendance_mode, self.attendance_mode.value)


class AttendanceListItem(BaseSchema):
    """
    Minimal attendance list item for efficient list rendering.
    
    Optimized for pagination and list views with minimal data transfer.
    """

    id: UUID = Field(
        ...,
        description="Attendance record unique identifier",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Room number",
    )
    attendance_date: date = Field(
        ...,
        description="Attendance date",
    )
    status: AttendanceStatus = Field(
        ...,
        description="Attendance status",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time",
    )
    is_late: bool = Field(
        ...,
        description="Late indicator",
    )
    marked_by_name: str = Field(
        ...,
        description="Marked by user name",
    )

    @computed_field
    @property
    def status_badge_color(self) -> str:
        """
        Get color code for status badge (for UI rendering).
        
        Returns color name/code for frontend styling.
        """
        color_map = {
            AttendanceStatus.PRESENT: "green",
            AttendanceStatus.ABSENT: "red",
            AttendanceStatus.LATE: "orange",
            AttendanceStatus.ON_LEAVE: "blue",
            AttendanceStatus.HALF_DAY: "yellow",
        }
        return color_map.get(self.status, "gray")


class DailyAttendanceSummary(BaseSchema):
    """
    Daily attendance summary with statistics.
    
    Provides aggregated view of daily attendance for a hostel
    with percentage calculations.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    date: date = Field(
        ...,
        description="Attendance date",
    )
    total_students: int = Field(
        ...,
        ge=0,
        description="Total number of students",
    )
    total_present: int = Field(
        ...,
        ge=0,
        description="Number of present students",
    )
    total_absent: int = Field(
        ...,
        ge=0,
        description="Number of absent students",
    )
    total_late: int = Field(
        ...,
        ge=0,
        description="Number of late students",
    )
    total_on_leave: int = Field(
        ...,
        ge=0,
        description="Number of students on leave",
    )
    total_half_day: int = Field(
        default=0,
        ge=0,
        description="Number of half-day attendances",
    )
    attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall attendance percentage",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked attendance",
    )
    marked_by_name: str = Field(
        ...,
        description="Name of user who marked attendance",
    )
    marking_completed: bool = Field(
        ...,
        description="Whether attendance marking is complete",
    )
    marked_at: Optional[datetime] = Field(
        None,
        description="Timestamp when marking was completed",
    )

    @computed_field
    @property
    def pending_students(self) -> int:
        """Calculate number of students with pending attendance."""
        marked = (
            self.total_present
            + self.total_absent
            + self.total_late
            + self.total_on_leave
            + self.total_half_day
        )
        return max(0, self.total_students - marked)

    @computed_field
    @property
    def attendance_status(self) -> str:
        """
        Get attendance quality status based on percentage.
        
        Returns status: excellent, good, average, poor, critical
        """
        percentage = float(self.attendance_percentage)
        if percentage >= 95:
            return "excellent"
        elif percentage >= 85:
            return "good"
        elif percentage >= 75:
            return "average"
        elif percentage >= 60:
            return "poor"
        else:
            return "critical"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\attendance\__init__.py ---
# --- File: app/schemas/attendance/__init__.py ---
"""
Attendance schemas package.

Comprehensive attendance tracking, reporting, and alerting schemas
for hostel management system with enhanced validation and type safety.
"""

from __future__ import annotations

from app.schemas.attendance.attendance_alert import (
    AlertAcknowledgment,
    AlertConfig,
    AlertList,
    AlertSummary,
    AlertTrigger,
    AttendanceAlert,
)
from app.schemas.attendance.attendance_base import (
    AttendanceBase,
    AttendanceCreate,
    AttendanceUpdate,
    BulkAttendanceCreate,
    SingleAttendanceRecord,
)
from app.schemas.attendance.attendance_filters import (
    AttendanceExportRequest,
    AttendanceFilterParams,
    DateRangeRequest,
)
from app.schemas.attendance.attendance_policy import (
    AttendancePolicy,
    PolicyConfig,
    PolicyUpdate,
    PolicyViolation,
)
from app.schemas.attendance.attendance_record import (
    AttendanceCorrection,
    AttendanceRecordRequest,
    BulkAttendanceRequest,
    QuickAttendanceMarkAll,
    StudentAttendanceRecord,
)
from app.schemas.attendance.attendance_report import (
    AttendanceComparison,
    AttendanceReport,
    AttendanceSummary,
    ComparisonItem,
    DailyAttendanceRecord,
    MonthlyComparison,
    MonthlyReport,
    StudentMonthlySummary,
    TrendAnalysis,
    WeeklyAttendance,
)
from app.schemas.attendance.attendance_response import (
    AttendanceDetail,
    AttendanceListItem,
    AttendanceResponse,
    DailyAttendanceSummary,
)

__all__ = [
    # Base schemas
    "AttendanceBase",
    "AttendanceCreate",
    "AttendanceUpdate",
    "BulkAttendanceCreate",
    "SingleAttendanceRecord",
    # Response schemas
    "AttendanceResponse",
    "AttendanceDetail",
    "AttendanceListItem",
    "DailyAttendanceSummary",
    # Recording schemas
    "AttendanceRecordRequest",
    "BulkAttendanceRequest",
    "StudentAttendanceRecord",
    "AttendanceCorrection",
    "QuickAttendanceMarkAll",
    # Report schemas
    "AttendanceReport",
    "AttendanceSummary",
    "DailyAttendanceRecord",
    "TrendAnalysis",
    "WeeklyAttendance",
    "MonthlyComparison",
    "MonthlyReport",
    "StudentMonthlySummary",
    "AttendanceComparison",
    "ComparisonItem",
    # Policy schemas
    "AttendancePolicy",
    "PolicyConfig",
    "PolicyUpdate",
    "PolicyViolation",
    # Alert schemas
    "AttendanceAlert",
    "AlertConfig",
    "AlertTrigger",
    "AlertAcknowledgment",
    "AlertList",
    "AlertSummary",
    # Filter schemas
    "AttendanceFilterParams",
    "DateRangeRequest",
    "AttendanceExportRequest",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\audit =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\audit\admin_override_log.py ---
# --- File: app/schemas/audit/admin_override_log.py ---
"""
Admin override audit log schemas with enhanced tracking.

Tracks admin interventions and overrides of supervisor decisions
for accountability, performance review, and governance.
"""

from datetime import datetime, date
from decimal import Decimal
from typing import Any, Dict, List, Optional

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema
from app.schemas.common.filters import DateTimeRangeFilter

__all__ = [
    "AdminOverrideBase",
    "AdminOverrideCreate",
    "AdminOverrideLogResponse",
    "AdminOverrideDetail",
    "AdminOverrideSummary",
    "AdminOverrideTimelinePoint",
    "AdminOverrideAnalytics",
    "SupervisorImpactAnalysis",
]


class AdminOverrideBase(BaseSchema):
    """
    Base admin override log fields.
    
    Comprehensive tracking of admin interventions in supervisor
    decisions for oversight, accountability, and process improvement.
    """
    
    # Actors
    admin_id: UUID = Field(
        ...,
        description="Admin who performed the override"
    )
    admin_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Admin name (for display)"
    )
    
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Supervisor whose decision was overridden (if applicable)"
    )
    supervisor_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Supervisor name (for display)"
    )
    
    # Context
    hostel_id: UUID = Field(
        ...,
        description="Hostel where the override occurred"
    )
    hostel_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Hostel name (for display)"
    )
    
    # Override details
    override_type: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Type of override (e.g., 'complaint_reassignment', 'maintenance_approval')"
    )
    override_category: str = Field(
        ...,
        pattern="^(decision_reversal|task_reassignment|priority_change|approval|rejection|other)$",
        description="Category of override"
    )
    
    # Entity affected
    entity_type: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Entity type affected (e.g., 'complaint', 'maintenance_request')"
    )
    entity_id: UUID = Field(
        ...,
        description="Primary key of affected entity"
    )
    entity_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Display name of entity"
    )
    
    # Reason and justification
    reason: str = Field(
        ...,
        min_length=10,
        max_length=2000,
        description="Why the admin override was performed"
    )
    justification_category: Optional[str] = Field(
        None,
        pattern="^(quality_issue|policy_violation|emergency|customer_complaint|other)$",
        description="Category of justification"
    )
    
    # Original and override actions
    original_action: Optional[Dict[str, Any]] = Field(
        None,
        description="Snapshot of supervisor's original action/decision"
    )
    override_action: Dict[str, Any] = Field(
        ...,
        description="Admin's override decision and details"
    )
    
    # Impact assessment
    severity: str = Field(
        "medium",
        pattern="^(low|medium|high|critical)$",
        description="Severity/impact of the override"
    )
    urgency: str = Field(
        "normal",
        pattern="^(low|normal|high|urgent)$",
        description="Urgency of the override"
    )
    
    # Notification
    supervisor_notified: bool = Field(
        False,
        description="Whether supervisor was notified"
    )
    notification_sent_at: Optional[datetime] = Field(
        None,
        description="When notification was sent"
    )
    
    # Approval workflow (if override requires approval)
    requires_approval: bool = Field(
        False,
        description="Whether override requires higher approval"
    )
    approved_by: Optional[UUID] = Field(
        None,
        description="Senior admin who approved override"
    )
    approved_at: Optional[datetime] = Field(
        None,
        description="When override was approved"
    )
    
    # Outcome
    outcome: Optional[str] = Field(
        None,
        max_length=500,
        description="Outcome of the override"
    )
    outcome_status: str = Field(
        "pending",
        pattern="^(pending|successful|failed|reversed)$",
        description="Status of override outcome"
    )
    
    # Timestamp
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when override was recorded"
    )
    
    # Follow-up
    follow_up_required: bool = Field(
        False,
        description="Whether follow-up action is required"
    )
    follow_up_completed: Optional[bool] = Field(
        None,
        description="Whether follow-up was completed"
    )
    
    @computed_field
    @property
    def impact_score(self) -> Decimal:
        """
        Calculate impact score (0-100) based on severity and urgency.
        
        Higher score indicates greater impact.
        """
        severity_scores = {
            "low": 25,
            "medium": 50,
            "high": 75,
            "critical": 100,
        }
        
        urgency_multipliers = {
            "low": 0.7,
            "normal": 1.0,
            "high": 1.3,
            "urgent": 1.5,
        }
        
        base_score = severity_scores.get(self.severity, 50)
        multiplier = urgency_multipliers.get(self.urgency, 1.0)
        
        score = min(100, base_score * multiplier)
        return round(Decimal(str(score)), 2)


class AdminOverrideCreate(AdminOverrideBase, BaseCreateSchema):
    """
    Payload for creating new admin override log entries.
    
    Used by services to record admin interventions and
    maintain governance audit trail.
    """
    
    @classmethod
    def for_complaint_override(
        cls,
        admin_id: UUID,
        supervisor_id: UUID,
        hostel_id: UUID,
        complaint_id: UUID,
        reason: str,
        original_action: Dict[str, Any],
        override_action: Dict[str, Any],
        **kwargs
    ) -> "AdminOverrideCreate":
        """
        Factory method for complaint-related overrides.
        
        Args:
            admin_id: Admin performing override
            supervisor_id: Supervisor being overridden
            hostel_id: Hostel context
            complaint_id: Complaint being overridden
            reason: Justification for override
            original_action: Original supervisor action
            override_action: Admin's override action
            **kwargs: Additional fields
            
        Returns:
            AdminOverrideCreate instance
        """
        return cls(
            admin_id=admin_id,
            supervisor_id=supervisor_id,
            hostel_id=hostel_id,
            override_type="complaint_override",
            override_category="decision_reversal",
            entity_type="complaint",
            entity_id=complaint_id,
            reason=reason,
            original_action=original_action,
            override_action=override_action,
            **kwargs
        )


class AdminOverrideLogResponse(BaseResponseSchema):
    """
    List item representation of an admin override log.
    
    Optimized for audit tables and oversight dashboards.
    """
    
    id: UUID = Field(..., description="Override log entry ID")
    
    # Actors
    admin_id: UUID
    admin_name: Optional[str] = None
    
    supervisor_id: Optional[UUID]
    supervisor_name: Optional[str] = None
    
    # Context
    hostel_id: UUID
    hostel_name: Optional[str] = None
    
    # Override details
    override_type: str
    override_category: str
    
    # Entity
    entity_type: str
    entity_id: UUID
    entity_name: Optional[str]
    
    # Reason
    reason: str
    justification_category: Optional[str]
    
    # Impact
    severity: str
    urgency: str
    impact_score: Decimal
    
    # Status
    outcome_status: str
    
    # Timestamp
    created_at: datetime
    
    @computed_field
    @property
    def display_text(self) -> str:
        """Generate display text for UI."""
        parts = []
        
        if self.admin_name:
            parts.append(f"{self.admin_name} overrode")
        else:
            parts.append("Admin overrode")
        
        if self.supervisor_name:
            parts.append(f"{self.supervisor_name}'s")
        
        parts.append(f"{self.override_type}")
        
        if self.entity_name:
            parts.append(f"for {self.entity_name}")
        
        return " ".join(parts)
    
    @computed_field
    @property
    def severity_badge_color(self) -> str:
        """Get color for severity badge."""
        colors = {
            "low": "blue",
            "medium": "yellow",
            "high": "orange",
            "critical": "red",
        }
        return colors.get(self.severity, "gray")


class AdminOverrideDetail(BaseResponseSchema):
    """
    Detailed view of a single admin override entry.
    
    Includes complete information for investigation and review.
    """
    
    id: UUID = Field(..., description="Override log entry ID")
    
    # Actors
    admin_id: UUID
    admin_name: Optional[str] = None
    admin_email: Optional[str] = None
    
    supervisor_id: Optional[UUID]
    supervisor_name: Optional[str] = None
    supervisor_email: Optional[str] = None
    
    # Context
    hostel_id: UUID
    hostel_name: Optional[str] = None
    
    # Override details
    override_type: str
    override_category: str
    
    # Entity
    entity_type: str
    entity_id: UUID
    entity_name: Optional[str]
    
    # Reason and justification
    reason: str
    justification_category: Optional[str]
    
    # Actions
    original_action: Optional[Dict[str, Any]]
    override_action: Dict[str, Any]
    
    # Impact
    severity: str
    urgency: str
    impact_score: Decimal
    
    # Notification
    supervisor_notified: bool
    notification_sent_at: Optional[datetime]
    
    # Approval
    requires_approval: bool
    approved_by: Optional[UUID]
    approved_by_name: Optional[str]
    approved_at: Optional[datetime]
    
    # Outcome
    outcome: Optional[str]
    outcome_status: str
    
    # Follow-up
    follow_up_required: bool
    follow_up_completed: Optional[bool]
    
    # Timestamps
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    @computed_field
    @property
    def is_pending_approval(self) -> bool:
        """Check if override is pending approval."""
        return self.requires_approval and self.approved_at is None
    
    @computed_field
    @property
    def time_to_resolution(self) -> Optional[int]:
        """Calculate hours from creation to outcome completion."""
        if self.outcome_status not in ["successful", "failed"]:
            return None
        
        if not self.updated_at:
            return None
        
        delta = self.updated_at - self.created_at
        return int(delta.total_seconds() / 3600)


class AdminOverrideTimelinePoint(BaseSchema):
    """
    Time-bucketed view of admin overrides.
    
    Aggregates overrides for trend analysis and
    pattern identification.
    """
    
    bucket_label: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Label for time bucket (e.g., '2025-01-15', 'Week 02')"
    )
    bucket_start: datetime = Field(..., description="Bucket start")
    bucket_end: datetime = Field(..., description="Bucket end")
    
    # Counts
    override_count: int = Field(..., ge=0, description="Total overrides")
    
    # By category
    by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Overrides by category"
    )
    
    # By severity
    critical_count: int = Field(0, ge=0)
    high_count: int = Field(0, ge=0)
    medium_count: int = Field(0, ge=0)
    low_count: int = Field(0, ge=0)
    
    # Top supervisors affected
    top_affected_supervisors: List[UUID] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 supervisors with overrides"
    )
    
    # Average impact
    avg_impact_score: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average impact score"
    )
    
    @computed_field
    @property
    def alert_level(self) -> str:
        """Determine alert level based on override volume and severity."""
        if self.critical_count > 0 or self.override_count > 20:
            return "critical"
        elif self.high_count > 3 or self.override_count > 10:
            return "high"
        elif self.override_count > 5:
            return "medium"
        else:
            return "normal"


class SupervisorImpactAnalysis(BaseSchema):
    """
    Analysis of override impact on a specific supervisor.
    
    Tracks how frequently a supervisor's decisions are
    overridden for performance feedback.
    """
    
    supervisor_id: UUID
    supervisor_name: Optional[str] = None
    hostel_id: UUID
    hostel_name: Optional[str] = None
    
    period_start: datetime
    period_end: datetime
    
    # Override metrics
    total_overrides: int = Field(..., ge=0)
    overrides_by_type: Dict[str, int] = Field(default_factory=dict)
    overrides_by_category: Dict[str, int] = Field(default_factory=dict)
    
    # Severity distribution
    critical_overrides: int = Field(0, ge=0)
    high_overrides: int = Field(0, ge=0)
    medium_overrides: int = Field(0, ge=0)
    low_overrides: int = Field(0, ge=0)
    
    # Performance context
    total_decisions_made: int = Field(..., ge=0, description="Total decisions by supervisor")
    override_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of decisions overridden"
    )
    
    # Reasons for overrides
    top_override_reasons: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 reasons for overrides"
    )
    
    # Trend
    trend_direction: Optional[str] = Field(
        None,
        pattern="^(improving|worsening|stable)$",
        description="Trend in override frequency"
    )
    
    # Impact on performance score
    performance_impact_score: Decimal = Field(
        ...,
        decimal_places=2,
        description="Negative impact on performance (-100 to 0)"
    )
    
    @computed_field
    @property
    def override_risk_level(self) -> str:
        """Assess risk level based on override rate."""
        rate = float(self.override_rate)
        
        if rate >= 20:
            return "high"
        elif rate >= 10:
            return "medium"
        elif rate >= 5:
            return "low"
        else:
            return "minimal"
    
    @computed_field
    @property
    def needs_training(self) -> bool:
        """Determine if supervisor needs additional training."""
        return (
            self.override_rate > 15 or
            self.critical_overrides > 2 or
            self.total_overrides > 20
        )


class AdminOverrideSummary(BaseSchema):
    """
    Summary statistics for admin overrides.
    
    Provides aggregated view for oversight dashboards
    and governance reporting.
    """
    
    period_start: datetime
    period_end: datetime
    
    # Scope
    supervisor_id: Optional[UUID] = Field(
        None,
        description="If summarizing overrides for specific supervisor"
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="If summarizing for specific hostel"
    )
    
    # Overall stats
    total_overrides: int = Field(..., ge=0)
    unique_supervisors_affected: int = Field(..., ge=0)
    unique_admins_performing: int = Field(..., ge=0)
    
    # Distribution
    overrides_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="override_type -> count"
    )
    overrides_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="override_category -> count"
    )
    overrides_by_admin: Dict[str, int] = Field(
        default_factory=dict,
        description="admin_id -> count"
    )
    overrides_by_severity: Dict[str, int] = Field(
        default_factory=dict,
        description="severity -> count"
    )
    
    # Performance impact
    override_rate_for_supervisor: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="For a given supervisor: overridden_actions / total_actions"
    )
    
    # Impact analysis
    supervisor_impacts: List[SupervisorImpactAnalysis] = Field(
        default_factory=list,
        description="Impact analysis per supervisor"
    )
    
    # Trends
    trend_direction: str = Field(
        ...,
        pattern="^(increasing|decreasing|stable)$",
        description="Overall trend in override frequency"
    )
    percentage_change: Decimal = Field(
        ...,
        decimal_places=2,
        description="Percentage change vs previous period"
    )
    
    # Timeline
    timeline: List[AdminOverrideTimelinePoint] = Field(
        default_factory=list,
        description="Override activity over time"
    )
    
    @computed_field
    @property
    def most_common_override_type(self) -> Optional[str]:
        """Identify most common override type."""
        if not self.overrides_by_type:
            return None
        return max(self.overrides_by_type, key=self.overrides_by_type.get)
    
    @computed_field
    @property
    def most_overriding_admin(self) -> Optional[str]:
        """Identify admin performing most overrides."""
        if not self.overrides_by_admin:
            return None
        return max(self.overrides_by_admin, key=self.overrides_by_admin.get)


class AdminOverrideAnalytics(BaseSchema):
    """
    Advanced analytics for admin override patterns.
    
    Provides insights for process improvement and
    supervisory training needs identification.
    """
    
    period: DateTimeRangeFilter
    generated_at: datetime = Field(default_factory=datetime.utcnow)
    
    # Summary
    summary: AdminOverrideSummary
    
    # Pattern analysis
    common_patterns: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Identified common override patterns"
    )
    
    # Root cause analysis
    root_causes: Dict[str, int] = Field(
        default_factory=dict,
        description="Root causes of overrides"
    )
    
    # Recommendations
    training_needs: List[str] = Field(
        default_factory=list,
        description="Identified training needs"
    )
    process_improvements: List[str] = Field(
        default_factory=list,
        description="Recommended process improvements"
    )
    
    # Supervisor rankings (by override frequency)
    supervisors_needing_support: List[UUID] = Field(
        default_factory=list,
        description="Supervisors who may need additional support"
    )
    
    @computed_field
    @property
    def overall_health_score(self) -> Decimal:
        """
        Calculate overall health score (0-100).
        
        Lower override rates and severity indicate better health.
        """
        if self.summary.total_overrides == 0:
            return Decimal("100.00")
        
        # Factors
        volume_penalty = min(50, self.summary.total_overrides)
        severity_penalty = (
            self.summary.overrides_by_severity.get("critical", 0) * 10 +
            self.summary.overrides_by_severity.get("high", 0) * 5
        )
        
        total_penalty = min(100, volume_penalty + severity_penalty)
        score = 100 - total_penalty
        
        return round(Decimal(str(max(0, score))), 2)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\audit\all_folders_files_content.txt ---
### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\audit ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\audit =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\audit\admin_override_log.py ---
"""
Admin override audit log schemas
"""
from datetime import datetime
from typing import Any, Dict, List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema


class AdminOverrideBase(BaseSchema):
    """
    Base admin override log fields.

    Mirrors `admin_override_logs` table:
    - admin_id
    - supervisor_id (optional)
    - hostel_id
    - override_type
    - entity_type
    - entity_id
    - reason
    - original_action
    - override_action
    - created_at
    """
    admin_id: UUID = Field(..., description="Admin who performed the override")
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Supervisor whose decision was overridden (if applicable)",
    )
    hostel_id: UUID = Field(..., description="Hostel where the override occurred")

    override_type: str = Field(
        ...,
        max_length=100,
        description="Type of override, e.g. 'complaint_reassignment', 'maintenance_approval'",
    )

    entity_type: str = Field(
        ...,
        max_length=50,
        description="Entity type affected, e.g. 'complaint', 'maintenance_request'",
    )
    entity_id: UUID = Field(..., description="Primary key of affected entity")

    reason: str = Field(
        ...,
        min_length=10,
        max_length=2000,
        description="Why the admin override was performed",
    )

    original_action: Optional[Dict[str, Any]] = Field(
        None,
        description="Snapshot of supervisor's original action/decision",
    )
    override_action: Dict[str, Any] = Field(
        ...,
        description="Admin's override decision, details",
    )

    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when override was recorded",
    )


class AdminOverrideCreate(AdminOverrideBase, BaseCreateSchema):
    """Payload used by services to record a new admin override."""
    pass


class AdminOverrideLogResponse(BaseResponseSchema):
    """
    List item representation of an admin override log.
    Useful for audit tables, supervisor performance review, etc.
    """
    admin_id: UUID
    admin_name: Optional[str] = Field(None, description="Admin display name")

    supervisor_id: Optional[UUID]
    supervisor_name: Optional[str] = Field(None, description="Supervisor display name")

    hostel_id: UUID
    hostel_name: Optional[str] = None

    override_type: str
    entity_type: str
    entity_id: UUID

    reason: str

    created_at: datetime


class AdminOverrideDetail(BaseResponseSchema):
    """
    Detailed view of a single admin override entry,
    including original and override actions.
    """
    admin_id: UUID
    admin_name: Optional[str] = None

    supervisor_id: Optional[UUID]
    supervisor_name: Optional[str] = None

    hostel_id: UUID
    hostel_name: Optional[str] = None

    override_type: str
    entity_type: str
    entity_id: UUID

    reason: str

    original_action: Optional[Dict[str, Any]]
    override_action: Dict[str, Any]

    created_at: datetime


class AdminOverrideSummary(BaseSchema):
    """
    Summary statistics for admin overrides,
    typically for supervisor performance/oversight dashboards.
    """
    period_start: datetime
    period_end: datetime

    # Scope
    supervisor_id: Optional[UUID] = Field(
        None, description="If summarizing overrides for specific supervisor"
    )
    hostel_id: Optional[UUID] = Field(
        None, description="If summarizing for specific hostel"
    )

    # Overall stats
    total_overrides: int = Field(..., ge=0)
    overrides_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="override_type -> count",
    )
    overrides_by_admin: Dict[UUID, int] = Field(
        default_factory=dict,
        description="admin_id -> count",
    )

    # For supervisor perspective
    override_rate_for_supervisor: Optional[float] = Field(
        None,
        description="For a given supervisor: overridden_actions / total_actions",
    )


class AdminOverrideTimelinePoint(BaseSchema):
    """Time-bucketed view of overrides (e.g., by day/week)."""
    bucket_label: str = Field(..., description="e.g. '2025-01-10' or 'Week 02'")
    override_count: int = Field(..., ge=0)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\audit\audit_filters.py ---
"""
Audit log filtering schemas
"""
from datetime import datetime
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import AuditActionCategory, UserRole
from app.schemas.common.filters import DateTimeRangeFilter


class AuditFilterParams(BaseFilterSchema):
    """Filter criteria for querying audit logs"""
    # Actor
    user_id: Optional[UUID] = None
    user_role: Optional[UserRole] = None

    # Hostel
    hostel_id: Optional[UUID] = None

    # Entity
    entity_type: Optional[str] = Field(None, max_length=50)
    entity_id: Optional[UUID] = None

    # Action
    action_type: Optional[str] = Field(None, max_length=100)
    action_category: Optional[AuditActionCategory] = None

    # Time range
    datetime_range: Optional[DateTimeRangeFilter] = None

    # Request ID
    request_id: Optional[str] = None

    # Paging
    page: int = Field(1, ge=1)
    page_size: int = Field(50, ge=1, le=200)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\audit\audit_log_base.py ---
"""
Base schemas for audit log entries
"""
from datetime import datetime
from typing import Optional, Dict, Any
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema
from app.schemas.common.enums import AuditActionCategory, UserRole


class AuditLogBase(BaseSchema):
    """Base audit log entry schema (read model)"""
    user_id: Optional[UUID] = Field(None, description="Actor user ID (if any)")
    user_role: Optional[UserRole] = Field(None, description="Actor role (if known)")

    action_type: str = Field(..., max_length=100, description="Action type identifier")
    action_category: AuditActionCategory = Field(
        AuditActionCategory.OTHER, description="High-level action category"
    )

    entity_type: Optional[str] = Field(
        None, max_length=50, description="Entity type name (e.g. 'Booking', 'Payment')"
    )
    entity_id: Optional[UUID] = Field(None, description="Primary key of affected entity")

    hostel_id: Optional[UUID] = Field(
        None, description="Hostel context (if applicable)"
    )

    description: str = Field(
        ..., max_length=2000, description="Human-readable description of action"
    )

    old_values: Optional[Dict[str, Any]] = Field(
        None, description="Previous values (for update actions)"
    )
    new_values: Optional[Dict[str, Any]] = Field(
        None, description="New values (for update actions)"
    )

    ip_address: Optional[str] = Field(None, description="IP address (if web/API call)")
    user_agent: Optional[str] = Field(None, description="User-Agent string")
    request_id: Optional[str] = Field(
        None, max_length=100, description="Correlation/request ID (for tracing)"
    )

    created_at: datetime = Field(default_factory=datetime.utcnow)


class AuditLogCreate(AuditLogBase, BaseCreateSchema):
    """Payload used by services to create a new audit log entry"""
    pass

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\audit\audit_log_response.py ---
"""
Audit log response schemas
"""
from typing import Optional, Dict, Any
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema
from app.schemas.common.enums import AuditActionCategory, UserRole


class AuditLogResponse(BaseResponseSchema):
    """Audit log list item"""
    user_id: Optional[UUID]
    user_role: Optional[UserRole]

    action_type: str
    action_category: AuditActionCategory

    entity_type: Optional[str]
    entity_id: Optional[UUID]
    hostel_id: Optional[UUID]

    description: str

    ip_address: Optional[str]
    created_at: datetime


class AuditLogDetail(BaseResponseSchema):
    """Detailed audit log with old/new values"""
    user_id: Optional[UUID]
    user_role: Optional[UserRole]

    action_type: str
    action_category: AuditActionCategory

    entity_type: Optional[str]
    entity_id: Optional[UUID]
    hostel_id: Optional[UUID]

    description: str

    old_values: Optional[Dict[str, Any]]
    new_values: Optional[Dict[str, Any]]

    ip_address: Optional[str]
    user_agent: Optional[str]
    request_id: Optional[str]

    created_at: datetime

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\audit\audit_reports.py ---
"""
Audit reporting schemas
"""
from datetime import datetime, date
from typing import List, Dict, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import AuditActionCategory, UserRole
from app.schemas.common.filters import DateRangeFilter


class AuditSummary(BaseSchema):
    """High-level summary for audit log report"""
    period: DateRangeFilter
    total_events: int

    # Distribution
    events_by_category: Dict[AuditActionCategory, int] = Field(default_factory=dict)
    events_by_user_role: Dict[UserRole, int] = Field(default_factory=dict)

    # Top actors
    top_users_by_events: List["UserActivitySummary"] = Field(default_factory=list)


class UserActivitySummary(BaseSchema):
    """Aggregate audit activity for one user"""
    user_id: UUID
    user_name: Optional[str] = None
    user_role: Optional[UserRole] = None

    total_events: int
    events_by_category: Dict[AuditActionCategory, int] = Field(default_factory=dict)


class EntityChangeSummary(BaseSchema):
    """Summary of changes for one entity type"""
    entity_type: str
    change_count: int
    last_change_at: datetime


class EntityChangeRecord(BaseSchema):
    """Single change record for history view"""
    log_id: UUID
    action_type: str
    description: str
    old_values: Optional[dict]
    new_values: Optional[dict]
    changed_by: Optional[UUID]
    changed_by_name: Optional[str]
    changed_at: datetime


class EntityChangeHistory(BaseSchema):
    """Complete change history for a specific entity instance"""
    entity_type: str
    entity_id: UUID
    changes: List[EntityChangeRecord] = Field(default_factory=list)


class AuditReport(BaseSchema):
    """Full audit report response"""
    generated_at: datetime = Field(default_factory=datetime.utcnow)
    period: DateRangeFilter

    summary: AuditSummary
    entity_summaries: List[EntityChangeSummary] = Field(default_factory=list)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\audit\supervisor_activity_log.py ---
"""
Supervisor activity audit log schemas
"""
from datetime import datetime
from typing import Any, Dict, List, Optional

from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema
from app.schemas.common.filters import DateTimeRangeFilter


class SupervisorActivityBase(BaseSchema):
    """
    Base fields for supervisor activity log.

    Mirrors the `supervisor_activity_logs` table:
    - supervisor_id
    - hostel_id
    - action_type
    - action_category
    - entity_type / entity_id
    - action_description
    - metadata
    - ip_address
    - user_agent
    - created_at
    """
    supervisor_id: UUID = Field(..., description="Supervisor performing the action")
    hostel_id: UUID = Field(..., description="Hostel where action occurred")

    action_type: str = Field(
        ...,
        max_length=100,
        description="Action identifier, e.g. 'complaint_resolved', 'attendance_marked'",
    )
    action_category: str = Field(
        ...,
        pattern=(
            r"^(complaint|attendance|maintenance|menu|announcement|"
            r"student_management|other)$"
        ),
        description="High-level category of action",
    )

    entity_type: Optional[str] = Field(
        None, max_length=50, description="Entity type, e.g. 'complaint', 'attendance'"
    )
    entity_id: Optional[UUID] = Field(
        None, description="ID of the entity affected (if applicable)"
    )

    action_description: str = Field(
        ...,
        max_length=2000,
        description="Human-readable description of the action",
    )

    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Extra details/context for the action (JSON)",
    )

    ip_address: Optional[str] = Field(
        None,
        description="IP address from which the action originated (if tracked)",
    )
    user_agent: Optional[str] = Field(
        None,
        description="User-Agent string from supervisor's device (if tracked)",
    )

    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when the action was logged",
    )


class SupervisorActivityCreate(SupervisorActivityBase, BaseCreateSchema):
    """Used by services to record a new supervisor activity log entry."""
    pass


class SupervisorActivityLogResponse(BaseResponseSchema):
    """
    List item representation of supervisor activity log.
    Suitable for tables or basic activity feeds.
    """
    supervisor_id: UUID
    supervisor_name: Optional[str] = Field(
        None, description="Supervisor display name (if joined in query)"
    )
    hostel_id: UUID
    hostel_name: Optional[str] = Field(
        None, description="Hostel display name (if joined in query)"
    )

    action_type: str
    action_category: str

    entity_type: Optional[str]
    entity_id: Optional[UUID]

    action_description: str

    created_at: datetime
    ip_address: Optional[str]
    user_agent: Optional[str]


class SupervisorActivityDetail(BaseResponseSchema):
    """
    Detailed view of a single supervisor activity entry,
    including full metadata.
    """
    supervisor_id: UUID
    supervisor_name: Optional[str] = None
    hostel_id: UUID
    hostel_name: Optional[str] = None

    action_type: str
    action_category: str

    entity_type: Optional[str]
    entity_id: Optional[UUID]

    action_description: str
    metadata: Dict[str, Any]

    ip_address: Optional[str]
    user_agent: Optional[str]
    created_at: datetime


class SupervisorActivityFilter(BaseSchema):
    """
    Filter criteria for querying supervisor activity logs.
    Typically used as a body/query schema for list endpoints.
    """
    supervisor_id: Optional[UUID] = None
    hostel_id: Optional[UUID] = None

    action_type: Optional[str] = Field(None, max_length=100)
    action_category: Optional[str] = Field(
        None,
        pattern=(
            r"^(complaint|attendance|maintenance|menu|announcement|"
            r"student_management|other)$"
        ),
    )

    entity_type: Optional[str] = Field(None, max_length=50)
    entity_id: Optional[UUID] = None

    datetime_range: Optional[DateTimeRangeFilter] = None

    # Pagination
    page: int = Field(1, ge=1)
    page_size: int = Field(50, ge=1, le=200)


class SupervisorActivitySummary(BaseSchema):
    """
    Summary statistics for a supervisor's activity over a period.
    Useful for performance dashboards.
    """
    supervisor_id: UUID
    supervisor_name: Optional[str] = None
    hostel_id: UUID
    hostel_name: Optional[str] = None

    period_start: datetime
    period_end: datetime

    total_actions: int
    actions_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Category -> count",
    )
    actions_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Action type -> count",
    )

    # For trending / charts (optional)
    timeline: List["SupervisorActivityTimelinePoint"] = Field(
        default_factory=list,
        description="Activity over time",
    )


class SupervisorActivityTimelinePoint(BaseSchema):
    """Time-bucketed count of supervisor actions (e.g., daily/weekly)."""
    bucket_label: str = Field(
        ...,
        description="Label for the time bucket (e.g. '2025-01-15', 'Week 12')",
    )
    action_count: int = Field(..., ge=0)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\audit\__init__.py ---
"""
Audit & logging schemas package
"""

from app.schemas.audit.audit_log_base import (
    AuditLogBase,
    AuditLogCreate,
)
from app.schemas.audit.audit_log_response import (
    AuditLogResponse,
    AuditLogDetail,
)
from app.schemas.audit.audit_filters import (
    AuditFilterParams,
)
from app.schemas.audit.audit_reports import (
    AuditReport,
    AuditSummary,
    UserActivitySummary,
    EntityChangeHistory,
)
from app.schemas.audit.supervisor_activity_log import (
    SupervisorActivityBase,
    SupervisorActivityCreate,
    SupervisorActivityLogResponse,
    SupervisorActivityDetail,
    SupervisorActivityFilter,
    SupervisorActivitySummary,
    SupervisorActivityTimelinePoint,
)

from app.schemas.audit.admin_override_log import (
    AdminOverrideBase,
    AdminOverrideCreate,
    AdminOverrideLogResponse,
    AdminOverrideDetail,
    AdminOverrideSummary,
    AdminOverrideTimelinePoint,
)

__all__ = [
    # Base
    "AuditLogBase",
    "AuditLogCreate",
    # Response
    "AuditLogResponse",
    "AuditLogDetail",
    # Filters
    "AuditFilterParams",
    # Reports
    "AuditReport",
    "AuditSummary",
    "UserActivitySummary",
    "EntityChangeHistory",
    # Supervisor Activity
    "SupervisorActivityBase",
    "SupervisorActivityCreate",
    "SupervisorActivityLogResponse",
    "SupervisorActivityDetail",
    "SupervisorActivityFilter",
    "SupervisorActivitySummary",
    "SupervisorActivityTimelinePoint",
    # Admin Override
    "AdminOverrideBase",
    "AdminOverrideCreate",
    "AdminOverrideLogResponse",
    "AdminOverrideDetail",
    "AdminOverrideSummary",
    "AdminOverrideTimelinePoint",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\audit\audit_filters.py ---
# --- File: app/schemas/audit/audit_filters.py ---
"""
Enhanced audit log filtering schemas with advanced query capabilities.

Provides comprehensive filtering options for audit log queries
including time ranges, actors, entities, actions, and more.
"""

from datetime import datetime, date
from typing import List, Optional
from enum import Enum

from pydantic import Field, field_validator, model_validator, computed_field
from uuid import UUID

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import AuditActionCategory, UserRole
from app.schemas.common.filters import DateTimeRangeFilter

__all__ = [
    "AuditSortField",
    "AuditFilterParams",
    "AuditSearchParams",
    "AuditExportParams",
]


class AuditSortField(str, Enum):
    """Available sort fields for audit logs."""
    
    CREATED_AT = "created_at"
    ACTION_TYPE = "action_type"
    USER_ID = "user_id"
    ENTITY_TYPE = "entity_type"
    STATUS = "status"
    SEVERITY = "severity_level"


class AuditFilterParams(BaseFilterSchema):
    """
    Comprehensive filter criteria for querying audit logs.
    
    Supports filtering by actor, action, entity, time, location,
    and various other dimensions for precise audit queries.
    """
    
    # Actor filters
    user_id: Optional[UUID] = Field(
        None,
        description="Filter by specific user"
    )
    user_ids: Optional[List[UUID]] = Field(
        None,
        max_length=50,
        description="Filter by list of users"
    )
    user_role: Optional[UserRole] = Field(
        None,
        description="Filter by user role"
    )
    user_roles: Optional[List[UserRole]] = Field(
        None,
        max_length=10,
        description="Filter by multiple user roles"
    )
    user_email: Optional[str] = Field(
        None,
        max_length=255,
        description="Filter by user email (partial match)"
    )
    exclude_user_ids: Optional[List[UUID]] = Field(
        None,
        max_length=50,
        description="Exclude specific users"
    )
    
    # Impersonation
    impersonator_id: Optional[UUID] = Field(
        None,
        description="Filter by impersonator"
    )
    include_impersonated: bool = Field(
        True,
        description="Include impersonated actions"
    )
    
    # Hostel context
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by hostel"
    )
    hostel_ids: Optional[List[UUID]] = Field(
        None,
        max_length=100,
        description="Filter by multiple hostels"
    )
    
    # Entity filters
    entity_type: Optional[str] = Field(
        None,
        max_length=50,
        description="Filter by entity type"
    )
    entity_types: Optional[List[str]] = Field(
        None,
        max_length=20,
        description="Filter by multiple entity types"
    )
    entity_id: Optional[UUID] = Field(
        None,
        description="Filter by specific entity"
    )
    entity_ids: Optional[List[UUID]] = Field(
        None,
        max_length=100,
        description="Filter by multiple entities"
    )
    
    # Action filters
    action_type: Optional[str] = Field(
        None,
        max_length=100,
        description="Filter by action type"
    )
    action_types: Optional[List[str]] = Field(
        None,
        max_length=50,
        description="Filter by multiple action types"
    )
    action_category: Optional[AuditActionCategory] = Field(
        None,
        description="Filter by action category"
    )
    action_categories: Optional[List[AuditActionCategory]] = Field(
        None,
        max_length=15,
        description="Filter by multiple categories"
    )
    action_pattern: Optional[str] = Field(
        None,
        max_length=100,
        description="Filter by action type pattern (supports wildcards)"
    )
    
    # Time range filters
    datetime_range: Optional[DateTimeRangeFilter] = Field(
        None,
        description="Filter by datetime range"
    )
    created_after: Optional[datetime] = Field(
        None,
        description="Filter events after this datetime"
    )
    created_before: Optional[datetime] = Field(
        None,
        description="Filter events before this datetime"
    )
    
    # Quick time filters
    last_hours: Optional[int] = Field(
        None,
        ge=1,
        le=720,  # Max 30 days
        description="Filter events in last N hours"
    )
    last_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Filter events in last N days"
    )
    
    # Status filters
    status: Optional[str] = Field(
        None,
        pattern="^(success|failure|partial|pending)$",
        description="Filter by status"
    )
    statuses: Optional[List[str]] = Field(
        None,
        max_length=4,
        description="Filter by multiple statuses"
    )
    only_failures: bool = Field(
        False,
        description="Show only failed actions"
    )
    
    # Severity filters
    severity_level: Optional[str] = Field(
        None,
        pattern="^(critical|high|medium|low|info)$",
        description="Filter by severity level"
    )
    min_severity: Optional[str] = Field(
        None,
        pattern="^(critical|high|medium|low|info)$",
        description="Minimum severity level"
    )
    
    # Security filters
    is_sensitive: Optional[bool] = Field(
        None,
        description="Filter by sensitive data flag"
    )
    requires_review: Optional[bool] = Field(
        None,
        description="Filter by review requirement"
    )
    compliance_tag: Optional[str] = Field(
        None,
        max_length=50,
        description="Filter by compliance tag"
    )
    
    # Network filters
    ip_address: Optional[str] = Field(
        None,
        description="Filter by IP address"
    )
    ip_addresses: Optional[List[str]] = Field(
        None,
        max_length=100,
        description="Filter by multiple IP addresses"
    )
    country_code: Optional[str] = Field(
        None,
        pattern=r"^[A-Z]{2}$",
        description="Filter by country code"
    )
    
    # Device filters
    device_type: Optional[str] = Field(
        None,
        pattern="^(desktop|mobile|tablet|api|system)$",
        description="Filter by device type"
    )
    platform: Optional[str] = Field(
        None,
        max_length=50,
        description="Filter by platform/OS"
    )
    
    # Request context
    request_id: Optional[str] = Field(
        None,
        max_length=100,
        description="Filter by request ID"
    )
    session_id: Optional[str] = Field(
        None,
        max_length=100,
        description="Filter by session ID"
    )
    
    # Change filters
    has_changes: Optional[bool] = Field(
        None,
        description="Filter by presence of value changes"
    )
    changed_field: Optional[str] = Field(
        None,
        max_length=100,
        description="Filter by specific changed field"
    )
    
    # Search
    search_query: Optional[str] = Field(
        None,
        min_length=1,
        max_length=500,
        description="Full-text search in descriptions"
    )
    
    # Sorting
    sort_by: AuditSortField = Field(
        AuditSortField.CREATED_AT,
        description="Field to sort by"
    )
    sort_order: str = Field(
        "desc",
        pattern="^(asc|desc)$",
        description="Sort order"
    )
    
    # Pagination
    page: int = Field(
        1,
        ge=1,
        description="Page number"
    )
    page_size: int = Field(
        50,
        ge=1,
        le=200,
        description="Items per page"
    )
    
    @model_validator(mode='after')
    def validate_time_filters(self) -> 'AuditFilterParams':
        """Validate time filter combinations."""
        
        time_filters = [
            self.datetime_range,
            self.created_after,
            self.created_before,
            self.last_hours,
            self.last_days
        ]
        
        # Count non-None time filters
        active_filters = sum(1 for f in time_filters if f is not None)
        
        # Can't use both datetime_range and individual datetime filters
        if self.datetime_range and (self.created_after or self.created_before):
            raise ValueError(
                "Cannot use datetime_range with created_after/created_before"
            )
        
        # Can't use both last_hours and last_days
        if self.last_hours and self.last_days:
            raise ValueError(
                "Cannot use both last_hours and last_days"
            )
        
        return self
    
    @model_validator(mode='after')
    def validate_list_filters(self) -> 'AuditFilterParams':
        """Validate that single and list filters aren't both used."""
        
        conflicts = [
            ('user_id', 'user_ids'),
            ('user_role', 'user_roles'),
            ('hostel_id', 'hostel_ids'),
            ('entity_type', 'entity_types'),
            ('entity_id', 'entity_ids'),
            ('action_type', 'action_types'),
            ('action_category', 'action_categories'),
            ('status', 'statuses'),
            ('ip_address', 'ip_addresses'),
        ]
        
        for single, multiple in conflicts:
            if getattr(self, single) and getattr(self, multiple):
                raise ValueError(
                    f"Cannot use both {single} and {multiple} filters"
                )
        
        return self
    
    @computed_field
    @property
    def has_active_filters(self) -> bool:
        """Check if any filters are active."""
        # Exclude pagination and sorting
        exclude_fields = {
            'page', 'page_size', 'sort_by', 'sort_order',
            'include_impersonated', 'only_failures'
        }
        
        for field_name, value in self.model_dump(exclude_unset=True).items():
            if field_name not in exclude_fields and value is not None:
                return True
        
        return False


class AuditSearchParams(BaseFilterSchema):
    """
    Advanced search parameters for audit logs.
    
    Provides text search capabilities with optional filters.
    """
    
    # Search query
    query: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Search query string"
    )
    
    # Search fields
    search_in_description: bool = Field(
        True,
        description="Search in action descriptions"
    )
    search_in_entity_names: bool = Field(
        True,
        description="Search in entity names"
    )
    search_in_user_emails: bool = Field(
        False,
        description="Search in user emails"
    )
    search_in_values: bool = Field(
        False,
        description="Search in old/new values"
    )
    
    # Search options
    case_sensitive: bool = Field(
        False,
        description="Case-sensitive search"
    )
    fuzzy_search: bool = Field(
        False,
        description="Enable fuzzy matching"
    )
    exact_phrase: bool = Field(
        False,
        description="Match exact phrase only"
    )
    
    # Additional filters (subset from AuditFilterParams)
    datetime_range: Optional[DateTimeRangeFilter] = None
    action_category: Optional[AuditActionCategory] = None
    severity_level: Optional[str] = Field(
        None,
        pattern="^(critical|high|medium|low|info)$"
    )
    
    # Results
    page: int = Field(1, ge=1)
    page_size: int = Field(20, ge=1, le=100)


class AuditExportParams(BaseFilterSchema):
    """
    Parameters for exporting audit logs.
    
    Defines export format, filters, and output options.
    """
    
    # Export format
    format: str = Field(
        ...,
        pattern="^(csv|json|xlsx|pdf)$",
        description="Export file format"
    )
    
    # Filters (reuse from AuditFilterParams)
    filters: AuditFilterParams = Field(
        default_factory=AuditFilterParams,
        description="Filter criteria for export"
    )
    
    # Field selection
    include_fields: Optional[List[str]] = Field(
        None,
        max_length=50,
        description="Specific fields to include (if None, include all)"
    )
    exclude_fields: Optional[List[str]] = Field(
        None,
        max_length=50,
        description="Fields to exclude from export"
    )
    
    # Privacy options
    redact_sensitive: bool = Field(
        True,
        description="Redact sensitive data in export"
    )
    mask_ip_addresses: bool = Field(
        False,
        description="Mask IP addresses in export"
    )
    anonymize_users: bool = Field(
        False,
        description="Anonymize user identifiers"
    )
    
    # Output options
    include_summary: bool = Field(
        True,
        description="Include summary statistics"
    )
    include_charts: bool = Field(
        False,
        description="Include charts (for PDF/XLSX)"
    )
    
    # Limits
    max_records: int = Field(
        10000,
        ge=1,
        le=100000,
        description="Maximum records to export"
    )
    
    @model_validator(mode='after')
    def validate_field_selections(self) -> 'AuditExportParams':
        """Validate field inclusion/exclusion."""
        
        if self.include_fields and self.exclude_fields:
            # Check for conflicts
            overlap = set(self.include_fields) & set(self.exclude_fields)
            if overlap:
                raise ValueError(
                    f"Fields cannot be both included and excluded: {overlap}"
                )
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\audit\audit_log_base.py ---
# --- File: app/schemas/audit/audit_log_base.py ---
"""
Base schemas for audit log entries with enhanced validation.

Provides core audit logging functionality for tracking all system actions
including user activities, data changes, and system events with comprehensive
metadata and traceability.
"""

from datetime import datetime
from typing import Any, Dict, Optional
from ipaddress import IPv4Address, IPv6Address, ip_address
import re

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema
from app.schemas.common.enums import AuditActionCategory, UserRole

__all__ = [
    "AuditLogBase",
    "AuditLogCreate",
    "AuditContext",
    "ChangeDetail",
]


class AuditContext(BaseSchema):
    """
    Contextual information for audit events.
    
    Provides additional metadata about the environment
    and circumstances of the audited action.
    """
    
    # Request context
    request_id: Optional[str] = Field(
        None,
        min_length=1,
        max_length=100,
        description="Unique request/trace ID for correlation"
    )
    session_id: Optional[str] = Field(
        None,
        min_length=1,
        max_length=100,
        description="User session identifier"
    )
    
    # Network context
    ip_address: Optional[str] = Field(
        None,
        max_length=45,
        description="IP address (IPv4 or IPv6)"
    )
    user_agent: Optional[str] = Field(
        None,
        max_length=500,
        description="User-Agent string from request"
    )
    
    # Geographic context
    country_code: Optional[str] = Field(
        None,
        pattern=r"^[A-Z]{2}$",
        description="ISO 3166-1 alpha-2 country code"
    )
    region: Optional[str] = Field(
        None,
        max_length=100,
        description="Geographic region/state"
    )
    city: Optional[str] = Field(
        None,
        max_length=100,
        description="City name"
    )
    
    # Device context
    device_type: Optional[str] = Field(
        None,
        pattern="^(desktop|mobile|tablet|api|system)$",
        description="Type of device used"
    )
    platform: Optional[str] = Field(
        None,
        max_length=50,
        description="Operating system/platform"
    )
    
    # API context
    api_version: Optional[str] = Field(
        None,
        max_length=20,
        description="API version used"
    )
    endpoint: Optional[str] = Field(
        None,
        max_length=255,
        description="API endpoint accessed"
    )
    http_method: Optional[str] = Field(
        None,
        pattern="^(GET|POST|PUT|PATCH|DELETE|OPTIONS|HEAD)$",
        description="HTTP method used"
    )
    
    # Additional metadata
    custom_metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional custom metadata"
    )
    
    @field_validator("ip_address")
    @classmethod
    def validate_ip_address(cls, v: Optional[str]) -> Optional[str]:
        """Validate IP address format."""
        if v is None:
            return v
        
        try:
            # This will raise ValueError if invalid
            ip_address(v)
            return v
        except ValueError:
            raise ValueError(f"Invalid IP address format: {v}")
    
    @field_validator("user_agent")
    @classmethod
    def validate_user_agent(cls, v: Optional[str]) -> Optional[str]:
        """Sanitize and validate user agent string."""
        if v is None:
            return v
        
        # Remove control characters and excessive whitespace
        sanitized = re.sub(r'[\x00-\x1F\x7F-\x9F]', '', v)
        sanitized = ' '.join(sanitized.split())
        
        return sanitized[:500]  # Enforce max length
    
    @computed_field
    @property
    def is_mobile(self) -> bool:
        """Determine if request came from mobile device."""
        if not self.user_agent:
            return False
        
        mobile_patterns = [
            r'Mobile', r'Android', r'iPhone', r'iPad',
            r'Windows Phone', r'BlackBerry'
        ]
        
        return any(
            re.search(pattern, self.user_agent, re.IGNORECASE)
            for pattern in mobile_patterns
        )
    
    @computed_field
    @property
    def browser_name(self) -> Optional[str]:
        """Extract browser name from user agent."""
        if not self.user_agent:
            return None
        
        browsers = {
            'Chrome': r'Chrome/[\d.]+',
            'Firefox': r'Firefox/[\d.]+',
            'Safari': r'Safari/[\d.]+',
            'Edge': r'Edg/[\d.]+',
            'Opera': r'Opera/[\d.]+',
        }
        
        for name, pattern in browsers.items():
            if re.search(pattern, self.user_agent, re.IGNORECASE):
                return name
        
        return "Unknown"


class ChangeDetail(BaseSchema):
    """
    Detailed information about a specific field change.
    
    Provides granular tracking of what changed, from what value,
    and to what value for audit trails.
    """
    
    field_name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Name of the field that changed"
    )
    field_type: Optional[str] = Field(
        None,
        max_length=50,
        description="Data type of the field"
    )
    old_value: Optional[Any] = Field(
        None,
        description="Previous value before change"
    )
    new_value: Optional[Any] = Field(
        None,
        description="New value after change"
    )
    change_type: str = Field(
        ...,
        pattern="^(created|updated|deleted|restored)$",
        description="Type of change operation"
    )
    is_sensitive: bool = Field(
        False,
        description="Whether this field contains sensitive data"
    )
    
    @computed_field
    @property
    def has_actual_change(self) -> bool:
        """Check if there's an actual value change."""
        if self.change_type in ['created', 'deleted', 'restored']:
            return True
        return self.old_value != self.new_value
    
    @computed_field
    @property
    def display_value(self) -> str:
        """Get safe display value (masks sensitive data)."""
        if self.is_sensitive:
            return "***REDACTED***"
        
        if self.change_type == "created":
            return f"Created: {self.new_value}"
        elif self.change_type == "deleted":
            return f"Deleted: {self.old_value}"
        elif self.change_type == "restored":
            return f"Restored: {self.new_value}"
        else:
            return f"{self.old_value}  {self.new_value}"


class AuditLogBase(BaseSchema):
    """
    Base audit log entry schema.
    
    Comprehensive audit logging for all system actions with full
    context, change tracking, and metadata support.
    """
    
    # Actor information
    user_id: Optional[UUID] = Field(
        None,
        description="ID of user who performed the action"
    )
    user_role: Optional[UserRole] = Field(
        None,
        description="Role of the user at time of action"
    )
    user_email: Optional[str] = Field(
        None,
        max_length=255,
        description="Email of the user (for reference)"
    )
    impersonator_id: Optional[UUID] = Field(
        None,
        description="ID of user impersonating (if applicable)"
    )
    
    # Action details
    action_type: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Specific action identifier (e.g., 'booking.created')"
    )
    action_category: AuditActionCategory = Field(
        ...,
        description="High-level action category"
    )
    action_description: str = Field(
        ...,
        min_length=1,
        max_length=2000,
        description="Human-readable description of the action"
    )
    
    # Entity information
    entity_type: Optional[str] = Field(
        None,
        min_length=1,
        max_length=50,
        description="Type of entity affected (e.g., 'Booking', 'Payment')"
    )
    entity_id: Optional[UUID] = Field(
        None,
        description="Primary key of the affected entity"
    )
    entity_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Display name/identifier of the entity"
    )
    
    # Related entity (for relationships)
    related_entity_type: Optional[str] = Field(
        None,
        max_length=50,
        description="Type of related entity"
    )
    related_entity_id: Optional[UUID] = Field(
        None,
        description="ID of related entity"
    )
    
    # Organizational context
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel context (if applicable)"
    )
    hostel_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Hostel name for display"
    )
    
    # Change tracking
    old_values: Optional[Dict[str, Any]] = Field(
        None,
        description="Previous values (for update/delete actions)"
    )
    new_values: Optional[Dict[str, Any]] = Field(
        None,
        description="New values (for create/update actions)"
    )
    change_details: Optional[list[ChangeDetail]] = Field(
        None,
        description="Detailed field-level changes"
    )
    
    # Request context
    context: Optional[AuditContext] = Field(
        None,
        description="Contextual information about the action"
    )
    
    # Legacy fields for backward compatibility
    ip_address: Optional[str] = Field(
        None,
        description="IP address (deprecated: use context.ip_address)"
    )
    user_agent: Optional[str] = Field(
        None,
        description="User agent (deprecated: use context.user_agent)"
    )
    request_id: Optional[str] = Field(
        None,
        max_length=100,
        description="Request ID (deprecated: use context.request_id)"
    )
    
    # Status and result
    status: str = Field(
        "success",
        pattern="^(success|failure|partial|pending)$",
        description="Outcome status of the action"
    )
    error_message: Optional[str] = Field(
        None,
        max_length=1000,
        description="Error message if status is failure"
    )
    
    # Timestamps
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When the action occurred"
    )
    
    # Security and compliance
    is_sensitive: bool = Field(
        False,
        description="Whether this log contains sensitive information"
    )
    retention_days: Optional[int] = Field(
        None,
        ge=1,
        description="Number of days to retain this log entry"
    )
    compliance_tags: list[str] = Field(
        default_factory=list,
        description="Compliance framework tags (GDPR, HIPAA, etc.)"
    )
    
    @model_validator(mode='after')
    def validate_change_tracking(self) -> 'AuditLogBase':
        """Validate change tracking fields are consistent."""
        
        # For update actions, we should have old and new values
        if 'update' in self.action_type.lower():
            if self.old_values is None and self.new_values is None:
                # Warning: update action without change tracking
                pass
        
        # For create actions, we should have new values
        if 'create' in self.action_type.lower():
            if self.new_values is None:
                # Warning: create action without new values
                pass
        
        # For delete actions, we should have old values
        if 'delete' in self.action_type.lower():
            if self.old_values is None:
                # Warning: delete action without old values
                pass
        
        return self
    
    @model_validator(mode='after')
    def migrate_legacy_fields(self) -> 'AuditLogBase':
        """Migrate legacy fields to context object."""
        
        # If context doesn't exist but legacy fields do, create context
        if self.context is None and any([
            self.ip_address,
            self.user_agent,
            self.request_id
        ]):
            self.context = AuditContext(
                ip_address=self.ip_address,
                user_agent=self.user_agent,
                request_id=self.request_id
            )
        
        return self
    
    @computed_field
    @property
    def severity_level(self) -> str:
        """
        Determine severity level of the audit event.
        
        Returns:
            'critical', 'high', 'medium', 'low', or 'info'
        """
        critical_actions = [
            'authentication.failed_multiple',
            'authorization.access_denied',
            'user_management.deleted',
            'payment.refunded',
            'configuration.security_changed'
        ]
        
        high_actions = [
            'authentication.login',
            'authentication.logout',
            'user_management.created',
            'user_management.role_changed',
            'payment.created'
        ]
        
        if self.status == 'failure':
            return 'high'
        
        if self.action_type in critical_actions:
            return 'critical'
        
        if self.action_type in high_actions:
            return 'high'
        
        if self.action_category in [
            AuditActionCategory.AUTHENTICATION,
            AuditActionCategory.AUTHORIZATION,
            AuditActionCategory.USER_MANAGEMENT
        ]:
            return 'medium'
        
        return 'low'
    
    @computed_field
    @property
    def requires_review(self) -> bool:
        """Determine if this audit event requires manual review."""
        return (
            self.severity_level in ['critical', 'high'] or
            self.status == 'failure' or
            self.impersonator_id is not None or
            self.is_sensitive
        )
    
    @computed_field
    @property
    def changed_fields(self) -> list[str]:
        """Get list of fields that were changed."""
        if self.change_details:
            return [
                detail.field_name
                for detail in self.change_details
                if detail.has_actual_change
            ]
        
        if self.old_values and self.new_values:
            changed = []
            for key in set(self.old_values.keys()) | set(self.new_values.keys()):
                old = self.old_values.get(key)
                new = self.new_values.get(key)
                if old != new:
                    changed.append(key)
            return changed
        
        return []
    
    def to_log_message(self) -> str:
        """
        Generate structured log message.
        
        Returns:
            Human-readable log message string
        """
        parts = [
            f"[{self.action_category.value.upper()}]",
            f"Action: {self.action_type}",
        ]
        
        if self.user_id:
            parts.append(f"User: {self.user_id}")
        
        if self.entity_type and self.entity_id:
            parts.append(f"Entity: {self.entity_type}#{self.entity_id}")
        
        if self.hostel_id:
            parts.append(f"Hostel: {self.hostel_id}")
        
        parts.append(f"Status: {self.status}")
        
        if self.context and self.context.ip_address:
            parts.append(f"IP: {self.context.ip_address}")
        
        return " | ".join(parts)


class AuditLogCreate(AuditLogBase, BaseCreateSchema):
    """
    Payload for creating new audit log entries.
    
    Used by services and middleware to record audit events
    throughout the application lifecycle.
    """
    
    @classmethod
    def from_request(
        cls,
        action_type: str,
        action_category: AuditActionCategory,
        description: str,
        user_id: Optional[UUID] = None,
        user_role: Optional[UserRole] = None,
        entity_type: Optional[str] = None,
        entity_id: Optional[UUID] = None,
        hostel_id: Optional[UUID] = None,
        old_values: Optional[Dict[str, Any]] = None,
        new_values: Optional[Dict[str, Any]] = None,
        request_context: Optional[Dict[str, Any]] = None,
        **kwargs
    ) -> "AuditLogCreate":
        """
        Factory method to create audit log from request context.
        
        Args:
            action_type: Type of action performed
            action_category: Category of the action
            description: Human-readable description
            user_id: User performing the action
            user_role: User's role
            entity_type: Type of entity affected
            entity_id: ID of entity affected
            hostel_id: Hostel context
            old_values: Previous values
            new_values: New values
            request_context: Request metadata (IP, user agent, etc.)
            **kwargs: Additional fields
            
        Returns:
            AuditLogCreate instance
        """
        context = None
        if request_context:
            context = AuditContext(**request_context)
        
        return cls(
            action_type=action_type,
            action_category=action_category,
            action_description=description,
            user_id=user_id,
            user_role=user_role,
            entity_type=entity_type,
            entity_id=entity_id,
            hostel_id=hostel_id,
            old_values=old_values,
            new_values=new_values,
            context=context,
            **kwargs
        )
    
    @classmethod
    def for_authentication(
        cls,
        user_id: UUID,
        action: str,
        success: bool,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        **kwargs
    ) -> "AuditLogCreate":
        """
        Create audit log for authentication event.
        
        Args:
            user_id: User attempting authentication
            action: Authentication action (login, logout, etc.)
            success: Whether authentication succeeded
            ip_address: IP address of request
            user_agent: User agent string
            **kwargs: Additional fields
            
        Returns:
            AuditLogCreate instance
        """
        context = AuditContext(
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        return cls(
            user_id=user_id,
            action_type=f"authentication.{action}",
            action_category=AuditActionCategory.AUTHENTICATION,
            action_description=f"User {action} {'successful' if success else 'failed'}",
            status="success" if success else "failure",
            context=context,
            **kwargs
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\audit\audit_log_response.py ---
# --- File: app/schemas/audit/audit_log_response.py ---
"""
Audit log response schemas with enhanced presentation.

Provides different views of audit log data for various use cases
including list views, detailed views, and aggregated summaries.
"""

from datetime import datetime
from typing import Any, Dict, List, Optional

from pydantic import Field, computed_field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema
from app.schemas.common.enums import AuditActionCategory, UserRole

__all__ = [
    "AuditLogResponse",
    "AuditLogDetail",
    "AuditLogSummary",
    "AuditLogTimeline",
]


class AuditLogResponse(BaseResponseSchema):
    """
    Audit log list item for tables and lists.
    
    Provides essential information for displaying audit logs
    in list views with minimal data transfer.
    """
    
    # ID fields
    id: UUID = Field(..., description="Audit log entry ID")
    
    # Actor
    user_id: Optional[UUID] = Field(None, description="User who performed action")
    user_email: Optional[str] = Field(None, description="User email")
    user_role: Optional[UserRole] = Field(None, description="User role")
    
    # Action
    action_type: str = Field(..., description="Action type identifier")
    action_category: AuditActionCategory = Field(..., description="Action category")
    action_description: str = Field(..., description="Action description")
    
    # Entity
    entity_type: Optional[str] = Field(None, description="Affected entity type")
    entity_id: Optional[UUID] = Field(None, description="Affected entity ID")
    entity_name: Optional[str] = Field(None, description="Entity display name")
    
    # Context
    hostel_id: Optional[UUID] = Field(None, description="Hostel context")
    hostel_name: Optional[str] = Field(None, description="Hostel name")
    
    # Status
    status: str = Field(..., description="Action status")
    
    # Network
    ip_address: Optional[str] = Field(None, description="Source IP address")
    
    # Timestamps
    created_at: datetime = Field(..., description="When action occurred")
    
    # Security
    is_sensitive: bool = Field(False, description="Contains sensitive data")
    severity_level: Optional[str] = Field(None, description="Severity level")
    
    @computed_field
    @property
    def display_text(self) -> str:
        """Generate display-friendly text for UI."""
        parts = []
        
        if self.user_email:
            parts.append(self.user_email)
        
        parts.append(self.action_description)
        
        if self.entity_name:
            parts.append(f"({self.entity_name})")
        
        return " ".join(parts)
    
    @computed_field
    @property
    def status_badge_color(self) -> str:
        """Get color for status badge in UI."""
        status_colors = {
            "success": "green",
            "failure": "red",
            "partial": "yellow",
            "pending": "blue",
        }
        return status_colors.get(self.status, "gray")
    
    @computed_field
    @property
    def category_icon(self) -> str:
        """Get icon identifier for the action category."""
        icons = {
            AuditActionCategory.AUTHENTICATION: "lock",
            AuditActionCategory.AUTHORIZATION: "shield",
            AuditActionCategory.USER_MANAGEMENT: "users",
            AuditActionCategory.HOSTEL_MANAGEMENT: "building",
            AuditActionCategory.BOOKING: "calendar",
            AuditActionCategory.PAYMENT: "credit-card",
            AuditActionCategory.COMPLAINT: "alert-circle",
            AuditActionCategory.ATTENDANCE: "check-square",
            AuditActionCategory.MAINTENANCE: "tool",
            AuditActionCategory.ANNOUNCEMENT: "megaphone",
            AuditActionCategory.STUDENT_MANAGEMENT: "user-check",
            AuditActionCategory.SUPERVISOR_MANAGEMENT: "user-cog",
            AuditActionCategory.CONFIGURATION: "settings",
            AuditActionCategory.OTHER: "info",
        }
        return icons.get(self.action_category, "info")


class AuditLogDetail(BaseResponseSchema):
    """
    Detailed audit log view with complete information.
    
    Includes all fields and metadata for detailed inspection
    and forensic analysis.
    """
    
    # ID fields
    id: UUID = Field(..., description="Audit log entry ID")
    
    # Actor information
    user_id: Optional[UUID] = Field(None, description="User who performed action")
    user_email: Optional[str] = Field(None, description="User email")
    user_role: Optional[UserRole] = Field(None, description="User role at time of action")
    impersonator_id: Optional[UUID] = Field(
        None,
        description="User impersonating (if applicable)"
    )
    
    # Action details
    action_type: str = Field(..., description="Action type identifier")
    action_category: AuditActionCategory = Field(..., description="Action category")
    action_description: str = Field(..., description="Detailed action description")
    
    # Entity information
    entity_type: Optional[str] = Field(None, description="Affected entity type")
    entity_id: Optional[UUID] = Field(None, description="Affected entity ID")
    entity_name: Optional[str] = Field(None, description="Entity display name")
    
    # Related entity
    related_entity_type: Optional[str] = Field(None, description="Related entity type")
    related_entity_id: Optional[UUID] = Field(None, description="Related entity ID")
    
    # Context
    hostel_id: Optional[UUID] = Field(None, description="Hostel context")
    hostel_name: Optional[str] = Field(None, description="Hostel name")
    
    # Change tracking
    old_values: Optional[Dict[str, Any]] = Field(
        None,
        description="Previous values"
    )
    new_values: Optional[Dict[str, Any]] = Field(
        None,
        description="New values"
    )
    changed_fields: List[str] = Field(
        default_factory=list,
        description="List of fields that changed"
    )
    
    # Request context
    ip_address: Optional[str] = Field(None, description="IP address")
    user_agent: Optional[str] = Field(None, description="User agent string")
    request_id: Optional[str] = Field(None, description="Request/trace ID")
    session_id: Optional[str] = Field(None, description="Session ID")
    
    # Geographic context
    country_code: Optional[str] = Field(None, description="Country code")
    region: Optional[str] = Field(None, description="Region/state")
    city: Optional[str] = Field(None, description="City")
    
    # Device context
    device_type: Optional[str] = Field(None, description="Device type")
    platform: Optional[str] = Field(None, description="Platform/OS")
    browser_name: Optional[str] = Field(None, description="Browser name")
    
    # API context
    api_version: Optional[str] = Field(None, description="API version")
    endpoint: Optional[str] = Field(None, description="API endpoint")
    http_method: Optional[str] = Field(None, description="HTTP method")
    
    # Status and result
    status: str = Field(..., description="Action status")
    error_message: Optional[str] = Field(None, description="Error message if failed")
    
    # Security
    is_sensitive: bool = Field(False, description="Contains sensitive data")
    severity_level: str = Field(..., description="Severity level")
    requires_review: bool = Field(False, description="Requires manual review")
    compliance_tags: List[str] = Field(
        default_factory=list,
        description="Compliance tags"
    )
    
    # Timestamps
    created_at: datetime = Field(..., description="When action occurred")
    
    # Retention
    retention_days: Optional[int] = Field(
        None,
        description="Retention period in days"
    )
    
    @computed_field
    @property
    def change_summary(self) -> Optional[str]:
        """Generate human-readable change summary."""
        if not self.changed_fields:
            return None
        
        if len(self.changed_fields) == 1:
            return f"Changed: {self.changed_fields[0]}"
        elif len(self.changed_fields) <= 3:
            return f"Changed: {', '.join(self.changed_fields)}"
        else:
            first_three = ', '.join(self.changed_fields[:3])
            remaining = len(self.changed_fields) - 3
            return f"Changed: {first_three} and {remaining} more"
    
    @computed_field
    @property
    def location_summary(self) -> Optional[str]:
        """Generate location summary string."""
        parts = []
        if self.city:
            parts.append(self.city)
        if self.region:
            parts.append(self.region)
        if self.country_code:
            parts.append(self.country_code)
        
        return ", ".join(parts) if parts else None
    
    def get_field_change(self, field_name: str) -> Optional[Dict[str, Any]]:
        """
        Get change details for a specific field.
        
        Args:
            field_name: Name of the field
            
        Returns:
            Dictionary with old_value and new_value, or None
        """
        if field_name not in self.changed_fields:
            return None
        
        return {
            "field": field_name,
            "old_value": self.old_values.get(field_name) if self.old_values else None,
            "new_value": self.new_values.get(field_name) if self.new_values else None,
        }


class AuditLogSummary(BaseResponseSchema):
    """
    Aggregated summary of audit logs.
    
    Provides statistical overview for dashboards and reports.
    """
    
    # Time period
    period_start: datetime = Field(..., description="Summary period start")
    period_end: datetime = Field(..., description="Summary period end")
    
    # Scope
    hostel_id: Optional[UUID] = Field(None, description="Hostel scope if applicable")
    user_id: Optional[UUID] = Field(None, description="User scope if applicable")
    
    # Overall metrics
    total_events: int = Field(..., ge=0, description="Total audit events")
    unique_users: int = Field(..., ge=0, description="Number of unique users")
    unique_ip_addresses: int = Field(..., ge=0, description="Number of unique IPs")
    
    # Status breakdown
    successful_actions: int = Field(..., ge=0, description="Successful actions")
    failed_actions: int = Field(..., ge=0, description="Failed actions")
    pending_actions: int = Field(..., ge=0, description="Pending actions")
    
    # Category breakdown
    events_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Event count by category"
    )
    
    # User role breakdown
    events_by_role: Dict[str, int] = Field(
        default_factory=dict,
        description="Event count by user role"
    )
    
    # Top actions
    top_action_types: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Most frequent action types"
    )
    
    # Security metrics
    sensitive_events: int = Field(..., ge=0, description="Events with sensitive data")
    events_requiring_review: int = Field(
        ...,
        ge=0,
        description="Events requiring manual review"
    )
    critical_events: int = Field(..., ge=0, description="Critical severity events")
    high_severity_events: int = Field(..., ge=0, description="High severity events")
    
    # Anomaly indicators
    failed_login_attempts: int = Field(
        0,
        ge=0,
        description="Failed authentication attempts"
    )
    access_denied_count: int = Field(
        0,
        ge=0,
        description="Authorization failures"
    )
    unusual_activity_count: int = Field(
        0,
        ge=0,
        description="Flagged unusual activities"
    )
    
    @computed_field
    @property
    def success_rate(self) -> float:
        """Calculate success rate percentage."""
        if self.total_events == 0:
            return 100.0
        return round(
            (self.successful_actions / self.total_events) * 100,
            2
        )
    
    @computed_field
    @property
    def security_score(self) -> float:
        """
        Calculate security health score (0-100).
        
        Lower is better - indicates fewer security concerns.
        """
        if self.total_events == 0:
            return 100.0
        
        # Negative indicators
        penalties = (
            self.failed_login_attempts * 5 +
            self.access_denied_count * 3 +
            self.unusual_activity_count * 10 +
            self.critical_events * 15
        )
        
        # Normalize to 0-100 scale
        score = max(0, 100 - (penalties / self.total_events * 100))
        return round(score, 2)
    
    @computed_field
    @property
    def requires_attention(self) -> bool:
        """Check if summary indicates issues requiring attention."""
        return (
            self.security_score < 70 or
            self.failed_login_attempts > 10 or
            self.critical_events > 0 or
            self.unusual_activity_count > 5
        )


class AuditLogTimeline(BaseResponseSchema):
    """
    Timeline view of audit events.
    
    Organizes audit logs chronologically for timeline visualizations.
    """
    
    # Time bucket
    timestamp: datetime = Field(..., description="Timeline point timestamp")
    bucket_label: str = Field(..., description="Display label for time bucket")
    
    # Event counts
    event_count: int = Field(..., ge=0, description="Total events in bucket")
    
    # Category breakdown
    categories: Dict[str, int] = Field(
        default_factory=dict,
        description="Event count by category"
    )
    
    # Status breakdown
    successful: int = Field(..., ge=0, description="Successful events")
    failed: int = Field(..., ge=0, description="Failed events")
    
    # Severity
    critical_count: int = Field(0, ge=0, description="Critical events")
    high_count: int = Field(0, ge=0, description="High severity events")
    
    # Notable events (for highlighting)
    notable_events: List[AuditLogResponse] = Field(
        default_factory=list,
        max_length=5,
        description="Up to 5 notable events in this bucket"
    )
    
    @computed_field
    @property
    def severity_indicator(self) -> str:
        """Get overall severity indicator for this time bucket."""
        if self.critical_count > 0:
            return "critical"
        elif self.high_count > 0:
            return "high"
        elif self.failed > self.event_count * 0.1:  # >10% failures
            return "medium"
        else:
            return "normal"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\audit\audit_reports.py ---
# --- File: app/schemas/audit/audit_reports.py ---
"""
Comprehensive audit reporting schemas with advanced analytics.

Provides detailed reporting capabilities for audit logs including
summaries, trends, user activity analysis, and entity change history.
"""

from datetime import datetime, date
from decimal import Decimal
from typing import Any, Dict, List, Optional
from enum import Enum

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import AuditActionCategory, UserRole
from app.schemas.common.filters import DateRangeFilter, DateTimeRangeFilter

__all__ = [
    "ReportFormat",
    "AuditSummary",
    "UserActivitySummary",
    "EntityChangeSummary",
    "EntityChangeRecord",
    "EntityChangeHistory",
    "CategoryAnalytics",
    "ComplianceReport",
    "SecurityAuditReport",
    "AuditReport",
    "AuditTrendAnalysis",
]


class ReportFormat(str, Enum):
    """Available report output formats."""
    
    JSON = "json"
    CSV = "csv"
    XLSX = "xlsx"
    PDF = "pdf"
    HTML = "html"


class CategoryAnalytics(BaseSchema):
    """
    Analytics for a specific audit action category.
    
    Provides detailed metrics and trends for category-level analysis.
    """
    
    category: AuditActionCategory = Field(
        ...,
        description="Action category"
    )
    category_name: Optional[str] = Field(
        None,
        description="Human-readable category name"
    )
    
    # Volume metrics
    total_events: int = Field(
        ...,
        ge=0,
        description="Total events in this category"
    )
    unique_users: int = Field(
        ...,
        ge=0,
        description="Number of unique users in this category"
    )
    unique_entities: int = Field(
        0,
        ge=0,
        description="Number of unique entities affected"
    )
    
    # Status breakdown
    successful_events: int = Field(..., ge=0)
    failed_events: int = Field(..., ge=0)
    pending_events: int = Field(0, ge=0)
    
    # Timing
    avg_events_per_day: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average events per day"
    )
    peak_hour: Optional[int] = Field(
        None,
        ge=0,
        le=23,
        description="Hour of day with most activity (0-23)"
    )
    
    # Top action types in this category
    top_action_types: List[Dict[str, Any]] = Field(
        default_factory=list,
        max_length=10,
        description="Top 10 action types by frequency"
    )
    
    # Trend
    trend_direction: Optional[str] = Field(
        None,
        pattern="^(increasing|decreasing|stable)$",
        description="Trend direction over the period"
    )
    trend_percentage: Optional[Decimal] = Field(
        None,
        decimal_places=2,
        description="Percentage change vs previous period"
    )
    
    @computed_field
    @property
    def success_rate(self) -> Decimal:
        """Calculate success rate percentage."""
        if self.total_events == 0:
            return Decimal("100.00")
        return round(
            (Decimal(self.successful_events) / Decimal(self.total_events)) * 100,
            2
        )
    
    @computed_field
    @property
    def failure_rate(self) -> Decimal:
        """Calculate failure rate percentage."""
        if self.total_events == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.failed_events) / Decimal(self.total_events)) * 100,
            2
        )


class AuditSummary(BaseSchema):
    """
    High-level summary for audit log report.
    
    Provides aggregated statistics and distributions across
    multiple dimensions for executive overview.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Reporting period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Scope
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel scope (None = platform-wide)"
    )
    hostel_name: Optional[str] = Field(
        None,
        description="Hostel name"
    )
    
    # Overall metrics
    total_events: int = Field(
        ...,
        ge=0,
        description="Total audit events in period"
    )
    unique_users: int = Field(
        ...,
        ge=0,
        description="Number of unique users"
    )
    unique_ip_addresses: int = Field(
        0,
        ge=0,
        description="Number of unique IP addresses"
    )
    unique_sessions: int = Field(
        0,
        ge=0,
        description="Number of unique sessions"
    )
    
    # Status distribution
    successful_actions: int = Field(..., ge=0)
    failed_actions: int = Field(..., ge=0)
    pending_actions: int = Field(0, ge=0)
    partial_actions: int = Field(0, ge=0)
    
    # Distribution by category
    events_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Event count by AuditActionCategory"
    )
    category_analytics: List[CategoryAnalytics] = Field(
        default_factory=list,
        description="Detailed analytics per category"
    )
    
    # Distribution by user role
    events_by_user_role: Dict[str, int] = Field(
        default_factory=dict,
        description="Event count by UserRole"
    )
    
    # Distribution by entity type
    events_by_entity_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Event count by entity type"
    )
    
    # Top actors
    top_users_by_events: List["UserActivitySummary"] = Field(
        default_factory=list,
        max_length=10,
        description="Top 10 most active users"
    )
    
    # Security metrics
    critical_events: int = Field(0, ge=0, description="Critical severity events")
    high_severity_events: int = Field(0, ge=0, description="High severity events")
    sensitive_data_events: int = Field(
        0,
        ge=0,
        description="Events involving sensitive data"
    )
    events_requiring_review: int = Field(
        0,
        ge=0,
        description="Events flagged for review"
    )
    
    # Authentication metrics
    login_attempts: int = Field(0, ge=0)
    successful_logins: int = Field(0, ge=0)
    failed_logins: int = Field(0, ge=0)
    
    # Authorization metrics
    access_granted: int = Field(0, ge=0)
    access_denied: int = Field(0, ge=0)
    
    # Geographic distribution
    events_by_country: Dict[str, int] = Field(
        default_factory=dict,
        description="Event count by country code"
    )
    
    # Device distribution
    events_by_device_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Event count by device type"
    )
    
    @computed_field
    @property
    def overall_success_rate(self) -> Decimal:
        """Calculate overall success rate."""
        if self.total_events == 0:
            return Decimal("100.00")
        return round(
            (Decimal(self.successful_actions) / Decimal(self.total_events)) * 100,
            2
        )
    
    @computed_field
    @property
    def login_success_rate(self) -> Decimal:
        """Calculate login success rate."""
        if self.login_attempts == 0:
            return Decimal("100.00")
        return round(
            (Decimal(self.successful_logins) / Decimal(self.login_attempts)) * 100,
            2
        )
    
    @computed_field
    @property
    def authorization_success_rate(self) -> Decimal:
        """Calculate authorization success rate."""
        total_auth = self.access_granted + self.access_denied
        if total_auth == 0:
            return Decimal("100.00")
        return round(
            (Decimal(self.access_granted) / Decimal(total_auth)) * 100,
            2
        )
    
    @computed_field
    @property
    def security_health_score(self) -> Decimal:
        """
        Calculate security health score (0-100).
        
        Higher score indicates better security posture.
        """
        if self.total_events == 0:
            return Decimal("100.00")
        
        # Factors that reduce score
        failure_penalty = (self.failed_actions / self.total_events) * 30
        critical_penalty = (self.critical_events / self.total_events) * 50
        access_denied_penalty = (self.access_denied / max(1, self.total_events)) * 20
        
        total_penalty = min(100, failure_penalty + critical_penalty + access_denied_penalty)
        score = 100 - total_penalty
        
        return round(Decimal(str(max(0, score))), 2)
    
    @computed_field
    @property
    def most_active_category(self) -> Optional[str]:
        """Identify the most active audit category."""
        if not self.events_by_category:
            return None
        return max(self.events_by_category, key=self.events_by_category.get)
    
    @computed_field
    @property
    def requires_attention(self) -> bool:
        """Determine if summary indicates issues requiring attention."""
        return (
            self.security_health_score < 70 or
            self.critical_events > 0 or
            self.events_requiring_review > 10 or
            self.failed_logins > 20
        )


class UserActivitySummary(BaseSchema):
    """
    Aggregate audit activity for one user.
    
    Provides comprehensive view of user's audit trail
    for activity monitoring and investigation.
    """
    
    user_id: UUID = Field(..., description="User identifier")
    user_name: Optional[str] = Field(None, description="User display name")
    user_email: Optional[str] = Field(None, description="User email")
    user_role: Optional[UserRole] = Field(None, description="User role")
    
    # Activity period
    period_start: datetime = Field(..., description="Period start")
    period_end: datetime = Field(..., description="Period end")
    first_activity: Optional[datetime] = Field(
        None,
        description="First activity timestamp in period"
    )
    last_activity: Optional[datetime] = Field(
        None,
        description="Last activity timestamp in period"
    )
    
    # Volume metrics
    total_events: int = Field(..., ge=0, description="Total events by this user")
    total_sessions: int = Field(0, ge=0, description="Number of sessions")
    unique_ip_addresses: int = Field(
        0,
        ge=0,
        description="Number of unique IPs used"
    )
    
    # Activity distribution
    events_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Event count by category"
    )
    events_by_action_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Event count by action type"
    )
    events_by_status: Dict[str, int] = Field(
        default_factory=dict,
        description="Event count by status"
    )
    
    # Entity interactions
    entities_affected: int = Field(
        0,
        ge=0,
        description="Number of unique entities affected"
    )
    entities_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Entity count by type"
    )
    
    # Security metrics
    successful_actions: int = Field(0, ge=0)
    failed_actions: int = Field(0, ge=0)
    sensitive_data_accessed: int = Field(
        0,
        ge=0,
        description="Events involving sensitive data"
    )
    
    # Anomalies
    unusual_activity_count: int = Field(
        0,
        ge=0,
        description="Flagged unusual activities"
    )
    access_denied_count: int = Field(
        0,
        ge=0,
        description="Authorization failures"
    )
    
    # Activity patterns
    most_active_hour: Optional[int] = Field(
        None,
        ge=0,
        le=23,
        description="Hour of day with most activity"
    )
    most_active_day: Optional[str] = Field(
        None,
        description="Day of week with most activity"
    )
    avg_daily_events: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Average events per day"
    )
    
    # Geographic
    countries_accessed_from: List[str] = Field(
        default_factory=list,
        description="Country codes user accessed from"
    )
    
    # Devices
    device_types_used: List[str] = Field(
        default_factory=list,
        description="Device types used"
    )
    
    @computed_field
    @property
    def success_rate(self) -> Decimal:
        """Calculate user's success rate."""
        total = self.successful_actions + self.failed_actions
        if total == 0:
            return Decimal("100.00")
        return round(
            (Decimal(self.successful_actions) / Decimal(total)) * 100,
            2
        )
    
    @computed_field
    @property
    def activity_score(self) -> Decimal:
        """
        Calculate activity score (0-100).
        
        Based on volume and diversity of activities.
        """
        # Volume component (0-50)
        volume_score = min(50, (self.total_events / 100) * 50)
        
        # Diversity component (0-50)
        category_diversity = min(10, len(self.events_by_category)) * 5
        
        score = volume_score + category_diversity
        return round(Decimal(str(min(100, score))), 2)
    
    @computed_field
    @property
    def risk_level(self) -> str:
        """
        Assess user risk level based on activity patterns.
        
        Returns:
            'low', 'medium', 'high', or 'critical'
        """
        risk_score = 0
        
        # Failed actions
        if self.failed_actions > 10:
            risk_score += 2
        
        # Access denied
        if self.access_denied_count > 5:
            risk_score += 3
        
        # Unusual activity
        if self.unusual_activity_count > 0:
            risk_score += 4
        
        # Multiple IPs
        if self.unique_ip_addresses > 5:
            risk_score += 1
        
        # Multiple countries
        if len(self.countries_accessed_from) > 3:
            risk_score += 2
        
        if risk_score >= 8:
            return "critical"
        elif risk_score >= 5:
            return "high"
        elif risk_score >= 3:
            return "medium"
        else:
            return "low"


class EntityChangeSummary(BaseSchema):
    """
    Summary of changes for one entity type.
    
    Provides overview of how frequently entities of a
    specific type are being modified.
    """
    
    entity_type: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Entity type name"
    )
    entity_type_display: Optional[str] = Field(
        None,
        description="Human-readable entity type name"
    )
    
    # Volume
    total_changes: int = Field(
        ...,
        ge=0,
        description="Total change events"
    )
    unique_entities_changed: int = Field(
        ...,
        ge=0,
        description="Number of unique entities modified"
    )
    
    # Change types
    creates: int = Field(0, ge=0, description="Create operations")
    updates: int = Field(0, ge=0, description="Update operations")
    deletes: int = Field(0, ge=0, description="Delete operations")
    restores: int = Field(0, ge=0, description="Restore operations")
    
    # Timing
    last_change_at: Optional[datetime] = Field(
        None,
        description="Timestamp of most recent change"
    )
    first_change_at: Optional[datetime] = Field(
        None,
        description="Timestamp of first change in period"
    )
    avg_changes_per_day: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Average changes per day"
    )
    
    # Most changed entities
    most_changed_entities: List[Dict[str, Any]] = Field(
        default_factory=list,
        max_length=10,
        description="Entities with most changes"
    )
    
    # Most active users
    top_users: List[UUID] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 users modifying this entity type"
    )
    
    @computed_field
    @property
    def change_rate(self) -> Decimal:
        """Calculate average changes per entity."""
        if self.unique_entities_changed == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.total_changes) / Decimal(self.unique_entities_changed),
            2
        )
    
    @computed_field
    @property
    def volatility_score(self) -> Decimal:
        """
        Calculate volatility score (0-100).
        
        Higher score indicates more frequent changes.
        """
        if self.unique_entities_changed == 0:
            return Decimal("0.00")
        
        # Changes per entity
        changes_per_entity = self.total_changes / self.unique_entities_changed
        
        # Normalize to 0-100
        score = min(100, changes_per_entity * 10)
        return round(Decimal(str(score)), 2)


class EntityChangeRecord(BaseSchema):
    """
    Single change record for entity change history.
    
    Represents one modification event in an entity's lifecycle.
    """
    
    log_id: UUID = Field(..., description="Audit log entry ID")
    
    # Action details
    action_type: str = Field(..., description="Action type")
    action_category: AuditActionCategory = Field(..., description="Action category")
    description: str = Field(..., description="Change description")
    
    # Change data
    old_values: Optional[Dict[str, Any]] = Field(
        None,
        description="Previous values"
    )
    new_values: Optional[Dict[str, Any]] = Field(
        None,
        description="New values"
    )
    changed_fields: List[str] = Field(
        default_factory=list,
        description="List of fields that changed"
    )
    
    # Actor
    changed_by: Optional[UUID] = Field(None, description="User who made the change")
    changed_by_name: Optional[str] = Field(None, description="User display name")
    changed_by_role: Optional[UserRole] = Field(None, description="User role")
    
    # Context
    changed_at: datetime = Field(..., description="Change timestamp")
    ip_address: Optional[str] = Field(None, description="IP address")
    request_id: Optional[str] = Field(None, description="Request ID")
    
    # Status
    status: str = Field(..., description="Change status")
    
    @computed_field
    @property
    def change_summary(self) -> str:
        """Generate human-readable change summary."""
        if not self.changed_fields:
            return self.description
        
        field_list = ", ".join(self.changed_fields[:3])
        if len(self.changed_fields) > 3:
            field_list += f" and {len(self.changed_fields) - 3} more"
        
        return f"Changed: {field_list}"
    
    @computed_field
    @property
    def actor_display(self) -> str:
        """Get display string for actor."""
        if self.changed_by_name:
            return self.changed_by_name
        elif self.changed_by:
            return str(self.changed_by)
        else:
            return "System"


class EntityChangeHistory(BaseSchema):
    """
    Complete change history for a specific entity instance.
    
    Provides full audit trail for a single entity showing
    all modifications throughout its lifecycle.
    """
    
    entity_type: str = Field(..., description="Entity type")
    entity_id: UUID = Field(..., description="Entity ID")
    entity_name: Optional[str] = Field(None, description="Entity display name")
    
    # Lifecycle
    created_at: Optional[datetime] = Field(None, description="Entity creation time")
    created_by: Optional[UUID] = Field(None, description="Creator user ID")
    last_modified_at: Optional[datetime] = Field(
        None,
        description="Last modification time"
    )
    last_modified_by: Optional[UUID] = Field(None, description="Last modifier user ID")
    
    # Change records
    total_changes: int = Field(..., ge=0, description="Total number of changes")
    changes: List[EntityChangeRecord] = Field(
        default_factory=list,
        description="Chronological list of changes"
    )
    
    # Statistics
    unique_modifiers: int = Field(
        0,
        ge=0,
        description="Number of unique users who modified this entity"
    )
    fields_modified: List[str] = Field(
        default_factory=list,
        description="List of all fields ever modified"
    )
    
    # Current state
    is_deleted: bool = Field(False, description="Whether entity is deleted")
    deleted_at: Optional[datetime] = Field(None, description="Deletion timestamp")
    deleted_by: Optional[UUID] = Field(None, description="User who deleted")
    
    @computed_field
    @property
    def entity_age_days(self) -> Optional[int]:
        """Calculate entity age in days."""
        if not self.created_at:
            return None
        return (datetime.utcnow() - self.created_at).days
    
    @computed_field
    @property
    def change_frequency(self) -> Optional[Decimal]:
        """Calculate average changes per day."""
        if not self.created_at or self.total_changes == 0:
            return None
        
        age_days = self.entity_age_days or 1
        return round(Decimal(self.total_changes) / Decimal(max(1, age_days)), 2)
    
    def get_field_history(self, field_name: str) -> List[Dict[str, Any]]:
        """
        Get change history for a specific field.
        
        Args:
            field_name: Name of the field
            
        Returns:
            List of changes for that field
        """
        field_changes = []
        
        for change in self.changes:
            if field_name in change.changed_fields:
                field_changes.append({
                    "timestamp": change.changed_at,
                    "old_value": change.old_values.get(field_name) if change.old_values else None,
                    "new_value": change.new_values.get(field_name) if change.new_values else None,
                    "changed_by": change.changed_by,
                })
        
        return field_changes


class ComplianceReport(BaseSchema):
    """
    Compliance-focused audit report.
    
    Provides audit trail information organized for
    regulatory compliance and certification.
    """
    
    period: DateRangeFilter = Field(..., description="Reporting period")
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation time"
    )
    
    # Compliance framework
    framework: str = Field(
        ...,
        max_length=50,
        description="Compliance framework (GDPR, HIPAA, SOC2, etc.)"
    )
    
    # Scope
    hostel_id: Optional[UUID] = None
    scope_description: str = Field(
        ...,
        description="Description of report scope"
    )
    
    # Access control metrics
    authentication_events: int = Field(0, ge=0)
    authorization_events: int = Field(0, ge=0)
    access_violations: int = Field(0, ge=0)
    privileged_access_events: int = Field(0, ge=0)
    
    # Data access metrics
    sensitive_data_access: int = Field(0, ge=0)
    pii_access_events: int = Field(0, ge=0)
    data_export_events: int = Field(0, ge=0)
    data_deletion_events: int = Field(0, ge=0)
    
    # Change management
    configuration_changes: int = Field(0, ge=0)
    user_changes: int = Field(0, ge=0)
    permission_changes: int = Field(0, ge=0)
    
    # Anomalies and incidents
    failed_login_attempts: int = Field(0, ge=0)
    unusual_access_patterns: int = Field(0, ge=0)
    policy_violations: int = Field(0, ge=0)
    security_incidents: int = Field(0, ge=0)
    
    # User activity
    unique_users: int = Field(0, ge=0)
    admin_users_active: int = Field(0, ge=0)
    external_access_count: int = Field(0, ge=0)
    
    # Compliance status
    compliant_events: int = Field(0, ge=0)
    non_compliant_events: int = Field(0, ge=0)
    compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of compliant events"
    )
    
    # Recommendations
    findings: List[str] = Field(
        default_factory=list,
        description="Compliance findings and issues"
    )
    recommendations: List[str] = Field(
        default_factory=list,
        description="Recommended actions"
    )
    
    @computed_field
    @property
    def compliance_grade(self) -> str:
        """Get compliance grade based on compliance rate."""
        rate = float(self.compliance_rate)
        
        if rate >= 99:
            return "A+"
        elif rate >= 95:
            return "A"
        elif rate >= 90:
            return "B"
        elif rate >= 80:
            return "C"
        elif rate >= 70:
            return "D"
        else:
            return "F"
    
    @computed_field
    @property
    def risk_assessment(self) -> str:
        """Assess overall compliance risk."""
        if self.compliance_rate >= 95 and self.security_incidents == 0:
            return "low"
        elif self.compliance_rate >= 85 and self.security_incidents <= 2:
            return "medium"
        elif self.compliance_rate >= 70:
            return "high"
        else:
            return "critical"


class SecurityAuditReport(BaseSchema):
    """
    Security-focused audit report.
    
    Provides detailed security metrics and threat analysis
    based on audit trail data.
    """
    
    period: DateRangeFilter = Field(..., description="Reporting period")
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation time"
    )
    
    # Authentication security
    total_login_attempts: int = Field(0, ge=0)
    successful_logins: int = Field(0, ge=0)
    failed_logins: int = Field(0, ge=0)
    brute_force_attempts: int = Field(0, ge=0)
    compromised_accounts: int = Field(0, ge=0)
    
    # Authorization security
    total_access_attempts: int = Field(0, ge=0)
    unauthorized_access_attempts: int = Field(0, ge=0)
    privilege_escalation_attempts: int = Field(0, ge=0)
    
    # Data security
    sensitive_data_exposures: int = Field(0, ge=0)
    data_exfiltration_attempts: int = Field(0, ge=0)
    suspicious_data_access: int = Field(0, ge=0)
    
    # Threat indicators
    suspicious_ips: List[str] = Field(
        default_factory=list,
        description="IP addresses with suspicious activity"
    )
    suspicious_users: List[UUID] = Field(
        default_factory=list,
        description="Users with suspicious activity"
    )
    anomalous_patterns: int = Field(0, ge=0)
    
    # Security events
    critical_events: int = Field(0, ge=0)
    security_policy_violations: int = Field(0, ge=0)
    configuration_changes: int = Field(0, ge=0)
    
    # Risk metrics
    overall_risk_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall security risk score (0=best, 100=worst)"
    )
    
    # Recommendations
    critical_findings: List[str] = Field(
        default_factory=list,
        description="Critical security findings"
    )
    recommendations: List[str] = Field(
        default_factory=list,
        description="Security recommendations"
    )
    
    @computed_field
    @property
    def threat_level(self) -> str:
        """Assess overall threat level."""
        score = float(self.overall_risk_score)
        
        if score >= 80:
            return "critical"
        elif score >= 60:
            return "high"
        elif score >= 40:
            return "medium"
        elif score >= 20:
            return "low"
        else:
            return "minimal"
    
    @computed_field
    @property
    def login_success_rate(self) -> Decimal:
        """Calculate login success rate."""
        if self.total_login_attempts == 0:
            return Decimal("100.00")
        return round(
            (Decimal(self.successful_logins) / Decimal(self.total_login_attempts)) * 100,
            2
        )


class AuditTrendAnalysis(BaseSchema):
    """
    Trend analysis for audit metrics over time.
    
    Provides time-series data and trend indicators for
    identifying patterns and anomalies.
    """
    
    period: DateRangeFilter = Field(..., description="Analysis period")
    granularity: str = Field(
        ...,
        pattern="^(hourly|daily|weekly|monthly)$",
        description="Time granularity"
    )
    
    # Data points
    data_points: List[Dict[str, Any]] = Field(
        ...,
        description="Time-series data points"
    )
    
    # Trend metrics
    trend_direction: str = Field(
        ...,
        pattern="^(increasing|decreasing|stable)$",
        description="Overall trend direction"
    )
    trend_strength: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Trend strength (0-100)"
    )
    percentage_change: Decimal = Field(
        ...,
        decimal_places=2,
        description="Percentage change over period"
    )
    
    # Statistical metrics
    average_value: Decimal = Field(..., decimal_places=2)
    median_value: Decimal = Field(..., decimal_places=2)
    std_deviation: Decimal = Field(..., ge=0, decimal_places=2)
    
    # Anomalies
    anomaly_count: int = Field(0, ge=0, description="Number of detected anomalies")
    anomaly_dates: List[date] = Field(
        default_factory=list,
        description="Dates with anomalous activity"
    )
    
    # Peak/low points
    peak_value: Decimal = Field(..., description="Highest value in period")
    peak_date: Optional[date] = Field(None, description="Date of peak value")
    low_value: Decimal = Field(..., description="Lowest value in period")
    low_date: Optional[date] = Field(None, description="Date of lowest value")
    
    @computed_field
    @property
    def volatility_score(self) -> Decimal:
        """Calculate volatility score based on standard deviation."""
        if float(self.average_value) == 0:
            return Decimal("0.00")
        
        cv = (float(self.std_deviation) / float(self.average_value)) * 100
        return round(Decimal(str(min(100, cv))), 2)
    
    @computed_field
    @property
    def is_anomalous_period(self) -> bool:
        """Determine if the period shows anomalous patterns."""
        return self.anomaly_count > 0 or self.volatility_score > 50


class AuditReport(BaseSchema):
    """
    Complete comprehensive audit report.
    
    Consolidates all audit analytics into a single
    comprehensive report for executive review.
    """
    
    # Report metadata
    report_id: UUID = Field(default_factory=lambda: UUID(int=0), description="Report ID")
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    generated_by: Optional[UUID] = Field(None, description="User who generated report")
    
    period: DateRangeFilter = Field(..., description="Reporting period")
    
    # Scope
    hostel_id: Optional[UUID] = None
    hostel_name: Optional[str] = None
    scope_description: str = Field(
        "Platform-wide audit report",
        description="Report scope description"
    )
    
    # Core sections
    summary: AuditSummary = Field(..., description="Executive summary")
    entity_summaries: List[EntityChangeSummary] = Field(
        default_factory=list,
        description="Entity change summaries"
    )
    user_activities: List[UserActivitySummary] = Field(
        default_factory=list,
        max_length=50,
        description="User activity summaries"
    )
    
    # Specialized reports
    compliance_report: Optional[ComplianceReport] = Field(
        None,
        description="Compliance report (if applicable)"
    )
    security_report: Optional[SecurityAuditReport] = Field(
        None,
        description="Security audit report"
    )
    
    # Trends
    trends: List[AuditTrendAnalysis] = Field(
        default_factory=list,
        description="Trend analyses"
    )
    
    # Insights
    key_findings: List[str] = Field(
        default_factory=list,
        description="Key findings from the audit"
    )
    recommendations: List[str] = Field(
        default_factory=list,
        description="Recommended actions"
    )
    action_items: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Actionable items with priorities"
    )
    
    # Attachments
    export_formats: List[ReportFormat] = Field(
        default_factory=list,
        description="Available export formats"
    )
    
    @computed_field
    @property
    def executive_summary_text(self) -> str:
        """Generate executive summary text."""
        parts = []
        
        parts.append(
            f"Audit report for period {self.period.start_date} to {self.period.end_date}"
        )
        parts.append(f"Total events: {self.summary.total_events:,}")
        parts.append(
            f"Success rate: {self.summary.overall_success_rate}%"
        )
        
        if self.summary.requires_attention:
            parts.append("  Requires attention: Security or compliance issues detected")
        
        return " | ".join(parts)
    
    @computed_field
    @property
    def overall_health_score(self) -> Decimal:
        """Calculate overall audit health score."""
        scores = [float(self.summary.security_health_score)]
        
        if self.compliance_report:
            scores.append(float(self.compliance_report.compliance_rate))
        
        if self.security_report:
            scores.append(100 - float(self.security_report.overall_risk_score))
        
        avg_score = sum(scores) / len(scores)
        return round(Decimal(str(avg_score)), 2)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\audit\supervisor_activity_log.py ---
# --- File: app/schemas/audit/supervisor_activity_log.py ---
"""
Supervisor activity audit log schemas with enhanced tracking.

Provides comprehensive tracking of supervisor activities including
task management, student interactions, facility oversight, and
performance metrics for accountability and analytics.
"""

from datetime import datetime, date
from decimal import Decimal
from typing import Any, Dict, List, Optional
from enum import Enum

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema
from app.schemas.common.filters import DateTimeRangeFilter

__all__ = [
    "SupervisorActionCategory",
    "SupervisorActivityBase",
    "SupervisorActivityCreate",
    "SupervisorActivityLogResponse",
    "SupervisorActivityDetail",
    "SupervisorActivityFilter",
    "SupervisorActivitySummary",
    "SupervisorActivityTimelinePoint",
    "SupervisorPerformanceMetrics",
    "SupervisorShiftReport",
]


class SupervisorActionCategory(str, Enum):
    """Categories of supervisor actions for classification."""
    
    COMPLAINT = "complaint"
    ATTENDANCE = "attendance"
    MAINTENANCE = "maintenance"
    MENU = "menu"
    ANNOUNCEMENT = "announcement"
    STUDENT_MANAGEMENT = "student_management"
    VISITOR_MANAGEMENT = "visitor_management"
    ROOM_INSPECTION = "room_inspection"
    FACILITY_MANAGEMENT = "facility_management"
    EMERGENCY_RESPONSE = "emergency_response"
    DISCIPLINARY = "disciplinary"
    OTHER = "other"


class SupervisorActivityBase(BaseSchema):
    """
    Base fields for supervisor activity log.
    
    Comprehensive tracking of all supervisor actions for
    accountability, performance monitoring, and audit trails.
    """
    
    # Actor
    supervisor_id: UUID = Field(
        ...,
        description="Supervisor performing the action"
    )
    supervisor_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Supervisor name (for display)"
    )
    
    # Context
    hostel_id: UUID = Field(
        ...,
        description="Hostel where action occurred"
    )
    hostel_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Hostel name (for display)"
    )
    
    # Action details
    action_type: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Specific action identifier (e.g., 'complaint_resolved', 'attendance_marked')"
    )
    action_category: SupervisorActionCategory = Field(
        ...,
        description="High-level category of action"
    )
    action_description: str = Field(
        ...,
        min_length=1,
        max_length=2000,
        description="Human-readable description of the action"
    )
    
    # Entity affected
    entity_type: Optional[str] = Field(
        None,
        max_length=50,
        description="Entity type affected (e.g., 'complaint', 'attendance', 'student')"
    )
    entity_id: Optional[UUID] = Field(
        None,
        description="ID of the entity affected (if applicable)"
    )
    entity_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Display name of affected entity"
    )
    
    # Related entities (for complex actions)
    related_student_id: Optional[UUID] = Field(
        None,
        description="Student involved in the action"
    )
    related_room_id: Optional[UUID] = Field(
        None,
        description="Room involved in the action"
    )
    
    # Action outcome
    status: str = Field(
        "completed",
        pattern="^(completed|pending|failed|cancelled)$",
        description="Status of the action"
    )
    outcome: Optional[str] = Field(
        None,
        max_length=500,
        description="Brief outcome description"
    )
    
    # Additional data
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Extra details/context for the action (JSON)"
    )
    
    # Performance metrics
    time_taken_minutes: Optional[int] = Field(
        None,
        ge=0,
        description="Time taken to complete the action (minutes)"
    )
    priority_level: Optional[str] = Field(
        None,
        pattern="^(low|medium|high|urgent|critical)$",
        description="Priority level of the action"
    )
    
    # Request context
    ip_address: Optional[str] = Field(
        None,
        max_length=45,
        description="IP address from which the action originated"
    )
    user_agent: Optional[str] = Field(
        None,
        max_length=500,
        description="User-Agent string from supervisor's device"
    )
    device_type: Optional[str] = Field(
        None,
        pattern="^(mobile|tablet|desktop|other)$",
        description="Device type used"
    )
    
    # Location (for field activities)
    location: Optional[str] = Field(
        None,
        max_length=255,
        description="Physical location where action was performed"
    )
    gps_coordinates: Optional[str] = Field(
        None,
        pattern=r"^-?\d+\.\d+,-?\d+\.\d+$",
        description="GPS coordinates (latitude,longitude)"
    )
    
    # Shift context
    shift_id: Optional[UUID] = Field(
        None,
        description="Shift during which action occurred"
    )
    shift_type: Optional[str] = Field(
        None,
        pattern="^(morning|afternoon|evening|night)$",
        description="Type of shift"
    )
    
    # Timestamp
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when the action was logged"
    )
    
    # Quality indicators
    quality_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Quality score for the action (0-5)"
    )
    student_feedback_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Student feedback score (if applicable)"
    )
    
    # Follow-up
    requires_follow_up: bool = Field(
        False,
        description="Whether action requires follow-up"
    )
    follow_up_date: Optional[datetime] = Field(
        None,
        description="When follow-up is due"
    )
    
    @field_validator("time_taken_minutes")
    @classmethod
    def validate_time_taken(cls, v: Optional[int]) -> Optional[int]:
        """Validate time taken is reasonable."""
        if v is not None and v > 1440:  # More than 24 hours
            raise ValueError("time_taken_minutes cannot exceed 1440 (24 hours)")
        return v
    
    @computed_field
    @property
    def efficiency_score(self) -> Optional[Decimal]:
        """
        Calculate efficiency score based on time taken and priority.
        
        Returns:
            Score from 0-100, or None if insufficient data
        """
        if self.time_taken_minutes is None or not self.priority_level:
            return None
        
        # Expected time based on priority
        expected_times = {
            "critical": 15,
            "urgent": 30,
            "high": 60,
            "medium": 120,
            "low": 240,
        }
        
        expected = expected_times.get(self.priority_level, 120)
        
        # Calculate efficiency (100 = exactly on time, >100 = faster, <100 = slower)
        if self.time_taken_minutes == 0:
            return Decimal("100.00")
        
        efficiency = (expected / self.time_taken_minutes) * 100
        return round(Decimal(str(min(100, efficiency))), 2)


class SupervisorActivityCreate(SupervisorActivityBase, BaseCreateSchema):
    """
    Payload for creating new supervisor activity log entries.
    
    Used by services to record supervisor actions throughout
    their shift and activities.
    """
    
    @classmethod
    def for_complaint_action(
        cls,
        supervisor_id: UUID,
        hostel_id: UUID,
        complaint_id: UUID,
        action: str,
        description: str,
        time_taken: Optional[int] = None,
        **kwargs
    ) -> "SupervisorActivityCreate":
        """
        Factory method for complaint-related activities.
        
        Args:
            supervisor_id: Supervisor performing action
            hostel_id: Hostel context
            complaint_id: Complaint being acted upon
            action: Specific action (resolved, assigned, etc.)
            description: Action description
            time_taken: Minutes taken to complete
            **kwargs: Additional fields
            
        Returns:
            SupervisorActivityCreate instance
        """
        return cls(
            supervisor_id=supervisor_id,
            hostel_id=hostel_id,
            action_type=f"complaint.{action}",
            action_category=SupervisorActionCategory.COMPLAINT,
            action_description=description,
            entity_type="complaint",
            entity_id=complaint_id,
            time_taken_minutes=time_taken,
            **kwargs
        )
    
    @classmethod
    def for_attendance_action(
        cls,
        supervisor_id: UUID,
        hostel_id: UUID,
        student_id: UUID,
        action: str,
        description: str,
        **kwargs
    ) -> "SupervisorActivityCreate":
        """
        Factory method for attendance-related activities.
        
        Args:
            supervisor_id: Supervisor performing action
            hostel_id: Hostel context
            student_id: Student whose attendance is recorded
            action: Specific action (marked, verified, etc.)
            description: Action description
            **kwargs: Additional fields
            
        Returns:
            SupervisorActivityCreate instance
        """
        return cls(
            supervisor_id=supervisor_id,
            hostel_id=hostel_id,
            action_type=f"attendance.{action}",
            action_category=SupervisorActionCategory.ATTENDANCE,
            action_description=description,
            entity_type="attendance",
            related_student_id=student_id,
            **kwargs
        )


class SupervisorActivityLogResponse(BaseResponseSchema):
    """
    List item representation of supervisor activity log.
    
    Optimized for tables and activity feeds with essential
    information for quick scanning.
    """
    
    id: UUID = Field(..., description="Activity log entry ID")
    
    # Actor
    supervisor_id: UUID
    supervisor_name: Optional[str] = None
    
    # Context
    hostel_id: UUID
    hostel_name: Optional[str] = None
    
    # Action
    action_type: str
    action_category: SupervisorActionCategory
    action_description: str
    
    # Entity
    entity_type: Optional[str]
    entity_id: Optional[UUID]
    entity_name: Optional[str]
    
    # Status
    status: str
    outcome: Optional[str]
    
    # Metrics
    time_taken_minutes: Optional[int]
    priority_level: Optional[str]
    quality_score: Optional[Decimal]
    
    # Timestamp
    created_at: datetime
    
    # Network
    ip_address: Optional[str]
    device_type: Optional[str]
    
    @computed_field
    @property
    def display_text(self) -> str:
        """Generate display-friendly text."""
        parts = [self.action_description]
        
        if self.time_taken_minutes:
            parts.append(f"({self.time_taken_minutes}m)")
        
        if self.entity_name:
            parts.append(f"- {self.entity_name}")
        
        return " ".join(parts)
    
    @computed_field
    @property
    def status_color(self) -> str:
        """Get color for status badge."""
        colors = {
            "completed": "green",
            "pending": "yellow",
            "failed": "red",
            "cancelled": "gray",
        }
        return colors.get(self.status, "gray")
    
    @computed_field
    @property
    def priority_badge_color(self) -> str:
        """Get color for priority badge."""
        colors = {
            "critical": "red",
            "urgent": "orange",
            "high": "yellow",
            "medium": "blue",
            "low": "gray",
        }
        return colors.get(self.priority_level or "", "gray")


class SupervisorActivityDetail(BaseResponseSchema):
    """
    Detailed view of a single supervisor activity entry.
    
    Includes all fields and metadata for comprehensive
    activity review and investigation.
    """
    
    id: UUID = Field(..., description="Activity log entry ID")
    
    # Actor
    supervisor_id: UUID
    supervisor_name: Optional[str] = None
    supervisor_email: Optional[str] = None
    
    # Context
    hostel_id: UUID
    hostel_name: Optional[str] = None
    
    # Action details
    action_type: str
    action_category: SupervisorActionCategory
    action_description: str
    
    # Entity
    entity_type: Optional[str]
    entity_id: Optional[UUID]
    entity_name: Optional[str]
    
    # Related entities
    related_student_id: Optional[UUID]
    related_student_name: Optional[str]
    related_room_id: Optional[UUID]
    related_room_number: Optional[str]
    
    # Outcome
    status: str
    outcome: Optional[str]
    
    # Metadata
    metadata: Dict[str, Any]
    
    # Performance
    time_taken_minutes: Optional[int]
    priority_level: Optional[str]
    efficiency_score: Optional[Decimal]
    
    # Quality
    quality_score: Optional[Decimal]
    student_feedback_score: Optional[Decimal]
    
    # Request context
    ip_address: Optional[str]
    user_agent: Optional[str]
    device_type: Optional[str]
    
    # Location
    location: Optional[str]
    gps_coordinates: Optional[str]
    
    # Shift context
    shift_id: Optional[UUID]
    shift_type: Optional[str]
    
    # Follow-up
    requires_follow_up: bool
    follow_up_date: Optional[datetime]
    follow_up_completed: Optional[bool] = None
    
    # Timestamps
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if follow-up is overdue."""
        if not self.requires_follow_up or not self.follow_up_date:
            return False
        
        if self.follow_up_completed:
            return False
        
        return datetime.utcnow() > self.follow_up_date
    
    @computed_field
    @property
    def performance_rating(self) -> str:
        """Get overall performance rating for this activity."""
        scores = []
        
        if self.efficiency_score:
            scores.append(float(self.efficiency_score))
        
        if self.quality_score:
            scores.append(float(self.quality_score) * 20)  # Scale to 0-100
        
        if self.student_feedback_score:
            scores.append(float(self.student_feedback_score) * 20)
        
        if not scores:
            return "unknown"
        
        avg_score = sum(scores) / len(scores)
        
        if avg_score >= 90:
            return "excellent"
        elif avg_score >= 75:
            return "good"
        elif avg_score >= 60:
            return "satisfactory"
        elif avg_score >= 40:
            return "needs_improvement"
        else:
            return "poor"


class SupervisorActivityFilter(BaseSchema):
    """
    Filter criteria for querying supervisor activity logs.
    
    Provides comprehensive filtering options for activity
    analysis and reporting.
    """
    
    # Actor filters
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Filter by specific supervisor"
    )
    supervisor_ids: Optional[List[UUID]] = Field(
        None,
        max_length=50,
        description="Filter by multiple supervisors"
    )
    
    # Context filters
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by hostel"
    )
    hostel_ids: Optional[List[UUID]] = Field(
        None,
        max_length=100,
        description="Filter by multiple hostels"
    )
    
    # Action filters
    action_type: Optional[str] = Field(
        None,
        max_length=100,
        description="Filter by action type"
    )
    action_types: Optional[List[str]] = Field(
        None,
        max_length=50,
        description="Filter by multiple action types"
    )
    action_category: Optional[SupervisorActionCategory] = Field(
        None,
        description="Filter by action category"
    )
    action_categories: Optional[List[SupervisorActionCategory]] = Field(
        None,
        max_length=12,
        description="Filter by multiple categories"
    )
    
    # Entity filters
    entity_type: Optional[str] = Field(
        None,
        max_length=50,
        description="Filter by entity type"
    )
    entity_id: Optional[UUID] = Field(
        None,
        description="Filter by specific entity"
    )
    
    # Related entity filters
    related_student_id: Optional[UUID] = Field(
        None,
        description="Filter by student"
    )
    related_room_id: Optional[UUID] = Field(
        None,
        description="Filter by room"
    )
    
    # Status filters
    status: Optional[str] = Field(
        None,
        pattern="^(completed|pending|failed|cancelled)$",
        description="Filter by status"
    )
    statuses: Optional[List[str]] = Field(
        None,
        max_length=4,
        description="Filter by multiple statuses"
    )
    
    # Priority filters
    priority_level: Optional[str] = Field(
        None,
        pattern="^(low|medium|high|urgent|critical)$",
        description="Filter by priority level"
    )
    min_priority: Optional[str] = Field(
        None,
        description="Minimum priority level"
    )
    
    # Time filters
    datetime_range: Optional[DateTimeRangeFilter] = Field(
        None,
        description="Filter by datetime range"
    )
    created_after: Optional[datetime] = Field(
        None,
        description="Filter activities after this datetime"
    )
    created_before: Optional[datetime] = Field(
        None,
        description="Filter activities before this datetime"
    )
    
    # Quick time filters
    last_hours: Optional[int] = Field(
        None,
        ge=1,
        le=168,  # Max 1 week
        description="Filter activities in last N hours"
    )
    today_only: bool = Field(
        False,
        description="Filter today's activities only"
    )
    
    # Shift filters
    shift_id: Optional[UUID] = Field(
        None,
        description="Filter by shift"
    )
    shift_type: Optional[str] = Field(
        None,
        pattern="^(morning|afternoon|evening|night)$",
        description="Filter by shift type"
    )
    
    # Performance filters
    min_quality_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Minimum quality score"
    )
    min_efficiency_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Minimum efficiency score"
    )
    
    # Follow-up filters
    requires_follow_up: Optional[bool] = Field(
        None,
        description="Filter by follow-up requirement"
    )
    overdue_follow_ups: bool = Field(
        False,
        description="Show only overdue follow-ups"
    )
    
    # Search
    search_query: Optional[str] = Field(
        None,
        min_length=1,
        max_length=500,
        description="Search in action descriptions"
    )
    
    # Sorting
    sort_by: str = Field(
        "created_at",
        pattern="^(created_at|priority_level|time_taken|quality_score)$",
        description="Field to sort by"
    )
    sort_order: str = Field(
        "desc",
        pattern="^(asc|desc)$",
        description="Sort order"
    )
    
    # Pagination
    page: int = Field(1, ge=1, description="Page number")
    page_size: int = Field(50, ge=1, le=200, description="Items per page")
    
    @model_validator(mode='after')
    def validate_time_filters(self) -> 'SupervisorActivityFilter':
        """Validate time filter combinations."""
        if self.datetime_range and (self.created_after or self.created_before):
            raise ValueError(
                "Cannot use datetime_range with created_after/created_before"
            )
        return self


class SupervisorActivityTimelinePoint(BaseSchema):
    """
    Time-bucketed view of supervisor activities.
    
    Aggregates activities into time buckets for
    timeline visualizations and trend analysis.
    """
    
    bucket_label: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Label for the time bucket (e.g., '2025-01-15', 'Week 12', '14:00-15:00')"
    )
    bucket_start: datetime = Field(
        ...,
        description="Start of the time bucket"
    )
    bucket_end: datetime = Field(
        ...,
        description="End of the time bucket"
    )
    
    # Activity counts
    action_count: int = Field(
        ...,
        ge=0,
        description="Total actions in this bucket"
    )
    completed_count: int = Field(
        0,
        ge=0,
        description="Completed actions"
    )
    pending_count: int = Field(
        0,
        ge=0,
        description="Pending actions"
    )
    failed_count: int = Field(
        0,
        ge=0,
        description="Failed actions"
    )
    
    # By category
    actions_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Action count by category"
    )
    
    # Performance metrics
    avg_time_taken_minutes: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Average time taken for actions"
    )
    avg_quality_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average quality score"
    )
    
    # Top actions
    top_action_types: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 action types in this bucket"
    )
    
    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate for this bucket."""
        if self.action_count == 0:
            return Decimal("100.00")
        return round(
            (Decimal(self.completed_count) / Decimal(self.action_count)) * 100,
            2
        )
    
    @computed_field
    @property
    def workload_intensity(self) -> str:
        """Assess workload intensity."""
        if self.action_count == 0:
            return "idle"
        elif self.action_count <= 5:
            return "light"
        elif self.action_count <= 15:
            return "moderate"
        elif self.action_count <= 30:
            return "heavy"
        else:
            return "very_heavy"


class SupervisorPerformanceMetrics(BaseSchema):
    """
    Performance metrics calculated from supervisor activities.
    
    Provides aggregated performance data for supervisor
    evaluation and recognition.
    """
    
    supervisor_id: UUID
    supervisor_name: Optional[str] = None
    hostel_id: UUID
    hostel_name: Optional[str] = None
    
    period_start: datetime
    period_end: datetime
    
    # Volume metrics
    total_activities: int = Field(..., ge=0)
    total_shifts_worked: int = Field(0, ge=0)
    total_hours_worked: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Total hours worked in period"
    )
    
    # Activity distribution
    activities_by_category: Dict[str, int] = Field(default_factory=dict)
    activities_by_priority: Dict[str, int] = Field(default_factory=dict)
    
    # Quality metrics
    avg_quality_score: Decimal = Field(
        0,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average quality score"
    )
    avg_student_feedback: Decimal = Field(
        0,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average student feedback score"
    )
    
    # Efficiency metrics
    avg_time_per_task_minutes: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Average time per task"
    )
    avg_efficiency_score: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average efficiency score"
    )
    
    # Completion metrics
    completion_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Task completion rate"
    )
    on_time_completion_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="On-time completion rate"
    )
    
    # Issue resolution
    complaints_handled: int = Field(0, ge=0)
    complaints_resolved: int = Field(0, ge=0)
    avg_complaint_resolution_time_hours: Decimal = Field(
        0,
        ge=0,
        decimal_places=2
    )
    
    # Follow-up tracking
    follow_ups_required: int = Field(0, ge=0)
    follow_ups_completed: int = Field(0, ge=0)
    overdue_follow_ups: int = Field(0, ge=0)
    
    # Attendance tracking
    attendance_records_marked: int = Field(0, ge=0)
    attendance_accuracy_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Attendance marking accuracy"
    )
    
    @computed_field
    @property
    def overall_performance_score(self) -> Decimal:
        """
        Calculate overall performance score (0-100).
        
        Weighted combination of multiple metrics.
        """
        weights = {
            "quality": 0.3,
            "efficiency": 0.25,
            "completion": 0.25,
            "feedback": 0.2,
        }
        
        quality_score = float(self.avg_quality_score) * 20  # Scale to 0-100
        efficiency_score = float(self.avg_efficiency_score)
        completion_score = float(self.completion_rate)
        feedback_score = float(self.avg_student_feedback) * 20
        
        score = (
            quality_score * weights["quality"] +
            efficiency_score * weights["efficiency"] +
            completion_score * weights["completion"] +
            feedback_score * weights["feedback"]
        )
        
        return round(Decimal(str(score)), 2)
    
    @computed_field
    @property
    def performance_grade(self) -> str:
        """Get letter grade for performance."""
        score = float(self.overall_performance_score)
        
        if score >= 90:
            return "A"
        elif score >= 80:
            return "B"
        elif score >= 70:
            return "C"
        elif score >= 60:
            return "D"
        else:
            return "F"
    
    @computed_field
    @property
    def productivity_rate(self) -> Decimal:
        """Calculate tasks per hour worked."""
        if float(self.total_hours_worked) == 0:
            return Decimal("0.00")
        
        rate = self.total_activities / float(self.total_hours_worked)
        return round(Decimal(str(rate)), 2)


class SupervisorActivitySummary(BaseSchema):
    """
    Summary statistics for a supervisor's activity over a period.
    
    Comprehensive overview for performance dashboards and
    supervisor self-assessment.
    """
    
    supervisor_id: UUID
    supervisor_name: Optional[str] = None
    hostel_id: UUID
    hostel_name: Optional[str] = None
    
    period_start: datetime
    period_end: datetime
    
    # Overall stats
    total_actions: int = Field(..., ge=0)
    actions_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Category -> count"
    )
    actions_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Action type -> count"
    )
    actions_by_status: Dict[str, int] = Field(
        default_factory=dict,
        description="Status -> count"
    )
    
    # Performance metrics
    performance_metrics: Optional[SupervisorPerformanceMetrics] = None
    
    # Timeline
    timeline: List[SupervisorActivityTimelinePoint] = Field(
        default_factory=list,
        description="Activity over time"
    )
    
    # Top actions
    top_action_types: List[Dict[str, Any]] = Field(
        default_factory=list,
        max_length=10,
        description="Top 10 action types by frequency"
    )
    
    # Highlights
    peak_activity_hour: Optional[int] = Field(
        None,
        ge=0,
        le=23,
        description="Hour with most activity"
    )
    peak_activity_day: Optional[str] = Field(
        None,
        description="Day of week with most activity"
    )
    busiest_date: Optional[date] = Field(
        None,
        description="Date with most activities"
    )
    
    # Achievements
    high_quality_actions: int = Field(
        0,
        ge=0,
        description="Actions with quality score >= 4.0"
    )
    quick_resolutions: int = Field(
        0,
        ge=0,
        description="Actions completed in < 30 minutes"
    )
    perfect_days: int = Field(
        0,
        ge=0,
        description="Days with 100% completion rate"
    )
    
    @computed_field
    @property
    def avg_daily_actions(self) -> Decimal:
        """Calculate average actions per day."""
        days = (self.period_end - self.period_start).days + 1
        if days == 0:
            return Decimal("0.00")
        
        return round(Decimal(self.total_actions) / Decimal(days), 2)
    
    @computed_field
    @property
    def most_common_action(self) -> Optional[str]:
        """Identify most common action type."""
        if not self.actions_by_type:
            return None
        return max(self.actions_by_type, key=self.actions_by_type.get)


class SupervisorShiftReport(BaseSchema):
    """
    End-of-shift report for supervisor activities.
    
    Summarizes activities performed during a single shift
    for handover and record-keeping.
    """
    
    shift_id: UUID
    supervisor_id: UUID
    supervisor_name: str
    hostel_id: UUID
    hostel_name: str
    
    # Shift details
    shift_type: str = Field(
        ...,
        pattern="^(morning|afternoon|evening|night)$"
    )
    shift_start: datetime
    shift_end: datetime
    shift_duration_hours: Decimal = Field(..., ge=0, decimal_places=2)
    
    # Activities
    total_activities: int = Field(..., ge=0)
    activities_by_category: Dict[str, int] = Field(default_factory=dict)
    completed_activities: int = Field(..., ge=0)
    pending_activities: int = Field(..., ge=0)
    
    # Detailed activity list
    activities: List[SupervisorActivityLogResponse] = Field(
        default_factory=list,
        description="All activities during shift"
    )
    
    # Key events
    critical_incidents: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Critical incidents during shift"
    )
    
    # Handover notes
    handover_notes: Optional[str] = Field(
        None,
        max_length=2000,
        description="Notes for next shift"
    )
    pending_tasks: List[str] = Field(
        default_factory=list,
        description="Tasks to be completed by next shift"
    )
    
    # Performance
    shift_performance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2
    )
    
    # Generated metadata
    generated_at: datetime = Field(default_factory=datetime.utcnow)
    
    @computed_field
    @property
    def productivity_rate(self) -> Decimal:
        """Calculate activities per hour."""
        if float(self.shift_duration_hours) == 0:
            return Decimal("0.00")
        
        rate = self.total_activities / float(self.shift_duration_hours)
        return round(Decimal(str(rate)), 2)
    
    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate."""
        if self.total_activities == 0:
            return Decimal("100.00")
        
        return round(
            (Decimal(self.completed_activities) / Decimal(self.total_activities)) * 100,
            2
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\audit\__init__.py ---
# --- File: app/schemas/audit/__init__.py ---
"""
Audit & logging schemas package.

Comprehensive audit trail and activity logging for:
- System-wide audit logs
- Supervisor activity tracking
- Admin override recording
- Compliance and security reporting
- Performance analytics
"""

# Base audit logs
from app.schemas.audit.audit_log_base import (
    AuditLogBase,
    AuditLogCreate,
    AuditContext,
    ChangeDetail,
)

# Audit responses
from app.schemas.audit.audit_log_response import (
    AuditLogResponse,
    AuditLogDetail,
    AuditLogSummary,
    AuditLogTimeline,
)

# Audit filters
from app.schemas.audit.audit_filters import (
    AuditFilterParams,
    AuditSearchParams,
    AuditExportParams,
    AuditSortField,
)

# Audit reports
from app.schemas.audit.audit_reports import (
    AuditReport,
    AuditSummary,
    UserActivitySummary,
    EntityChangeHistory,
    EntityChangeRecord,
    EntityChangeSummary,
    CategoryAnalytics,
    ComplianceReport,
    SecurityAuditReport,
    AuditTrendAnalysis,
    ReportFormat,
)

# Supervisor activity
from app.schemas.audit.supervisor_activity_log import (
    SupervisorActivityBase,
    SupervisorActivityCreate,
    SupervisorActivityLogResponse,
    SupervisorActivityDetail,
    SupervisorActivityFilter,
    SupervisorActivitySummary,
    SupervisorActivityTimelinePoint,
    SupervisorPerformanceMetrics,
    SupervisorShiftReport,
    SupervisorActionCategory,
)

# Admin overrides
from app.schemas.audit.admin_override_log import (
    AdminOverrideBase,
    AdminOverrideCreate,
    AdminOverrideLogResponse,
    AdminOverrideDetail,
    AdminOverrideSummary,
    AdminOverrideTimelinePoint,
    AdminOverrideAnalytics,
    SupervisorImpactAnalysis,
)

__all__ = [
    # Base audit logs
    "AuditLogBase",
    "AuditLogCreate",
    "AuditContext",
    "ChangeDetail",
    
    # Audit responses
    "AuditLogResponse",
    "AuditLogDetail",
    "AuditLogSummary",
    "AuditLogTimeline",
    
    # Filters and search
    "AuditFilterParams",
    "AuditSearchParams",
    "AuditExportParams",
    "AuditSortField",
    
    # Reports and analytics
    "AuditReport",
    "AuditSummary",
    "UserActivitySummary",
    "EntityChangeHistory",
    "EntityChangeRecord",
    "EntityChangeSummary",
    "CategoryAnalytics",
    "ComplianceReport",
    "SecurityAuditReport",
    "AuditTrendAnalysis",
    "ReportFormat",
    
    # Supervisor activity
    "SupervisorActivityBase",
    "SupervisorActivityCreate",
    "SupervisorActivityLogResponse",
    "SupervisorActivityDetail",
    "SupervisorActivityFilter",
    "SupervisorActivitySummary",
    "SupervisorActivityTimelinePoint",
    "SupervisorPerformanceMetrics",
    "SupervisorShiftReport",
    "SupervisorActionCategory",
    
    # Admin overrides
    "AdminOverrideBase",
    "AdminOverrideCreate",
    "AdminOverrideLogResponse",
    "AdminOverrideDetail",
    "AdminOverrideSummary",
    "AdminOverrideTimelinePoint",
    "AdminOverrideAnalytics",
    "SupervisorImpactAnalysis",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\audit\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\auth =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\auth ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\auth =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\login.py ---
# --- File: app/schemas/auth/login.py ---
"""
Login schemas with enhanced validation and type safety.
"""

from __future__ import annotations

from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import UserRole

__all__ = [
    "LoginRequest",
    "PhoneLoginRequest",
    "TokenData",
    "UserLoginInfo",
    "LoginResponse",
]


class LoginRequest(BaseCreateSchema):
    """
    Email/password-based login request.
    
    Validates email format and password length constraints.
    """

    email: EmailStr = Field(
        ...,
        description="User email address",
        examples=["user@example.com"],
    )
    password: str = Field(
        ...,
        min_length=8,
        max_length=128,
        description="User password",
    )
    remember_me: bool = Field(
        default=False,
        description="Remember user session for extended period",
    )

    @field_validator("password")
    @classmethod
    def validate_password_not_empty(cls, v: str) -> str:
        """Ensure password is not just whitespace."""
        if not v or not v.strip():
            raise ValueError("Password cannot be empty or whitespace")
        return v


class PhoneLoginRequest(BaseCreateSchema):
    """
    Phone-based login request.
    
    Supports international phone numbers in E.164 format.
    """

    phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number (E.164 format recommended)",
        examples=["+919876543210", "9876543210"],
    )
    password: str = Field(
        ...,
        min_length=8,
        max_length=128,
        description="User password",
    )
    remember_me: bool = Field(
        default=False,
        description="Remember user session for extended period",
    )

    @field_validator("phone")
    @classmethod
    def normalize_phone(cls, v: str) -> str:
        """Normalize phone number by removing spaces and dashes."""
        return v.replace(" ", "").replace("-", "")

    @field_validator("password")
    @classmethod
    def validate_password_not_empty(cls, v: str) -> str:
        """Ensure password is not just whitespace."""
        if not v or not v.strip():
            raise ValueError("Password cannot be empty or whitespace")
        return v


class TokenData(BaseSchema):
    """
    Token data embedded in JWT payload.
    
    Contains minimal user identification and context information.
    """

    user_id: UUID = Field(
        ...,
        description="User unique identifier",
    )
    email: str = Field(
        ...,
        description="User email address",
        examples=["user@example.com"],
    )
    role: UserRole = Field(
        ...,
        description="User role for authorization",
    )
    hostel_id: Optional[UUID] = Field(
        default=None,
        description="Active hostel context for multi-hostel admins",
    )


class UserLoginInfo(BaseSchema):
    """
    User information included in login response.
    
    Provides essential user profile data without sensitive information.
    """

    id: UUID = Field(
        ...,
        description="User unique identifier",
    )
    email: str = Field(
        ...,
        description="User email address",
    )
    full_name: str = Field(
        ...,
        description="User full name",
        examples=["John Doe"],
    )
    role: UserRole = Field(
        ...,
        description="User role",
    )
    is_email_verified: bool = Field(
        ...,
        description="Email verification status",
    )
    is_phone_verified: bool = Field(
        ...,
        description="Phone verification status",
    )
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
        examples=["https://example.com/images/profile.jpg"],
    )


class LoginResponse(BaseSchema):
    """
    Login response with JWT tokens and user information.
    
    Follows OAuth 2.0 token response format.
    """

    access_token: str = Field(
        ...,
        description="JWT access token for API authentication",
    )
    refresh_token: str = Field(
        ...,
        description="JWT refresh token for obtaining new access tokens",
    )
    token_type: str = Field(
        default="bearer",
        description="Token type (always 'bearer')",
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="Access token expiration time in seconds",
        examples=[3600],
    )
    user: UserLoginInfo = Field(
        ...,
        description="Authenticated user information",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\otp.py ---
# --- File: app/schemas/auth/otp.py ---
"""
OTP (One-Time Password) schemas with enhanced validation.
"""

from __future__ import annotations

from datetime import datetime
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import OTPType

__all__ = [
    "OTPGenerateRequest",
    "OTPVerifyRequest",
    "OTPResponse",
    "OTPVerifyResponse",
    "ResendOTPRequest",
]


class OTPGenerateRequest(BaseCreateSchema):
    """
    Generate OTP request.
    
    Requires at least one contact method (email or phone).
    """

    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID if authenticated context",
    )
    email: Optional[EmailStr] = Field(
        default=None,
        description="Email address for OTP delivery",
    )
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number for OTP delivery",
    )
    otp_type: OTPType = Field(
        ...,
        description="OTP purpose/type",
    )

    @model_validator(mode="after")
    def validate_contact_method(self) -> "OTPGenerateRequest":
        """
        Ensure at least one contact method is provided.
        
        Raises:
            ValueError: If neither email nor phone is provided.
        """
        if not self.email and not self.phone:
            raise ValueError(
                "At least one contact method (email or phone) must be provided"
            )
        return self

    @field_validator("phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone number by removing spaces and dashes."""
        if v:
            return v.replace(" ", "").replace("-", "")
        return v


class OTPVerifyRequest(BaseCreateSchema):
    """
    Verify OTP request.
    
    Validates OTP code format and ensures contact method is provided.
    """

    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID for verification",
    )
    email: Optional[EmailStr] = Field(
        default=None,
        description="Email address used for OTP generation",
    )
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number used for OTP generation",
    )
    otp_code: str = Field(
        ...,
        min_length=6,
        max_length=6,
        pattern=r"^\d{6}$",
        description="6-digit OTP code",
        examples=["123456"],
    )
    otp_type: OTPType = Field(
        ...,
        description="OTP purpose/type",
    )

    @model_validator(mode="after")
    def validate_contact_method(self) -> "OTPVerifyRequest":
        """Ensure at least one contact method is provided."""
        if not self.email and not self.phone:
            raise ValueError(
                "At least one contact method (email or phone) must be provided"
            )
        return self

    @field_validator("otp_code")
    @classmethod
    def validate_otp_format(cls, v: str) -> str:
        """Ensure OTP is exactly 6 digits."""
        if not v.isdigit():
            raise ValueError("OTP must contain only digits")
        if len(v) != 6:
            raise ValueError("OTP must be exactly 6 digits")
        return v


class OTPResponse(BaseSchema):
    """
    OTP generation response.
    
    Provides masked delivery information and expiration details.
    """

    message: str = Field(
        ...,
        description="Response message",
        examples=["OTP sent successfully"],
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="OTP expiration time in seconds",
        examples=[300],
    )
    sent_to: str = Field(
        ...,
        description="Masked email/phone where OTP was sent",
        examples=["u***@example.com", "+91******3210"],
    )
    otp_type: OTPType = Field(
        ...,
        description="OTP type/purpose",
    )
    max_attempts: int = Field(
        default=3,
        ge=1,
        description="Maximum verification attempts allowed",
    )


class OTPVerifyResponse(BaseSchema):
    """
    OTP verification response.
    
    Indicates verification status and provides related information.
    """

    is_valid: bool = Field(
        ...,
        description="Whether OTP verification was successful",
    )
    message: str = Field(
        ...,
        description="Verification result message",
        examples=["OTP verified successfully", "Invalid or expired OTP"],
    )
    verified_at: Optional[datetime] = Field(
        default=None,
        description="Verification timestamp (UTC)",
    )
    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID associated with verified OTP",
    )
    remaining_attempts: Optional[int] = Field(
        default=None,
        ge=0,
        description="Remaining verification attempts (if failed)",
    )


class ResendOTPRequest(BaseCreateSchema):
    """
    Resend OTP request.
    
    Used when user didn't receive the original OTP.
    """

    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID for OTP resend",
    )
    email: Optional[EmailStr] = Field(
        default=None,
        description="Email address for OTP delivery",
    )
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number for OTP delivery",
    )
    otp_type: OTPType = Field(
        ...,
        description="OTP purpose/type",
    )

    @model_validator(mode="after")
    def validate_contact_method(self) -> "ResendOTPRequest":
        """Ensure at least one contact method is provided."""
        if not self.email and not self.phone:
            raise ValueError(
                "At least one contact method (email or phone) must be provided"
            )
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\password.py ---
# --- File: app/schemas/auth/password.py ---
"""
Password management schemas with robust validation.
"""

from __future__ import annotations

import re
from typing import List
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "PasswordResetRequest",
    "PasswordResetConfirm",
    "PasswordChangeRequest",
    "PasswordChangeResponse",
    "PasswordStrengthCheck",
    "PasswordStrengthResponse",
]


class PasswordValidator:
    """
    Centralized password validation logic.
    
    Provides reusable validation methods for password strength.
    """

    SPECIAL_CHARS = r"!@#$%^&*()_+\-=\[\]{}|;:,.<>?"
    MIN_LENGTH = 8
    MAX_LENGTH = 128

    @classmethod
    def validate_strength(cls, password: str) -> tuple[bool, List[str]]:
        """
        Validate password strength and return issues.
        
        Args:
            password: Password to validate
            
        Returns:
            Tuple of (is_valid, list_of_issues)
        """
        issues = []

        if len(password) < cls.MIN_LENGTH:
            issues.append(f"Password must be at least {cls.MIN_LENGTH} characters long")

        if not any(char.isdigit() for char in password):
            issues.append("Password must contain at least one digit")

        if not any(char.isupper() for char in password):
            issues.append("Password must contain at least one uppercase letter")

        if not any(char.islower() for char in password):
            issues.append("Password must contain at least one lowercase letter")

        if not re.search(f"[{re.escape(cls.SPECIAL_CHARS)}]", password):
            issues.append(
                "Password must contain at least one special character "
                f"({cls.SPECIAL_CHARS})"
            )

        return len(issues) == 0, issues

    @classmethod
    def calculate_strength_score(cls, password: str) -> int:
        """
        Calculate password strength score (0-5).
        
        Args:
            password: Password to evaluate
            
        Returns:
            Strength score from 0 (very weak) to 5 (very strong)
        """
        score = 0

        # Length score
        if len(password) >= 8:
            score += 1
        if len(password) >= 12:
            score += 1

        # Character diversity
        if any(char.islower() for char in password):
            score += 1
        if any(char.isupper() for char in password):
            score += 1
        if any(char.isdigit() for char in password):
            score += 1
        if re.search(f"[{re.escape(cls.SPECIAL_CHARS)}]", password):
            score += 1

        # Cap at 5
        return min(score, 5)


class PasswordResetRequest(BaseCreateSchema):
    """
    Password reset request (forgot password flow).
    
    Initiates password reset process via email.
    """

    email: str = Field(
        ...,
        description="User email address",
        examples=["user@example.com"],
    )

    @field_validator("email")
    @classmethod
    def validate_email_format(cls, v: str) -> str:
        """Validate email format and normalize."""
        v = v.strip().lower()
        if not v:
            raise ValueError("Email cannot be empty")
        # Basic email validation
        if "@" not in v or "." not in v.split("@")[-1]:
            raise ValueError("Invalid email format")
        return v


class PasswordResetConfirm(BaseCreateSchema):
    """
    Confirm password reset with token and new password.
    
    Completes the password reset process.
    """

    token: str = Field(
        ...,
        min_length=1,
        description="Password reset token from email",
    )
    new_password: str = Field(
        ...,
        min_length=PasswordValidator.MIN_LENGTH,
        max_length=PasswordValidator.MAX_LENGTH,
        description="New password",
    )
    confirm_password: str = Field(
        ...,
        description="Confirm new password",
    )

    @field_validator("new_password")
    @classmethod
    def validate_password_strength(cls, v: str) -> str:
        """Validate password strength requirements."""
        is_valid, issues = PasswordValidator.validate_strength(v)
        if not is_valid:
            raise ValueError("; ".join(issues))
        return v

    @model_validator(mode="after")
    def validate_passwords_match(self) -> "PasswordResetConfirm":
        """Ensure new_password and confirm_password match."""
        if self.new_password != self.confirm_password:
            raise ValueError("Passwords do not match")
        return self


class PasswordChangeRequest(BaseCreateSchema):
    """
    Change password for authenticated user.
    
    Requires current password for security verification.
    """

    current_password: str = Field(
        ...,
        description="Current password for verification",
    )
    new_password: str = Field(
        ...,
        min_length=PasswordValidator.MIN_LENGTH,
        max_length=PasswordValidator.MAX_LENGTH,
        description="New password",
    )
    confirm_password: str = Field(
        ...,
        description="Confirm new password",
    )

    @field_validator("new_password")
    @classmethod
    def validate_password_strength(cls, v: str) -> str:
        """Validate password strength requirements."""
        is_valid, issues = PasswordValidator.validate_strength(v)
        if not is_valid:
            raise ValueError("; ".join(issues))
        return v

    @model_validator(mode="after")
    def validate_password_requirements(self) -> "PasswordChangeRequest":
        """
        Validate password change requirements.
        
        Ensures:
        - New password matches confirmation
        - New password differs from current password
        """
        if self.new_password != self.confirm_password:
            raise ValueError("New password and confirmation do not match")

        if self.new_password == self.current_password:
            raise ValueError(
                "New password must be different from current password"
            )

        return self


class PasswordChangeResponse(BaseSchema):
    """Password change success response."""

    message: str = Field(
        ...,
        description="Success message",
        examples=["Password changed successfully"],
    )
    user_id: UUID = Field(
        ...,
        description="User ID",
    )


class PasswordStrengthCheck(BaseCreateSchema):
    """
    Check password strength without saving.
    
    Useful for real-time password strength indicators.
    """

    password: str = Field(
        ...,
        min_length=1,
        max_length=PasswordValidator.MAX_LENGTH,
        description="Password to evaluate",
    )


class PasswordStrengthResponse(BaseSchema):
    """
    Password strength evaluation response.
    
    Provides detailed strength analysis and suggestions.
    """

    score: int = Field(
        ...,
        ge=0,
        le=5,
        description="Strength score: 0 (very weak) to 5 (very strong)",
    )
    strength: str = Field(
        ...,
        description="Strength label",
        examples=["weak", "medium", "strong", "very_strong"],
    )
    has_minimum_length: bool = Field(
        ...,
        description=f"Has minimum {PasswordValidator.MIN_LENGTH} characters",
    )
    has_uppercase: bool = Field(
        ...,
        description="Contains uppercase letter",
    )
    has_lowercase: bool = Field(
        ...,
        description="Contains lowercase letter",
    )
    has_digit: bool = Field(
        ...,
        description="Contains digit",
    )
    has_special_char: bool = Field(
        ...,
        description="Contains special character",
    )
    suggestions: List[str] = Field(
        default_factory=list,
        description="Suggestions for improvement",
    )

    @staticmethod
    def from_password(password: str) -> "PasswordStrengthResponse":
        """
        Create response from password analysis.
        
        Args:
            password: Password to analyze
            
        Returns:
            PasswordStrengthResponse with complete analysis
        """
        score = PasswordValidator.calculate_strength_score(password)
        is_valid, issues = PasswordValidator.validate_strength(password)

        # Determine strength label
        if score <= 1:
            strength = "very_weak"
        elif score == 2:
            strength = "weak"
        elif score == 3:
            strength = "medium"
        elif score == 4:
            strength = "strong"
        else:
            strength = "very_strong"

        return PasswordStrengthResponse(
            score=score,
            strength=strength,
            has_minimum_length=len(password) >= PasswordValidator.MIN_LENGTH,
            has_uppercase=any(c.isupper() for c in password),
            has_lowercase=any(c.islower() for c in password),
            has_digit=any(c.isdigit() for c in password),
            has_special_char=bool(
                re.search(
                    f"[{re.escape(PasswordValidator.SPECIAL_CHARS)}]",
                    password,
                )
            ),
            suggestions=issues if not is_valid else [],
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\register.py ---
# --- File: app/schemas/auth/register.py ---
"""
Registration schemas with comprehensive validation.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import Gender, UserRole

__all__ = [
    "RegisterRequest",
    "RegisterResponse",
    "VerifyEmailRequest",
    "VerifyPhoneRequest",
    "ResendVerificationRequest",
]


class RegisterRequest(BaseCreateSchema):
    """
    User registration request with comprehensive validation.
    
    Validates email, phone, password strength, and personal information.
    """

    email: EmailStr = Field(
        ...,
        description="Email address (must be unique)",
        examples=["user@example.com"],
    )
    phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number (E.164 format recommended)",
        examples=["+919876543210"],
    )
    password: str = Field(
        ...,
        min_length=8,
        max_length=128,
        description="Password (min 8 chars, must include uppercase, lowercase, digit)",
    )
    confirm_password: str = Field(
        ...,
        description="Password confirmation (must match password)",
    )
    full_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Full name",
        examples=["John Doe"],
    )
    role: UserRole = Field(
        default=UserRole.VISITOR,
        description="User role (defaults to visitor for security)",
    )
    gender: Optional[Gender] = Field(
        default=None,
        description="Gender (optional)",
    )
    date_of_birth: Optional[date] = Field(
        default=None,
        description="Date of birth (optional)",
    )

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: EmailStr) -> str:
        """Normalize email to lowercase."""
        return v.lower().strip()

    @field_validator("phone")
    @classmethod
    def normalize_phone(cls, v: str) -> str:
        """Normalize phone number by removing spaces and dashes."""
        return v.replace(" ", "").replace("-", "").strip()

    @field_validator("full_name")
    @classmethod
    def validate_full_name(cls, v: str) -> str:
        """
        Validate and normalize full name.
        
        Ensures name contains at least 2 characters and is not just numbers.
        """
        v = v.strip()
        if len(v) < 2:
            raise ValueError("Full name must be at least 2 characters")
        if v.isdigit():
            raise ValueError("Full name cannot be only numbers")
        return v

    @field_validator("date_of_birth")
    @classmethod
    def validate_age(cls, v: Optional[date]) -> Optional[date]:
        """
        Validate date of birth for reasonable age constraints.
        
        Ensures user is at least 13 years old and not born in the future.
        """
        if v is None:
            return v

        today = date.today()
        if v >= today:
            raise ValueError("Date of birth cannot be in the future")

        age = today.year - v.year - ((today.month, today.day) < (v.month, v.day))
        if age < 13:
            raise ValueError("User must be at least 13 years old")
        if age > 120:
            raise ValueError("Invalid date of birth")

        return v

    @field_validator("password")
    @classmethod
    def validate_password_strength(cls, v: str) -> str:
        """Validate password meets strength requirements."""
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters long")
        if not any(char.isdigit() for char in v):
            raise ValueError("Password must contain at least one digit")
        if not any(char.isupper() for char in v):
            raise ValueError("Password must contain at least one uppercase letter")
        if not any(char.islower() for char in v):
            raise ValueError("Password must contain at least one lowercase letter")
        return v

    @model_validator(mode="after")
    def validate_passwords_match(self) -> "RegisterRequest":
        """Ensure password and confirm_password match."""
        if self.password != self.confirm_password:
            raise ValueError("Passwords do not match")
        return self

    @field_validator("role")
    @classmethod
    def validate_role_restriction(cls, v: UserRole) -> UserRole:
        """
        Restrict self-registration to certain roles.
        
        Prevents users from self-registering as admin roles.
        """
        allowed_roles = {UserRole.VISITOR, UserRole.STUDENT}
        if v not in allowed_roles:
            raise ValueError(
                f"Cannot self-register with role '{v}'. "
                f"Allowed roles: {', '.join(r.value for r in allowed_roles)}"
            )
        return v


class RegisterResponse(BaseSchema):
    """
    Registration success response.
    
    Provides user details and verification requirements.
    """

    user_id: UUID = Field(
        ...,
        description="Created user ID",
    )
    email: str = Field(
        ...,
        description="Registered email address",
    )
    full_name: str = Field(
        ...,
        description="User full name",
    )
    role: UserRole = Field(
        ...,
        description="Assigned user role",
    )
    message: str = Field(
        ...,
        description="Success message",
        examples=["Registration successful. Please verify your email."],
    )
    verification_required: bool = Field(
        default=True,
        description="Whether email/phone verification is required",
    )


class VerifyEmailRequest(BaseCreateSchema):
    """
    Email verification request.
    
    Used to verify email address with code sent via email.
    """

    user_id: UUID = Field(
        ...,
        description="User ID to verify",
    )
    verification_code: str = Field(
        ...,
        min_length=6,
        max_length=6,
        pattern=r"^\d{6}$",
        description="6-digit verification code from email",
        examples=["123456"],
    )

    @field_validator("verification_code")
    @classmethod
    def validate_code_format(cls, v: str) -> str:
        """Ensure verification code is exactly 6 digits."""
        if not v.isdigit():
            raise ValueError("Verification code must contain only digits")
        if len(v) != 6:
            raise ValueError("Verification code must be exactly 6 digits")
        return v


class VerifyPhoneRequest(BaseCreateSchema):
    """
    Phone verification request.
    
    Used to verify phone number with code sent via SMS.
    """

    user_id: UUID = Field(
        ...,
        description="User ID to verify",
    )
    verification_code: str = Field(
        ...,
        min_length=6,
        max_length=6,
        pattern=r"^\d{6}$",
        description="6-digit verification code from SMS",
        examples=["123456"],
    )

    @field_validator("verification_code")
    @classmethod
    def validate_code_format(cls, v: str) -> str:
        """Ensure verification code is exactly 6 digits."""
        if not v.isdigit():
            raise ValueError("Verification code must contain only digits")
        if len(v) != 6:
            raise ValueError("Verification code must be exactly 6 digits")
        return v


class ResendVerificationRequest(BaseCreateSchema):
    """
    Resend verification code request.
    
    Used when user didn't receive the original verification code.
    """

    user_id: UUID = Field(
        ...,
        description="User ID for verification code resend",
    )
    verification_type: str = Field(
        ...,
        pattern=r"^(email|phone)$",
        description="Type of verification (email or phone)",
        examples=["email", "phone"],
    )

    @field_validator("verification_type")
    @classmethod
    def normalize_verification_type(cls, v: str) -> str:
        """Normalize verification type to lowercase."""
        return v.lower().strip()

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\social_auth.py ---
# --- File: app/schemas/auth/social_auth.py ---
"""
Social authentication schemas with provider-specific validation.
"""

from __future__ import annotations

from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, HttpUrl, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import Gender, UserRole

__all__ = [
    "SocialAuthRequest",
    "GoogleAuthRequest",
    "FacebookAuthRequest",
    "SocialUserInfo",
    "SocialProfileData",
    "SocialAuthResponse",
]


class SocialAuthRequest(BaseCreateSchema):
    """
    Base social authentication request.
    
    Generic schema for OAuth providers.
    """

    access_token: str = Field(
        ...,
        min_length=1,
        description="OAuth access token from provider",
    )
    provider: str = Field(
        ...,
        pattern=r"^(google|facebook|apple)$",
        description="OAuth provider name",
        examples=["google", "facebook"],
    )

    @field_validator("provider")
    @classmethod
    def normalize_provider(cls, v: str) -> str:
        """Normalize provider name to lowercase."""
        return v.lower().strip()

    @field_validator("access_token")
    @classmethod
    def validate_token_not_empty(cls, v: str) -> str:
        """Ensure access token is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Access token cannot be empty")
        return v


class GoogleAuthRequest(BaseCreateSchema):
    """
    Google OAuth authentication request.
    
    Uses Google ID token for secure authentication.
    """

    id_token: str = Field(
        ...,
        min_length=1,
        description="Google ID token (JWT) from OAuth flow",
    )
    access_token: Optional[str] = Field(
        default=None,
        description="Google access token (optional, for additional API access)",
    )

    @field_validator("id_token", "access_token")
    @classmethod
    def validate_token_format(cls, v: Optional[str]) -> Optional[str]:
        """Validate token format and strip whitespace."""
        if v is not None:
            v = v.strip()
            if not v:
                raise ValueError("Token cannot be empty or whitespace")
        return v


class FacebookAuthRequest(BaseCreateSchema):
    """
    Facebook OAuth authentication request.
    
    Uses Facebook access token and user ID for authentication.
    """

    access_token: str = Field(
        ...,
        min_length=1,
        description="Facebook access token from OAuth flow",
    )
    user_id: str = Field(
        ...,
        min_length=1,
        description="Facebook user ID",
    )

    @field_validator("access_token", "user_id")
    @classmethod
    def validate_not_empty(cls, v: str) -> str:
        """Ensure field is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Field cannot be empty or whitespace")
        return v


class SocialUserInfo(BaseSchema):
    """
    User information from social authentication.
    
    Minimal user profile data returned after social auth.
    """

    id: UUID = Field(
        ...,
        description="User ID in our system",
    )
    email: str = Field(
        ...,
        description="User email address",
    )
    full_name: str = Field(
        ...,
        description="User full name",
    )
    role: UserRole = Field(
        ...,
        description="User role",
    )
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL from social provider",
    )
    is_email_verified: bool = Field(
        default=True,
        description="Email verification status (auto-verified via social auth)",
    )


class SocialProfileData(BaseSchema):
    """
    Profile data extracted from social provider.
    
    Comprehensive user information from OAuth provider.
    """

    provider_user_id: str = Field(
        ...,
        description="Unique user ID from OAuth provider",
    )
    email: EmailStr = Field(
        ...,
        description="Email address from provider",
    )
    full_name: str = Field(
        ...,
        description="Full name from provider",
    )
    first_name: Optional[str] = Field(
        default=None,
        description="First name",
    )
    last_name: Optional[str] = Field(
        default=None,
        description="Last name",
    )
    profile_picture_url: Optional[HttpUrl] = Field(
        default=None,
        description="Profile picture URL from provider",
    )
    gender: Optional[Gender] = Field(
        default=None,
        description="Gender (if provided by provider)",
    )
    locale: Optional[str] = Field(
        default=None,
        description="User locale/language preference",
        examples=["en_US", "hi_IN"],
    )

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: EmailStr) -> str:
        """Normalize email to lowercase."""
        return v.lower().strip()


class SocialAuthResponse(BaseSchema):
    """
    Social authentication response.
    
    Follows OAuth 2.0 token response format with user information.
    """

    access_token: str = Field(
        ...,
        description="JWT access token for API authentication",
    )
    refresh_token: str = Field(
        ...,
        description="JWT refresh token",
    )
    token_type: str = Field(
        default="bearer",
        description="Token type (always 'bearer')",
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="Access token expiration in seconds",
        examples=[3600],
    )
    user: SocialUserInfo = Field(
        ...,
        description="Authenticated user information",
    )
    is_new_user: bool = Field(
        ...,
        description="Whether this is a new user (first-time registration)",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\token.py ---
# --- File: app/schemas/auth/token.py ---
"""
Token management schemas with enhanced security features.
"""

from __future__ import annotations

from datetime import datetime
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import UserRole

__all__ = [
    "Token",
    "TokenPayload",
    "RefreshTokenRequest",
    "RefreshTokenResponse",
    "TokenValidationRequest",
    "TokenValidationResponse",
    "RevokeTokenRequest",
    "LogoutRequest",
]


class Token(BaseSchema):
    """
    JWT token schema.
    
    Standard OAuth 2.0 token response format.
    """

    access_token: str = Field(
        ...,
        description="JWT access token",
    )
    refresh_token: str = Field(
        ...,
        description="JWT refresh token",
    )
    token_type: str = Field(
        default="bearer",
        description="Token type (always 'bearer')",
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="Access token expiration time in seconds",
        examples=[3600],
    )


class TokenPayload(BaseSchema):
    """
    JWT token payload structure.
    
    Standard JWT claims plus custom application claims.
    """

    sub: str = Field(
        ...,
        description="Subject (user_id as string)",
    )
    user_id: UUID = Field(
        ...,
        description="User unique identifier",
    )
    email: str = Field(
        ...,
        description="User email address",
    )
    role: UserRole = Field(
        ...,
        description="User role for authorization",
    )
    hostel_id: Optional[UUID] = Field(
        default=None,
        description="Active hostel context (for multi-hostel scenarios)",
    )
    exp: int = Field(
        ...,
        gt=0,
        description="Expiration timestamp (Unix epoch)",
    )
    iat: int = Field(
        ...,
        gt=0,
        description="Issued at timestamp (Unix epoch)",
    )
    jti: str = Field(
        ...,
        description="JWT ID (unique token identifier for revocation)",
    )

    @field_validator("exp", "iat")
    @classmethod
    def validate_timestamp(cls, v: int) -> int:
        """Validate timestamp is reasonable (not negative, not too far in future)."""
        if v < 0:
            raise ValueError("Timestamp cannot be negative")
        # Check if timestamp is not more than 100 years in the future
        max_future = int(datetime.now().timestamp()) + (100 * 365 * 24 * 3600)
        if v > max_future:
            raise ValueError("Timestamp is too far in the future")
        return v


class RefreshTokenRequest(BaseCreateSchema):
    """
    Refresh token request.
    
    Used to obtain a new access token using a refresh token.
    """

    refresh_token: str = Field(
        ...,
        min_length=1,
        description="Refresh token",
    )

    @field_validator("refresh_token")
    @classmethod
    def validate_token_not_empty(cls, v: str) -> str:
        """Ensure refresh token is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Refresh token cannot be empty")
        return v


class RefreshTokenResponse(BaseSchema):
    """
    Refresh token response.
    
    Returns new access and refresh tokens.
    """

    access_token: str = Field(
        ...,
        description="New JWT access token",
    )
    refresh_token: str = Field(
        ...,
        description="New refresh token (token rotation)",
    )
    token_type: str = Field(
        default="bearer",
        description="Token type (always 'bearer')",
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="New access token expiration time in seconds",
        examples=[3600],
    )


class TokenValidationRequest(BaseCreateSchema):
    """
    Token validation request.
    
    Used to validate token without making an authenticated request.
    """

    token: str = Field(
        ...,
        min_length=1,
        description="Token to validate (access or refresh)",
    )

    @field_validator("token")
    @classmethod
    def validate_token_not_empty(cls, v: str) -> str:
        """Ensure token is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Token cannot be empty")
        return v


class TokenValidationResponse(BaseSchema):
    """
    Token validation response.
    
    Indicates token validity and provides decoded information.
    """

    is_valid: bool = Field(
        ...,
        description="Whether token is valid and not expired",
    )
    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID if token is valid",
    )
    role: Optional[UserRole] = Field(
        default=None,
        description="User role if token is valid",
    )
    expires_at: Optional[datetime] = Field(
        default=None,
        description="Token expiration datetime (UTC)",
    )
    error: Optional[str] = Field(
        default=None,
        description="Error message if token is invalid",
        examples=["Token expired", "Invalid signature"],
    )


class RevokeTokenRequest(BaseCreateSchema):
    """
    Revoke token request.
    
    Used to invalidate specific token or all user tokens.
    """

    token: str = Field(
        ...,
        min_length=1,
        description="Token to revoke",
    )
    revoke_all: bool = Field(
        default=False,
        description="Revoke all tokens for this user",
    )

    @field_validator("token")
    @classmethod
    def validate_token_not_empty(cls, v: str) -> str:
        """Ensure token is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Token cannot be empty")
        return v


class LogoutRequest(BaseCreateSchema):
    """
    Logout request.
    
    Used to terminate user session(s).
    """

    refresh_token: Optional[str] = Field(
        default=None,
        description="Refresh token to revoke (optional if using access token)",
    )
    logout_all_devices: bool = Field(
        default=False,
        description="Logout from all devices (revoke all user tokens)",
    )

    @field_validator("refresh_token")
    @classmethod
    def validate_token_format(cls, v: Optional[str]) -> Optional[str]:
        """Validate refresh token format if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                raise ValueError("Refresh token cannot be empty if provided")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\__init__.py ---
# --- File: app/schemas/auth/__init__.py ---
"""
Authentication schemas package.

Re-exports commonly used auth-related schemas for convenient imports.

Example:
    from app.schemas.auth import LoginRequest, RegisterRequest, Token
"""

from __future__ import annotations

from app.schemas.auth.login import (
    LoginRequest,
    LoginResponse,
    PhoneLoginRequest,
    TokenData,
    UserLoginInfo,
)
from app.schemas.auth.otp import (
    OTPGenerateRequest,
    OTPResponse,
    OTPVerifyRequest,
    OTPVerifyResponse,
    ResendOTPRequest,
)
from app.schemas.auth.password import (
    PasswordChangeRequest,
    PasswordChangeResponse,
    PasswordResetConfirm,
    PasswordResetRequest,
    PasswordStrengthCheck,
    PasswordStrengthResponse,
    PasswordValidator,
)
from app.schemas.auth.register import (
    RegisterRequest,
    RegisterResponse,
    ResendVerificationRequest,
    VerifyEmailRequest,
    VerifyPhoneRequest,
)
from app.schemas.auth.social_auth import (
    FacebookAuthRequest,
    GoogleAuthRequest,
    SocialAuthRequest,
    SocialAuthResponse,
    SocialProfileData,
    SocialUserInfo,
)
from app.schemas.auth.token import (
    LogoutRequest,
    RefreshTokenRequest,
    RefreshTokenResponse,
    RevokeTokenRequest,
    Token,
    TokenPayload,
    TokenValidationRequest,
    TokenValidationResponse,
)

__all__ = [
    # Login
    "LoginRequest",
    "LoginResponse",
    "PhoneLoginRequest",
    "TokenData",
    "UserLoginInfo",
    # Register
    "RegisterRequest",
    "RegisterResponse",
    "VerifyEmailRequest",
    "VerifyPhoneRequest",
    "ResendVerificationRequest",
    # Token
    "Token",
    "TokenPayload",
    "RefreshTokenRequest",
    "RefreshTokenResponse",
    "TokenValidationRequest",
    "TokenValidationResponse",
    "RevokeTokenRequest",
    "LogoutRequest",
    # Password
    "PasswordResetRequest",
    "PasswordResetConfirm",
    "PasswordChangeRequest",
    "PasswordChangeResponse",
    "PasswordStrengthCheck",
    "PasswordStrengthResponse",
    "PasswordValidator",
    # OTP
    "OTPGenerateRequest",
    "OTPVerifyRequest",
    "OTPResponse",
    "OTPVerifyResponse",
    "ResendOTPRequest",
    # Social Auth
    "SocialAuthRequest",
    "SocialAuthResponse",
    "GoogleAuthRequest",
    "FacebookAuthRequest",
    "SocialUserInfo",
    "SocialProfileData",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\login.py ---
# --- File: app/schemas/auth/login.py ---
"""
Login schemas with enhanced validation and type safety.
"""

from __future__ import annotations

from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import UserRole

__all__ = [
    "LoginRequest",
    "PhoneLoginRequest",
    "TokenData",
    "UserLoginInfo",
    "LoginResponse",
]


class LoginRequest(BaseCreateSchema):
    """
    Email/password-based login request.
    
    Validates email format and password length constraints.
    """

    email: EmailStr = Field(
        ...,
        description="User email address",
        examples=["user@example.com"],
    )
    password: str = Field(
        ...,
        min_length=8,
        max_length=128,
        description="User password",
    )
    remember_me: bool = Field(
        default=False,
        description="Remember user session for extended period",
    )

    @field_validator("password")
    @classmethod
    def validate_password_not_empty(cls, v: str) -> str:
        """Ensure password is not just whitespace."""
        if not v or not v.strip():
            raise ValueError("Password cannot be empty or whitespace")
        return v


class PhoneLoginRequest(BaseCreateSchema):
    """
    Phone-based login request.
    
    Supports international phone numbers in E.164 format.
    """

    phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number (E.164 format recommended)",
        examples=["+919876543210", "9876543210"],
    )
    password: str = Field(
        ...,
        min_length=8,
        max_length=128,
        description="User password",
    )
    remember_me: bool = Field(
        default=False,
        description="Remember user session for extended period",
    )

    @field_validator("phone")
    @classmethod
    def normalize_phone(cls, v: str) -> str:
        """Normalize phone number by removing spaces and dashes."""
        return v.replace(" ", "").replace("-", "")

    @field_validator("password")
    @classmethod
    def validate_password_not_empty(cls, v: str) -> str:
        """Ensure password is not just whitespace."""
        if not v or not v.strip():
            raise ValueError("Password cannot be empty or whitespace")
        return v


class TokenData(BaseSchema):
    """
    Token data embedded in JWT payload.
    
    Contains minimal user identification and context information.
    """

    user_id: UUID = Field(
        ...,
        description="User unique identifier",
    )
    email: str = Field(
        ...,
        description="User email address",
        examples=["user@example.com"],
    )
    role: UserRole = Field(
        ...,
        description="User role for authorization",
    )
    hostel_id: Optional[UUID] = Field(
        default=None,
        description="Active hostel context for multi-hostel admins",
    )


class UserLoginInfo(BaseSchema):
    """
    User information included in login response.
    
    Provides essential user profile data without sensitive information.
    """

    id: UUID = Field(
        ...,
        description="User unique identifier",
    )
    email: str = Field(
        ...,
        description="User email address",
    )
    full_name: str = Field(
        ...,
        description="User full name",
        examples=["John Doe"],
    )
    role: UserRole = Field(
        ...,
        description="User role",
    )
    is_email_verified: bool = Field(
        ...,
        description="Email verification status",
    )
    is_phone_verified: bool = Field(
        ...,
        description="Phone verification status",
    )
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
        examples=["https://example.com/images/profile.jpg"],
    )


class LoginResponse(BaseSchema):
    """
    Login response with JWT tokens and user information.
    
    Follows OAuth 2.0 token response format.
    """

    access_token: str = Field(
        ...,
        description="JWT access token for API authentication",
    )
    refresh_token: str = Field(
        ...,
        description="JWT refresh token for obtaining new access tokens",
    )
    token_type: str = Field(
        default="bearer",
        description="Token type (always 'bearer')",
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="Access token expiration time in seconds",
        examples=[3600],
    )
    user: UserLoginInfo = Field(
        ...,
        description="Authenticated user information",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\otp.py ---
# --- File: app/schemas/auth/otp.py ---
"""
OTP (One-Time Password) schemas with enhanced validation.
"""

from __future__ import annotations

from datetime import datetime
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, model_validator, field_validator


from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import OTPType

__all__ = [
    "OTPGenerateRequest",
    "OTPVerifyRequest",
    "OTPResponse",
    "OTPVerifyResponse",
    "ResendOTPRequest",
]


class OTPGenerateRequest(BaseCreateSchema):
    """
    Generate OTP request.
    
    Requires at least one contact method (email or phone).
    """

    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID if authenticated context",
    )
    email: Optional[EmailStr] = Field(
        default=None,
        description="Email address for OTP delivery",
    )
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number for OTP delivery",
    )
    otp_type: OTPType = Field(
        ...,
        description="OTP purpose/type",
    )

    @model_validator(mode="after")
    def validate_contact_method(self) -> "OTPGenerateRequest":
        """
        Ensure at least one contact method is provided.
        
        Raises:
            ValueError: If neither email nor phone is provided.
        """
        if not self.email and not self.phone:
            raise ValueError(
                "At least one contact method (email or phone) must be provided"
            )
        return self

    @field_validator("phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone number by removing spaces and dashes."""
        if v:
            return v.replace(" ", "").replace("-", "")
        return v


class OTPVerifyRequest(BaseCreateSchema):
    """
    Verify OTP request.
    
    Validates OTP code format and ensures contact method is provided.
    """

    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID for verification",
    )
    email: Optional[EmailStr] = Field(
        default=None,
        description="Email address used for OTP generation",
    )
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number used for OTP generation",
    )
    otp_code: str = Field(
        ...,
        min_length=6,
        max_length=6,
        pattern=r"^\d{6}$",
        description="6-digit OTP code",
        examples=["123456"],
    )
    otp_type: OTPType = Field(
        ...,
        description="OTP purpose/type",
    )

    @model_validator(mode="after")
    def validate_contact_method(self) -> "OTPVerifyRequest":
        """Ensure at least one contact method is provided."""
        if not self.email and not self.phone:
            raise ValueError(
                "At least one contact method (email or phone) must be provided"
            )
        return self

    @field_validator("otp_code")
    @classmethod
    def validate_otp_format(cls, v: str) -> str:
        """Ensure OTP is exactly 6 digits."""
        if not v.isdigit():
            raise ValueError("OTP must contain only digits")
        if len(v) != 6:
            raise ValueError("OTP must be exactly 6 digits")
        return v


class OTPResponse(BaseSchema):
    """
    OTP generation response.
    
    Provides masked delivery information and expiration details.
    """

    message: str = Field(
        ...,
        description="Response message",
        examples=["OTP sent successfully"],
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="OTP expiration time in seconds",
        examples=[300],
    )
    sent_to: str = Field(
        ...,
        description="Masked email/phone where OTP was sent",
        examples=["u***@example.com", "+91******3210"],
    )
    otp_type: OTPType = Field(
        ...,
        description="OTP type/purpose",
    )
    max_attempts: int = Field(
        default=3,
        ge=1,
        description="Maximum verification attempts allowed",
    )


class OTPVerifyResponse(BaseSchema):
    """
    OTP verification response.
    
    Indicates verification status and provides related information.
    """

    is_valid: bool = Field(
        ...,
        description="Whether OTP verification was successful",
    )
    message: str = Field(
        ...,
        description="Verification result message",
        examples=["OTP verified successfully", "Invalid or expired OTP"],
    )
    verified_at: Optional[datetime] = Field(
        default=None,
        description="Verification timestamp (UTC)",
    )
    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID associated with verified OTP",
    )
    remaining_attempts: Optional[int] = Field(
        default=None,
        ge=0,
        description="Remaining verification attempts (if failed)",
    )


class ResendOTPRequest(BaseCreateSchema):
    """
    Resend OTP request.
    
    Used when user didn't receive the original OTP.
    """

    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID for OTP resend",
    )
    email: Optional[EmailStr] = Field(
        default=None,
        description="Email address for OTP delivery",
    )
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number for OTP delivery",
    )
    otp_type: OTPType = Field(
        ...,
        description="OTP purpose/type",
    )

    @model_validator(mode="after")
    def validate_contact_method(self) -> "ResendOTPRequest":
        """Ensure at least one contact method is provided."""
        if not self.email and not self.phone:
            raise ValueError(
                "At least one contact method (email or phone) must be provided"
            )
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\password.py ---
# --- File: app/schemas/auth/password.py ---
"""
Password management schemas with robust validation.
"""

from __future__ import annotations

import re
from typing import List
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "PasswordResetRequest",
    "PasswordResetConfirm",
    "PasswordChangeRequest",
    "PasswordChangeResponse",
    "PasswordStrengthCheck",
    "PasswordStrengthResponse",
]


class PasswordValidator:
    """
    Centralized password validation logic.
    
    Provides reusable validation methods for password strength.
    """

    SPECIAL_CHARS = r"!@#$%^&*()_+\-=\[\]{}|;:,.<>?"
    MIN_LENGTH = 8
    MAX_LENGTH = 128

    @classmethod
    def validate_strength(cls, password: str) -> tuple[bool, List[str]]:
        """
        Validate password strength and return issues.
        
        Args:
            password: Password to validate
            
        Returns:
            Tuple of (is_valid, list_of_issues)
        """
        issues = []

        if len(password) < cls.MIN_LENGTH:
            issues.append(f"Password must be at least {cls.MIN_LENGTH} characters long")

        if not any(char.isdigit() for char in password):
            issues.append("Password must contain at least one digit")

        if not any(char.isupper() for char in password):
            issues.append("Password must contain at least one uppercase letter")

        if not any(char.islower() for char in password):
            issues.append("Password must contain at least one lowercase letter")

        if not re.search(f"[{re.escape(cls.SPECIAL_CHARS)}]", password):
            issues.append(
                "Password must contain at least one special character "
                f"({cls.SPECIAL_CHARS})"
            )

        return len(issues) == 0, issues

    @classmethod
    def calculate_strength_score(cls, password: str) -> int:
        """
        Calculate password strength score (0-5).
        
        Args:
            password: Password to evaluate
            
        Returns:
            Strength score from 0 (very weak) to 5 (very strong)
        """
        score = 0

        # Length score
        if len(password) >= 8:
            score += 1
        if len(password) >= 12:
            score += 1

        # Character diversity
        if any(char.islower() for char in password):
            score += 1
        if any(char.isupper() for char in password):
            score += 1
        if any(char.isdigit() for char in password):
            score += 1
        if re.search(f"[{re.escape(cls.SPECIAL_CHARS)}]", password):
            score += 1

        # Cap at 5
        return min(score, 5)


class PasswordResetRequest(BaseCreateSchema):
    """
    Password reset request (forgot password flow).
    
    Initiates password reset process via email.
    """

    email: str = Field(
        ...,
        description="User email address",
        examples=["user@example.com"],
    )

    @field_validator("email")
    @classmethod
    def validate_email_format(cls, v: str) -> str:
        """Validate email format and normalize."""
        v = v.strip().lower()
        if not v:
            raise ValueError("Email cannot be empty")
        # Basic email validation
        if "@" not in v or "." not in v.split("@")[-1]:
            raise ValueError("Invalid email format")
        return v


class PasswordResetConfirm(BaseCreateSchema):
    """
    Confirm password reset with token and new password.
    
    Completes the password reset process.
    """

    token: str = Field(
        ...,
        min_length=1,
        description="Password reset token from email",
    )
    new_password: str = Field(
        ...,
        min_length=PasswordValidator.MIN_LENGTH,
        max_length=PasswordValidator.MAX_LENGTH,
        description="New password",
    )
    confirm_password: str = Field(
        ...,
        description="Confirm new password",
    )

    @field_validator("new_password")
    @classmethod
    def validate_password_strength(cls, v: str) -> str:
        """Validate password strength requirements."""
        is_valid, issues = PasswordValidator.validate_strength(v)
        if not is_valid:
            raise ValueError("; ".join(issues))
        return v

    @model_validator(mode="after")
    def validate_passwords_match(self) -> "PasswordResetConfirm":
        """Ensure new_password and confirm_password match."""
        if self.new_password != self.confirm_password:
            raise ValueError("Passwords do not match")
        return self


class PasswordChangeRequest(BaseCreateSchema):
    """
    Change password for authenticated user.
    
    Requires current password for security verification.
    """

    current_password: str = Field(
        ...,
        description="Current password for verification",
    )
    new_password: str = Field(
        ...,
        min_length=PasswordValidator.MIN_LENGTH,
        max_length=PasswordValidator.MAX_LENGTH,
        description="New password",
    )
    confirm_password: str = Field(
        ...,
        description="Confirm new password",
    )

    @field_validator("new_password")
    @classmethod
    def validate_password_strength(cls, v: str) -> str:
        """Validate password strength requirements."""
        is_valid, issues = PasswordValidator.validate_strength(v)
        if not is_valid:
            raise ValueError("; ".join(issues))
        return v

    @model_validator(mode="after")
    def validate_password_requirements(self) -> "PasswordChangeRequest":
        """
        Validate password change requirements.
        
        Ensures:
        - New password matches confirmation
        - New password differs from current password
        """
        if self.new_password != self.confirm_password:
            raise ValueError("New password and confirmation do not match")

        if self.new_password == self.current_password:
            raise ValueError(
                "New password must be different from current password"
            )

        return self


class PasswordChangeResponse(BaseSchema):
    """Password change success response."""

    message: str = Field(
        ...,
        description="Success message",
        examples=["Password changed successfully"],
    )
    user_id: UUID = Field(
        ...,
        description="User ID",
    )


class PasswordStrengthCheck(BaseCreateSchema):
    """
    Check password strength without saving.
    
    Useful for real-time password strength indicators.
    """

    password: str = Field(
        ...,
        min_length=1,
        max_length=PasswordValidator.MAX_LENGTH,
        description="Password to evaluate",
    )


class PasswordStrengthResponse(BaseSchema):
    """
    Password strength evaluation response.
    
    Provides detailed strength analysis and suggestions.
    """

    score: int = Field(
        ...,
        ge=0,
        le=5,
        description="Strength score: 0 (very weak) to 5 (very strong)",
    )
    strength: str = Field(
        ...,
        description="Strength label",
        examples=["weak", "medium", "strong", "very_strong"],
    )
    has_minimum_length: bool = Field(
        ...,
        description=f"Has minimum {PasswordValidator.MIN_LENGTH} characters",
    )
    has_uppercase: bool = Field(
        ...,
        description="Contains uppercase letter",
    )
    has_lowercase: bool = Field(
        ...,
        description="Contains lowercase letter",
    )
    has_digit: bool = Field(
        ...,
        description="Contains digit",
    )
    has_special_char: bool = Field(
        ...,
        description="Contains special character",
    )
    suggestions: List[str] = Field(
        default_factory=list,
        description="Suggestions for improvement",
    )

    @staticmethod
    def from_password(password: str) -> "PasswordStrengthResponse":
        """
        Create response from password analysis.
        
        Args:
            password: Password to analyze
            
        Returns:
            PasswordStrengthResponse with complete analysis
        """
        score = PasswordValidator.calculate_strength_score(password)
        is_valid, issues = PasswordValidator.validate_strength(password)

        # Determine strength label
        if score <= 1:
            strength = "very_weak"
        elif score == 2:
            strength = "weak"
        elif score == 3:
            strength = "medium"
        elif score == 4:
            strength = "strong"
        else:
            strength = "very_strong"

        return PasswordStrengthResponse(
            score=score,
            strength=strength,
            has_minimum_length=len(password) >= PasswordValidator.MIN_LENGTH,
            has_uppercase=any(c.isupper() for c in password),
            has_lowercase=any(c.islower() for c in password),
            has_digit=any(c.isdigit() for c in password),
            has_special_char=bool(
                re.search(
                    f"[{re.escape(PasswordValidator.SPECIAL_CHARS)}]",
                    password,
                )
            ),
            suggestions=issues if not is_valid else [],
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\register.py ---
# --- File: app/schemas/auth/register.py ---
"""
Registration schemas with comprehensive validation.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import Gender, UserRole

__all__ = [
    "RegisterRequest",
    "RegisterResponse",
    "VerifyEmailRequest",
    "VerifyPhoneRequest",
    "ResendVerificationRequest",
]


class RegisterRequest(BaseCreateSchema):
    """
    User registration request with comprehensive validation.
    
    Validates email, phone, password strength, and personal information.
    """

    email: EmailStr = Field(
        ...,
        description="Email address (must be unique)",
        examples=["user@example.com"],
    )
    phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number (E.164 format recommended)",
        examples=["+919876543210"],
    )
    password: str = Field(
        ...,
        min_length=8,
        max_length=128,
        description="Password (min 8 chars, must include uppercase, lowercase, digit)",
    )
    confirm_password: str = Field(
        ...,
        description="Password confirmation (must match password)",
    )
    full_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Full name",
        examples=["John Doe"],
    )
    role: UserRole = Field(
        default=UserRole.VISITOR,
        description="User role (defaults to visitor for security)",
    )
    gender: Optional[Gender] = Field(
        default=None,
        description="Gender (optional)",
    )
    date_of_birth: Optional[date] = Field(
        default=None,
        description="Date of birth (optional)",
    )

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: EmailStr) -> str:
        """Normalize email to lowercase."""
        return v.lower().strip()

    @field_validator("phone")
    @classmethod
    def normalize_phone(cls, v: str) -> str:
        """Normalize phone number by removing spaces and dashes."""
        return v.replace(" ", "").replace("-", "").strip()

    @field_validator("full_name")
    @classmethod
    def validate_full_name(cls, v: str) -> str:
        """
        Validate and normalize full name.
        
        Ensures name contains at least 2 characters and is not just numbers.
        """
        v = v.strip()
        if len(v) < 2:
            raise ValueError("Full name must be at least 2 characters")
        if v.isdigit():
            raise ValueError("Full name cannot be only numbers")
        return v

    @field_validator("date_of_birth")
    @classmethod
    def validate_age(cls, v: Optional[date]) -> Optional[date]:
        """
        Validate date of birth for reasonable age constraints.
        
        Ensures user is at least 13 years old and not born in the future.
        """
        if v is None:
            return v

        today = date.today()
        if v >= today:
            raise ValueError("Date of birth cannot be in the future")

        age = today.year - v.year - ((today.month, today.day) < (v.month, v.day))
        if age < 13:
            raise ValueError("User must be at least 13 years old")
        if age > 120:
            raise ValueError("Invalid date of birth")

        return v

    @field_validator("password")
    @classmethod
    def validate_password_strength(cls, v: str) -> str:
        """Validate password meets strength requirements."""
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters long")
        if not any(char.isdigit() for char in v):
            raise ValueError("Password must contain at least one digit")
        if not any(char.isupper() for char in v):
            raise ValueError("Password must contain at least one uppercase letter")
        if not any(char.islower() for char in v):
            raise ValueError("Password must contain at least one lowercase letter")
        return v

    @model_validator(mode="after")
    def validate_passwords_match(self) -> "RegisterRequest":
        """Ensure password and confirm_password match."""
        if self.password != self.confirm_password:
            raise ValueError("Passwords do not match")
        return self

    @field_validator("role")
    @classmethod
    def validate_role_restriction(cls, v: UserRole) -> UserRole:
        """
        Restrict self-registration to certain roles.
        
        Prevents users from self-registering as admin roles.
        """
        allowed_roles = {UserRole.VISITOR, UserRole.STUDENT}
        if v not in allowed_roles:
            raise ValueError(
                f"Cannot self-register with role '{v}'. "
                f"Allowed roles: {', '.join(r.value for r in allowed_roles)}"
            )
        return v


class RegisterResponse(BaseSchema):
    """
    Registration success response.
    
    Provides user details and verification requirements.
    """

    user_id: UUID = Field(
        ...,
        description="Created user ID",
    )
    email: str = Field(
        ...,
        description="Registered email address",
    )
    full_name: str = Field(
        ...,
        description="User full name",
    )
    role: UserRole = Field(
        ...,
        description="Assigned user role",
    )
    message: str = Field(
        ...,
        description="Success message",
        examples=["Registration successful. Please verify your email."],
    )
    verification_required: bool = Field(
        default=True,
        description="Whether email/phone verification is required",
    )


class VerifyEmailRequest(BaseCreateSchema):
    """
    Email verification request.
    
    Used to verify email address with code sent via email.
    """

    user_id: UUID = Field(
        ...,
        description="User ID to verify",
    )
    verification_code: str = Field(
        ...,
        min_length=6,
        max_length=6,
        pattern=r"^\d{6}$",
        description="6-digit verification code from email",
        examples=["123456"],
    )

    @field_validator("verification_code")
    @classmethod
    def validate_code_format(cls, v: str) -> str:
        """Ensure verification code is exactly 6 digits."""
        if not v.isdigit():
            raise ValueError("Verification code must contain only digits")
        if len(v) != 6:
            raise ValueError("Verification code must be exactly 6 digits")
        return v


class VerifyPhoneRequest(BaseCreateSchema):
    """
    Phone verification request.
    
    Used to verify phone number with code sent via SMS.
    """

    user_id: UUID = Field(
        ...,
        description="User ID to verify",
    )
    verification_code: str = Field(
        ...,
        min_length=6,
        max_length=6,
        pattern=r"^\d{6}$",
        description="6-digit verification code from SMS",
        examples=["123456"],
    )

    @field_validator("verification_code")
    @classmethod
    def validate_code_format(cls, v: str) -> str:
        """Ensure verification code is exactly 6 digits."""
        if not v.isdigit():
            raise ValueError("Verification code must contain only digits")
        if len(v) != 6:
            raise ValueError("Verification code must be exactly 6 digits")
        return v


class ResendVerificationRequest(BaseCreateSchema):
    """
    Resend verification code request.
    
    Used when user didn't receive the original verification code.
    """

    user_id: UUID = Field(
        ...,
        description="User ID for verification code resend",
    )
    verification_type: str = Field(
        ...,
        pattern=r"^(email|phone)$",
        description="Type of verification (email or phone)",
        examples=["email", "phone"],
    )

    @field_validator("verification_type")
    @classmethod
    def normalize_verification_type(cls, v: str) -> str:
        """Normalize verification type to lowercase."""
        return v.lower().strip()

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\social_auth.py ---
# --- File: app/schemas/auth/social_auth.py ---
"""
Social authentication schemas with provider-specific validation.
"""

from __future__ import annotations

from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, HttpUrl, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import Gender, UserRole

__all__ = [
    "SocialAuthRequest",
    "GoogleAuthRequest",
    "FacebookAuthRequest",
    "SocialUserInfo",
    "SocialProfileData",
    "SocialAuthResponse",
]


class SocialAuthRequest(BaseCreateSchema):
    """
    Base social authentication request.
    
    Generic schema for OAuth providers.
    """

    access_token: str = Field(
        ...,
        min_length=1,
        description="OAuth access token from provider",
    )
    provider: str = Field(
        ...,
        pattern=r"^(google|facebook|apple)$",
        description="OAuth provider name",
        examples=["google", "facebook"],
    )

    @field_validator("provider")
    @classmethod
    def normalize_provider(cls, v: str) -> str:
        """Normalize provider name to lowercase."""
        return v.lower().strip()

    @field_validator("access_token")
    @classmethod
    def validate_token_not_empty(cls, v: str) -> str:
        """Ensure access token is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Access token cannot be empty")
        return v


class GoogleAuthRequest(BaseCreateSchema):
    """
    Google OAuth authentication request.
    
    Uses Google ID token for secure authentication.
    """

    id_token: str = Field(
        ...,
        min_length=1,
        description="Google ID token (JWT) from OAuth flow",
    )
    access_token: Optional[str] = Field(
        default=None,
        description="Google access token (optional, for additional API access)",
    )

    @field_validator("id_token", "access_token")
    @classmethod
    def validate_token_format(cls, v: Optional[str]) -> Optional[str]:
        """Validate token format and strip whitespace."""
        if v is not None:
            v = v.strip()
            if not v:
                raise ValueError("Token cannot be empty or whitespace")
        return v


class FacebookAuthRequest(BaseCreateSchema):
    """
    Facebook OAuth authentication request.
    
    Uses Facebook access token and user ID for authentication.
    """

    access_token: str = Field(
        ...,
        min_length=1,
        description="Facebook access token from OAuth flow",
    )
    user_id: str = Field(
        ...,
        min_length=1,
        description="Facebook user ID",
    )

    @field_validator("access_token", "user_id")
    @classmethod
    def validate_not_empty(cls, v: str) -> str:
        """Ensure field is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Field cannot be empty or whitespace")
        return v


class SocialUserInfo(BaseSchema):
    """
    User information from social authentication.
    
    Minimal user profile data returned after social auth.
    """

    id: UUID = Field(
        ...,
        description="User ID in our system",
    )
    email: str = Field(
        ...,
        description="User email address",
    )
    full_name: str = Field(
        ...,
        description="User full name",
    )
    role: UserRole = Field(
        ...,
        description="User role",
    )
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL from social provider",
    )
    is_email_verified: bool = Field(
        default=True,
        description="Email verification status (auto-verified via social auth)",
    )


class SocialProfileData(BaseSchema):
    """
    Profile data extracted from social provider.
    
    Comprehensive user information from OAuth provider.
    """

    provider_user_id: str = Field(
        ...,
        description="Unique user ID from OAuth provider",
    )
    email: EmailStr = Field(
        ...,
        description="Email address from provider",
    )
    full_name: str = Field(
        ...,
        description="Full name from provider",
    )
    first_name: Optional[str] = Field(
        default=None,
        description="First name",
    )
    last_name: Optional[str] = Field(
        default=None,
        description="Last name",
    )
    profile_picture_url: Optional[HttpUrl] = Field(
        default=None,
        description="Profile picture URL from provider",
    )
    gender: Optional[Gender] = Field(
        default=None,
        description="Gender (if provided by provider)",
    )
    locale: Optional[str] = Field(
        default=None,
        description="User locale/language preference",
        examples=["en_US", "hi_IN"],
    )

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: EmailStr) -> str:
        """Normalize email to lowercase."""
        return v.lower().strip()


class SocialAuthResponse(BaseSchema):
    """
    Social authentication response.
    
    Follows OAuth 2.0 token response format with user information.
    """

    access_token: str = Field(
        ...,
        description="JWT access token for API authentication",
    )
    refresh_token: str = Field(
        ...,
        description="JWT refresh token",
    )
    token_type: str = Field(
        default="bearer",
        description="Token type (always 'bearer')",
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="Access token expiration in seconds",
        examples=[3600],
    )
    user: SocialUserInfo = Field(
        ...,
        description="Authenticated user information",
    )
    is_new_user: bool = Field(
        ...,
        description="Whether this is a new user (first-time registration)",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\token.py ---
# --- File: app/schemas/auth/token.py ---
"""
Token management schemas with enhanced security features.
"""

from __future__ import annotations

from datetime import datetime
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import UserRole

__all__ = [
    "Token",
    "TokenPayload",
    "RefreshTokenRequest",
    "RefreshTokenResponse",
    "TokenValidationRequest",
    "TokenValidationResponse",
    "RevokeTokenRequest",
    "LogoutRequest",
]


class Token(BaseSchema):
    """
    JWT token schema.
    
    Standard OAuth 2.0 token response format.
    """

    access_token: str = Field(
        ...,
        description="JWT access token",
    )
    refresh_token: str = Field(
        ...,
        description="JWT refresh token",
    )
    token_type: str = Field(
        default="bearer",
        description="Token type (always 'bearer')",
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="Access token expiration time in seconds",
        examples=[3600],
    )


class TokenPayload(BaseSchema):
    """
    JWT token payload structure.
    
    Standard JWT claims plus custom application claims.
    """

    sub: str = Field(
        ...,
        description="Subject (user_id as string)",
    )
    user_id: UUID = Field(
        ...,
        description="User unique identifier",
    )
    email: str = Field(
        ...,
        description="User email address",
    )
    role: UserRole = Field(
        ...,
        description="User role for authorization",
    )
    hostel_id: Optional[UUID] = Field(
        default=None,
        description="Active hostel context (for multi-hostel scenarios)",
    )
    exp: int = Field(
        ...,
        gt=0,
        description="Expiration timestamp (Unix epoch)",
    )
    iat: int = Field(
        ...,
        gt=0,
        description="Issued at timestamp (Unix epoch)",
    )
    jti: str = Field(
        ...,
        description="JWT ID (unique token identifier for revocation)",
    )

    @field_validator("exp", "iat")
    @classmethod
    def validate_timestamp(cls, v: int) -> int:
        """Validate timestamp is reasonable (not negative, not too far in future)."""
        if v < 0:
            raise ValueError("Timestamp cannot be negative")
        # Check if timestamp is not more than 100 years in the future
        max_future = int(datetime.now().timestamp()) + (100 * 365 * 24 * 3600)
        if v > max_future:
            raise ValueError("Timestamp is too far in the future")
        return v


class RefreshTokenRequest(BaseCreateSchema):
    """
    Refresh token request.
    
    Used to obtain a new access token using a refresh token.
    """

    refresh_token: str = Field(
        ...,
        min_length=1,
        description="Refresh token",
    )

    @field_validator("refresh_token")
    @classmethod
    def validate_token_not_empty(cls, v: str) -> str:
        """Ensure refresh token is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Refresh token cannot be empty")
        return v


class RefreshTokenResponse(BaseSchema):
    """
    Refresh token response.
    
    Returns new access and refresh tokens.
    """

    access_token: str = Field(
        ...,
        description="New JWT access token",
    )
    refresh_token: str = Field(
        ...,
        description="New refresh token (token rotation)",
    )
    token_type: str = Field(
        default="bearer",
        description="Token type (always 'bearer')",
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="New access token expiration time in seconds",
        examples=[3600],
    )


class TokenValidationRequest(BaseCreateSchema):
    """
    Token validation request.
    
    Used to validate token without making an authenticated request.
    """

    token: str = Field(
        ...,
        min_length=1,
        description="Token to validate (access or refresh)",
    )

    @field_validator("token")
    @classmethod
    def validate_token_not_empty(cls, v: str) -> str:
        """Ensure token is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Token cannot be empty")
        return v


class TokenValidationResponse(BaseSchema):
    """
    Token validation response.
    
    Indicates token validity and provides decoded information.
    """

    is_valid: bool = Field(
        ...,
        description="Whether token is valid and not expired",
    )
    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID if token is valid",
    )
    role: Optional[UserRole] = Field(
        default=None,
        description="User role if token is valid",
    )
    expires_at: Optional[datetime] = Field(
        default=None,
        description="Token expiration datetime (UTC)",
    )
    error: Optional[str] = Field(
        default=None,
        description="Error message if token is invalid",
        examples=["Token expired", "Invalid signature"],
    )


class RevokeTokenRequest(BaseCreateSchema):
    """
    Revoke token request.
    
    Used to invalidate specific token or all user tokens.
    """

    token: str = Field(
        ...,
        min_length=1,
        description="Token to revoke",
    )
    revoke_all: bool = Field(
        default=False,
        description="Revoke all tokens for this user",
    )

    @field_validator("token")
    @classmethod
    def validate_token_not_empty(cls, v: str) -> str:
        """Ensure token is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Token cannot be empty")
        return v


class LogoutRequest(BaseCreateSchema):
    """
    Logout request.
    
    Used to terminate user session(s).
    """

    refresh_token: Optional[str] = Field(
        default=None,
        description="Refresh token to revoke (optional if using access token)",
    )
    logout_all_devices: bool = Field(
        default=False,
        description="Logout from all devices (revoke all user tokens)",
    )

    @field_validator("refresh_token")
    @classmethod
    def validate_token_format(cls, v: Optional[str]) -> Optional[str]:
        """Validate refresh token format if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                raise ValueError("Refresh token cannot be empty if provided")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\__init__.py ---
# --- File: app/schemas/auth/__init__.py ---
"""
Authentication schemas package.

Re-exports commonly used auth-related schemas for convenient imports.

Example:
    from app.schemas.auth import LoginRequest, RegisterRequest, Token
"""

from __future__ import annotations

from app.schemas.auth.login import (
    LoginRequest,
    LoginResponse,
    PhoneLoginRequest,
    TokenData,
    UserLoginInfo,
)
from app.schemas.auth.otp import (
    OTPGenerateRequest,
    OTPResponse,
    OTPVerifyRequest,
    OTPVerifyResponse,
    ResendOTPRequest,
)
from app.schemas.auth.password import (
    PasswordChangeRequest,
    PasswordChangeResponse,
    PasswordResetConfirm,
    PasswordResetRequest,
    PasswordStrengthCheck,
    PasswordStrengthResponse,
    PasswordValidator,
)
from app.schemas.auth.register import (
    RegisterRequest,
    RegisterResponse,
    ResendVerificationRequest,
    VerifyEmailRequest,
    VerifyPhoneRequest,
)
from app.schemas.auth.social_auth import (
    FacebookAuthRequest,
    GoogleAuthRequest,
    SocialAuthRequest,
    SocialAuthResponse,
    SocialProfileData,
    SocialUserInfo,
)
from app.schemas.auth.token import (
    LogoutRequest,
    RefreshTokenRequest,
    RefreshTokenResponse,
    RevokeTokenRequest,
    Token,
    TokenPayload,
    TokenValidationRequest,
    TokenValidationResponse,
)

__all__ = [
    # Login
    "LoginRequest",
    "LoginResponse",
    "PhoneLoginRequest",
    "TokenData",
    "UserLoginInfo",
    # Register
    "RegisterRequest",
    "RegisterResponse",
    "VerifyEmailRequest",
    "VerifyPhoneRequest",
    "ResendVerificationRequest",
    # Token
    "Token",
    "TokenPayload",
    "RefreshTokenRequest",
    "RefreshTokenResponse",
    "TokenValidationRequest",
    "TokenValidationResponse",
    "RevokeTokenRequest",
    "LogoutRequest",
    # Password
    "PasswordResetRequest",
    "PasswordResetConfirm",
    "PasswordChangeRequest",
    "PasswordChangeResponse",
    "PasswordStrengthCheck",
    "PasswordStrengthResponse",
    "PasswordValidator",
    # OTP
    "OTPGenerateRequest",
    "OTPVerifyRequest",
    "OTPResponse",
    "OTPVerifyResponse",
    "ResendOTPRequest",
    # Social Auth
    "SocialAuthRequest",
    "SocialAuthResponse",
    "GoogleAuthRequest",
    "FacebookAuthRequest",
    "SocialUserInfo",
    "SocialProfileData",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\booking =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\booking ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\booking =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_approval.py ---
"""
Booking approval schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema


class BookingApprovalRequest(BaseCreateSchema):
    """Approve booking request"""
    booking_id: UUID = Field(..., description="Booking ID to approve")
    
    # Room assignment
    room_id: UUID = Field(..., description="Assigned room")
    bed_id: UUID = Field(..., description="Assigned bed")
    
    # Confirm or adjust dates
    approved_check_in_date: date = Field(..., description="Approved check-in date")
    
    # Confirm or adjust pricing
    final_rent_monthly: Decimal = Field(..., ge=0, description="Final monthly rent")
    final_security_deposit: Decimal = Field(..., ge=0, description="Final security deposit")
    
    # Additional charges
    processing_fee: Decimal = Field(Decimal("0.00"), ge=0, description="One-time processing fee")
    
    # Notes
    admin_notes: Optional[str] = Field(None, max_length=500, description="Internal notes")
    message_to_guest: Optional[str] = Field(None, max_length=1000, description="Message to guest")
    
    # Payment requirement
    advance_payment_required: bool = Field(True, description="Require advance payment")
    advance_payment_percentage: Decimal = Field(
        Decimal("20.00"),
        ge=0,
        le=100,
        description="Advance payment %"
    )


class ApprovalResponse(BaseSchema):
    """Booking approval response"""
    booking_id: UUID
    booking_reference: str
    
    status: str = Field("approved", description="New status")
    
    # Assignment details
    room_number: str
    bed_number: str
    
    # Final amounts
    monthly_rent: Decimal
    security_deposit: Decimal
    advance_amount: Decimal
    total_amount: Decimal
    
    # Dates
    approved_at: datetime
    check_in_date: date
    
    # Next steps
    payment_pending: bool
    payment_deadline: Optional[datetime]
    
    message: str


class RejectionRequest(BaseCreateSchema):
    """Reject booking request"""
    booking_id: UUID = Field(..., description="Booking ID to reject")
    rejection_reason: str = Field(..., min_length=10, max_length=500, description="Reason for rejection")
    
    # Suggest alternatives
    suggest_alternative_dates: bool = Field(False)
    alternative_check_in_dates: Optional[list[date]] = Field(None, max_items=3)
    
    suggest_alternative_room_types: bool = Field(False)
    alternative_room_types: Optional[list[str]] = None
    
    # Message to guest
    message_to_guest: Optional[str] = Field(None, max_length=1000)


class BulkApprovalRequest(BaseCreateSchema):
    """Approve multiple bookings"""
    booking_ids: list[UUID] = Field(..., min_items=1, description="Booking IDs to approve")
    
    # Common settings
    auto_assign_rooms: bool = Field(True, description="Auto-assign available rooms")
    send_notifications: bool = Field(True, description="Send approval notifications")


class ApprovalSettings(BaseSchema):
    """Hostel booking approval settings"""
    hostel_id: UUID
    
    auto_approve_enabled: bool = Field(False, description="Auto-approve bookings")
    auto_approve_conditions: dict = Field(
        default_factory=dict,
        description="Conditions for auto-approval"
    )
    
    approval_expiry_hours: int = Field(48, ge=1, le=168, description="Hours to respond to booking")
    
    require_advance_payment: bool = Field(True)
    advance_payment_percentage: Decimal = Field(Decimal("20.00"), ge=0, le=100)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_assignment.py ---
"""
Booking room and bed assignment schemas
"""
from datetime import date
from typing import Optional, List
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class RoomAssignment(BaseSchema):
    """Room assignment for booking"""
    booking_id: UUID
    booking_reference: str
    
    hostel_id: UUID
    room_id: UUID
    room_number: str
    room_type: str
    
    assigned_by: UUID
    assigned_by_name: str
    assigned_at: datetime
    
    check_in_date: date


class BedAssignment(BaseSchema):
    """Bed assignment for booking"""
    booking_id: UUID
    booking_reference: str
    
    room_id: UUID
    room_number: str
    bed_id: UUID
    bed_number: str
    
    assigned_by: UUID
    assigned_by_name: str
    assigned_at: datetime


class AssignmentRequest(BaseCreateSchema):
    """Assign room and bed to booking"""
    booking_id: UUID = Field(..., description="Booking ID")
    room_id: UUID = Field(..., description="Room to assign")
    bed_id: UUID = Field(..., description="Bed to assign")
    
    # Override check-in date if needed
    override_check_in_date: Optional[date] = Field(None, description="Override preferred check-in date")
    
    notes: Optional[str] = Field(None, max_length=500, description="Assignment notes")


class BulkAssignmentRequest(BaseCreateSchema):
    """Bulk assign rooms to multiple bookings"""
    assignments: List["SingleAssignment"] = Field(..., min_items=1, description="List of assignments")
    
    auto_approve: bool = Field(False, description="Auto-approve after assignment")


class SingleAssignment(BaseSchema):
    """Single assignment in bulk operation"""
    booking_id: UUID
    room_id: UUID
    bed_id: UUID


class AssignmentResponse(BaseSchema):
    """Assignment response"""
    booking_id: UUID
    booking_reference: str
    
    room_assigned: bool
    room_number: Optional[str]
    bed_number: Optional[str]
    
    message: str
    next_steps: List[str]


class ReassignmentRequest(BaseCreateSchema):
    """Reassign booking to different room/bed"""
    booking_id: UUID
    current_room_id: UUID
    new_room_id: UUID
    new_bed_id: UUID
    
    reason: str = Field(..., min_length=10, max_length=500)
    notify_guest: bool = Field(True)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_base.py ---
"""
Booking base schemas
"""
from datetime import date
from decimal import Decimal
from typing import Optional
from pydantic import Field, field_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseUpdateSchema, BaseSchema
from app.schemas.common.enums import BookingStatus, RoomType, BookingSource


class BookingBase(BaseSchema):
    """Base booking schema"""
    visitor_id: UUID = Field(..., description="Visitor/guest making booking")
    hostel_id: UUID = Field(..., description="Hostel being booked")
    
    # Booking details
    room_type_requested: RoomType = Field(..., description="Requested room type")
    preferred_check_in_date: date = Field(..., description="Preferred check-in date")
    stay_duration_months: int = Field(..., ge=1, le=24, description="Stay duration in months")
    
    # Pricing
    quoted_rent_monthly: Decimal = Field(..., ge=0, description="Quoted monthly rent")
    total_amount: Decimal = Field(..., ge=0, description="Total amount")
    security_deposit: Decimal = Field(Decimal("0.00"), ge=0, description="Security deposit")
    advance_amount: Decimal = Field(Decimal("0.00"), ge=0, description="Advance payment amount")
    
    # Special requests
    special_requests: Optional[str] = Field(None, max_length=1000, description="Special requests")
    dietary_preferences: Optional[str] = Field(None, max_length=255, description="Dietary preferences")
    has_vehicle: bool = Field(False, description="Has vehicle")
    vehicle_details: Optional[str] = Field(None, max_length=255, description="Vehicle details")
    
    # Source
    source: BookingSource = Field(BookingSource.WEBSITE, description="Booking source")
    referral_code: Optional[str] = Field(None, max_length=50, description="Referral code used")
    
    @field_validator('total_amount')
    @classmethod
    def validate_total_amount(cls, v: Decimal, info) -> Decimal:
        """Validate total amount calculation"""
        if 'quoted_rent_monthly' in info.data and 'stay_duration_months' in info.data:
            expected = info.data['quoted_rent_monthly'] * info.data['stay_duration_months']
            if abs(v - expected) > Decimal('0.01'):  # Allow small floating point differences
                raise ValueError(f'Total amount should be approximately {expected}')
        return v


class BookingCreate(BookingBase, BaseCreateSchema):
    """Create booking schema"""
    # Guest information embedded
    guest_name: str = Field(..., min_length=2, max_length=255)
    guest_email: str = Field(...)
    guest_phone: str = Field(..., pattern=r'^\+?[1-9]\d{9,14}$')
    
    # Optional ID proof
    guest_id_proof_type: Optional[str] = None
    guest_id_proof_number: Optional[str] = None
    
    # Emergency contact
    emergency_contact_name: Optional[str] = None
    emergency_contact_phone: Optional[str] = None
    emergency_contact_relation: Optional[str] = None
    
    # Institutional/employment
    institution_or_company: Optional[str] = None
    designation_or_course: Optional[str] = None


class BookingUpdate(BaseUpdateSchema):
    """Update booking schema"""
    room_type_requested: Optional[RoomType] = None
    preferred_check_in_date: Optional[date] = None
    stay_duration_months: Optional[int] = Field(None, ge=1, le=24)
    
    special_requests: Optional[str] = None
    dietary_preferences: Optional[str] = None
    has_vehicle: Optional[bool] = None
    vehicle_details: Optional[str] = None
    
    # Status updates (admin only)
    booking_status: Optional[BookingStatus] = None

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_calendar.py ---
"""
Booking calendar schemas
"""
from datetime import date, datetime
from typing import List, Dict, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import BookingStatus


class CalendarView(BaseSchema):
    """Calendar view of bookings"""
    hostel_id: UUID
    month: str = Field(..., description="Month in YYYY-MM format")
    
    # Calendar data
    days: Dict[str, "DayBookings"] = Field(..., description="Bookings by date")
    
    # Summary
    total_check_ins: int
    total_check_outs: int
    peak_occupancy_date: Optional[date]
    
    # Room availability summary
    available_rooms_by_date: Dict[str, int]


class DayBookings(BaseSchema):
    """Bookings for a specific day"""
    date: date
    
    check_ins: List["BookingEvent"] = Field(default_factory=list)
    check_outs: List["BookingEvent"] = Field(default_factory=list)
    pending_bookings: List["BookingEvent"] = Field(default_factory=list)
    
    available_beds: int
    total_beds: int


class BookingEvent(BaseSchema):
    """Booking event for calendar"""
    booking_id: UUID
    booking_reference: str
    guest_name: str
    room_number: Optional[str]
    room_type: str
    status: BookingStatus
    
    # For check-in events
    is_check_in: bool = Field(False)
    # For check-out events  
    is_check_out: bool = Field(False)


class CalendarEvent(BaseSchema):
    """Generic calendar event"""
    event_id: UUID
    event_type: str = Field(..., pattern="^(check_in|check_out|booking_request|maintenance)$")
    title: str
    start_date: date
    end_date: Optional[date]
    
    # Related entities
    booking_id: Optional[UUID] = None
    room_id: Optional[UUID] = None
    
    # Display
    color: str = Field(..., description="Color code for event")
    is_all_day: bool = Field(True)


class AvailabilityCalendar(BaseSchema):
    """Room availability calendar"""
    hostel_id: UUID
    room_id: Optional[UUID] = Field(None, description="Specific room or all rooms")
    month: str = Field(..., description="YYYY-MM")
    
    availability: Dict[str, "DayAvailability"]


class DayAvailability(BaseSchema):
    """Availability for a specific day"""
    date: date
    total_beds: int
    available_beds: int
    booked_beds: int
    is_fully_booked: bool
    
    # Bookings for this day
    active_bookings: List[UUID] = Field(default_factory=list)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_cancellation.py ---
"""
Booking cancellation schemas
"""
from datetime import datetime
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class CancellationRequest(BaseCreateSchema):
    """Request to cancel booking"""
    booking_id: UUID = Field(..., description="Booking ID to cancel")
    cancelled_by_role: str = Field(
        ...,
        pattern="^(visitor|admin|system)$",
        description="Who is cancelling"
    )
    
    cancellation_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for cancellation"
    )
    
    # Refund preference
    request_refund: bool = Field(True, description="Request refund of advance payment")
    
    # Additional details
    additional_comments: Optional[str] = Field(None, max_length=1000)


class CancellationResponse(BaseSchema):
    """Cancellation response"""
    booking_id: UUID
    booking_reference: str
    
    cancelled: bool
    cancelled_at: datetime
    
    # Refund information
    refund: "RefundCalculation"
    
    message: str
    confirmation_sent: bool


class RefundCalculation(BaseSchema):
    """Refund calculation details"""
    advance_paid: Decimal
    cancellation_charge: Decimal
    cancellation_charge_percentage: Decimal
    
    refundable_amount: Decimal
    refund_processing_time_days: int
    
    # Refund method
    refund_method: str = Field(..., description="How refund will be processed")
    
    # Breakdown
    breakdown: dict = Field(
        ...,
        description="Detailed refund breakdown"
    )


class CancellationPolicy(BaseSchema):
    """Hostel cancellation policy"""
    hostel_id: UUID
    
    # Charges based on timing
    cancellation_before_days: List["CancellationCharge"] = Field(
        ...,
        description="Cancellation charges based on days before check-in"
    )
    
    # Special conditions
    no_show_charge_percentage: Decimal = Field(
        Decimal("100.00"),
        description="Charge if guest doesn't show up"
    )
    
    refund_processing_days: int = Field(7, description="Days to process refund")
    
    policy_text: str = Field(..., description="Full policy text")


class CancellationCharge(BaseSchema):
    """Cancellation charge tier"""
    days_before_checkin: int = Field(..., description="Days before check-in")
    charge_percentage: Decimal = Field(..., ge=0, le=100, description="% of advance to charge")
    
    description: str


class BulkCancellation(BaseCreateSchema):
    """Cancel multiple bookings"""
    booking_ids: List[UUID] = Field(..., min_items=1)
    reason: str = Field(..., min_length=10)
    process_refunds: bool = Field(True)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_conversion.py ---
"""
Booking to student conversion schemas
"""
from datetime import date
from typing import Optional, List
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class ConvertToStudentRequest(BaseCreateSchema):
    """Convert confirmed booking to student profile"""
    booking_id: UUID = Field(..., description="Booking ID to convert")
    
    # Check-in details
    actual_check_in_date: date = Field(..., description="Actual check-in date")
    
    # Financial confirmation
    security_deposit_paid: bool = Field(..., description="Security deposit paid")
    first_month_rent_paid: bool = Field(..., description="First month rent paid")
    
    # Additional student details (if not in booking)
    student_id_number: Optional[str] = None
    guardian_address: Optional[str] = None
    
    # Documents uploaded
    id_proof_uploaded: bool = Field(False)
    photo_uploaded: bool = Field(False)
    
    notes: Optional[str] = Field(None, max_length=500, description="Conversion notes")


class ConversionResponse(BaseSchema):
    """Conversion response"""
    booking_id: UUID
    student_profile_id: UUID
    
    converted: bool
    conversion_date: date
    
    # Room assignment
    room_number: str
    bed_number: str
    
    # Financial setup
    monthly_rent: Decimal
    security_deposit: Decimal
    next_payment_due_date: date
    
    message: str
    next_steps: List[str]


class ConversionChecklist(BaseSchema):
    """Pre-conversion checklist"""
    booking_id: UUID
    booking_reference: str
    
    # Checklist items
    checks: List["ChecklistItem"]
    
    all_checks_passed: bool
    can_convert: bool
    
    missing_items: List[str]


class ChecklistItem(BaseSchema):
    """Individual checklist item"""
    item_name: str
    description: str
    is_completed: bool
    is_required: bool
    completed_at: Optional[datetime] = None
    notes: Optional[str] = None


class BulkConversion(BaseCreateSchema):
    """Convert multiple bookings to students"""
    booking_ids: List[UUID] = Field(..., min_items=1)
    conversion_date: date
    
    # Common financial confirmation
    all_deposits_paid: bool
    all_first_rents_paid: bool


class ConversionRollback(BaseCreateSchema):
    """Rollback conversion (emergency only)"""
    student_profile_id: UUID
    reason: str = Field(..., min_length=20, max_length=500)
    
    # What to do with data
    delete_student_profile: bool = Field(False)
    restore_booking: bool = Field(True)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_filters.py ---
"""
Booking filter and search schemas
"""
from datetime import date
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import BookingStatus, BookingSource, RoomType


class BookingFilterParams(BaseFilterSchema):
    """Booking filter parameters"""
    # Text search
    search: Optional[str] = Field(None, description="Search in reference, guest name, email, phone")
    
    # Hostel filter
    hostel_id: Optional[UUID] = None
    hostel_ids: Optional[List[UUID]] = None
    
    # Status filter
    status: Optional[BookingStatus] = None
    statuses: Optional[List[BookingStatus]] = None
    
    # Date filters
    booking_date_from: Optional[date] = None
    booking_date_to: Optional[date] = None
    check_in_date_from: Optional[date] = None
    check_in_date_to: Optional[date] = None
    
    # Room type
    room_type: Optional[RoomType] = None
    
    # Source
    source: Optional[BookingSource] = None
    
    # Payment status
    advance_paid: Optional[bool] = None
    
    # Conversion status
    converted_to_student: Optional[bool] = None
    
    # Expiry
    expiring_soon: Optional[bool] = Field(None, description="Bookings expiring in next 24 hours")
    expired: Optional[bool] = None


class BookingSearchRequest(BaseFilterSchema):
    """Booking search request"""
    query: str = Field(..., min_length=1, description="Search query")
    hostel_id: Optional[UUID] = None
    
    # Search fields
    search_in_reference: bool = Field(True)
    search_in_guest_name: bool = Field(True)
    search_in_email: bool = Field(True)
    search_in_phone: bool = Field(True)
    
    # Status filter
    status: Optional[BookingStatus] = None
    
    # Pagination
    page: int = Field(1, ge=1)
    page_size: int = Field(20, ge=1, le=100)


class BookingSortOptions(BaseFilterSchema):
    """Booking sorting options"""
    sort_by: str = Field(
        "booking_date",
        pattern="^(booking_date|check_in_date|guest_name|status|total_amount)$"
    )
    sort_order: str = Field("desc", pattern="^(asc|desc)$")


class BookingExportRequest(BaseFilterSchema):
    """Export bookings"""
    hostel_id: Optional[UUID] = None
    filters: Optional[BookingFilterParams] = None
    
    format: str = Field("csv", pattern="^(csv|excel|pdf)$")
    
    # Fields to include
    include_guest_details: bool = Field(True)
    include_payment_details: bool = Field(True)
    include_assignment_details: bool = Field(True)


class BookingAnalyticsRequest(BaseFilterSchema):
    """Booking analytics request"""
    hostel_id: Optional[UUID] = None
    date_from: date
    date_to: date
    
    group_by: str = Field("day", pattern="^(day|week|month)$")

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_modification.py ---
"""
Booking modification schemas
"""
from datetime import date
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema
from app.schemas.common.enums import RoomType


class ModificationRequest(BaseCreateSchema):
    """Request to modify booking"""
    booking_id: UUID = Field(..., description="Booking ID")
    
    # What to modify
    modify_check_in_date: bool = Field(False)
    new_check_in_date: Optional[date] = None
    
    modify_duration: bool = Field(False)
    new_duration_months: Optional[int] = Field(None, ge=1, le=24)
    
    modify_room_type: bool = Field(False)
    new_room_type: Optional[RoomType] = None
    
    # Reason
    modification_reason: str = Field(..., min_length=10, max_length=500)
    
    # Accept price difference
    accept_price_change: bool = Field(False, description="Accept if price changes")


class ModificationResponse(BaseSchema):
    """Modification response"""
    booking_id: UUID
    booking_reference: str
    
    # What changed
    modifications_applied: List[str]
    
    # Price impact
    original_total: Decimal
    new_total: Decimal
    price_difference: Decimal
    additional_payment_required: bool
    additional_amount: Decimal
    
    # Status
    requires_admin_approval: bool
    auto_approved: bool
    
    message: str


class DateChangeRequest(BaseCreateSchema):
    """Request to change check-in date"""
    booking_id: UUID
    new_check_in_date: date = Field(..., description="New desired check-in date")
    reason: str = Field(..., min_length=10, max_length=500)


class DurationChangeRequest(BaseCreateSchema):
    """Request to change stay duration"""
    booking_id: UUID
    new_duration_months: int = Field(..., ge=1, le=24)
    reason: str = Field(..., min_length=10, max_length=500)


class RoomTypeChangeRequest(BaseCreateSchema):
    """Request to change room type"""
    booking_id: UUID
    new_room_type: RoomType
    reason: str = Field(..., min_length=10, max_length=500)
    accept_price_difference: bool = Field(False)


class ModificationApproval(BaseCreateSchema):
    """Approve/reject modification request"""
    modification_request_id: UUID
    approved: bool
    
    # If approved
    adjusted_price: Optional[Decimal] = None
    
    # If rejected
    rejection_reason: Optional[str] = None
    
    admin_notes: Optional[str] = None

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_request.py ---
"""
Booking request schemas
"""
from datetime import date
from decimal import Decimal
from typing import Optional
from pydantic import EmailStr, Field, field_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import RoomType


class GuestInformation(BaseSchema):
    """Guest information for booking"""
    guest_name: str = Field(..., min_length=2, max_length=255, description="Full name")
    guest_email: EmailStr = Field(..., description="Email address")
    guest_phone: str = Field(..., pattern=r'^\+?[1-9]\d{9,14}$', description="Phone number")
    
    # ID proof (optional at booking, required at check-in)
    guest_id_proof_type: Optional[str] = Field(
        None,
        pattern="^(aadhaar|passport|driving_license|voter_id|pan_card)$"
    )
    guest_id_proof_number: Optional[str] = Field(None, max_length=50)
    
    # Emergency contact
    emergency_contact_name: Optional[str] = Field(None, max_length=255)
    emergency_contact_phone: Optional[str] = Field(None, pattern=r'^\+?[1-9]\d{9,14}$')
    emergency_contact_relation: Optional[str] = Field(None, max_length=50)
    
    # Institutional/employment details
    institution_or_company: Optional[str] = Field(None, max_length=255)
    designation_or_course: Optional[str] = Field(None, max_length=255)


class BookingRequest(BaseCreateSchema):
    """Complete booking request"""
    hostel_id: UUID = Field(..., description="Hostel ID")
    
    # Booking details
    room_type_requested: RoomType = Field(..., description="Desired room type")
    preferred_check_in_date: date = Field(..., description="Desired check-in date")
    stay_duration_months: int = Field(..., ge=1, le=24, description="Stay duration (1-24 months)")
    
    # Guest information
    guest_info: GuestInformation = Field(..., description="Guest details")
    
    # Special requests
    special_requests: Optional[str] = Field(None, max_length=1000)
    dietary_preferences: Optional[str] = Field(None, max_length=255)
    has_vehicle: bool = Field(False)
    vehicle_details: Optional[str] = Field(None, max_length=255)
    
    # Referral
    referral_code: Optional[str] = Field(None, max_length=50)
    
    @field_validator('preferred_check_in_date')
    @classmethod
    def validate_checkin_date(cls, v: date) -> date:
        """Validate check-in date is in future"""
        from datetime import date as date_type
        if v < date_type.today():
            raise ValueError('Check-in date must be in the future')
        return v


class BookingInquiry(BaseCreateSchema):
    """Simple inquiry (without full booking)"""
    hostel_id: UUID = Field(..., description="Hostel ID")
    
    # Contact info
    visitor_name: str = Field(..., min_length=2, max_length=255)
    visitor_email: EmailStr = Field(...)
    visitor_phone: str = Field(..., pattern=r'^\+?[1-9]\d{9,14}$')
    
    # Interest details
    room_type_interest: Optional[RoomType] = None
    preferred_check_in_date: Optional[date] = None
    message: Optional[str] = Field(None, max_length=1000)


class QuickBookingRequest(BaseCreateSchema):
    """Quick booking (minimal information)"""
    hostel_id: UUID
    room_type_requested: RoomType
    check_in_date: date
    duration_months: int = Field(..., ge=1, le=24)
    
    # Minimal guest info (rest can be added later)
    name: str = Field(..., min_length=2, max_length=255)
    email: EmailStr
    phone: str = Field(..., pattern=r'^\+?[1-9]\d{9,14}$')

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_response.py ---
"""
Booking response schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import BookingStatus, RoomType, BookingSource


class BookingResponse(BaseResponseSchema):
    """Booking response schema"""
    booking_reference: str
    visitor_id: UUID
    hostel_id: UUID
    hostel_name: str
    
    room_type_requested: RoomType
    preferred_check_in_date: date
    stay_duration_months: int
    expected_check_out_date: date
    
    # Guest info
    guest_name: str
    guest_email: str
    guest_phone: str
    
    # Pricing
    quoted_rent_monthly: Decimal
    total_amount: Decimal
    security_deposit: Decimal
    advance_amount: Decimal
    advance_paid: bool
    
    # Status
    booking_status: BookingStatus
    
    # Dates
    booking_date: datetime
    expires_at: Optional[datetime]


class BookingDetail(BaseResponseSchema):
    """Detailed booking information"""
    booking_reference: str
    visitor_id: UUID
    visitor_name: str
    
    hostel_id: UUID
    hostel_name: str
    hostel_city: str
    hostel_address: str
    hostel_phone: str
    
    # Requested details
    room_type_requested: RoomType
    preferred_check_in_date: date
    stay_duration_months: int
    expected_check_out_date: date
    
    # Assignment (if approved)
    room_id: Optional[UUID]
    room_number: Optional[str]
    bed_id: Optional[UUID]
    bed_number: Optional[str]
    
    # Guest information
    guest_name: str
    guest_email: str
    guest_phone: str
    guest_id_proof_type: Optional[str]
    guest_id_proof_number: Optional[str]
    
    # Emergency contact
    emergency_contact_name: Optional[str]
    emergency_contact_phone: Optional[str]
    emergency_contact_relation: Optional[str]
    
    # Institutional/employment
    institution_or_company: Optional[str]
    designation_or_course: Optional[str]
    
    # Special requests
    special_requests: Optional[str]
    dietary_preferences: Optional[str]
    has_vehicle: bool
    vehicle_details: Optional[str]
    
    # Pricing
    quoted_rent_monthly: Decimal
    total_amount: Decimal
    security_deposit: Decimal
    advance_amount: Decimal
    advance_paid: bool
    advance_payment_id: Optional[UUID]
    
    # Status workflow
    booking_status: BookingStatus
    approved_by: Optional[UUID]
    approved_by_name: Optional[str]
    approved_at: Optional[datetime]
    rejected_by: Optional[UUID]
    rejected_at: Optional[datetime]
    rejection_reason: Optional[str]
    
    # Cancellation
    cancelled_by: Optional[UUID]
    cancelled_at: Optional[datetime]
    cancellation_reason: Optional[str]
    
    # Conversion
    converted_to_student: bool
    student_profile_id: Optional[UUID]
    conversion_date: Optional[date]
    
    # Source
    source: BookingSource
    referral_code: Optional[str]
    
    # Timestamps
    booking_date: datetime
    expires_at: Optional[datetime]


class BookingListItem(BaseSchema):
    """Booking list item"""
    id: UUID
    booking_reference: str
    guest_name: str
    guest_phone: str
    
    hostel_name: str
    room_type_requested: str
    
    preferred_check_in_date: date
    stay_duration_months: int
    
    total_amount: Decimal
    advance_paid: bool
    
    booking_status: BookingStatus
    booking_date: datetime
    
    # Quick indicators
    is_urgent: bool = Field(..., description="Expiring soon")
    days_until_checkin: Optional[int]


class BookingConfirmation(BaseSchema):
    """Booking confirmation response"""
    booking_id: UUID
    booking_reference: str
    
    hostel_name: str
    room_type: str
    check_in_date: date
    
    total_amount: Decimal
    advance_amount: Decimal
    balance_amount: Decimal
    
    confirmation_message: str
    next_steps: list[str]
    
    # Contact
    hostel_contact_phone: str
    hostel_contact_email: Optional[str]

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_waitlist.py ---
"""
Booking waitlist schemas
"""
from datetime import date, datetime
from typing import Optional
from pydantic import Field, EmailStr
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema
from app.schemas.common.enums import RoomType, WaitlistStatus


class WaitlistRequest(BaseCreateSchema):
    """Add to waitlist when hostel is full"""
    hostel_id: UUID = Field(..., description="Hostel ID")
    visitor_id: UUID = Field(..., description="Visitor ID")
    
    room_type: RoomType = Field(..., description="Desired room type")
    preferred_check_in_date: date = Field(..., description="Desired check-in date")
    
    # Contact
    contact_email: EmailStr = Field(..., description="Email for notifications")
    contact_phone: str = Field(..., pattern=r'^\+?[1-9]\d{9,14}$')
    
    # Additional info
    notes: Optional[str] = Field(None, max_length=500)


class WaitlistResponse(BaseResponseSchema):
    """Waitlist entry response"""
    hostel_id: UUID
    hostel_name: str
    visitor_id: UUID
    
    room_type: RoomType
    preferred_check_in_date: date
    
    contact_email: str
    contact_phone: str
    
    priority: int = Field(..., description="Position in waitlist (1 = first)")
    status: WaitlistStatus
    
    estimated_availability_date: Optional[date] = Field(
        None,
        description="Estimated date when room might be available"
    )
    
    created_at: datetime


class WaitlistStatus(BaseSchema):
    """Waitlist status for visitor"""
    waitlist_id: UUID
    hostel_name: str
    room_type: str
    
    position: int = Field(..., description="Current position in queue")
    total_in_queue: int
    
    status: str = Field(..., pattern="^(waiting|notified|converted|expired|cancelled)$")
    
    # Notifications
    last_notification_sent: Optional[datetime]
    notification_count: int
    
    # Estimated wait
    estimated_wait_days: Optional[int]


class WaitlistNotification(BaseSchema):
    """Notification when room becomes available"""
    waitlist_id: UUID
    visitor_id: UUID
    hostel_id: UUID
    
    message: str
    available_room_id: UUID
    available_bed_id: UUID
    
    # Action required
    response_deadline: datetime = Field(..., description="Deadline to respond")
    
    # Booking link
    booking_link: str


class WaitlistConversion(BaseCreateSchema):
    """Convert waitlist to booking"""
    waitlist_id: UUID
    accept: bool = Field(..., description="Accept the available room")
    
    # If accepting
    proceed_with_booking: bool = Field(True)


class WaitlistCancellation(BaseCreateSchema):
    """Remove from waitlist"""
    waitlist_id: UUID
    cancellation_reason: Optional[str] = Field(None, max_length=500)


class WaitlistManagement(BaseSchema):
    """Manage waitlist (admin)"""
    hostel_id: UUID
    room_type: RoomType
    
    total_in_waitlist: int
    entries: List["WaitlistEntry"]


class WaitlistEntry(BaseSchema):
    """Individual waitlist entry"""
    waitlist_id: UUID
    visitor_name: str
    contact_email: str
    contact_phone: str
    
    preferred_check_in_date: date
    priority: int
    status: WaitlistStatus
    
    days_waiting: int
    created_at: datetime

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\__init__.py ---
"""
Booking schemas package
"""
from app.schemas.booking.booking_base import (
    BookingBase,
    BookingCreate,
    BookingUpdate
)
from app.schemas.booking.booking_response import (
    BookingResponse,
    BookingDetail,
    BookingListItem
)
from app.schemas.booking.booking_request import (
    BookingRequest,
    GuestInformation,
    BookingInquiry
)
from app.schemas.booking.booking_approval import (
    BookingApprovalRequest,
    ApprovalResponse,
    RejectionRequest
)
from app.schemas.booking.booking_calendar import (
    CalendarView,
    CalendarEvent,
    AvailabilityCalendar,
    DayBookings
)
from app.schemas.booking.booking_assignment import (
    RoomAssignment,
    BedAssignment,
    AssignmentRequest
)
from app.schemas.booking.booking_cancellation import (
    CancellationRequest,
    CancellationResponse,
    RefundCalculation
)
from app.schemas.booking.booking_modification import (
    ModificationRequest,
    ModificationResponse,
    DateChangeRequest
)
from app.schemas.booking.booking_waitlist import (
    WaitlistRequest,
    WaitlistResponse,
    WaitlistStatus,
    WaitlistNotification
)
from app.schemas.booking.booking_conversion import (
    ConvertToStudentRequest,
    ConversionResponse,
    ConversionChecklist
)
from app.schemas.booking.booking_filters import (
    BookingFilterParams,
    BookingSearchRequest,
    BookingSortOptions
)

__all__ = [
    # Base
    "BookingBase",
    "BookingCreate",
    "BookingUpdate",
    
    # Response
    "BookingResponse",
    "BookingDetail",
    "BookingListItem",
    
    # Request
    "BookingRequest",
    "GuestInformation",
    "BookingInquiry",
    
    # Approval
    "BookingApprovalRequest",
    "ApprovalResponse",
    "RejectionRequest",
    
    # Calendar
    "CalendarView",
    "CalendarEvent",
    "AvailabilityCalendar",
    "DayBookings",
    
    # Assignment
    "RoomAssignment",
    "BedAssignment",
    "AssignmentRequest",
    
    # Cancellation
    "CancellationRequest",
    "CancellationResponse",
    "RefundCalculation",
    
    # Modification
    "ModificationRequest",
    "ModificationResponse",
    "DateChangeRequest",
    
    # Waitlist
    "WaitlistRequest",
    "WaitlistResponse",
    "WaitlistStatus",
    "WaitlistNotification",
    
    # Conversion
    "ConvertToStudentRequest",
    "ConversionResponse",
    "ConversionChecklist",
    
    # Filters
    "BookingFilterParams",
    "BookingSearchRequest",
    "BookingSortOptions",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_approval.py ---
# --- File: app/schemas/booking/booking_approval.py ---
"""
Booking approval schemas for admin approval workflow.

This module defines schemas for approving, rejecting, and managing
booking approval workflows including bulk operations and settings.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "BookingApprovalRequest",
    "ApprovalResponse",
    "RejectionRequest",
    "BulkApprovalRequest",
    "ApprovalSettings",
]


class BookingApprovalRequest(BaseCreateSchema):
    """
    Request to approve a pending booking.
    
    Contains all information needed to approve a booking including
    room assignment, pricing confirmation, and payment requirements.
    """

    booking_id: UUID = Field(
        ...,
        description="Unique identifier of the booking to approve",
    )

    # Room Assignment
    room_id: UUID = Field(
        ...,
        description="ID of the room to assign to this booking",
    )
    bed_id: UUID = Field(
        ...,
        description="ID of the specific bed to assign",
    )

    # Date Confirmation/Adjustment
    approved_check_in_date: date = Field(
        ...,
        description="Confirmed or adjusted check-in date",
    )

    # Pricing Confirmation/Adjustment
    final_rent_monthly: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Final confirmed monthly rent amount",
    )
    final_security_deposit: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Final confirmed security deposit amount",
    )

    # Additional Charges
    processing_fee: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="One-time processing or booking fee",
    )

    # Notes and Communication
    admin_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Internal notes visible only to admins",
    )
    message_to_guest: Optional[str] = Field(
        None,
        max_length=1000,
        description="Message to be sent to guest with approval",
    )

    # Payment Requirements
    advance_payment_required: bool = Field(
        True,
        description="Whether advance payment is required before check-in",
    )
    advance_payment_percentage: Decimal = Field(
        Decimal("20.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of total amount required as advance (0-100)",
    )

    @field_validator("approved_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate approved check-in date is not in the past."""
        if v < date.today():
            raise ValueError(
                f"Approved check-in date ({v.strftime('%Y-%m-%d')}) "
                "cannot be in the past"
            )
        return v

    @field_validator("final_rent_monthly")
    @classmethod
    def validate_rent_amount(cls, v: Decimal) -> Decimal:
        """Validate rent amount is reasonable."""
        if v <= 0:
            raise ValueError("Monthly rent must be greater than zero")
        
        # Sanity check
        min_rent = Decimal("500.00")
        max_rent = Decimal("100000.00")
        
        if v < min_rent:
            raise ValueError(f"Monthly rent ({v}) is below minimum ({min_rent})")
        if v > max_rent:
            raise ValueError(f"Monthly rent ({v}) exceeds maximum ({max_rent})")
        
        return v

    @model_validator(mode="after")
    def validate_advance_payment(self) -> "BookingApprovalRequest":
        """Validate advance payment settings."""
        if self.advance_payment_required:
            if self.advance_payment_percentage <= 0:
                raise ValueError(
                    "Advance payment percentage must be greater than 0 when required"
                )
            if self.advance_payment_percentage > 100:
                raise ValueError(
                    "Advance payment percentage cannot exceed 100"
                )
        
        return self

    @field_validator("admin_notes", "message_to_guest")
    @classmethod
    def clean_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Clean optional text fields."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class ApprovalResponse(BaseSchema):
    """
    Response after booking approval.
    
    Contains approval confirmation and next steps for guest.
    """

    booking_id: UUID = Field(
        ...,
        description="Approved booking ID",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference number",
    )

    status: str = Field(
        "approved",
        description="New booking status after approval",
    )

    # Assignment Details
    room_number: str = Field(
        ...,
        description="Assigned room number",
    )
    bed_number: str = Field(
        ...,
        description="Assigned bed number",
    )

    # Financial Details
    monthly_rent: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Confirmed monthly rent",
    )
    security_deposit: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Security deposit amount",
    )
    advance_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Advance payment amount required",
    )
    total_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total booking amount",
    )

    # Dates
    approved_at: datetime = Field(
        ...,
        description="Approval timestamp",
    )
    check_in_date: date = Field(
        ...,
        description="Confirmed check-in date",
    )

    # Next Steps
    payment_pending: bool = Field(
        ...,
        description="Whether payment is still pending",
    )
    payment_deadline: Optional[datetime] = Field(
        None,
        description="Deadline for advance payment",
    )

    message: str = Field(
        ...,
        description="Confirmation message for guest",
    )


class RejectionRequest(BaseCreateSchema):
    """
    Request to reject a booking.
    
    Contains rejection reason and optional alternative suggestions.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID to reject",
    )
    rejection_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for rejection",
    )

    # Alternative Suggestions
    suggest_alternative_dates: bool = Field(
        False,
        description="Whether to suggest alternative check-in dates",
    )
    alternative_check_in_dates: Optional[List[date]] = Field(
        None,
        max_length=3,
        description="Up to 3 alternative check-in dates",
    )

    suggest_alternative_room_types: bool = Field(
        False,
        description="Whether to suggest alternative room types",
    )
    alternative_room_types: Optional[List[str]] = Field(
        None,
        max_length=3,
        description="Alternative room types available",
    )

    # Communication
    message_to_guest: Optional[str] = Field(
        None,
        max_length=1000,
        description="Personalized message to guest explaining rejection",
    )

    @field_validator("rejection_reason")
    @classmethod
    def validate_rejection_reason(cls, v: str) -> str:
        """Validate rejection reason is meaningful."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError(
                "Rejection reason must be at least 10 characters to be meaningful"
            )
        return v

    @model_validator(mode="after")
    def validate_alternative_dates(self) -> "RejectionRequest":
        """Validate alternative dates if provided."""
        if self.suggest_alternative_dates:
            if not self.alternative_check_in_dates:
                raise ValueError(
                    "Alternative check-in dates must be provided when "
                    "suggest_alternative_dates is True"
                )
            
            # Validate all dates are in future
            for alt_date in self.alternative_check_in_dates:
                if alt_date < date.today():
                    raise ValueError(
                        f"Alternative date {alt_date} cannot be in the past"
                    )
        
        return self

    @model_validator(mode="after")
    def validate_alternative_room_types(self) -> "RejectionRequest":
        """Validate alternative room types if provided."""
        if self.suggest_alternative_room_types:
            if not self.alternative_room_types:
                raise ValueError(
                    "Alternative room types must be provided when "
                    "suggest_alternative_room_types is True"
                )
        
        return self


class BulkApprovalRequest(BaseCreateSchema):
    """
    Approve multiple bookings in one operation.
    
    Used for batch processing of pending bookings.
    """

    booking_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of booking IDs to approve (max 50)",
    )

    # Common Settings
    auto_assign_rooms: bool = Field(
        True,
        description="Automatically assign available rooms based on preferences",
    )
    send_notifications: bool = Field(
        True,
        description="Send approval notifications to all guests",
    )

    # Common admin note for all approvals
    admin_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Common admin notes for all approvals",
    )

    @field_validator("booking_ids")
    @classmethod
    def validate_booking_ids(cls, v: List[UUID]) -> List[UUID]:
        """Validate booking IDs list."""
        if len(v) == 0:
            raise ValueError("At least one booking ID is required")
        
        if len(v) > 50:
            raise ValueError("Maximum 50 bookings can be approved at once")
        
        # Remove duplicates while preserving order
        seen = set()
        unique_ids = []
        for booking_id in v:
            if booking_id not in seen:
                seen.add(booking_id)
                unique_ids.append(booking_id)
        
        return unique_ids


class ApprovalSettings(BaseSchema):
    """
    Hostel-specific booking approval settings.
    
    Configures auto-approval rules and policies for a hostel.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )

    # Auto-Approval
    auto_approve_enabled: bool = Field(
        False,
        description="Enable automatic approval of bookings",
    )
    auto_approve_conditions: Dict = Field(
        default_factory=dict,
        description="Conditions that must be met for auto-approval (JSON)",
    )

    # Timing
    approval_expiry_hours: int = Field(
        48,
        ge=1,
        le=168,
        description="Hours to respond to booking before it expires (1-168)",
    )

    # Payment Settings
    require_advance_payment: bool = Field(
        True,
        description="Require advance payment after approval",
    )
    advance_payment_percentage: Decimal = Field(
        Decimal("20.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Default advance payment percentage (0-100)",
    )

    @field_validator("approval_expiry_hours")
    @classmethod
    def validate_expiry_hours(cls, v: int) -> int:
        """Validate approval expiry hours."""
        if v < 1:
            raise ValueError("Approval expiry must be at least 1 hour")
        if v > 168:  # 1 week
            raise ValueError("Approval expiry cannot exceed 168 hours (1 week)")
        return v

    @field_validator("auto_approve_conditions")
    @classmethod
    def validate_auto_approve_conditions(cls, v: Dict) -> Dict:
        """Validate auto-approve conditions structure."""
        # Could add validation for expected keys/structure
        # For now, just ensure it's a dict
        if not isinstance(v, dict):
            raise ValueError("Auto-approve conditions must be a dictionary")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_assignment.py ---
# --- File: app/schemas/booking/booking_assignment.py ---
"""
Booking room and bed assignment schemas.

This module defines schemas for assigning rooms and beds to bookings,
including bulk operations and reassignment workflows.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "RoomAssignment",
    "BedAssignment",
    "AssignmentRequest",
    "BulkAssignmentRequest",
    "SingleAssignment",
    "AssignmentResponse",
    "ReassignmentRequest",
]


class RoomAssignment(BaseSchema):
    """
    Room assignment record for a booking.
    
    Represents the assignment of a specific room to a booking.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking identifier",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference number",
    )

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    room_id: UUID = Field(
        ...,
        description="Assigned room identifier",
    )
    room_number: str = Field(
        ...,
        description="Assigned room number",
    )
    room_type: str = Field(
        ...,
        description="Room type",
    )

    assigned_by: UUID = Field(
        ...,
        description="Admin who made the assignment",
    )
    assigned_by_name: str = Field(
        ...,
        description="Name of admin who assigned",
    )
    assigned_at: datetime = Field(
        ...,
        description="Assignment timestamp",
    )

    check_in_date: date = Field(
        ...,
        description="Scheduled check-in date",
    )


class BedAssignment(BaseSchema):
    """
    Bed assignment record for a booking.
    
    Represents the assignment of a specific bed within a room.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking identifier",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference number",
    )

    room_id: UUID = Field(
        ...,
        description="Room identifier",
    )
    room_number: str = Field(
        ...,
        description="Room number",
    )
    bed_id: UUID = Field(
        ...,
        description="Assigned bed identifier",
    )
    bed_number: str = Field(
        ...,
        description="Assigned bed number",
    )

    assigned_by: UUID = Field(
        ...,
        description="Admin who made the assignment",
    )
    assigned_by_name: str = Field(
        ...,
        description="Name of admin who assigned",
    )
    assigned_at: datetime = Field(
        ...,
        description="Assignment timestamp",
    )


class AssignmentRequest(BaseCreateSchema):
    """
    Request to assign room and bed to a booking.
    
    Used by admins to manually assign specific room and bed
    to an approved booking.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID to assign room/bed to",
    )
    room_id: UUID = Field(
        ...,
        description="Room ID to assign",
    )
    bed_id: UUID = Field(
        ...,
        description="Bed ID to assign within the room",
    )

    # Optional Override
    override_check_in_date: Optional[date] = Field(
        None,
        description="Override the preferred check-in date if needed",
    )

    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Assignment notes for internal reference",
    )

    @field_validator("override_check_in_date")
    @classmethod
    def validate_override_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate override check-in date."""
        if v is not None and v < date.today():
            raise ValueError(
                f"Override check-in date ({v}) cannot be in the past"
            )
        return v

    @field_validator("notes")
    @classmethod
    def clean_notes(cls, v: Optional[str]) -> Optional[str]:
        """Clean notes field."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class SingleAssignment(BaseSchema):
    """
    Single assignment in bulk operation.
    
    Minimal schema for individual assignment within bulk request.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID",
    )
    room_id: UUID = Field(
        ...,
        description="Room ID to assign",
    )
    bed_id: UUID = Field(
        ...,
        description="Bed ID to assign",
    )


class BulkAssignmentRequest(BaseCreateSchema):
    """
    Bulk assign rooms to multiple bookings.
    
    Used for batch assignment operations.
    """

    assignments: List[SingleAssignment] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of room/bed assignments (max 100)",
    )

    auto_approve: bool = Field(
        False,
        description="Automatically approve bookings after assignment",
    )

    @field_validator("assignments")
    @classmethod
    def validate_assignments(cls, v: List[SingleAssignment]) -> List[SingleAssignment]:
        """Validate assignments list."""
        if len(v) == 0:
            raise ValueError("At least one assignment is required")
        
        if len(v) > 100:
            raise ValueError("Maximum 100 assignments allowed per bulk operation")
        
        # Check for duplicate booking IDs
        booking_ids = [a.booking_id for a in v]
        if len(booking_ids) != len(set(booking_ids)):
            raise ValueError("Duplicate booking IDs found in assignments list")
        
        return v


class AssignmentResponse(BaseSchema):
    """
    Response after assignment operation.
    
    Provides feedback on assignment success and next steps.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking identifier",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference",
    )

    room_assigned: bool = Field(
        ...,
        description="Whether room was successfully assigned",
    )
    room_number: Optional[str] = Field(
        None,
        description="Assigned room number if successful",
    )
    bed_number: Optional[str] = Field(
        None,
        description="Assigned bed number if successful",
    )

    message: str = Field(
        ...,
        description="Result message",
    )
    next_steps: List[str] = Field(
        default_factory=list,
        description="List of next steps required",
    )


class ReassignmentRequest(BaseCreateSchema):
    """
    Request to reassign booking to different room/bed.
    
    Used when guest needs to be moved to a different room
    or bed after initial assignment.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID to reassign",
    )
    current_room_id: UUID = Field(
        ...,
        description="Current room assignment",
    )
    new_room_id: UUID = Field(
        ...,
        description="New room to assign",
    )
    new_bed_id: UUID = Field(
        ...,
        description="New bed to assign",
    )

    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for reassignment",
    )
    notify_guest: bool = Field(
        True,
        description="Send notification to guest about reassignment",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reassignment reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError(
                "Reassignment reason must be at least 10 characters"
            )
        return v

    @field_validator("new_room_id")
    @classmethod
    def validate_different_room(cls, v: UUID, info) -> UUID:
        """Ensure new room is different from current."""
        current_room_id = info.data.get("current_room_id")
        if current_room_id and v == current_room_id:
            raise ValueError(
                "New room must be different from current room"
            )
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_base.py ---
# --- File: app/schemas/booking/booking_base.py ---
"""
Booking base schemas with comprehensive validation.

This module defines the core booking schemas including creation,
updates, and base validation logic for the booking lifecycle.
"""

from __future__ import annotations

from datetime import date, timedelta
from decimal import Decimal
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import BookingSource, BookingStatus, RoomType

__all__ = [
    "BookingBase",
    "BookingCreate",
    "BookingUpdate",
]


class BookingBase(BaseSchema):
    """
    Base booking schema with common fields and validation.
    
    Contains all core booking information including visitor details,
    hostel selection, room preferences, pricing, and special requirements.
    """

    visitor_id: UUID = Field(
        ...,
        description="Unique identifier of the visitor/guest making the booking",
    )
    hostel_id: UUID = Field(
        ...,
        description="Unique identifier of the hostel being booked",
    )

    # Booking Details
    room_type_requested: RoomType = Field(
        ...,
        description="Type of room requested (single, double, dormitory, etc.)",
    )
    preferred_check_in_date: date = Field(
        ...,
        description="Preferred check-in date",
    )
    stay_duration_months: int = Field(
        ...,
        ge=1,
        le=24,
        description="Duration of stay in months (1-24)",
    )

    # Pricing Information
    quoted_rent_monthly: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly rent amount quoted at time of booking",
    )
    total_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total amount for entire stay (monthly rent  duration)",
    )
    security_deposit: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Refundable security deposit amount",
    )
    advance_amount: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Advance payment amount required",
    )

    # Special Requirements
    special_requests: Optional[str] = Field(
        None,
        max_length=1000,
        description="Any special requests or requirements from the guest",
    )
    dietary_preferences: Optional[str] = Field(
        None,
        max_length=255,
        description="Dietary preferences (vegetarian, vegan, etc.)",
    )
    has_vehicle: bool = Field(
        False,
        description="Whether guest has a vehicle requiring parking",
    )
    vehicle_details: Optional[str] = Field(
        None,
        max_length=255,
        description="Vehicle details (type, registration number)",
    )

    # Booking Source
    source: BookingSource = Field(
        BookingSource.WEBSITE,
        description="Source of the booking (website, app, referral, etc.)",
    )
    referral_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Referral code used during booking",
    )

    @field_validator("preferred_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date is not in the past."""
        if v < date.today():
            raise ValueError(
                f"Check-in date ({v}) cannot be in the past. "
                f"Please select today or a future date."
            )
        
        # Warn if check-in is too far in the future (e.g., > 6 months)
        max_advance_days = 180  # 6 months
        if (v - date.today()).days > max_advance_days:
            # Note: This is a warning, not an error
            # Could be logged or handled differently in production
            pass
        
        return v

    @field_validator("quoted_rent_monthly")
    @classmethod
    def validate_rent_amount(cls, v: Decimal) -> Decimal:
        """Validate rent amount is reasonable."""
        if v <= 0:
            raise ValueError("Monthly rent must be greater than zero")
        
        # Sanity check: Rent should typically be between 1,000 and 1,00,000
        min_rent = Decimal("1000.00")
        max_rent = Decimal("100000.00")
        
        if v < min_rent:
            raise ValueError(
                f"Monthly rent ({v}) seems too low. Minimum is {min_rent}"
            )
        if v > max_rent:
            raise ValueError(
                f"Monthly rent ({v}) seems too high. Maximum is {max_rent}"
            )
        
        return v

    @model_validator(mode="after")
    def validate_total_amount(self) -> "BookingBase":
        """Validate total amount calculation."""
        expected_total = self.quoted_rent_monthly * self.stay_duration_months
        
        # Allow small floating-point differences (up to 1)
        tolerance = Decimal("1.00")
        difference = abs(self.total_amount - expected_total)
        
        if difference > tolerance:
            raise ValueError(
                f"Total amount ({self.total_amount}) does not match "
                f"expected calculation ({expected_total:.2f} = "
                f"{self.quoted_rent_monthly}  {self.stay_duration_months} months). "
                f"Difference: {difference:.2f}"
            )
        
        return self

    @model_validator(mode="after")
    def validate_advance_amount(self) -> "BookingBase":
        """Validate advance amount is reasonable."""
        if self.advance_amount > self.total_amount:
            raise ValueError(
                f"Advance amount ({self.advance_amount}) cannot exceed "
                f"total amount ({self.total_amount})"
            )
        
        # Typically, advance is 10-50% of total
        min_advance_percent = Decimal("0.10")  # 10%
        max_advance_percent = Decimal("0.50")  # 50%
        
        if self.advance_amount > 0:
            advance_percent = self.advance_amount / self.total_amount
            
            if advance_percent < min_advance_percent:
                # Warning: Less than typical advance
                pass
            elif advance_percent > max_advance_percent:
                raise ValueError(
                    f"Advance amount ({self.advance_amount}) is "
                    f"{advance_percent * 100:.1f}% of total, which exceeds "
                    f"the maximum allowed ({max_advance_percent * 100}%)"
                )
        
        return self

    @model_validator(mode="after")
    def validate_vehicle_details(self) -> "BookingBase":
        """Validate vehicle details are provided if has_vehicle is True."""
        if self.has_vehicle and not self.vehicle_details:
            raise ValueError(
                "Vehicle details must be provided when has_vehicle is True"
            )
        
        return self

    @field_validator("special_requests", "dietary_preferences")
    @classmethod
    def clean_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Clean and validate text fields."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v

    @property
    def expected_check_out_date(self) -> date:
        """Calculate expected check-out date based on duration."""
        # Approximate: 1 month = 30 days
        return self.preferred_check_in_date + timedelta(
            days=self.stay_duration_months * 30
        )

    @property
    def days_until_check_in(self) -> int:
        """Calculate days remaining until check-in."""
        return (self.preferred_check_in_date - date.today()).days

    @property
    def is_long_term_booking(self) -> bool:
        """Check if this is a long-term booking (>= 6 months)."""
        return self.stay_duration_months >= 6


class BookingCreate(BookingBase, BaseCreateSchema):
    """
    Schema for creating a new booking.
    
    Includes all base booking fields plus guest information
    that must be provided at booking time.
    """

    # Guest Information (embedded for convenience)
    guest_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Full name of the guest",
    )
    guest_email: EmailStr = Field(
        ...,
        description="Guest email address for communication",
    )
    guest_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Guest contact phone number (international format supported)",
    )

    # Optional ID Proof (can be provided later)
    guest_id_proof_type: Optional[str] = Field(
        None,
        pattern=r"^(aadhaar|passport|driving_license|voter_id|pan_card)$",
        description="Type of ID proof",
    )
    guest_id_proof_number: Optional[str] = Field(
        None,
        max_length=50,
        description="ID proof number",
    )

    # Emergency Contact Information
    emergency_contact_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Emergency contact person name",
    )
    emergency_contact_phone: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone number",
    )
    emergency_contact_relation: Optional[str] = Field(
        None,
        max_length=50,
        description="Relation to emergency contact",
    )

    # Institutional/Employment Details
    institution_or_company: Optional[str] = Field(
        None,
        max_length=255,
        description="Name of institution or company",
    )
    designation_or_course: Optional[str] = Field(
        None,
        max_length=255,
        description="Designation (if employed) or course (if student)",
    )

    @field_validator("guest_name")
    @classmethod
    def validate_guest_name(cls, v: str) -> str:
        """Validate and normalize guest name."""
        v = v.strip()
        
        if len(v) < 2:
            raise ValueError("Guest name must be at least 2 characters")
        
        # Check for minimum name parts (at least first name)
        name_parts = v.split()
        if len(name_parts) < 1:
            raise ValueError("Please provide at least a first name")
        
        # Check for invalid characters
        if any(char.isdigit() for char in v):
            raise ValueError("Guest name should not contain numbers")
        
        return v

    @field_validator("guest_phone")
    @classmethod
    def validate_guest_phone(cls, v: str) -> str:
        """Validate and normalize phone number."""
        # Remove spaces and dashes
        v = v.replace(" ", "").replace("-", "")
        
        # Ensure it's not too short
        if len(v) < 10:
            raise ValueError("Phone number must be at least 10 digits")
        
        return v

    @model_validator(mode="after")
    def validate_emergency_contact(self) -> "BookingCreate":
        """Validate emergency contact consistency."""
        has_emergency_name = self.emergency_contact_name is not None
        has_emergency_phone = self.emergency_contact_phone is not None
        
        # If one is provided, encourage both
        if has_emergency_name and not has_emergency_phone:
            raise ValueError(
                "Emergency contact phone is required when name is provided"
            )
        if has_emergency_phone and not has_emergency_name:
            raise ValueError(
                "Emergency contact name is required when phone is provided"
            )
        
        return self

    @model_validator(mode="after")
    def validate_id_proof(self) -> "BookingCreate":
        """Validate ID proof consistency."""
        has_id_type = self.guest_id_proof_type is not None
        has_id_number = self.guest_id_proof_number is not None
        
        if has_id_type and not has_id_number:
            raise ValueError("ID proof number is required when type is provided")
        if has_id_number and not has_id_type:
            raise ValueError("ID proof type is required when number is provided")
        
        return self


class BookingUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing booking.
    
    All fields are optional, allowing partial updates.
    Only admin-modifiable fields are included.
    """

    # Booking Details (modifiable)
    room_type_requested: Optional[RoomType] = Field(
        None,
        description="Update requested room type",
    )
    preferred_check_in_date: Optional[date] = Field(
        None,
        description="Update preferred check-in date",
    )
    stay_duration_months: Optional[int] = Field(
        None,
        ge=1,
        le=24,
        description="Update stay duration",
    )

    # Special Requirements
    special_requests: Optional[str] = Field(
        None,
        max_length=1000,
        description="Update special requests",
    )
    dietary_preferences: Optional[str] = Field(
        None,
        max_length=255,
        description="Update dietary preferences",
    )
    has_vehicle: Optional[bool] = Field(
        None,
        description="Update vehicle status",
    )
    vehicle_details: Optional[str] = Field(
        None,
        max_length=255,
        description="Update vehicle details",
    )

    # Status Updates (admin only)
    booking_status: Optional[BookingStatus] = Field(
        None,
        description="Update booking status (admin only)",
    )

    @field_validator("preferred_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate updated check-in date."""
        if v is not None and v < date.today():
            raise ValueError(
                f"Check-in date ({v}) cannot be in the past"
            )
        return v

    @field_validator("special_requests", "dietary_preferences")
    @classmethod
    def clean_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Clean text fields."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_calendar.py ---
# --- File: app/schemas/booking/booking_calendar.py ---
"""
Booking calendar schemas for calendar views and availability tracking.

This module defines schemas for calendar views, booking events,
and availability tracking across dates.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import BookingStatus

__all__ = [
    "CalendarView",
    "DayBookings",
    "BookingEvent",
    "CalendarEvent",
    "AvailabilityCalendar",
    "DayAvailability",
]


class BookingEvent(BaseSchema):
    """
    Individual booking event for calendar display.
    
    Represents a booking-related event (check-in, check-out, etc.)
    for calendar visualization.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking identifier",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference number",
    )
    guest_name: str = Field(
        ...,
        description="Guest name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Assigned room number if available",
    )
    room_type: str = Field(
        ...,
        description="Room type",
    )
    status: BookingStatus = Field(
        ...,
        description="Current booking status",
    )

    # Event Type Flags
    is_check_in: bool = Field(
        False,
        description="Whether this is a check-in event",
    )
    is_check_out: bool = Field(
        False,
        description="Whether this is a check-out event",
    )

    @computed_field
    @property
    def event_type_display(self) -> str:
        """Get display-friendly event type."""
        if self.is_check_in:
            return "Check-in"
        elif self.is_check_out:
            return "Check-out"
        else:
            return "Booking Request"

    @computed_field
    @property
    def status_color(self) -> str:
        """Get color code for status display."""
        color_map = {
            BookingStatus.PENDING: "#FFA500",  # Orange
            BookingStatus.APPROVED: "#4CAF50",  # Green
            BookingStatus.CONFIRMED: "#2196F3",  # Blue
            BookingStatus.CHECKED_IN: "#9C27B0",  # Purple
            BookingStatus.COMPLETED: "#607D8B",  # Gray
            BookingStatus.REJECTED: "#F44336",  # Red
            BookingStatus.CANCELLED: "#9E9E9E",  # Light Gray
            BookingStatus.EXPIRED: "#757575",  # Dark Gray
        }
        return color_map.get(self.status, "#000000")


class DayBookings(BaseSchema):
    """
    All bookings and events for a specific day.
    
    Aggregates check-ins, check-outs, and pending bookings
    for a single calendar day.
    """

    date: date = Field(
        ...,
        description="Date for this day's bookings",
    )

    # Events by Type
    check_ins: List[BookingEvent] = Field(
        default_factory=list,
        description="Check-in events for this day",
    )
    check_outs: List[BookingEvent] = Field(
        default_factory=list,
        description="Check-out events for this day",
    )
    pending_bookings: List[BookingEvent] = Field(
        default_factory=list,
        description="Pending booking requests for this day",
    )

    # Availability
    available_beds: int = Field(
        ...,
        ge=0,
        description="Number of beds available on this day",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total number of beds in hostel",
    )

    @computed_field
    @property
    def total_events(self) -> int:
        """Total number of events for this day."""
        return (
            len(self.check_ins)
            + len(self.check_outs)
            + len(self.pending_bookings)
        )

    @computed_field
    @property
    def occupancy_rate(self) -> float:
        """Calculate occupancy rate for this day."""
        if self.total_beds == 0:
            return 0.0
        occupied = self.total_beds - self.available_beds
        return round((occupied / self.total_beds) * 100, 2)

    @computed_field
    @property
    def is_fully_booked(self) -> bool:
        """Check if hostel is fully booked on this day."""
        return self.available_beds == 0

    @computed_field
    @property
    def is_high_activity_day(self) -> bool:
        """Check if this is a high-activity day (many events)."""
        return self.total_events >= 5


class CalendarView(BaseSchema):
    """
    Monthly calendar view of bookings.
    
    Provides a complete calendar view for a specific month
    showing all booking events and availability.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    month: str = Field(
        ...,
        pattern=r"^\d{4}-\d{2}$",
        description="Month in YYYY-MM format",
    )

    # Calendar Data (keyed by date string YYYY-MM-DD)
    days: Dict[str, DayBookings] = Field(
        ...,
        description="Bookings organized by date (YYYY-MM-DD as key)",
    )

    # Summary Statistics
    total_check_ins: int = Field(
        ...,
        ge=0,
        description="Total check-ins scheduled this month",
    )
    total_check_outs: int = Field(
        ...,
        ge=0,
        description="Total check-outs scheduled this month",
    )
    peak_occupancy_date: Optional[date] = Field(
        None,
        description="Date with highest occupancy this month",
    )

    # Room Availability by Date
    available_rooms_by_date: Dict[str, int] = Field(
        ...,
        description="Available rooms count by date (YYYY-MM-DD as key)",
    )

    @field_validator("month")
    @classmethod
    def validate_month_format(cls, v: str) -> str:
        """Validate month format."""
        try:
            year, month_num = v.split("-")
            year_int = int(year)
            month_int = int(month_num)
            
            if year_int < 2020 or year_int > 2100:
                raise ValueError("Year must be between 2020 and 2100")
            
            if month_int < 1 or month_int > 12:
                raise ValueError("Month must be between 01 and 12")
            
            # Normalize to ensure zero-padding
            return f"{year_int:04d}-{month_int:02d}"
            
        except ValueError as e:
            raise ValueError(f"Invalid month format: {e}")

    @computed_field
    @property
    def total_events(self) -> int:
        """Calculate total events for the month."""
        return self.total_check_ins + self.total_check_outs

    @computed_field
    @property
    def busiest_week_start(self) -> Optional[date]:
        """Find the start date of the busiest week."""
        if not self.days:
            return None
        
        # This is a simplified calculation
        # In production, you'd calculate this based on actual weekly totals
        return self.peak_occupancy_date


class CalendarEvent(BaseSchema):
    """
    Generic calendar event for various event types.
    
    Supports booking-related events as well as maintenance,
    announcements, and other calendar items.
    """

    event_id: UUID = Field(
        ...,
        description="Unique event identifier",
    )
    event_type: str = Field(
        ...,
        pattern=r"^(check_in|check_out|booking_request|maintenance|announcement|blocked)$",
        description="Type of event",
    )
    title: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Event title",
    )
    start_date: date = Field(
        ...,
        description="Event start date",
    )
    end_date: Optional[date] = Field(
        None,
        description="Event end date (for multi-day events)",
    )

    # Related Entities
    booking_id: Optional[UUID] = Field(
        None,
        description="Related booking ID if applicable",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Related room ID if applicable",
    )

    # Display Properties
    color: str = Field(
        ...,
        pattern=r"^#[0-9A-Fa-f]{6}$",
        description="Hex color code for event display",
    )
    is_all_day: bool = Field(
        True,
        description="Whether this is an all-day event",
    )

    @field_validator("end_date")
    @classmethod
    def validate_end_date(cls, v: Optional[date], info) -> Optional[date]:
        """Validate end date is after or equal to start date."""
        start_date = info.data.get("start_date")
        if v is not None and start_date is not None:
            if v < start_date:
                raise ValueError(
                    f"End date ({v}) cannot be before start date ({start_date})"
                )
        return v

    @computed_field
    @property
    def duration_days(self) -> int:
        """Calculate event duration in days."""
        if self.end_date is None:
            return 1
        return (self.end_date - self.start_date).days + 1

    @computed_field
    @property
    def is_past_event(self) -> bool:
        """Check if event is in the past."""
        event_end = self.end_date or self.start_date
        return event_end < date.today()


class DayAvailability(BaseSchema):
    """
    Bed availability for a specific day.
    
    Tracks available and booked beds for capacity planning.
    """

    date: date = Field(
        ...,
        description="Date for this availability snapshot",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total number of beds in hostel/room",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Number of beds currently available",
    )
    booked_beds: int = Field(
        ...,
        ge=0,
        description="Number of beds currently booked",
    )
    is_fully_booked: bool = Field(
        ...,
        description="Whether all beds are booked",
    )

    # Active Bookings
    active_bookings: List[UUID] = Field(
        default_factory=list,
        description="List of active booking IDs for this day",
    )

    @field_validator("booked_beds")
    @classmethod
    def validate_booked_beds(cls, v: int, info) -> int:
        """Validate booked beds doesn't exceed total."""
        total_beds = info.data.get("total_beds")
        if total_beds is not None and v > total_beds:
            raise ValueError(
                f"Booked beds ({v}) cannot exceed total beds ({total_beds})"
            )
        return v

    @field_validator("available_beds")
    @classmethod
    def validate_available_beds(cls, v: int, info) -> int:
        """Validate available beds calculation."""
        total_beds = info.data.get("total_beds")
        booked_beds = info.data.get("booked_beds")
        
        if total_beds is not None and booked_beds is not None:
            expected_available = total_beds - booked_beds
            if v != expected_available:
                raise ValueError(
                    f"Available beds ({v}) should equal "
                    f"total ({total_beds}) - booked ({booked_beds}) = {expected_available}"
                )
        
        return v

    @computed_field
    @property
    def occupancy_rate(self) -> float:
        """Calculate occupancy rate as percentage."""
        if self.total_beds == 0:
            return 0.0
        return round((self.booked_beds / self.total_beds) * 100, 2)

    @computed_field
    @property
    def availability_level(self) -> str:
        """
        Categorize availability level.
        
        Returns: "high", "medium", "low", or "full"
        """
        if self.is_fully_booked:
            return "full"
        
        availability_percentage = (self.available_beds / self.total_beds) * 100
        
        if availability_percentage >= 50:
            return "high"
        elif availability_percentage >= 20:
            return "medium"
        else:
            return "low"


class AvailabilityCalendar(BaseSchema):
    """
    Room availability calendar for a month.
    
    Provides daily availability tracking for capacity planning
    and booking management.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Specific room ID, or None for all rooms",
    )
    month: str = Field(
        ...,
        pattern=r"^\d{4}-\d{2}$",
        description="Month in YYYY-MM format",
    )

    # Availability by Date
    availability: Dict[str, DayAvailability] = Field(
        ...,
        description="Daily availability keyed by date (YYYY-MM-DD)",
    )

    @field_validator("month")
    @classmethod
    def validate_month_format(cls, v: str) -> str:
        """Validate and normalize month format."""
        try:
            year, month_num = v.split("-")
            year_int = int(year)
            month_int = int(month_num)
            
            if year_int < 2020 or year_int > 2100:
                raise ValueError("Year must be between 2020 and 2100")
            
            if month_int < 1 or month_int > 12:
                raise ValueError("Month must be between 01 and 12")
            
            return f"{year_int:04d}-{month_int:02d}"
            
        except ValueError as e:
            raise ValueError(f"Invalid month format: {e}")

    @computed_field
    @property
    def average_occupancy_rate(self) -> float:
        """Calculate average occupancy rate for the month."""
        if not self.availability:
            return 0.0
        
        total_rate = sum(day.occupancy_rate for day in self.availability.values())
        return round(total_rate / len(self.availability), 2)

    @computed_field
    @property
    def days_fully_booked(self) -> int:
        """Count number of days that are fully booked."""
        return sum(1 for day in self.availability.values() if day.is_fully_booked)

    @computed_field
    @property
    def peak_occupancy_date(self) -> Optional[str]:
        """Find date with highest occupancy."""
        if not self.availability:
            return None
        
        peak_day = max(
            self.availability.items(),
            key=lambda x: x[1].occupancy_rate
        )
        return peak_day[0]

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_cancellation.py ---
# --- File: app/schemas/booking/booking_cancellation.py ---
"""
Booking cancellation schemas.

This module defines schemas for cancelling bookings, calculating refunds,
and managing cancellation policies.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "CancellationRequest",
    "CancellationResponse",
    "RefundCalculation",
    "CancellationPolicy",
    "CancellationCharge",
    "BulkCancellation",
]


class CancellationRequest(BaseCreateSchema):
    """
    Request to cancel a booking.
    
    Contains cancellation details including who is cancelling,
    reason, and refund preferences.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID to cancel",
    )
    cancelled_by_role: str = Field(
        ...,
        pattern=r"^(visitor|admin|system)$",
        description="Role of person/system cancelling: visitor, admin, or system",
    )

    cancellation_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for cancellation",
    )

    # Refund Preference
    request_refund: bool = Field(
        True,
        description="Whether to request refund of advance payment",
    )

    # Additional Details
    additional_comments: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional comments or context",
    )

    @field_validator("cancellation_reason")
    @classmethod
    def validate_cancellation_reason(cls, v: str) -> str:
        """Validate cancellation reason is meaningful."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError(
                "Cancellation reason must be at least 10 characters"
            )
        return v

    @field_validator("cancelled_by_role")
    @classmethod
    def normalize_role(cls, v: str) -> str:
        """Normalize role value."""
        return v.lower()

    @field_validator("additional_comments")
    @classmethod
    def clean_comments(cls, v: Optional[str]) -> Optional[str]:
        """Clean additional comments."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class RefundCalculation(BaseSchema):
    """
    Refund calculation details.
    
    Provides transparent breakdown of refund amount calculation
    based on cancellation policy.
    """

    advance_paid: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total advance amount paid",
    )
    cancellation_charge: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Cancellation charge amount",
    )
    cancellation_charge_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Cancellation charge as percentage of advance",
    )

    refundable_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Final amount to be refunded",
    )
    refund_processing_time_days: int = Field(
        ...,
        ge=0,
        description="Expected number of days to process refund",
    )

    # Refund Method
    refund_method: str = Field(
        ...,
        description="Method of refund (bank transfer, original payment method, etc.)",
    )

    # Detailed Breakdown
    breakdown: Dict = Field(
        ...,
        description="Detailed refund calculation breakdown",
    )

    @field_validator("refundable_amount")
    @classmethod
    def validate_refundable_amount(cls, v: Decimal, info) -> Decimal:
        """Validate refundable amount calculation."""
        advance_paid = info.data.get("advance_paid")
        cancellation_charge = info.data.get("cancellation_charge")
        
        if advance_paid is not None and cancellation_charge is not None:
            expected = advance_paid - cancellation_charge
            if expected < 0:
                expected = Decimal("0.00")
            
            # Allow small floating point differences
            if abs(v - expected) > Decimal("0.01"):
                raise ValueError(
                    f"Refundable amount ({v}) does not match calculation "
                    f"({expected} = {advance_paid} - {cancellation_charge})"
                )
        
        return v


class CancellationResponse(BaseSchema):
    """
    Response after cancellation request.
    
    Confirms cancellation and provides refund details.
    """

    booking_id: UUID = Field(
        ...,
        description="Cancelled booking ID",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference number",
    )

    cancelled: bool = Field(
        ...,
        description="Whether cancellation was successful",
    )
    cancelled_at: datetime = Field(
        ...,
        description="Cancellation timestamp",
    )

    # Refund Information
    refund: RefundCalculation = Field(
        ...,
        description="Refund calculation details",
    )

    message: str = Field(
        ...,
        description="Cancellation confirmation message",
    )
    confirmation_sent: bool = Field(
        ...,
        description="Whether confirmation email/SMS was sent",
    )


class CancellationCharge(BaseSchema):
    """
    Cancellation charge tier based on timing.
    
    Defines cancellation charges based on how many days
    before check-in the cancellation occurs.
    """

    days_before_checkin: int = Field(
        ...,
        ge=0,
        description="Minimum days before check-in for this tier",
    )
    charge_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of advance to charge as cancellation fee",
    )

    description: str = Field(
        ...,
        description="Human-readable description of this tier",
    )


class CancellationPolicy(BaseSchema):
    """
    Hostel cancellation policy configuration.
    
    Defines cancellation charges and refund policies for a hostel.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )

    # Tiered Cancellation Charges
    cancellation_before_days: List[CancellationCharge] = Field(
        ...,
        description="List of cancellation charge tiers based on timing",
    )

    # Special Conditions
    no_show_charge_percentage: Decimal = Field(
        Decimal("100.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Charge if guest doesn't show up (typically 100%)",
    )

    # Processing
    refund_processing_days: int = Field(
        7,
        ge=1,
        le=30,
        description="Number of business days to process refund",
    )

    # Policy Documentation
    policy_text: str = Field(
        ...,
        description="Full cancellation policy text for display to users",
    )

    @field_validator("cancellation_before_days")
    @classmethod
    def validate_cancellation_tiers(
        cls,
        v: List[CancellationCharge],
    ) -> List[CancellationCharge]:
        """Validate cancellation charge tiers are properly ordered."""
        if not v:
            raise ValueError("At least one cancellation tier is required")
        
        # Sort by days_before_checkin descending
        sorted_tiers = sorted(v, key=lambda x: x.days_before_checkin, reverse=True)
        
        # Validate charges increase as check-in approaches
        for i in range(len(sorted_tiers) - 1):
            current = sorted_tiers[i]
            next_tier = sorted_tiers[i + 1]
            
            if current.charge_percentage > next_tier.charge_percentage:
                raise ValueError(
                    f"Cancellation charges must increase as check-in approaches. "
                    f"Tier at {current.days_before_checkin} days ({current.charge_percentage}%) "
                    f"has higher charge than tier at {next_tier.days_before_checkin} days "
                    f"({next_tier.charge_percentage}%)"
                )
        
        return sorted_tiers


class BulkCancellation(BaseCreateSchema):
    """
    Cancel multiple bookings in one operation.
    
    Used for batch cancellation (e.g., event cancellation,
    hostel closure, etc.).
    """

    booking_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of booking IDs to cancel (max 100)",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Common cancellation reason for all bookings",
    )
    process_refunds: bool = Field(
        True,
        description="Whether to process refunds for all cancellations",
    )

    @field_validator("booking_ids")
    @classmethod
    def validate_booking_ids(cls, v: List[UUID]) -> List[UUID]:
        """Validate booking IDs list."""
        if len(v) == 0:
            raise ValueError("At least one booking ID is required")
        
        if len(v) > 100:
            raise ValueError("Maximum 100 bookings can be cancelled at once")
        
        # Remove duplicates
        unique_ids = list(dict.fromkeys(v))
        
        return unique_ids

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate cancellation reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Cancellation reason must be at least 10 characters")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_conversion.py ---
# --- File: app/schemas/booking/booking_conversion.py ---
"""
Booking to student conversion schemas.

This module defines schemas for converting confirmed bookings
into active student profiles after check-in.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "ConvertToStudentRequest",
    "ConversionResponse",
    "ConversionChecklist",
    "ChecklistItem",
    "BulkConversion",
    "ConversionRollback",
]


class ConvertToStudentRequest(BaseCreateSchema):
    """
    Request to convert confirmed booking to student profile.
    
    Used after guest checks in to convert booking into
    active student residence.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID to convert",
    )

    # Check-in Confirmation
    actual_check_in_date: date = Field(
        ...,
        description="Actual check-in date (may differ from preferred)",
    )

    # Financial Confirmation
    security_deposit_paid: bool = Field(
        ...,
        description="Confirm security deposit has been paid",
    )
    first_month_rent_paid: bool = Field(
        ...,
        description="Confirm first month's rent has been paid",
    )

    # Additional Student Details (if not already in booking)
    student_id_number: Optional[str] = Field(
        None,
        max_length=50,
        description="Student ID or enrollment number",
    )
    guardian_address: Optional[str] = Field(
        None,
        max_length=500,
        description="Guardian's address",
    )

    # Document Verification
    id_proof_uploaded: bool = Field(
        False,
        description="ID proof document has been uploaded",
    )
    photo_uploaded: bool = Field(
        False,
        description="Student photo has been uploaded",
    )

    # Notes
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Conversion notes for internal reference",
    )

    @field_validator("actual_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date is not in the future."""
        if v > date.today():
            raise ValueError(
                f"Actual check-in date ({v.strftime('%Y-%m-%d')}) "
                "cannot be in the future"
            )
        
        # Warn if check-in is too far in the past (> 30 days)
        days_ago = (date.today() - v).days
        if days_ago > 30:
            # Log warning - might be data entry error
            pass
        
        return v

    @model_validator(mode="after")
    def validate_payments(self) -> "ConvertToStudentRequest":
        """Validate required payments are confirmed."""
        if not self.security_deposit_paid:
            raise ValueError(
                "Security deposit must be paid before conversion to student"
            )
        
        if not self.first_month_rent_paid:
            raise ValueError(
                "First month's rent must be paid before conversion to student"
            )
        
        return self

    @field_validator("notes")
    @classmethod
    def clean_notes(cls, v: Optional[str]) -> Optional[str]:
        """Clean notes field."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class ConversionResponse(BaseSchema):
    """
    Response after successful conversion to student.
    
    Provides confirmation and next steps for student onboarding.
    """

    booking_id: UUID = Field(
        ...,
        description="Original booking ID",
    )
    student_profile_id: UUID = Field(
        ...,
        description="Newly created student profile ID",
    )

    converted: bool = Field(
        ...,
        description="Whether conversion was successful",
    )
    conversion_date: date = Field(
        ...,
        description="Date of conversion",
    )

    # Assignment Details
    room_number: str = Field(
        ...,
        description="Assigned room number",
    )
    bed_number: str = Field(
        ...,
        description="Assigned bed number",
    )

    # Financial Setup
    monthly_rent: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly rent amount",
    )
    security_deposit: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Security deposit amount",
    )
    next_payment_due_date: date = Field(
        ...,
        description="Next rent payment due date",
    )

    message: str = Field(
        ...,
        description="Conversion confirmation message",
    )
    next_steps: List[str] = Field(
        ...,
        description="List of next steps for student/admin",
    )


class ChecklistItem(BaseSchema):
    """
    Individual checklist item for conversion validation.
    
    Represents a single requirement that must be met
    before conversion can proceed.
    """

    item_name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Name of checklist item",
    )
    description: str = Field(
        ...,
        description="Detailed description of requirement",
    )
    is_completed: bool = Field(
        ...,
        description="Whether this item is completed",
    )
    is_required: bool = Field(
        ...,
        description="Whether this item is mandatory for conversion",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="When this item was completed",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes about this item",
    )


class ConversionChecklist(BaseSchema):
    """
    Pre-conversion checklist validation.
    
    Checks all requirements before allowing conversion
    to student profile.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID being checked",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference",
    )

    # Checklist Items
    checks: List[ChecklistItem] = Field(
        ...,
        description="List of checklist items",
    )

    # Summary
    all_checks_passed: bool = Field(
        ...,
        description="Whether all required checks are completed",
    )
    can_convert: bool = Field(
        ...,
        description="Whether conversion can proceed",
    )

    missing_items: List[str] = Field(
        default_factory=list,
        description="List of missing/incomplete required items",
    )

    @field_validator("checks")
    @classmethod
    def validate_checks(cls, v: List[ChecklistItem]) -> List[ChecklistItem]:
        """Validate checklist has items."""
        if not v:
            raise ValueError("Checklist must have at least one item")
        return v


class BulkConversion(BaseCreateSchema):
    """
    Convert multiple bookings to students in bulk.
    
    Used for batch processing of check-ins.
    """

    booking_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of booking IDs to convert (max 50)",
    )
    conversion_date: date = Field(
        ...,
        description="Common check-in/conversion date for all",
    )

    # Common Financial Confirmation
    all_deposits_paid: bool = Field(
        ...,
        description="Confirm all security deposits are paid",
    )
    all_first_rents_paid: bool = Field(
        ...,
        description="Confirm all first month rents are paid",
    )

    @field_validator("booking_ids")
    @classmethod
    def validate_booking_ids(cls, v: List[UUID]) -> List[UUID]:
        """Validate booking IDs list."""
        if len(v) == 0:
            raise ValueError("At least one booking ID is required")
        
        if len(v) > 50:
            raise ValueError("Maximum 50 bookings can be converted at once")
        
        # Remove duplicates
        unique_ids = list(dict.fromkeys(v))
        
        return unique_ids

    @field_validator("conversion_date")
    @classmethod
    def validate_conversion_date(cls, v: date) -> date:
        """Validate conversion date."""
        if v > date.today():
            raise ValueError("Conversion date cannot be in the future")
        
        # Warn if too old
        days_ago = (date.today() - v).days
        if days_ago > 7:
            # Log warning
            pass
        
        return v

    @model_validator(mode="after")
    def validate_financial_confirmation(self) -> "BulkConversion":
        """Validate financial confirmations."""
        if not self.all_deposits_paid:
            raise ValueError(
                "All security deposits must be confirmed paid for bulk conversion"
            )
        
        if not self.all_first_rents_paid:
            raise ValueError(
                "All first month rents must be confirmed paid for bulk conversion"
            )
        
        return self


class ConversionRollback(BaseCreateSchema):
    """
    Rollback a student conversion (emergency only).
    
    Used in cases where conversion was done in error
    or needs to be reversed.
    """

    student_profile_id: UUID = Field(
        ...,
        description="Student profile ID to rollback",
    )
    reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Detailed reason for rollback (must be substantial)",
    )

    # Rollback Options
    delete_student_profile: bool = Field(
        False,
        description="Whether to delete the student profile",
    )
    restore_booking: bool = Field(
        True,
        description="Whether to restore original booking",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate rollback reason is substantial."""
        v = v.strip()
        if len(v) < 20:
            raise ValueError(
                "Rollback reason must be at least 20 characters "
                "and provide detailed justification"
            )
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_filters.py ---
# --- File: app/schemas/booking/booking_filters.py ---
"""
Booking filter and search schemas.

This module defines schemas for filtering, searching, sorting,
and exporting booking data.
"""

from __future__ import annotations

from datetime import date
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import BookingSource, BookingStatus, RoomType

__all__ = [
    "BookingFilterParams",
    "BookingSearchRequest",
    "BookingSortOptions",
    "BookingExportRequest",
    "BookingAnalyticsRequest",
]


class BookingFilterParams(BaseFilterSchema):
    """
    Comprehensive booking filter parameters.
    
    Supports filtering by various criteria including status,
    dates, hostel, room type, and more.
    """

    # Text Search
    search: Optional[str] = Field(
        None,
        max_length=255,
        description="Search in booking reference, guest name, email, or phone",
    )

    # Hostel Filters
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by specific hostel",
    )
    hostel_ids: Optional[List[UUID]] = Field(
        None,
        max_length=20,
        description="Filter by multiple hostels (max 20)",
    )

    # Status Filters
    status: Optional[BookingStatus] = Field(
        None,
        description="Filter by specific status",
    )
    statuses: Optional[List[BookingStatus]] = Field(
        None,
        max_length=10,
        description="Filter by multiple statuses",
    )

    # Date Filters
    booking_date_from: Optional[date] = Field(
        None,
        description="Filter bookings created from this date",
    )
    booking_date_to: Optional[date] = Field(
        None,
        description="Filter bookings created until this date",
    )
    check_in_date_from: Optional[date] = Field(
        None,
        description="Filter by check-in date from",
    )
    check_in_date_to: Optional[date] = Field(
        None,
        description="Filter by check-in date until",
    )

    # Room Type Filter
    room_type: Optional[RoomType] = Field(
        None,
        description="Filter by room type",
    )

    # Source Filter
    source: Optional[BookingSource] = Field(
        None,
        description="Filter by booking source",
    )

    # Payment Status
    advance_paid: Optional[bool] = Field(
        None,
        description="Filter by advance payment status",
    )

    # Conversion Status
    converted_to_student: Optional[bool] = Field(
        None,
        description="Filter by student conversion status",
    )

    # Urgency Filters
    expiring_soon: Optional[bool] = Field(
        None,
        description="Show only bookings expiring in next 24 hours",
    )
    expired: Optional[bool] = Field(
        None,
        description="Show only expired bookings",
    )

    @field_validator("booking_date_to")
    @classmethod
    def validate_booking_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate booking date range."""
        booking_date_from = info.data.get("booking_date_from")
        if v is not None and booking_date_from is not None:
            if v < booking_date_from:
                raise ValueError(
                    "booking_date_to must be after or equal to booking_date_from"
                )
        return v

    @field_validator("check_in_date_to")
    @classmethod
    def validate_check_in_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate check-in date range."""
        check_in_date_from = info.data.get("check_in_date_from")
        if v is not None and check_in_date_from is not None:
            if v < check_in_date_from:
                raise ValueError(
                    "check_in_date_to must be after or equal to check_in_date_from"
                )
        return v


class BookingSearchRequest(BaseFilterSchema):
    """
    Booking search request with pagination.
    
    Supports full-text search across booking fields.
    """

    query: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Search query string",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Limit search to specific hostel",
    )

    # Search Fields (which fields to search in)
    search_in_reference: bool = Field(
        True,
        description="Search in booking reference",
    )
    search_in_guest_name: bool = Field(
        True,
        description="Search in guest name",
    )
    search_in_email: bool = Field(
        True,
        description="Search in email address",
    )
    search_in_phone: bool = Field(
        True,
        description="Search in phone number",
    )

    # Status Filter
    status: Optional[BookingStatus] = Field(
        None,
        description="Limit search to specific status",
    )

    # Pagination
    page: int = Field(
        1,
        ge=1,
        description="Page number (1-indexed)",
    )
    page_size: int = Field(
        20,
        ge=1,
        le=100,
        description="Items per page (max 100)",
    )

    @field_validator("query")
    @classmethod
    def validate_query(cls, v: str) -> str:
        """Validate and clean search query."""
        v = v.strip()
        if len(v) == 0:
            raise ValueError("Search query cannot be empty")
        return v


class BookingSortOptions(BaseFilterSchema):
    """
    Booking sorting options.
    
    Defines how to sort booking results.
    """

    sort_by: str = Field(
        "booking_date",
        pattern=r"^(booking_date|check_in_date|guest_name|status|total_amount)$",
        description="Field to sort by",
    )
    sort_order: str = Field(
        "desc",
        pattern=r"^(asc|desc)$",
        description="Sort order: ascending or descending",
    )

    @field_validator("sort_by", "sort_order")
    @classmethod
    def normalize_sort_fields(cls, v: str) -> str:
        """Normalize sort field values."""
        return v.lower()


class BookingExportRequest(BaseFilterSchema):
    """
    Request to export bookings data.
    
    Supports multiple export formats with customizable fields.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Export bookings for specific hostel",
    )
    filters: Optional[BookingFilterParams] = Field(
        None,
        description="Apply filters to export",
    )

    # Export Format
    format: str = Field(
        "csv",
        pattern=r"^(csv|excel|pdf)$",
        description="Export format: csv, excel, or pdf",
    )

    # Fields to Include
    include_guest_details: bool = Field(
        True,
        description="Include guest personal details",
    )
    include_payment_details: bool = Field(
        True,
        description="Include payment information",
    )
    include_assignment_details: bool = Field(
        True,
        description="Include room/bed assignment details",
    )

    @field_validator("format")
    @classmethod
    def normalize_format(cls, v: str) -> str:
        """Normalize export format."""
        return v.lower()


class BookingAnalyticsRequest(BaseFilterSchema):
    """
    Request for booking analytics data.
    
    Generate analytics and reports for bookings within
    a specified date range.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Generate analytics for specific hostel (or all)",
    )
    date_from: date = Field(
        ...,
        description="Analytics start date",
    )
    date_to: date = Field(
        ...,
        description="Analytics end date",
    )

    # Grouping
    group_by: str = Field(
        "day",
        pattern=r"^(day|week|month)$",
        description="Group analytics by: day, week, or month",
    )

    @field_validator("date_to")
    @classmethod
    def validate_date_range(cls, v: date, info) -> date:
        """Validate date range."""
        date_from = info.data.get("date_from")
        if date_from is not None:
            if v < date_from:
                raise ValueError("date_to must be after or equal to date_from")
            
            # Limit to reasonable range (e.g., max 1 year)
            days_diff = (v - date_from).days
            if days_diff > 365:
                raise ValueError(
                    "Date range cannot exceed 365 days for analytics"
                )
        
        return v

    @field_validator("group_by")
    @classmethod
    def normalize_group_by(cls, v: str) -> str:
        """Normalize group_by value."""
        return v.lower()

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_modification.py ---
# --- File: app/schemas/booking/booking_modification.py ---
"""
Booking modification schemas.

This module defines schemas for modifying existing bookings including
date changes, duration changes, and room type changes.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import RoomType

__all__ = [
    "ModificationRequest",
    "ModificationResponse",
    "DateChangeRequest",
    "DurationChangeRequest",
    "RoomTypeChangeRequest",
    "ModificationApproval",
]


class ModificationRequest(BaseCreateSchema):
    """
    General booking modification request.
    
    Allows modification of multiple aspects of a booking
    in a single request.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID to modify",
    )

    # Check-in Date Modification
    modify_check_in_date: bool = Field(
        False,
        description="Whether to modify check-in date",
    )
    new_check_in_date: Optional[date] = Field(
        None,
        description="New check-in date if modifying",
    )

    # Duration Modification
    modify_duration: bool = Field(
        False,
        description="Whether to modify stay duration",
    )
    new_duration_months: Optional[int] = Field(
        None,
        ge=1,
        le=24,
        description="New duration in months if modifying",
    )

    # Room Type Modification
    modify_room_type: bool = Field(
        False,
        description="Whether to modify room type",
    )
    new_room_type: Optional[RoomType] = Field(
        None,
        description="New room type if modifying",
    )

    # Justification
    modification_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for modification request",
    )

    # Acknowledgment
    accept_price_change: bool = Field(
        False,
        description="Acknowledge and accept if modification results in price change",
    )

    @model_validator(mode="after")
    def validate_at_least_one_modification(self) -> "ModificationRequest":
        """Ensure at least one modification is requested."""
        if not (
            self.modify_check_in_date
            or self.modify_duration
            or self.modify_room_type
        ):
            raise ValueError(
                "At least one modification type must be selected "
                "(check-in date, duration, or room type)"
            )
        return self

    @model_validator(mode="after")
    def validate_modification_values(self) -> "ModificationRequest":
        """Validate that required values are provided for selected modifications."""
        if self.modify_check_in_date and self.new_check_in_date is None:
            raise ValueError(
                "new_check_in_date is required when modify_check_in_date is True"
            )
        
        if self.modify_duration and self.new_duration_months is None:
            raise ValueError(
                "new_duration_months is required when modify_duration is True"
            )
        
        if self.modify_room_type and self.new_room_type is None:
            raise ValueError(
                "new_room_type is required when modify_room_type is True"
            )
        
        return self

    @field_validator("new_check_in_date")
    @classmethod
    def validate_new_check_in_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate new check-in date."""
        if v is not None and v < date.today():
            raise ValueError(
                f"New check-in date ({v}) cannot be in the past"
            )
        return v

    @field_validator("modification_reason")
    @classmethod
    def validate_modification_reason(cls, v: str) -> str:
        """Validate modification reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError(
                "Modification reason must be at least 10 characters"
            )
        return v


class ModificationResponse(BaseSchema):
    """
    Response to modification request.
    
    Provides details about what was changed and pricing impact.
    """

    booking_id: UUID = Field(
        ...,
        description="Modified booking ID",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference",
    )

    # Modifications Applied
    modifications_applied: List[str] = Field(
        ...,
        description="List of modifications that were applied",
    )

    # Pricing Impact
    original_total: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Original total amount",
    )
    new_total: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="New total amount after modifications",
    )
    price_difference: Decimal = Field(
        ...,
        decimal_places=2,
        description="Price difference (positive = increase, negative = decrease)",
    )
    additional_payment_required: bool = Field(
        ...,
        description="Whether additional payment is required",
    )
    additional_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Additional amount to be paid if increased",
    )

    # Approval Status
    requires_admin_approval: bool = Field(
        ...,
        description="Whether modification requires admin approval",
    )
    auto_approved: bool = Field(
        ...,
        description="Whether modification was automatically approved",
    )

    message: str = Field(
        ...,
        description="Result message",
    )


class DateChangeRequest(BaseCreateSchema):
    """
    Specific request to change check-in date.
    
    Simplified schema for date-only modifications.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID",
    )
    new_check_in_date: date = Field(
        ...,
        description="New desired check-in date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for date change",
    )

    @field_validator("new_check_in_date")
    @classmethod
    def validate_new_date(cls, v: date) -> date:
        """Validate new check-in date."""
        if v < date.today():
            raise ValueError(
                f"New check-in date ({v.strftime('%Y-%m-%d')}) cannot be in the past"
            )
        return v

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Reason must be at least 10 characters")
        return v


class DurationChangeRequest(BaseCreateSchema):
    """
    Specific request to change stay duration.
    
    Simplified schema for duration-only modifications.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID",
    )
    new_duration_months: int = Field(
        ...,
        ge=1,
        le=24,
        description="New stay duration in months (1-24)",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for duration change",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Reason must be at least 10 characters")
        return v


class RoomTypeChangeRequest(BaseCreateSchema):
    """
    Specific request to change room type.
    
    Simplified schema for room type-only modifications.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID",
    )
    new_room_type: RoomType = Field(
        ...,
        description="New desired room type",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for room type change",
    )
    accept_price_difference: bool = Field(
        False,
        description="Accept price difference if room type has different pricing",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Reason must be at least 10 characters")
        return v


class ModificationApproval(BaseCreateSchema):
    """
    Admin approval/rejection of modification request.
    
    Used when modification requires manual admin review.
    """

    modification_request_id: UUID = Field(
        ...,
        description="Modification request ID",
    )
    approved: bool = Field(
        ...,
        description="Whether to approve (True) or reject (False) the modification",
    )

    # If Approved
    adjusted_price: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Adjusted price if admin wants to override calculated price",
    )

    # If Rejected
    rejection_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for rejection if not approved",
    )

    # Admin Notes
    admin_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Internal admin notes about the decision",
    )

    @model_validator(mode="after")
    def validate_approval_fields(self) -> "ModificationApproval":
        """Validate approval-specific fields."""
        if not self.approved and not self.rejection_reason:
            raise ValueError(
                "rejection_reason is required when modification is rejected"
            )
        
        return self

    @field_validator("rejection_reason")
    @classmethod
    def validate_rejection_reason(cls, v: Optional[str]) -> Optional[str]:
        """Validate rejection reason if provided."""
        if v is not None:
            v = v.strip()
            if len(v) < 10:
                raise ValueError(
                    "Rejection reason must be at least 10 characters if provided"
                )
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_request.py ---
# --- File: app/schemas/booking/booking_request.py ---
"""
Booking request schemas for initiating bookings.

This module defines schemas for various types of booking requests
including full bookings, inquiries, and quick bookings.
"""

from __future__ import annotations

from datetime import date
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import RoomType

__all__ = [
    "GuestInformation",
    "BookingRequest",
    "BookingInquiry",
    "QuickBookingRequest",
]


class GuestInformation(BaseSchema):
    """
    Guest information schema for bookings.
    
    Contains all personal, contact, and background information
    about the guest making the booking.
    """

    # Basic Information
    guest_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Full name of the guest",
    )
    guest_email: EmailStr = Field(
        ...,
        description="Email address for communication and booking confirmations",
    )
    guest_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact phone number (with optional country code)",
    )

    # ID Proof (optional at booking, required at check-in)
    guest_id_proof_type: Optional[str] = Field(
        None,
        pattern=r"^(aadhaar|passport|driving_license|voter_id|pan_card)$",
        description="Type of government-issued ID proof",
    )
    guest_id_proof_number: Optional[str] = Field(
        None,
        max_length=50,
        description="ID proof number/reference",
    )

    # Emergency Contact
    emergency_contact_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Name of emergency contact person",
    )
    emergency_contact_phone: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone number",
    )
    emergency_contact_relation: Optional[str] = Field(
        None,
        max_length=50,
        description="Relationship to emergency contact (parent, spouse, friend, etc.)",
    )

    # Institutional/Employment Details
    institution_or_company: Optional[str] = Field(
        None,
        max_length=255,
        description="Name of educational institution or employer",
    )
    designation_or_course: Optional[str] = Field(
        None,
        max_length=255,
        description="Job designation or course/program of study",
    )

    @field_validator("guest_name")
    @classmethod
    def validate_guest_name(cls, v: str) -> str:
        """Validate and clean guest name."""
        v = v.strip()
        
        if len(v) < 2:
            raise ValueError("Guest name must be at least 2 characters long")
        
        # Ensure at least one word
        if not v.split():
            raise ValueError("Guest name cannot be empty or only whitespace")
        
        # Check for numbers (names shouldn't contain digits)
        if any(char.isdigit() for char in v):
            raise ValueError("Guest name should not contain numbers")
        
        return v

    @field_validator("guest_phone", "emergency_contact_phone")
    @classmethod
    def validate_phone_number(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize phone number."""
        if v is None:
            return v
        
        # Remove common formatting characters
        v = v.replace(" ", "").replace("-", "").replace("(", "").replace(")", "")
        
        # Check minimum length
        if len(v) < 10:
            raise ValueError("Phone number must be at least 10 digits")
        
        return v

    @model_validator(mode="after")
    def validate_id_proof_consistency(self) -> "GuestInformation":
        """Ensure ID proof type and number are provided together."""
        has_type = self.guest_id_proof_type is not None
        has_number = self.guest_id_proof_number is not None
        
        if has_type != has_number:
            raise ValueError(
                "Both ID proof type and number must be provided together, or both omitted"
            )
        
        return self

    @model_validator(mode="after")
    def validate_emergency_contact_consistency(self) -> "GuestInformation":
        """Ensure emergency contact fields are provided together."""
        has_name = self.emergency_contact_name is not None
        has_phone = self.emergency_contact_phone is not None
        
        # If either is provided, both should be provided
        if has_name or has_phone:
            if not (has_name and has_phone):
                raise ValueError(
                    "Both emergency contact name and phone must be provided together"
                )
        
        return self


class BookingRequest(BaseCreateSchema):
    """
    Complete booking request schema.
    
    Contains all information needed to create a booking including
    hostel selection, room preferences, guest details, and special requirements.
    """

    hostel_id: UUID = Field(
        ...,
        description="Unique identifier of the hostel to book",
    )

    # Booking Preferences
    room_type_requested: RoomType = Field(
        ...,
        description="Desired type of room (single, double, dormitory, etc.)",
    )
    preferred_check_in_date: date = Field(
        ...,
        description="Desired check-in date",
    )
    stay_duration_months: int = Field(
        ...,
        ge=1,
        le=24,
        description="Intended stay duration in months (1-24)",
    )

    # Guest Information
    guest_info: GuestInformation = Field(
        ...,
        description="Detailed guest information",
    )

    # Special Requirements
    special_requests: Optional[str] = Field(
        None,
        max_length=1000,
        description="Any special requests or requirements (quiet room, ground floor, etc.)",
    )
    dietary_preferences: Optional[str] = Field(
        None,
        max_length=255,
        description="Dietary preferences or restrictions (vegetarian, vegan, allergies, etc.)",
    )
    has_vehicle: bool = Field(
        False,
        description="Whether guest has a vehicle and needs parking",
    )
    vehicle_details: Optional[str] = Field(
        None,
        max_length=255,
        description="Vehicle details if applicable (type, registration, etc.)",
    )

    # Referral
    referral_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Referral or promo code if applicable",
    )

    @field_validator("preferred_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date is in the future."""
        if v < date.today():
            raise ValueError(
                f"Check-in date ({v.strftime('%Y-%m-%d')}) cannot be in the past. "
                "Please select today or a future date."
            )
        
        # Warn about very far future dates (> 6 months)
        days_ahead = (v - date.today()).days
        if days_ahead > 180:
            # Log warning but don't reject
            # In production, this could trigger a notification
            pass
        
        return v

    @model_validator(mode="after")
    def validate_vehicle_consistency(self) -> "BookingRequest":
        """Ensure vehicle details are provided if has_vehicle is True."""
        if self.has_vehicle and not self.vehicle_details:
            raise ValueError(
                "Vehicle details must be provided when has_vehicle is True"
            )
        
        return self

    @field_validator("special_requests", "dietary_preferences", "vehicle_details")
    @classmethod
    def clean_optional_text(cls, v: Optional[str]) -> Optional[str]:
        """Clean optional text fields."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class BookingInquiry(BaseCreateSchema):
    """
    Simple inquiry schema for potential bookings.
    
    Used when a visitor wants to express interest without
    making a full booking commitment.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel of interest",
    )

    # Basic Contact Information
    visitor_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Name of the person inquiring",
    )
    visitor_email: EmailStr = Field(
        ...,
        description="Email address for follow-up",
    )
    visitor_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact phone number",
    )

    # Interest Details (all optional)
    room_type_interest: Optional[RoomType] = Field(
        None,
        description="Room type of interest",
    )
    preferred_check_in_date: Optional[date] = Field(
        None,
        description="Approximate check-in date if known",
    )
    message: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional message or questions",
    )

    @field_validator("visitor_name")
    @classmethod
    def validate_visitor_name(cls, v: str) -> str:
        """Validate visitor name."""
        v = v.strip()
        if len(v) < 2:
            raise ValueError("Name must be at least 2 characters")
        return v

    @field_validator("visitor_phone")
    @classmethod
    def validate_phone(cls, v: str) -> str:
        """Normalize phone number."""
        return v.replace(" ", "").replace("-", "")

    @field_validator("preferred_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate check-in date if provided."""
        if v is not None and v < date.today():
            raise ValueError("Check-in date cannot be in the past")
        return v


class QuickBookingRequest(BaseCreateSchema):
    """
    Quick booking schema with minimal required information.
    
    Used for fast-track bookings where detailed information
    can be collected later.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel to book",
    )
    room_type_requested: RoomType = Field(
        ...,
        description="Desired room type",
    )
    check_in_date: date = Field(
        ...,
        description="Check-in date",
    )
    duration_months: int = Field(
        ...,
        ge=1,
        le=24,
        description="Stay duration in months",
    )

    # Minimal Guest Information
    name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Guest name",
    )
    email: EmailStr = Field(
        ...,
        description="Guest email",
    )
    phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Guest phone",
    )

    @field_validator("check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date."""
        if v < date.today():
            raise ValueError(
                f"Check-in date ({v.strftime('%Y-%m-%d')}) must be today or in the future"
            )
        return v

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        """Validate and clean name."""
        v = v.strip()
        if len(v) < 2:
            raise ValueError("Name must be at least 2 characters")
        if any(char.isdigit() for char in v):
            raise ValueError("Name should not contain numbers")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_response.py ---
# --- File: app/schemas/booking/booking_response.py ---
"""
Booking response schemas for API responses.

This module defines response schemas for booking data including
basic responses, detailed information, list items, and confirmations.
"""

from __future__ import annotations

from datetime import date, datetime, timedelta
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import BookingSource, BookingStatus, RoomType

__all__ = [
    "BookingResponse",
    "BookingDetail",
    "BookingListItem",
    "BookingConfirmation",
]


class BookingResponse(BaseResponseSchema):
    """
    Standard booking response schema.
    
    Contains core booking information for API responses.
    """

    booking_reference: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Unique human-readable booking reference",
    )
    visitor_id: UUID = Field(
        ...,
        description="Visitor/guest identifier",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Name of the hostel",
    )

    # Booking Details
    room_type_requested: RoomType = Field(
        ...,
        description="Type of room requested",
    )
    preferred_check_in_date: date = Field(
        ...,
        description="Preferred check-in date",
    )
    stay_duration_months: int = Field(
        ...,
        ge=1,
        description="Stay duration in months",
    )
    expected_check_out_date: date = Field(
        ...,
        description="Calculated expected check-out date",
    )

    # Guest Information
    guest_name: str = Field(
        ...,
        description="Guest full name",
    )
    guest_email: str = Field(
        ...,
        description="Guest email address",
    )
    guest_phone: str = Field(
        ...,
        description="Guest contact phone",
    )

    # Pricing
    quoted_rent_monthly: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly rent amount",
    )
    total_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total booking amount",
    )
    security_deposit: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Security deposit amount",
    )
    advance_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Advance payment amount",
    )
    advance_paid: bool = Field(
        ...,
        description="Whether advance payment has been made",
    )

    # Status
    booking_status: BookingStatus = Field(
        ...,
        description="Current booking status",
    )

    # Timestamps
    booking_date: datetime = Field(
        ...,
        description="When booking was created",
    )
    expires_at: Optional[datetime] = Field(
        None,
        description="When booking expires if not confirmed",
    )

    @computed_field
    @property
    def days_until_check_in(self) -> int:
        """Calculate days until check-in."""
        return (self.preferred_check_in_date - date.today()).days

    @computed_field
    @property
    def is_expiring_soon(self) -> bool:
        """Check if booking is expiring within 24 hours."""
        if self.expires_at is None:
            return False
        return (self.expires_at - datetime.utcnow()).total_seconds() < 86400

    @computed_field
    @property
    def balance_amount(self) -> Decimal:
        """Calculate remaining balance after advance."""
        if self.advance_paid:
            return (self.total_amount - self.advance_amount).quantize(Decimal("0.01"))
        return self.total_amount


class BookingDetail(BaseResponseSchema):
    """
    Detailed booking information schema.
    
    Contains complete booking information including guest details,
    assignments, workflow status, and all related metadata.
    """

    booking_reference: str = Field(
        ...,
        description="Unique booking reference",
    )
    visitor_id: UUID = Field(
        ...,
        description="Visitor identifier",
    )
    visitor_name: str = Field(
        ...,
        description="Visitor/user name",
    )

    # Hostel Information
    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    hostel_city: str = Field(
        ...,
        description="Hostel city",
    )
    hostel_address: str = Field(
        ...,
        description="Hostel full address",
    )
    hostel_phone: str = Field(
        ...,
        description="Hostel contact phone",
    )

    # Booking Details
    room_type_requested: RoomType = Field(
        ...,
        description="Requested room type",
    )
    preferred_check_in_date: date = Field(
        ...,
        description="Preferred check-in date",
    )
    stay_duration_months: int = Field(
        ...,
        ge=1,
        description="Stay duration in months",
    )
    expected_check_out_date: date = Field(
        ...,
        description="Expected check-out date",
    )

    # Room Assignment (if approved)
    room_id: Optional[UUID] = Field(
        None,
        description="Assigned room ID (if approved)",
    )
    room_number: Optional[str] = Field(
        None,
        description="Assigned room number",
    )
    bed_id: Optional[UUID] = Field(
        None,
        description="Assigned bed ID (if approved)",
    )
    bed_number: Optional[str] = Field(
        None,
        description="Assigned bed number",
    )

    # Guest Information
    guest_name: str = Field(
        ...,
        description="Guest full name",
    )
    guest_email: str = Field(
        ...,
        description="Guest email",
    )
    guest_phone: str = Field(
        ...,
        description="Guest phone",
    )
    guest_id_proof_type: Optional[str] = Field(
        None,
        description="ID proof type",
    )
    guest_id_proof_number: Optional[str] = Field(
        None,
        description="ID proof number",
    )

    # Emergency Contact
    emergency_contact_name: Optional[str] = Field(
        None,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        None,
        description="Emergency contact phone",
    )
    emergency_contact_relation: Optional[str] = Field(
        None,
        description="Relation to emergency contact",
    )

    # Institutional/Employment
    institution_or_company: Optional[str] = Field(
        None,
        description="Institution or company name",
    )
    designation_or_course: Optional[str] = Field(
        None,
        description="Designation or course",
    )

    # Special Requirements
    special_requests: Optional[str] = Field(
        None,
        description="Special requests",
    )
    dietary_preferences: Optional[str] = Field(
        None,
        description="Dietary preferences",
    )
    has_vehicle: bool = Field(
        ...,
        description="Has vehicle",
    )
    vehicle_details: Optional[str] = Field(
        None,
        description="Vehicle details",
    )

    # Pricing
    quoted_rent_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Monthly rent quoted",
    )
    total_amount: Decimal = Field(
        ...,
        ge=0,
        description="Total amount",
    )
    security_deposit: Decimal = Field(
        ...,
        ge=0,
        description="Security deposit",
    )
    advance_amount: Decimal = Field(
        ...,
        ge=0,
        description="Advance amount",
    )
    advance_paid: bool = Field(
        ...,
        description="Advance payment status",
    )
    advance_payment_id: Optional[UUID] = Field(
        None,
        description="Advance payment transaction ID",
    )

    # Status Workflow
    booking_status: BookingStatus = Field(
        ...,
        description="Current booking status",
    )

    # Approval Details
    approved_by: Optional[UUID] = Field(
        None,
        description="Admin who approved booking",
    )
    approved_by_name: Optional[str] = Field(
        None,
        description="Approver name",
    )
    approved_at: Optional[datetime] = Field(
        None,
        description="Approval timestamp",
    )

    # Rejection Details
    rejected_by: Optional[UUID] = Field(
        None,
        description="Admin who rejected booking",
    )
    rejected_at: Optional[datetime] = Field(
        None,
        description="Rejection timestamp",
    )
    rejection_reason: Optional[str] = Field(
        None,
        description="Reason for rejection",
    )

    # Cancellation Details
    cancelled_by: Optional[UUID] = Field(
        None,
        description="Who cancelled the booking",
    )
    cancelled_at: Optional[datetime] = Field(
        None,
        description="Cancellation timestamp",
    )
    cancellation_reason: Optional[str] = Field(
        None,
        description="Reason for cancellation",
    )

    # Conversion to Student
    converted_to_student: bool = Field(
        ...,
        description="Whether booking was converted to student profile",
    )
    student_profile_id: Optional[UUID] = Field(
        None,
        description="Student profile ID if converted",
    )
    conversion_date: Optional[date] = Field(
        None,
        description="Date of conversion to student",
    )

    # Source
    source: BookingSource = Field(
        ...,
        description="Booking source",
    )
    referral_code: Optional[str] = Field(
        None,
        description="Referral code used",
    )

    # Timestamps
    booking_date: datetime = Field(
        ...,
        description="Booking creation timestamp",
    )
    expires_at: Optional[datetime] = Field(
        None,
        description="Booking expiry timestamp",
    )

    @computed_field
    @property
    def is_assigned(self) -> bool:
        """Check if room and bed are assigned."""
        return self.room_id is not None and self.bed_id is not None

    @computed_field
    @property
    def days_until_check_in(self) -> int:
        """Days remaining until check-in."""
        return (self.preferred_check_in_date - date.today()).days

    @computed_field
    @property
    def balance_amount(self) -> Decimal:
        """Calculate balance amount."""
        if self.advance_paid:
            return (self.total_amount - self.advance_amount).quantize(Decimal("0.01"))
        return self.total_amount


class BookingListItem(BaseSchema):
    """
    Booking list item for summary views.
    
    Optimized schema for listing multiple bookings with
    essential information only.
    """

    id: UUID = Field(
        ...,
        description="Booking ID",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference",
    )
    guest_name: str = Field(
        ...,
        description="Guest name",
    )
    guest_phone: str = Field(
        ...,
        description="Guest phone",
    )

    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    room_type_requested: str = Field(
        ...,
        description="Requested room type",
    )

    preferred_check_in_date: date = Field(
        ...,
        description="Check-in date",
    )
    stay_duration_months: int = Field(
        ...,
        ge=1,
        description="Duration in months",
    )

    total_amount: Decimal = Field(
        ...,
        ge=0,
        description="Total amount",
    )
    advance_paid: bool = Field(
        ...,
        description="Advance payment status",
    )

    booking_status: BookingStatus = Field(
        ...,
        description="Booking status",
    )
    booking_date: datetime = Field(
        ...,
        description="Booking date",
    )

    # Quick Indicators
    is_urgent: bool = Field(
        ...,
        description="Whether booking is expiring soon or requires urgent attention",
    )
    days_until_checkin: Optional[int] = Field(
        None,
        description="Days until check-in (if applicable)",
    )

    @computed_field
    @property
    def status_badge_color(self) -> str:
        """Get color code for status badge."""
        status_colors = {
            BookingStatus.PENDING: "warning",
            BookingStatus.APPROVED: "success",
            BookingStatus.CONFIRMED: "info",
            BookingStatus.CHECKED_IN: "primary",
            BookingStatus.COMPLETED: "secondary",
            BookingStatus.REJECTED: "danger",
            BookingStatus.CANCELLED: "dark",
            BookingStatus.EXPIRED: "muted",
        }
        return status_colors.get(self.booking_status, "secondary")


class BookingConfirmation(BaseSchema):
    """
    Booking confirmation response.
    
    Sent to guest after successful booking creation or approval.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking identifier",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference number",
    )

    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    room_type: str = Field(
        ...,
        description="Room type",
    )
    check_in_date: date = Field(
        ...,
        description="Check-in date",
    )

    total_amount: Decimal = Field(
        ...,
        ge=0,
        description="Total booking amount",
    )
    advance_amount: Decimal = Field(
        ...,
        ge=0,
        description="Advance payment required",
    )
    balance_amount: Decimal = Field(
        ...,
        ge=0,
        description="Balance amount to be paid",
    )

    confirmation_message: str = Field(
        ...,
        description="Confirmation message for guest",
    )
    next_steps: List[str] = Field(
        ...,
        description="List of next steps for guest",
    )

    # Contact Information
    hostel_contact_phone: str = Field(
        ...,
        description="Hostel contact phone",
    )
    hostel_contact_email: Optional[str] = Field(
        None,
        description="Hostel contact email",
    )

    @computed_field
    @property
    def payment_pending(self) -> bool:
        """Check if payment is still pending."""
        return self.balance_amount > Decimal("0")

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\booking_waitlist.py ---
# --- File: app/schemas/booking/booking_waitlist.py ---
"""
Booking waitlist schemas for managing waiting lists.

This module defines schemas for waitlist management when hostels
are fully booked, including notifications and conversions.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import List, Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import RoomType, WaitlistStatus

__all__ = [
    "WaitlistRequest",
    "WaitlistResponse",
    "WaitlistStatusInfo",
    "WaitlistNotification",
    "WaitlistConversion",
    "WaitlistCancellation",
    "WaitlistManagement",
    "WaitlistEntry",
]


class WaitlistRequest(BaseCreateSchema):
    """
    Request to add visitor to waitlist.
    
    Used when desired room type/date is not available
    and visitor wants to be notified when it becomes available.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID for waitlist",
    )
    visitor_id: UUID = Field(
        ...,
        description="Visitor ID requesting waitlist",
    )

    # Preferences
    room_type: RoomType = Field(
        ...,
        description="Desired room type",
    )
    preferred_check_in_date: date = Field(
        ...,
        description="Desired check-in date",
    )

    # Contact Information
    contact_email: EmailStr = Field(
        ...,
        description="Email address for waitlist notifications",
    )
    contact_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number for notifications",
    )

    # Additional Information
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes or preferences",
    )

    @field_validator("preferred_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date is in the future."""
        if v < date.today():
            raise ValueError(
                f"Preferred check-in date ({v.strftime('%Y-%m-%d')}) "
                "cannot be in the past"
            )
        return v

    @field_validator("contact_phone")
    @classmethod
    def normalize_phone(cls, v: str) -> str:
        """Normalize phone number."""
        return v.replace(" ", "").replace("-", "")

    @field_validator("notes")
    @classmethod
    def clean_notes(cls, v: Optional[str]) -> Optional[str]:
        """Clean notes field."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class WaitlistResponse(BaseResponseSchema):
    """
    Response after adding to waitlist.
    
    Confirms waitlist entry with position and estimated timeline.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    visitor_id: UUID = Field(
        ...,
        description="Visitor ID",
    )

    # Waitlist Details
    room_type: RoomType = Field(
        ...,
        description="Room type on waitlist",
    )
    preferred_check_in_date: date = Field(
        ...,
        description="Preferred check-in date",
    )

    # Contact
    contact_email: str = Field(
        ...,
        description="Contact email",
    )
    contact_phone: str = Field(
        ...,
        description="Contact phone",
    )

    # Position and Status
    priority: int = Field(
        ...,
        ge=1,
        description="Position in waitlist (1 = first in line)",
    )
    status: WaitlistStatus = Field(
        ...,
        description="Current waitlist status",
    )

    # Estimated Timeline
    estimated_availability_date: Optional[date] = Field(
        None,
        description="Estimated date when room might become available",
    )

    created_at: datetime = Field(
        ...,
        description="When added to waitlist",
    )

    @computed_field
    @property
    def days_on_waitlist(self) -> int:
        """Calculate days on waitlist."""
        return (datetime.utcnow() - self.created_at).days

    @computed_field
    @property
    def is_top_priority(self) -> bool:
        """Check if this is the top priority entry."""
        return self.priority == 1


class WaitlistStatusInfo(BaseSchema):
    """
    Current waitlist status for a visitor.
    
    Provides detailed status information about waitlist position
    and notifications.
    """

    waitlist_id: UUID = Field(
        ...,
        description="Waitlist entry ID",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    room_type: str = Field(
        ...,
        description="Room type",
    )

    # Position Information
    position: int = Field(
        ...,
        ge=1,
        description="Current position in queue (1 = next in line)",
    )
    total_in_queue: int = Field(
        ...,
        ge=1,
        description="Total number of people in this waitlist",
    )

    # Status
    status: str = Field(
        ...,
        pattern=r"^(waiting|notified|converted|expired|cancelled)$",
        description="Current waitlist status",
    )

    # Notification Tracking
    last_notification_sent: Optional[datetime] = Field(
        None,
        description="When last notification was sent",
    )
    notification_count: int = Field(
        0,
        ge=0,
        description="Number of notifications sent",
    )

    # Wait Estimation
    estimated_wait_days: Optional[int] = Field(
        None,
        ge=0,
        description="Estimated days until availability",
    )

    @computed_field
    @property
    def position_percentage(self) -> float:
        """Calculate position as percentage of queue."""
        if self.total_in_queue == 0:
            return 0.0
        return round((self.position / self.total_in_queue) * 100, 2)

    @computed_field
    @property
    def is_next_in_line(self) -> bool:
        """Check if visitor is next in line."""
        return self.position == 1


class WaitlistNotification(BaseSchema):
    """
    Notification when room becomes available.
    
    Sent to waitlisted visitor when their desired room/bed
    becomes available.
    """

    waitlist_id: UUID = Field(
        ...,
        description="Waitlist entry ID",
    )
    visitor_id: UUID = Field(
        ...,
        description="Visitor ID to notify",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )

    # Availability Details
    message: str = Field(
        ...,
        description="Notification message",
    )
    available_room_id: UUID = Field(
        ...,
        description="ID of available room",
    )
    available_bed_id: UUID = Field(
        ...,
        description="ID of available bed",
    )

    # Action Required
    response_deadline: datetime = Field(
        ...,
        description="Deadline to respond to this notification",
    )

    # Booking Link
    booking_link: str = Field(
        ...,
        description="Direct link to proceed with booking",
    )

    @computed_field
    @property
    def hours_until_deadline(self) -> float:
        """Calculate hours remaining until response deadline."""
        delta = self.response_deadline - datetime.utcnow()
        return round(delta.total_seconds() / 3600, 1)

    @computed_field
    @property
    def is_expiring_soon(self) -> bool:
        """Check if notification is expiring within 6 hours."""
        return self.hours_until_deadline <= 6


class WaitlistConversion(BaseCreateSchema):
    """
    Convert waitlist entry to booking.
    
    Visitor's response to availability notification.
    """

    waitlist_id: UUID = Field(
        ...,
        description="Waitlist entry ID",
    )
    accept: bool = Field(
        ...,
        description="Whether to accept the available room (True/False)",
    )

    # If Accepting
    proceed_with_booking: bool = Field(
        True,
        description="Whether to proceed with creating booking",
    )


class WaitlistCancellation(BaseCreateSchema):
    """
    Remove entry from waitlist.
    
    Visitor can cancel their waitlist entry at any time.
    """

    waitlist_id: UUID = Field(
        ...,
        description="Waitlist entry ID to cancel",
    )
    cancellation_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for cancelling waitlist entry",
    )

    @field_validator("cancellation_reason")
    @classmethod
    def clean_reason(cls, v: Optional[str]) -> Optional[str]:
        """Clean cancellation reason."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class WaitlistEntry(BaseSchema):
    """
    Individual waitlist entry for admin view.
    
    Detailed information about a single waitlist entry
    for management purposes.
    """

    waitlist_id: UUID = Field(
        ...,
        description="Waitlist entry ID",
    )
    visitor_name: str = Field(
        ...,
        description="Visitor name",
    )
    contact_email: str = Field(
        ...,
        description="Contact email",
    )
    contact_phone: str = Field(
        ...,
        description="Contact phone",
    )

    # Preferences
    preferred_check_in_date: date = Field(
        ...,
        description="Preferred check-in date",
    )
    priority: int = Field(
        ...,
        ge=1,
        description="Position in waitlist",
    )
    status: WaitlistStatus = Field(
        ...,
        description="Current status",
    )

    # Tracking
    days_waiting: int = Field(
        ...,
        ge=0,
        description="Number of days on waitlist",
    )
    created_at: datetime = Field(
        ...,
        description="When added to waitlist",
    )

    @computed_field
    @property
    def is_long_wait(self) -> bool:
        """Check if entry has been waiting a long time (>30 days)."""
        return self.days_waiting > 30


class WaitlistManagement(BaseSchema):
    """
    Waitlist management view for admins.
    
    Provides overview of all waitlist entries for a specific
    hostel and room type.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    room_type: RoomType = Field(
        ...,
        description="Room type for this waitlist",
    )

    # Summary
    total_in_waitlist: int = Field(
        ...,
        ge=0,
        description="Total number of entries in waitlist",
    )

    # Entries
    entries: List[WaitlistEntry] = Field(
        default_factory=list,
        description="List of waitlist entries ordered by priority",
    )

    @computed_field
    @property
    def average_wait_days(self) -> float:
        """Calculate average wait time in days."""
        if not self.entries:
            return 0.0
        
        total_days = sum(entry.days_waiting for entry in self.entries)
        return round(total_days / len(self.entries), 1)

    @computed_field
    @property
    def longest_wait_days(self) -> int:
        """Find longest wait time in days."""
        if not self.entries:
            return 0
        
        return max(entry.days_waiting for entry in self.entries)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\booking\__init__.py ---
# --- File: app/schemas/booking/__init__.py ---
"""
Booking schemas package.

This module exports all booking-related schemas for easy importing
across the application.
"""

from __future__ import annotations

from app.schemas.booking.booking_approval import (
    ApprovalResponse,
    ApprovalSettings,
    BookingApprovalRequest,
    BulkApprovalRequest,
    RejectionRequest,
)
from app.schemas.booking.booking_assignment import (
    AssignmentRequest,
    AssignmentResponse,
    BedAssignment,
    BulkAssignmentRequest,
    ReassignmentRequest,
    RoomAssignment,
    SingleAssignment,
)
from app.schemas.booking.booking_base import (
    BookingBase,
    BookingCreate,
    BookingUpdate,
)
from app.schemas.booking.booking_calendar import (
    AvailabilityCalendar,
    BookingEvent,
    CalendarEvent,
    CalendarView,
    DayAvailability,
    DayBookings,
)
from app.schemas.booking.booking_cancellation import (
    BulkCancellation,
    CancellationCharge,
    CancellationPolicy,
    CancellationRequest,
    CancellationResponse,
    RefundCalculation,
)
from app.schemas.booking.booking_conversion import (
    BulkConversion,
    ChecklistItem,
    ConversionChecklist,
    ConversionResponse,
    ConversionRollback,
    ConvertToStudentRequest,
)
from app.schemas.booking.booking_filters import (
    BookingAnalyticsRequest,
    BookingExportRequest,
    BookingFilterParams,
    BookingSearchRequest,
    BookingSortOptions,
)
from app.schemas.booking.booking_modification import (
    DateChangeRequest,
    DurationChangeRequest,
    ModificationApproval,
    ModificationRequest,
    ModificationResponse,
    RoomTypeChangeRequest,
)
from app.schemas.booking.booking_request import (
    BookingInquiry,
    BookingRequest,
    GuestInformation,
    QuickBookingRequest,
)
from app.schemas.booking.booking_response import (
    BookingConfirmation,
    BookingDetail,
    BookingListItem,
    BookingResponse,
)
from app.schemas.booking.booking_waitlist import (
    WaitlistCancellation,
    WaitlistConversion,
    WaitlistEntry,
    WaitlistManagement,
    WaitlistNotification,
    WaitlistRequest,
    WaitlistResponse,
    WaitlistStatusInfo,
)

__all__ = [
    # Base
    "BookingBase",
    "BookingCreate",
    "BookingUpdate",
    # Request
    "BookingRequest",
    "GuestInformation",
    "BookingInquiry",
    "QuickBookingRequest",
    # Response
    "BookingResponse",
    "BookingDetail",
    "BookingListItem",
    "BookingConfirmation",
    # Approval
    "BookingApprovalRequest",
    "ApprovalResponse",
    "RejectionRequest",
    "BulkApprovalRequest",
    "ApprovalSettings",
    # Assignment
    "RoomAssignment",
    "BedAssignment",
    "AssignmentRequest",
    "AssignmentResponse",
    "BulkAssignmentRequest",
    "SingleAssignment",
    "ReassignmentRequest",
    # Cancellation
    "CancellationRequest",
    "CancellationResponse",
    "RefundCalculation",
    "CancellationPolicy",
    "CancellationCharge",
    "BulkCancellation",
    # Modification
    "ModificationRequest",
    "ModificationResponse",
    "DateChangeRequest",
    "DurationChangeRequest",
    "RoomTypeChangeRequest",
    "ModificationApproval",
    # Calendar
    "CalendarView",
    "DayBookings",
    "BookingEvent",
    "CalendarEvent",
    "AvailabilityCalendar",
    "DayAvailability",
    # Waitlist
    "WaitlistRequest",
    "WaitlistResponse",
    "WaitlistStatusInfo",
    "WaitlistNotification",
    "WaitlistConversion",
    "WaitlistCancellation",
    "WaitlistManagement",
    "WaitlistEntry",
    # Conversion
    "ConvertToStudentRequest",
    "ConversionResponse",
    "ConversionChecklist",
    "ChecklistItem",
    "BulkConversion",
    "ConversionRollback",
    # Filters
    "BookingFilterParams",
    "BookingSearchRequest",
    "BookingSortOptions",
    "BookingExportRequest",
    "BookingAnalyticsRequest",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\common =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\common ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\common =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\base.py ---
# --- File: app/schemas/common/base.py ---
"""
Base schema classes with common fields and configurations.
"""

from __future__ import annotations

from datetime import datetime
from typing import Optional

from pydantic import BaseModel, ConfigDict, Field

__all__ = [
    "BaseSchema",
    "TimestampMixin",
    "SoftDeleteMixin",
    "UUIDMixin",
    "BaseDBSchema",
    "BaseCreateSchema",
    "BaseUpdateSchema",
    "BaseResponseSchema",
    "BaseFilterSchema",
]


class BaseSchema(BaseModel):
    """
    Base schema with common Pydantic configuration.

    All application-facing schemas should ideally inherit from this to ensure
    consistent behaviour (e.g. JSON encoders, validation, etc.).
    """

    model_config = ConfigDict(
        from_attributes=True,
        populate_by_name=True,
        # Keep enums as Enum instances to retain full type information;
        # callers can still access `.value` if needed.
        use_enum_values=False,
        arbitrary_types_allowed=True,
        str_strip_whitespace=True,
        validate_assignment=True,
        json_encoders={
            datetime: lambda v: v.isoformat(),
        },
    )


class TimestampMixin(BaseModel):
    """Mixin for timestamp fields."""

    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")


class SoftDeleteMixin(BaseModel):
    """Mixin for soft delete support."""

    deleted_at: Optional[datetime] = Field(None, description="Deletion timestamp")
    is_deleted: bool = Field(False, description="Soft delete flag")


class UUIDMixin(BaseModel):
    """Mixin for UUID primary key."""

    id: str = Field(..., description="Unique identifier")


class BaseDBSchema(BaseSchema, UUIDMixin, TimestampMixin):
    """Base schema for database entities with ID and timestamps."""
    pass


class BaseCreateSchema(BaseSchema):
    """Base schema for create operations."""
    pass


class BaseUpdateSchema(BaseSchema):
    """
    Base schema for update operations.

    Note:
        This base class does not itself make fields optional. Subclasses
        intended for partial updates should declare their fields as
        Optional[...] / with defaults as appropriate.
    """
    pass


class BaseResponseSchema(BaseDBSchema):
    """Base schema for API responses."""
    pass


class BaseFilterSchema(BaseSchema):
    """Base schema for filter parameters."""
    pass

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\enums.py ---
# --- File: app/schemas/common/enums.py ---
"""
All enumeration types used across the application.

These enums represent the core domain concepts for the hostel management
system (users, hostels, rooms, bookings, payments, complaints, etc.).
"""

from __future__ import annotations

from enum import Enum

__all__ = [
    "UserRole",
    "Gender",
    "HostelType",
    "HostelStatus",
    "RoomType",
    "RoomStatus",
    "BedStatus",
    "BookingStatus",
    "BookingSource",
    "PaymentStatus",
    "PaymentMethod",
    "PaymentType",
    "FeeType",
    "ComplaintCategory",
    "ComplaintStatus",
    "Priority",
    "AttendanceStatus",
    "AttendanceMode",
    "LeaveType",
    "LeaveStatus",
    "MaintenanceCategory",
    "MaintenanceStatus",
    "MaintenanceIssueType",
    "MaintenanceRecurrence",
    "NotificationType",
    "NotificationStatus",
    "SubscriptionPlan",
    "SubscriptionStatus",
    "BillingCycle",
    "StudentStatus",
    "SupervisorStatus",
    "EmploymentType",
    "AnnouncementCategory",
    "TargetAudience",
    "MealType",
    "DietaryPreference",
    "IDProofType",
    "PermissionLevel",
    "ReferralStatus",
    "RewardStatus",
    "ReviewStatus",
    "VoteType",
    "DeviceType",
    "SearchSource",
    "InquiryStatus",
    "InquirySource",
    "WaitlistStatus",
    "OTPType",
    "AuditActionCategory",
    "ChargeType",
]


class UserRole(str, Enum):
    """User role enumeration."""

    SUPER_ADMIN = "super_admin"
    HOSTEL_ADMIN = "hostel_admin"
    SUPERVISOR = "supervisor"
    STUDENT = "student"
    VISITOR = "visitor"


class Gender(str, Enum):
    """Gender enumeration."""

    MALE = "male"
    FEMALE = "female"
    OTHER = "other"


class HostelType(str, Enum):
    """Hostel type enumeration."""

    BOYS = "boys"
    GIRLS = "girls"
    CO_ED = "co_ed"


class HostelStatus(str, Enum):
    """Hostel operational status."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    UNDER_MAINTENANCE = "under_maintenance"
    CLOSED = "closed"


class RoomType(str, Enum):
    """Room type enumeration."""

    SINGLE = "single"
    DOUBLE = "double"
    TRIPLE = "triple"
    FOUR_SHARING = "four_sharing"
    DORMITORY = "dormitory"


class RoomStatus(str, Enum):
    """Room status enumeration."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    MAINTENANCE = "maintenance"
    RESERVED = "reserved"


class BedStatus(str, Enum):
    """Bed status enumeration."""

    AVAILABLE = "available"
    OCCUPIED = "occupied"
    RESERVED = "reserved"
    MAINTENANCE = "maintenance"


class BookingStatus(str, Enum):
    """Booking status enumeration."""

    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    CANCELLED = "cancelled"
    EXPIRED = "expired"
    CONFIRMED = "confirmed"
    CHECKED_IN = "checked_in"
    COMPLETED = "completed"


class BookingSource(str, Enum):
    """Booking source enumeration."""

    WEBSITE = "website"
    MOBILE_APP = "mobile_app"
    REFERRAL = "referral"
    WALK_IN = "walk_in"
    AGENT = "agent"
    OTHER = "other"


class PaymentStatus(str, Enum):
    """Payment status enumeration."""

    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    REFUNDED = "refunded"
    PARTIALLY_REFUNDED = "partially_refunded"


class PaymentMethod(str, Enum):
    """Payment method enumeration."""

    CASH = "cash"
    UPI = "upi"
    CARD = "card"
    NET_BANKING = "net_banking"
    CHEQUE = "cheque"
    BANK_TRANSFER = "bank_transfer"
    PAYMENT_GATEWAY = "payment_gateway"


class PaymentType(str, Enum):
    """Payment type enumeration."""

    RENT = "rent"
    SECURITY_DEPOSIT = "security_deposit"
    MESS_CHARGES = "mess_charges"
    ELECTRICITY = "electricity"
    WATER = "water"
    MAINTENANCE = "maintenance"
    BOOKING_ADVANCE = "booking_advance"
    OTHER = "other"


class FeeType(str, Enum):
    """Fee type enumeration."""

    MONTHLY = "monthly"
    QUARTERLY = "quarterly"
    HALF_YEARLY = "half_yearly"
    YEARLY = "yearly"


class ComplaintCategory(str, Enum):
    """Complaint category enumeration."""

    ROOM_MAINTENANCE = "room_maintenance"
    PLUMBING = "plumbing"
    ELECTRICAL = "electrical"
    CLEANLINESS = "cleanliness"
    MESS_FOOD_QUALITY = "mess_food_quality"
    SECURITY = "security"
    NOISE = "noise"
    INTERNET = "internet"
    STAFF_BEHAVIOR = "staff_behavior"
    OTHER = "other"


class ComplaintStatus(str, Enum):
    """Complaint status enumeration."""

    OPEN = "open"
    ASSIGNED = "assigned"
    IN_PROGRESS = "in_progress"
    ON_HOLD = "on_hold"
    RESOLVED = "resolved"
    CLOSED = "closed"
    REOPENED = "reopened"


class Priority(str, Enum):
    """Priority level enumeration."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"
    CRITICAL = "critical"


class AttendanceStatus(str, Enum):
    """Attendance status enumeration."""

    PRESENT = "present"
    ABSENT = "absent"
    LATE = "late"
    ON_LEAVE = "on_leave"
    HALF_DAY = "half_day"


class AttendanceMode(str, Enum):
    """Attendance recording mode."""

    MANUAL = "manual"
    BIOMETRIC = "biometric"
    QR_CODE = "qr_code"
    MOBILE_APP = "mobile_app"


class LeaveType(str, Enum):
    """Leave type enumeration."""

    CASUAL = "casual"
    SICK = "sick"
    EMERGENCY = "emergency"
    VACATION = "vacation"
    OTHER = "other"


class LeaveStatus(str, Enum):
    """Leave application status."""

    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    CANCELLED = "cancelled"


class MaintenanceCategory(str, Enum):
    """Maintenance category enumeration."""

    ELECTRICAL = "electrical"
    PLUMBING = "plumbing"
    CARPENTRY = "carpentry"
    CLEANING = "cleaning"
    APPLIANCE_REPAIR = "appliance_repair"
    STRUCTURAL = "structural"
    PAINTING = "painting"
    OTHER = "other"


class MaintenanceStatus(str, Enum):
    """Maintenance request status."""

    PENDING = "pending"
    APPROVED = "approved"
    ASSIGNED = "assigned"
    IN_PROGRESS = "in_progress"
    ON_HOLD = "on_hold"
    COMPLETED = "completed"
    REJECTED = "rejected"
    CANCELLED = "cancelled"


class MaintenanceIssueType(str, Enum):
    """Maintenance issue type."""

    ROUTINE = "routine"
    PREVENTIVE = "preventive"
    EMERGENCY = "emergency"
    BREAKDOWN = "breakdown"


class MaintenanceRecurrence(str, Enum):
    """Preventive maintenance recurrence."""

    NONE = "none"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    QUARTERLY = "quarterly"
    HALF_YEARLY = "half_yearly"
    YEARLY = "yearly"


class NotificationType(str, Enum):
    """Notification type enumeration."""

    EMAIL = "email"
    SMS = "sms"
    PUSH = "push"


class NotificationStatus(str, Enum):
    """Notification delivery status."""

    QUEUED = "queued"
    PROCESSING = "processing"
    SENT = "sent"
    FAILED = "failed"
    CANCELLED = "cancelled"


class SubscriptionPlan(str, Enum):
    """Subscription plan types."""

    FREE = "free"
    BASIC = "basic"
    STANDARD = "standard"
    PREMIUM = "premium"
    ENTERPRISE = "enterprise"


class SubscriptionStatus(str, Enum):
    """Subscription status."""

    TRIAL = "trial"
    ACTIVE = "active"
    PAST_DUE = "past_due"
    CANCELLED = "cancelled"
    EXPIRED = "expired"


class BillingCycle(str, Enum):
    """Billing cycle."""

    MONTHLY = "monthly"
    YEARLY = "yearly"


class StudentStatus(str, Enum):
    """Student status enumeration."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    NOTICE_PERIOD = "notice_period"
    ALUMNI = "alumni"
    SUSPENDED = "suspended"


class SupervisorStatus(str, Enum):
    """Supervisor status enumeration."""

    ACTIVE = "active"
    ON_LEAVE = "on_leave"
    SUSPENDED = "suspended"
    TERMINATED = "terminated"


class EmploymentType(str, Enum):
    """Employment type."""

    FULL_TIME = "full_time"
    PART_TIME = "part_time"
    CONTRACT = "contract"


class AnnouncementCategory(str, Enum):
    """Announcement category."""

    GENERAL = "general"
    URGENT = "urgent"
    MAINTENANCE = "maintenance"
    EVENT = "event"
    RULE_CHANGE = "rule_change"
    FEE_RELATED = "fee_related"
    SECURITY = "security"
    OTHER = "other"


class TargetAudience(str, Enum):
    """Target audience for announcements."""

    ALL = "all"
    STUDENTS_ONLY = "students_only"
    SPECIFIC_ROOMS = "specific_rooms"
    SPECIFIC_FLOORS = "specific_floors"
    INDIVIDUAL = "individual"


class MealType(str, Enum):
    """Meal type enumeration."""

    BREAKFAST = "breakfast"
    LUNCH = "lunch"
    SNACKS = "snacks"
    DINNER = "dinner"


class DietaryPreference(str, Enum):
    """Dietary preference."""

    VEGETARIAN = "vegetarian"
    NON_VEGETARIAN = "non_vegetarian"
    VEGAN = "vegan"
    JAIN = "jain"


class IDProofType(str, Enum):
    """ID proof type."""

    AADHAAR = "aadhaar"
    PASSPORT = "passport"
    DRIVING_LICENSE = "driving_license"
    VOTER_ID = "voter_id"
    PAN_CARD = "pan_card"


class PermissionLevel(str, Enum):
    """Permission level for admin-hostel assignments."""

    FULL_ACCESS = "full_access"
    LIMITED_ACCESS = "limited_access"
    VIEW_ONLY = "view_only"


class ReferralStatus(str, Enum):
    """Referral status."""

    PENDING = "pending"
    REGISTERED = "registered"
    BOOKING_MADE = "booking_made"
    COMPLETED = "completed"
    EXPIRED = "expired"
    CANCELLED = "cancelled"


class RewardStatus(str, Enum):
    """Reward payment status."""

    PENDING = "pending"
    APPROVED = "approved"
    PAID = "paid"
    CANCELLED = "cancelled"


class ReviewStatus(str, Enum):
    """Review moderation status."""

    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    FLAGGED = "flagged"


class VoteType(str, Enum):
    """Review vote type."""

    HELPFUL = "helpful"
    NOT_HELPFUL = "not_helpful"


class DeviceType(str, Enum):
    """Device type for push notifications."""

    IOS = "ios"
    ANDROID = "android"
    WEB = "web"


class SearchSource(str, Enum):
    """Search result source."""

    SEARCH_RESULTS = "search_results"
    DIRECT_LINK = "direct_link"
    FEATURED = "featured"
    COMPARISON = "comparison"
    REFERRAL = "referral"


class InquiryStatus(str, Enum):
    """Inquiry status."""

    NEW = "new"
    CONTACTED = "contacted"
    INTERESTED = "interested"
    NOT_INTERESTED = "not_interested"
    CONVERTED = "converted"


class InquirySource(str, Enum):
    """Inquiry source."""

    WEBSITE = "website"
    MOBILE_APP = "mobile_app"
    REFERRAL = "referral"
    SOCIAL_MEDIA = "social_media"
    OTHER = "other"


class WaitlistStatus(str, Enum):
    """Waitlist status."""

    WAITING = "waiting"
    NOTIFIED = "notified"
    CONVERTED = "converted"
    EXPIRED = "expired"
    CANCELLED = "cancelled"


class OTPType(str, Enum):
    """OTP type."""

    EMAIL_VERIFICATION = "email_verification"
    PHONE_VERIFICATION = "phone_verification"
    LOGIN = "login"
    PASSWORD_RESET = "password_reset"


class AuditActionCategory(str, Enum):
    """Audit action category."""

    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    USER_MANAGEMENT = "user_management"
    HOSTEL_MANAGEMENT = "hostel_management"
    BOOKING = "booking"
    PAYMENT = "payment"
    COMPLAINT = "complaint"
    ATTENDANCE = "attendance"
    MAINTENANCE = "maintenance"
    ANNOUNCEMENT = "announcement"
    STUDENT_MANAGEMENT = "student_management"
    SUPERVISOR_MANAGEMENT = "supervisor_management"
    CONFIGURATION = "configuration"
    OTHER = "other"


class ChargeType(str, Enum):
    """Utility charge type."""

    INCLUDED = "included"
    ACTUAL = "actual"
    FIXED_MONTHLY = "fixed_monthly"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\filters.py ---
# --- File: app/schemas/common/filters.py ---
"""
Common filter schemas used for query/filter parameters across the API.
"""

from __future__ import annotations

from datetime import date, datetime, time
from typing import Dict, List, Optional

from pydantic import Field, field_validator

from app.schemas.common.base import BaseFilterSchema, BaseSchema

__all__ = [
    "DateRangeFilter",
    "DateTimeRangeFilter",
    "TimeRangeFilter",
    "PriceRangeFilter",
    "SearchFilter",
    "SortOptions",
    "StatusFilter",
    "NumericRangeFilter",
    "LocationFilter",
    "MultiSelectFilter",
    "BooleanFilter",
    "TextSearchFilter",
]


class DateRangeFilter(BaseFilterSchema):
    """Date range filter."""

    start_date: Optional[date] = Field(None, description="Start date (inclusive)")
    end_date: Optional[date] = Field(None, description="End date (inclusive)")

    @field_validator("end_date")
    @classmethod
    def validate_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate end_date is after or equal to start_date."""
        start_date = info.data.get("start_date")
        if v is not None and start_date is not None and v < start_date:
            raise ValueError("end_date must be after or equal to start_date")
        return v


class DateTimeRangeFilter(BaseFilterSchema):
    """Datetime range filter."""

    start_datetime: Optional[datetime] = Field(
        None,
        description="Start datetime (inclusive)",
    )
    end_datetime: Optional[datetime] = Field(
        None,
        description="End datetime (inclusive)",
    )

    @field_validator("end_datetime")
    @classmethod
    def validate_datetime_range(
        cls,
        v: Optional[datetime],
        info,
    ) -> Optional[datetime]:
        """Validate end_datetime is after or equal to start_datetime."""
        start_datetime = info.data.get("start_datetime")
        if v is not None and start_datetime is not None and v < start_datetime:
            raise ValueError(
                "end_datetime must be after or equal to start_datetime",
            )
        return v


class TimeRangeFilter(BaseFilterSchema):
    """Time range filter."""

    start_time: Optional[time] = Field(None, description="Start time")
    end_time: Optional[time] = Field(None, description="End time")


class PriceRangeFilter(BaseFilterSchema):
    """Price range filter."""

    min_price: Optional[float] = Field(
        None,
        ge=0,
        description="Minimum price",
    )
    max_price: Optional[float] = Field(
        None,
        ge=0,
        description="Maximum price",
    )

    @field_validator("max_price")
    @classmethod
    def validate_price_range(cls, v: Optional[float], info) -> Optional[float]:
        """Validate max_price is greater than or equal to min_price."""
        min_price = info.data.get("min_price")
        if v is not None and min_price is not None and v < min_price:
            raise ValueError(
                "max_price must be greater than or equal to min_price",
            )
        return v


class SearchFilter(BaseFilterSchema):
    """Generic search filter."""

    search_query: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Search query string",
    )


class SortOptions(BaseFilterSchema):
    """Sorting options."""

    sort_by: str = Field(..., description="Field to sort by")
    sort_order: str = Field(
        "asc",
        pattern=r"^(asc|desc)$",
        description="Sort order: asc or desc (case-insensitive input allowed)",
    )

    @field_validator("sort_order")
    @classmethod
    def validate_sort_order(cls, v: str) -> str:
        """Validate and normalize sort order."""
        return v.lower()


class StatusFilter(BaseFilterSchema):
    """Status filter."""

    statuses: Optional[List[str]] = Field(
        None,
        description="Filter by status values",
    )
    exclude_statuses: Optional[List[str]] = Field(
        None,
        description="Exclude status values",
    )


class NumericRangeFilter(BaseFilterSchema):
    """Generic numeric range filter."""

    min_value: Optional[float] = Field(None, description="Minimum value")
    max_value: Optional[float] = Field(None, description="Maximum value")

    @field_validator("max_value")
    @classmethod
    def validate_range(cls, v: Optional[float], info) -> Optional[float]:
        """Validate max_value is greater than or equal to min_value."""
        min_value = info.data.get("min_value")
        if v is not None and min_value is not None and v < min_value:
            raise ValueError(
                "max_value must be greater than or equal to min_value",
            )
        return v


class LocationFilter(BaseFilterSchema):
    """Location-based filter."""

    latitude: Optional[float] = Field(
        None,
        ge=-90,
        le=90,
        description="Latitude",
    )
    longitude: Optional[float] = Field(
        None,
        ge=-180,
        le=180,
        description="Longitude",
    )
    radius_km: Optional[float] = Field(
        None,
        ge=0,
        le=100,
        description="Search radius in kilometers",
    )
    city: Optional[str] = Field(None, description="City name")
    state: Optional[str] = Field(None, description="State name")
    pincode: Optional[str] = Field(
        None,
        pattern=r"^\d{6}$",
        description="Pincode",
    )


class MultiSelectFilter(BaseFilterSchema):
    """Multi-select filter with include/exclude."""

    include: Optional[List[str]] = Field(
        None,
        description="Include these values",
    )
    exclude: Optional[List[str]] = Field(
        None,
        description="Exclude these values",
    )


class BooleanFilter(BaseFilterSchema):
    """Boolean filter (yes/no/all)."""

    value: Optional[bool] = Field(
        None,
        description="Boolean filter value",
    )


class TextSearchFilter(BaseFilterSchema):
    """Full-text search filter."""

    query: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Search query",
    )
    fields: Optional[List[str]] = Field(
        None,
        description="Fields to search in",
    )
    fuzzy: bool = Field(False, description="Enable fuzzy search")
    boost: Optional[Dict[str, float]] = Field(
        None,
        description="Field boost weights",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\mixins.py ---
# --- File: app/schemas/common/mixins.py ---
"""
Reusable schema mixins for address, contact info, media, audit, etc.
"""

from __future__ import annotations

from datetime import datetime
from typing import List, Optional
from uuid import UUID

from pydantic import BaseModel, Field, HttpUrl

__all__ = [
    "AddressMixin",
    "ContactMixin",
    "LocationMixin",
    "MediaMixin",
    "EmergencyContactMixin",
    "AuditMixin",
    "ApprovalMixin",
    "SEOMixin",
]


class AddressMixin(BaseModel):
    """Address fields mixin."""

    address_line1: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Address line 1",
    )
    address_line2: Optional[str] = Field(
        None,
        max_length=255,
        description="Address line 2",
    )
    city: str = Field(
        ...,
        min_length=2,
        max_length=100,
        description="City",
    )
    state: str = Field(
        ...,
        min_length=2,
        max_length=100,
        description="State",
    )
    pincode: str = Field(
        ...,
        pattern=r"^\d{6}$",
        description="6-digit pincode",
    )
    country: str = Field(
        "India",
        min_length=2,
        max_length=100,
        description="Country",
    )


class ContactMixin(BaseModel):
    """Contact information mixin."""

    contact_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Primary contact phone",
    )
    alternate_phone: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Alternate phone",
    )
    contact_email: Optional[str] = Field(
        None,
        description="Contact email",
    )


class LocationMixin(BaseModel):
    """Geographic location mixin."""

    latitude: Optional[float] = Field(
        None,
        ge=-90,
        le=90,
        description="Latitude",
    )
    longitude: Optional[float] = Field(
        None,
        ge=-180,
        le=180,
        description="Longitude",
    )


class MediaMixin(BaseModel):
    """Media URLs mixin."""

    images: List[HttpUrl] = Field(
        default_factory=list,
        description="Image URLs",
    )
    videos: List[HttpUrl] = Field(
        default_factory=list,
        description="Video URLs",
    )
    documents: List[HttpUrl] = Field(
        default_factory=list,
        description="Document URLs",
    )


class EmergencyContactMixin(BaseModel):
    """Emergency contact mixin."""

    emergency_contact_name: Optional[str] = Field(
        None,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone",
    )
    emergency_contact_relation: Optional[str] = Field(
        None,
        description="Relation to person",
    )


class AuditMixin(BaseModel):
    """Audit trail mixin."""

    created_by: Optional[UUID] = Field(
        None,
        description="User who created the record",
    )
    updated_by: Optional[UUID] = Field(
        None,
        description="User who last updated the record",
    )


class ApprovalMixin(BaseModel):
    """Approval workflow mixin."""

    approved_by: Optional[UUID] = Field(
        None,
        description="User who approved",
    )
    approved_at: Optional[datetime] = Field(
        None,
        description="Approval timestamp",
    )
    rejection_reason: Optional[str] = Field(
        None,
        description="Reason for rejection",
    )


class SEOMixin(BaseModel):
    """SEO fields mixin."""

    meta_title: Optional[str] = Field(
        None,
        max_length=255,
        description="SEO meta title",
    )
    meta_description: Optional[str] = Field(
        None,
        max_length=500,
        description="SEO meta description",
    )
    meta_keywords: Optional[str] = Field(
        None,
        max_length=500,
        description="SEO keywords",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\pagination.py ---
# --- File: app/schemas/common/pagination.py ---
"""
Pagination schemas for page-based and cursor-based responses.
"""

from __future__ import annotations

from typing import Generic, List, Optional, TypeVar

from pydantic import Field, field_validator

from app.schemas.common.base import BaseSchema

T = TypeVar("T")

__all__ = [
    "PaginationParams",
    "PaginationMeta",
    "PaginatedResponse",
    "CursorPaginationParams",
    "CursorPaginationMeta",
    "CursorPaginatedResponse",
]


class PaginationParams(BaseSchema):
    """Pagination query parameters."""

    page: int = Field(
        1,
        ge=1,
        description="Page number (1-indexed)",
    )
    page_size: int = Field(
        20,
        ge=1,
        le=100,
        description="Items per page",
    )

    @field_validator("page")
    @classmethod
    def validate_page(cls, v: int) -> int:
        """Validate page number."""
        if v < 1:
            raise ValueError("Page number must be >= 1")
        return v

    @field_validator("page_size")
    @classmethod
    def validate_page_size(cls, v: int) -> int:
        """Validate page size."""
        if v < 1 or v > 100:
            raise ValueError("Page size must be between 1 and 100")
        return v

    @property
    def offset(self) -> int:
        """Calculate offset for database queries."""
        return (self.page - 1) * self.page_size

    @property
    def limit(self) -> int:
        """Get limit for database queries."""
        return self.page_size


class PaginationMeta(BaseSchema):
    """Pagination metadata."""

    total_items: int = Field(
        ...,
        ge=0,
        description="Total number of items",
    )
    total_pages: int = Field(
        ...,
        ge=0,
        description="Total number of pages",
    )
    current_page: int = Field(
        ...,
        ge=1,
        description="Current page number",
    )
    page_size: int = Field(
        ...,
        ge=1,
        description="Items per page",
    )
    has_next: bool = Field(..., description="Has next page")
    has_previous: bool = Field(..., description="Has previous page")


class PaginatedResponse(BaseSchema, Generic[T]):
    """Generic paginated response."""

    items: List[T] = Field(..., description="List of items")
    meta: PaginationMeta = Field(..., description="Pagination metadata")

    @classmethod
    def create(
        cls,
        items: List[T],
        total_items: int,
        page: int,
        page_size: int,
    ) -> "PaginatedResponse[T]":
        """
        Create paginated response with calculated metadata.

        Args:
            items: List of items for current page.
            total_items: Total number of items across all pages.
            page: Current page number.
            page_size: Number of items per page.

        Returns:
            PaginatedResponse with items and metadata.
        """
        # Calculate total pages (handle division by zero)
        total_pages = (
            (total_items + page_size - 1) // page_size if page_size > 0 else 0
        )

        # Ensure total_pages is at least 1 if there are items
        if total_items > 0 and total_pages == 0:
            total_pages = 1

        meta = PaginationMeta(
            total_items=total_items,
            total_pages=total_pages,
            current_page=page,
            page_size=page_size,
            has_next=page < total_pages,
            has_previous=page > 1,
        )

        return cls(items=items, meta=meta)


class CursorPaginationParams(BaseSchema):
    """Cursor-based pagination parameters (for infinite scroll)."""

    cursor: Optional[str] = Field(
        None,
        description="Cursor for next page",
    )
    limit: int = Field(
        20,
        ge=1,
        le=100,
        description="Number of items to fetch",
    )


class CursorPaginationMeta(BaseSchema):
    """Cursor pagination metadata."""

    next_cursor: Optional[str] = Field(
        None,
        description="Cursor for next page",
    )
    has_more: bool = Field(
        ...,
        description="Whether more items exist",
    )


class CursorPaginatedResponse(BaseSchema, Generic[T]):
    """Generic cursor-based paginated response."""

    items: List[T] = Field(..., description="List of items")
    meta: CursorPaginationMeta = Field(
        ...,
        description="Cursor pagination metadata",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\response.py ---
# --- File: app/schemas/common/response.py ---
"""
Standard API response wrappers for success, error, and bulk operations.
"""

from __future__ import annotations

from typing import Any, Dict, Generic, List, Optional, TypeVar

from pydantic import Field

from app.schemas.common.base import BaseSchema

T = TypeVar("T")

__all__ = [
    "SuccessResponse",
    "ErrorDetail",
    "ErrorResponse",
    "MessageResponse",
    "BulkOperationResponse",
    "ValidationErrorResponse",
    "NotFoundResponse",
    "UnauthorizedResponse",
    "ForbiddenResponse",
    "ConflictResponse",
    "RateLimitResponse",
]


class SuccessResponse(BaseSchema, Generic[T]):
    """Standard success response."""

    success: bool = Field(True, description="Success flag")
    message: str = Field(..., description="Response message")
    data: Optional[T] = Field(None, description="Response data")

    @classmethod
    def create(
        cls,
        message: str,
        data: Optional[T] = None,
    ) -> "SuccessResponse[T]":
        """Create success response."""
        return cls(success=True, message=message, data=data)


class ErrorDetail(BaseSchema):
    """Error detail information."""

    field: Optional[str] = Field(
        None,
        description="Field name causing error",
    )
    message: str = Field(..., description="Error message")
    code: Optional[str] = Field(
        None,
        description="Error code",
    )
    location: Optional[List[str]] = Field(
        None,
        description="Error location in nested structure",
    )


class ErrorResponse(BaseSchema):
    """Standard error response."""

    success: bool = Field(False, description="Success flag")
    message: str = Field(..., description="Error message")
    errors: Optional[List[ErrorDetail]] = Field(
        None,
        description="Detailed errors",
    )
    error_code: Optional[str] = Field(
        None,
        description="Application error code",
    )
    timestamp: Optional[str] = Field(
        None,
        description="Error timestamp",
    )
    path: Optional[str] = Field(
        None,
        description="Request path that caused error",
    )

    @classmethod
    def create(
        cls,
        message: str,
        errors: Optional[List[ErrorDetail]] = None,
        error_code: Optional[str] = None,
    ) -> "ErrorResponse":
        """Create error response."""
        return cls(
            success=False,
            message=message,
            errors=errors,
            error_code=error_code,
        )


class MessageResponse(BaseSchema):
    """Simple message response."""

    message: str = Field(..., description="Response message")

    @classmethod
    def create(cls, message: str) -> "MessageResponse":
        """Create message response."""
        return cls(message=message)


class BulkOperationResponse(BaseSchema):
    """Response for bulk operations."""

    total: int = Field(
        ...,
        ge=0,
        description="Total items processed",
    )
    successful: int = Field(
        ...,
        ge=0,
        description="Successfully processed items",
    )
    failed: int = Field(
        ...,
        ge=0,
        description="Failed items",
    )
    errors: Optional[List[Dict[str, Any]]] = Field(
        None,
        description="Errors for failed items",
    )
    details: Optional[Dict[str, Any]] = Field(
        None,
        description="Additional operation details",
    )

    @classmethod
    def create(
        cls,
        total: int,
        successful: int,
        failed: int,
        errors: Optional[List[Dict[str, Any]]] = None,
        details: Optional[Dict[str, Any]] = None,
    ) -> "BulkOperationResponse":
        """Create bulk operation response."""
        return cls(
            total=total,
            successful=successful,
            failed=failed,
            errors=errors,
            details=details,
        )


class ValidationErrorResponse(ErrorResponse):
    """Validation error response (422)."""

    validation_errors: List[ErrorDetail] = Field(
        ...,
        description="Validation error details",
    )


class NotFoundResponse(ErrorResponse):
    """Not found error response (404)."""

    resource_type: Optional[str] = Field(
        None,
        description="Type of resource not found",
    )
    resource_id: Optional[str] = Field(
        None,
        description="ID of resource not found",
    )


class UnauthorizedResponse(ErrorResponse):
    """Unauthorized error response (401)."""

    auth_scheme: Optional[str] = Field(
        None,
        description="Authentication scheme required",
    )


class ForbiddenResponse(ErrorResponse):
    """Forbidden error response (403)."""

    required_permission: Optional[str] = Field(
        None,
        description="Required permission",
    )
    user_permissions: Optional[List[str]] = Field(
        None,
        description="User's current permissions",
    )


class ConflictResponse(ErrorResponse):
    """Conflict error response (409)."""

    conflicting_resource: Optional[str] = Field(
        None,
        description="Conflicting resource identifier",
    )


class RateLimitResponse(ErrorResponse):
    """Rate limit exceeded response (429)."""

    retry_after: Optional[int] = Field(
        None,
        description="Seconds to wait before retry",
    )
    limit: Optional[int] = Field(
        None,
        description="Rate limit",
    )
    window: Optional[int] = Field(
        None,
        description="Time window in seconds",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\__init__.py ---
# --- File: app/schemas/common/__init__.py ---
"""
Common schemas package.

This __init__ module re-exports frequently used base schemas, enums,
pagination helpers, responses, and filters from a single location:

    from app.schemas.common import BaseSchema, UserRole, PaginationParams
"""

from __future__ import annotations

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseDBSchema,
    BaseFilterSchema,
    BaseResponseSchema,
    BaseSchema,
    BaseUpdateSchema,
    SoftDeleteMixin,
    TimestampMixin,
    UUIDMixin,
)
from app.schemas.common.enums import (
    AnnouncementCategory,
    AttendanceStatus,
    BillingCycle,
    BookingStatus,
    ComplaintCategory,
    ComplaintStatus,
    DietaryPreference,
    DeviceType,
    EmploymentType,
    Gender,
    IDProofType,
    InquiryStatus,
    MealType,
    MaintenanceCategory,
    MaintenanceStatus,
    NotificationStatus,
    NotificationType,
    PaymentMethod,
    PaymentStatus,
    PaymentType,
    Priority,
    ReferralStatus,
    ReviewStatus,
    RoomType,
    SearchSource,
    StudentStatus,
    SubscriptionPlan,
    SubscriptionStatus,
    SupervisorStatus,
    TargetAudience,
    UserRole,
)
from app.schemas.common.filters import (
    DateRangeFilter,
    DateTimeRangeFilter,
    PriceRangeFilter,
    SearchFilter,
    SortOptions,
    StatusFilter,
)
from app.schemas.common.pagination import (
    PaginatedResponse,
    PaginationMeta,
    PaginationParams,
)
from app.schemas.common.response import (
    BulkOperationResponse,
    ErrorDetail,
    ErrorResponse,
    MessageResponse,
    SuccessResponse,
)

__all__ = [
    # Base schemas
    "BaseSchema",
    "BaseCreateSchema",
    "BaseUpdateSchema",
    "BaseResponseSchema",
    "BaseDBSchema",
    "BaseFilterSchema",
    "TimestampMixin",
    "SoftDeleteMixin",
    "UUIDMixin",
    # Enums
    "UserRole",
    "Gender",
    "RoomType",
    "BookingStatus",
    "PaymentStatus",
    "PaymentMethod",
    "PaymentType",
    "ComplaintCategory",
    "ComplaintStatus",
    "Priority",
    "AttendanceStatus",
    "MaintenanceCategory",
    "MaintenanceStatus",
    "NotificationType",
    "SubscriptionPlan",
    "StudentStatus",
    "SupervisorStatus",
    "AnnouncementCategory",
    "TargetAudience",
    "MealType",
    "DietaryPreference",
    "IDProofType",
    "EmploymentType",
    "BillingCycle",
    "SubscriptionStatus",
    "ReferralStatus",
    "ReviewStatus",
    "NotificationStatus",
    "DeviceType",
    "SearchSource",
    "InquiryStatus",
    # Pagination
    "PaginationParams",
    "PaginationMeta",
    "PaginatedResponse",
    # Responses
    "SuccessResponse",
    "ErrorDetail",
    "ErrorResponse",
    "MessageResponse",
    "BulkOperationResponse",
    # Filters
    "DateRangeFilter",
    "DateTimeRangeFilter",
    "PriceRangeFilter",
    "SearchFilter",
    "SortOptions",
    "StatusFilter",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\base.py ---
# --- File: app/schemas/common/base.py ---
"""
Base schema classes with common fields and configurations.
"""

from __future__ import annotations

from datetime import datetime
from typing import Optional

from pydantic import BaseModel, ConfigDict, Field

__all__ = [
    "BaseSchema",
    "TimestampMixin",
    "SoftDeleteMixin",
    "UUIDMixin",
    "BaseDBSchema",
    "BaseCreateSchema",
    "BaseUpdateSchema",
    "BaseResponseSchema",
    "BaseFilterSchema",
]


class BaseSchema(BaseModel):
    """
    Base schema with common Pydantic configuration.

    All application-facing schemas should ideally inherit from this to ensure
    consistent behaviour (e.g. JSON encoders, validation, etc.).
    """

    model_config = ConfigDict(
        from_attributes=True,
        populate_by_name=True,
        # Keep enums as Enum instances to retain full type information;
        # callers can still access `.value` if needed.
        use_enum_values=False,
        arbitrary_types_allowed=True,
        str_strip_whitespace=True,
        validate_assignment=True,
        json_encoders={
            datetime: lambda v: v.isoformat(),
        },
    )


class TimestampMixin(BaseModel):
    """Mixin for timestamp fields."""

    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")


class SoftDeleteMixin(BaseModel):
    """Mixin for soft delete support."""

    deleted_at: Optional[datetime] = Field(None, description="Deletion timestamp")
    is_deleted: bool = Field(False, description="Soft delete flag")


class UUIDMixin(BaseModel):
    """Mixin for UUID primary key."""

    id: str = Field(..., description="Unique identifier")


class BaseDBSchema(BaseSchema, UUIDMixin, TimestampMixin):
    """Base schema for database entities with ID and timestamps."""
    pass


class BaseCreateSchema(BaseSchema):
    """Base schema for create operations."""
    pass


class BaseUpdateSchema(BaseSchema):
    """
    Base schema for update operations.

    Note:
        This base class does not itself make fields optional. Subclasses
        intended for partial updates should declare their fields as
        Optional[...] / with defaults as appropriate.
    """
    pass


class BaseResponseSchema(BaseDBSchema):
    """Base schema for API responses."""
    pass


class BaseFilterSchema(BaseSchema):
    """Base schema for filter parameters."""
    pass

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\enums.py ---
# --- File: app/schemas/common/enums.py ---
"""
All enumeration types used across the application.

These enums represent the core domain concepts for the hostel management
system (users, hostels, rooms, bookings, payments, complaints, etc.).
"""

from __future__ import annotations

from enum import Enum

__all__ = [
    "UserRole",
    "Gender",
    "HostelType",
    "HostelStatus",
    "RoomType",
    "RoomStatus",
    "BedStatus",
    "BookingStatus",
    "BookingSource",
    "PaymentStatus",
    "PaymentMethod",
    "PaymentType",
    "FeeType",
    "ComplaintCategory",
    "ComplaintStatus",
    "Priority",
    "AttendanceStatus",
    "AttendanceMode",
    "LeaveType",
    "LeaveStatus",
    "MaintenanceCategory",
    "MaintenanceStatus",
    "MaintenanceIssueType",
    "MaintenanceRecurrence",
    "NotificationType",
    "NotificationStatus",
    "SubscriptionPlan",
    "SubscriptionStatus",
    "BillingCycle",
    "StudentStatus",
    "SupervisorStatus",
    "EmploymentType",
    "AnnouncementCategory",
    "TargetAudience",
    "MealType",
    "DietaryPreference",
    "IDProofType",
    "PermissionLevel",
    "ReferralStatus",
    "RewardStatus",
    "ReviewStatus",
    "VoteType",
    "DeviceType",
    "SearchSource",
    "InquiryStatus",
    "InquirySource",
    "WaitlistStatus",
    "OTPType",
    "AuditActionCategory",
    "ChargeType",
]


class UserRole(str, Enum):
    """User role enumeration."""

    SUPER_ADMIN = "super_admin"
    HOSTEL_ADMIN = "hostel_admin"
    SUPERVISOR = "supervisor"
    STUDENT = "student"
    VISITOR = "visitor"


class Gender(str, Enum):
    """Gender enumeration."""

    MALE = "male"
    FEMALE = "female"
    OTHER = "other"


class HostelType(str, Enum):
    """Hostel type enumeration."""

    BOYS = "boys"
    GIRLS = "girls"
    CO_ED = "co_ed"


class HostelStatus(str, Enum):
    """Hostel operational status."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    UNDER_MAINTENANCE = "under_maintenance"
    CLOSED = "closed"


class RoomType(str, Enum):
    """Room type enumeration."""

    SINGLE = "single"
    DOUBLE = "double"
    TRIPLE = "triple"
    FOUR_SHARING = "four_sharing"
    DORMITORY = "dormitory"


class RoomStatus(str, Enum):
    """Room status enumeration."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    MAINTENANCE = "maintenance"
    RESERVED = "reserved"


class BedStatus(str, Enum):
    """Bed status enumeration."""

    AVAILABLE = "available"
    OCCUPIED = "occupied"
    RESERVED = "reserved"
    MAINTENANCE = "maintenance"


class BookingStatus(str, Enum):
    """Booking status enumeration."""

    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    CANCELLED = "cancelled"
    EXPIRED = "expired"
    CONFIRMED = "confirmed"
    CHECKED_IN = "checked_in"
    COMPLETED = "completed"


class BookingSource(str, Enum):
    """Booking source enumeration."""

    WEBSITE = "website"
    MOBILE_APP = "mobile_app"
    REFERRAL = "referral"
    WALK_IN = "walk_in"
    AGENT = "agent"
    OTHER = "other"


class PaymentStatus(str, Enum):
    """Payment status enumeration."""

    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    REFUNDED = "refunded"
    PARTIALLY_REFUNDED = "partially_refunded"


class PaymentMethod(str, Enum):
    """Payment method enumeration."""

    CASH = "cash"
    UPI = "upi"
    CARD = "card"
    NET_BANKING = "net_banking"
    CHEQUE = "cheque"
    BANK_TRANSFER = "bank_transfer"
    PAYMENT_GATEWAY = "payment_gateway"


class PaymentType(str, Enum):
    """Payment type enumeration."""

    RENT = "rent"
    SECURITY_DEPOSIT = "security_deposit"
    MESS_CHARGES = "mess_charges"
    ELECTRICITY = "electricity"
    WATER = "water"
    MAINTENANCE = "maintenance"
    BOOKING_ADVANCE = "booking_advance"
    OTHER = "other"


class FeeType(str, Enum):
    """Fee type enumeration."""

    MONTHLY = "monthly"
    QUARTERLY = "quarterly"
    HALF_YEARLY = "half_yearly"
    YEARLY = "yearly"


class ComplaintCategory(str, Enum):
    """Complaint category enumeration."""

    ROOM_MAINTENANCE = "room_maintenance"
    PLUMBING = "plumbing"
    ELECTRICAL = "electrical"
    CLEANLINESS = "cleanliness"
    MESS_FOOD_QUALITY = "mess_food_quality"
    SECURITY = "security"
    NOISE = "noise"
    INTERNET = "internet"
    STAFF_BEHAVIOR = "staff_behavior"
    OTHER = "other"


class ComplaintStatus(str, Enum):
    """Complaint status enumeration."""

    OPEN = "open"
    ASSIGNED = "assigned"
    IN_PROGRESS = "in_progress"
    ON_HOLD = "on_hold"
    RESOLVED = "resolved"
    CLOSED = "closed"
    REOPENED = "reopened"


class Priority(str, Enum):
    """Priority level enumeration."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"
    CRITICAL = "critical"


class AttendanceStatus(str, Enum):
    """Attendance status enumeration."""

    PRESENT = "present"
    ABSENT = "absent"
    LATE = "late"
    ON_LEAVE = "on_leave"
    HALF_DAY = "half_day"


class AttendanceMode(str, Enum):
    """Attendance recording mode."""

    MANUAL = "manual"
    BIOMETRIC = "biometric"
    QR_CODE = "qr_code"
    MOBILE_APP = "mobile_app"


class LeaveType(str, Enum):
    """Leave type enumeration."""

    CASUAL = "casual"
    SICK = "sick"
    EMERGENCY = "emergency"
    VACATION = "vacation"
    OTHER = "other"


class LeaveStatus(str, Enum):
    """Leave application status."""

    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    CANCELLED = "cancelled"


class MaintenanceCategory(str, Enum):
    """Maintenance category enumeration."""

    ELECTRICAL = "electrical"
    PLUMBING = "plumbing"
    CARPENTRY = "carpentry"
    CLEANING = "cleaning"
    APPLIANCE_REPAIR = "appliance_repair"
    STRUCTURAL = "structural"
    PAINTING = "painting"
    OTHER = "other"


class MaintenanceStatus(str, Enum):
    """Maintenance request status."""

    PENDING = "pending"
    APPROVED = "approved"
    ASSIGNED = "assigned"
    IN_PROGRESS = "in_progress"
    ON_HOLD = "on_hold"
    COMPLETED = "completed"
    REJECTED = "rejected"
    CANCELLED = "cancelled"


class MaintenanceIssueType(str, Enum):
    """Maintenance issue type."""

    ROUTINE = "routine"
    PREVENTIVE = "preventive"
    EMERGENCY = "emergency"
    BREAKDOWN = "breakdown"


class MaintenanceRecurrence(str, Enum):
    """Preventive maintenance recurrence."""

    NONE = "none"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    QUARTERLY = "quarterly"
    HALF_YEARLY = "half_yearly"
    YEARLY = "yearly"


class NotificationType(str, Enum):
    """Notification type enumeration."""

    EMAIL = "email"
    SMS = "sms"
    PUSH = "push"


class NotificationStatus(str, Enum):
    """Notification delivery status."""

    QUEUED = "queued"
    PROCESSING = "processing"
    SENT = "sent"
    FAILED = "failed"
    CANCELLED = "cancelled"


class SubscriptionPlan(str, Enum):
    """Subscription plan types."""

    FREE = "free"
    BASIC = "basic"
    STANDARD = "standard"
    PREMIUM = "premium"
    ENTERPRISE = "enterprise"


class SubscriptionStatus(str, Enum):
    """Subscription status."""

    TRIAL = "trial"
    ACTIVE = "active"
    PAST_DUE = "past_due"
    CANCELLED = "cancelled"
    EXPIRED = "expired"


class BillingCycle(str, Enum):
    """Billing cycle."""

    MONTHLY = "monthly"
    YEARLY = "yearly"


class StudentStatus(str, Enum):
    """Student status enumeration."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    NOTICE_PERIOD = "notice_period"
    ALUMNI = "alumni"
    SUSPENDED = "suspended"


class SupervisorStatus(str, Enum):
    """Supervisor status enumeration."""

    ACTIVE = "active"
    ON_LEAVE = "on_leave"
    SUSPENDED = "suspended"
    TERMINATED = "terminated"


class EmploymentType(str, Enum):
    """Employment type."""

    FULL_TIME = "full_time"
    PART_TIME = "part_time"
    CONTRACT = "contract"


class AnnouncementCategory(str, Enum):
    """Announcement category."""

    GENERAL = "general"
    URGENT = "urgent"
    MAINTENANCE = "maintenance"
    EVENT = "event"
    RULE_CHANGE = "rule_change"
    FEE_RELATED = "fee_related"
    SECURITY = "security"
    OTHER = "other"


class TargetAudience(str, Enum):
    """Target audience for announcements."""

    ALL = "all"
    STUDENTS_ONLY = "students_only"
    SPECIFIC_ROOMS = "specific_rooms"
    SPECIFIC_FLOORS = "specific_floors"
    INDIVIDUAL = "individual"


class MealType(str, Enum):
    """Meal type enumeration."""

    BREAKFAST = "breakfast"
    LUNCH = "lunch"
    SNACKS = "snacks"
    DINNER = "dinner"


class DietaryPreference(str, Enum):
    """Dietary preference."""

    VEGETARIAN = "vegetarian"
    NON_VEGETARIAN = "non_vegetarian"
    VEGAN = "vegan"
    JAIN = "jain"


class IDProofType(str, Enum):
    """ID proof type."""

    AADHAAR = "aadhaar"
    PASSPORT = "passport"
    DRIVING_LICENSE = "driving_license"
    VOTER_ID = "voter_id"
    PAN_CARD = "pan_card"


class PermissionLevel(str, Enum):
    """Permission level for admin-hostel assignments."""

    FULL_ACCESS = "full_access"
    LIMITED_ACCESS = "limited_access"
    VIEW_ONLY = "view_only"


class ReferralStatus(str, Enum):
    """Referral status."""

    PENDING = "pending"
    REGISTERED = "registered"
    BOOKING_MADE = "booking_made"
    COMPLETED = "completed"
    EXPIRED = "expired"
    CANCELLED = "cancelled"


class RewardStatus(str, Enum):
    """Reward payment status."""

    PENDING = "pending"
    APPROVED = "approved"
    PAID = "paid"
    CANCELLED = "cancelled"


class ReviewStatus(str, Enum):
    """Review moderation status."""

    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    FLAGGED = "flagged"


class VoteType(str, Enum):
    """Review vote type."""

    HELPFUL = "helpful"
    NOT_HELPFUL = "not_helpful"


class DeviceType(str, Enum):
    """Device type for push notifications."""

    IOS = "ios"
    ANDROID = "android"
    WEB = "web"


class SearchSource(str, Enum):
    """Search result source."""

    SEARCH_RESULTS = "search_results"
    DIRECT_LINK = "direct_link"
    FEATURED = "featured"
    COMPARISON = "comparison"
    REFERRAL = "referral"


class InquiryStatus(str, Enum):
    """Inquiry status."""

    NEW = "new"
    CONTACTED = "contacted"
    INTERESTED = "interested"
    NOT_INTERESTED = "not_interested"
    CONVERTED = "converted"


class InquirySource(str, Enum):
    """Inquiry source."""

    WEBSITE = "website"
    MOBILE_APP = "mobile_app"
    REFERRAL = "referral"
    SOCIAL_MEDIA = "social_media"
    OTHER = "other"


class WaitlistStatus(str, Enum):
    """Waitlist status."""

    WAITING = "waiting"
    NOTIFIED = "notified"
    CONVERTED = "converted"
    EXPIRED = "expired"
    CANCELLED = "cancelled"


class OTPType(str, Enum):
    """OTP type."""

    EMAIL_VERIFICATION = "email_verification"
    PHONE_VERIFICATION = "phone_verification"
    LOGIN = "login"
    PASSWORD_RESET = "password_reset"


class AuditActionCategory(str, Enum):
    """Audit action category."""

    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    USER_MANAGEMENT = "user_management"
    HOSTEL_MANAGEMENT = "hostel_management"
    BOOKING = "booking"
    PAYMENT = "payment"
    COMPLAINT = "complaint"
    ATTENDANCE = "attendance"
    MAINTENANCE = "maintenance"
    ANNOUNCEMENT = "announcement"
    STUDENT_MANAGEMENT = "student_management"
    SUPERVISOR_MANAGEMENT = "supervisor_management"
    CONFIGURATION = "configuration"
    OTHER = "other"


class ChargeType(str, Enum):
    """Utility charge type."""

    INCLUDED = "included"
    ACTUAL = "actual"
    FIXED_MONTHLY = "fixed_monthly"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\filters.py ---
# --- File: app/schemas/common/filters.py ---
"""
Common filter schemas used for query/filter parameters across the API.
"""

from __future__ import annotations

from datetime import date, datetime, time
from typing import Dict, List, Optional

from pydantic import Field, field_validator

from app.schemas.common.base import BaseFilterSchema, BaseSchema

__all__ = [
    "DateRangeFilter",
    "DateTimeRangeFilter",
    "TimeRangeFilter",
    "PriceRangeFilter",
    "SearchFilter",
    "SortOptions",
    "StatusFilter",
    "NumericRangeFilter",
    "LocationFilter",
    "MultiSelectFilter",
    "BooleanFilter",
    "TextSearchFilter",
]


class DateRangeFilter(BaseFilterSchema):
    """Date range filter."""

    start_date: Optional[date] = Field(None, description="Start date (inclusive)")
    end_date: Optional[date] = Field(None, description="End date (inclusive)")

    @field_validator("end_date")
    @classmethod
    def validate_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate end_date is after or equal to start_date."""
        start_date = info.data.get("start_date")
        if v is not None and start_date is not None and v < start_date:
            raise ValueError("end_date must be after or equal to start_date")
        return v


class DateTimeRangeFilter(BaseFilterSchema):
    """Datetime range filter."""

    start_datetime: Optional[datetime] = Field(
        None,
        description="Start datetime (inclusive)",
    )
    end_datetime: Optional[datetime] = Field(
        None,
        description="End datetime (inclusive)",
    )

    @field_validator("end_datetime")
    @classmethod
    def validate_datetime_range(
        cls,
        v: Optional[datetime],
        info,
    ) -> Optional[datetime]:
        """Validate end_datetime is after or equal to start_datetime."""
        start_datetime = info.data.get("start_datetime")
        if v is not None and start_datetime is not None and v < start_datetime:
            raise ValueError(
                "end_datetime must be after or equal to start_datetime",
            )
        return v


class TimeRangeFilter(BaseFilterSchema):
    """Time range filter."""

    start_time: Optional[time] = Field(None, description="Start time")
    end_time: Optional[time] = Field(None, description="End time")


class PriceRangeFilter(BaseFilterSchema):
    """Price range filter."""

    min_price: Optional[float] = Field(
        None,
        ge=0,
        description="Minimum price",
    )
    max_price: Optional[float] = Field(
        None,
        ge=0,
        description="Maximum price",
    )

    @field_validator("max_price")
    @classmethod
    def validate_price_range(cls, v: Optional[float], info) -> Optional[float]:
        """Validate max_price is greater than or equal to min_price."""
        min_price = info.data.get("min_price")
        if v is not None and min_price is not None and v < min_price:
            raise ValueError(
                "max_price must be greater than or equal to min_price",
            )
        return v


class SearchFilter(BaseFilterSchema):
    """Generic search filter."""

    search_query: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Search query string",
    )


class SortOptions(BaseFilterSchema):
    """Sorting options."""

    sort_by: str = Field(..., description="Field to sort by")
    sort_order: str = Field(
        "asc",
        pattern=r"^(asc|desc)$",
        description="Sort order: asc or desc (case-insensitive input allowed)",
    )

    @field_validator("sort_order")
    @classmethod
    def validate_sort_order(cls, v: str) -> str:
        """Validate and normalize sort order."""
        return v.lower()


class StatusFilter(BaseFilterSchema):
    """Status filter."""

    statuses: Optional[List[str]] = Field(
        None,
        description="Filter by status values",
    )
    exclude_statuses: Optional[List[str]] = Field(
        None,
        description="Exclude status values",
    )


class NumericRangeFilter(BaseFilterSchema):
    """Generic numeric range filter."""

    min_value: Optional[float] = Field(None, description="Minimum value")
    max_value: Optional[float] = Field(None, description="Maximum value")

    @field_validator("max_value")
    @classmethod
    def validate_range(cls, v: Optional[float], info) -> Optional[float]:
        """Validate max_value is greater than or equal to min_value."""
        min_value = info.data.get("min_value")
        if v is not None and min_value is not None and v < min_value:
            raise ValueError(
                "max_value must be greater than or equal to min_value",
            )
        return v


class LocationFilter(BaseFilterSchema):
    """Location-based filter."""

    latitude: Optional[float] = Field(
        None,
        ge=-90,
        le=90,
        description="Latitude",
    )
    longitude: Optional[float] = Field(
        None,
        ge=-180,
        le=180,
        description="Longitude",
    )
    radius_km: Optional[float] = Field(
        None,
        ge=0,
        le=100,
        description="Search radius in kilometers",
    )
    city: Optional[str] = Field(None, description="City name")
    state: Optional[str] = Field(None, description="State name")
    pincode: Optional[str] = Field(
        None,
        pattern=r"^\d{6}$",
        description="Pincode",
    )


class MultiSelectFilter(BaseFilterSchema):
    """Multi-select filter with include/exclude."""

    include: Optional[List[str]] = Field(
        None,
        description="Include these values",
    )
    exclude: Optional[List[str]] = Field(
        None,
        description="Exclude these values",
    )


class BooleanFilter(BaseFilterSchema):
    """Boolean filter (yes/no/all)."""

    value: Optional[bool] = Field(
        None,
        description="Boolean filter value",
    )


class TextSearchFilter(BaseFilterSchema):
    """Full-text search filter."""

    query: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Search query",
    )
    fields: Optional[List[str]] = Field(
        None,
        description="Fields to search in",
    )
    fuzzy: bool = Field(False, description="Enable fuzzy search")
    boost: Optional[Dict[str, float]] = Field(
        None,
        description="Field boost weights",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\mixins.py ---
# --- File: app/schemas/common/mixins.py ---
"""
Reusable schema mixins for address, contact info, media, audit, etc.
"""

from __future__ import annotations

from datetime import datetime
from typing import List, Optional
from uuid import UUID

from pydantic import BaseModel, Field, HttpUrl

__all__ = [
    "AddressMixin",
    "ContactMixin",
    "LocationMixin",
    "MediaMixin",
    "EmergencyContactMixin",
    "AuditMixin",
    "ApprovalMixin",
    "SEOMixin",
]


class AddressMixin(BaseModel):
    """Address fields mixin."""

    address_line1: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Address line 1",
    )
    address_line2: Optional[str] = Field(
        None,
        max_length=255,
        description="Address line 2",
    )
    city: str = Field(
        ...,
        min_length=2,
        max_length=100,
        description="City",
    )
    state: str = Field(
        ...,
        min_length=2,
        max_length=100,
        description="State",
    )
    pincode: str = Field(
        ...,
        pattern=r"^\d{6}$",
        description="6-digit pincode",
    )
    country: str = Field(
        "India",
        min_length=2,
        max_length=100,
        description="Country",
    )


class ContactMixin(BaseModel):
    """Contact information mixin."""

    contact_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Primary contact phone",
    )
    alternate_phone: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Alternate phone",
    )
    contact_email: Optional[str] = Field(
        None,
        description="Contact email",
    )


class LocationMixin(BaseModel):
    """Geographic location mixin."""

    latitude: Optional[float] = Field(
        None,
        ge=-90,
        le=90,
        description="Latitude",
    )
    longitude: Optional[float] = Field(
        None,
        ge=-180,
        le=180,
        description="Longitude",
    )


class MediaMixin(BaseModel):
    """Media URLs mixin."""

    images: List[HttpUrl] = Field(
        default_factory=list,
        description="Image URLs",
    )
    videos: List[HttpUrl] = Field(
        default_factory=list,
        description="Video URLs",
    )
    documents: List[HttpUrl] = Field(
        default_factory=list,
        description="Document URLs",
    )


class EmergencyContactMixin(BaseModel):
    """Emergency contact mixin."""

    emergency_contact_name: Optional[str] = Field(
        None,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone",
    )
    emergency_contact_relation: Optional[str] = Field(
        None,
        description="Relation to person",
    )


class AuditMixin(BaseModel):
    """Audit trail mixin."""

    created_by: Optional[UUID] = Field(
        None,
        description="User who created the record",
    )
    updated_by: Optional[UUID] = Field(
        None,
        description="User who last updated the record",
    )


class ApprovalMixin(BaseModel):
    """Approval workflow mixin."""

    approved_by: Optional[UUID] = Field(
        None,
        description="User who approved",
    )
    approved_at: Optional[datetime] = Field(
        None,
        description="Approval timestamp",
    )
    rejection_reason: Optional[str] = Field(
        None,
        description="Reason for rejection",
    )


class SEOMixin(BaseModel):
    """SEO fields mixin."""

    meta_title: Optional[str] = Field(
        None,
        max_length=255,
        description="SEO meta title",
    )
    meta_description: Optional[str] = Field(
        None,
        max_length=500,
        description="SEO meta description",
    )
    meta_keywords: Optional[str] = Field(
        None,
        max_length=500,
        description="SEO keywords",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\pagination.py ---
# --- File: app/schemas/common/pagination.py ---
"""
Pagination schemas for page-based and cursor-based responses.
"""

from __future__ import annotations

from typing import Generic, List, Optional, TypeVar

from pydantic import Field, field_validator

from app.schemas.common.base import BaseSchema

T = TypeVar("T")

__all__ = [
    "PaginationParams",
    "PaginationMeta",
    "PaginatedResponse",
    "CursorPaginationParams",
    "CursorPaginationMeta",
    "CursorPaginatedResponse",
]


class PaginationParams(BaseSchema):
    """Pagination query parameters."""

    page: int = Field(
        1,
        ge=1,
        description="Page number (1-indexed)",
    )
    page_size: int = Field(
        20,
        ge=1,
        le=100,
        description="Items per page",
    )

    @field_validator("page")
    @classmethod
    def validate_page(cls, v: int) -> int:
        """Validate page number."""
        if v < 1:
            raise ValueError("Page number must be >= 1")
        return v

    @field_validator("page_size")
    @classmethod
    def validate_page_size(cls, v: int) -> int:
        """Validate page size."""
        if v < 1 or v > 100:
            raise ValueError("Page size must be between 1 and 100")
        return v

    @property
    def offset(self) -> int:
        """Calculate offset for database queries."""
        return (self.page - 1) * self.page_size

    @property
    def limit(self) -> int:
        """Get limit for database queries."""
        return self.page_size


class PaginationMeta(BaseSchema):
    """Pagination metadata."""

    total_items: int = Field(
        ...,
        ge=0,
        description="Total number of items",
    )
    total_pages: int = Field(
        ...,
        ge=0,
        description="Total number of pages",
    )
    current_page: int = Field(
        ...,
        ge=1,
        description="Current page number",
    )
    page_size: int = Field(
        ...,
        ge=1,
        description="Items per page",
    )
    has_next: bool = Field(..., description="Has next page")
    has_previous: bool = Field(..., description="Has previous page")


class PaginatedResponse(BaseSchema, Generic[T]):
    """Generic paginated response."""

    items: List[T] = Field(..., description="List of items")
    meta: PaginationMeta = Field(..., description="Pagination metadata")

    @classmethod
    def create(
        cls,
        items: List[T],
        total_items: int,
        page: int,
        page_size: int,
    ) -> "PaginatedResponse[T]":
        """
        Create paginated response with calculated metadata.

        Args:
            items: List of items for current page.
            total_items: Total number of items across all pages.
            page: Current page number.
            page_size: Number of items per page.

        Returns:
            PaginatedResponse with items and metadata.
        """
        # Calculate total pages (handle division by zero)
        total_pages = (
            (total_items + page_size - 1) // page_size if page_size > 0 else 0
        )

        # Ensure total_pages is at least 1 if there are items
        if total_items > 0 and total_pages == 0:
            total_pages = 1

        meta = PaginationMeta(
            total_items=total_items,
            total_pages=total_pages,
            current_page=page,
            page_size=page_size,
            has_next=page < total_pages,
            has_previous=page > 1,
        )

        return cls(items=items, meta=meta)


class CursorPaginationParams(BaseSchema):
    """Cursor-based pagination parameters (for infinite scroll)."""

    cursor: Optional[str] = Field(
        None,
        description="Cursor for next page",
    )
    limit: int = Field(
        20,
        ge=1,
        le=100,
        description="Number of items to fetch",
    )


class CursorPaginationMeta(BaseSchema):
    """Cursor pagination metadata."""

    next_cursor: Optional[str] = Field(
        None,
        description="Cursor for next page",
    )
    has_more: bool = Field(
        ...,
        description="Whether more items exist",
    )


class CursorPaginatedResponse(BaseSchema, Generic[T]):
    """Generic cursor-based paginated response."""

    items: List[T] = Field(..., description="List of items")
    meta: CursorPaginationMeta = Field(
        ...,
        description="Cursor pagination metadata",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\response.py ---
# --- File: app/schemas/common/response.py ---
"""
Standard API response wrappers for success, error, and bulk operations.
"""

from __future__ import annotations

from typing import Any, Dict, Generic, List, Optional, TypeVar

from pydantic import Field

from app.schemas.common.base import BaseSchema

T = TypeVar("T")

__all__ = [
    "SuccessResponse",
    "ErrorDetail",
    "ErrorResponse",
    "MessageResponse",
    "BulkOperationResponse",
    "ValidationErrorResponse",
    "NotFoundResponse",
    "UnauthorizedResponse",
    "ForbiddenResponse",
    "ConflictResponse",
    "RateLimitResponse",
]


class SuccessResponse(BaseSchema, Generic[T]):
    """Standard success response."""

    success: bool = Field(True, description="Success flag")
    message: str = Field(..., description="Response message")
    data: Optional[T] = Field(None, description="Response data")

    @classmethod
    def create(
        cls,
        message: str,
        data: Optional[T] = None,
    ) -> "SuccessResponse[T]":
        """Create success response."""
        return cls(success=True, message=message, data=data)


class ErrorDetail(BaseSchema):
    """Error detail information."""

    field: Optional[str] = Field(
        None,
        description="Field name causing error",
    )
    message: str = Field(..., description="Error message")
    code: Optional[str] = Field(
        None,
        description="Error code",
    )
    location: Optional[List[str]] = Field(
        None,
        description="Error location in nested structure",
    )


class ErrorResponse(BaseSchema):
    """Standard error response."""

    success: bool = Field(False, description="Success flag")
    message: str = Field(..., description="Error message")
    errors: Optional[List[ErrorDetail]] = Field(
        None,
        description="Detailed errors",
    )
    error_code: Optional[str] = Field(
        None,
        description="Application error code",
    )
    timestamp: Optional[str] = Field(
        None,
        description="Error timestamp",
    )
    path: Optional[str] = Field(
        None,
        description="Request path that caused error",
    )

    @classmethod
    def create(
        cls,
        message: str,
        errors: Optional[List[ErrorDetail]] = None,
        error_code: Optional[str] = None,
    ) -> "ErrorResponse":
        """Create error response."""
        return cls(
            success=False,
            message=message,
            errors=errors,
            error_code=error_code,
        )


class MessageResponse(BaseSchema):
    """Simple message response."""

    message: str = Field(..., description="Response message")

    @classmethod
    def create(cls, message: str) -> "MessageResponse":
        """Create message response."""
        return cls(message=message)


class BulkOperationResponse(BaseSchema):
    """Response for bulk operations."""

    total: int = Field(
        ...,
        ge=0,
        description="Total items processed",
    )
    successful: int = Field(
        ...,
        ge=0,
        description="Successfully processed items",
    )
    failed: int = Field(
        ...,
        ge=0,
        description="Failed items",
    )
    errors: Optional[List[Dict[str, Any]]] = Field(
        None,
        description="Errors for failed items",
    )
    details: Optional[Dict[str, Any]] = Field(
        None,
        description="Additional operation details",
    )

    @classmethod
    def create(
        cls,
        total: int,
        successful: int,
        failed: int,
        errors: Optional[List[Dict[str, Any]]] = None,
        details: Optional[Dict[str, Any]] = None,
    ) -> "BulkOperationResponse":
        """Create bulk operation response."""
        return cls(
            total=total,
            successful=successful,
            failed=failed,
            errors=errors,
            details=details,
        )


class ValidationErrorResponse(ErrorResponse):
    """Validation error response (422)."""

    validation_errors: List[ErrorDetail] = Field(
        ...,
        description="Validation error details",
    )


class NotFoundResponse(ErrorResponse):
    """Not found error response (404)."""

    resource_type: Optional[str] = Field(
        None,
        description="Type of resource not found",
    )
    resource_id: Optional[str] = Field(
        None,
        description="ID of resource not found",
    )


class UnauthorizedResponse(ErrorResponse):
    """Unauthorized error response (401)."""

    auth_scheme: Optional[str] = Field(
        None,
        description="Authentication scheme required",
    )


class ForbiddenResponse(ErrorResponse):
    """Forbidden error response (403)."""

    required_permission: Optional[str] = Field(
        None,
        description="Required permission",
    )
    user_permissions: Optional[List[str]] = Field(
        None,
        description="User's current permissions",
    )


class ConflictResponse(ErrorResponse):
    """Conflict error response (409)."""

    conflicting_resource: Optional[str] = Field(
        None,
        description="Conflicting resource identifier",
    )


class RateLimitResponse(ErrorResponse):
    """Rate limit exceeded response (429)."""

    retry_after: Optional[int] = Field(
        None,
        description="Seconds to wait before retry",
    )
    limit: Optional[int] = Field(
        None,
        description="Rate limit",
    )
    window: Optional[int] = Field(
        None,
        description="Time window in seconds",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\common\__init__.py ---
# --- File: app/schemas/common/__init__.py ---
"""
Common schemas package.

This __init__ module re-exports frequently used base schemas, enums,
pagination helpers, responses, and filters from a single location:

    from app.schemas.common import BaseSchema, UserRole, PaginationParams
"""

from __future__ import annotations

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseDBSchema,
    BaseFilterSchema,
    BaseResponseSchema,
    BaseSchema,
    BaseUpdateSchema,
    SoftDeleteMixin,
    TimestampMixin,
    UUIDMixin,
)
from app.schemas.common.enums import (
    AnnouncementCategory,
    AttendanceStatus,
    BillingCycle,
    BookingStatus,
    ComplaintCategory,
    ComplaintStatus,
    DietaryPreference,
    DeviceType,
    EmploymentType,
    Gender,
    IDProofType,
    InquiryStatus,
    MealType,
    MaintenanceCategory,
    MaintenanceStatus,
    NotificationStatus,
    NotificationType,
    PaymentMethod,
    PaymentStatus,
    PaymentType,
    Priority,
    ReferralStatus,
    ReviewStatus,
    RoomType,
    SearchSource,
    StudentStatus,
    SubscriptionPlan,
    SubscriptionStatus,
    SupervisorStatus,
    TargetAudience,
    UserRole,
)
from app.schemas.common.filters import (
    DateRangeFilter,
    DateTimeRangeFilter,
    PriceRangeFilter,
    SearchFilter,
    SortOptions,
    StatusFilter,
)
from app.schemas.common.pagination import (
    PaginatedResponse,
    PaginationMeta,
    PaginationParams,
)
from app.schemas.common.response import (
    BulkOperationResponse,
    ErrorDetail,
    ErrorResponse,
    MessageResponse,
    SuccessResponse,
)

__all__ = [
    # Base schemas
    "BaseSchema",
    "BaseCreateSchema",
    "BaseUpdateSchema",
    "BaseResponseSchema",
    "BaseDBSchema",
    "BaseFilterSchema",
    "TimestampMixin",
    "SoftDeleteMixin",
    "UUIDMixin",
    # Enums
    "UserRole",
    "Gender",
    "RoomType",
    "BookingStatus",
    "PaymentStatus",
    "PaymentMethod",
    "PaymentType",
    "ComplaintCategory",
    "ComplaintStatus",
    "Priority",
    "AttendanceStatus",
    "MaintenanceCategory",
    "MaintenanceStatus",
    "NotificationType",
    "SubscriptionPlan",
    "StudentStatus",
    "SupervisorStatus",
    "AnnouncementCategory",
    "TargetAudience",
    "MealType",
    "DietaryPreference",
    "IDProofType",
    "EmploymentType",
    "BillingCycle",
    "SubscriptionStatus",
    "ReferralStatus",
    "ReviewStatus",
    "NotificationStatus",
    "DeviceType",
    "SearchSource",
    "InquiryStatus",
    # Pagination
    "PaginationParams",
    "PaginationMeta",
    "PaginatedResponse",
    # Responses
    "SuccessResponse",
    "ErrorDetail",
    "ErrorResponse",
    "MessageResponse",
    "BulkOperationResponse",
    # Filters
    "DateRangeFilter",
    "DateTimeRangeFilter",
    "PriceRangeFilter",
    "SearchFilter",
    "SortOptions",
    "StatusFilter",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\common\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\all_folders_files_content.txt ---
<<<<<<< Updated upstream
<<<<<<< Updated upstream
### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\complaint ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\complaint =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\complaint\complaint_analytics.py ---
=======
=======
>>>>>>> Stashed changes
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_analytics.py ---
<<<<<<< Updated upstream
>>>>>>> Stashed changes
=======
>>>>>>> Stashed changes
"""
Complaint analytics schemas
"""
from datetime import date
from decimal import Decimal
from typing import Dict, List
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema


class ComplaintAnalytics(BaseSchema):
    """Comprehensive complaint analytics"""
    hostel_id: Optional[UUID] = None
    period_start: date
    period_end: date
    
    # Summary
    total_complaints: int
    open_complaints: int
    resolved_complaints: int
    closed_complaints: int
    
    # Resolution metrics
    resolution_metrics: "ResolutionMetrics"
    
    # Category analysis
    category_analysis: "CategoryAnalysis"
    
    # Priority distribution
    priority_distribution: Dict[str, int]
    
    # Trend
    complaint_trend: List["ComplaintTrendPoint"]
    
    # SLA performance
    sla_compliance_rate: Decimal
    sla_breached_count: int
    
    # Staff performance
    top_resolvers: List["StaffPerformance"]


class ResolutionMetrics(BaseSchema):
    """Resolution performance metrics"""
    total_resolved: int
    
    # Time metrics
    average_resolution_time_hours: Decimal
    median_resolution_time_hours: Decimal
    fastest_resolution_hours: Decimal
    slowest_resolution_hours: Decimal
    
    # Resolution rate
    resolution_rate: Decimal = Field(..., description="% of complaints resolved")
    same_day_resolution_rate: Decimal
    
    # Escalation
    escalation_rate: Decimal = Field(..., description="% of complaints escalated")
    
    # Reopened
    reopen_rate: Decimal = Field(..., description="% of resolved complaints reopened")


class CategoryAnalysis(BaseSchema):
    """Analysis by complaint category"""
    categories: List["CategoryMetrics"]
    
    most_common_category: str
    most_problematic_category: str = Field(..., description="Category with longest resolution time")


class CategoryMetrics(BaseSchema):
    """Metrics for single category"""
    category: str
    total_complaints: int
    open_complaints: int
    resolved_complaints: int
    
    average_resolution_time_hours: Decimal
    resolution_rate: Decimal
    
    percentage_of_total: Decimal


class ComplaintTrendPoint(BaseSchema):
    """Complaint trend data point"""
    period: str = Field(..., description="Date, week, or month")
    total_complaints: int
    open_complaints: int
    resolved_complaints: int
    
    # By priority
    urgent_count: int
    high_count: int
    medium_count: int
    low_count: int


class StaffPerformance(BaseSchema):
    """Staff complaint resolution performance"""
    staff_id: UUID
    staff_name: str
    staff_role: str
    
    complaints_assigned: int
    complaints_resolved: int
    
    average_resolution_time_hours: Decimal
    resolution_rate: Decimal
    
    average_rating: Optional[Decimal] = None


class ComplaintHeatmap(BaseSchema):
    """Complaint heatmap by time/location"""
    hostel_id: UUID
    
    # By hour of day
    complaints_by_hour: Dict[int, int] = Field(..., description="Hour (0-23) -> count")
    
    # By day of week
    complaints_by_day: Dict[str, int] = Field(..., description="Day -> count")
    
    # By room/floor
    complaints_by_room: List["RoomComplaintCount"]
    complaints_by_floor: Dict[int, int]


class RoomComplaintCount(BaseSchema):
    """Complaint count by room"""
    room_id: UUID
    room_number: str
    complaint_count: int
    
    most_common_category: str

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\complaint\complaint_assignment.py ---
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_assignment.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_assignment.py ---
>>>>>>> Stashed changes
"""
Complaint assignment schemas
"""
from datetime import datetime
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class AssignmentRequest(BaseCreateSchema):
    """Assign complaint to staff member"""
    complaint_id: UUID = Field(..., description="Complaint ID")
    assigned_to: UUID = Field(..., description="User ID to assign to (supervisor/staff)")
    
    # Optional
    estimated_resolution_time: Optional[datetime] = Field(
        None,
        description="Estimated resolution time"
    )
    
    assignment_notes: Optional[str] = Field(None, max_length=500)


class AssignmentResponse(BaseSchema):
    """Assignment response"""
    complaint_id: UUID
    complaint_number: str
    
    assigned_to: UUID
    assigned_to_name: str
    assigned_by: UUID
    assigned_by_name: str
    
    assigned_at: datetime
    
    message: str


class ReassignmentRequest(BaseCreateSchema):
    """Reassign complaint to different staff"""
    complaint_id: UUID
    new_assigned_to: UUID = Field(..., description="New assignee")
    
    reassignment_reason: str = Field(..., min_length=10, max_length=500)
    
    # Notify previous assignee
    notify_previous_assignee: bool = Field(True)


class BulkAssignment(BaseCreateSchema):
    """Assign multiple complaints"""
    complaint_ids: List[UUID] = Field(..., min_items=1)
    assigned_to: UUID
    
    assignment_notes: Optional[str] = None


class UnassignRequest(BaseCreateSchema):
    """Unassign complaint"""
    complaint_id: UUID
    reason: str = Field(..., min_length=10, max_length=500)

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\complaint\complaint_base.py ---
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_base.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_base.py ---
>>>>>>> Stashed changes
"""
Complaint base schemas
"""
from typing import List, Optional
from pydantic import Field, HttpUrl
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseUpdateSchema, BaseSchema
from app.schemas.common.enums import ComplaintCategory, ComplaintStatus, Priority


class ComplaintBase(BaseSchema):
    """Base complaint schema"""
    hostel_id: UUID = Field(..., description="Hostel ID")
    raised_by: UUID = Field(..., description="User who raised complaint")
    student_id: Optional[UUID] = Field(None, description="Student ID if raised by student")
    
    # Complaint details
    title: str = Field(..., min_length=5, max_length=255, description="Complaint title")
    description: str = Field(..., min_length=20, max_length=2000, description="Detailed description")
    
    category: ComplaintCategory = Field(..., description="Complaint category")
    sub_category: Optional[str] = Field(None, max_length=100, description="Sub-category")
    
    priority: Priority = Field(Priority.MEDIUM, description="Priority level")
    
    # Location
    room_id: Optional[UUID] = Field(None, description="Related room")
    location_details: Optional[str] = Field(None, max_length=500, description="Specific location details")
    
    # Attachments
    attachments: List[HttpUrl] = Field(default_factory=list, description="Photo/document URLs")


class ComplaintCreate(ComplaintBase, BaseCreateSchema):
    """Create complaint schema"""
    pass


class ComplaintUpdate(BaseUpdateSchema):
    """Update complaint schema"""
    title: Optional[str] = Field(None, min_length=5, max_length=255)
    description: Optional[str] = Field(None, min_length=20, max_length=2000)
    category: Optional[ComplaintCategory] = None
    sub_category: Optional[str] = None
    priority: Optional[Priority] = None
    location_details: Optional[str] = None
    attachments: Optional[List[HttpUrl]] = None
    
    # Status updates
    status: Optional[ComplaintStatus] = None


class ComplaintStatusUpdate(BaseUpdateSchema):
    """Update complaint status"""
    status: ComplaintStatus = Field(..., description="New status")
    notes: Optional[str] = Field(None, max_length=500, description="Status change notes")

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\complaint\complaint_comments.py ---
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_comments.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_comments.py ---
>>>>>>> Stashed changes
"""
Complaint comments/discussion schemas
"""
from datetime import datetime
from typing import List, Optional
from pydantic import Field, HttpUrl
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema


class CommentCreate(BaseCreateSchema):
    """Create comment on complaint"""
    complaint_id: UUID = Field(..., description="Complaint ID")
    
    comment_text: str = Field(..., min_length=5, max_length=1000, description="Comment text")
    
    # Internal or public
    is_internal: bool = Field(False, description="Internal note vs public comment")
    
    # Attachments
    attachments: List[HttpUrl] = Field(default_factory=list)


class CommentResponse(BaseResponseSchema):
    """Comment response"""
    complaint_id: UUID
    
    commented_by: UUID
    commented_by_name: str
    commented_by_role: str
    
    comment_text: str
    is_internal: bool
    
    attachments: List[str]
    
    created_at: datetime
    updated_at: datetime


class CommentList(BaseSchema):
    """List of comments for complaint"""
    complaint_id: UUID
    complaint_number: str
    
    total_comments: int
    public_comments: int
    internal_notes: int
    
    comments: List[CommentResponse]


class CommentUpdate(BaseCreateSchema):
    """Update comment"""
    comment_id: UUID
    comment_text: str = Field(..., min_length=5, max_length=1000)


class CommentDelete(BaseCreateSchema):
    """Delete comment"""
    comment_id: UUID
    reason: Optional[str] = Field(None, max_length=200)


class MentionNotification(BaseSchema):
    """Notification when mentioned in comment"""
    comment_id: UUID
    complaint_id: UUID
    complaint_number: str
    
    mentioned_by: UUID
    mentioned_by_name: str
    
    comment_excerpt: str
    
    comment_url: str

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\complaint\complaint_escalation.py ---
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_escalation.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_escalation.py ---
>>>>>>> Stashed changes
"""
Complaint escalation schemas
"""
from datetime import datetime
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema


class EscalationRequest(BaseCreateSchema):
    """Escalate complaint"""
    complaint_id: UUID = Field(..., description="Complaint ID")
    escalate_to: UUID = Field(..., description="User to escalate to (admin/supervisor)")
    
    escalation_reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Reason for escalation"
    )
    
    # Priority increase
    increase_priority: bool = Field(True, description="Increase priority level")
    
    # Urgency
    is_urgent: bool = Field(False)


class EscalationResponse(BaseSchema):
    """Escalation response"""
    complaint_id: UUID
    complaint_number: str
    
    escalated: bool
    escalated_to: UUID
    escalated_to_name: str
    escalated_by: UUID
    escalated_by_name: str
    escalated_at: datetime
    
    new_priority: str
    
    message: str


class EscalationHistory(BaseSchema):
    """Escalation history for complaint"""
    complaint_id: UUID
    complaint_number: str
    
    escalations: List["EscalationEntry"]
    total_escalations: int


class EscalationEntry(BaseResponseSchema):
    """Individual escalation entry"""
    escalated_to: UUID
    escalated_to_name: str
    escalated_by: UUID
    escalated_by_name: str
    escalated_at: datetime
    
    reason: str
    
    # Status at time of escalation
    status_before: str
    priority_before: str
    priority_after: str
    
    # Response time
    response_time_hours: Optional[int] = None
    resolved_after_escalation: bool


class AutoEscalationRule(BaseSchema):
    """Auto-escalation rule configuration"""
    hostel_id: UUID
    
    # Trigger conditions
    escalate_after_hours: int = Field(24, description="Hours before auto-escalation")
    escalate_on_sla_breach: bool = Field(True)
    
    # Priority-based rules
    urgent_escalation_hours: int = Field(4)
    high_escalation_hours: int = Field(12)
    medium_escalation_hours: int = Field(24)
    
    # Escalation chain
    first_escalation_to: UUID = Field(..., description="First level escalation")
    second_escalation_to: Optional[UUID] = Field(None, description="Second level if not resolved")
    
    is_active: bool = Field(True)

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\complaint\complaint_feedback.py ---
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_feedback.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_feedback.py ---
>>>>>>> Stashed changes
"""
Complaint feedback schemas
"""
from datetime import datetime
from typing import Optional
from pydantic import Field, field_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema


class FeedbackRequest(BaseCreateSchema):
    """Submit feedback on resolved complaint"""
    complaint_id: UUID = Field(..., description="Complaint ID")
    
    rating: int = Field(..., ge=1, le=5, description="Rating 1-5")
    
    feedback: Optional[str] = Field(None, max_length=1000, description="Detailed feedback")
    
    # Satisfaction questions
    issue_resolved_satisfactorily: bool = Field(..., description="Was issue resolved well?")
    response_time_satisfactory: bool = Field(..., description="Was response time good?")
    staff_helpful: bool = Field(..., description="Was staff helpful?")
    
    # Would recommend
    would_recommend: Optional[bool] = Field(None, description="Would recommend complaint system")


class FeedbackResponse(BaseResponseSchema):
    """Feedback response"""
    complaint_id: UUID
    complaint_number: str
    
    rating: int
    feedback: Optional[str]
    
    submitted_by: UUID
    submitted_at: datetime
    
    message: str


class FeedbackSummary(BaseSchema):
    """Feedback summary for hostel/supervisor"""
    entity_id: UUID
    entity_type: str = Field(..., pattern="^(hostel|supervisor)$")
    
    # Period
    period_start: date
    period_end: date
    
    # Overall stats
    total_feedbacks: int
    average_rating: Decimal
    
    # Rating distribution
    rating_5_count: int
    rating_4_count: int
    rating_3_count: int
    rating_2_count: int
    rating_1_count: int
    
    # Satisfaction metrics
    resolution_satisfaction_rate: Decimal = Field(..., description="% satisfied with resolution")
    response_time_satisfaction_rate: Decimal
    staff_helpfulness_rate: Decimal
    
    # Recommendation
    recommendation_rate: Decimal = Field(..., description="% who would recommend")
    
    # Comments analysis
    positive_feedback_count: int
    negative_feedback_count: int
    common_themes: List[str] = Field(default_factory=list)


class FeedbackAnalysis(BaseSchema):
    """Detailed feedback analysis"""
    hostel_id: UUID
    period_start: date
    period_end: date
    
    # Trend
    rating_trend: List["RatingTrendPoint"]
    
    # By category
    feedback_by_category: dict = Field(..., description="Average rating by complaint category")
    
    # By priority
    feedback_by_priority: dict
    
    # Response time impact
    avg_rating_quick_response: Decimal
    avg_rating_slow_response: Decimal


class RatingTrendPoint(BaseSchema):
    """Rating trend data point"""
    period: str = Field(..., description="Date or week")
    average_rating: Decimal
    feedback_count: int

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\complaint\complaint_filters.py ---
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_filters.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_filters.py ---
>>>>>>> Stashed changes
"""
Complaint filter and search schemas
"""
from datetime import date, datetime
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import ComplaintCategory, ComplaintStatus, Priority


class ComplaintFilterParams(BaseFilterSchema):
    """Complaint filter parameters"""
    # Text search
    search: Optional[str] = Field(None, description="Search in title, description, number")
    
    # Hostel filter
    hostel_id: Optional[UUID] = None
    hostel_ids: Optional[List[UUID]] = None
    
    # Raised by
    raised_by: Optional[UUID] = None
    student_id: Optional[UUID] = None
    
    # Assignment
    assigned_to: Optional[UUID] = None
    unassigned_only: Optional[bool] = None
    
    # Category
    category: Optional[ComplaintCategory] = None
    categories: Optional[List[ComplaintCategory]] = None
    
    # Priority
    priority: Optional[Priority] = None
    priorities: Optional[List[Priority]] = None
    
    # Status
    status: Optional[ComplaintStatus] = None
    statuses: Optional[List[ComplaintStatus]] = None
    
    # Date filters
    opened_date_from: Optional[date] = None
    opened_date_to: Optional[date] = None
    resolved_date_from: Optional[date] = None
    resolved_date_to: Optional[date] = None
    
    # SLA
    sla_breached_only: Optional[bool] = None
    
    # Escalation
    escalated_only: Optional[bool] = None
    
    # Room
    room_id: Optional[UUID] = None
    
    # Age
    age_hours_min: Optional[int] = Field(None, ge=0)
    age_hours_max: Optional[int] = Field(None, ge=0)


class ComplaintSearchRequest(BaseFilterSchema):
    """Complaint search request"""
    query: str = Field(..., min_length=1, description="Search query")
    hostel_id: Optional[UUID] = None
    
    # Search fields
    search_in_title: bool = Field(True)
    search_in_description: bool = Field(True)
    search_in_number: bool = Field(True)
    
    # Filters
    status: Optional[ComplaintStatus] = None
    priority: Optional[Priority] = None
    
    # Pagination
    page: int = Field(1, ge=1)
    page_size: int = Field(20, ge=1, le=100)


class ComplaintSortOptions(BaseFilterSchema):
    """Complaint sorting options"""
    sort_by: str = Field(
        "opened_at",
        pattern="^(opened_at|priority|status|category|age)$"
    )
    sort_order: str = Field("desc", pattern="^(asc|desc)$")


class ComplaintExportRequest(BaseFilterSchema):
    """Export complaints"""
    hostel_id: Optional[UUID] = None
    filters: Optional[ComplaintFilterParams] = None
    
    format: str = Field("csv", pattern="^(csv|excel|pdf)$")
    
    # Fields to include
    include_comments: bool = Field(False)
    include_resolution_details: bool = Field(True)
    include_feedback: bool = Field(True)

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\complaint\complaint_resolution.py ---
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_resolution.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_resolution.py ---
>>>>>>> Stashed changes
"""
Complaint resolution schemas
"""
from datetime import datetime
from typing import List, Optional
from pydantic import Field, HttpUrl
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class ResolutionRequest(BaseCreateSchema):
    """Mark complaint as resolved"""
    complaint_id: UUID = Field(..., description="Complaint ID")
    
    resolution_notes: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Resolution details"
    )
    
    # Attachments (proof of resolution)
    resolution_attachments: List[HttpUrl] = Field(
        default_factory=list,
        description="Photos/documents of resolved issue"
    )
    
    # Time tracking
    actual_resolution_time: Optional[datetime] = Field(
        None,
        description="Actual time taken to resolve"
    )
    
    # Follow-up required
    follow_up_required: bool = Field(False)
    follow_up_date: Optional[date] = None
    follow_up_notes: Optional[str] = None


class ResolutionResponse(BaseSchema):
    """Resolution response"""
    complaint_id: UUID
    complaint_number: str
    
    resolved: bool
    resolved_at: datetime
    resolved_by: UUID
    resolved_by_name: str
    
    resolution_notes: str
    
    # Time taken
    time_to_resolve_hours: int
    sla_met: bool
    
    message: str


class ResolutionUpdate(BaseCreateSchema):
    """Update resolution details"""
    complaint_id: UUID
    
    resolution_notes: Optional[str] = Field(None, min_length=20, max_length=2000)
    resolution_attachments: Optional[List[HttpUrl]] = None
    follow_up_notes: Optional[str] = None


class ReopenRequest(BaseCreateSchema):
    """Reopen resolved complaint"""
    complaint_id: UUID
    
    reopen_reason: str = Field(..., min_length=20, max_length=500)
    
    # Additional details
    additional_issues: Optional[str] = Field(None, max_length=1000)
    new_attachments: List[HttpUrl] = Field(default_factory=list)


class CloseRequest(BaseCreateSchema):
    """Close complaint (final)"""
    complaint_id: UUID
    
    closure_notes: Optional[str] = Field(None, max_length=500)
    
    # Require student confirmation
    student_confirmed: bool = Field(False, description="Student confirmed resolution")

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\complaint\complaint_response.py ---
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_response.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_response.py ---
>>>>>>> Stashed changes
"""
Complaint response schemas
"""
from datetime import datetime
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import ComplaintCategory, ComplaintStatus, Priority


class ComplaintResponse(BaseResponseSchema):
    """Complaint response schema"""
    complaint_number: str
    hostel_id: UUID
    hostel_name: str
    
    raised_by: UUID
    raised_by_name: str
    student_id: Optional[UUID]
    
    title: str
    category: ComplaintCategory
    priority: Priority
    status: ComplaintStatus
    
    assigned_to: Optional[UUID]
    assigned_to_name: Optional[str]
    
    opened_at: datetime
    resolved_at: Optional[datetime]
    
    # SLA
    sla_breach: bool
    age_hours: int


class ComplaintDetail(BaseResponseSchema):
    """Detailed complaint information"""
    complaint_number: str
    
    # Hostel
    hostel_id: UUID
    hostel_name: str
    
    # Raised by
    raised_by: UUID
    raised_by_name: str
    raised_by_email: str
    raised_by_phone: str
    
    student_id: Optional[UUID]
    student_name: Optional[str]
    room_number: Optional[str]
    
    # Complaint details
    title: str
    description: str
    category: ComplaintCategory
    sub_category: Optional[str]
    priority: Priority
    
    # Location
    room_id: Optional[UUID]
    location_details: Optional[str]
    
    # Attachments
    attachments: List[str]
    
    # Assignment
    assigned_to: Optional[UUID]
    assigned_to_name: Optional[str]
    assigned_by: Optional[UUID]
    assigned_by_name: Optional[str]
    assigned_at: Optional[datetime]
    reassigned_count: int
    
    # Status workflow
    status: ComplaintStatus
    opened_at: datetime
    in_progress_at: Optional[datetime]
    resolved_at: Optional[datetime]
    closed_at: Optional[datetime]
    closed_by: Optional[UUID]
    closed_by_name: Optional[str]
    
    # Resolution
    resolution_notes: Optional[str]
    resolution_attachments: List[str]
    estimated_resolution_time: Optional[datetime]
    actual_resolution_time: Optional[datetime]
    
    # Feedback
    student_feedback: Optional[str]
    student_rating: Optional[int]
    feedback_submitted_at: Optional[datetime]
    
    # SLA
    sla_breach: bool
    sla_breach_reason: Optional[str]
    
    # Escalation
    escalated: bool
    escalated_to: Optional[UUID]
    escalated_to_name: Optional[str]
    escalated_at: Optional[datetime]
    escalation_reason: Optional[str]
    
    # Admin override
    overridden_by_admin: bool
    override_admin_id: Optional[UUID]
    override_timestamp: Optional[datetime]
    override_reason: Optional[str]
    
    # Comments count
    total_comments: int
    
    # Time tracking
    age_hours: int
    time_to_resolve_hours: Optional[int]


class ComplaintListItem(BaseSchema):
    """Complaint list item"""
    id: UUID
    complaint_number: str
    title: str
    
    category: str
    priority: str
    status: ComplaintStatus
    
    raised_by_name: str
    room_number: Optional[str]
    
    assigned_to_name: Optional[str]
    
    opened_at: datetime
    age_hours: int
    
    sla_breach: bool


class ComplaintSummary(BaseSchema):
    """Complaint summary for dashboard"""
    hostel_id: UUID
    
    total_complaints: int
    open_complaints: int
    in_progress_complaints: int
    resolved_complaints: int
    
    high_priority_count: int
    urgent_priority_count: int
    
    sla_breached_count: int
    
    average_resolution_time_hours: Decimal

<<<<<<< Updated upstream
<<<<<<< Updated upstream
# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\complaint\__init__.py ---
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\__init__.py ---
>>>>>>> Stashed changes
=======
# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\__init__.py ---
>>>>>>> Stashed changes
"""
Complaint schemas package
"""
from app.schemas.complaint.complaint_base import (
    ComplaintBase,
    ComplaintCreate,
    ComplaintUpdate
)
from app.schemas.complaint.complaint_response import (
    ComplaintResponse,
    ComplaintDetail,
    ComplaintListItem
)
from app.schemas.complaint.complaint_assignment import (
    AssignmentRequest,
    AssignmentResponse,
    ReassignmentRequest
)
from app.schemas.complaint.complaint_resolution import (
    ResolutionRequest,
    ResolutionResponse,
    ResolutionUpdate
)
from app.schemas.complaint.complaint_escalation import (
    EscalationRequest,
    EscalationResponse,
    EscalationHistory
)
from app.schemas.complaint.complaint_feedback import (
    FeedbackRequest,
    FeedbackResponse,
    FeedbackSummary
)
from app.schemas.complaint.complaint_comments import (
    CommentCreate,
    CommentResponse,
    CommentList
)
from app.schemas.complaint.complaint_filters import (
    ComplaintFilterParams,
    ComplaintSearchRequest,
    ComplaintSortOptions
)
from app.schemas.complaint.complaint_analytics import (
    ComplaintAnalytics,
    ResolutionMetrics,
    CategoryAnalysis
)

__all__ = [
    # Base
    "ComplaintBase",
    "ComplaintCreate",
    "ComplaintUpdate",
    
    # Response
    "ComplaintResponse",
    "ComplaintDetail",
    "ComplaintListItem",
    
    # Assignment
    "AssignmentRequest",
    "AssignmentResponse",
    "ReassignmentRequest",
    
    # Resolution
    "ResolutionRequest",
    "ResolutionResponse",
    "ResolutionUpdate",
    
    # Escalation
    "EscalationRequest",
    "EscalationResponse",
    "EscalationHistory",
    
    # Feedback
    "FeedbackRequest",
    "FeedbackResponse",
    "FeedbackSummary",
    
    # Comments
    "CommentCreate",
    "CommentResponse",
    "CommentList",
    
    # Filters
    "ComplaintFilterParams",
    "ComplaintSearchRequest",
    "ComplaintSortOptions",
    
    # Analytics
    "ComplaintAnalytics",
    "ResolutionMetrics",
    "CategoryAnalysis",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_analytics.py ---
"""
Complaint analytics and reporting schemas.

Provides comprehensive analytics, metrics, and insights
for complaint management performance.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator

from app.schemas.common.base import BaseSchema

__all__ = [
    "ComplaintAnalytics",
    "ResolutionMetrics",
    "CategoryAnalysis",
    "CategoryMetrics",
    "ComplaintTrendPoint",
    "StaffPerformance",
    "ComplaintHeatmap",
    "RoomComplaintCount",
]


class ComplaintAnalytics(BaseSchema):
    """
    Comprehensive complaint analytics dashboard.
    
    Provides holistic view of complaint management performance.
    """

    hostel_id: Optional[str] = Field(
        None,
        description="Hostel ID (None for system-wide analytics)",
    )
    period_start: date = Field(..., description="Analytics period start")
    period_end: date = Field(..., description="Analytics period end")

    # Summary counts
    total_complaints: int = Field(ge=0, description="Total complaints")
    open_complaints: int = Field(ge=0, description="Open complaints")
    resolved_complaints: int = Field(ge=0, description="Resolved complaints")
    closed_complaints: int = Field(ge=0, description="Closed complaints")

    # Detailed metrics
    resolution_metrics: "ResolutionMetrics" = Field(
        ...,
        description="Resolution performance metrics",
    )

    category_analysis: "CategoryAnalysis" = Field(
        ...,
        description="Category-wise breakdown",
    )

    priority_distribution: Dict[str, int] = Field(
        default_factory=dict,
        description="Distribution by priority level",
    )

    complaint_trend: List["ComplaintTrendPoint"] = Field(
        default_factory=list,
        description="Time-series trend data",
    )

    # SLA metrics
    sla_compliance_rate: Decimal = Field(
        ge=0,
        le=100,
        description="SLA compliance percentage",
    )
    sla_breached_count: int = Field(
        ge=0,
        description="SLA breached complaint count",
    )

    # Staff performance
    top_resolvers: List["StaffPerformance"] = Field(
        default_factory=list,
        max_length=10,
        description="Top 10 complaint resolvers",
    )

    @field_validator("period_end")
    @classmethod
    def validate_period_range(cls, v: date, info) -> date:
        """Validate analytics period is logical."""
        period_start = info.data.get("period_start")
        if period_start and v < period_start:
            raise ValueError("period_end must be >= period_start")
        return v


class ResolutionMetrics(BaseSchema):
    """
    Detailed complaint resolution performance metrics.
    
    Tracks resolution efficiency and quality indicators.
    """

    total_resolved: int = Field(ge=0, description="Total resolved count")

    # Time metrics (in hours)
    average_resolution_time_hours: Decimal = Field(
        ge=0,
        description="Average resolution time (hours)",
    )
    median_resolution_time_hours: Decimal = Field(
        ge=0,
        description="Median resolution time (hours)",
    )
    fastest_resolution_hours: Decimal = Field(
        ge=0,
        description="Fastest resolution time (hours)",
    )
    slowest_resolution_hours: Decimal = Field(
        ge=0,
        description="Slowest resolution time (hours)",
    )

    # Performance rates
    resolution_rate: Decimal = Field(
        ge=0,
        le=100,
        description="% of complaints resolved",
    )
    same_day_resolution_rate: Decimal = Field(
        ge=0,
        le=100,
        description="% resolved within 24 hours",
    )

    # Escalation metrics
    escalation_rate: Decimal = Field(
        ge=0,
        le=100,
        description="% of complaints escalated",
    )

    # Quality metrics
    reopen_rate: Decimal = Field(
        ge=0,
        le=100,
        description="% of resolved complaints reopened",
    )


class CategoryAnalysis(BaseSchema):
    """
    Category-wise complaint analysis.
    
    Identifies problem areas and trends by category.
    """

    categories: List["CategoryMetrics"] = Field(
        default_factory=list,
        description="Metrics for each category",
    )

    most_common_category: str = Field(
        ...,
        description="Category with most complaints",
    )
    most_problematic_category: str = Field(
        ...,
        description="Category with longest avg resolution time",
    )


class CategoryMetrics(BaseSchema):
    """
    Metrics for a single complaint category.
    
    Provides detailed performance data per category.
    """

    category: str = Field(..., description="Category name")
    total_complaints: int = Field(ge=0, description="Total complaints")
    open_complaints: int = Field(ge=0, description="Open complaints")
    resolved_complaints: int = Field(ge=0, description="Resolved complaints")

    average_resolution_time_hours: Decimal = Field(
        ge=0,
        description="Average resolution time (hours)",
    )
    resolution_rate: Decimal = Field(
        ge=0,
        le=100,
        description="Resolution rate percentage",
    )

    percentage_of_total: Decimal = Field(
        ge=0,
        le=100,
        description="% of total complaints",
    )


class ComplaintTrendPoint(BaseSchema):
    """
    Time-series data point for complaint trends.
    
    Represents complaint metrics for a specific period.
    """

    period: str = Field(
        ...,
        description="Time period (date, week, or month)",
        examples=["2024-01-15", "2024-W03", "2024-01"],
    )
    total_complaints: int = Field(ge=0, description="Total complaints")
    open_complaints: int = Field(ge=0, description="Open complaints")
    resolved_complaints: int = Field(ge=0, description="Resolved complaints")

    # Priority breakdown
    urgent_count: int = Field(ge=0, description="Urgent priority count")
    high_count: int = Field(ge=0, description="High priority count")
    medium_count: int = Field(ge=0, description="Medium priority count")
    low_count: int = Field(ge=0, description="Low priority count")


class StaffPerformance(BaseSchema):
    """
    Individual staff member complaint resolution performance.
    
    Tracks productivity and quality metrics per staff member.
    """

    staff_id: str = Field(..., description="Staff member user ID")
    staff_name: str = Field(..., description="Staff member name")
    staff_role: str = Field(..., description="Staff member role")

    complaints_assigned: int = Field(
        ge=0,
        description="Total complaints assigned",
    )
    complaints_resolved: int = Field(
        ge=0,
        description="Total complaints resolved",
    )

    average_resolution_time_hours: Decimal = Field(
        ge=0,
        description="Average resolution time (hours)",
    )
    resolution_rate: Decimal = Field(
        ge=0,
        le=100,
        description="Resolution rate percentage",
    )

    average_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average feedback rating (1-5)",
    )


class ComplaintHeatmap(BaseSchema):
    """
    Complaint heatmap for pattern analysis.
    
    Identifies temporal and spatial complaint patterns.
    """

    hostel_id: str = Field(..., description="Hostel identifier")

    # Temporal patterns
    complaints_by_hour: Dict[int, int] = Field(
        default_factory=dict,
        description="Complaint count by hour of day (0-23)",
    )
    complaints_by_day: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaint count by day of week",
    )

    # Spatial patterns
    complaints_by_room: List["RoomComplaintCount"] = Field(
        default_factory=list,
        description="Complaint count by room",
    )
    complaints_by_floor: Dict[int, int] = Field(
        default_factory=dict,
        description="Complaint count by floor number",
    )

    @field_validator("complaints_by_hour")
    @classmethod
    def validate_hour_keys(cls, v: Dict[int, int]) -> Dict[int, int]:
        """Validate hour keys are in valid range (0-23)."""
        for hour in v.keys():
            if not 0 <= hour <= 23:
                raise ValueError(f"Invalid hour: {hour}. Must be 0-23")
        return v


class RoomComplaintCount(BaseSchema):
    """
    Complaint count and analysis for specific room.
    
    Helps identify problematic rooms.
    """

    room_id: str = Field(..., description="Room identifier")
    room_number: str = Field(..., description="Room number")
    complaint_count: int = Field(ge=0, description="Total complaints")

    most_common_category: str = Field(
        ...,
        description="Most frequent complaint category",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_assignment.py ---
"""
Complaint assignment and reassignment schemas.

Handles complaint assignment to staff members, reassignments,
bulk operations, and unassignment flows.
"""

from __future__ import annotations

from datetime import datetime
from typing import List, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "AssignmentRequest",
    "AssignmentResponse",
    "ReassignmentRequest",
    "BulkAssignment",
    "UnassignRequest",
    "AssignmentHistory",
]


class AssignmentRequest(BaseCreateSchema):
    """
    Request to assign complaint to a staff member.
    
    Supports optional estimated resolution time and notes
    for assignment context.
    """

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to assign",
    )
    assigned_to: str = Field(
        ...,
        description="User ID of assignee (supervisor/staff)",
    )

    estimated_resolution_time: Optional[datetime] = Field(
        None,
        description="Estimated resolution timestamp",
    )

    assignment_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Assignment context or instructions",
    )

    @field_validator("assignment_notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize assignment notes."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @field_validator("estimated_resolution_time")
    @classmethod
    def validate_estimated_time(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Ensure estimated resolution time is in the future."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError(
                "Estimated resolution time must be in the future"
            )
        return v


class AssignmentResponse(BaseSchema):
    """
    Response after successful complaint assignment.
    
    Provides confirmation details and assignment metadata.
    """

    complaint_id: str = Field(..., description="Assigned complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    assigned_to: str = Field(..., description="Assignee user ID")
    assigned_to_name: str = Field(..., description="Assignee name")
    assigned_by: str = Field(..., description="User who performed assignment")
    assigned_by_name: str = Field(..., description="Assigner name")

    assigned_at: datetime = Field(..., description="Assignment timestamp")

    message: str = Field(
        ...,
        description="Confirmation message",
        examples=["Complaint assigned successfully"],
    )


class ReassignmentRequest(BaseCreateSchema):
    """
    Request to reassign complaint to different staff member.
    
    Requires reason for reassignment to maintain audit trail.
    """

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to reassign",
    )
    new_assigned_to: str = Field(
        ...,
        description="New assignee user ID",
    )

    reassignment_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for reassignment (mandatory)",
    )

    notify_previous_assignee: bool = Field(
        default=True,
        description="Send notification to previous assignee",
    )

    @field_validator("reassignment_reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reassignment reason."""
        v = v.strip()
        if not v:
            raise ValueError("Reassignment reason cannot be empty")
        
        word_count = len(v.split())
        if word_count < 3:
            raise ValueError(
                "Reassignment reason must be at least 3 words"
            )
        
        return v


class BulkAssignment(BaseCreateSchema):
    """
    Bulk assignment of multiple complaints to one assignee.
    
    Useful for distributing workload efficiently.
    """

    complaint_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of complaint IDs to assign (max 50)",
    )
    assigned_to: str = Field(
        ...,
        description="User ID of assignee for all complaints",
    )

    assignment_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Common assignment notes",
    )

    @field_validator("complaint_ids")
    @classmethod
    def validate_complaint_ids_unique(cls, v: List[str]) -> List[str]:
        """Ensure complaint IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Complaint IDs must be unique")
        
        if len(v) > 50:
            raise ValueError("Cannot assign more than 50 complaints at once")
        
        return v

    @field_validator("assignment_notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize assignment notes."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v


class UnassignRequest(BaseCreateSchema):
    """
    Request to unassign complaint from current assignee.
    
    Requires reason for accountability.
    """

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to unassign",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for unassignment",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate unassignment reason."""
        v = v.strip()
        if not v:
            raise ValueError("Unassignment reason cannot be empty")
        
        word_count = len(v.split())
        if word_count < 3:
            raise ValueError(
                "Unassignment reason must be at least 3 words"
            )
        
        return v


class AssignmentHistory(BaseSchema):
    """
    Assignment history entry for audit trail.
    
    Tracks all assignment changes for a complaint.
    """

    complaint_id: str = Field(..., description="Complaint ID")
    
    assigned_to: str = Field(..., description="Assignee user ID")
    assigned_to_name: str = Field(..., description="Assignee name")
    
    assigned_by: str = Field(..., description="Assigner user ID")
    assigned_by_name: str = Field(..., description="Assigner name")
    
    assigned_at: datetime = Field(..., description="Assignment timestamp")
    unassigned_at: Optional[datetime] = Field(
        None,
        description="Unassignment timestamp",
    )
    
    reason: Optional[str] = Field(
        None,
        description="Assignment/reassignment reason",
    )
    
    duration_hours: Optional[int] = Field(
        None,
        ge=0,
        description="Duration assigned (hours)",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_base.py ---
"""
Core complaint schemas with enhanced validation and type safety.

This module provides base schemas for complaint creation, updates, and status management
with comprehensive field validation and business rule enforcement.
"""

from __future__ import annotations

from typing import List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import ComplaintCategory, ComplaintStatus, Priority

__all__ = [
    "ComplaintBase",
    "ComplaintCreate",
    "ComplaintUpdate",
    "ComplaintStatusUpdate",
]


class ComplaintBase(BaseSchema):
    """
    Base complaint schema with core fields and validation.
    
    This schema defines the fundamental structure of a complaint including
    identification, categorization, priority, and location details.
    """

    hostel_id: str = Field(
        ...,
        description="Hostel identifier where complaint originated",
    )
    raised_by: str = Field(
        ...,
        description="User ID who raised the complaint",
    )
    student_id: Optional[str] = Field(
        None,
        description="Student ID if complaint raised by a student",
    )

    # Complaint content
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Brief complaint title/summary",
    )
    description: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed complaint description",
    )

    # Classification
    category: ComplaintCategory = Field(
        ...,
        description="Primary complaint category",
    )
    sub_category: Optional[str] = Field(
        None,
        max_length=100,
        description="Optional sub-category for finer classification",
    )

    # Priority
    priority: Priority = Field(
        default=Priority.MEDIUM,
        description="Complaint priority level (defaults to medium)",
    )

    # Location details
    room_id: Optional[str] = Field(
        None,
        description="Room identifier if complaint is room-specific",
    )
    location_details: Optional[str] = Field(
        None,
        max_length=500,
        description="Detailed location information within hostel",
    )

    # Attachments
    attachments: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="URLs of supporting documents/photos (max 10)",
    )

    @field_validator("title")
    @classmethod
    def validate_title(cls, v: str) -> str:
        """
        Validate and normalize complaint title.
        
        Ensures title is meaningful and properly formatted.
        """
        v = v.strip()
        if not v:
            raise ValueError("Title cannot be empty or whitespace only")
        if v.isdigit():
            raise ValueError("Title cannot consist of only numbers")
        return v

    @field_validator("description")
    @classmethod
    def validate_description(cls, v: str) -> str:
        """
        Validate and normalize complaint description.
        
        Ensures description provides sufficient detail.
        """
        v = v.strip()
        if not v:
            raise ValueError("Description cannot be empty or whitespace only")
        
        # Check for minimum word count (at least 5 words)
        word_count = len(v.split())
        if word_count < 5:
            raise ValueError(
                "Description must contain at least 5 words for clarity"
            )
        
        return v

    @field_validator("sub_category")
    @classmethod
    def validate_sub_category(cls, v: Optional[str]) -> Optional[str]:
        """Normalize sub-category if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @field_validator("location_details")
    @classmethod
    def validate_location_details(cls, v: Optional[str]) -> Optional[str]:
        """Normalize location details if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @field_validator("attachments")
    @classmethod
    def validate_attachments_limit(cls, v: List[HttpUrl]) -> List[HttpUrl]:
        """Ensure attachment count doesn't exceed limit."""
        if len(v) > 10:
            raise ValueError("Maximum 10 attachments allowed per complaint")
        return v

    @model_validator(mode="after")
    def validate_location_consistency(self) -> "ComplaintBase":
        """
        Validate location-related fields are consistent.
        
        If room_id is provided, location_details should also be provided
        for better context.
        """
        if self.room_id and not self.location_details:
            # This is a soft validation - log warning but don't fail
            pass
        
        return self


class ComplaintCreate(ComplaintBase, BaseCreateSchema):
    """
    Schema for creating a new complaint.
    
    Inherits all validation from ComplaintBase and adds any
    create-specific validation if needed.
    """

    @model_validator(mode="after")
    def validate_create_specific_rules(self) -> "ComplaintCreate":
        """
        Enforce creation-specific business rules.
        
        Additional validation that only applies during complaint creation.
        """
        # Ensure high/urgent priority complaints have location details
        if self.priority in [Priority.HIGH, Priority.URGENT, Priority.CRITICAL]:
            if not self.location_details and not self.room_id:
                raise ValueError(
                    f"High priority complaints ({self.priority.value}) "
                    "must include location details or room ID"
                )
        
        return self


class ComplaintUpdate(BaseUpdateSchema):
    """
    Schema for updating existing complaint.
    
    All fields are optional to support partial updates.
    Includes validation to ensure meaningful updates.
    """

    title: Optional[str] = Field(
        None,
        min_length=5,
        max_length=255,
        description="Updated complaint title",
    )
    description: Optional[str] = Field(
        None,
        min_length=20,
        max_length=2000,
        description="Updated complaint description",
    )
    category: Optional[ComplaintCategory] = Field(
        None,
        description="Updated complaint category",
    )
    sub_category: Optional[str] = Field(
        None,
        max_length=100,
        description="Updated sub-category",
    )
    priority: Optional[Priority] = Field(
        None,
        description="Updated priority level",
    )
    location_details: Optional[str] = Field(
        None,
        max_length=500,
        description="Updated location details",
    )
    attachments: Optional[List[HttpUrl]] = Field(
        None,
        max_length=10,
        description="Updated attachments list",
    )
    status: Optional[ComplaintStatus] = Field(
        None,
        description="Updated complaint status",
    )

    @field_validator("title")
    @classmethod
    def validate_title(cls, v: Optional[str]) -> Optional[str]:
        """Validate title if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                raise ValueError("Title cannot be empty or whitespace only")
            if v.isdigit():
                raise ValueError("Title cannot consist of only numbers")
        return v

    @field_validator("description")
    @classmethod
    def validate_description(cls, v: Optional[str]) -> Optional[str]:
        """Validate description if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                raise ValueError("Description cannot be empty or whitespace only")
            
            word_count = len(v.split())
            if word_count < 5:
                raise ValueError(
                    "Description must contain at least 5 words for clarity"
                )
        return v

    @field_validator("attachments")
    @classmethod
    def validate_attachments_limit(cls, v: Optional[List[HttpUrl]]) -> Optional[List[HttpUrl]]:
        """Ensure attachment count doesn't exceed limit."""
        if v is not None and len(v) > 10:
            raise ValueError("Maximum 10 attachments allowed per complaint")
        return v

    @model_validator(mode="after")
    def validate_has_updates(self) -> "ComplaintUpdate":
        """
        Ensure at least one field is being updated.
        
        Prevents empty update requests.
        """
        update_fields = {
            k: v for k, v in self.model_dump(exclude_unset=True).items()
            if v is not None
        }
        
        if not update_fields:
            raise ValueError("At least one field must be provided for update")
        
        return self


class ComplaintStatusUpdate(BaseUpdateSchema):
    """
    Dedicated schema for complaint status updates.
    
    Provides focused status change functionality with
    mandatory change notes for audit trail.
    """

    status: ComplaintStatus = Field(
        ...,
        description="New complaint status",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason or notes for status change",
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize status change notes."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @model_validator(mode="after")
    def validate_status_change_requirements(self) -> "ComplaintStatusUpdate":
        """
        Enforce business rules for status changes.
        
        Certain status transitions require mandatory notes.
        """
        # Statuses that require explanatory notes
        statuses_requiring_notes = {
            ComplaintStatus.REJECTED,
            ComplaintStatus.ON_HOLD,
            ComplaintStatus.CLOSED,
            ComplaintStatus.REOPENED,
        }
        
        if self.status in statuses_requiring_notes and not self.notes:
            raise ValueError(
                f"Status change to '{self.status.value}' requires explanatory notes"
            )
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_comments.py ---
"""
Complaint discussion and comments schemas.

Handles internal notes and public comments on complaints
with support for attachments and mentions.
"""

from __future__ import annotations

from datetime import datetime
from typing import List, Optional

from pydantic import Field, HttpUrl, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "CommentCreate",
    "CommentResponse",
    "CommentList",
    "CommentUpdate",
    "CommentDelete",
    "MentionNotification",
]


class CommentCreate(BaseCreateSchema):
    """
    Create comment on complaint.
    
    Supports both public comments and internal notes
    with optional attachments.
    """

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to comment on",
    )

    comment_text: str = Field(
        ...,
        min_length=5,
        max_length=1000,
        description="Comment text content",
    )

    is_internal: bool = Field(
        default=False,
        description="Internal note (staff only) vs public comment",
    )

    attachments: List[HttpUrl] = Field(
        default_factory=list,
        max_length=5,
        description="Comment attachments (max 5)",
    )

    @field_validator("comment_text")
    @classmethod
    def validate_comment_text(cls, v: str) -> str:
        """Validate comment text quality."""
        v = v.strip()
        if not v:
            raise ValueError("Comment text cannot be empty")
        
        # Ensure meaningful content
        if len(v) < 5:
            raise ValueError("Comment must be at least 5 characters")
        
        return v

    @field_validator("attachments")
    @classmethod
    def validate_attachments_limit(cls, v: List[HttpUrl]) -> List[HttpUrl]:
        """Ensure attachment count doesn't exceed limit."""
        if len(v) > 5:
            raise ValueError("Maximum 5 attachments allowed per comment")
        return v


class CommentResponse(BaseResponseSchema):
    """
    Comment response with author information.
    
    Includes metadata about comment author and timing.
    """

    complaint_id: str = Field(..., description="Associated complaint ID")

    commented_by: str = Field(..., description="Commenter user ID")
    commented_by_name: str = Field(..., description="Commenter name")
    commented_by_role: str = Field(..., description="Commenter role")

    comment_text: str = Field(..., description="Comment content")
    is_internal: bool = Field(..., description="Internal note flag")

    attachments: List[str] = Field(
        default_factory=list,
        description="Attachment URLs",
    )

    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")

    is_edited: bool = Field(
        default=False,
        description="Whether comment was edited",
    )


class CommentList(BaseSchema):
    """
    List of comments for a complaint.
    
    Provides summary statistics and comment thread.
    """

    complaint_id: str = Field(..., description="Complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    total_comments: int = Field(ge=0, description="Total comment count")
    public_comments: int = Field(ge=0, description="Public comment count")
    internal_notes: int = Field(ge=0, description="Internal note count")

    comments: List[CommentResponse] = Field(
        default_factory=list,
        description="List of comments (sorted by creation time)",
    )


class CommentUpdate(BaseCreateSchema):
    """
    Update existing comment.
    
    Allows modification of comment text only.
    """

    comment_id: str = Field(
        ...,
        description="Comment identifier to update",
    )
    comment_text: str = Field(
        ...,
        min_length=5,
        max_length=1000,
        description="Updated comment text",
    )

    @field_validator("comment_text")
    @classmethod
    def validate_comment_text(cls, v: str) -> str:
        """Validate comment text quality."""
        v = v.strip()
        if not v:
            raise ValueError("Comment text cannot be empty")
        
        if len(v) < 5:
            raise ValueError("Comment must be at least 5 characters")
        
        return v


class CommentDelete(BaseCreateSchema):
    """
    Delete comment request.
    
    Optional reason for deletion audit trail.
    """

    comment_id: str = Field(
        ...,
        description="Comment identifier to delete",
    )
    reason: Optional[str] = Field(
        None,
        max_length=200,
        description="Deletion reason (optional)",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: Optional[str]) -> Optional[str]:
        """Normalize deletion reason if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v


class MentionNotification(BaseSchema):
    """
    Notification when user is mentioned in comment.
    
    Supports @mention functionality in comments.
    """

    comment_id: str = Field(..., description="Comment ID with mention")
    complaint_id: str = Field(..., description="Associated complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    mentioned_by: str = Field(..., description="User who mentioned")
    mentioned_by_name: str = Field(..., description="Mentioner name")

    comment_excerpt: str = Field(
        ...,
        max_length=200,
        description="Comment excerpt (first 200 chars)",
    )

    comment_url: str = Field(
        ...,
        description="Direct URL to comment",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_escalation.py ---
"""
Complaint escalation schemas with comprehensive tracking.

Handles complaint escalation workflow, auto-escalation rules,
and escalation history management.
"""

from __future__ import annotations

from datetime import datetime
from typing import List, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "EscalationRequest",
    "EscalationResponse",
    "EscalationHistory",
    "EscalationEntry",
    "AutoEscalationRule",
]


class EscalationRequest(BaseCreateSchema):
    """
    Request to escalate complaint to higher authority.
    
    Requires detailed reason and supports priority increase
    and urgency flags.
    """

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to escalate",
    )
    escalate_to: str = Field(
        ...,
        description="User ID to escalate to (admin/supervisor)",
    )

    escalation_reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Detailed escalation reason",
    )

    increase_priority: bool = Field(
        default=True,
        description="Automatically increase priority level",
    )

    is_urgent: bool = Field(
        default=False,
        description="Mark as urgent escalation",
    )

    @field_validator("escalation_reason")
    @classmethod
    def validate_escalation_reason(cls, v: str) -> str:
        """Validate escalation reason quality."""
        v = v.strip()
        if not v:
            raise ValueError("Escalation reason cannot be empty")
        
        word_count = len(v.split())
        if word_count < 5:
            raise ValueError(
                "Escalation reason must contain at least 5 words "
                "for proper documentation"
            )
        
        return v


class EscalationResponse(BaseSchema):
    """
    Response after successful escalation.
    
    Provides confirmation and updated complaint details.
    """

    complaint_id: str = Field(..., description="Escalated complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    escalated: bool = Field(..., description="Escalation confirmation flag")
    escalated_to: str = Field(..., description="Escalated to user ID")
    escalated_to_name: str = Field(..., description="Escalated to name")
    escalated_by: str = Field(..., description="Escalator user ID")
    escalated_by_name: str = Field(..., description="Escalator name")
    escalated_at: datetime = Field(..., description="Escalation timestamp")

    new_priority: str = Field(
        ...,
        description="Updated priority level after escalation",
    )

    message: str = Field(
        ...,
        description="Confirmation message",
        examples=["Complaint escalated successfully"],
    )


class EscalationHistory(BaseSchema):
    """
    Complete escalation history for a complaint.
    
    Provides audit trail of all escalations.
    """

    complaint_id: str = Field(..., description="Complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    escalations: List["EscalationEntry"] = Field(
        default_factory=list,
        description="List of escalation entries",
    )
    total_escalations: int = Field(
        ge=0,
        description="Total escalation count",
    )


class EscalationEntry(BaseResponseSchema):
    """
    Individual escalation entry in history.
    
    Tracks single escalation event with complete metadata.
    """

    escalated_to: str = Field(..., description="Escalated to user ID")
    escalated_to_name: str = Field(..., description="Escalated to name")
    escalated_by: str = Field(..., description="Escalator user ID")
    escalated_by_name: str = Field(..., description="Escalator name")
    escalated_at: datetime = Field(..., description="Escalation timestamp")

    reason: str = Field(..., description="Escalation reason")

    # State before/after
    status_before: str = Field(..., description="Status before escalation")
    priority_before: str = Field(..., description="Priority before escalation")
    priority_after: str = Field(..., description="Priority after escalation")

    # Response tracking
    response_time_hours: Optional[int] = Field(
        None,
        ge=0,
        description="Time taken to respond (hours)",
    )
    resolved_after_escalation: bool = Field(
        ...,
        description="Whether resolved after this escalation",
    )


class AutoEscalationRule(BaseSchema):
    """
    Auto-escalation rule configuration.
    
    Defines automatic escalation triggers based on time
    and SLA conditions.
    """

    hostel_id: str = Field(
        ...,
        description="Hostel identifier for rule scope",
    )

    # Trigger conditions
    escalate_after_hours: int = Field(
        default=24,
        ge=1,
        le=168,  # Max 1 week
        description="Hours before auto-escalation (default 24)",
    )
    escalate_on_sla_breach: bool = Field(
        default=True,
        description="Auto-escalate on SLA breach",
    )

    # Priority-specific rules
    urgent_escalation_hours: int = Field(
        default=4,
        ge=1,
        le=24,
        description="Escalation threshold for urgent complaints (hours)",
    )
    high_escalation_hours: int = Field(
        default=12,
        ge=1,
        le=48,
        description="Escalation threshold for high priority (hours)",
    )
    medium_escalation_hours: int = Field(
        default=24,
        ge=1,
        le=72,
        description="Escalation threshold for medium priority (hours)",
    )

    # Escalation chain
    first_escalation_to: str = Field(
        ...,
        description="First level escalation target user ID",
    )
    second_escalation_to: Optional[str] = Field(
        None,
        description="Second level escalation target (if first unresolved)",
    )

    is_active: bool = Field(
        default=True,
        description="Rule active status",
    )

    @model_validator(mode="after")
    def validate_escalation_thresholds(self) -> "AutoEscalationRule":
        """
        Validate escalation time thresholds are logical.
        
        Ensures urgent < high < medium.
        """
        if not (
            self.urgent_escalation_hours
            < self.high_escalation_hours
            < self.medium_escalation_hours
        ):
            raise ValueError(
                "Escalation thresholds must follow: "
                "urgent < high < medium"
            )
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_feedback.py ---
"""
Complaint feedback and satisfaction schemas.

Handles student feedback collection, ratings, and
feedback analytics for service improvement.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "FeedbackRequest",
    "FeedbackResponse",
    "FeedbackSummary",
    "FeedbackAnalysis",
    "RatingTrendPoint",
]


class FeedbackRequest(BaseCreateSchema):
    """
    Submit feedback on resolved complaint.
    
    Collects rating, detailed feedback, and satisfaction metrics.
    """

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to provide feedback for",
    )

    rating: int = Field(
        ...,
        ge=1,
        le=5,
        description="Overall rating (1-5 stars)",
    )

    feedback: Optional[str] = Field(
        None,
        max_length=1000,
        description="Detailed feedback comments",
    )

    # Satisfaction questions
    issue_resolved_satisfactorily: bool = Field(
        ...,
        description="Was the issue resolved to your satisfaction?",
    )
    response_time_satisfactory: bool = Field(
        ...,
        description="Was the response time acceptable?",
    )
    staff_helpful: bool = Field(
        ...,
        description="Was the staff helpful and professional?",
    )

    would_recommend: Optional[bool] = Field(
        None,
        description="Would you recommend this complaint system?",
    )

    @field_validator("feedback")
    @classmethod
    def validate_feedback(cls, v: Optional[str]) -> Optional[str]:
        """Normalize feedback text if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @field_validator("rating")
    @classmethod
    def validate_rating_for_poor_scores(cls, v: int, info) -> int:
        """
        Encourage feedback text for low ratings.
        
        Note: This is advisory validation, not enforced.
        """
        # Could log warning if rating <= 2 and no feedback
        # but not enforcing to avoid friction
        return v


class FeedbackResponse(BaseResponseSchema):
    """
    Feedback submission response.
    
    Confirms feedback receipt and provides summary.
    """

    complaint_id: str = Field(..., description="Complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    rating: int = Field(..., description="Submitted rating")
    feedback: Optional[str] = Field(None, description="Submitted feedback")

    submitted_by: str = Field(..., description="Feedback submitter user ID")
    submitted_at: datetime = Field(..., description="Submission timestamp")

    message: str = Field(
        ...,
        description="Confirmation message",
        examples=["Thank you for your feedback!"],
    )


class FeedbackSummary(BaseSchema):
    """
    Feedback summary for hostel or supervisor.
    
    Provides aggregate feedback metrics and insights.
    """

    entity_id: str = Field(
        ...,
        description="Entity identifier (hostel or supervisor)",
    )
    entity_type: str = Field(
        ...,
        pattern=r"^(hostel|supervisor)$",
        description="Entity type: hostel or supervisor",
    )

    # Time period
    period_start: date = Field(..., description="Summary period start date")
    period_end: date = Field(..., description="Summary period end date")

    # Overall statistics
    total_feedbacks: int = Field(ge=0, description="Total feedback count")
    average_rating: Decimal = Field(
        ge=0,
        le=5,
        description="Average rating (0-5)",
    )

    # Rating distribution
    rating_5_count: int = Field(ge=0, description="5-star rating count")
    rating_4_count: int = Field(ge=0, description="4-star rating count")
    rating_3_count: int = Field(ge=0, description="3-star rating count")
    rating_2_count: int = Field(ge=0, description="2-star rating count")
    rating_1_count: int = Field(ge=0, description="1-star rating count")

    # Satisfaction metrics (percentages)
    resolution_satisfaction_rate: Decimal = Field(
        ge=0,
        le=100,
        description="% satisfied with issue resolution",
    )
    response_time_satisfaction_rate: Decimal = Field(
        ge=0,
        le=100,
        description="% satisfied with response time",
    )
    staff_helpfulness_rate: Decimal = Field(
        ge=0,
        le=100,
        description="% who found staff helpful",
    )

    # Recommendation
    recommendation_rate: Decimal = Field(
        ge=0,
        le=100,
        description="% who would recommend the system",
    )

    # Sentiment analysis
    positive_feedback_count: int = Field(
        ge=0,
        description="Positive feedback count",
    )
    negative_feedback_count: int = Field(
        ge=0,
        description="Negative feedback count",
    )
    common_themes: List[str] = Field(
        default_factory=list,
        description="Common themes from feedback analysis",
    )


class FeedbackAnalysis(BaseSchema):
    """
    Detailed feedback analysis with trends.
    
    Provides deep insights into feedback patterns.
    """

    hostel_id: str = Field(..., description="Hostel identifier")
    period_start: date = Field(..., description="Analysis period start")
    period_end: date = Field(..., description="Analysis period end")

    # Trend data
    rating_trend: List["RatingTrendPoint"] = Field(
        default_factory=list,
        description="Rating trend over time",
    )

    # Category analysis
    feedback_by_category: dict[str, Decimal] = Field(
        default_factory=dict,
        description="Average rating by complaint category",
    )

    # Priority analysis
    feedback_by_priority: dict[str, Decimal] = Field(
        default_factory=dict,
        description="Average rating by priority level",
    )

    # Response time impact
    avg_rating_quick_response: Decimal = Field(
        ge=0,
        le=5,
        description="Average rating for quick responses",
    )
    avg_rating_slow_response: Decimal = Field(
        ge=0,
        le=5,
        description="Average rating for slow responses",
    )


class RatingTrendPoint(BaseSchema):
    """
    Data point for rating trend analysis.
    
    Represents rating metrics for a specific time period.
    """

    period: str = Field(
        ...,
        description="Time period (date, week, or month)",
        examples=["2024-01", "Week 1", "2024-01-15"],
    )
    average_rating: Decimal = Field(
        ge=0,
        le=5,
        description="Average rating for period",
    )
    feedback_count: int = Field(
        ge=0,
        description="Number of feedbacks in period",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_filters.py ---
"""
Complaint filtering and search schemas.

Provides comprehensive filtering, searching, and sorting
capabilities for complaint queries.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import List, Optional

from pydantic import Field, field_validator

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import ComplaintCategory, ComplaintStatus, Priority

__all__ = [
    "ComplaintFilterParams",
    "ComplaintSearchRequest",
    "ComplaintSortOptions",
    "ComplaintExportRequest",
]


class ComplaintFilterParams(BaseFilterSchema):
    """
    Comprehensive complaint filter parameters.
    
    Supports filtering by multiple dimensions for flexible queries.
    """

    # Text search
    search: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Search in title, description, complaint number",
    )

    # Hostel filters
    hostel_id: Optional[str] = Field(
        None,
        description="Filter by single hostel",
    )
    hostel_ids: Optional[List[str]] = Field(
        None,
        max_length=50,
        description="Filter by multiple hostels (max 50)",
    )

    # User filters
    raised_by: Optional[str] = Field(
        None,
        description="Filter by complainant user ID",
    )
    student_id: Optional[str] = Field(
        None,
        description="Filter by student ID",
    )

    # Assignment filters
    assigned_to: Optional[str] = Field(
        None,
        description="Filter by assigned staff member",
    )
    unassigned_only: Optional[bool] = Field(
        None,
        description="Show only unassigned complaints",
    )

    # Category filters
    category: Optional[ComplaintCategory] = Field(
        None,
        description="Filter by single category",
    )
    categories: Optional[List[ComplaintCategory]] = Field(
        None,
        max_length=20,
        description="Filter by multiple categories",
    )

    # Priority filters
    priority: Optional[Priority] = Field(
        None,
        description="Filter by single priority",
    )
    priorities: Optional[List[Priority]] = Field(
        None,
        max_length=10,
        description="Filter by multiple priorities",
    )

    # Status filters
    status: Optional[ComplaintStatus] = Field(
        None,
        description="Filter by single status",
    )
    statuses: Optional[List[ComplaintStatus]] = Field(
        None,
        max_length=10,
        description="Filter by multiple statuses",
    )

    # Date range filters
    opened_date_from: Optional[date] = Field(
        None,
        description="Opened date range start (inclusive)",
    )
    opened_date_to: Optional[date] = Field(
        None,
        description="Opened date range end (inclusive)",
    )
    resolved_date_from: Optional[date] = Field(
        None,
        description="Resolved date range start",
    )
    resolved_date_to: Optional[date] = Field(
        None,
        description="Resolved date range end",
    )

    # Special filters
    sla_breached_only: Optional[bool] = Field(
        None,
        description="Show only SLA breached complaints",
    )
    escalated_only: Optional[bool] = Field(
        None,
        description="Show only escalated complaints",
    )

    # Location filters
    room_id: Optional[str] = Field(
        None,
        description="Filter by specific room",
    )

    # Age filters
    age_hours_min: Optional[int] = Field(
        None,
        ge=0,
        description="Minimum complaint age in hours",
    )
    age_hours_max: Optional[int] = Field(
        None,
        ge=0,
        description="Maximum complaint age in hours",
    )

    @field_validator("search")
    @classmethod
    def validate_search(cls, v: Optional[str]) -> Optional[str]:
        """Normalize search query."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @field_validator("hostel_ids", "categories", "priorities", "statuses")
    @classmethod
    def validate_list_length(cls, v: Optional[List]) -> Optional[List]:
        """Ensure filter lists don't exceed reasonable limits."""
        if v is not None and len(v) > 50:
            raise ValueError("Too many items in filter list (max 50)")
        return v

    @field_validator("opened_date_to")
    @classmethod
    def validate_opened_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate opened date range is logical."""
        opened_date_from = info.data.get("opened_date_from")
        if v is not None and opened_date_from is not None:
            if v < opened_date_from:
                raise ValueError(
                    "opened_date_to must be >= opened_date_from"
                )
        return v

    @field_validator("resolved_date_to")
    @classmethod
    def validate_resolved_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate resolved date range is logical."""
        resolved_date_from = info.data.get("resolved_date_from")
        if v is not None and resolved_date_from is not None:
            if v < resolved_date_from:
                raise ValueError(
                    "resolved_date_to must be >= resolved_date_from"
                )
        return v

    @field_validator("age_hours_max")
    @classmethod
    def validate_age_range(cls, v: Optional[int], info) -> Optional[int]:
        """Validate age range is logical."""
        age_hours_min = info.data.get("age_hours_min")
        if v is not None and age_hours_min is not None:
            if v < age_hours_min:
                raise ValueError(
                    "age_hours_max must be >= age_hours_min"
                )
        return v


class ComplaintSearchRequest(BaseFilterSchema):
    """
    Full-text search request for complaints.
    
    Supports configurable search fields and filters.
    """

    query: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Search query string",
    )
    hostel_id: Optional[str] = Field(
        None,
        description="Limit search to specific hostel",
    )

    # Search scope configuration
    search_in_title: bool = Field(
        default=True,
        description="Include title in search",
    )
    search_in_description: bool = Field(
        default=True,
        description="Include description in search",
    )
    search_in_number: bool = Field(
        default=True,
        description="Include complaint number in search",
    )

    # Optional filters
    status: Optional[ComplaintStatus] = Field(
        None,
        description="Filter by status",
    )
    priority: Optional[Priority] = Field(
        None,
        description="Filter by priority",
    )

    # Pagination
    page: int = Field(
        default=1,
        ge=1,
        description="Page number",
    )
    page_size: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Results per page (1-100)",
    )

    @field_validator("query")
    @classmethod
    def validate_query(cls, v: str) -> str:
        """Normalize search query."""
        v = v.strip()
        if not v:
            raise ValueError("Search query cannot be empty")
        return v


class ComplaintSortOptions(BaseFilterSchema):
    """
    Sorting options for complaint queries.
    
    Defines available sort fields and order.
    """

    sort_by: str = Field(
        default="opened_at",
        pattern=r"^(opened_at|priority|status|category|age|updated_at|resolved_at)$",
        description="Field to sort by",
    )
    sort_order: str = Field(
        default="desc",
        pattern=r"^(asc|desc)$",
        description="Sort order: ascending or descending",
    )

    @field_validator("sort_by", "sort_order")
    @classmethod
    def normalize_sort_params(cls, v: str) -> str:
        """Normalize sort parameters to lowercase."""
        return v.lower().strip()


class ComplaintExportRequest(BaseFilterSchema):
    """
    Export complaints to various formats.
    
    Supports CSV, Excel, and PDF exports with configurable fields.
    """

    hostel_id: Optional[str] = Field(
        None,
        description="Limit export to specific hostel",
    )
    filters: Optional[ComplaintFilterParams] = Field(
        None,
        description="Apply filters to export",
    )

    format: str = Field(
        default="csv",
        pattern=r"^(csv|excel|pdf)$",
        description="Export format: csv, excel, or pdf",
    )

    # Export options
    include_comments: bool = Field(
        default=False,
        description="Include comments in export",
    )
    include_resolution_details: bool = Field(
        default=True,
        description="Include resolution details",
    )
    include_feedback: bool = Field(
        default=True,
        description="Include student feedback",
    )

    @field_validator("format")
    @classmethod
    def normalize_format(cls, v: str) -> str:
        """Normalize export format to lowercase."""
        return v.lower().strip()

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_resolution.py ---
"""
Complaint resolution and closure schemas.

Handles complaint resolution workflow including marking as resolved,
reopening, and final closure with comprehensive validation.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "ResolutionRequest",
    "ResolutionResponse",
    "ResolutionUpdate",
    "ReopenRequest",
    "CloseRequest",
]


class ResolutionRequest(BaseCreateSchema):
    """
    Request to mark complaint as resolved.
    
    Requires detailed resolution notes and supports
    optional proof attachments and follow-up scheduling.
    """

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to resolve",
    )

    resolution_notes: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed resolution description",
    )

    resolution_attachments: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="Proof of resolution (photos/documents)",
    )

    actual_resolution_time: Optional[datetime] = Field(
        None,
        description="Actual time resolution was completed",
    )

    # Follow-up tracking
    follow_up_required: bool = Field(
        default=False,
        description="Whether follow-up check is needed",
    )
    follow_up_date: Optional[date] = Field(
        None,
        description="Scheduled follow-up date",
    )
    follow_up_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Follow-up instructions",
    )

    @field_validator("resolution_notes")
    @classmethod
    def validate_resolution_notes(cls, v: str) -> str:
        """Validate resolution notes quality."""
        v = v.strip()
        if not v:
            raise ValueError("Resolution notes cannot be empty")
        
        word_count = len(v.split())
        if word_count < 10:
            raise ValueError(
                "Resolution notes must contain at least 10 words "
                "for proper documentation"
            )
        
        return v

    @field_validator("resolution_attachments")
    @classmethod
    def validate_attachments_limit(cls, v: List[HttpUrl]) -> List[HttpUrl]:
        """Ensure attachment count doesn't exceed limit."""
        if len(v) > 10:
            raise ValueError(
                "Maximum 10 resolution attachments allowed"
            )
        return v

    @field_validator("follow_up_date")
    @classmethod
    def validate_follow_up_date(cls, v: Optional[date]) -> Optional[date]:
        """Ensure follow-up date is in the future."""
        if v is not None and v <= date.today():
            raise ValueError(
                "Follow-up date must be in the future"
            )
        return v

    @model_validator(mode="after")
    def validate_follow_up_consistency(self) -> "ResolutionRequest":
        """
        Validate follow-up fields are consistent.
        
        If follow_up_required is True, follow_up_date must be provided.
        """
        if self.follow_up_required and not self.follow_up_date:
            raise ValueError(
                "Follow-up date is required when follow-up is marked as needed"
            )
        
        return self


class ResolutionResponse(BaseSchema):
    """
    Response after successful complaint resolution.
    
    Provides confirmation and resolution metrics.
    """

    complaint_id: str = Field(..., description="Resolved complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")

    resolved: bool = Field(..., description="Resolution confirmation flag")
    resolved_at: datetime = Field(..., description="Resolution timestamp")
    resolved_by: str = Field(..., description="Resolver user ID")
    resolved_by_name: str = Field(..., description="Resolver name")

    resolution_notes: str = Field(..., description="Resolution description")

    # Performance metrics
    time_to_resolve_hours: int = Field(
        ge=0,
        description="Total resolution time in hours",
    )
    sla_met: bool = Field(
        ...,
        description="Whether SLA was met for this resolution",
    )

    message: str = Field(
        ...,
        description="Confirmation message",
        examples=["Complaint resolved successfully"],
    )


class ResolutionUpdate(BaseCreateSchema):
    """
    Update resolution details for already resolved complaint.
    
    Allows modification of resolution notes and attachments.
    """

    complaint_id: str = Field(
        ...,
        description="Complaint identifier",
    )

    resolution_notes: Optional[str] = Field(
        None,
        min_length=20,
        max_length=2000,
        description="Updated resolution notes",
    )
    resolution_attachments: Optional[List[HttpUrl]] = Field(
        None,
        max_length=10,
        description="Updated resolution attachments",
    )
    follow_up_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Updated follow-up notes",
    )

    @field_validator("resolution_notes")
    @classmethod
    def validate_resolution_notes(cls, v: Optional[str]) -> Optional[str]:
        """Validate resolution notes if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                raise ValueError("Resolution notes cannot be empty")
            
            word_count = len(v.split())
            if word_count < 10:
                raise ValueError(
                    "Resolution notes must contain at least 10 words"
                )
        
        return v

    @field_validator("resolution_attachments")
    @classmethod
    def validate_attachments_limit(
        cls,
        v: Optional[List[HttpUrl]]
    ) -> Optional[List[HttpUrl]]:
        """Ensure attachment count doesn't exceed limit."""
        if v is not None and len(v) > 10:
            raise ValueError(
                "Maximum 10 resolution attachments allowed"
            )
        return v

    @model_validator(mode="after")
    def validate_has_updates(self) -> "ResolutionUpdate":
        """Ensure at least one field is being updated."""
        update_fields = {
            k: v for k, v in self.model_dump(exclude_unset=True).items()
            if v is not None and k != "complaint_id"
        }
        
        if not update_fields:
            raise ValueError(
                "At least one field must be provided for update"
            )
        
        return self


class ReopenRequest(BaseCreateSchema):
    """
    Request to reopen a resolved/closed complaint.
    
    Requires detailed reason and supports additional information.
    """

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to reopen",
    )

    reopen_reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Detailed reason for reopening",
    )

    additional_issues: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional issues discovered",
    )
    new_attachments: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="New supporting attachments",
    )

    @field_validator("reopen_reason")
    @classmethod
    def validate_reopen_reason(cls, v: str) -> str:
        """Validate reopen reason quality."""
        v = v.strip()
        if not v:
            raise ValueError("Reopen reason cannot be empty")
        
        word_count = len(v.split())
        if word_count < 5:
            raise ValueError(
                "Reopen reason must contain at least 5 words "
                "for proper documentation"
            )
        
        return v

    @field_validator("additional_issues")
    @classmethod
    def validate_additional_issues(cls, v: Optional[str]) -> Optional[str]:
        """Normalize additional issues if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @field_validator("new_attachments")
    @classmethod
    def validate_attachments_limit(cls, v: List[HttpUrl]) -> List[HttpUrl]:
        """Ensure attachment count doesn't exceed limit."""
        if len(v) > 10:
            raise ValueError(
                "Maximum 10 new attachments allowed"
            )
        return v


class CloseRequest(BaseCreateSchema):
    """
    Request to close complaint (final state).
    
    Optional closure notes and student confirmation.
    """

    complaint_id: str = Field(
        ...,
        description="Complaint identifier to close",
    )

    closure_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Final closure notes",
    )

    student_confirmed: bool = Field(
        default=False,
        description="Student confirmed resolution satisfaction",
    )

    @field_validator("closure_notes")
    @classmethod
    def validate_closure_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize closure notes if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\complaint_response.py ---
"""
Complaint response schemas for API outputs.

Provides comprehensive response models for different complaint views:
- Summary responses for list views
- Detailed responses for single complaint views
- Dashboard summary statistics
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import ComplaintCategory, ComplaintStatus, Priority

__all__ = [
    "ComplaintResponse",
    "ComplaintDetail",
    "ComplaintListItem",
    "ComplaintSummary",
    "ComplaintStats",
]


class ComplaintResponse(BaseResponseSchema):
    """
    Standard complaint response with essential fields.
    
    Used for list views and general complaint information.
    """

    complaint_number: str = Field(
        ...,
        description="Unique complaint reference number",
    )
    hostel_id: str = Field(
        ...,
        description="Associated hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Associated hostel name for display",
    )

    # Complainant information
    raised_by: str = Field(
        ...,
        description="User ID who raised the complaint",
    )
    raised_by_name: str = Field(
        ...,
        description="Display name of complainant",
    )
    student_id: Optional[str] = Field(
        None,
        description="Student ID if applicable",
    )

    # Core complaint fields
    title: str = Field(
        ...,
        description="Complaint title",
    )
    category: ComplaintCategory = Field(
        ...,
        description="Complaint category",
    )
    priority: Priority = Field(
        ...,
        description="Priority level",
    )
    status: ComplaintStatus = Field(
        ...,
        description="Current status",
    )

    # Assignment
    assigned_to: Optional[str] = Field(
        None,
        description="Assigned staff member ID",
    )
    assigned_to_name: Optional[str] = Field(
        None,
        description="Assigned staff member name",
    )

    # Timestamps
    opened_at: datetime = Field(
        ...,
        description="Complaint creation timestamp",
    )
    resolved_at: Optional[datetime] = Field(
        None,
        description="Resolution timestamp",
    )

    # Metrics
    sla_breach: bool = Field(
        ...,
        description="Whether complaint has breached SLA",
    )
    age_hours: int = Field(
        ...,
        ge=0,
        description="Age of complaint in hours",
    )

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Determine if complaint is overdue based on priority and age."""
        # Define SLA thresholds in hours by priority
        sla_thresholds = {
            Priority.CRITICAL: 2,
            Priority.URGENT: 4,
            Priority.HIGH: 12,
            Priority.MEDIUM: 24,
            Priority.LOW: 48,
        }
        
        threshold = sla_thresholds.get(self.priority, 24)
        return self.age_hours > threshold and self.status not in [
            ComplaintStatus.RESOLVED,
            ComplaintStatus.CLOSED,
        ]


class ComplaintDetail(BaseResponseSchema):
    """
    Comprehensive complaint details with full information.
    
    Used for single complaint view with complete audit trail
    and relationship information.
    """

    complaint_number: str = Field(
        ...,
        description="Unique complaint reference number",
    )

    # Hostel information
    hostel_id: str = Field(..., description="Hostel identifier")
    hostel_name: str = Field(..., description="Hostel name")

    # Complainant information (detailed)
    raised_by: str = Field(..., description="User ID of complainant")
    raised_by_name: str = Field(..., description="Complainant name")
    raised_by_email: str = Field(..., description="Complainant email")
    raised_by_phone: str = Field(..., description="Complainant phone")

    student_id: Optional[str] = Field(None, description="Student ID")
    student_name: Optional[str] = Field(None, description="Student name")
    room_number: Optional[str] = Field(None, description="Room number")

    # Complaint content
    title: str = Field(..., description="Complaint title")
    description: str = Field(..., description="Detailed description")
    category: ComplaintCategory = Field(..., description="Category")
    sub_category: Optional[str] = Field(None, description="Sub-category")
    priority: Priority = Field(..., description="Priority level")

    # Location
    room_id: Optional[str] = Field(None, description="Room ID")
    location_details: Optional[str] = Field(None, description="Location details")

    # Media
    attachments: List[str] = Field(
        default_factory=list,
        description="Attachment URLs",
    )

    # Assignment history
    assigned_to: Optional[str] = Field(None, description="Current assignee ID")
    assigned_to_name: Optional[str] = Field(None, description="Current assignee name")
    assigned_by: Optional[str] = Field(None, description="Assigned by user ID")
    assigned_by_name: Optional[str] = Field(None, description="Assigned by name")
    assigned_at: Optional[datetime] = Field(None, description="Assignment timestamp")
    reassigned_count: int = Field(
        default=0,
        ge=0,
        description="Number of times complaint was reassigned",
    )

    # Status workflow
    status: ComplaintStatus = Field(..., description="Current status")
    opened_at: datetime = Field(..., description="Creation timestamp")
    in_progress_at: Optional[datetime] = Field(
        None,
        description="When complaint moved to in-progress",
    )
    resolved_at: Optional[datetime] = Field(
        None,
        description="Resolution timestamp",
    )
    closed_at: Optional[datetime] = Field(None, description="Closure timestamp")
    closed_by: Optional[str] = Field(None, description="User who closed complaint")
    closed_by_name: Optional[str] = Field(None, description="Closer name")

    # Resolution details
    resolution_notes: Optional[str] = Field(
        None,
        description="Resolution description",
    )
    resolution_attachments: List[str] = Field(
        default_factory=list,
        description="Resolution proof URLs",
    )
    estimated_resolution_time: Optional[datetime] = Field(
        None,
        description="Estimated resolution time",
    )
    actual_resolution_time: Optional[datetime] = Field(
        None,
        description="Actual resolution time",
    )

    # Feedback
    student_feedback: Optional[str] = Field(None, description="Student feedback")
    student_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Student rating (1-5)",
    )
    feedback_submitted_at: Optional[datetime] = Field(
        None,
        description="Feedback submission timestamp",
    )

    # SLA tracking
    sla_breach: bool = Field(..., description="SLA breach status")
    sla_breach_reason: Optional[str] = Field(
        None,
        description="Reason for SLA breach",
    )

    # Escalation
    escalated: bool = Field(default=False, description="Escalation status")
    escalated_to: Optional[str] = Field(None, description="Escalated to user ID")
    escalated_to_name: Optional[str] = Field(None, description="Escalated to name")
    escalated_at: Optional[datetime] = Field(None, description="Escalation timestamp")
    escalation_reason: Optional[str] = Field(None, description="Escalation reason")

    # Admin override
    overridden_by_admin: bool = Field(
        default=False,
        description="Admin override flag",
    )
    override_admin_id: Optional[str] = Field(None, description="Override admin ID")
    override_timestamp: Optional[datetime] = Field(
        None,
        description="Override timestamp",
    )
    override_reason: Optional[str] = Field(None, description="Override reason")

    # Engagement metrics
    total_comments: int = Field(
        default=0,
        ge=0,
        description="Total comment count",
    )

    # Time metrics
    age_hours: int = Field(ge=0, description="Complaint age in hours")
    time_to_resolve_hours: Optional[int] = Field(
        None,
        ge=0,
        description="Time taken to resolve (hours)",
    )

    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if complaint is in an active state."""
        active_statuses = {
            ComplaintStatus.OPEN,
            ComplaintStatus.ASSIGNED,
            ComplaintStatus.IN_PROGRESS,
            ComplaintStatus.REOPENED,
        }
        return self.status in active_statuses

    @computed_field
    @property
    def resolution_efficiency(self) -> Optional[str]:
        """
        Calculate resolution efficiency rating.
        
        Returns:
            Efficiency rating: 'excellent', 'good', 'average', 'poor', or None
        """
        if not self.time_to_resolve_hours:
            return None
        
        # Define efficiency thresholds based on priority
        thresholds = {
            Priority.CRITICAL: {"excellent": 1, "good": 2, "average": 4},
            Priority.URGENT: {"excellent": 2, "good": 4, "average": 8},
            Priority.HIGH: {"excellent": 6, "good": 12, "average": 24},
            Priority.MEDIUM: {"excellent": 12, "good": 24, "average": 48},
            Priority.LOW: {"excellent": 24, "good": 48, "average": 72},
        }
        
        threshold = thresholds.get(self.priority, thresholds[Priority.MEDIUM])
        hours = self.time_to_resolve_hours
        
        if hours <= threshold["excellent"]:
            return "excellent"
        elif hours <= threshold["good"]:
            return "good"
        elif hours <= threshold["average"]:
            return "average"
        else:
            return "poor"


class ComplaintListItem(BaseSchema):
    """
    Lightweight complaint item for list views.
    
    Optimized for performance with minimal fields
    for table/grid displays.
    """

    id: str = Field(..., description="Complaint ID")
    complaint_number: str = Field(..., description="Reference number")
    title: str = Field(..., description="Complaint title")

    category: str = Field(..., description="Category name")
    priority: str = Field(..., description="Priority level")
    status: ComplaintStatus = Field(..., description="Current status")

    raised_by_name: str = Field(..., description="Complainant name")
    room_number: Optional[str] = Field(None, description="Room number")

    assigned_to_name: Optional[str] = Field(None, description="Assignee name")

    opened_at: datetime = Field(..., description="Creation timestamp")
    age_hours: int = Field(ge=0, description="Age in hours")

    sla_breach: bool = Field(..., description="SLA breach status")

    @computed_field
    @property
    def status_color(self) -> str:
        """
        Get status color code for UI display.
        
        Returns:
            Color code string for status badge
        """
        color_map = {
            ComplaintStatus.OPEN: "red",
            ComplaintStatus.ASSIGNED: "orange",
            ComplaintStatus.IN_PROGRESS: "blue",
            ComplaintStatus.ON_HOLD: "yellow",
            ComplaintStatus.RESOLVED: "green",
            ComplaintStatus.CLOSED: "gray",
            ComplaintStatus.REOPENED: "purple",
        }
        return color_map.get(self.status, "gray")

    @computed_field
    @property
    def priority_weight(self) -> int:
        """
        Get numeric priority weight for sorting.
        
        Returns:
            Integer weight (higher = more urgent)
        """
        weight_map = {
            "critical": 5,
            "urgent": 4,
            "high": 3,
            "medium": 2,
            "low": 1,
        }
        return weight_map.get(self.priority.lower(), 2)


class ComplaintSummary(BaseSchema):
    """
    Complaint statistics summary for dashboard.
    
    Provides aggregate metrics for a hostel or supervisor.
    """

    hostel_id: str = Field(..., description="Hostel identifier")

    total_complaints: int = Field(ge=0, description="Total complaint count")
    open_complaints: int = Field(ge=0, description="Open complaints")
    in_progress_complaints: int = Field(ge=0, description="In-progress complaints")
    resolved_complaints: int = Field(ge=0, description="Resolved complaints")

    high_priority_count: int = Field(ge=0, description="High priority count")
    urgent_priority_count: int = Field(ge=0, description="Urgent priority count")

    sla_breached_count: int = Field(ge=0, description="SLA breached count")

    average_resolution_time_hours: Decimal = Field(
        ge=0,
        description="Average resolution time in hours",
    )

    @computed_field
    @property
    def resolution_rate(self) -> float:
        """
        Calculate complaint resolution rate percentage.
        
        Returns:
            Resolution rate as percentage (0-100)
        """
        if self.total_complaints == 0:
            return 0.0
        return round(
            (self.resolved_complaints / self.total_complaints) * 100,
            2
        )

    @computed_field
    @property
    def sla_compliance_rate(self) -> float:
        """
        Calculate SLA compliance rate percentage.
        
        Returns:
            SLA compliance rate as percentage (0-100)
        """
        if self.total_complaints == 0:
            return 100.0
        
        compliant = self.total_complaints - self.sla_breached_count
        return round((compliant / self.total_complaints) * 100, 2)


class ComplaintStats(BaseSchema):
    """
    Extended complaint statistics with breakdown details.
    
    Provides comprehensive analytics for reporting.
    """

    total: int = Field(ge=0, description="Total complaints")
    
    # Status breakdown
    by_status: dict[str, int] = Field(
        default_factory=dict,
        description="Complaint count by status",
    )
    
    # Priority breakdown
    by_priority: dict[str, int] = Field(
        default_factory=dict,
        description="Complaint count by priority",
    )
    
    # Category breakdown
    by_category: dict[str, int] = Field(
        default_factory=dict,
        description="Complaint count by category",
    )
    
    # Time-based metrics
    avg_resolution_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average resolution time",
    )
    median_resolution_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Median resolution time",
    )
    
    # Performance indicators
    sla_compliance_percentage: Decimal = Field(
        ge=0,
        le=100,
        description="SLA compliance percentage",
    )
    resolution_percentage: Decimal = Field(
        ge=0,
        le=100,
        description="Resolution percentage",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\complaint\__init__.py ---
"""
Complaint schemas package.

Comprehensive complaint management schemas including creation, updates,
assignments, resolution, escalation, feedback, and analytics.

Example:
    from app.schemas.complaint import ComplaintCreate, ComplaintDetail
"""

from __future__ import annotations

from app.schemas.complaint.complaint_analytics import (
    CategoryAnalysis,
    CategoryMetrics,
    ComplaintAnalytics,
    ComplaintHeatmap,
    ComplaintTrendPoint,
    ResolutionMetrics,
    RoomComplaintCount,
    StaffPerformance,
)
from app.schemas.complaint.complaint_assignment import (
    AssignmentHistory,
    AssignmentRequest,
    AssignmentResponse,
    BulkAssignment,
    ReassignmentRequest,
    UnassignRequest,
)
from app.schemas.complaint.complaint_base import (
    ComplaintBase,
    ComplaintCreate,
    ComplaintStatusUpdate,
    ComplaintUpdate,
)
from app.schemas.complaint.complaint_comments import (
    CommentCreate,
    CommentDelete,
    CommentList,
    CommentResponse,
    CommentUpdate,
    MentionNotification,
)
from app.schemas.complaint.complaint_escalation import (
    AutoEscalationRule,
    EscalationEntry,
    EscalationHistory,
    EscalationRequest,
    EscalationResponse,
)
from app.schemas.complaint.complaint_feedback import (
    FeedbackAnalysis,
    FeedbackRequest,
    FeedbackResponse,
    FeedbackSummary,
    RatingTrendPoint,
)
from app.schemas.complaint.complaint_filters import (
    ComplaintExportRequest,
    ComplaintFilterParams,
    ComplaintSearchRequest,
    ComplaintSortOptions,
)
from app.schemas.complaint.complaint_resolution import (
    CloseRequest,
    ReopenRequest,
    ResolutionRequest,
    ResolutionResponse,
    ResolutionUpdate,
)
from app.schemas.complaint.complaint_response import (
    ComplaintDetail,
    ComplaintListItem,
    ComplaintResponse,
    ComplaintStats,
    ComplaintSummary,
)

__all__ = [
    # Base schemas
    "ComplaintBase",
    "ComplaintCreate",
    "ComplaintUpdate",
    "ComplaintStatusUpdate",
    # Response schemas
    "ComplaintResponse",
    "ComplaintDetail",
    "ComplaintListItem",
    "ComplaintSummary",
    "ComplaintStats",
    # Assignment schemas
    "AssignmentRequest",
    "AssignmentResponse",
    "ReassignmentRequest",
    "BulkAssignment",
    "UnassignRequest",
    "AssignmentHistory",
    # Resolution schemas
    "ResolutionRequest",
    "ResolutionResponse",
    "ResolutionUpdate",
    "ReopenRequest",
    "CloseRequest",
    # Escalation schemas
    "EscalationRequest",
    "EscalationResponse",
    "EscalationHistory",
    "EscalationEntry",
    "AutoEscalationRule",
    # Feedback schemas
    "FeedbackRequest",
    "FeedbackResponse",
    "FeedbackSummary",
    "FeedbackAnalysis",
    "RatingTrendPoint",
    # Comment schemas
    "CommentCreate",
    "CommentResponse",
    "CommentList",
    "CommentUpdate",
    "CommentDelete",
    "MentionNotification",
    # Filter schemas
    "ComplaintFilterParams",
    "ComplaintSearchRequest",
    "ComplaintSortOptions",
    "ComplaintExportRequest",
    # Analytics schemas
    "ComplaintAnalytics",
    "ResolutionMetrics",
    "CategoryAnalysis",
    "CategoryMetrics",
    "ComplaintTrendPoint",
    "StaffPerformance",
    "ComplaintHeatmap",
    "RoomComplaintCount",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\fee_structure =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\fee_structure\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\fee_structure ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\fee_structure =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\fee_structure\fee_base.py ---
"""
Base fee structure schemas
"""
from datetime import date
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseUpdateSchema
from app.schemas.common.enums import RoomType, FeeType, ChargeType


class FeeStructureBase(BaseSchema):
    """Base fee structure per hostel & room type"""
    hostel_id: UUID = Field(..., description="Hostel ID")
    room_type: RoomType = Field(..., description="Room type to which this fee applies")
    fee_type: FeeType = Field(..., description="Billing frequency")

    amount: Decimal = Field(..., ge=0, description="Base rent amount per period")
    security_deposit: Decimal = Field(Decimal("0.00"), ge=0)

    includes_mess: bool = Field(False, description="Whether mess is included")
    mess_charges_monthly: Decimal = Field(Decimal("0.00"), ge=0)

    # Utility charges
    electricity_charges: ChargeType = Field(
        ChargeType.INCLUDED, description="How electricity is billed"
    )
    electricity_fixed_amount: Optional[Decimal] = Field(None, ge=0)

    water_charges: ChargeType = Field(
        ChargeType.INCLUDED, description="How water is billed"
    )
    water_fixed_amount: Optional[Decimal] = Field(None, ge=0)

    effective_from: date = Field(..., description="Fee effective start date")
    effective_to: Optional[date] = Field(None, description="End date (if any)")

    is_active: bool = Field(True)


class FeeStructureCreate(FeeStructureBase, BaseCreateSchema):
    """Create fee structure entry"""
    pass


class FeeStructureUpdate(BaseUpdateSchema):
    """Update fee structure"""
    amount: Optional[Decimal] = Field(None, ge=0)
    security_deposit: Optional[Decimal] = Field(None, ge=0)
    includes_mess: Optional[bool] = None
    mess_charges_monthly: Optional[Decimal] = Field(None, ge=0)
    electricity_charges: Optional[ChargeType] = None
    electricity_fixed_amount: Optional[Decimal] = Field(None, ge=0)
    water_charges: Optional[ChargeType] = None
    water_fixed_amount: Optional[Decimal] = Field(None, ge=0)
    effective_from: Optional[date] = None
    effective_to: Optional[date] = None
    is_active: Optional[bool] = None

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\fee_structure\fee_config.py ---
"""
Fee configuration & breakdown schemas
"""
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import RoomType, FeeType, ChargeType


class ChargesBreakdown(BaseSchema):
    """Breakdown of all components of a fee"""
    base_rent: Decimal
    mess_charges: Decimal
    electricity_charges: Decimal
    water_charges: Decimal
    other_charges: Decimal = Field(Decimal("0.00"))

    total_monthly: Decimal
    total_first_month: Decimal
    security_deposit: Decimal


class FeeConfiguration(BaseSchema):
    """Configuration for calculating total fees for a given booking/student"""
    hostel_id: UUID
    room_type: RoomType
    fee_type: FeeType

    # Components
    base_amount: Decimal
    security_deposit: Decimal
    includes_mess: bool
    mess_charges_monthly: Decimal

    electricity_charges: ChargeType
    electricity_fixed_amount: Optional[Decimal]
    water_charges: ChargeType
    water_fixed_amount: Optional[Decimal]

    # Derived breakdown
    breakdown: ChargesBreakdown

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\fee_structure\fee_response.py ---
"""
Fee structure response schemas
"""
from datetime import date
from decimal import Decimal
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import RoomType, FeeType, ChargeType


class FeeStructureResponse(BaseResponseSchema):
    """Fee structure response"""
    hostel_id: UUID
    hostel_name: str

    room_type: RoomType
    fee_type: FeeType

    amount: Decimal
    security_deposit: Decimal

    includes_mess: bool
    mess_charges_monthly: Decimal

    electricity_charges: ChargeType
    electricity_fixed_amount: Optional[Decimal]

    water_charges: ChargeType
    water_fixed_amount: Optional[Decimal]

    effective_from: date
    effective_to: Optional[date]
    is_active: bool


class FeeDetail(BaseSchema):
    """Full fee detail for a room type (assembled for UI)"""
    room_type: RoomType
    fee_type: FeeType
    amount: Decimal
    security_deposit: Decimal
    includes_mess: bool
    mess_charges_monthly: Decimal
    total_first_month_payable: Decimal
    total_recurring_monthly: Decimal


class FeeStructureList(BaseSchema):
    """List of fee structures for a hostel"""
    hostel_id: UUID
    hostel_name: str
    items: List[FeeStructureResponse] = Field(default_factory=list)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\fee_structure\__init__.py ---
"""
Fee structure & configuration schemas package
"""

from app.schemas.fee_structure.fee_base import (
    FeeStructureBase,
    FeeStructureCreate,
    FeeStructureUpdate,
)
from app.schemas.fee_structure.fee_response import (
    FeeStructureResponse,
    FeeDetail,
    FeeStructureList,
)
from app.schemas.fee_structure.fee_config import (
    FeeConfiguration,
    ChargesBreakdown,
)

__all__ = [
    # Base
    "FeeStructureBase",
    "FeeStructureCreate",
    "FeeStructureUpdate",
    # Response
    "FeeStructureResponse",
    "FeeDetail",
    "FeeStructureList",
    # Config
    "FeeConfiguration",
    "ChargesBreakdown",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\fee_structure\fee_base.py ---
# --- File: app/schemas/fee_structure/fee_base.py ---
"""
Base fee structure schemas with comprehensive validation.

This module defines the core fee structure schemas for managing
hostel pricing across different room types and billing frequencies.
"""

from __future__ import annotations

from datetime import date, timedelta
from decimal import Decimal
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import ChargeType, FeeType, RoomType

__all__ = [
    "FeeStructureBase",
    "FeeStructureCreate",
    "FeeStructureUpdate",
]


class FeeStructureBase(BaseSchema):
    """
    Base fee structure schema.
    
    Defines pricing and charges for a specific hostel and room type,
    including base rent, security deposit, utilities, and mess charges.
    """

    hostel_id: UUID = Field(
        ...,
        description="Unique identifier of the hostel",
    )
    room_type: RoomType = Field(
        ...,
        description="Type of room this fee structure applies to",
    )
    fee_type: FeeType = Field(
        ...,
        description="Billing frequency (monthly, quarterly, yearly, etc.)",
    )

    # Base Charges
    amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Base rent amount per billing period",
    )
    security_deposit: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Refundable security deposit amount",
    )

    # Mess Charges
    includes_mess: bool = Field(
        False,
        description="Whether mess/food is included in base rent",
    )
    mess_charges_monthly: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Monthly mess charges (if not included)",
    )

    # Utility Charges - Electricity
    electricity_charges: ChargeType = Field(
        ChargeType.INCLUDED,
        description="How electricity is billed (included/actual/fixed)",
    )
    electricity_fixed_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Fixed monthly electricity charge (if applicable)",
    )

    # Utility Charges - Water
    water_charges: ChargeType = Field(
        ChargeType.INCLUDED,
        description="How water is billed (included/actual/fixed)",
    )
    water_fixed_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Fixed monthly water charge (if applicable)",
    )

    # Validity Period
    effective_from: date = Field(
        ...,
        description="Date from which this fee structure is effective",
    )
    effective_to: Optional[date] = Field(
        None,
        description="End date of fee structure validity (null for indefinite)",
    )

    # Status
    is_active: bool = Field(
        True,
        description="Whether this fee structure is currently active",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate base amount is reasonable."""
        if v <= 0:
            raise ValueError("Base rent amount must be greater than zero")
        
        # Sanity check: Minimum and maximum rent
        min_rent = Decimal("500.00")
        max_rent = Decimal("100000.00")
        
        if v < min_rent:
            raise ValueError(f"Rent amount ({v}) is below minimum ({min_rent})")
        if v > max_rent:
            raise ValueError(f"Rent amount ({v}) exceeds maximum ({max_rent})")
        
        return v.quantize(Decimal("0.01"))

    @field_validator("security_deposit")
    @classmethod
    def validate_security_deposit(cls, v: Decimal) -> Decimal:
        """Validate security deposit amount."""
        if v < 0:
            raise ValueError("Security deposit cannot be negative")
        
        # Typically security deposit is 1-3 months rent
        # This will be validated in model_validator with access to amount
        return v.quantize(Decimal("0.01"))

    @field_validator("mess_charges_monthly")
    @classmethod
    def validate_mess_charges(cls, v: Decimal) -> Decimal:
        """Validate mess charges."""
        if v < 0:
            raise ValueError("Mess charges cannot be negative")
        
        # Sanity check
        max_mess = Decimal("10000.00")
        if v > max_mess:
            raise ValueError(
                f"Mess charges ({v}) exceed reasonable maximum ({max_mess})"
            )
        
        return v.quantize(Decimal("0.01"))

    @model_validator(mode="after")
    def validate_security_deposit_ratio(self) -> "FeeStructureBase":
        """Validate security deposit is reasonable relative to rent."""
        if self.security_deposit > 0:
            # Security deposit typically ranges from 1-3 months rent
            max_security = self.amount * 3
            
            if self.security_deposit > max_security:
                raise ValueError(
                    f"Security deposit ({self.security_deposit}) exceeds "
                    f"3 times the base rent ({self.amount}). "
                    f"Maximum allowed: {max_security}"
                )
        
        return self

    @model_validator(mode="after")
    def validate_electricity_charges(self) -> "FeeStructureBase":
        """Validate electricity charge configuration."""
        if self.electricity_charges == ChargeType.FIXED_MONTHLY:
            if not self.electricity_fixed_amount:
                raise ValueError(
                    "electricity_fixed_amount is required when "
                    "electricity_charges is FIXED_MONTHLY"
                )
            if self.electricity_fixed_amount <= 0:
                raise ValueError("Fixed electricity amount must be greater than zero")
        
        # Clear fixed amount if not fixed type
        if self.electricity_charges != ChargeType.FIXED_MONTHLY:
            if self.electricity_fixed_amount is not None:
                # Automatically clear it
                self.electricity_fixed_amount = None
        
        return self

    @model_validator(mode="after")
    def validate_water_charges(self) -> "FeeStructureBase":
        """Validate water charge configuration."""
        if self.water_charges == ChargeType.FIXED_MONTHLY:
            if not self.water_fixed_amount:
                raise ValueError(
                    "water_fixed_amount is required when "
                    "water_charges is FIXED_MONTHLY"
                )
            if self.water_fixed_amount <= 0:
                raise ValueError("Fixed water amount must be greater than zero")
        
        # Clear fixed amount if not fixed type
        if self.water_charges != ChargeType.FIXED_MONTHLY:
            if self.water_fixed_amount is not None:
                # Automatically clear it
                self.water_fixed_amount = None
        
        return self

    @model_validator(mode="after")
    def validate_mess_configuration(self) -> "FeeStructureBase":
        """Validate mess configuration consistency."""
        if self.includes_mess:
            # If mess is included, charges should be 0
            if self.mess_charges_monthly > 0:
                raise ValueError(
                    "mess_charges_monthly should be 0 when includes_mess is True. "
                    "The mess cost is already included in base rent."
                )
        
        return self

    @model_validator(mode="after")
    def validate_effective_dates(self) -> "FeeStructureBase":
        """Validate effective date range."""
        if self.effective_to is not None:
            if self.effective_to <= self.effective_from:
                raise ValueError(
                    f"effective_to ({self.effective_to}) must be after "
                    f"effective_from ({self.effective_from})"
                )
            
            # Check if date range is reasonable (not too long)
            days_diff = (self.effective_to - self.effective_from).days
            max_validity_days = 1825  # 5 years
            
            if days_diff > max_validity_days:
                raise ValueError(
                    f"Fee structure validity period ({days_diff} days) exceeds "
                    f"maximum allowed ({max_validity_days} days / ~5 years)"
                )
        
        return self

    @field_validator("effective_from")
    @classmethod
    def validate_effective_from(cls, v: date) -> date:
        """Validate effective_from date."""
        # Allow backdated fee structures but warn if too old
        days_ago = (date.today() - v).days
        if days_ago > 365:
            # Log warning - might be data migration
            pass
        
        return v

    @computed_field
    @property
    def is_currently_effective(self) -> bool:
        """Check if fee structure is currently within effective date range."""
        today = date.today()
        if today < self.effective_from:
            return False
        if self.effective_to is not None and today > self.effective_to:
            return False
        return True

    @computed_field
    @property
    def days_until_effective(self) -> int:
        """Calculate days until fee structure becomes effective."""
        if self.effective_from > date.today():
            return (self.effective_from - date.today()).days
        return 0

    @computed_field
    @property
    def days_remaining(self) -> Optional[int]:
        """Calculate days remaining until fee structure expires."""
        if self.effective_to is None:
            return None
        if self.effective_to < date.today():
            return 0
        return (self.effective_to - date.today()).days

    @computed_field
    @property
    def monthly_total_minimum(self) -> Decimal:
        """
        Calculate minimum monthly total.
        
        Includes base rent + mess + minimum utilities (if fixed).
        """
        total = self.amount
        
        if not self.includes_mess:
            total += self.mess_charges_monthly
        
        if self.electricity_charges == ChargeType.FIXED_MONTHLY and self.electricity_fixed_amount:
            total += self.electricity_fixed_amount
        
        if self.water_charges == ChargeType.FIXED_MONTHLY and self.water_fixed_amount:
            total += self.water_fixed_amount
        
        return total.quantize(Decimal("0.01"))


class FeeStructureCreate(FeeStructureBase, BaseCreateSchema):
    """
    Schema for creating a new fee structure.
    
    All base fields are inherited. Additional creation-time
    validations can be added here.
    """

    @model_validator(mode="after")
    def validate_no_overlapping_periods(self) -> "FeeStructureCreate":
        """
        Validate that new fee structure doesn't overlap with existing ones.
        
        Note: This validation requires database access and should be
        implemented at the service layer. This is a placeholder.
        """
        # In production, check for overlaps with existing fee structures
        # for the same hostel_id and room_type
        return self


class FeeStructureUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing fee structure.
    
    All fields are optional, allowing partial updates.
    """

    # Pricing
    amount: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Update base rent amount",
    )
    security_deposit: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Update security deposit",
    )

    # Mess
    includes_mess: Optional[bool] = Field(
        None,
        description="Update mess inclusion",
    )
    mess_charges_monthly: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Update mess charges",
    )

    # Utilities
    electricity_charges: Optional[ChargeType] = Field(
        None,
        description="Update electricity billing method",
    )
    electricity_fixed_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Update fixed electricity amount",
    )

    water_charges: Optional[ChargeType] = Field(
        None,
        description="Update water billing method",
    )
    water_fixed_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Update fixed water amount",
    )

    # Validity
    effective_from: Optional[date] = Field(
        None,
        description="Update effective start date",
    )
    effective_to: Optional[date] = Field(
        None,
        description="Update effective end date",
    )

    # Status
    is_active: Optional[bool] = Field(
        None,
        description="Update active status",
    )

    @field_validator("amount", "security_deposit", "mess_charges_monthly")
    @classmethod
    def validate_amounts(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Validate monetary amounts if provided."""
        if v is not None:
            if v < 0:
                raise ValueError("Amount cannot be negative")
            return v.quantize(Decimal("0.01"))
        return v

    @model_validator(mode="after")
    def validate_partial_updates(self) -> "FeeStructureUpdate":
        """Validate consistency in partial updates."""
        # If electricity is being changed to FIXED_MONTHLY, amount must be provided
        if self.electricity_charges == ChargeType.FIXED_MONTHLY:
            if self.electricity_fixed_amount is None:
                raise ValueError(
                    "electricity_fixed_amount must be provided when changing "
                    "electricity_charges to FIXED_MONTHLY"
                )
        
        # If water is being changed to FIXED_MONTHLY, amount must be provided
        if self.water_charges == ChargeType.FIXED_MONTHLY:
            if self.water_fixed_amount is None:
                raise ValueError(
                    "water_fixed_amount must be provided when changing "
                    "water_charges to FIXED_MONTHLY"
                )
        
        # Validate date range if both dates are being updated
        if self.effective_from is not None and self.effective_to is not None:
            if self.effective_to <= self.effective_from:
                raise ValueError(
                    "effective_to must be after effective_from"
                )
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\fee_structure\fee_config.py ---
# --- File: app/schemas/fee_structure/fee_config.py ---
"""
Fee configuration and breakdown schemas.

This module defines schemas for fee calculations, breakdowns,
and comprehensive fee configurations.
"""

from __future__ import annotations

from decimal import Decimal
from typing import Dict, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import ChargeType, FeeType, RoomType

__all__ = [
    "ChargesBreakdown",
    "FeeConfiguration",
    "FeeComparison",
    "DiscountConfiguration",
]


class ChargesBreakdown(BaseSchema):
    """
    Detailed breakdown of all fee components.
    
    Provides transparent itemization of all charges that make up
    the total fee for a student.
    """

    # Base Components
    base_rent: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Base rent per period",
    )
    mess_charges: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Mess/food charges",
    )
    electricity_charges: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Electricity charges",
    )
    water_charges: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Water charges",
    )
    other_charges: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Other miscellaneous charges",
    )

    # Totals
    total_monthly: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total monthly recurring charges",
    )
    total_first_month: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total for first month (may include one-time charges)",
    )
    security_deposit: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="One-time refundable security deposit",
    )

    # Optional Discount
    discount_amount: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Total discount applied",
    )
    discount_percentage: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Discount as percentage",
    )

    # Tax (if applicable)
    tax_amount: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Tax amount (GST, etc.)",
    )
    tax_percentage: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Tax rate as percentage",
    )

    @computed_field
    @property
    def subtotal(self) -> Decimal:
        """Calculate subtotal before discount and tax."""
        return (
            self.base_rent
            + self.mess_charges
            + self.electricity_charges
            + self.water_charges
            + self.other_charges
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def total_after_discount(self) -> Decimal:
        """Calculate total after applying discount."""
        return (self.total_monthly - self.discount_amount).quantize(Decimal("0.01"))

    @computed_field
    @property
    def grand_total(self) -> Decimal:
        """Calculate grand total including tax."""
        return (self.total_after_discount + self.tax_amount).quantize(Decimal("0.01"))

    @computed_field
    @property
    def total_upfront_payment(self) -> Decimal:
        """
        Calculate total upfront payment required.
        
        Includes security deposit + first month charges.
        """
        return (self.security_deposit + self.total_first_month).quantize(
            Decimal("0.01")
        )


class FeeConfiguration(BaseSchema):
    """
    Complete fee configuration for a hostel/room combination.
    
    Contains all pricing information and calculated breakdowns
    for a specific booking or student assignment.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    room_type: RoomType = Field(
        ...,
        description="Room type",
    )
    fee_type: FeeType = Field(
        ...,
        description="Billing frequency",
    )

    # Base Components
    base_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Base rent amount",
    )
    security_deposit: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Security deposit",
    )

    # Mess Configuration
    includes_mess: bool = Field(
        ...,
        description="Whether mess is included",
    )
    mess_charges_monthly: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly mess charges",
    )

    # Utility Configurations
    electricity_charges: ChargeType = Field(
        ...,
        description="Electricity billing method",
    )
    electricity_fixed_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Fixed electricity amount",
    )

    water_charges: ChargeType = Field(
        ...,
        description="Water billing method",
    )
    water_fixed_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Fixed water amount",
    )

    # Calculated Breakdown
    breakdown: ChargesBreakdown = Field(
        ...,
        description="Detailed charges breakdown",
    )

    # Additional Configuration
    description: Optional[str] = Field(
        None,
        max_length=500,
        description="Configuration description or notes",
    )

    @computed_field
    @property
    def has_variable_charges(self) -> bool:
        """Check if configuration includes variable/actual charges."""
        return (
            self.electricity_charges == ChargeType.ACTUAL
            or self.water_charges == ChargeType.ACTUAL
        )

    @computed_field
    @property
    def is_all_inclusive(self) -> bool:
        """Check if all charges are included in base rent."""
        return (
            self.includes_mess
            and self.electricity_charges == ChargeType.INCLUDED
            and self.water_charges == ChargeType.INCLUDED
        )


class DiscountConfiguration(BaseSchema):
    """
    Discount configuration schema.
    
    Defines various types of discounts that can be applied
    to fee structures.
    """

    discount_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Name of the discount",
    )
    discount_type: str = Field(
        ...,
        pattern=r"^(percentage|fixed_amount|waiver)$",
        description="Type of discount",
    )

    # Discount Value
    discount_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Discount percentage (if type is percentage)",
    )
    discount_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Fixed discount amount (if type is fixed_amount)",
    )

    # Applicability
    applies_to: str = Field(
        ...,
        pattern=r"^(base_rent|mess_charges|total|security_deposit)$",
        description="What the discount applies to",
    )

    # Conditions
    minimum_stay_months: Optional[int] = Field(
        None,
        ge=1,
        description="Minimum stay required for discount",
    )
    valid_for_new_students_only: bool = Field(
        False,
        description="Whether discount is only for new students",
    )

    # Validity
    valid_from: Optional[date] = Field(
        None,
        description="Discount valid from date",
    )
    valid_to: Optional[date] = Field(
        None,
        description="Discount valid until date",
    )

    is_active: bool = Field(
        True,
        description="Whether discount is currently active",
    )

    @field_validator("discount_type")
    @classmethod
    def validate_discount_type(cls, v: str) -> str:
        """Normalize discount type."""
        return v.lower()

    @field_validator("discount_name")
    @classmethod
    def validate_discount_name(cls, v: str) -> str:
        """Validate discount name."""
        v = v.strip()
        if len(v) < 3:
            raise ValueError("Discount name must be at least 3 characters")
        return v

    @computed_field
    @property
    def is_currently_valid(self) -> bool:
        """Check if discount is currently valid."""
        if not self.is_active:
            return False
        
        today = date.today()
        
        if self.valid_from and today < self.valid_from:
            return False
        
        if self.valid_to and today > self.valid_to:
            return False
        
        return True


class FeeComparison(BaseSchema):
    """
    Fee comparison schema for comparing different room types or periods.
    
    Useful for displaying pricing comparisons to potential students.
    """

    room_types: Dict[str, ChargesBreakdown] = Field(
        ...,
        description="Breakdown by room type",
    )

    # Comparison Metadata
    hostel_id: UUID = Field(
        ...,
        description="Hostel being compared",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    fee_type: FeeType = Field(
        ...,
        description="Billing frequency for comparison",
    )

    # Recommendations
    most_economical: str = Field(
        ...,
        description="Most economical room type",
    )
    most_popular: Optional[str] = Field(
        None,
        description="Most popular room type",
    )
    best_value: Optional[str] = Field(
        None,
        description="Best value room type",
    )

    @computed_field
    @property
    def price_range(self) -> str:
        """Get price range across all room types."""
        if not self.room_types:
            return "Not available"
        
        prices = [breakdown.total_monthly for breakdown in self.room_types.values()]
        min_price = min(prices)
        max_price = max(prices)
        
        return f"{min_price:,.2f} - {max_price:,.2f}"

    @computed_field
    @property
    def average_price(self) -> Decimal:
        """Calculate average price across room types."""
        if not self.room_types:
            return Decimal("0.00")
        
        total = sum(breakdown.total_monthly for breakdown in self.room_types.values())
        return (total / len(self.room_types)).quantize(Decimal("0.01"))

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\fee_structure\fee_response.py ---
# --- File: app/schemas/fee_structure/fee_response.py ---
"""
Fee structure response schemas for API responses.

This module defines response schemas for fee structure data including
basic responses, detailed information, and list views.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import ChargeType, FeeType, RoomType

__all__ = [
    "FeeStructureResponse",
    "FeeDetail",
    "FeeStructureList",
    "FeeHistory",
    "FeeHistoryItem",
    "FeeCalculation",
]


class FeeStructureResponse(BaseResponseSchema):
    """
    Standard fee structure response schema.
    
    Contains core fee structure information for API responses.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )

    # Fee Configuration
    room_type: RoomType = Field(
        ...,
        description="Room type",
    )
    fee_type: FeeType = Field(
        ...,
        description="Billing frequency",
    )

    # Base Charges
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Base rent amount",
    )
    security_deposit: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Security deposit",
    )

    # Mess Charges
    includes_mess: bool = Field(
        ...,
        description="Whether mess is included",
    )
    mess_charges_monthly: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly mess charges",
    )

    # Utility Charges
    electricity_charges: ChargeType = Field(
        ...,
        description="Electricity billing method",
    )
    electricity_fixed_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Fixed electricity amount",
    )

    water_charges: ChargeType = Field(
        ...,
        description="Water billing method",
    )
    water_fixed_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Fixed water amount",
    )

    # Validity Period
    effective_from: date = Field(
        ...,
        description="Effective start date",
    )
    effective_to: Optional[date] = Field(
        None,
        description="Effective end date",
    )

    # Status
    is_active: bool = Field(
        ...,
        description="Active status",
    )

    @computed_field
    @property
    def total_monthly_minimum(self) -> Decimal:
        """
        Calculate minimum monthly total.
        
        Includes all fixed charges that apply monthly.
        """
        total = self.amount
        
        # Add mess charges if not included
        if not self.includes_mess:
            total += self.mess_charges_monthly
        
        # Add fixed utility charges
        if self.electricity_charges == ChargeType.FIXED_MONTHLY and self.electricity_fixed_amount:
            total += self.electricity_fixed_amount
        
        if self.water_charges == ChargeType.FIXED_MONTHLY and self.water_fixed_amount:
            total += self.water_fixed_amount
        
        return total.quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_currently_effective(self) -> bool:
        """Check if fee structure is currently in effect."""
        today = date.today()
        
        if today < self.effective_from:
            return False
        
        if self.effective_to is not None and today > self.effective_to:
            return False
        
        return True

    @computed_field
    @property
    def status_display(self) -> str:
        """Get user-friendly status display."""
        if not self.is_active:
            return "Inactive"
        
        if not self.is_currently_effective:
            if date.today() < self.effective_from:
                return "Scheduled"
            else:
                return "Expired"
        
        return "Active"

    @computed_field
    @property
    def has_variable_charges(self) -> bool:
        """Check if structure includes variable charges."""
        return (
            self.electricity_charges == ChargeType.ACTUAL
            or self.water_charges == ChargeType.ACTUAL
        )


class FeeDetail(BaseSchema):
    """
    Detailed fee information for a room type.
    
    Assembled view optimized for UI display with all calculations
    pre-computed.
    """

    room_type: RoomType = Field(
        ...,
        description="Room type",
    )
    room_type_display: str = Field(
        ...,
        description="Human-readable room type name",
    )

    fee_type: FeeType = Field(
        ...,
        description="Billing frequency",
    )

    # Breakdown
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Base rent amount",
    )
    security_deposit: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Security deposit",
    )

    includes_mess: bool = Field(
        ...,
        description="Mess included",
    )
    mess_charges_monthly: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly mess charges",
    )

    # Calculated Totals
    total_first_month_payable: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total amount due for first month (including security deposit)",
    )
    total_recurring_monthly: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Recurring monthly charges",
    )

    # Utility Information
    utilities_included: bool = Field(
        ...,
        description="Whether utilities are included in base rent",
    )
    utilities_description: str = Field(
        ...,
        description="Description of utility billing",
    )

    # Availability
    available_beds: int = Field(
        ...,
        ge=0,
        description="Number of available beds for this room type",
    )

    # Discounts
    has_discounts: bool = Field(
        False,
        description="Whether discounts are available",
    )
    discount_info: Optional[str] = Field(
        None,
        description="Discount information",
    )

    @computed_field
    @property
    def is_available(self) -> bool:
        """Check if room type has availability."""
        return self.available_beds > 0

    @computed_field
    @property
    def savings_with_longer_stay(self) -> Optional[Decimal]:
        """Calculate potential savings with longer billing periods."""
        # This would be calculated based on quarterly/yearly discounts
        # Placeholder for business logic
        return None


class FeeStructureList(BaseSchema):
    """
    List of fee structures for a hostel.
    
    Provides organized view of all fee structures.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )

    # Fee Structures
    items: List[FeeStructureResponse] = Field(
        default_factory=list,
        description="List of fee structures",
    )

    # Summary Statistics
    total_structures: int = Field(
        ...,
        ge=0,
        description="Total number of fee structures",
    )
    active_structures: int = Field(
        ...,
        ge=0,
        description="Number of active structures",
    )

    # Price Range
    min_monthly_rent: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Minimum monthly rent across all room types",
    )
    max_monthly_rent: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Maximum monthly rent across all room types",
    )

    @computed_field
    @property
    def price_range_display(self) -> str:
        """Get formatted price range."""
        if self.min_monthly_rent is None or self.max_monthly_rent is None:
            return "Not available"
        
        if self.min_monthly_rent == self.max_monthly_rent:
            return f"{self.min_monthly_rent:,.2f}/month"
        
        return f"{self.min_monthly_rent:,.2f} - {self.max_monthly_rent:,.2f}/month"

    @computed_field
    @property
    def room_types_available(self) -> List[str]:
        """Get list of available room types."""
        return list(set(item.room_type.value for item in self.items if item.is_active))


class FeeHistoryItem(BaseSchema):
    """
    Individual fee history entry.
    
    Represents a single historical fee structure.
    """

    fee_structure_id: UUID = Field(
        ...,
        description="Fee structure ID",
    )

    room_type: RoomType = Field(
        ...,
        description="Room type",
    )

    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Rent amount",
    )

    effective_from: date = Field(
        ...,
        description="Effective start date",
    )
    effective_to: Optional[date] = Field(
        None,
        description="Effective end date",
    )

    # Change Information
    changed_by: Optional[UUID] = Field(
        None,
        description="Admin who made the change",
    )
    changed_by_name: Optional[str] = Field(
        None,
        description="Name of admin who made change",
    )
    change_reason: Optional[str] = Field(
        None,
        description="Reason for change",
    )

    # Previous Value (for comparison)
    previous_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Previous rent amount",
    )

    @computed_field
    @property
    def amount_change(self) -> Optional[Decimal]:
        """Calculate amount change from previous."""
        if self.previous_amount is None:
            return None
        return (self.amount - self.previous_amount).quantize(Decimal("0.01"))

    @computed_field
    @property
    def amount_change_percentage(self) -> Optional[Decimal]:
        """Calculate percentage change."""
        if self.previous_amount is None or self.previous_amount == 0:
            return None
        
        change = ((self.amount - self.previous_amount) / self.previous_amount) * 100
        return Decimal(change).quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_increase(self) -> bool:
        """Check if this was a price increase."""
        if self.amount_change is None:
            return False
        return self.amount_change > 0


class FeeHistory(BaseSchema):
    """
    Fee history for a hostel/room type.
    
    Tracks all historical changes to fee structures.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    room_type: RoomType = Field(
        ...,
        description="Room type",
    )

    # History Entries
    history: List[FeeHistoryItem] = Field(
        default_factory=list,
        description="List of historical fee structures (ordered by date)",
    )

    # Statistics
    total_changes: int = Field(
        ...,
        ge=0,
        description="Total number of fee changes",
    )
    average_change_interval_days: Optional[int] = Field(
        None,
        ge=0,
        description="Average days between fee changes",
    )

    @computed_field
    @property
    def current_fee(self) -> Optional[FeeHistoryItem]:
        """Get current active fee structure."""
        today = date.today()
        
        for entry in self.history:
            if entry.effective_from <= today:
                if entry.effective_to is None or entry.effective_to >= today:
                    return entry
        
        return None

    @computed_field
    @property
    def total_increases(self) -> int:
        """Count number of price increases."""
        return sum(1 for entry in self.history if entry.is_increase)

    @computed_field
    @property
    def total_decreases(self) -> int:
        """Count number of price decreases."""
        return sum(
            1 for entry in self.history 
            if entry.amount_change is not None and entry.amount_change < 0
        )


class FeeCalculation(BaseSchema):
    """
    Fee calculation result.
    
    Contains detailed calculation for a specific student booking
    or fee estimation.
    """

    # Input Parameters
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    room_type: RoomType = Field(
        ...,
        description="Room type",
    )
    fee_type: FeeType = Field(
        ...,
        description="Billing frequency",
    )
    stay_duration_months: int = Field(
        ...,
        ge=1,
        description="Stay duration in months",
    )

    # Base Charges
    monthly_rent: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly rent",
    )
    security_deposit: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Security deposit",
    )

    # Additional Charges
    mess_charges_total: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total mess charges for duration",
    )
    utility_charges_estimated: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Estimated utility charges",
    )

    # Discounts
    discount_applied: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Total discount amount",
    )
    discount_description: Optional[str] = Field(
        None,
        description="Discount details",
    )

    # Totals
    subtotal: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Subtotal before discount",
    )
    total_payable: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total amount payable",
    )
    first_month_total: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount due for first month",
    )

    # Payment Schedule
    monthly_recurring: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Recurring monthly amount",
    )

    # Breakdown by Period
    payment_schedule: Dict[int, Decimal] = Field(
        default_factory=dict,
        description="Payment schedule by month number",
    )

    @computed_field
    @property
    def average_monthly_cost(self) -> Decimal:
        """Calculate average monthly cost including all charges."""
        if self.stay_duration_months == 0:
            return Decimal("0.00")
        
        # Exclude security deposit from average (it's refundable)
        total_without_deposit = self.total_payable - self.security_deposit
        
        return (total_without_deposit / self.stay_duration_months).quantize(
            Decimal("0.01")
        )

    @computed_field
    @property
    def total_savings(self) -> Decimal:
        """Calculate total savings from discounts."""
        return self.discount_applied

    @computed_field
    @property
    def savings_percentage(self) -> Decimal:
        """Calculate savings as percentage of original amount."""
        if self.subtotal == 0:
            return Decimal("0.00")
        
        return ((self.discount_applied / self.subtotal) * 100).quantize(
            Decimal("0.01")
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\fee_structure\__init__.py ---
# --- File: app/schemas/fee_structure/__init__.py ---
"""
Fee structure and configuration schemas package.

This module exports all fee structure-related schemas for easy importing
across the application.
"""

from __future__ import annotations

from app.schemas.fee_structure.fee_base import (
    FeeStructureBase,
    FeeStructureCreate,
    FeeStructureUpdate,
)
from app.schemas.fee_structure.fee_config import (
    ChargesBreakdown,
    DiscountConfiguration,
    FeeComparison,
    FeeConfiguration,
)
from app.schemas.fee_structure.fee_response import (
    FeeCalculation,
    FeeDetail,
    FeeHistory,
    FeeHistoryItem,
    FeeStructureList,
    FeeStructureResponse,
)

__all__ = [
    # Base
    "FeeStructureBase",
    "FeeStructureCreate",
    "FeeStructureUpdate",
    # Response
    "FeeStructureResponse",
    "FeeDetail",
    "FeeStructureList",
    "FeeHistory",
    "FeeHistoryItem",
    "FeeCalculation",
    # Configuration
    "FeeConfiguration",
    "ChargesBreakdown",
    "DiscountConfiguration",
    "FeeComparison",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\file =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\file\all_folders_files_content.txt ---
### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\file ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\file =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\file\document_upload.py ---
"""
Document upload-specific schemas
"""
from datetime import date
from typing import Optional, List
from pydantic import Field, HttpUrl
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.file.file_upload import FileUploadInitResponse


class DocumentUploadInitRequest(BaseCreateSchema):
    """
    Initialize a document upload.

    For ID proofs, agreements, invoices, etc.
    """
    filename: str = Field(..., min_length=1, max_length=255)
    content_type: str = Field(
        ...,
        pattern=r"^(application\/pdf|image\/[a-zA-Z0-9.+-]+)$",
        description="Allowed: PDF or image formats",
    )
    size_bytes: int = Field(
        ...,
        ge=1,
        le=25 * 1024 * 1024,
        description="Max 25MB for documents",
    )

    uploaded_by_user_id: UUID
    student_id: Optional[UUID] = None
    hostel_id: Optional[UUID] = None

    document_type: str = Field(
        ...,
        pattern=(
            r"^(id_proof|address_proof|agreement|invoice|receipt|"
            r"medical_certificate|other)$"
        ),
        description="Type of document",
    )

    # Additional classification
    description: Optional[str] = Field(None, max_length=255)


class DocumentUploadInitResponse(FileUploadInitResponse):
    """Document-specific init response (same as generic for now)"""
    # Can be extended with OCR flags, etc.
    pass


class DocumentValidationResult(BaseSchema):
    """
    Result of backend-side document validation
    (e.g. mime, size, simple content checks).
    """
    storage_key: str
    is_valid: bool
    reason: Optional[str] = Field(None, description="Why invalid, if false")

    # Optional extracted info (non-PII summary)
    extracted_metadata: Optional[dict] = Field(
        None,
        description="e.g. issue_date, expiry_date (if parsed)",
    )


class DocumentInfo(BaseSchema):
    """Document info for student/admin views"""
    id: UUID
    storage_key: str
    url: HttpUrl

    document_type: str
    description: Optional[str]

    uploaded_by_user_id: UUID
    uploaded_by_name: Optional[str]

    uploaded_at: date
    verified: bool
    verified_by: Optional[UUID]
    verified_at: Optional[date]
    verification_notes: Optional[str]


class DocumentList(BaseSchema):
    """List of documents for a student/hostel"""
    owner_type: str = Field(..., pattern="^(student|hostel|system)$")
    owner_id: UUID

    documents: List[DocumentInfo] = Field(default_factory=list)
    total_documents: int

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\file\file_response.py ---
"""
File information and listing schemas
"""
from datetime import datetime
from typing import List, Optional, Dict
from pydantic import Field, HttpUrl
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema


class FileMetadata(BaseSchema):
    """Additional metadata attached to a file"""
    content_type: str = Field(..., description="MIME type")
    size_bytes: int = Field(..., ge=0, description="File size in bytes")

    # Optional metadata
    original_filename: Optional[str] = Field(None, description="Original filename")
    tags: List[str] = Field(default_factory=list)
    category: Optional[str] = Field(None, description="Logical category")
    custom_metadata: Dict[str, str] = Field(
        default_factory=dict,
        description="Free-form key/value metadata (e.g. 'room_id', 'hostel_id')",
    )


class FileInfo(BaseResponseSchema):
    """Full file information as stored in the system"""
    storage_key: str = Field(..., description="Storage path/key (unique)")

    # Ownership / context
    uploaded_by_user_id: UUID
    hostel_id: Optional[UUID] = None

    # Access
    is_public: bool = Field(False, description="Publicly accessible or not")
    public_url: Optional[HttpUrl] = Field(None, description="Public CDN URL if is_public=True")
    signed_url: Optional[HttpUrl] = Field(
        None,
        description="Signed temporary URL for private access (optional)",
    )

    # Metadata
    metadata: FileMetadata

    # Audit
    created_at: datetime
    updated_at: datetime


class FileURL(BaseSchema):
    """Simple container for a file URL"""
    url: HttpUrl
    expires_at: Optional[datetime] = Field(
        None,
        description="If signed URL, when it will expire",
    )


class FileListResponse(BaseSchema):
    """Paginated list of files"""
    items: List[FileInfo] = Field(default_factory=list)
    total_items: int
    page: int
    page_size: int

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\file\file_upload.py ---
"""
Generic file upload schemas (pre-signed URL / direct upload)
"""
from datetime import datetime
from typing import List, Optional, Dict
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema


class FileUploadInitRequest(BaseCreateSchema):
    """
    Request to initialize a file upload.

    Typically used to generate a pre-signed URL or
    register a file before multipart upload.
    """
    filename: str = Field(..., min_length=1, max_length=255)
    content_type: str = Field(
        ...,
        max_length=255,
        description="MIME type, e.g. 'image/jpeg', 'application/pdf'",
    )
    size_bytes: int = Field(
        ...,
        ge=1,
        le=50 * 1024 * 1024,
        description="Expected file size in bytes (max 50MB by default)",
    )

    # Logical location
    folder: Optional[str] = Field(
        None,
        max_length=255,
        description="Logical folder/path (e.g. 'hostels/123/photos')",
    )

    # Ownership / context
    uploaded_by_user_id: UUID = Field(..., description="User initiating upload")
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel context (if file is hostel-specific)",
    )

    # Metadata / classification
    category: Optional[str] = Field(
        None,
        max_length=50,
        description="Category, e.g. 'hostel_photo', 'document', 'avatar'",
    )
    tags: List[str] = Field(
        default_factory=list,
        description="Free-form tags for search/filtering",
    )

    # Access control
    is_public: bool = Field(
        False,
        description="If true, file will be publicly accessible (CDN/public URL)",
    )


class FileUploadInitResponse(BaseResponseSchema):
    """
    Response for upload initialization.

    Either returns a direct upload URL (pre-signed) or
    indicates that the client should upload via the API.
    """
    filename: str
    content_type: str
    size_bytes: int

    storage_key: str = Field(
        ...,
        description="Internal storage key/path for this file",
    )

    # Pre-signed URL (for direct S3/GCS upload)
    upload_url: Optional[str] = Field(
        None,
        description="Pre-signed URL for direct upload to object storage",
    )
    upload_method: str = Field(
        "PUT",
        description="HTTP method to use with upload_url (PUT/POST)",
    )
    upload_headers: Dict[str, str] = Field(
        default_factory=dict,
        description="Any headers that must be included when uploading",
    )

    # Access information
    is_public: bool
    public_url: Optional[str] = Field(
        None,
        description="Public URL if file is/will be public",
    )


class FileUploadCompleteRequest(BaseCreateSchema):
    """
    Notify backend that the client finished uploading the file
    to the storage using the pre-signed URL.
    """
    storage_key: str = Field(..., description="Storage key returned in init response")
    uploaded_by_user_id: UUID = Field(..., description="User who uploaded")
    checksum: Optional[str] = Field(
        None,
        description="Optional checksum/ETag from storage to verify integrity",
    )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\file\image_upload.py ---
"""
Image upload-specific schemas
"""
from typing import List, Optional
from pydantic import Field, HttpUrl
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.file.file_upload import FileUploadInitResponse


class ImageUploadInitRequest(BaseCreateSchema):
    """
    Initialize an image upload.

    Used for hostel photos, room photos, avatars, etc.
    """
    filename: str = Field(..., min_length=1, max_length=255)
    content_type: str = Field(
        ...,
        pattern=r"^image\/[a-zA-Z0-9.+-]+$",
        description="Image MIME type, e.g. 'image/jpeg', 'image/png'",
    )
    size_bytes: int = Field(
        ...,
        ge=1,
        le=20 * 1024 * 1024,
        description="Max 20MB for images",
    )

    uploaded_by_user_id: UUID
    hostel_id: Optional[UUID] = None

    # Usage context
    usage: str = Field(
        ...,
        pattern=r"^(hostel_cover|hostel_gallery|room_photo|avatar|document_scan)$",
        description="Intended usage of the image",
    )

    # Optional transformations
    generate_variants: bool = Field(
        True,
        description="If true, system may generate resized variants",
    )


class ImageVariant(BaseSchema):
    """Information about an image variant (thumbnail, medium, etc.)"""
    name: str = Field(..., description="Variant name, e.g. 'thumbnail', 'medium'")
    url: HttpUrl = Field(..., description="URL for this variant")
    width: Optional[int] = Field(None, ge=1)
    height: Optional[int] = Field(None, ge=1)
    size_bytes: Optional[int] = Field(None, ge=0)


class ImageUploadInitResponse(FileUploadInitResponse):
    """
    Image-specific upload init response.

    Extends generic file upload init response with image-specific hints.
    """
    variants_planned: List[str] = Field(
        default_factory=lambda: ["thumbnail", "medium"],
        description="Variants the system will generate after upload (for reference)",
    )


class ImageProcessingResult(BaseSchema):
    """Result of post-upload image processing"""
    storage_key: str
    original_url: HttpUrl
    variants: List[ImageVariant] = Field(default_factory=list)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\file\__init__.py ---
"""
File management schemas package
"""

from app.schemas.file.file_upload import (
    FileUploadInitRequest,
    FileUploadInitResponse,
    FileUploadCompleteRequest,
)
from app.schemas.file.file_response import (
    FileInfo,
    FileMetadata,
    FileURL,
    FileListResponse,
)
from app.schemas.file.image_upload import (
    ImageUploadInitRequest,
    ImageUploadInitResponse,
    ImageVariant,
)
from app.schemas.file.document_upload import (
    DocumentUploadInitRequest,
    DocumentUploadInitResponse,
    DocumentValidationResult,
)

__all__ = [
    # Generic file
    "FileUploadInitRequest",
    "FileUploadInitResponse",
    "FileUploadCompleteRequest",
    "FileInfo",
    "FileMetadata",
    "FileURL",
    "FileListResponse",
    # Images
    "ImageUploadInitRequest",
    "ImageUploadInitResponse",
    "ImageVariant",
    # Documents
    "DocumentUploadInitRequest",
    "DocumentUploadInitResponse",
    "DocumentValidationResult",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\file\document_upload.py ---
"""
Document-specific upload schemas with validation and verification.

Handles document uploads including ID proofs, agreements, invoices,
and other official documents with OCR and verification support.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Dict, List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator,computed_field

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import IDProofType
from app.schemas.file.file_upload import FileUploadInitResponse

__all__ = [
    "DocumentUploadInitRequest",
    "DocumentUploadInitResponse",
    "DocumentValidationResult",
    "DocumentInfo",
    "DocumentList",
    "DocumentVerificationRequest",
    "DocumentVerificationResponse",
    "DocumentOCRResult",
    "DocumentExpiryAlert",
]


class DocumentUploadInitRequest(BaseCreateSchema):
    """
    Initialize document upload with classification.
    
    Supports various document types with appropriate validation
    and processing rules.
    """

    filename: str = Field(..., min_length=1, max_length=255)
    content_type: str = Field(
        ...,
        pattern=r"^(application\/pdf|image\/(jpeg|jpg|png|tiff|bmp))$",
        description="Allowed: PDF or image formats for documents",
    )
    size_bytes: int = Field(
        ...,
        ge=1,
        le=25 * 1024 * 1024,
        description="Document size (max 25 MB)",
    )

    uploaded_by_user_id: str = Field(...)
    student_id: Optional[str] = Field(
        None,
        description="Student ID if document belongs to student",
    )
    hostel_id: Optional[str] = Field(
        None,
        description="Hostel ID if document is hostel-related",
    )

    # Document classification
    document_type: str = Field(
        ...,
        pattern=r"^(id_proof|address_proof|income_proof|educational_certificate|"
        r"medical_certificate|agreement|invoice|receipt|noc|"
        r"parent_consent|police_verification|other)$",
        description="Type of document being uploaded",
    )
    document_subtype: Optional[str] = Field(
        None,
        max_length=50,
        description="Specific subtype (e.g., 'aadhaar', 'passport' for id_proof)",
    )

    # Metadata
    description: Optional[str] = Field(
        None,
        max_length=500,
        description="Document description or notes",
    )
    reference_number: Optional[str] = Field(
        None,
        max_length=100,
        description="Document reference/ID number",
    )

    # Dates
    issue_date: Optional[date] = Field(
        None,
        description="Document issue date",
    )
    expiry_date: Optional[date] = Field(
        None,
        description="Document expiry date (if applicable)",
    )

    # Processing options
    enable_ocr: bool = Field(
        default=True,
        description="Enable OCR text extraction",
    )
    auto_verify: bool = Field(
        default=False,
        description="Attempt automatic verification if possible",
    )
    redact_sensitive_info: bool = Field(
        default=False,
        description="Redact sensitive information (PII)",
    )

    @field_validator("filename")
    @classmethod
    def validate_document_filename(cls, v: str) -> str:
        """Validate document filename."""
        v = v.strip()
        if not v:
            raise ValueError("Filename cannot be empty")
        
        valid_extensions = [".pdf", ".jpg", ".jpeg", ".png", ".tiff", ".bmp"]
        if not any(v.lower().endswith(ext) for ext in valid_extensions):
            raise ValueError(
                f"Invalid extension. Allowed: {', '.join(valid_extensions)}"
            )
        
        return v

    @field_validator("reference_number")
    @classmethod
    def validate_reference_number(cls, v: Optional[str]) -> Optional[str]:
        """Normalize reference number."""
        if v is not None:
            v = v.strip().upper()
            if not v:
                return None
        return v

    @field_validator("expiry_date")
    @classmethod
    def validate_expiry_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate expiry date is in the future."""
        if v is not None and v < date.today():
            raise ValueError(
                "Document expiry date cannot be in the past"
            )
        return v

    @model_validator(mode="after")
    def validate_dates_consistency(self) -> "DocumentUploadInitRequest":
        """Validate issue and expiry dates are consistent."""
        if self.issue_date and self.expiry_date:
            if self.expiry_date <= self.issue_date:
                raise ValueError(
                    "Expiry date must be after issue date"
                )
        
        return self


class DocumentUploadInitResponse(FileUploadInitResponse):
    """
    Document-specific upload initialization response.
    
    Extends base response with document processing information.
    """

    document_type: str = Field(..., description="Document type")
    
    # Processing flags
    will_perform_ocr: bool = Field(
        default=False,
        description="Whether OCR will be performed",
    )
    will_auto_verify: bool = Field(
        default=False,
        description="Whether automatic verification will be attempted",
    )
    
    # Expected processing time
    estimated_processing_time_seconds: Optional[int] = Field(
        None,
        ge=0,
        description="Estimated time for document processing",
    )


class DocumentValidationResult(BaseSchema):
    """
    Backend document validation result.
    
    Validates document format, size, content, and basic checks.
    """

    storage_key: str = Field(..., description="Document storage key")
    file_id: str = Field(..., description="File identifier")

    # Validation status
    is_valid: bool = Field(..., description="Overall validation status")
    validation_score: int = Field(
        ge=0,
        le=100,
        description="Validation confidence score (0-100)",
    )

    # Validation checks
    checks_passed: List[str] = Field(
        default_factory=list,
        description="List of passed validation checks",
    )
    checks_failed: List[str] = Field(
        default_factory=list,
        description="List of failed validation checks",
    )
    warnings: List[str] = Field(
        default_factory=list,
        description="Validation warnings",
    )

    # Failure details
    reason: Optional[str] = Field(
        None,
        description="Primary reason if invalid",
    )
    error_details: Optional[str] = Field(
        None,
        description="Detailed error information",
    )

    # Extracted metadata (non-PII summary)
    extracted_metadata: Optional[Dict[str, str]] = Field(
        None,
        description="Extracted document metadata",
    )
    detected_type: Optional[str] = Field(
        None,
        description="Auto-detected document type",
    )
    confidence_level: Optional[str] = Field(
        None,
        description="Detection confidence",
        examples=["high", "medium", "low"],
    )

    validated_at: datetime = Field(
        ...,
        description="Validation timestamp",
    )


class DocumentInfo(BaseResponseSchema):
    """
    Comprehensive document information.
    
    Used for displaying document details to users and admins.
    """

    document_id: str = Field(..., description="Document identifier")
    file_id: str = Field(..., description="Associated file ID")
    storage_key: str = Field(..., description="Storage key")

    # URLs
    url: HttpUrl = Field(..., description="Document access URL")
    thumbnail_url: Optional[HttpUrl] = Field(
        None,
        description="Thumbnail URL for preview",
    )

    # Classification
    document_type: str = Field(..., description="Document type")
    document_subtype: Optional[str] = Field(None, description="Document subtype")
    description: Optional[str] = Field(None, description="Description")

    # Ownership
    uploaded_by_user_id: str = Field(..., description="Uploader user ID")
    uploaded_by_name: Optional[str] = Field(None, description="Uploader name")
    student_id: Optional[str] = Field(None, description="Associated student")
    hostel_id: Optional[str] = Field(None, description="Associated hostel")

    # Document details
    reference_number: Optional[str] = Field(None, description="Reference number")
    issue_date: Optional[date] = Field(None, description="Issue date")
    expiry_date: Optional[date] = Field(None, description="Expiry date")

    # File metadata
    filename: str = Field(..., description="Original filename")
    content_type: str = Field(..., description="MIME type")
    size_bytes: int = Field(ge=0, description="File size")

    # Verification status
    verified: bool = Field(
        default=False,
        description="Whether document has been verified",
    )
    verified_by: Optional[str] = Field(
        None,
        description="User ID who verified",
    )
    verified_by_name: Optional[str] = Field(
        None,
        description="Verifier name",
    )
    verified_at: Optional[datetime] = Field(
        None,
        description="Verification timestamp",
    )
    verification_notes: Optional[str] = Field(
        None,
        description="Verification notes",
    )

    # Status
    status: str = Field(
        default="pending",
        description="Document status",
        examples=["pending", "verified", "rejected", "expired"],
    )
    rejection_reason: Optional[str] = Field(
        None,
        description="Reason for rejection if rejected",
    )

    # OCR results
    ocr_completed: bool = Field(
        default=False,
        description="Whether OCR was performed",
    )
    extracted_text: Optional[str] = Field(
        None,
        description="OCR extracted text (truncated for display)",
    )

    # Timestamps
    uploaded_at: datetime = Field(..., description="Upload timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    

    @computed_field
    @property
    def is_expired(self) -> bool:
        """Check if document has expired."""
        if self.expiry_date is None:
            return False
        return self.expiry_date < date.today()

    @computed_field
    @property
    def days_until_expiry(self) -> Optional[int]:
        """Get days until expiry."""
        if self.expiry_date is None:
            return None
        delta = self.expiry_date - date.today()
        return delta.days

    @computed_field
    @property
    def is_expiring_soon(self) -> bool:
        """Check if document expires within 30 days."""
        days = self.days_until_expiry
        return days is not None and 0 <= days <= 30


class DocumentList(BaseSchema):
    """
    List of documents for a student/hostel/user.
    
    Provides organized document listing with filtering.
    """

    owner_type: str = Field(
        ...,
        pattern=r"^(student|hostel|user|system)$",
        description="Owner entity type",
    )
    owner_id: str = Field(..., description="Owner identifier")

    documents: List[DocumentInfo] = Field(
        default_factory=list,
        description="List of documents",
    )

    # Summary
    total_documents: int = Field(ge=0, description="Total document count")
    verified_count: int = Field(ge=0, description="Verified documents")
    pending_count: int = Field(ge=0, description="Pending verification")
    expired_count: int = Field(ge=0, description="Expired documents")
    expiring_soon_count: int = Field(
        ge=0,
        description="Documents expiring within 30 days",
    )

    # By type breakdown
    by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Document count by type",
    )

    @computed_field
    @property
    def verification_rate(self) -> float:
        """Get verification rate percentage."""
        if self.total_documents == 0:
            return 0.0
        return round((self.verified_count / self.total_documents) * 100, 2)


class DocumentVerificationRequest(BaseCreateSchema):
    """
    Request to verify a document.
    
    Used by admins/supervisors to verify uploaded documents.
    """

    document_id: str = Field(..., description="Document identifier to verify")
    
    verified_by_user_id: str = Field(
        ...,
        description="User performing verification",
    )

    # Verification decision
    verification_status: str = Field(
        ...,
        pattern=r"^(approved|rejected)$",
        description="Verification decision",
    )

    # Notes
    verification_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Verification notes or comments",
    )
    rejection_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for rejection (required if rejected)",
    )

    # Extracted information (manual correction)
    extracted_reference_number: Optional[str] = Field(
        None,
        max_length=100,
        description="Manually extracted reference number",
    )
    extracted_issue_date: Optional[date] = Field(
        None,
        description="Manually extracted issue date",
    )
    extracted_expiry_date: Optional[date] = Field(
        None,
        description="Manually extracted expiry date",
    )

    @model_validator(mode="after")
    def validate_rejection_reason(self) -> "DocumentVerificationRequest":
        """Ensure rejection reason is provided when rejecting."""
        if self.verification_status == "rejected" and not self.rejection_reason:
            raise ValueError(
                "Rejection reason is required when rejecting a document"
            )
        return self


class DocumentVerificationResponse(BaseSchema):
    """
    Response after document verification.
    
    Confirms verification action and provides updated status.
    """

    document_id: str = Field(..., description="Document identifier")
    file_id: str = Field(..., description="Associated file ID")

    verification_status: str = Field(..., description="Verification status")
    verified_by: str = Field(..., description="Verifier user ID")
    verified_by_name: str = Field(..., description="Verifier name")
    verified_at: datetime = Field(..., description="Verification timestamp")

    message: str = Field(
        ...,
        description="Confirmation message",
        examples=["Document verified successfully", "Document rejected"],
    )


class DocumentOCRResult(BaseSchema):
    """
    OCR (Optical Character Recognition) result.
    
    Contains extracted text and structured data from document.
    """

    document_id: str = Field(..., description="Document identifier")
    file_id: str = Field(..., description="File identifier")

    # OCR status
    ocr_status: str = Field(
        ...,
        description="OCR processing status",
        examples=["completed", "failed", "partial"],
    )
    confidence_score: Optional[float] = Field(
        None,
        ge=0,
        le=100,
        description="Overall OCR confidence score (0-100)",
    )

    # Extracted content
    full_text: str = Field(
        default="",
        description="Complete extracted text",
    )
    text_length: int = Field(
        ge=0,
        description="Length of extracted text",
    )

    # Structured data extraction
    extracted_fields: Dict[str, str] = Field(
        default_factory=dict,
        description="Structured fields extracted from document",
    )

    # For ID documents
    extracted_name: Optional[str] = Field(None, description="Extracted name")
    extracted_id_number: Optional[str] = Field(None, description="Extracted ID number")
    extracted_dob: Optional[str] = Field(None, description="Extracted date of birth")
    extracted_address: Optional[str] = Field(None, description="Extracted address")

    # Processing metadata
    ocr_engine: str = Field(
        default="tesseract",
        description="OCR engine used",
        examples=["tesseract", "google_vision", "aws_textract"],
    )
    processing_time_seconds: Optional[float] = Field(
        None,
        ge=0,
        description="OCR processing time",
    )
    processed_at: datetime = Field(..., description="OCR completion timestamp")

    # Error information
    error_message: Optional[str] = Field(
        None,
        description="Error message if OCR failed",
    )


class DocumentExpiryAlert(BaseSchema):
    """
    Document expiry alert/notification.
    
    Used to notify users about expiring or expired documents.
    """

    document_id: str = Field(..., description="Document identifier")
    document_type: str = Field(..., description="Document type")
    reference_number: Optional[str] = Field(None, description="Document reference")

    owner_id: str = Field(..., description="Document owner ID")
    owner_type: str = Field(..., description="Owner type (student/hostel)")
    owner_name: str = Field(..., description="Owner name")

    # Expiry information
    expiry_date: date = Field(..., description="Document expiry date")
    days_until_expiry: int = Field(
        ...,
        description="Days until expiry (negative if already expired)",
    )

    # Alert details
    alert_type: str = Field(
        ...,
        description="Alert type",
        examples=["expiring_soon", "expired", "renewal_required"],
    )
    severity: str = Field(
        ...,
        description="Alert severity",
        examples=["info", "warning", "critical"],
    )

    # Notification
    notification_sent: bool = Field(
        default=False,
        description="Whether notification was sent",
    )
    notification_sent_at: Optional[datetime] = Field(
        None,
        description="Notification timestamp",
    )

    created_at: datetime = Field(..., description="Alert creation timestamp")

    @computed_field
    @property
    def is_expired(self) -> bool:
        """Check if document is already expired."""
        return self.days_until_expiry < 0

    @computed_field
    @property
    def urgency_level(self) -> str:
        """Determine urgency level based on days until expiry."""
        if self.days_until_expiry < 0:
            return "critical"
        elif self.days_until_expiry <= 7:
            return "high"
        elif self.days_until_expiry <= 30:
            return "medium"
        else:
            return "low"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\file\file_filters.py ---
"""
File filtering and search schemas.

Provides comprehensive filtering, searching, and sorting
capabilities for file queries.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import List, Optional

from pydantic import Field, field_validator

from app.schemas.common.base import BaseFilterSchema

__all__ = [
    "FileFilterParams",
    "FileSearchRequest",
    "FileSortOptions",
    "DocumentFilterParams",
    "ImageFilterParams",
]


class FileFilterParams(BaseFilterSchema):
    """
    Comprehensive file filter parameters.
    
    Supports filtering by multiple dimensions for flexible queries.
    """

    # Text search
    search: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Search in filename, tags, description",
    )

    # Ownership filters
    uploaded_by_user_id: Optional[str] = Field(
        None,
        description="Filter by uploader",
    )
    hostel_id: Optional[str] = Field(
        None,
        description="Filter by hostel",
    )
    student_id: Optional[str] = Field(
        None,
        description="Filter by student",
    )

    # File type filters
    content_type: Optional[str] = Field(
        None,
        description="Filter by MIME type",
    )
    content_type_prefix: Optional[str] = Field(
        None,
        description="Filter by MIME type prefix (e.g., 'image/')",
    )
    category: Optional[str] = Field(
        None,
        description="Filter by file category",
    )
    categories: Optional[List[str]] = Field(
        None,
        max_length=20,
        description="Filter by multiple categories",
    )

    # Tags
    tags: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Filter by tags (AND logic)",
    )
    any_tags: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Filter by tags (OR logic)",
    )

    # Size filters
    min_size_bytes: Optional[int] = Field(
        None,
        ge=0,
        description="Minimum file size",
    )
    max_size_bytes: Optional[int] = Field(
        None,
        ge=0,
        description="Maximum file size",
    )

    # Date filters
    uploaded_after: Optional[datetime] = Field(
        None,
        description="Uploaded after this timestamp",
    )
    uploaded_before: Optional[datetime] = Field(
        None,
        description="Uploaded before this timestamp",
    )

    # Access filters
    is_public: Optional[bool] = Field(
        None,
        description="Filter by public/private status",
    )
    is_deleted: Optional[bool] = Field(
        None,
        description="Include deleted files",
    )

    # Security filters
    virus_scan_status: Optional[str] = Field(
        None,
        pattern=r"^(pending|clean|infected|error|skipped)$",
        description="Filter by virus scan status",
    )

    @field_validator("search")
    @classmethod
    def validate_search(cls, v: Optional[str]) -> Optional[str]:
        """Normalize search query."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
        return v

    @field_validator("max_size_bytes")
    @classmethod
    def validate_size_range(cls, v: Optional[int], info) -> Optional[int]:
        """Validate size range is logical."""
        min_size = info.data.get("min_size_bytes")
        if v is not None and min_size is not None:
            if v < min_size:
                raise ValueError(
                    "max_size_bytes must be >= min_size_bytes"
                )
        return v

    @field_validator("uploaded_before")
    @classmethod
    def validate_date_range(cls, v: Optional[datetime], info) -> Optional[datetime]:
        """Validate date range is logical."""
        uploaded_after = info.data.get("uploaded_after")
        if v is not None and uploaded_after is not None:
            if v < uploaded_after:
                raise ValueError(
                    "uploaded_before must be >= uploaded_after"
                )
        return v


class FileSearchRequest(BaseFilterSchema):
    """
    Full-text file search request.
    
    Supports advanced search with field selection and filters.
    """

    query: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Search query string",
    )

    # Search scope
    search_in_filename: bool = Field(
        default=True,
        description="Search in filenames",
    )
    search_in_tags: bool = Field(
        default=True,
        description="Search in tags",
    )
    search_in_metadata: bool = Field(
        default=True,
        description="Search in metadata",
    )
    search_in_ocr_text: bool = Field(
        default=False,
        description="Search in OCR extracted text",
    )

    # Optional filters
    hostel_id: Optional[str] = Field(
        None,
        description="Limit to specific hostel",
    )
    content_type_prefix: Optional[str] = Field(
        None,
        description="Limit to specific file type",
    )

    # Pagination
    page: int = Field(default=1, ge=1, description="Page number")
    page_size: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Results per page",
    )

    @field_validator("query")
    @classmethod
    def validate_query(cls, v: str) -> str:
        """Normalize search query."""
        v = v.strip()
        if not v:
            raise ValueError("Search query cannot be empty")
        return v


class FileSortOptions(BaseFilterSchema):
    """
    File sorting options.
    
    Defines available sort fields and order.
    """

    sort_by: str = Field(
        default="created_at",
        pattern=r"^(created_at|updated_at|filename|size_bytes|access_count)$",
        description="Field to sort by",
    )
    sort_order: str = Field(
        default="desc",
        pattern=r"^(asc|desc)$",
        description="Sort order",
    )

    @field_validator("sort_by", "sort_order")
    @classmethod
    def normalize_sort_params(cls, v: str) -> str:
        """Normalize sort parameters."""
        return v.lower().strip()


class DocumentFilterParams(BaseFilterSchema):
    """
    Document-specific filter parameters.
    
    Extends base file filters with document-specific fields.
    """

    # Document type filters
    document_type: Optional[str] = Field(
        None,
        description="Filter by document type",
    )
    document_types: Optional[List[str]] = Field(
        None,
        max_length=20,
        description="Filter by multiple document types",
    )
    document_subtype: Optional[str] = Field(
        None,
        description="Filter by document subtype",
    )

    # Verification status
    verified: Optional[bool] = Field(
        None,
        description="Filter by verification status",
    )
    verification_status: Optional[str] = Field(
        None,
        pattern=r"^(pending|verified|rejected)$",
        description="Filter by specific verification status",
    )

    # Expiry filters
    is_expired: Optional[bool] = Field(
        None,
        description="Filter expired documents",
    )
    expiring_within_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Filter documents expiring within N days",
    )
    expiry_date_from: Optional[date] = Field(
        None,
        description="Expiry date range start",
    )
    expiry_date_to: Optional[date] = Field(
        None,
        description="Expiry date range end",
    )

    # OCR filters
    ocr_completed: Optional[bool] = Field(
        None,
        description="Filter by OCR completion status",
    )

    # Student/Hostel filters
    student_id: Optional[str] = Field(None)
    hostel_id: Optional[str] = Field(None)


class ImageFilterParams(BaseFilterSchema):
    """
    Image-specific filter parameters.
    
    Extends base file filters with image-specific fields.
    """

    # Image usage filters
    usage: Optional[str] = Field(
        None,
        pattern=r"^(hostel_cover|hostel_gallery|room_photo|avatar|"
        r"profile_photo|document_scan|complaint_attachment|"
        r"announcement_image|other)$",
        description="Filter by image usage",
    )

    # Dimension filters
    min_width: Optional[int] = Field(
        None,
        ge=1,
        description="Minimum width in pixels",
    )
    max_width: Optional[int] = Field(
        None,
        ge=1,
        description="Maximum width in pixels",
    )
    min_height: Optional[int] = Field(
        None,
        ge=1,
        description="Minimum height in pixels",
    )
    max_height: Optional[int] = Field(
        None,
        ge=1,
        description="Maximum height in pixels",
    )

    # Orientation filter
    orientation: Optional[str] = Field(
        None,
        pattern=r"^(landscape|portrait|square)$",
        description="Filter by image orientation",
    )

    # Processing filters
    has_variants: Optional[bool] = Field(
        None,
        description="Filter images with generated variants",
    )
    is_optimized: Optional[bool] = Field(
        None,
        description="Filter optimized images",
    )

    # Format filters
    format: Optional[str] = Field(
        None,
        pattern=r"^(jpeg|png|gif|webp|svg|bmp|tiff)$",
        description="Filter by image format",
    )

    # Hostel filters
    hostel_id: Optional[str] = Field(None)

    @field_validator("max_width")
    @classmethod
    def validate_width_range(cls, v: Optional[int], info) -> Optional[int]:
        """Validate width range."""
        min_width = info.data.get("min_width")
        if v is not None and min_width is not None:
            if v < min_width:
                raise ValueError("max_width must be >= min_width")
        return v

    @field_validator("max_height")
    @classmethod
    def validate_height_range(cls, v: Optional[int], info) -> Optional[int]:
        """Validate height range."""
        min_height = info.data.get("min_height")
        if v is not None and min_height is not None:
            if v < min_height:
                raise ValueError("max_height must be >= min_height")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\file\file_response.py ---
"""
File information and listing schemas.

Provides comprehensive file metadata and listing capabilities
with filtering and pagination support.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, HttpUrl, computed_field, field_validator

from app.schemas.common.base import BaseResponseSchema, BaseSchema

__all__ = [
    "FileMetadata",
    "FileInfo",
    "FileURL",
    "FileListResponse",
    "FileStats",
    "FileAccessLog",
]


class FileMetadata(BaseSchema):
    """
    Comprehensive file metadata.
    
    Stores technical and business metadata for files.
    """

    # Technical metadata
    content_type: str = Field(..., description="MIME type")
    size_bytes: int = Field(..., ge=0, description="File size in bytes")
    checksum: Optional[str] = Field(
        None,
        description="File checksum (MD5/SHA256)",
    )

    # Original file information
    original_filename: Optional[str] = Field(
        None,
        max_length=255,
        description="Original uploaded filename",
    )
    extension: Optional[str] = Field(
        None,
        max_length=20,
        description="File extension (without dot)",
    )

    # Dimensions (for images/videos)
    width: Optional[int] = Field(None, ge=1, description="Width in pixels")
    height: Optional[int] = Field(None, ge=1, description="Height in pixels")
    duration_seconds: Optional[int] = Field(
        None,
        ge=0,
        description="Duration for audio/video files",
    )

    # Classification
    category: Optional[str] = Field(None, description="File category")
    tags: List[str] = Field(default_factory=list, description="Searchable tags")

    # Custom metadata
    custom_metadata: Dict[str, str] = Field(
        default_factory=dict,
        description="Custom key-value metadata",
    )

    # Processing information
    is_processed: bool = Field(
        default=False,
        description="Whether post-upload processing is complete",
    )
    processing_error: Optional[str] = Field(
        None,
        description="Processing error message if failed",
    )

    @computed_field
    @property
    def size_mb(self) -> Decimal:
        """Get file size in megabytes."""
        return Decimal(str(round(self.size_bytes / (1024 * 1024), 2)))

    @computed_field
    @property
    def is_image(self) -> bool:
        """Check if file is an image."""
        return self.content_type.startswith("image/")

    @computed_field
    @property
    def is_video(self) -> bool:
        """Check if file is a video."""
        return self.content_type.startswith("video/")

    @computed_field
    @property
    def is_audio(self) -> bool:
        """Check if file is audio."""
        return self.content_type.startswith("audio/")

    @computed_field
    @property
    def is_document(self) -> bool:
        """Check if file is a document."""
        document_types = [
            "application/pdf",
            "application/msword",
            "application/vnd.openxmlformats-officedocument",
            "application/vnd.ms-excel",
        ]
        return any(self.content_type.startswith(dt) for dt in document_types)


class FileInfo(BaseResponseSchema):
    """
    Complete file information record.
    
    Represents a stored file with all associated metadata.
    """

    file_id: str = Field(..., description="Unique file identifier")
    storage_key: str = Field(..., description="Storage path/key")

    # Ownership
    uploaded_by_user_id: str = Field(..., description="Uploader user ID")
    uploaded_by_name: Optional[str] = Field(None, description="Uploader name")

    hostel_id: Optional[str] = Field(None, description="Associated hostel")
    student_id: Optional[str] = Field(None, description="Associated student")

    # Access control
    is_public: bool = Field(default=False, description="Public access flag")
    is_deleted: bool = Field(default=False, description="Soft delete flag")

    # URLs
    url: HttpUrl = Field(..., description="Primary access URL")
    public_url: Optional[HttpUrl] = Field(
        None,
        description="Public CDN URL (if is_public=True)",
    )
    thumbnail_url: Optional[HttpUrl] = Field(
        None,
        description="Thumbnail URL (for images)",
    )

    # Metadata
    metadata: FileMetadata = Field(..., description="File metadata")

    # Security
    virus_scan_status: str = Field(
        default="pending",
        description="Antivirus scan status",
        examples=["pending", "clean", "infected", "error", "skipped"],
    )
    virus_scan_timestamp: Optional[datetime] = Field(
        None,
        description="Virus scan completion timestamp",
    )

    # Access tracking
    access_count: int = Field(
        default=0,
        ge=0,
        description="Number of times file was accessed",
    )
    last_accessed_at: Optional[datetime] = Field(
        None,
        description="Last access timestamp",
    )

    # Audit timestamps
    created_at: datetime = Field(..., description="Upload timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    deleted_at: Optional[datetime] = Field(None, description="Deletion timestamp")

    @computed_field
    @property
    def age_days(self) -> int:
        """Get file age in days."""
        delta = datetime.utcnow() - self.created_at
        return delta.days

    @computed_field
    @property
    def is_recent(self) -> bool:
        """Check if file was uploaded within last 7 days."""
        return self.age_days <= 7


class FileURL(BaseSchema):
    """
    File access URL with expiration information.
    
    Used for temporary signed URLs.
    """

    url: HttpUrl = Field(..., description="Access URL")
    url_type: str = Field(
        default="signed",
        description="URL type",
        examples=["public", "signed", "cdn"],
    )

    expires_at: Optional[datetime] = Field(
        None,
        description="URL expiration timestamp (for signed URLs)",
    )
    is_permanent: bool = Field(
        default=False,
        description="Whether URL is permanent (public URLs)",
    )

    @computed_field
    @property
    def is_expired(self) -> bool:
        """Check if URL has expired."""
        if self.is_permanent or self.expires_at is None:
            return False
        return datetime.utcnow() >= self.expires_at

    @computed_field
    @property
    def time_until_expiry_minutes(self) -> Optional[int]:
        """Get minutes until URL expires."""
        if self.is_permanent or self.expires_at is None:
            return None
        
        delta = self.expires_at - datetime.utcnow()
        return max(0, int(delta.total_seconds() / 60))


class FileListResponse(BaseSchema):
    """
    Paginated file listing response.
    
    Provides filtered and sorted file listings.
    """

    items: List[FileInfo] = Field(
        default_factory=list,
        description="List of files",
    )

    # Pagination
    total_items: int = Field(ge=0, description="Total matching files")
    page: int = Field(ge=1, description="Current page number")
    page_size: int = Field(ge=1, le=100, description="Items per page")
    total_pages: int = Field(ge=0, description="Total pages")

    # Summary statistics
    total_size_bytes: int = Field(
        default=0,
        ge=0,
        description="Total size of all files in list",
    )

    @computed_field
    @property
    def has_next(self) -> bool:
        """Check if there are more pages."""
        return self.page < self.total_pages

    @computed_field
    @property
    def has_previous(self) -> bool:
        """Check if there are previous pages."""
        return self.page > 1

    @computed_field
    @property
    def total_size_mb(self) -> Decimal:
        """Get total size in megabytes."""
        return Decimal(str(round(self.total_size_bytes / (1024 * 1024), 2)))


class FileStats(BaseSchema):
    """
    File storage statistics.
    
    Provides aggregate statistics for a user, hostel, or system.
    """

    entity_id: Optional[str] = Field(
        None,
        description="Entity ID (user/hostel) or None for system-wide",
    )
    entity_type: str = Field(
        default="system",
        description="Entity type",
        examples=["user", "hostel", "system"],
    )

    # Counts
    total_files: int = Field(ge=0, description="Total file count")
    public_files: int = Field(ge=0, description="Public file count")
    private_files: int = Field(ge=0, description="Private file count")

    # By type
    images_count: int = Field(ge=0, description="Image file count")
    videos_count: int = Field(ge=0, description="Video file count")
    documents_count: int = Field(ge=0, description="Document file count")
    other_count: int = Field(ge=0, description="Other file count")

    # Storage usage
    total_size_bytes: int = Field(ge=0, description="Total storage used (bytes)")
    storage_quota_bytes: Optional[int] = Field(
        None,
        ge=0,
        description="Storage quota (bytes)",
    )

    # Time-based
    files_uploaded_today: int = Field(ge=0, description="Files uploaded today")
    files_uploaded_this_week: int = Field(ge=0, description="Files uploaded this week")
    files_uploaded_this_month: int = Field(ge=0, description="Files uploaded this month")

    @computed_field
    @property
    def total_size_gb(self) -> Decimal:
        """Get total size in gigabytes."""
        return Decimal(str(round(self.total_size_bytes / (1024 ** 3), 2)))

    @computed_field
    @property
    def storage_used_percentage(self) -> Optional[Decimal]:
        """Get storage usage percentage."""
        if self.storage_quota_bytes is None or self.storage_quota_bytes == 0:
            return None
        
        percentage = (self.total_size_bytes / self.storage_quota_bytes) * 100
        return Decimal(str(round(percentage, 2)))

    @computed_field
    @property
    def is_near_quota(self) -> bool:
        """Check if storage is near quota (>80%)."""
        usage = self.storage_used_percentage
        return usage is not None and usage >= 80


class FileAccessLog(BaseSchema):
    """
    File access audit log entry.
    
    Tracks file access for security and analytics.
    """

    log_id: str = Field(..., description="Log entry identifier")
    file_id: str = Field(..., description="Accessed file ID")
    storage_key: str = Field(..., description="File storage key")

    # Access details
    accessed_by_user_id: Optional[str] = Field(
        None,
        description="User who accessed (None for public access)",
    )
    accessed_by_name: Optional[str] = Field(None, description="User name")

    access_type: str = Field(
        ...,
        description="Type of access",
        examples=["download", "view", "preview", "api"],
    )
    access_method: str = Field(
        ...,
        description="Access method",
        examples=["direct_url", "signed_url", "api", "cdn"],
    )

    # Request metadata
    ip_address: Optional[str] = Field(None, description="Client IP address")
    user_agent: Optional[str] = Field(None, description="Client user agent")
    referrer: Optional[str] = Field(None, description="HTTP referrer")

    # Geo-location
    country: Optional[str] = Field(None, description="Country code")
    city: Optional[str] = Field(None, description="City")

    accessed_at: datetime = Field(..., description="Access timestamp")

    # Response
    success: bool = Field(..., description="Whether access was successful")
    error_message: Optional[str] = Field(
        None,
        description="Error message if access failed",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\file\file_upload.py ---
"""
Generic file upload schemas with comprehensive validation.

Handles file upload initialization, completion, and validation
for various storage backends (S3, GCS, Azure Blob, etc.).
"""

from __future__ import annotations

from datetime import datetime, timedelta
from typing import Dict, List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "FileUploadInitRequest",
    "FileUploadInitResponse",
    "FileUploadCompleteRequest",
    "FileUploadCompleteResponse",
    "MultipartUploadInitRequest",
    "MultipartUploadPart",
    "MultipartUploadCompleteRequest",
]


class FileUploadInitRequest(BaseCreateSchema):
    """
    Request to initialize a file upload.
    
    Generates pre-signed URLs or prepares upload session
    for direct-to-storage uploads.
    """

    filename: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Original filename with extension",
    )
    content_type: str = Field(
        ...,
        max_length=255,
        description="MIME type (e.g., 'image/jpeg', 'application/pdf')",
    )
    size_bytes: int = Field(
        ...,
        ge=1,
        le=100 * 1024 * 1024,  # 100 MB default max
        description="File size in bytes (max 100MB)",
    )

    # Logical organization
    folder: Optional[str] = Field(
        None,
        max_length=500,
        description="Logical folder path (e.g., 'hostels/123/documents')",
    )

    # Ownership context
    uploaded_by_user_id: str = Field(
        ...,
        description="User ID initiating the upload",
    )
    hostel_id: Optional[str] = Field(
        None,
        description="Associated hostel ID (if applicable)",
    )
    student_id: Optional[str] = Field(
        None,
        description="Associated student ID (if applicable)",
    )

    # Classification
    category: Optional[str] = Field(
        None,
        max_length=50,
        description="File category for organization",
        examples=["hostel_photo", "document", "avatar", "invoice"],
    )
    tags: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Searchable tags (max 20)",
    )

    # Access control
    is_public: bool = Field(
        default=False,
        description="Whether file should be publicly accessible",
    )

    # Advanced options
    enable_virus_scan: bool = Field(
        default=True,
        description="Enable antivirus scanning on upload",
    )
    auto_optimize: bool = Field(
        default=False,
        description="Auto-optimize file (compression, format conversion)",
    )

    @field_validator("filename")
    @classmethod
    def validate_filename(cls, v: str) -> str:
        """
        Validate and sanitize filename.
        
        Prevents path traversal and dangerous characters.
        """
        v = v.strip()
        if not v:
            raise ValueError("Filename cannot be empty")
        
        # Block dangerous characters
        dangerous_chars = ["<", ">", ":", '"', "|", "?", "*", "/", "\\"]
        if any(char in v for char in dangerous_chars):
            raise ValueError(
                f"Filename contains invalid characters: {dangerous_chars}"
            )
        
        # Block path traversal attempts
        if ".." in v or v.startswith("."):
            raise ValueError("Filename cannot contain '..' or start with '.'")
        
        # Validate extension exists
        if "." not in v:
            raise ValueError("Filename must include an extension")
        
        return v

    @field_validator("content_type")
    @classmethod
    def validate_content_type(cls, v: str) -> str:
        """Validate MIME type format."""
        v = v.lower().strip()
        
        # Basic MIME type validation
        if "/" not in v:
            raise ValueError("Invalid MIME type format (must contain '/')")
        
        parts = v.split("/")
        if len(parts) != 2:
            raise ValueError("Invalid MIME type format")
        
        # Validate main type
        valid_main_types = [
            "image", "video", "audio", "application",
            "text", "multipart", "message",
        ]
        if parts[0] not in valid_main_types:
            raise ValueError(f"Unsupported MIME type category: {parts[0]}")
        
        return v

    @field_validator("folder")
    @classmethod
    def validate_folder(cls, v: Optional[str]) -> Optional[str]:
        """Validate folder path."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            
            # Normalize path separators
            v = v.replace("\\", "/")
            
            # Remove leading/trailing slashes
            v = v.strip("/")
            
            # Block path traversal
            if ".." in v:
                raise ValueError("Folder path cannot contain '..'")
            
            # Block absolute paths
            if v.startswith("/"):
                raise ValueError("Folder path cannot be absolute")
        
        return v

    @field_validator("tags")
    @classmethod
    def validate_tags(cls, v: List[str]) -> List[str]:
        """Validate and normalize tags."""
        if len(v) > 20:
            raise ValueError("Maximum 20 tags allowed")
        
        # Normalize and validate each tag
        normalized_tags = []
        for tag in v:
            tag = tag.strip().lower()
            if tag:
                if len(tag) > 50:
                    raise ValueError("Tag length cannot exceed 50 characters")
                if " " in tag:
                    raise ValueError("Tags cannot contain spaces")
                normalized_tags.append(tag)
        
        # Remove duplicates while preserving order
        seen = set()
        unique_tags = []
        for tag in normalized_tags:
            if tag not in seen:
                seen.add(tag)
                unique_tags.append(tag)
        
        return unique_tags

    @model_validator(mode="after")
    def validate_size_for_type(self) -> "FileUploadInitRequest":
        """
        Validate file size is appropriate for content type.
        
        Different file types have different reasonable size limits.
        """
        size_limits = {
            "image/": 20 * 1024 * 1024,      # 20 MB for images
            "video/": 100 * 1024 * 1024,     # 100 MB for videos
            "audio/": 50 * 1024 * 1024,      # 50 MB for audio
            "application/pdf": 25 * 1024 * 1024,  # 25 MB for PDFs
            "text/": 10 * 1024 * 1024,       # 10 MB for text
        }
        
        for prefix, limit in size_limits.items():
            if self.content_type.startswith(prefix):
                if self.size_bytes > limit:
                    raise ValueError(
                        f"File size ({self.size_bytes / (1024*1024):.2f} MB) "
                        f"exceeds limit for {prefix} files "
                        f"({limit / (1024*1024):.0f} MB)"
                    )
                break
        
        return self


class FileUploadInitResponse(BaseResponseSchema):
    """
    Response for file upload initialization.
    
    Provides pre-signed URL and upload instructions.
    """

    upload_id: str = Field(
        ...,
        description="Unique upload session identifier",
    )
    storage_key: str = Field(
        ...,
        description="Storage path/key for the file",
    )

    # Direct upload information
    upload_url: Optional[HttpUrl] = Field(
        None,
        description="Pre-signed URL for direct upload to storage",
    )
    upload_method: str = Field(
        default="PUT",
        pattern=r"^(PUT|POST)$",
        description="HTTP method for upload (PUT or POST)",
    )
    upload_headers: Dict[str, str] = Field(
        default_factory=dict,
        description="Required headers for upload request",
    )

    # File information
    filename: str = Field(..., description="Original filename")
    content_type: str = Field(..., description="MIME type")
    size_bytes: int = Field(..., description="Expected file size")

    # Access information
    is_public: bool = Field(..., description="Public access flag")
    public_url: Optional[HttpUrl] = Field(
        None,
        description="Public URL (if is_public=True)",
    )

    # Upload constraints
    expires_at: datetime = Field(
        ...,
        description="Upload URL expiration timestamp",
    )
    max_file_size: int = Field(
        ...,
        description="Maximum allowed file size for this upload",
    )

    # Processing hints
    will_scan_virus: bool = Field(
        default=True,
        description="Whether file will be scanned for viruses",
    )
    will_optimize: bool = Field(
        default=False,
        description="Whether file will be auto-optimized",
    )


class FileUploadCompleteRequest(BaseCreateSchema):
    """
    Notify backend that upload is complete.
    
    Triggers post-upload processing and validation.
    """

    upload_id: str = Field(
        ...,
        description="Upload session ID from init response",
    )
    storage_key: str = Field(
        ...,
        description="Storage key from init response",
    )

    uploaded_by_user_id: str = Field(
        ...,
        description="User who completed the upload",
    )

    # Verification
    checksum: Optional[str] = Field(
        None,
        max_length=128,
        description="File checksum (MD5/SHA256) for integrity verification",
    )
    etag: Optional[str] = Field(
        None,
        max_length=128,
        description="ETag from storage provider",
    )

    # Optional metadata
    actual_size_bytes: Optional[int] = Field(
        None,
        ge=1,
        description="Actual uploaded file size (for verification)",
    )

    @field_validator("checksum", "etag")
    @classmethod
    def validate_hash(cls, v: Optional[str]) -> Optional[str]:
        """Validate checksum/etag format."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Basic hex validation
            if not all(c in "0123456789abcdefABCDEF" for c in v):
                raise ValueError("Checksum must be hexadecimal")
        return v


class FileUploadCompleteResponse(BaseSchema):
    """
    Response after successful upload completion.
    
    Provides file access information and processing status.
    """

    file_id: str = Field(..., description="Unique file identifier")
    storage_key: str = Field(..., description="Storage path/key")

    # Access URLs
    url: HttpUrl = Field(..., description="File access URL")
    public_url: Optional[HttpUrl] = Field(
        None,
        description="Public CDN URL (if applicable)",
    )

    # File metadata
    filename: str = Field(..., description="Original filename")
    content_type: str = Field(..., description="MIME type")
    size_bytes: int = Field(..., description="Actual file size")

    # Processing status
    processing_status: str = Field(
        default="completed",
        description="Post-upload processing status",
        examples=["completed", "processing", "scanning", "optimizing"],
    )
    virus_scan_status: str = Field(
        default="pending",
        description="Virus scan status",
        examples=["pending", "clean", "infected", "error"],
    )

    uploaded_at: datetime = Field(..., description="Upload completion timestamp")

    message: str = Field(
        default="File uploaded successfully",
        description="Success message",
    )


class MultipartUploadInitRequest(BaseCreateSchema):
    """
    Initialize multipart upload for large files.
    
    Enables chunked uploads for files over a certain size threshold.
    """

    filename: str = Field(..., min_length=1, max_length=255)
    content_type: str = Field(..., max_length=255)
    total_size_bytes: int = Field(
        ...,
        ge=5 * 1024 * 1024,  # Minimum 5 MB for multipart
        le=5 * 1024 * 1024 * 1024,  # Maximum 5 GB
        description="Total file size (5 MB - 5 GB)",
    )

    # Chunk configuration
    part_size_bytes: int = Field(
        default=5 * 1024 * 1024,
        ge=5 * 1024 * 1024,
        le=100 * 1024 * 1024,
        description="Size of each part (5 MB - 100 MB)",
    )

    uploaded_by_user_id: str = Field(...)
    hostel_id: Optional[str] = Field(None)

    category: Optional[str] = Field(None, max_length=50)
    is_public: bool = Field(default=False)

    @field_validator("filename")
    @classmethod
    def validate_filename(cls, v: str) -> str:
        """Validate filename (same as regular upload)."""
        v = v.strip()
        if not v:
            raise ValueError("Filename cannot be empty")
        
        dangerous_chars = ["<", ">", ":", '"', "|", "?", "*", "/", "\\"]
        if any(char in v for char in dangerous_chars):
            raise ValueError(f"Filename contains invalid characters")
        
        if ".." in v or v.startswith("."):
            raise ValueError("Invalid filename pattern")
        
        return v


class MultipartUploadPart(BaseSchema):
    """
    Pre-signed URL for a single multipart upload part.
    
    Each part can be uploaded independently.
    """

    part_number: int = Field(
        ...,
        ge=1,
        le=10000,
        description="Part number (1-10000)",
    )
    upload_url: HttpUrl = Field(..., description="Pre-signed URL for this part")
    size_bytes: int = Field(..., ge=1, description="Expected size for this part")

    expires_at: datetime = Field(..., description="URL expiration timestamp")


class MultipartUploadCompleteRequest(BaseCreateSchema):
    """
    Complete multipart upload after all parts uploaded.
    
    Combines all parts into final file.
    """

    upload_id: str = Field(..., description="Multipart upload session ID")
    storage_key: str = Field(..., description="Storage key")

    uploaded_by_user_id: str = Field(...)

    # Part verification
    parts: List[Dict[str, str]] = Field(
        ...,
        min_length=1,
        description="List of uploaded parts with ETags",
    )

    @field_validator("parts")
    @classmethod
    def validate_parts(cls, v: List[Dict[str, str]]) -> List[Dict[str, str]]:
        """Validate parts list contains required fields."""
        for i, part in enumerate(v, 1):
            if "part_number" not in part or "etag" not in part:
                raise ValueError(
                    f"Part {i} missing required fields (part_number, etag)"
                )
            
            try:
                part_num = int(part["part_number"])
                if part_num < 1:
                    raise ValueError(f"Invalid part_number: {part_num}")
            except (ValueError, TypeError):
                raise ValueError(f"Invalid part_number in part {i}")
        
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\file\image_upload.py ---
"""
Image-specific upload schemas with advanced processing.

Handles image uploads with variant generation, optimization,
and format conversion capabilities.
"""

from __future__ import annotations

from typing import List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator,computed_field

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema
from app.schemas.file.file_upload import FileUploadInitResponse

__all__ = [
    "ImageUploadInitRequest",
    "ImageUploadInitResponse",
    "ImageVariant",
    "ImageProcessingResult",
    "ImageProcessingOptions",
    "ImageMetadata",
]


class ImageUploadInitRequest(BaseCreateSchema):
    """
    Initialize image upload with processing options.
    
    Supports various image types and automatic processing.
    """

    filename: str = Field(..., min_length=1, max_length=255)
    content_type: str = Field(
        ...,
        pattern=r"^image\/(jpeg|jpg|png|gif|webp|svg\+xml|bmp|tiff)$",
        description="Image MIME type (jpeg, png, gif, webp, svg, bmp, tiff)",
    )
    size_bytes: int = Field(
        ...,
        ge=1,
        le=20 * 1024 * 1024,
        description="Image size (max 20 MB)",
    )

    uploaded_by_user_id: str = Field(...)
    hostel_id: Optional[str] = Field(None)
    student_id: Optional[str] = Field(None)

    # Image context
    usage: str = Field(
        ...,
        pattern=r"^(hostel_cover|hostel_gallery|room_photo|avatar|profile_photo|"
        r"document_scan|complaint_attachment|announcement_image|other)$",
        description="Intended usage of the image",
    )

    # Processing options
    generate_variants: bool = Field(
        default=True,
        description="Generate resized variants (thumbnail, medium, large)",
    )
    auto_optimize: bool = Field(
        default=True,
        description="Optimize image (compression, format conversion)",
    )
    convert_to_webp: bool = Field(
        default=False,
        description="Convert to WebP format for better compression",
    )

    # Quality settings
    quality: int = Field(
        default=85,
        ge=1,
        le=100,
        description="Image quality for compression (1-100)",
    )

    # Watermark
    add_watermark: bool = Field(
        default=False,
        description="Add watermark to image",
    )

    @field_validator("filename")
    @classmethod
    def validate_image_filename(cls, v: str) -> str:
        """Validate image filename has valid extension."""
        v = v.strip()
        if not v:
            raise ValueError("Filename cannot be empty")
        
        valid_extensions = [
            ".jpg", ".jpeg", ".png", ".gif",
            ".webp", ".svg", ".bmp", ".tiff"
        ]
        
        if not any(v.lower().endswith(ext) for ext in valid_extensions):
            raise ValueError(
                f"Invalid image extension. Allowed: {', '.join(valid_extensions)}"
            )
        
        return v

    @model_validator(mode="after")
    def validate_svg_restrictions(self) -> "ImageUploadInitRequest":
        """Apply special restrictions for SVG files."""
        if self.content_type == "image/svg+xml":
            # SVG files shouldn't generate variants
            if self.generate_variants:
                raise ValueError(
                    "Variant generation not supported for SVG files"
                )
            
            # No optimization for SVG
            if self.auto_optimize:
                raise ValueError(
                    "Auto-optimization not supported for SVG files"
                )
        
        return self


class ImageVariant(BaseSchema):
    """
    Generated image variant information.
    
    Represents a resized/optimized version of the original image.
    """

    variant_name: str = Field(
        ...,
        description="Variant identifier",
        examples=["thumbnail", "small", "medium", "large", "original"],
    )
    url: HttpUrl = Field(..., description="Variant URL")

    # Dimensions
    width: int = Field(ge=1, description="Width in pixels")
    height: int = Field(ge=1, description="Height in pixels")

    # File information
    size_bytes: int = Field(ge=0, description="Variant file size")
    format: str = Field(..., description="Image format", examples=["jpeg", "png", "webp"])

    # Processing
    is_optimized: bool = Field(
        default=False,
        description="Whether variant was optimized",
    )
    quality: Optional[int] = Field(
        None,
        ge=1,
        le=100,
        description="Quality setting used",
    )

    @computed_field
    @property
    def aspect_ratio(self) -> str:
        """Get aspect ratio as string."""
        from math import gcd
        divisor = gcd(self.width, self.height)
        return f"{self.width // divisor}:{self.height // divisor}"

    @computed_field
    @property
    def megapixels(self) -> float:
        """Get image size in megapixels."""
        return round((self.width * self.height) / 1_000_000, 2)


class ImageUploadInitResponse(FileUploadInitResponse):
    """
    Image-specific upload initialization response.
    
    Extends base upload response with image processing information.
    """

    # Variant planning
    variants_planned: List[str] = Field(
        default_factory=lambda: ["thumbnail", "medium", "large"],
        description="Variants that will be generated after upload",
    )

    # Processing flags
    will_optimize: bool = Field(
        default=True,
        description="Whether image will be optimized",
    )
    will_convert_format: bool = Field(
        default=False,
        description="Whether format conversion will occur",
    )
    target_format: Optional[str] = Field(
        None,
        description="Target format if converting",
        examples=["webp", "jpeg"],
    )


class ImageProcessingResult(BaseSchema):
    """
    Result of post-upload image processing.
    
    Provides information about all generated variants.
    """

    file_id: str = Field(..., description="File identifier")
    storage_key: str = Field(..., description="Original storage key")

    # Original image
    original_url: HttpUrl = Field(..., description="Original image URL")
    original_width: int = Field(ge=1, description="Original width")
    original_height: int = Field(ge=1, description="Original height")
    original_size_bytes: int = Field(ge=0, description="Original file size")

    # Generated variants
    variants: List[ImageVariant] = Field(
        default_factory=list,
        description="List of generated variants",
    )

    # Processing details
    processing_status: str = Field(
        default="completed",
        description="Processing status",
        examples=["completed", "failed", "partial"],
    )
    processing_time_seconds: Optional[float] = Field(
        None,
        ge=0,
        description="Time taken to process",
    )
    processing_error: Optional[str] = Field(
        None,
        description="Error message if processing failed",
    )

    # Optimization results
    was_optimized: bool = Field(
        default=False,
        description="Whether optimization was applied",
    )
    size_reduction_percentage: Optional[float] = Field(
        None,
        ge=0,
        le=100,
        description="Percentage of size reduction from optimization",
    )

    @computed_field
    @property
    def total_variants(self) -> int:
        """Get total number of variants generated."""
        return len(self.variants)

    @computed_field
    @property
    def total_storage_bytes(self) -> int:
        """Get total storage used by all variants."""
        return self.original_size_bytes + sum(
            v.size_bytes for v in self.variants
        )


class ImageProcessingOptions(BaseSchema):
    """
    Advanced image processing configuration.
    
    Defines processing rules and variant specifications.
    """

    # Variant sizes
    thumbnail_max_size: int = Field(
        default=150,
        ge=50,
        le=500,
        description="Maximum dimension for thumbnail (pixels)",
    )
    small_max_size: int = Field(
        default=320,
        ge=200,
        le=640,
        description="Maximum dimension for small variant",
    )
    medium_max_size: int = Field(
        default=640,
        ge=400,
        le=1024,
        description="Maximum dimension for medium variant",
    )
    large_max_size: int = Field(
        default=1280,
        ge=800,
        le=2048,
        description="Maximum dimension for large variant",
    )

    # Quality settings
    thumbnail_quality: int = Field(default=70, ge=50, le=100)
    small_quality: int = Field(default=75, ge=50, le=100)
    medium_quality: int = Field(default=80, ge=50, le=100)
    large_quality: int = Field(default=85, ge=50, le=100)

    # Format preferences
    preferred_format: str = Field(
        default="original",
        pattern=r"^(original|jpeg|png|webp)$",
        description="Preferred output format",
    )

    # Processing flags
    preserve_exif: bool = Field(
        default=False,
        description="Preserve EXIF metadata",
    )
    strip_metadata: bool = Field(
        default=True,
        description="Strip all metadata for privacy",
    )
    auto_orient: bool = Field(
        default=True,
        description="Auto-rotate based on EXIF orientation",
    )

    # Watermark
    watermark_enabled: bool = Field(default=False)
    watermark_text: Optional[str] = Field(None, max_length=50)
    watermark_position: str = Field(
        default="bottom-right",
        pattern=r"^(top-left|top-right|bottom-left|bottom-right|center)$",
    )
    watermark_opacity: int = Field(default=50, ge=0, le=100)


class ImageMetadata(BaseSchema):
    """
    Extended image metadata.
    
    Stores comprehensive image information including EXIF data.
    """

    # Basic properties
    width: int = Field(ge=1, description="Width in pixels")
    height: int = Field(ge=1, description="Height in pixels")
    format: str = Field(..., description="Image format")
    mode: Optional[str] = Field(
        None,
        description="Color mode (RGB, RGBA, L, etc.)",
    )

    # Color information
    has_alpha: bool = Field(
        default=False,
        description="Whether image has alpha channel",
    )
    color_space: Optional[str] = Field(
        None,
        description="Color space (sRGB, Adobe RGB, etc.)",
    )

    # EXIF data (if preserved)
    camera_make: Optional[str] = Field(None, description="Camera manufacturer")
    camera_model: Optional[str] = Field(None, description="Camera model")
    date_taken: Optional[str] = Field(None, description="Date photo was taken")
    gps_latitude: Optional[float] = Field(None, description="GPS latitude")
    gps_longitude: Optional[float] = Field(None, description="GPS longitude")

    # Computed properties
    @computed_field
    @property
    def aspect_ratio(self) -> str:
        """Get aspect ratio."""
        from math import gcd
        divisor = gcd(self.width, self.height)
        return f"{self.width // divisor}:{self.height // divisor}"

    @computed_field
    @property
    def megapixels(self) -> float:
        """Get megapixels."""
        return round((self.width * self.height) / 1_000_000, 2)

    @computed_field
    @property
    def orientation(self) -> str:
        """Get image orientation."""
        if self.width > self.height:
            return "landscape"
        elif self.height > self.width:
            return "portrait"
        else:
            return "square"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\file\__init__.py ---
"""
File management schemas package.

Comprehensive file upload, management, and processing schemas
for images, documents, and generic files.

Example:
    from app.schemas.file import FileUploadInitRequest, DocumentInfo
"""

from __future__ import annotations

from app.schemas.file.document_upload import (
    DocumentExpiryAlert,
    DocumentInfo,
    DocumentList,
    DocumentOCRResult,
    DocumentUploadInitRequest,
    DocumentUploadInitResponse,
    DocumentValidationResult,
    DocumentVerificationRequest,
    DocumentVerificationResponse,
)
from app.schemas.file.file_filters import (
    DocumentFilterParams,
    FileFilterParams,
    FileSearchRequest,
    FileSortOptions,
    ImageFilterParams,
)
from app.schemas.file.file_response import (
    FileAccessLog,
    FileInfo,
    FileListResponse,
    FileMetadata,
    FileStats,
    FileURL,
)
from app.schemas.file.file_upload import (
    FileUploadCompleteRequest,
    FileUploadCompleteResponse,
    FileUploadInitRequest,
    FileUploadInitResponse,
    MultipartUploadCompleteRequest,
    MultipartUploadInitRequest,
    MultipartUploadPart,
)
from app.schemas.file.image_upload import (
    ImageMetadata,
    ImageProcessingOptions,
    ImageProcessingResult,
    ImageUploadInitRequest,
    ImageUploadInitResponse,
    ImageVariant,
)

__all__ = [
    # Generic file upload
    "FileUploadInitRequest",
    "FileUploadInitResponse",
    "FileUploadCompleteRequest",
    "FileUploadCompleteResponse",
    "MultipartUploadInitRequest",
    "MultipartUploadPart",
    "MultipartUploadCompleteRequest",
    # File response/info
    "FileInfo",
    "FileMetadata",
    "FileURL",
    "FileListResponse",
    "FileStats",
    "FileAccessLog",
    # File filters
    "FileFilterParams",
    "FileSearchRequest",
    "FileSortOptions",
    "DocumentFilterParams",
    "ImageFilterParams",
    # Image upload
    "ImageUploadInitRequest",
    "ImageUploadInitResponse",
    "ImageVariant",
    "ImageProcessingResult",
    "ImageProcessingOptions",
    "ImageMetadata",
    # Document upload
    "DocumentUploadInitRequest",
    "DocumentUploadInitResponse",
    "DocumentValidationResult",
    "DocumentInfo",
    "DocumentList",
    "DocumentVerificationRequest",
    "DocumentVerificationResponse",
    "DocumentOCRResult",
    "DocumentExpiryAlert",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\file\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_admin.py ---
# --- File: app/schemas/hostel/hostel_admin.py ---
"""
Hostel admin view schemas with enhanced configuration options.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Optional

from pydantic import Field, field_validator

from app.schemas.common.base import BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import HostelStatus, SubscriptionPlan, SubscriptionStatus

__all__ = [
    "HostelAdminView",
    "HostelSettings",
    "HostelVisibilityUpdate",
    "HostelCapacityUpdate",
    "HostelStatusUpdate",
]


class HostelAdminView(BaseSchema):
    """
    Comprehensive hostel view for administrators.
    
    Provides complete hostel information with statistics and metrics.
    """

    id: str = Field(..., description="Hostel ID")
    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")

    # Status
    status: HostelStatus = Field(..., description="Operational status")
    is_active: bool = Field(..., description="Active status")
    is_public: bool = Field(..., description="Public listing visibility")
    is_featured: bool = Field(..., description="Featured in listings")
    is_verified: bool = Field(..., description="Verification status")

    # Capacity stats
    total_rooms: int = Field(..., ge=0, description="Total number of rooms")
    total_beds: int = Field(..., ge=0, description="Total number of beds")
    occupied_beds: int = Field(..., ge=0, description="Currently occupied beds")
    available_beds: int = Field(..., ge=0, description="Available beds")
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Current occupancy percentage",
    )

    # Students
    total_students: int = Field(
        ...,
        ge=0,
        description="Total registered students",
    )
    active_students: int = Field(
        ...,
        ge=0,
        description="Currently active students",
    )

    # Financial
    total_revenue_this_month: Decimal = Field(
        ...,
        ge=0,
        description="Total revenue for current month",
    )
    outstanding_payments: Decimal = Field(
        ...,
        ge=0,
        description="Total outstanding payment amount",
    )

    # Pending items
    pending_bookings: int = Field(
        ...,
        ge=0,
        description="Number of pending booking requests",
    )
    pending_complaints: int = Field(
        ...,
        ge=0,
        description="Number of open/pending complaints",
    )
    pending_maintenance: int = Field(
        ...,
        ge=0,
        description="Number of pending maintenance requests",
    )

    # Subscription
    subscription_plan: Optional[SubscriptionPlan] = Field(
        default=None,
        description="Current subscription plan",
    )
    subscription_status: Optional[SubscriptionStatus] = Field(
        default=None,
        description="Subscription status",
    )
    subscription_expires_at: Optional[datetime] = Field(
        default=None,
        description="Subscription expiration date",
    )

    # Performance
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating from reviews",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )


class HostelSettings(BaseUpdateSchema):
    """
    Hostel configuration settings.
    
    Manages hostel operational and behavioral settings.
    """

    # Visibility
    is_public: Optional[bool] = Field(
        default=None,
        description="Make hostel visible in public listings",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Hostel operational status",
    )

    # Booking settings
    auto_approve_bookings: bool = Field(
        default=False,
        description="Automatically approve booking requests",
    )
    booking_advance_percentage: Decimal = Field(
        default=Decimal("20.00"),
        ge=0,
        le=100,
        description="Required advance payment percentage",
    )
    max_booking_duration_months: int = Field(
        default=12,
        ge=1,
        le=24,
        description="Maximum booking duration in months",
    )
    min_booking_duration_days: int = Field(
        default=30,
        ge=1,
        le=365,
        description="Minimum booking duration in days",
    )

    # Payment settings
    payment_due_day: int = Field(
        default=5,
        ge=1,
        le=28,
        description="Monthly payment due date",
    )
    late_payment_grace_days: int = Field(
        default=3,
        ge=0,
        le=10,
        description="Grace period for late payments (days)",
    )
    late_payment_penalty_percentage: Decimal = Field(
        default=Decimal("5.00"),
        ge=0,
        le=50,
        description="Late payment penalty percentage",
    )

    # Attendance settings
    enable_attendance_tracking: bool = Field(
        default=True,
        description="Enable attendance tracking system",
    )
    minimum_attendance_percentage: Decimal = Field(
        default=Decimal("75.00"),
        ge=0,
        le=100,
        description="Minimum required attendance percentage",
    )
    attendance_grace_period_days: int = Field(
        default=7,
        ge=0,
        le=30,
        description="Attendance tracking grace period for new students",
    )

    # Notification settings
    notify_on_booking: bool = Field(
        default=True,
        description="Send notifications for new bookings",
    )
    notify_on_complaint: bool = Field(
        default=True,
        description="Send notifications for new complaints",
    )
    notify_on_payment: bool = Field(
        default=True,
        description="Send notifications for payments",
    )
    notify_on_maintenance: bool = Field(
        default=True,
        description="Send notifications for maintenance requests",
    )

    # Mess settings
    mess_included: bool = Field(
        default=False,
        description="Mess facility included in rent",
    )
    mess_charges_monthly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Monthly mess charges (if separate)",
    )
    mess_advance_booking_days: int = Field(
        default=1,
        ge=0,
        le=7,
        description="Days in advance for mess meal booking",
    )

    # Security settings
    visitor_entry_time_start: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Visitor entry allowed from (HH:MM)",
    )
    visitor_entry_time_end: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Visitor entry allowed until (HH:MM)",
    )
    late_entry_time: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Late entry cutoff time (HH:MM)",
    )


class HostelVisibilityUpdate(BaseUpdateSchema):
    """
    Update hostel visibility settings.
    
    Controls hostel appearance in public listings and searches.
    """

    is_public: bool = Field(
        ...,
        description="Make hostel publicly visible",
    )
    is_featured: bool = Field(
        default=False,
        description="Feature hostel in search results",
    )
    is_verified: bool = Field(
        default=False,
        description="Mark hostel as verified (admin only)",
    )


class HostelCapacityUpdate(BaseUpdateSchema):
    """
    Update hostel capacity information.
    
    Admin-only operation to modify hostel capacity.
    """

    total_rooms: int = Field(
        ...,
        ge=1,
        description="Total number of rooms",
    )
    total_beds: int = Field(
        ...,
        ge=1,
        description="Total number of beds",
    )

    @field_validator("total_beds")
    @classmethod
    def validate_beds_vs_rooms(cls, v: int, info) -> int:
        """Validate that total beds is reasonable compared to rooms."""
        total_rooms = info.data.get("total_rooms")
        if total_rooms is not None and v < total_rooms:
            raise ValueError(
                "Total beds cannot be less than total rooms"
            )
        if total_rooms is not None and v > (total_rooms * 8):
            raise ValueError(
                "Total beds seems unreasonably high compared to rooms"
            )
        return v


class HostelStatusUpdate(BaseUpdateSchema):
    """
    Update hostel operational status.
    
    Tracks status changes with reason.
    """

    status: HostelStatus = Field(
        ...,
        description="New hostel status",
    )
    is_active: bool = Field(
        ...,
        description="Active status",
    )
    reason: Optional[str] = Field(
        default=None,
        min_length=10,
        max_length=500,
        description="Reason for status change",
    )
    effective_date: Optional[datetime] = Field(
        default=None,
        description="Effective date of status change",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason_required(cls, v: Optional[str], info) -> Optional[str]:
        """Require reason for certain status changes."""
        status = info.data.get("status")
        is_active = info.data.get("is_active")
        
        # Require reason if deactivating or setting to maintenance/closed
        if (
            is_active is False
            or status in [HostelStatus.UNDER_MAINTENANCE, HostelStatus.CLOSED]
        ) and not v:
            raise ValueError(
                "Reason is required when deactivating or changing to "
                "maintenance/closed status"
            )
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_analytics.py ---
# --- File: app/schemas/hostel/hostel_analytics.py ---
"""
Hostel analytics and reporting schemas with comprehensive metrics.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "HostelAnalytics",
    "OccupancyAnalytics",
    "OccupancyDataPoint",
    "RevenueAnalytics",
    "RevenueDataPoint",
    "BookingAnalytics",
    "BookingDataPoint",
    "ComplaintAnalytics",
    "ReviewAnalytics",
    "RatingDataPoint",
    "HostelOccupancyStats",
    "RoomTypeOccupancy",
    "HostelRevenueStats",
    "MonthlyRevenue",
    "AnalyticsRequest",
]


class OccupancyDataPoint(BaseSchema):
    """
    Single occupancy data point for trends.
    
    Represents occupancy at a specific point in time.
    """

    date: date = Field(..., description="Date of the data point")
    occupancy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Occupancy rate percentage",
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Number of occupied beds",
    )
    total_beds: int = Field(
        ...,
        ge=1,
        description="Total available beds",
    )


class OccupancyAnalytics(BaseSchema):
    """
    Comprehensive occupancy analytics.
    
    Provides detailed occupancy metrics and trends.
    """

    current_occupancy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Current occupancy percentage",
    )
    average_occupancy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Average occupancy for the period",
    )
    peak_occupancy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Peak occupancy during period",
    )
    lowest_occupancy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Lowest occupancy during period",
    )

    total_beds: int = Field(
        ...,
        ge=0,
        description="Total bed capacity",
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Currently occupied beds",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Currently available beds",
    )

    # Trends
    occupancy_trend: List[OccupancyDataPoint] = Field(
        default_factory=list,
        description="Historical occupancy trend",
    )

    # Predictions
    predicted_occupancy_next_month: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=100,
        description="Predicted occupancy for next month",
    )
    trend_direction: str = Field(
        ...,
        pattern=r"^(increasing|decreasing|stable)$",
        description="Overall occupancy trend direction",
    )


class RevenueDataPoint(BaseSchema):
    """
    Single revenue data point.
    
    Represents revenue metrics at a specific point in time.
    """

    date: date = Field(..., description="Date of the data point")
    revenue: Decimal = Field(
        ...,
        ge=0,
        description="Total revenue",
    )
    collected: Decimal = Field(
        ...,
        ge=0,
        description="Amount collected",
    )
    pending: Decimal = Field(
        ...,
        ge=0,
        description="Amount pending",
    )


class RevenueAnalytics(BaseSchema):
    """
    Comprehensive revenue analytics.
    
    Provides detailed financial metrics and trends.
    """

    total_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Total revenue for period",
    )
    rent_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Revenue from rent",
    )
    mess_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Revenue from mess charges",
    )
    other_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Revenue from other sources",
    )

    total_collected: Decimal = Field(
        ...,
        ge=0,
        description="Total amount collected",
    )
    total_pending: Decimal = Field(
        ...,
        ge=0,
        description="Total amount pending",
    )
    total_overdue: Decimal = Field(
        ...,
        ge=0,
        description="Total overdue amount",
    )

    collection_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Payment collection rate percentage",
    )

    # Trends
    revenue_trend: List[RevenueDataPoint] = Field(
        default_factory=list,
        description="Historical revenue trend",
    )

    # Comparisons
    revenue_vs_last_period: Decimal = Field(
        ...,
        description="Percentage change from last period",
    )
    revenue_vs_last_year: Optional[Decimal] = Field(
        default=None,
        description="Year-over-year percentage change",
    )

    # Additional metrics
    average_revenue_per_bed: Decimal = Field(
        ...,
        ge=0,
        description="Average revenue per occupied bed",
    )


class BookingDataPoint(BaseSchema):
    """
    Single booking data point.
    
    Represents booking metrics at a specific point in time.
    """

    date: date = Field(..., description="Date of the data point")
    total_bookings: int = Field(
        ...,
        ge=0,
        description="Total bookings",
    )
    approved: int = Field(
        ...,
        ge=0,
        description="Approved bookings",
    )
    rejected: int = Field(
        ...,
        ge=0,
        description="Rejected bookings",
    )


class BookingAnalytics(BaseSchema):
    """
    Comprehensive booking analytics.
    
    Provides detailed booking metrics and conversion rates.
    """

    total_bookings: int = Field(
        ...,
        ge=0,
        description="Total booking requests",
    )
    approved_bookings: int = Field(
        ...,
        ge=0,
        description="Approved bookings",
    )
    pending_bookings: int = Field(
        ...,
        ge=0,
        description="Pending bookings",
    )
    rejected_bookings: int = Field(
        ...,
        ge=0,
        description="Rejected bookings",
    )
    cancelled_bookings: int = Field(
        ...,
        ge=0,
        description="Cancelled bookings",
    )

    conversion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Booking approval rate percentage",
    )
    cancellation_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Cancellation rate percentage",
    )

    # Sources
    booking_sources: Dict[str, int] = Field(
        default_factory=dict,
        description="Bookings by source (website, app, etc.)",
    )

    # Trends
    booking_trend: List[BookingDataPoint] = Field(
        default_factory=list,
        description="Historical booking trend",
    )

    # Average metrics
    average_booking_value: Decimal = Field(
        ...,
        ge=0,
        description="Average booking value",
    )


class ComplaintAnalytics(BaseSchema):
    """
    Comprehensive complaint analytics.
    
    Provides detailed complaint metrics and resolution statistics.
    """

    total_complaints: int = Field(
        ...,
        ge=0,
        description="Total complaints",
    )
    open_complaints: int = Field(
        ...,
        ge=0,
        description="Currently open complaints",
    )
    resolved_complaints: int = Field(
        ...,
        ge=0,
        description="Resolved complaints",
    )
    closed_complaints: int = Field(
        ...,
        ge=0,
        description="Closed complaints",
    )

    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average time to resolve (hours)",
    )
    resolution_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of resolved complaints",
    )

    # By category
    complaints_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaints grouped by category",
    )

    # By priority
    complaints_by_priority: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaints grouped by priority",
    )

    # SLA compliance
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage meeting SLA",
    )
    sla_breaches: int = Field(
        ...,
        ge=0,
        description="Number of SLA breaches",
    )


class RatingDataPoint(BaseSchema):
    """
    Single rating data point.
    
    Represents rating metrics for a period.
    """

    month: str = Field(
        ...,
        pattern=r"^\d{4}-\d{2}$",
        description="Month in YYYY-MM format",
    )
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    review_count: int = Field(
        ...,
        ge=0,
        description="Number of reviews",
    )


class ReviewAnalytics(BaseSchema):
    """
    Comprehensive review analytics.
    
    Provides detailed review and rating statistics.
    """

    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Overall average rating",
    )

    # Rating distribution
    rating_distribution: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of ratings by star (1-5)",
    )

    # Detailed aspect ratings
    average_cleanliness_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average cleanliness rating",
    )
    average_food_quality_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average food quality rating",
    )
    average_staff_behavior_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average staff behavior rating",
    )
    average_security_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average security rating",
    )
    average_value_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average value for money rating",
    )

    # Trends
    rating_trend: List[RatingDataPoint] = Field(
        default_factory=list,
        description="Historical rating trend",
    )

    # Sentiment
    positive_reviews: int = Field(
        ...,
        ge=0,
        description="Number of positive reviews (4-5 stars)",
    )
    negative_reviews: int = Field(
        ...,
        ge=0,
        description="Number of negative reviews (1-2 stars)",
    )
    sentiment_score: Decimal = Field(
        ...,
        ge=-1,
        le=1,
        description="Overall sentiment score (-1 to 1)",
    )


class HostelAnalytics(BaseSchema):
    """
    Comprehensive hostel analytics dashboard.
    
    Aggregates all analytics for a hostel over a period.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    period_start: date = Field(..., description="Analytics period start")
    period_end: date = Field(..., description="Analytics period end")

    occupancy: OccupancyAnalytics = Field(
        ...,
        description="Occupancy analytics",
    )
    revenue: RevenueAnalytics = Field(
        ...,
        description="Revenue analytics",
    )
    bookings: BookingAnalytics = Field(
        ...,
        description="Booking analytics",
    )
    complaints: ComplaintAnalytics = Field(
        ...,
        description="Complaint analytics",
    )
    reviews: ReviewAnalytics = Field(
        ...,
        description="Review analytics",
    )

    generated_at: datetime = Field(
        ...,
        description="Analytics generation timestamp",
    )


class RoomTypeOccupancy(BaseSchema):
    """
    Occupancy statistics by room type.
    
    Provides occupancy breakdown for different room types.
    """

    room_type: str = Field(
        ...,
        description="Room type (single, double, etc.)",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds of this type",
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Occupied beds of this type",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds of this type",
    )
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Occupancy percentage for this type",
    )


class HostelOccupancyStats(BaseSchema):
    """
    Detailed occupancy statistics with breakdowns and projections.
    
    Provides comprehensive occupancy analysis.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")

    # Current status
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total number of rooms",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total number of beds",
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Currently occupied beds",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Currently available beds",
    )
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Current occupancy percentage",
    )

    # By room type
    occupancy_by_room_type: List[RoomTypeOccupancy] = Field(
        default_factory=list,
        description="Occupancy breakdown by room type",
    )

    # Historical
    occupancy_history: List[OccupancyDataPoint] = Field(
        default_factory=list,
        description="Historical occupancy data",
    )

    # Projections
    projected_occupancy_30_days: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=100,
        description="Projected occupancy in 30 days",
    )
    projected_occupancy_90_days: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=100,
        description="Projected occupancy in 90 days",
    )


class MonthlyRevenue(BaseSchema):
    """
    Monthly revenue breakdown with detailed metrics.
    
    Represents revenue for a single month.
    """

    month: str = Field(
        ...,
        pattern=r"^\d{4}-\d{2}$",
        description="Month in YYYY-MM format",
    )
    revenue: Decimal = Field(
        ...,
        ge=0,
        description="Total revenue",
    )
    collected: Decimal = Field(
        ...,
        ge=0,
        description="Amount collected",
    )
    pending: Decimal = Field(
        ...,
        ge=0,
        description="Amount pending",
    )
    student_count: int = Field(
        ...,
        ge=0,
        description="Number of students",
    )
    average_revenue_per_student: Decimal = Field(
        ...,
        ge=0,
        description="Average revenue per student",
    )


class HostelRevenueStats(BaseSchema):
    """
    Detailed revenue statistics with breakdowns and growth metrics.
    
    Provides comprehensive financial analysis.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period",
    )

    # Totals
    total_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Total revenue for period",
    )
    total_expenses: Decimal = Field(
        ...,
        ge=0,
        description="Total expenses for period",
    )
    net_profit: Decimal = Field(
        ...,
        description="Net profit (can be negative)",
    )
    profit_margin: Decimal = Field(
        ...,
        ge=-100,
        le=100,
        description="Profit margin percentage",
    )

    # Revenue breakdown
    revenue_by_type: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Revenue breakdown by type (rent, mess, etc.)",
    )

    # Collection
    total_collected: Decimal = Field(
        ...,
        ge=0,
        description="Total amount collected",
    )
    total_pending: Decimal = Field(
        ...,
        ge=0,
        description="Total amount pending",
    )
    total_overdue: Decimal = Field(
        ...,
        ge=0,
        description="Total overdue amount",
    )
    collection_efficiency: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Collection efficiency percentage",
    )

    # Monthly breakdown
    monthly_revenue: List[MonthlyRevenue] = Field(
        default_factory=list,
        description="Month-by-month revenue breakdown",
    )

    # Comparison
    revenue_growth_mom: Decimal = Field(
        ...,
        description="Month-over-month growth percentage",
    )
    revenue_growth_yoy: Optional[Decimal] = Field(
        default=None,
        description="Year-over-year growth percentage",
    )


class AnalyticsRequest(BaseSchema):
    """
    Request schema for generating analytics.
    
    Specifies parameters for analytics generation.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    start_date: date = Field(..., description="Analytics start date")
    end_date: date = Field(..., description="Analytics end date")
    include_predictions: bool = Field(
        default=False,
        description="Include predictive analytics",
    )
    granularity: str = Field(
        default="daily",
        pattern=r"^(daily|weekly|monthly)$",
        description="Data granularity",
    )

    @model_validator(mode="after")
    def validate_date_range(self) -> "AnalyticsRequest":
        """Validate date range is reasonable."""
        if self.end_date < self.start_date:
            raise ValueError("end_date must be after or equal to start_date")
        
        # Check if date range is not too large (max 2 years)
        days_diff = (self.end_date - self.start_date).days
        if days_diff > 730:  # 2 years
            raise ValueError("Date range cannot exceed 2 years")
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_base.py ---
# --- File: app/schemas/hostel/hostel_base.py ---
"""
Hostel base schemas with enhanced validation and type safety.
"""

from __future__ import annotations

from datetime import time
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import HostelStatus, HostelType
from app.schemas.common.mixins import AddressMixin, ContactMixin, LocationMixin

__all__ = [
    "HostelBase",
    "HostelCreate",
    "HostelUpdate",
    "HostelMediaUpdate",
    "HostelSEOUpdate",
]


class HostelBase(BaseSchema, AddressMixin, ContactMixin, LocationMixin):
    """
    Base hostel schema with common fields.
    
    Combines address, contact, and location information with hostel-specific fields.
    """

    name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Hostel name",
        examples=["Green Valley Hostel"],
    )
    slug: str = Field(
        ...,
        min_length=3,
        max_length=255,
        pattern=r"^[a-z0-9-]+$",
        description="URL-friendly slug (lowercase, alphanumeric, hyphens only)",
        examples=["green-valley-hostel"],
    )
    description: Optional[str] = Field(
        default=None,
        max_length=2000,
        description="Detailed hostel description",
    )

    # Type
    hostel_type: HostelType = Field(
        ...,
        description="Hostel type (boys/girls/co-ed)",
    )

    # Website
    website_url: Optional[HttpUrl] = Field(
        default=None,
        description="Hostel official website URL",
    )

    # Pricing
    starting_price_monthly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Starting monthly price (lowest room type)",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="Currency code (ISO 4217)",
        examples=["INR", "USD"],
    )

    # Amenities and facilities
    amenities: List[str] = Field(
        default_factory=list,
        description="List of amenities (WiFi, AC, etc.)",
        examples=[["WiFi", "AC", "Laundry", "Hot Water"]],
    )
    facilities: List[str] = Field(
        default_factory=list,
        description="List of facilities (Gym, Library, etc.)",
        examples=[["Gym", "Library", "Common Room"]],
    )
    security_features: List[str] = Field(
        default_factory=list,
        description="Security features (CCTV, Guards, etc.)",
        examples=[["CCTV", "24/7 Security", "Biometric Access"]],
    )

    # Policies
    rules: Optional[str] = Field(
        default=None,
        max_length=5000,
        description="Hostel rules and regulations",
    )
    check_in_time: Optional[time] = Field(
        default=None,
        description="Standard check-in time",
        examples=["10:00:00"],
    )
    check_out_time: Optional[time] = Field(
        default=None,
        description="Standard check-out time",
        examples=["11:00:00"],
    )
    visitor_policy: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Visitor policy details",
    )
    late_entry_policy: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Late entry policy and timings",
    )

    # Location info
    nearby_landmarks: List[Dict[str, str]] = Field(
        default_factory=list,
        description="Nearby landmarks with name, type, and distance",
        examples=[[{"name": "Metro Station", "type": "transport", "distance": "500m"}]],
    )
    connectivity_info: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Public transport and connectivity information",
    )

    @field_validator("slug")
    @classmethod
    def validate_slug(cls, v: str) -> str:
        """
        Validate and normalize slug format.
        
        Ensures slug contains only lowercase letters, numbers, and hyphens.
        """
        v = v.lower().strip()
        if not v.replace("-", "").isalnum():
            raise ValueError(
                "Slug can only contain lowercase letters, numbers, and hyphens"
            )
        # Remove consecutive hyphens
        while "--" in v:
            v = v.replace("--", "-")
        # Remove leading/trailing hyphens
        v = v.strip("-")
        return v

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        """Validate and normalize hostel name."""
        v = v.strip()
        # Remove excessive whitespace
        v = " ".join(v.split())
        if v.isdigit():
            raise ValueError("Hostel name cannot be only numbers")
        return v

    @field_validator("amenities", "facilities", "security_features")
    @classmethod
    def validate_and_clean_lists(cls, v: List[str]) -> List[str]:
        """
        Validate and clean list fields.
        
        Removes empty strings, duplicates, and normalizes values.
        """
        if not v:
            return []
        # Clean and normalize
        cleaned = [item.strip() for item in v if item and item.strip()]
        # Remove duplicates while preserving order
        seen = set()
        unique = []
        for item in cleaned:
            item_lower = item.lower()
            if item_lower not in seen:
                seen.add(item_lower)
                unique.append(item)
        return unique

    @field_validator("nearby_landmarks")
    @classmethod
    def validate_landmarks(cls, v: List[Dict[str, str]]) -> List[Dict[str, str]]:
        """Validate nearby landmarks structure."""
        if not v:
            return []
        validated = []
        for landmark in v:
            if not isinstance(landmark, dict):
                continue
            if "name" in landmark and landmark["name"].strip():
                validated.append({
                    "name": landmark.get("name", "").strip(),
                    "type": landmark.get("type", "other").strip(),
                    "distance": landmark.get("distance", "").strip(),
                })
        return validated

    @field_validator("currency")
    @classmethod
    def validate_currency(cls, v: str) -> str:
        """Normalize currency code to uppercase."""
        return v.upper().strip()

    @model_validator(mode="after")
    def validate_check_times(self) -> "HostelBase":
        """Validate check-in and check-out times."""
        if (
            self.check_in_time is not None
            and self.check_out_time is not None
            and self.check_in_time >= self.check_out_time
        ):
            raise ValueError("Check-in time must be before check-out time")
        return self


class HostelCreate(HostelBase, BaseCreateSchema):
    """
    Schema for creating a hostel.
    
    Enforces required fields for hostel creation.
    """

    # Override to enforce requirements
    name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Hostel name (required)",
    )
    hostel_type: HostelType = Field(
        ...,
        description="Hostel type (required)",
    )
    contact_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Primary contact phone (required)",
    )
    address_line1: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Address line 1 (required)",
    )
    city: str = Field(
        ...,
        min_length=2,
        max_length=100,
        description="City (required)",
    )
    state: str = Field(
        ...,
        min_length=2,
        max_length=100,
        description="State (required)",
    )
    pincode: str = Field(
        ...,
        pattern=r"^\d{6}$",
        description="6-digit pincode (required)",
    )


class HostelUpdate(BaseUpdateSchema):
    """
    Schema for updating hostel information.
    
    All fields are optional for partial updates.
    """

    # Basic info
    name: Optional[str] = Field(
        default=None,
        min_length=3,
        max_length=255,
        description="Hostel name",
    )
    slug: Optional[str] = Field(
        default=None,
        min_length=3,
        max_length=255,
        pattern=r"^[a-z0-9-]+$",
        description="URL slug",
    )
    description: Optional[str] = Field(
        default=None,
        max_length=2000,
        description="Description",
    )
    hostel_type: Optional[HostelType] = Field(
        default=None,
        description="Hostel type",
    )

    # Address fields
    address_line1: Optional[str] = Field(
        default=None,
        min_length=5,
        max_length=255,
        description="Address line 1",
    )
    address_line2: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Address line 2",
    )
    city: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="City",
    )
    state: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="State",
    )
    pincode: Optional[str] = Field(
        default=None,
        pattern=r"^\d{6}$",
        description="Pincode",
    )
    country: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="Country",
    )

    # Contact
    contact_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact phone",
    )
    alternate_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Alternate phone",
    )
    contact_email: Optional[str] = Field(
        default=None,
        description="Contact email",
    )
    website_url: Optional[HttpUrl] = Field(
        default=None,
        description="Website URL",
    )

    # Location
    latitude: Optional[Decimal] = Field(
        default=None,
        ge=-90,
        le=90,
        description="Latitude",
    )
    longitude: Optional[Decimal] = Field(
        default=None,
        ge=-180,
        le=180,
        description="Longitude",
    )

    # Pricing
    starting_price_monthly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Starting monthly price",
    )
    currency: Optional[str] = Field(
        default=None,
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="Currency code",
    )

    # Lists
    amenities: Optional[List[str]] = Field(
        default=None,
        description="Amenities list",
    )
    facilities: Optional[List[str]] = Field(
        default=None,
        description="Facilities list",
    )
    security_features: Optional[List[str]] = Field(
        default=None,
        description="Security features list",
    )

    # Policies
    rules: Optional[str] = Field(
        default=None,
        max_length=5000,
        description="Rules and regulations",
    )
    check_in_time: Optional[time] = Field(
        default=None,
        description="Check-in time",
    )
    check_out_time: Optional[time] = Field(
        default=None,
        description="Check-out time",
    )
    visitor_policy: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Visitor policy",
    )
    late_entry_policy: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Late entry policy",
    )

    # Location info
    nearby_landmarks: Optional[List[Dict[str, str]]] = Field(
        default=None,
        description="Nearby landmarks",
    )
    connectivity_info: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Connectivity info",
    )

    # Media
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image URL",
    )
    gallery_images: Optional[List[str]] = Field(
        default=None,
        description="Gallery image URLs",
    )
    virtual_tour_url: Optional[HttpUrl] = Field(
        default=None,
        description="Virtual tour URL",
    )

    # Status
    status: Optional[HostelStatus] = Field(
        default=None,
        description="Operational status",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Active status",
    )

    # Apply same validators as base
    _validate_slug = field_validator("slug")(HostelBase.validate_slug.__func__)
    _validate_name = field_validator("name")(HostelBase.validate_name.__func__)
    _validate_lists = field_validator(
        "amenities", "facilities", "security_features"
    )(HostelBase.validate_and_clean_lists.__func__)
    _validate_currency = field_validator("currency")(
        HostelBase.validate_currency.__func__
    )

    @field_validator("contact_phone", "alternate_phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone numbers."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return v


class HostelMediaUpdate(BaseUpdateSchema):
    """
    Update hostel media (images, videos, virtual tours).
    
    Manages hostel visual content.
    """

    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover/main image URL",
    )
    gallery_images: List[str] = Field(
        default_factory=list,
        max_items=20,
        description="Gallery image URLs (max 20)",
    )
    virtual_tour_url: Optional[HttpUrl] = Field(
        default=None,
        description="360 virtual tour URL",
    )
    video_urls: Optional[List[HttpUrl]] = Field(
        default=None,
        max_items=5,
        description="Video URLs (max 5)",
    )

    @field_validator("gallery_images")
    @classmethod
    def validate_gallery_images(cls, v: List[str]) -> List[str]:
        """Validate gallery images."""
        if not v:
            return []
        # Remove empty strings and duplicates
        cleaned = [img.strip() for img in v if img and img.strip()]
        # Remove duplicates while preserving order
        seen = set()
        unique = []
        for img in cleaned:
            if img not in seen:
                seen.add(img)
                unique.append(img)
        return unique[:20]  # Limit to 20


class HostelSEOUpdate(BaseUpdateSchema):
    """
    Update hostel SEO metadata.
    
    Manages search engine optimization fields.
    """

    meta_title: Optional[str] = Field(
        default=None,
        min_length=10,
        max_length=60,
        description="SEO meta title (optimal: 50-60 chars)",
    )
    meta_description: Optional[str] = Field(
        default=None,
        min_length=50,
        max_length=160,
        description="SEO meta description (optimal: 150-160 chars)",
    )
    meta_keywords: Optional[str] = Field(
        default=None,
        max_length=500,
        description="SEO keywords (comma-separated)",
    )
    og_title: Optional[str] = Field(
        default=None,
        max_length=95,
        description="Open Graph title",
    )
    og_description: Optional[str] = Field(
        default=None,
        max_length=200,
        description="Open Graph description",
    )
    og_image_url: Optional[HttpUrl] = Field(
        default=None,
        description="Open Graph image URL",
    )

    @field_validator("meta_keywords")
    @classmethod
    def validate_keywords(cls, v: Optional[str]) -> Optional[str]:
        """Validate and clean meta keywords."""
        if v is None:
            return v
        # Split, clean, and rejoin
        keywords = [kw.strip() for kw in v.split(",") if kw.strip()]
        # Limit to 10 keywords
        return ", ".join(keywords[:10])

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_comparison.py ---
# --- File: app/schemas/hostel/hostel_comparison.py ---
"""
Hostel comparison schemas for side-by-side analysis.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import HostelType

__all__ = [
    "HostelComparisonRequest",
    "ComparisonResult",
    "ComparisonItem",
    "RoomTypeComparison",
    "ComparisonSummary",
    "PriceComparison",
    "AmenityComparison",
]


class HostelComparisonRequest(BaseCreateSchema):
    """
    Request to compare multiple hostels.
    
    Allows comparison of 2-4 hostels side by side.
    """

    hostel_ids: List[UUID] = Field(
        ...,
        min_length=2,
        max_length=4,
        description="2-4 hostel IDs to compare",
    )

    @field_validator("hostel_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[UUID]) -> List[UUID]:
        """Ensure hostel IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Hostel IDs must be unique")
        return v


class RoomTypeComparison(BaseSchema):
    """
    Room type details for comparison.
    
    Provides room-specific information for comparison.
    """

    room_type: str = Field(
        ...,
        description="Room type (single, double, etc.)",
    )
    price_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Monthly price",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds",
    )
    amenities: List[str] = Field(
        default_factory=list,
        description="Room-specific amenities",
    )


class ComparisonItem(BaseSchema):
    """
    Individual hostel data in comparison.
    
    Complete hostel information formatted for comparison.
    """

    id: UUID = Field(..., description="Hostel ID")
    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")
    hostel_type: HostelType = Field(..., description="Hostel type")

    # Location
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    address: str = Field(..., description="Full address")
    distance_from_center_km: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Distance from city center (km)",
    )

    # Pricing
    starting_price_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Starting monthly price",
    )
    price_range_monthly: str = Field(
        ...,
        description="Price range (e.g., '5,000 - 15,000')",
    )
    security_deposit: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Security deposit amount",
    )

    # Capacity
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total bed capacity",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Currently available beds",
    )

    # Ratings
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )
    rating_breakdown: Dict[str, int] = Field(
        default_factory=dict,
        description="Rating distribution (1-5 stars)",
    )

    # Amenities
    amenities: List[str] = Field(
        default_factory=list,
        description="General amenities",
    )
    facilities: List[str] = Field(
        default_factory=list,
        description="Facilities available",
    )
    security_features: List[str] = Field(
        default_factory=list,
        description="Security features",
    )

    # Room types
    room_types_available: List[str] = Field(
        default_factory=list,
        description="Available room types",
    )
    room_type_details: List[RoomTypeComparison] = Field(
        default_factory=list,
        description="Detailed room type information",
    )

    # Policies
    check_in_time: Optional[str] = Field(
        default=None,
        description="Check-in time",
    )
    check_out_time: Optional[str] = Field(
        default=None,
        description="Check-out time",
    )
    visitor_allowed: bool = Field(
        ...,
        description="Whether visitors are allowed",
    )

    # Media
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image URL",
    )
    total_images: int = Field(
        ...,
        ge=0,
        description="Total number of images",
    )
    has_virtual_tour: bool = Field(
        ...,
        description="Virtual tour availability",
    )

    # Highlights
    unique_features: List[str] = Field(
        default_factory=list,
        description="Unique selling points",
    )
    pros: List[str] = Field(
        default_factory=list,
        description="Advantages/pros",
    )
    cons: List[str] = Field(
        default_factory=list,
        description="Disadvantages/cons",
    )


class PriceComparison(BaseSchema):
    """
    Price comparison summary.
    
    Provides price statistics across compared hostels.
    """

    lowest_price: Decimal = Field(
        ...,
        ge=0,
        description="Lowest starting price",
    )
    highest_price: Decimal = Field(
        ...,
        ge=0,
        description="Highest starting price",
    )
    average_price: Decimal = Field(
        ...,
        ge=0,
        description="Average starting price",
    )
    price_difference_percentage: Decimal = Field(
        ...,
        ge=0,
        description="Percentage difference between lowest and highest",
    )


class AmenityComparison(BaseSchema):
    """
    Amenity comparison summary.
    
    Provides amenity statistics and unique features.
    """

    common_amenities: List[str] = Field(
        default_factory=list,
        description="Amenities present in all compared hostels",
    )
    unique_to_hostel: Dict[str, List[str]] = Field(
        default_factory=dict,
        description="Unique amenities per hostel (hostel_id: [amenities])",
    )
    total_unique_amenities: int = Field(
        ...,
        ge=0,
        description="Total number of unique amenity types",
    )


class ComparisonSummary(BaseSchema):
    """
    Comparison summary with recommendations.
    
    Provides quick insights and best options.
    """

    best_for_budget: UUID = Field(
        ...,
        description="Best value for money (hostel ID)",
    )
    best_rated: UUID = Field(
        ...,
        description="Highest rated hostel (hostel ID)",
    )
    best_location: Optional[UUID] = Field(
        default=None,
        description="Best location (hostel ID)",
    )
    most_amenities: UUID = Field(
        ...,
        description="Most amenities (hostel ID)",
    )
    best_availability: UUID = Field(
        ...,
        description="Best bed availability (hostel ID)",
    )

    price_comparison: PriceComparison = Field(
        ...,
        description="Price comparison statistics",
    )
    amenity_comparison: AmenityComparison = Field(
        ...,
        description="Amenity comparison statistics",
    )


class ComparisonResult(BaseSchema):
    """
    Complete comparison result.
    
    Aggregates all comparison data and insights.
    """

    hostels: List[ComparisonItem] = Field(
        ...,
        description="Hostels being compared",
    )
    comparison_criteria: List[str] = Field(
        ...,
        description="Criteria included in comparison",
    )
    summary: ComparisonSummary = Field(
        ...,
        description="Comparison summary and recommendations",
    )
    generated_at: datetime = Field(
        ...,
        description="Comparison generation timestamp",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_filter.py ---
# --- File: app/schemas/hostel/hostel_filter.py ---
"""
Hostel filter and sort schemas with advanced filtering options.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import HostelStatus, HostelType

__all__ = [
    "HostelFilterParams",
    "HostelSortOptions",
    "AdvancedFilters",
    "BulkFilterParams",
]


class HostelFilterParams(BaseFilterSchema):
    """
    Hostel listing filter parameters.
    
    Provides comprehensive filtering options for hostel queries.
    """

    # Text search
    search: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=255,
        description="Search in name, description, city",
    )

    # Location
    city: Optional[str] = Field(
        default=None,
        description="Filter by city",
    )
    state: Optional[str] = Field(
        default=None,
        description="Filter by state",
    )
    cities: Optional[List[str]] = Field(
        default=None,
        description="Filter by multiple cities",
    )

    # Type
    hostel_type: Optional[HostelType] = Field(
        default=None,
        description="Filter by hostel type",
    )
    hostel_types: Optional[List[HostelType]] = Field(
        default=None,
        description="Filter by multiple hostel types",
    )

    # Status
    status: Optional[HostelStatus] = Field(
        default=None,
        description="Filter by operational status",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Filter by active status",
    )
    is_public: Optional[bool] = Field(
        default=None,
        description="Filter by public visibility",
    )
    is_featured: Optional[bool] = Field(
        default=None,
        description="Filter by featured status",
    )
    is_verified: Optional[bool] = Field(
        default=None,
        description="Filter by verification status",
    )

    # Price range
    price_min: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Minimum monthly price",
    )
    price_max: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Maximum monthly price",
    )

    # Rating
    min_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Minimum average rating",
    )

    # Availability
    has_availability: Optional[bool] = Field(
        default=None,
        description="Filter by bed availability",
    )
    min_available_beds: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum available beds required",
    )

    # Amenities
    amenities: Optional[List[str]] = Field(
        default=None,
        description="Required amenities (all must be present)",
    )

    # Admin filters
    admin_id: Optional[UUID] = Field(
        default=None,
        description="Filter by assigned admin (admin only)",
    )
    has_subscription: Optional[bool] = Field(
        default=None,
        description="Filter by subscription status (admin only)",
    )

    @field_validator("price_max")
    @classmethod
    def validate_price_range(cls, v: Optional[Decimal], info) -> Optional[Decimal]:
        """Validate price range."""
        if v is not None:
            price_min = info.data.get("price_min")
            if price_min is not None and v < price_min:
                raise ValueError("price_max must be greater than or equal to price_min")
        return v


class HostelSortOptions(BaseFilterSchema):
    """
    Hostel sorting options.
    
    Defines available sort criteria and order.
    """

    sort_by: str = Field(
        default="created_at",
        pattern=r"^(name|city|price|rating|occupancy|created_at|updated_at)$",
        description="Field to sort by",
    )
    sort_order: str = Field(
        default="desc",
        pattern=r"^(asc|desc)$",
        description="Sort order (ascending/descending)",
    )

    @field_validator("sort_order")
    @classmethod
    def normalize_sort_order(cls, v: str) -> str:
        """Normalize sort order to lowercase."""
        return v.lower()


class AdvancedFilters(BaseFilterSchema):
    """
    Advanced filtering options.
    
    Provides additional filtering criteria for complex queries.
    """

    # Date filters
    created_after: Optional[date] = Field(
        default=None,
        description="Filter hostels created after this date",
    )
    created_before: Optional[date] = Field(
        default=None,
        description="Filter hostels created before this date",
    )

    # Occupancy
    occupancy_min: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=100,
        description="Minimum occupancy percentage",
    )
    occupancy_max: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=100,
        description="Maximum occupancy percentage",
    )

    # Reviews
    min_reviews: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum number of reviews",
    )

    # Rooms
    min_rooms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum number of rooms",
    )
    max_rooms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Maximum number of rooms",
    )

    # Revenue (admin only)
    revenue_min: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Minimum monthly revenue (admin only)",
    )
    revenue_max: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Maximum monthly revenue (admin only)",
    )

    @field_validator("created_before")
    @classmethod
    def validate_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate date range."""
        if v is not None:
            created_after = info.data.get("created_after")
            if created_after is not None and v < created_after:
                raise ValueError("created_before must be after or equal to created_after")
        return v

    @field_validator("occupancy_max")
    @classmethod
    def validate_occupancy_range(cls, v: Optional[Decimal], info) -> Optional[Decimal]:
        """Validate occupancy range."""
        if v is not None:
            occupancy_min = info.data.get("occupancy_min")
            if occupancy_min is not None and v < occupancy_min:
                raise ValueError("occupancy_max must be >= occupancy_min")
        return v


class BulkFilterParams(BaseFilterSchema):
    """
    Bulk operation filter parameters.
    
    Allows filtering hostels for bulk operations.
    """

    hostel_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of hostel IDs (max 100)",
    )

    # Or use filters
    use_filters: bool = Field(
        default=False,
        description="Use filter criteria instead of explicit IDs",
    )
    filters: Optional[HostelFilterParams] = Field(
        default=None,
        description="Filter criteria (if use_filters is True)",
    )

    @field_validator("hostel_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[UUID]) -> List[UUID]:
        """Ensure hostel IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Hostel IDs must be unique")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_public.py ---
# --- File: app/schemas/hostel/hostel_public.py ---
"""
Public hostel profile schemas for visitor-facing content.
"""

from __future__ import annotations

from datetime import time
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import HostelType

__all__ = [
    "PublicHostelCard",
    "PublicRoomType",
    "PublicHostelProfile",
    "PublicHostelList",
]


class PublicHostelCard(BaseSchema):
    """
    Hostel card for public listing/search results.
    
    Provides essential information for hostel browsing.
    """

    id: UUID = Field(..., description="Hostel ID")
    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")
    hostel_type: HostelType = Field(..., description="Hostel type")
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    starting_price_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Starting monthly price",
    )
    currency: str = Field(..., description="Currency code")
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds",
    )
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image URL",
    )
    is_featured: bool = Field(
        ...,
        description="Featured status",
    )
    amenities: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 amenities for quick view",
    )
    distance_km: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Distance from search location (if applicable)",
    )


class PublicRoomType(BaseSchema):
    """
    Public room type information.
    
    Provides room-specific details for visitors.
    """

    room_type: str = Field(
        ...,
        description="Room type (single, double, etc.)",
    )
    price_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Monthly price",
    )
    price_quarterly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Quarterly price (if available)",
    )
    price_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Yearly price (if available)",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds of this type",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds of this type",
    )
    room_amenities: List[str] = Field(
        default_factory=list,
        description="Room-specific amenities",
    )
    room_images: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Room images (max 10)",
    )
    room_size_sqft: Optional[int] = Field(
        default=None,
        ge=0,
        description="Room size in square feet",
    )


class PublicHostelProfile(BaseSchema):
    """
    Complete public hostel profile.
    
    Comprehensive hostel information for detail pages.
    """

    id: UUID = Field(..., description="Hostel ID")
    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")
    description: Optional[str] = Field(
        default=None,
        description="Hostel description",
    )
    hostel_type: HostelType = Field(..., description="Hostel type")

    # Contact (public)
    contact_phone: str = Field(..., description="Contact phone number")
    contact_email: Optional[str] = Field(
        default=None,
        description="Contact email",
    )
    website_url: Optional[str] = Field(
        default=None,
        description="Official website URL",
    )

    # Address
    address_line1: str = Field(..., description="Address line 1")
    address_line2: Optional[str] = Field(
        default=None,
        description="Address line 2",
    )
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    pincode: str = Field(..., description="Pincode")
    latitude: Optional[Decimal] = Field(
        default=None,
        description="Latitude for map display",
    )
    longitude: Optional[Decimal] = Field(
        default=None,
        description="Longitude for map display",
    )

    # Pricing
    starting_price_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Starting monthly price",
    )
    currency: str = Field(..., description="Currency code")

    # Availability
    available_beds: int = Field(
        ...,
        ge=0,
        description="Total available beds",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total bed capacity",
    )

    # Ratings
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )
    rating_breakdown: Dict[str, int] = Field(
        default_factory=dict,
        description="Rating distribution {1: count, 2: count, ...}",
    )

    # Features
    amenities: List[str] = Field(
        default_factory=list,
        description="Available amenities",
    )
    facilities: List[str] = Field(
        default_factory=list,
        description="Available facilities",
    )
    security_features: List[str] = Field(
        default_factory=list,
        description="Security features",
    )

    # Policies
    rules: Optional[str] = Field(
        default=None,
        description="Hostel rules and regulations",
    )
    check_in_time: Optional[time] = Field(
        default=None,
        description="Standard check-in time",
    )
    check_out_time: Optional[time] = Field(
        default=None,
        description="Standard check-out time",
    )
    visitor_policy: Optional[str] = Field(
        default=None,
        description="Visitor policy",
    )

    # Location
    nearby_landmarks: List[Dict[str, str]] = Field(
        default_factory=list,
        description="Nearby landmarks with details",
    )
    connectivity_info: Optional[str] = Field(
        default=None,
        description="Public transport connectivity",
    )

    # Media
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image URL",
    )
    gallery_images: List[str] = Field(
        default_factory=list,
        description="Gallery images",
    )
    virtual_tour_url: Optional[str] = Field(
        default=None,
        description="360 virtual tour URL",
    )

    # Room types available
    room_types: List[PublicRoomType] = Field(
        default_factory=list,
        description="Available room types with pricing",
    )

    # Additional info
    established_year: Optional[int] = Field(
        default=None,
        ge=1900,
        le=2100,
        description="Year established",
    )
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total number of rooms",
    )


class PublicHostelList(BaseSchema):
    """
    List of public hostels with metadata.
    
    Response schema for hostel listing pages.
    """

    hostels: List[PublicHostelCard] = Field(
        ...,
        description="List of hostels",
    )
    total_count: int = Field(
        ...,
        ge=0,
        description="Total number of hostels matching criteria",
    )
    filters_applied: Dict[str, str] = Field(
        default_factory=dict,
        description="Summary of applied filters",
    )
    page: int = Field(
        default=1,
        ge=1,
        description="Current page number",
    )
    page_size: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Items per page",
    )
    total_pages: int = Field(
        ...,
        ge=0,
        description="Total number of pages",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_response.py ---
# --- File: app/schemas/hostel/hostel_response.py ---
"""
Hostel response schemas for API responses.
"""

from __future__ import annotations

from datetime import datetime, time
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import HostelStatus, HostelType

__all__ = [
    "HostelResponse",
    "HostelDetail",
    "HostelListItem",
    "HostelStats",
]


class HostelResponse(BaseResponseSchema):
    """
    Basic hostel response schema.
    
    Standard response for hostel operations.
    """

    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")
    hostel_type: HostelType = Field(..., description="Hostel type")
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    starting_price_monthly: Optional[Decimal] = Field(
        default=None,
        description="Starting monthly price",
    )
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total number of rooms",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds",
    )
    is_public: bool = Field(..., description="Public visibility")
    is_featured: bool = Field(..., description="Featured status")
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image URL",
    )
    status: HostelStatus = Field(..., description="Operational status")


class HostelDetail(BaseResponseSchema):
    """
    Detailed hostel information.
    
    Comprehensive hostel data for detail views.
    """

    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")
    description: Optional[str] = Field(
        default=None,
        description="Hostel description",
    )

    # Type and contact
    hostel_type: HostelType = Field(..., description="Hostel type")
    contact_email: Optional[str] = Field(
        default=None,
        description="Contact email",
    )
    contact_phone: str = Field(..., description="Contact phone")
    alternate_phone: Optional[str] = Field(
        default=None,
        description="Alternate phone",
    )
    website_url: Optional[str] = Field(
        default=None,
        description="Website URL",
    )

    # Address
    address_line1: str = Field(..., description="Address line 1")
    address_line2: Optional[str] = Field(
        default=None,
        description="Address line 2",
    )
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    pincode: str = Field(..., description="Pincode")
    country: str = Field(..., description="Country")
    latitude: Optional[Decimal] = Field(
        default=None,
        description="Latitude",
    )
    longitude: Optional[Decimal] = Field(
        default=None,
        description="Longitude",
    )

    # Pricing
    starting_price_monthly: Optional[Decimal] = Field(
        default=None,
        description="Starting monthly price",
    )
    currency: str = Field(..., description="Currency code")

    # Capacity
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total number of rooms",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total number of beds",
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Occupied beds",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds",
    )

    # Ratings
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total reviews",
    )

    # Features
    amenities: List[str] = Field(
        default_factory=list,
        description="Available amenities",
    )
    facilities: List[str] = Field(
        default_factory=list,
        description="Available facilities",
    )
    security_features: List[str] = Field(
        default_factory=list,
        description="Security features",
    )

    # Policies
    rules: Optional[str] = Field(
        default=None,
        description="Hostel rules",
    )
    check_in_time: Optional[time] = Field(
        default=None,
        description="Check-in time",
    )
    check_out_time: Optional[time] = Field(
        default=None,
        description="Check-out time",
    )
    visitor_policy: Optional[str] = Field(
        default=None,
        description="Visitor policy",
    )
    late_entry_policy: Optional[str] = Field(
        default=None,
        description="Late entry policy",
    )

    # Location info
    nearby_landmarks: List[dict] = Field(
        default_factory=list,
        description="Nearby landmarks",
    )
    connectivity_info: Optional[str] = Field(
        default=None,
        description="Connectivity information",
    )

    # Media
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image URL",
    )
    gallery_images: List[str] = Field(
        default_factory=list,
        description="Gallery images",
    )
    virtual_tour_url: Optional[str] = Field(
        default=None,
        description="Virtual tour URL",
    )

    # Status
    is_public: bool = Field(..., description="Public visibility")
    is_featured: bool = Field(..., description="Featured status")
    is_verified: bool = Field(..., description="Verification status")
    status: HostelStatus = Field(..., description="Operational status")
    is_active: bool = Field(..., description="Active status")

    # SEO
    meta_title: Optional[str] = Field(
        default=None,
        description="SEO meta title",
    )
    meta_description: Optional[str] = Field(
        default=None,
        description="SEO meta description",
    )
    meta_keywords: Optional[str] = Field(
        default=None,
        description="SEO keywords",
    )


class HostelListItem(BaseSchema):
    """
    Hostel list item for list views.
    
    Minimal information for efficient list rendering.
    """

    id: UUID = Field(..., description="Hostel ID")
    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")
    hostel_type: HostelType = Field(..., description="Hostel type")
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    starting_price_monthly: Optional[Decimal] = Field(
        default=None,
        description="Starting price",
    )
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total reviews",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds",
    )
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image",
    )
    is_featured: bool = Field(..., description="Featured status")
    distance_km: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Distance from search location",
    )


class HostelStats(BaseSchema):
    """
    Hostel statistics summary.
    
    Key metrics and statistics for a hostel.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")

    # Occupancy
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total rooms",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds",
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Occupied beds",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds",
    )
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Occupancy percentage",
    )

    # Revenue
    total_revenue_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Total monthly revenue",
    )
    total_outstanding: Decimal = Field(
        ...,
        ge=0,
        description="Total outstanding payments",
    )

    # Students
    total_students: int = Field(
        ...,
        ge=0,
        description="Total registered students",
    )
    active_students: int = Field(
        ...,
        ge=0,
        description="Active students",
    )

    # Complaints
    open_complaints: int = Field(
        ...,
        ge=0,
        description="Open complaints",
    )
    resolved_complaints: int = Field(
        ...,
        ge=0,
        description="Resolved complaints",
    )

    # Bookings
    pending_bookings: int = Field(
        ...,
        ge=0,
        description="Pending booking requests",
    )
    confirmed_bookings: int = Field(
        ...,
        ge=0,
        description="Confirmed bookings",
    )

    # Reviews
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total reviews",
    )

    # Last updated
    updated_at: datetime = Field(..., description="Last update timestamp")

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_search.py ---
# --- File: app/schemas/hostel/hostel_search.py ---
"""
Hostel search schemas with comprehensive search and filtering.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseFilterSchema, BaseSchema
from app.schemas.common.enums import HostelType, RoomType
from app.schemas.hostel.hostel_public import PublicHostelCard

__all__ = [
    "HostelSearchRequest",
    "HostelSearchResponse",
    "SearchFacets",
    "FacetItem",
    "PriceRangeFacet",
    "RatingFacet",
    "HostelSearchFilters",
]


class HostelSearchRequest(BaseFilterSchema):
    """
    Hostel search request with comprehensive filtering.
    
    Supports text search, location-based search, and various filters.
    """

    # Text search
    query: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=255,
        description="Search query (name, description, city)",
    )

    # Location filters
    city: Optional[str] = Field(
        default=None,
        description="Filter by city name",
    )
    state: Optional[str] = Field(
        default=None,
        description="Filter by state name",
    )
    pincode: Optional[str] = Field(
        default=None,
        pattern=r"^\d{6}$",
        description="Filter by 6-digit pincode",
    )

    # Location-based search (radius)
    latitude: Optional[Decimal] = Field(
        default=None,
        ge=-90,
        le=90,
        description="Latitude for radius search",
    )
    longitude: Optional[Decimal] = Field(
        default=None,
        ge=-180,
        le=180,
        description="Longitude for radius search",
    )
    radius_km: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=50,
        description="Search radius in kilometers",
    )

    # Type filter
    hostel_type: Optional[HostelType] = Field(
        default=None,
        description="Filter by hostel type",
    )

    # Price filter
    min_price: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Minimum monthly price",
    )
    max_price: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Maximum monthly price",
    )

    # Room type
    room_type: Optional[RoomType] = Field(
        default=None,
        description="Preferred room type",
    )

    # Amenities filter
    amenities: Optional[List[str]] = Field(
        default=None,
        max_length=10,
        description="Required amenities (all must be present)",
    )

    # Availability
    available_beds_min: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum available beds required",
    )

    # Rating filter
    min_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Minimum average rating",
    )

    # Features
    verified_only: bool = Field(
        default=False,
        description="Show only verified hostels",
    )
    featured_only: bool = Field(
        default=False,
        description="Show only featured hostels",
    )

    # Sort
    sort_by: str = Field(
        default="relevance",
        pattern=r"^(relevance|price_low|price_high|rating|distance|newest)$",
        description="Sort criteria",
    )

    # Pagination
    page: int = Field(
        default=1,
        ge=1,
        description="Page number",
    )
    page_size: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Results per page",
    )

    @model_validator(mode="after")
    def validate_location_search(self) -> "HostelSearchRequest":
        """Validate location-based search parameters."""
        # If radius search, both lat/lon and radius are required
        has_lat = self.latitude is not None
        has_lon = self.longitude is not None
        has_radius = self.radius_km is not None

        if any([has_lat, has_lon, has_radius]):
            if not all([has_lat, has_lon, has_radius]):
                raise ValueError(
                    "For radius search, latitude, longitude, and radius_km "
                    "are all required"
                )
        return self

    @field_validator("max_price")
    @classmethod
    def validate_price_range(cls, v: Optional[Decimal], info) -> Optional[Decimal]:
        """Validate price range."""
        if v is not None:
            min_price = info.data.get("min_price")
            if min_price is not None and v < min_price:
                raise ValueError("max_price must be >= min_price")
        return v


class FacetItem(BaseSchema):
    """
    Facet item with count.
    
    Represents a filter option with result count.
    """

    value: str = Field(..., description="Facet value")
    label: str = Field(..., description="Display label")
    count: int = Field(
        ...,
        ge=0,
        description="Number of results with this value",
    )


class PriceRangeFacet(BaseSchema):
    """
    Price range facet.
    
    Represents a price range filter option.
    """

    min_price: Decimal = Field(..., ge=0, description="Range minimum")
    max_price: Decimal = Field(..., ge=0, description="Range maximum")
    label: str = Field(..., description="Display label")
    count: int = Field(
        ...,
        ge=0,
        description="Number of results in range",
    )


class RatingFacet(BaseSchema):
    """
    Rating facet.
    
    Represents a rating filter option.
    """

    min_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Minimum rating",
    )
    label: str = Field(..., description="Display label")
    count: int = Field(
        ...,
        ge=0,
        description="Number of results",
    )


class SearchFacets(BaseSchema):
    """
    Search facets for filtering.
    
    Provides available filter options with counts.
    """

    cities: List[FacetItem] = Field(
        default_factory=list,
        description="Available cities with result counts",
    )
    hostel_types: List[FacetItem] = Field(
        default_factory=list,
        description="Hostel types with result counts",
    )
    price_ranges: List[PriceRangeFacet] = Field(
        default_factory=list,
        description="Price ranges with result counts",
    )
    amenities: List[FacetItem] = Field(
        default_factory=list,
        description="Available amenities with result counts",
    )
    ratings: List[RatingFacet] = Field(
        default_factory=list,
        description="Rating distribution",
    )


class HostelSearchResponse(BaseSchema):
    """
    Hostel search response.
    
    Complete search results with metadata and facets.
    """

    results: List[PublicHostelCard] = Field(
        ...,
        description="Search results",
    )
    total_results: int = Field(
        ...,
        ge=0,
        description="Total matching hostels",
    )
    total_pages: int = Field(
        ...,
        ge=0,
        description="Total number of pages",
    )
    current_page: int = Field(
        ...,
        ge=1,
        description="Current page number",
    )
    filters_applied: dict = Field(
        default_factory=dict,
        description="Summary of applied filters",
    )
    facets: SearchFacets = Field(
        ...,
        description="Available filter facets",
    )


class HostelSearchFilters(BaseFilterSchema):
    """
    Advanced search filters.
    
    Additional filtering options for hostel search.
    """

    # Gender
    gender: Optional[str] = Field(
        default=None,
        pattern=r"^(boys|girls|co_ed)$",
        description="Gender preference",
    )

    # Facilities (boolean filters)
    has_wifi: Optional[bool] = Field(
        default=None,
        description="Has WiFi",
    )
    has_ac: Optional[bool] = Field(
        default=None,
        description="Has AC",
    )
    has_laundry: Optional[bool] = Field(
        default=None,
        description="Has laundry facility",
    )
    has_parking: Optional[bool] = Field(
        default=None,
        description="Has parking",
    )
    has_gym: Optional[bool] = Field(
        default=None,
        description="Has gym/fitness center",
    )
    has_mess: Optional[bool] = Field(
        default=None,
        description="Has mess/canteen",
    )

    # Security
    has_cctv: Optional[bool] = Field(
        default=None,
        description="Has CCTV surveillance",
    )
    has_security_guard: Optional[bool] = Field(
        default=None,
        description="Has security guard",
    )

    # Rules
    allow_visitors: Optional[bool] = Field(
        default=None,
        description="Allows visitors",
    )

    # Availability
    check_in_date: Optional[date] = Field(
        default=None,
        description="Desired check-in date",
    )

    @field_validator("check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate check-in date is not in the past."""
        if v is not None:
            from datetime import date as dt
            if v < dt.today():
                raise ValueError("Check-in date cannot be in the past")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\__init__.py ---
from __future__ import annotations

from app.schemas.hostel.hostel_admin import (
    HostelAdminView,
    HostelCapacityUpdate,
    HostelSettings,
    HostelStatusUpdate,
    HostelVisibilityUpdate,
)
from app.schemas.hostel.hostel_analytics import (
    AnalyticsRequest,
    BookingAnalytics,
    ComplaintAnalytics,
    HostelAnalytics,
    HostelOccupancyStats,
    HostelRevenueStats,
    OccupancyAnalytics,
    RevenueAnalytics,
    ReviewAnalytics,
)
from app.schemas.hostel.hostel_base import (
    HostelBase,
    HostelCreate,
    HostelMediaUpdate,
    HostelSEOUpdate,
    HostelUpdate,
)
from app.schemas.hostel.hostel_comparison import (
    ComparisonItem,
    ComparisonResult,
    HostelComparisonRequest,
)
from app.schemas.hostel.hostel_filter import (
    AdvancedFilters,
    BulkFilterParams,
    HostelFilterParams,
    HostelSortOptions,
)
from app.schemas.hostel.hostel_public import (
    PublicHostelCard,
    PublicHostelList,
    PublicHostelProfile,
    PublicRoomType,
)
from app.schemas.hostel.hostel_response import (
    HostelDetail,
    HostelListItem,
    HostelResponse,
    HostelStats,
)
from app.schemas.hostel.hostel_search import (
    HostelSearchFilters,
    HostelSearchRequest,
    HostelSearchResponse,
    SearchFacets,
)

__all__ = [
    # Base
    "HostelBase",
    "HostelCreate",
    "HostelUpdate",
    "HostelMediaUpdate",
    "HostelSEOUpdate",
    # Response
    "HostelResponse",
    "HostelDetail",
    "HostelListItem",
    "HostelStats",
    # Public
    "PublicHostelProfile",
    "PublicHostelList",
    "PublicHostelCard",
    "PublicRoomType",
    # Admin
    "HostelAdminView",
    "HostelSettings",
    "HostelVisibilityUpdate",
    "HostelCapacityUpdate",
    "HostelStatusUpdate",
    # Search
    "HostelSearchRequest",
    "HostelSearchResponse",
    "HostelSearchFilters",
    "SearchFacets",
    # Filter
    "HostelFilterParams",
    "HostelSortOptions",
    "AdvancedFilters",
    "BulkFilterParams",
    # Analytics
    "HostelAnalytics",
    "OccupancyAnalytics",
    "RevenueAnalytics",
    "BookingAnalytics",
    "ComplaintAnalytics",
    "ReviewAnalytics",
    "HostelOccupancyStats",
    "HostelRevenueStats",
    "AnalyticsRequest",
    # Comparison
    "HostelComparisonRequest",
    "ComparisonResult",
    "ComparisonItem",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_admin.py ---
# --- File: app/schemas/hostel/hostel_admin.py ---
"""
Hostel admin view schemas with enhanced configuration options.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Optional

from pydantic import Field, field_validator

from app.schemas.common.base import BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import HostelStatus, SubscriptionPlan, SubscriptionStatus

__all__ = [
    "HostelAdminView",
    "HostelSettings",
    "HostelVisibilityUpdate",
    "HostelCapacityUpdate",
    "HostelStatusUpdate",
]


class HostelAdminView(BaseSchema):
    """
    Comprehensive hostel view for administrators.
    
    Provides complete hostel information with statistics and metrics.
    """

    id: str = Field(..., description="Hostel ID")
    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")

    # Status
    status: HostelStatus = Field(..., description="Operational status")
    is_active: bool = Field(..., description="Active status")
    is_public: bool = Field(..., description="Public listing visibility")
    is_featured: bool = Field(..., description="Featured in listings")
    is_verified: bool = Field(..., description="Verification status")

    # Capacity stats
    total_rooms: int = Field(..., ge=0, description="Total number of rooms")
    total_beds: int = Field(..., ge=0, description="Total number of beds")
    occupied_beds: int = Field(..., ge=0, description="Currently occupied beds")
    available_beds: int = Field(..., ge=0, description="Available beds")
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Current occupancy percentage",
    )

    # Students
    total_students: int = Field(
        ...,
        ge=0,
        description="Total registered students",
    )
    active_students: int = Field(
        ...,
        ge=0,
        description="Currently active students",
    )

    # Financial
    total_revenue_this_month: Decimal = Field(
        ...,
        ge=0,
        description="Total revenue for current month",
    )
    outstanding_payments: Decimal = Field(
        ...,
        ge=0,
        description="Total outstanding payment amount",
    )

    # Pending items
    pending_bookings: int = Field(
        ...,
        ge=0,
        description="Number of pending booking requests",
    )
    pending_complaints: int = Field(
        ...,
        ge=0,
        description="Number of open/pending complaints",
    )
    pending_maintenance: int = Field(
        ...,
        ge=0,
        description="Number of pending maintenance requests",
    )

    # Subscription
    subscription_plan: Optional[SubscriptionPlan] = Field(
        default=None,
        description="Current subscription plan",
    )
    subscription_status: Optional[SubscriptionStatus] = Field(
        default=None,
        description="Subscription status",
    )
    subscription_expires_at: Optional[datetime] = Field(
        default=None,
        description="Subscription expiration date",
    )

    # Performance
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating from reviews",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )


class HostelSettings(BaseUpdateSchema):
    """
    Hostel configuration settings.
    
    Manages hostel operational and behavioral settings.
    """

    # Visibility
    is_public: Optional[bool] = Field(
        default=None,
        description="Make hostel visible in public listings",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Hostel operational status",
    )

    # Booking settings
    auto_approve_bookings: bool = Field(
        default=False,
        description="Automatically approve booking requests",
    )
    booking_advance_percentage: Decimal = Field(
        default=Decimal("20.00"),
        ge=0,
        le=100,
        description="Required advance payment percentage",
    )
    max_booking_duration_months: int = Field(
        default=12,
        ge=1,
        le=24,
        description="Maximum booking duration in months",
    )
    min_booking_duration_days: int = Field(
        default=30,
        ge=1,
        le=365,
        description="Minimum booking duration in days",
    )

    # Payment settings
    payment_due_day: int = Field(
        default=5,
        ge=1,
        le=28,
        description="Monthly payment due date",
    )
    late_payment_grace_days: int = Field(
        default=3,
        ge=0,
        le=10,
        description="Grace period for late payments (days)",
    )
    late_payment_penalty_percentage: Decimal = Field(
        default=Decimal("5.00"),
        ge=0,
        le=50,
        description="Late payment penalty percentage",
    )

    # Attendance settings
    enable_attendance_tracking: bool = Field(
        default=True,
        description="Enable attendance tracking system",
    )
    minimum_attendance_percentage: Decimal = Field(
        default=Decimal("75.00"),
        ge=0,
        le=100,
        description="Minimum required attendance percentage",
    )
    attendance_grace_period_days: int = Field(
        default=7,
        ge=0,
        le=30,
        description="Attendance tracking grace period for new students",
    )

    # Notification settings
    notify_on_booking: bool = Field(
        default=True,
        description="Send notifications for new bookings",
    )
    notify_on_complaint: bool = Field(
        default=True,
        description="Send notifications for new complaints",
    )
    notify_on_payment: bool = Field(
        default=True,
        description="Send notifications for payments",
    )
    notify_on_maintenance: bool = Field(
        default=True,
        description="Send notifications for maintenance requests",
    )

    # Mess settings
    mess_included: bool = Field(
        default=False,
        description="Mess facility included in rent",
    )
    mess_charges_monthly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Monthly mess charges (if separate)",
    )
    mess_advance_booking_days: int = Field(
        default=1,
        ge=0,
        le=7,
        description="Days in advance for mess meal booking",
    )

    # Security settings
    visitor_entry_time_start: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Visitor entry allowed from (HH:MM)",
    )
    visitor_entry_time_end: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Visitor entry allowed until (HH:MM)",
    )
    late_entry_time: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Late entry cutoff time (HH:MM)",
    )


class HostelVisibilityUpdate(BaseUpdateSchema):
    """
    Update hostel visibility settings.
    
    Controls hostel appearance in public listings and searches.
    """

    is_public: bool = Field(
        ...,
        description="Make hostel publicly visible",
    )
    is_featured: bool = Field(
        default=False,
        description="Feature hostel in search results",
    )
    is_verified: bool = Field(
        default=False,
        description="Mark hostel as verified (admin only)",
    )


class HostelCapacityUpdate(BaseUpdateSchema):
    """
    Update hostel capacity information.
    
    Admin-only operation to modify hostel capacity.
    """

    total_rooms: int = Field(
        ...,
        ge=1,
        description="Total number of rooms",
    )
    total_beds: int = Field(
        ...,
        ge=1,
        description="Total number of beds",
    )

    @field_validator("total_beds")
    @classmethod
    def validate_beds_vs_rooms(cls, v: int, info) -> int:
        """Validate that total beds is reasonable compared to rooms."""
        total_rooms = info.data.get("total_rooms")
        if total_rooms is not None and v < total_rooms:
            raise ValueError(
                "Total beds cannot be less than total rooms"
            )
        if total_rooms is not None and v > (total_rooms * 8):
            raise ValueError(
                "Total beds seems unreasonably high compared to rooms"
            )
        return v


class HostelStatusUpdate(BaseUpdateSchema):
    """
    Update hostel operational status.
    
    Tracks status changes with reason.
    """

    status: HostelStatus = Field(
        ...,
        description="New hostel status",
    )
    is_active: bool = Field(
        ...,
        description="Active status",
    )
    reason: Optional[str] = Field(
        default=None,
        min_length=10,
        max_length=500,
        description="Reason for status change",
    )
    effective_date: Optional[datetime] = Field(
        default=None,
        description="Effective date of status change",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason_required(cls, v: Optional[str], info) -> Optional[str]:
        """Require reason for certain status changes."""
        status = info.data.get("status")
        is_active = info.data.get("is_active")
        
        # Require reason if deactivating or setting to maintenance/closed
        if (
            is_active is False
            or status in [HostelStatus.UNDER_MAINTENANCE, HostelStatus.CLOSED]
        ) and not v:
            raise ValueError(
                "Reason is required when deactivating or changing to "
                "maintenance/closed status"
            )
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_analytics.py ---
# --- File: app/schemas/hostel/hostel_analytics.py ---
"""
Hostel analytics and reporting schemas with comprehensive metrics.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "HostelAnalytics",
    "OccupancyAnalytics",
    "OccupancyDataPoint",
    "RevenueAnalytics",
    "RevenueDataPoint",
    "BookingAnalytics",
    "BookingDataPoint",
    "ComplaintAnalytics",
    "ReviewAnalytics",
    "RatingDataPoint",
    "HostelOccupancyStats",
    "RoomTypeOccupancy",
    "HostelRevenueStats",
    "MonthlyRevenue",
    "AnalyticsRequest",
]


class OccupancyDataPoint(BaseSchema):
    """
    Single occupancy data point for trends.
    
    Represents occupancy at a specific point in time.
    """

    date: date = Field(..., description="Date of the data point")
    occupancy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Occupancy rate percentage",
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Number of occupied beds",
    )
    total_beds: int = Field(
        ...,
        ge=1,
        description="Total available beds",
    )


class OccupancyAnalytics(BaseSchema):
    """
    Comprehensive occupancy analytics.
    
    Provides detailed occupancy metrics and trends.
    """

    current_occupancy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Current occupancy percentage",
    )
    average_occupancy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Average occupancy for the period",
    )
    peak_occupancy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Peak occupancy during period",
    )
    lowest_occupancy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Lowest occupancy during period",
    )

    total_beds: int = Field(
        ...,
        ge=0,
        description="Total bed capacity",
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Currently occupied beds",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Currently available beds",
    )

    # Trends
    occupancy_trend: List[OccupancyDataPoint] = Field(
        default_factory=list,
        description="Historical occupancy trend",
    )

    # Predictions
    predicted_occupancy_next_month: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=100,
        description="Predicted occupancy for next month",
    )
    trend_direction: str = Field(
        ...,
        pattern=r"^(increasing|decreasing|stable)$",
        description="Overall occupancy trend direction",
    )


class RevenueDataPoint(BaseSchema):
    """
    Single revenue data point.
    
    Represents revenue metrics at a specific point in time.
    """

    date: date = Field(..., description="Date of the data point")
    revenue: Decimal = Field(
        ...,
        ge=0,
        description="Total revenue",
    )
    collected: Decimal = Field(
        ...,
        ge=0,
        description="Amount collected",
    )
    pending: Decimal = Field(
        ...,
        ge=0,
        description="Amount pending",
    )


class RevenueAnalytics(BaseSchema):
    """
    Comprehensive revenue analytics.
    
    Provides detailed financial metrics and trends.
    """

    total_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Total revenue for period",
    )
    rent_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Revenue from rent",
    )
    mess_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Revenue from mess charges",
    )
    other_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Revenue from other sources",
    )

    total_collected: Decimal = Field(
        ...,
        ge=0,
        description="Total amount collected",
    )
    total_pending: Decimal = Field(
        ...,
        ge=0,
        description="Total amount pending",
    )
    total_overdue: Decimal = Field(
        ...,
        ge=0,
        description="Total overdue amount",
    )

    collection_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Payment collection rate percentage",
    )

    # Trends
    revenue_trend: List[RevenueDataPoint] = Field(
        default_factory=list,
        description="Historical revenue trend",
    )

    # Comparisons
    revenue_vs_last_period: Decimal = Field(
        ...,
        description="Percentage change from last period",
    )
    revenue_vs_last_year: Optional[Decimal] = Field(
        default=None,
        description="Year-over-year percentage change",
    )

    # Additional metrics
    average_revenue_per_bed: Decimal = Field(
        ...,
        ge=0,
        description="Average revenue per occupied bed",
    )


class BookingDataPoint(BaseSchema):
    """
    Single booking data point.
    
    Represents booking metrics at a specific point in time.
    """

    date: date = Field(..., description="Date of the data point")
    total_bookings: int = Field(
        ...,
        ge=0,
        description="Total bookings",
    )
    approved: int = Field(
        ...,
        ge=0,
        description="Approved bookings",
    )
    rejected: int = Field(
        ...,
        ge=0,
        description="Rejected bookings",
    )


class BookingAnalytics(BaseSchema):
    """
    Comprehensive booking analytics.
    
    Provides detailed booking metrics and conversion rates.
    """

    total_bookings: int = Field(
        ...,
        ge=0,
        description="Total booking requests",
    )
    approved_bookings: int = Field(
        ...,
        ge=0,
        description="Approved bookings",
    )
    pending_bookings: int = Field(
        ...,
        ge=0,
        description="Pending bookings",
    )
    rejected_bookings: int = Field(
        ...,
        ge=0,
        description="Rejected bookings",
    )
    cancelled_bookings: int = Field(
        ...,
        ge=0,
        description="Cancelled bookings",
    )

    conversion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Booking approval rate percentage",
    )
    cancellation_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Cancellation rate percentage",
    )

    # Sources
    booking_sources: Dict[str, int] = Field(
        default_factory=dict,
        description="Bookings by source (website, app, etc.)",
    )

    # Trends
    booking_trend: List[BookingDataPoint] = Field(
        default_factory=list,
        description="Historical booking trend",
    )

    # Average metrics
    average_booking_value: Decimal = Field(
        ...,
        ge=0,
        description="Average booking value",
    )


class ComplaintAnalytics(BaseSchema):
    """
    Comprehensive complaint analytics.
    
    Provides detailed complaint metrics and resolution statistics.
    """

    total_complaints: int = Field(
        ...,
        ge=0,
        description="Total complaints",
    )
    open_complaints: int = Field(
        ...,
        ge=0,
        description="Currently open complaints",
    )
    resolved_complaints: int = Field(
        ...,
        ge=0,
        description="Resolved complaints",
    )
    closed_complaints: int = Field(
        ...,
        ge=0,
        description="Closed complaints",
    )

    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average time to resolve (hours)",
    )
    resolution_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of resolved complaints",
    )

    # By category
    complaints_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaints grouped by category",
    )

    # By priority
    complaints_by_priority: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaints grouped by priority",
    )

    # SLA compliance
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage meeting SLA",
    )
    sla_breaches: int = Field(
        ...,
        ge=0,
        description="Number of SLA breaches",
    )


class RatingDataPoint(BaseSchema):
    """
    Single rating data point.
    
    Represents rating metrics for a period.
    """

    month: str = Field(
        ...,
        pattern=r"^\d{4}-\d{2}$",
        description="Month in YYYY-MM format",
    )
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    review_count: int = Field(
        ...,
        ge=0,
        description="Number of reviews",
    )


class ReviewAnalytics(BaseSchema):
    """
    Comprehensive review analytics.
    
    Provides detailed review and rating statistics.
    """

    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Overall average rating",
    )

    # Rating distribution
    rating_distribution: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of ratings by star (1-5)",
    )

    # Detailed aspect ratings
    average_cleanliness_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average cleanliness rating",
    )
    average_food_quality_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average food quality rating",
    )
    average_staff_behavior_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average staff behavior rating",
    )
    average_security_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average security rating",
    )
    average_value_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average value for money rating",
    )

    # Trends
    rating_trend: List[RatingDataPoint] = Field(
        default_factory=list,
        description="Historical rating trend",
    )

    # Sentiment
    positive_reviews: int = Field(
        ...,
        ge=0,
        description="Number of positive reviews (4-5 stars)",
    )
    negative_reviews: int = Field(
        ...,
        ge=0,
        description="Number of negative reviews (1-2 stars)",
    )
    sentiment_score: Decimal = Field(
        ...,
        ge=-1,
        le=1,
        description="Overall sentiment score (-1 to 1)",
    )


class HostelAnalytics(BaseSchema):
    """
    Comprehensive hostel analytics dashboard.
    
    Aggregates all analytics for a hostel over a period.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    period_start: date = Field(..., description="Analytics period start")
    period_end: date = Field(..., description="Analytics period end")

    occupancy: OccupancyAnalytics = Field(
        ...,
        description="Occupancy analytics",
    )
    revenue: RevenueAnalytics = Field(
        ...,
        description="Revenue analytics",
    )
    bookings: BookingAnalytics = Field(
        ...,
        description="Booking analytics",
    )
    complaints: ComplaintAnalytics = Field(
        ...,
        description="Complaint analytics",
    )
    reviews: ReviewAnalytics = Field(
        ...,
        description="Review analytics",
    )

    generated_at: datetime = Field(
        ...,
        description="Analytics generation timestamp",
    )


class RoomTypeOccupancy(BaseSchema):
    """
    Occupancy statistics by room type.
    
    Provides occupancy breakdown for different room types.
    """

    room_type: str = Field(
        ...,
        description="Room type (single, double, etc.)",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds of this type",
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Occupied beds of this type",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds of this type",
    )
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Occupancy percentage for this type",
    )


class HostelOccupancyStats(BaseSchema):
    """
    Detailed occupancy statistics with breakdowns and projections.
    
    Provides comprehensive occupancy analysis.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")

    # Current status
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total number of rooms",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total number of beds",
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Currently occupied beds",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Currently available beds",
    )
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Current occupancy percentage",
    )

    # By room type
    occupancy_by_room_type: List[RoomTypeOccupancy] = Field(
        default_factory=list,
        description="Occupancy breakdown by room type",
    )

    # Historical
    occupancy_history: List[OccupancyDataPoint] = Field(
        default_factory=list,
        description="Historical occupancy data",
    )

    # Projections
    projected_occupancy_30_days: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=100,
        description="Projected occupancy in 30 days",
    )
    projected_occupancy_90_days: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=100,
        description="Projected occupancy in 90 days",
    )


class MonthlyRevenue(BaseSchema):
    """
    Monthly revenue breakdown with detailed metrics.
    
    Represents revenue for a single month.
    """

    month: str = Field(
        ...,
        pattern=r"^\d{4}-\d{2}$",
        description="Month in YYYY-MM format",
    )
    revenue: Decimal = Field(
        ...,
        ge=0,
        description="Total revenue",
    )
    collected: Decimal = Field(
        ...,
        ge=0,
        description="Amount collected",
    )
    pending: Decimal = Field(
        ...,
        ge=0,
        description="Amount pending",
    )
    student_count: int = Field(
        ...,
        ge=0,
        description="Number of students",
    )
    average_revenue_per_student: Decimal = Field(
        ...,
        ge=0,
        description="Average revenue per student",
    )


class HostelRevenueStats(BaseSchema):
    """
    Detailed revenue statistics with breakdowns and growth metrics.
    
    Provides comprehensive financial analysis.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period",
    )

    # Totals
    total_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Total revenue for period",
    )
    total_expenses: Decimal = Field(
        ...,
        ge=0,
        description="Total expenses for period",
    )
    net_profit: Decimal = Field(
        ...,
        description="Net profit (can be negative)",
    )
    profit_margin: Decimal = Field(
        ...,
        ge=-100,
        le=100,
        description="Profit margin percentage",
    )

    # Revenue breakdown
    revenue_by_type: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Revenue breakdown by type (rent, mess, etc.)",
    )

    # Collection
    total_collected: Decimal = Field(
        ...,
        ge=0,
        description="Total amount collected",
    )
    total_pending: Decimal = Field(
        ...,
        ge=0,
        description="Total amount pending",
    )
    total_overdue: Decimal = Field(
        ...,
        ge=0,
        description="Total overdue amount",
    )
    collection_efficiency: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Collection efficiency percentage",
    )

    # Monthly breakdown
    monthly_revenue: List[MonthlyRevenue] = Field(
        default_factory=list,
        description="Month-by-month revenue breakdown",
    )

    # Comparison
    revenue_growth_mom: Decimal = Field(
        ...,
        description="Month-over-month growth percentage",
    )
    revenue_growth_yoy: Optional[Decimal] = Field(
        default=None,
        description="Year-over-year growth percentage",
    )


class AnalyticsRequest(BaseSchema):
    """
    Request schema for generating analytics.
    
    Specifies parameters for analytics generation.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    start_date: date = Field(..., description="Analytics start date")
    end_date: date = Field(..., description="Analytics end date")
    include_predictions: bool = Field(
        default=False,
        description="Include predictive analytics",
    )
    granularity: str = Field(
        default="daily",
        pattern=r"^(daily|weekly|monthly)$",
        description="Data granularity",
    )

    @model_validator(mode="after")
    def validate_date_range(self) -> "AnalyticsRequest":
        """Validate date range is reasonable."""
        if self.end_date < self.start_date:
            raise ValueError("end_date must be after or equal to start_date")
        
        # Check if date range is not too large (max 2 years)
        days_diff = (self.end_date - self.start_date).days
        if days_diff > 730:  # 2 years
            raise ValueError("Date range cannot exceed 2 years")
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_base.py ---
# --- File: app/schemas/hostel/hostel_base.py ---
"""
Hostel base schemas with enhanced validation and type safety.
"""

from __future__ import annotations

from datetime import time
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import HostelStatus, HostelType
from app.schemas.common.mixins import AddressMixin, ContactMixin, LocationMixin

__all__ = [
    "HostelBase",
    "HostelCreate",
    "HostelUpdate",
    "HostelMediaUpdate",
    "HostelSEOUpdate",
]


class HostelBase(BaseSchema, AddressMixin, ContactMixin, LocationMixin):
    """
    Base hostel schema with common fields.
    
    Combines address, contact, and location information with hostel-specific fields.
    """

    name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Hostel name",
        examples=["Green Valley Hostel"],
    )
    slug: str = Field(
        ...,
        min_length=3,
        max_length=255,
        pattern=r"^[a-z0-9-]+$",
        description="URL-friendly slug (lowercase, alphanumeric, hyphens only)",
        examples=["green-valley-hostel"],
    )
    description: Optional[str] = Field(
        default=None,
        max_length=2000,
        description="Detailed hostel description",
    )

    # Type
    hostel_type: HostelType = Field(
        ...,
        description="Hostel type (boys/girls/co-ed)",
    )

    # Website
    website_url: Optional[HttpUrl] = Field(
        default=None,
        description="Hostel official website URL",
    )

    # Pricing
    starting_price_monthly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Starting monthly price (lowest room type)",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="Currency code (ISO 4217)",
        examples=["INR", "USD"],
    )

    # Amenities and facilities
    amenities: List[str] = Field(
        default_factory=list,
        description="List of amenities (WiFi, AC, etc.)",
        examples=[["WiFi", "AC", "Laundry", "Hot Water"]],
    )
    facilities: List[str] = Field(
        default_factory=list,
        description="List of facilities (Gym, Library, etc.)",
        examples=[["Gym", "Library", "Common Room"]],
    )
    security_features: List[str] = Field(
        default_factory=list,
        description="Security features (CCTV, Guards, etc.)",
        examples=[["CCTV", "24/7 Security", "Biometric Access"]],
    )

    # Policies
    rules: Optional[str] = Field(
        default=None,
        max_length=5000,
        description="Hostel rules and regulations",
    )
    check_in_time: Optional[time] = Field(
        default=None,
        description="Standard check-in time",
        examples=["10:00:00"],
    )
    check_out_time: Optional[time] = Field(
        default=None,
        description="Standard check-out time",
        examples=["11:00:00"],
    )
    visitor_policy: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Visitor policy details",
    )
    late_entry_policy: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Late entry policy and timings",
    )

    # Location info
    nearby_landmarks: List[Dict[str, str]] = Field(
        default_factory=list,
        description="Nearby landmarks with name, type, and distance",
        examples=[[{"name": "Metro Station", "type": "transport", "distance": "500m"}]],
    )
    connectivity_info: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Public transport and connectivity information",
    )

    @field_validator("slug")
    @classmethod
    def validate_slug(cls, v: str) -> str:
        """
        Validate and normalize slug format.
        
        Ensures slug contains only lowercase letters, numbers, and hyphens.
        """
        v = v.lower().strip()
        if not v.replace("-", "").isalnum():
            raise ValueError(
                "Slug can only contain lowercase letters, numbers, and hyphens"
            )
        # Remove consecutive hyphens
        while "--" in v:
            v = v.replace("--", "-")
        # Remove leading/trailing hyphens
        v = v.strip("-")
        return v

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        """Validate and normalize hostel name."""
        v = v.strip()
        # Remove excessive whitespace
        v = " ".join(v.split())
        if v.isdigit():
            raise ValueError("Hostel name cannot be only numbers")
        return v

    @field_validator("amenities", "facilities", "security_features")
    @classmethod
    def validate_and_clean_lists(cls, v: List[str]) -> List[str]:
        """
        Validate and clean list fields.
        
        Removes empty strings, duplicates, and normalizes values.
        """
        if not v:
            return []
        # Clean and normalize
        cleaned = [item.strip() for item in v if item and item.strip()]
        # Remove duplicates while preserving order
        seen = set()
        unique = []
        for item in cleaned:
            item_lower = item.lower()
            if item_lower not in seen:
                seen.add(item_lower)
                unique.append(item)
        return unique

    @field_validator("nearby_landmarks")
    @classmethod
    def validate_landmarks(cls, v: List[Dict[str, str]]) -> List[Dict[str, str]]:
        """Validate nearby landmarks structure."""
        if not v:
            return []
        validated = []
        for landmark in v:
            if not isinstance(landmark, dict):
                continue
            if "name" in landmark and landmark["name"].strip():
                validated.append({
                    "name": landmark.get("name", "").strip(),
                    "type": landmark.get("type", "other").strip(),
                    "distance": landmark.get("distance", "").strip(),
                })
        return validated

    @field_validator("currency")
    @classmethod
    def validate_currency(cls, v: str) -> str:
        """Normalize currency code to uppercase."""
        return v.upper().strip()

    @model_validator(mode="after")
    def validate_check_times(self) -> "HostelBase":
        """Validate check-in and check-out times."""
        if (
            self.check_in_time is not None
            and self.check_out_time is not None
            and self.check_in_time >= self.check_out_time
        ):
            raise ValueError("Check-in time must be before check-out time")
        return self


class HostelCreate(HostelBase, BaseCreateSchema):
    """
    Schema for creating a hostel.
    
    Enforces required fields for hostel creation.
    """

    # Override to enforce requirements
    name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Hostel name (required)",
    )
    hostel_type: HostelType = Field(
        ...,
        description="Hostel type (required)",
    )
    contact_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Primary contact phone (required)",
    )
    address_line1: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Address line 1 (required)",
    )
    city: str = Field(
        ...,
        min_length=2,
        max_length=100,
        description="City (required)",
    )
    state: str = Field(
        ...,
        min_length=2,
        max_length=100,
        description="State (required)",
    )
    pincode: str = Field(
        ...,
        pattern=r"^\d{6}$",
        description="6-digit pincode (required)",
    )


class HostelUpdate(BaseUpdateSchema):
    """
    Schema for updating hostel information.
    
    All fields are optional for partial updates.
    """

    # Basic info
    name: Optional[str] = Field(
        default=None,
        min_length=3,
        max_length=255,
        description="Hostel name",
    )
    slug: Optional[str] = Field(
        default=None,
        min_length=3,
        max_length=255,
        pattern=r"^[a-z0-9-]+$",
        description="URL slug",
    )
    description: Optional[str] = Field(
        default=None,
        max_length=2000,
        description="Description",
    )
    hostel_type: Optional[HostelType] = Field(
        default=None,
        description="Hostel type",
    )

    # Address fields
    address_line1: Optional[str] = Field(
        default=None,
        min_length=5,
        max_length=255,
        description="Address line 1",
    )
    address_line2: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Address line 2",
    )
    city: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="City",
    )
    state: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="State",
    )
    pincode: Optional[str] = Field(
        default=None,
        pattern=r"^\d{6}$",
        description="Pincode",
    )
    country: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="Country",
    )

    # Contact
    contact_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact phone",
    )
    alternate_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Alternate phone",
    )
    contact_email: Optional[str] = Field(
        default=None,
        description="Contact email",
    )
    website_url: Optional[HttpUrl] = Field(
        default=None,
        description="Website URL",
    )

    # Location
    latitude: Optional[Decimal] = Field(
        default=None,
        ge=-90,
        le=90,
        description="Latitude",
    )
    longitude: Optional[Decimal] = Field(
        default=None,
        ge=-180,
        le=180,
        description="Longitude",
    )

    # Pricing
    starting_price_monthly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Starting monthly price",
    )
    currency: Optional[str] = Field(
        default=None,
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="Currency code",
    )

    # Lists
    amenities: Optional[List[str]] = Field(
        default=None,
        description="Amenities list",
    )
    facilities: Optional[List[str]] = Field(
        default=None,
        description="Facilities list",
    )
    security_features: Optional[List[str]] = Field(
        default=None,
        description="Security features list",
    )

    # Policies
    rules: Optional[str] = Field(
        default=None,
        max_length=5000,
        description="Rules and regulations",
    )
    check_in_time: Optional[time] = Field(
        default=None,
        description="Check-in time",
    )
    check_out_time: Optional[time] = Field(
        default=None,
        description="Check-out time",
    )
    visitor_policy: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Visitor policy",
    )
    late_entry_policy: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Late entry policy",
    )

    # Location info
    nearby_landmarks: Optional[List[Dict[str, str]]] = Field(
        default=None,
        description="Nearby landmarks",
    )
    connectivity_info: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Connectivity info",
    )

    # Media
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image URL",
    )
    gallery_images: Optional[List[str]] = Field(
        default=None,
        description="Gallery image URLs",
    )
    virtual_tour_url: Optional[HttpUrl] = Field(
        default=None,
        description="Virtual tour URL",
    )

    # Status
    status: Optional[HostelStatus] = Field(
        default=None,
        description="Operational status",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Active status",
    )

    # Apply same validators as base
    _validate_slug = field_validator("slug")(HostelBase.validate_slug.__func__)
    _validate_name = field_validator("name")(HostelBase.validate_name.__func__)
    _validate_lists = field_validator(
        "amenities", "facilities", "security_features"
    )(HostelBase.validate_and_clean_lists.__func__)
    _validate_currency = field_validator("currency")(
        HostelBase.validate_currency.__func__
    )

    @field_validator("contact_phone", "alternate_phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone numbers."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return v


class HostelMediaUpdate(BaseUpdateSchema):
    """
    Update hostel media (images, videos, virtual tours).
    
    Manages hostel visual content.
    """

    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover/main image URL",
    )
    gallery_images: List[str] = Field(
        default_factory=list,
        max_items=20,
        description="Gallery image URLs (max 20)",
    )
    virtual_tour_url: Optional[HttpUrl] = Field(
        default=None,
        description="360 virtual tour URL",
    )
    video_urls: Optional[List[HttpUrl]] = Field(
        default=None,
        max_items=5,
        description="Video URLs (max 5)",
    )

    @field_validator("gallery_images")
    @classmethod
    def validate_gallery_images(cls, v: List[str]) -> List[str]:
        """Validate gallery images."""
        if not v:
            return []
        # Remove empty strings and duplicates
        cleaned = [img.strip() for img in v if img and img.strip()]
        # Remove duplicates while preserving order
        seen = set()
        unique = []
        for img in cleaned:
            if img not in seen:
                seen.add(img)
                unique.append(img)
        return unique[:20]  # Limit to 20


class HostelSEOUpdate(BaseUpdateSchema):
    """
    Update hostel SEO metadata.
    
    Manages search engine optimization fields.
    """

    meta_title: Optional[str] = Field(
        default=None,
        min_length=10,
        max_length=60,
        description="SEO meta title (optimal: 50-60 chars)",
    )
    meta_description: Optional[str] = Field(
        default=None,
        min_length=50,
        max_length=160,
        description="SEO meta description (optimal: 150-160 chars)",
    )
    meta_keywords: Optional[str] = Field(
        default=None,
        max_length=500,
        description="SEO keywords (comma-separated)",
    )
    og_title: Optional[str] = Field(
        default=None,
        max_length=95,
        description="Open Graph title",
    )
    og_description: Optional[str] = Field(
        default=None,
        max_length=200,
        description="Open Graph description",
    )
    og_image_url: Optional[HttpUrl] = Field(
        default=None,
        description="Open Graph image URL",
    )

    @field_validator("meta_keywords")
    @classmethod
    def validate_keywords(cls, v: Optional[str]) -> Optional[str]:
        """Validate and clean meta keywords."""
        if v is None:
            return v
        # Split, clean, and rejoin
        keywords = [kw.strip() for kw in v.split(",") if kw.strip()]
        # Limit to 10 keywords
        return ", ".join(keywords[:10])

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_comparison.py ---
# --- File: app/schemas/hostel/hostel_comparison.py ---
"""
Hostel comparison schemas for side-by-side analysis.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import HostelType

__all__ = [
    "HostelComparisonRequest",
    "ComparisonResult",
    "ComparisonItem",
    "RoomTypeComparison",
    "ComparisonSummary",
    "PriceComparison",
    "AmenityComparison",
]


class HostelComparisonRequest(BaseCreateSchema):
    """
    Request to compare multiple hostels.
    
    Allows comparison of 2-4 hostels side by side.
    """

    hostel_ids: List[UUID] = Field(
        ...,
        min_length=2,
        max_length=4,
        description="2-4 hostel IDs to compare",
    )

    @field_validator("hostel_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[UUID]) -> List[UUID]:
        """Ensure hostel IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Hostel IDs must be unique")
        return v


class RoomTypeComparison(BaseSchema):
    """
    Room type details for comparison.
    
    Provides room-specific information for comparison.
    """

    room_type: str = Field(
        ...,
        description="Room type (single, double, etc.)",
    )
    price_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Monthly price",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds",
    )
    amenities: List[str] = Field(
        default_factory=list,
        description="Room-specific amenities",
    )


class ComparisonItem(BaseSchema):
    """
    Individual hostel data in comparison.
    
    Complete hostel information formatted for comparison.
    """

    id: UUID = Field(..., description="Hostel ID")
    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")
    hostel_type: HostelType = Field(..., description="Hostel type")

    # Location
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    address: str = Field(..., description="Full address")
    distance_from_center_km: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Distance from city center (km)",
    )

    # Pricing
    starting_price_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Starting monthly price",
    )
    price_range_monthly: str = Field(
        ...,
        description="Price range (e.g., '5,000 - 15,000')",
    )
    security_deposit: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Security deposit amount",
    )

    # Capacity
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total bed capacity",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Currently available beds",
    )

    # Ratings
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )
    rating_breakdown: Dict[str, int] = Field(
        default_factory=dict,
        description="Rating distribution (1-5 stars)",
    )

    # Amenities
    amenities: List[str] = Field(
        default_factory=list,
        description="General amenities",
    )
    facilities: List[str] = Field(
        default_factory=list,
        description="Facilities available",
    )
    security_features: List[str] = Field(
        default_factory=list,
        description="Security features",
    )

    # Room types
    room_types_available: List[str] = Field(
        default_factory=list,
        description="Available room types",
    )
    room_type_details: List[RoomTypeComparison] = Field(
        default_factory=list,
        description="Detailed room type information",
    )

    # Policies
    check_in_time: Optional[str] = Field(
        default=None,
        description="Check-in time",
    )
    check_out_time: Optional[str] = Field(
        default=None,
        description="Check-out time",
    )
    visitor_allowed: bool = Field(
        ...,
        description="Whether visitors are allowed",
    )

    # Media
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image URL",
    )
    total_images: int = Field(
        ...,
        ge=0,
        description="Total number of images",
    )
    has_virtual_tour: bool = Field(
        ...,
        description="Virtual tour availability",
    )

    # Highlights
    unique_features: List[str] = Field(
        default_factory=list,
        description="Unique selling points",
    )
    pros: List[str] = Field(
        default_factory=list,
        description="Advantages/pros",
    )
    cons: List[str] = Field(
        default_factory=list,
        description="Disadvantages/cons",
    )


class PriceComparison(BaseSchema):
    """
    Price comparison summary.
    
    Provides price statistics across compared hostels.
    """

    lowest_price: Decimal = Field(
        ...,
        ge=0,
        description="Lowest starting price",
    )
    highest_price: Decimal = Field(
        ...,
        ge=0,
        description="Highest starting price",
    )
    average_price: Decimal = Field(
        ...,
        ge=0,
        description="Average starting price",
    )
    price_difference_percentage: Decimal = Field(
        ...,
        ge=0,
        description="Percentage difference between lowest and highest",
    )


class AmenityComparison(BaseSchema):
    """
    Amenity comparison summary.
    
    Provides amenity statistics and unique features.
    """

    common_amenities: List[str] = Field(
        default_factory=list,
        description="Amenities present in all compared hostels",
    )
    unique_to_hostel: Dict[str, List[str]] = Field(
        default_factory=dict,
        description="Unique amenities per hostel (hostel_id: [amenities])",
    )
    total_unique_amenities: int = Field(
        ...,
        ge=0,
        description="Total number of unique amenity types",
    )


class ComparisonSummary(BaseSchema):
    """
    Comparison summary with recommendations.
    
    Provides quick insights and best options.
    """

    best_for_budget: UUID = Field(
        ...,
        description="Best value for money (hostel ID)",
    )
    best_rated: UUID = Field(
        ...,
        description="Highest rated hostel (hostel ID)",
    )
    best_location: Optional[UUID] = Field(
        default=None,
        description="Best location (hostel ID)",
    )
    most_amenities: UUID = Field(
        ...,
        description="Most amenities (hostel ID)",
    )
    best_availability: UUID = Field(
        ...,
        description="Best bed availability (hostel ID)",
    )

    price_comparison: PriceComparison = Field(
        ...,
        description="Price comparison statistics",
    )
    amenity_comparison: AmenityComparison = Field(
        ...,
        description="Amenity comparison statistics",
    )


class ComparisonResult(BaseSchema):
    """
    Complete comparison result.
    
    Aggregates all comparison data and insights.
    """

    hostels: List[ComparisonItem] = Field(
        ...,
        description="Hostels being compared",
    )
    comparison_criteria: List[str] = Field(
        ...,
        description="Criteria included in comparison",
    )
    summary: ComparisonSummary = Field(
        ...,
        description="Comparison summary and recommendations",
    )
    generated_at: datetime = Field(
        ...,
        description="Comparison generation timestamp",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_filter.py ---
# --- File: app/schemas/hostel/hostel_filter.py ---
"""
Hostel filter and sort schemas with advanced filtering options.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import HostelStatus, HostelType

__all__ = [
    "HostelFilterParams",
    "HostelSortOptions",
    "AdvancedFilters",
    "BulkFilterParams",
]


class HostelFilterParams(BaseFilterSchema):
    """
    Hostel listing filter parameters.
    
    Provides comprehensive filtering options for hostel queries.
    """

    # Text search
    search: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=255,
        description="Search in name, description, city",
    )

    # Location
    city: Optional[str] = Field(
        default=None,
        description="Filter by city",
    )
    state: Optional[str] = Field(
        default=None,
        description="Filter by state",
    )
    cities: Optional[List[str]] = Field(
        default=None,
        description="Filter by multiple cities",
    )

    # Type
    hostel_type: Optional[HostelType] = Field(
        default=None,
        description="Filter by hostel type",
    )
    hostel_types: Optional[List[HostelType]] = Field(
        default=None,
        description="Filter by multiple hostel types",
    )

    # Status
    status: Optional[HostelStatus] = Field(
        default=None,
        description="Filter by operational status",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Filter by active status",
    )
    is_public: Optional[bool] = Field(
        default=None,
        description="Filter by public visibility",
    )
    is_featured: Optional[bool] = Field(
        default=None,
        description="Filter by featured status",
    )
    is_verified: Optional[bool] = Field(
        default=None,
        description="Filter by verification status",
    )

    # Price range
    price_min: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Minimum monthly price",
    )
    price_max: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Maximum monthly price",
    )

    # Rating
    min_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Minimum average rating",
    )

    # Availability
    has_availability: Optional[bool] = Field(
        default=None,
        description="Filter by bed availability",
    )
    min_available_beds: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum available beds required",
    )

    # Amenities
    amenities: Optional[List[str]] = Field(
        default=None,
        description="Required amenities (all must be present)",
    )

    # Admin filters
    admin_id: Optional[UUID] = Field(
        default=None,
        description="Filter by assigned admin (admin only)",
    )
    has_subscription: Optional[bool] = Field(
        default=None,
        description="Filter by subscription status (admin only)",
    )

    @field_validator("price_max")
    @classmethod
    def validate_price_range(cls, v: Optional[Decimal], info) -> Optional[Decimal]:
        """Validate price range."""
        if v is not None:
            price_min = info.data.get("price_min")
            if price_min is not None and v < price_min:
                raise ValueError("price_max must be greater than or equal to price_min")
        return v


class HostelSortOptions(BaseFilterSchema):
    """
    Hostel sorting options.
    
    Defines available sort criteria and order.
    """

    sort_by: str = Field(
        default="created_at",
        pattern=r"^(name|city|price|rating|occupancy|created_at|updated_at)$",
        description="Field to sort by",
    )
    sort_order: str = Field(
        default="desc",
        pattern=r"^(asc|desc)$",
        description="Sort order (ascending/descending)",
    )

    @field_validator("sort_order")
    @classmethod
    def normalize_sort_order(cls, v: str) -> str:
        """Normalize sort order to lowercase."""
        return v.lower()


class AdvancedFilters(BaseFilterSchema):
    """
    Advanced filtering options.
    
    Provides additional filtering criteria for complex queries.
    """

    # Date filters
    created_after: Optional[date] = Field(
        default=None,
        description="Filter hostels created after this date",
    )
    created_before: Optional[date] = Field(
        default=None,
        description="Filter hostels created before this date",
    )

    # Occupancy
    occupancy_min: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=100,
        description="Minimum occupancy percentage",
    )
    occupancy_max: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=100,
        description="Maximum occupancy percentage",
    )

    # Reviews
    min_reviews: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum number of reviews",
    )

    # Rooms
    min_rooms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum number of rooms",
    )
    max_rooms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Maximum number of rooms",
    )

    # Revenue (admin only)
    revenue_min: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Minimum monthly revenue (admin only)",
    )
    revenue_max: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Maximum monthly revenue (admin only)",
    )

    @field_validator("created_before")
    @classmethod
    def validate_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate date range."""
        if v is not None:
            created_after = info.data.get("created_after")
            if created_after is not None and v < created_after:
                raise ValueError("created_before must be after or equal to created_after")
        return v

    @field_validator("occupancy_max")
    @classmethod
    def validate_occupancy_range(cls, v: Optional[Decimal], info) -> Optional[Decimal]:
        """Validate occupancy range."""
        if v is not None:
            occupancy_min = info.data.get("occupancy_min")
            if occupancy_min is not None and v < occupancy_min:
                raise ValueError("occupancy_max must be >= occupancy_min")
        return v


class BulkFilterParams(BaseFilterSchema):
    """
    Bulk operation filter parameters.
    
    Allows filtering hostels for bulk operations.
    """

    hostel_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of hostel IDs (max 100)",
    )

    # Or use filters
    use_filters: bool = Field(
        default=False,
        description="Use filter criteria instead of explicit IDs",
    )
    filters: Optional[HostelFilterParams] = Field(
        default=None,
        description="Filter criteria (if use_filters is True)",
    )

    @field_validator("hostel_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[UUID]) -> List[UUID]:
        """Ensure hostel IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Hostel IDs must be unique")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_public.py ---
# --- File: app/schemas/hostel/hostel_public.py ---
"""
Public hostel profile schemas for visitor-facing content.
"""

from __future__ import annotations

from datetime import time
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import HostelType

__all__ = [
    "PublicHostelCard",
    "PublicRoomType",
    "PublicHostelProfile",
    "PublicHostelList",
]


class PublicHostelCard(BaseSchema):
    """
    Hostel card for public listing/search results.
    
    Provides essential information for hostel browsing.
    """

    id: UUID = Field(..., description="Hostel ID")
    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")
    hostel_type: HostelType = Field(..., description="Hostel type")
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    starting_price_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Starting monthly price",
    )
    currency: str = Field(..., description="Currency code")
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds",
    )
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image URL",
    )
    is_featured: bool = Field(
        ...,
        description="Featured status",
    )
    amenities: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 amenities for quick view",
    )
    distance_km: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Distance from search location (if applicable)",
    )


class PublicRoomType(BaseSchema):
    """
    Public room type information.
    
    Provides room-specific details for visitors.
    """

    room_type: str = Field(
        ...,
        description="Room type (single, double, etc.)",
    )
    price_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Monthly price",
    )
    price_quarterly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Quarterly price (if available)",
    )
    price_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Yearly price (if available)",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds of this type",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds of this type",
    )
    room_amenities: List[str] = Field(
        default_factory=list,
        description="Room-specific amenities",
    )
    room_images: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Room images (max 10)",
    )
    room_size_sqft: Optional[int] = Field(
        default=None,
        ge=0,
        description="Room size in square feet",
    )


class PublicHostelProfile(BaseSchema):
    """
    Complete public hostel profile.
    
    Comprehensive hostel information for detail pages.
    """

    id: UUID = Field(..., description="Hostel ID")
    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")
    description: Optional[str] = Field(
        default=None,
        description="Hostel description",
    )
    hostel_type: HostelType = Field(..., description="Hostel type")

    # Contact (public)
    contact_phone: str = Field(..., description="Contact phone number")
    contact_email: Optional[str] = Field(
        default=None,
        description="Contact email",
    )
    website_url: Optional[str] = Field(
        default=None,
        description="Official website URL",
    )

    # Address
    address_line1: str = Field(..., description="Address line 1")
    address_line2: Optional[str] = Field(
        default=None,
        description="Address line 2",
    )
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    pincode: str = Field(..., description="Pincode")
    latitude: Optional[Decimal] = Field(
        default=None,
        description="Latitude for map display",
    )
    longitude: Optional[Decimal] = Field(
        default=None,
        description="Longitude for map display",
    )

    # Pricing
    starting_price_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Starting monthly price",
    )
    currency: str = Field(..., description="Currency code")

    # Availability
    available_beds: int = Field(
        ...,
        ge=0,
        description="Total available beds",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total bed capacity",
    )

    # Ratings
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )
    rating_breakdown: Dict[str, int] = Field(
        default_factory=dict,
        description="Rating distribution {1: count, 2: count, ...}",
    )

    # Features
    amenities: List[str] = Field(
        default_factory=list,
        description="Available amenities",
    )
    facilities: List[str] = Field(
        default_factory=list,
        description="Available facilities",
    )
    security_features: List[str] = Field(
        default_factory=list,
        description="Security features",
    )

    # Policies
    rules: Optional[str] = Field(
        default=None,
        description="Hostel rules and regulations",
    )
    check_in_time: Optional[time] = Field(
        default=None,
        description="Standard check-in time",
    )
    check_out_time: Optional[time] = Field(
        default=None,
        description="Standard check-out time",
    )
    visitor_policy: Optional[str] = Field(
        default=None,
        description="Visitor policy",
    )

    # Location
    nearby_landmarks: List[Dict[str, str]] = Field(
        default_factory=list,
        description="Nearby landmarks with details",
    )
    connectivity_info: Optional[str] = Field(
        default=None,
        description="Public transport connectivity",
    )

    # Media
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image URL",
    )
    gallery_images: List[str] = Field(
        default_factory=list,
        description="Gallery images",
    )
    virtual_tour_url: Optional[str] = Field(
        default=None,
        description="360 virtual tour URL",
    )

    # Room types available
    room_types: List[PublicRoomType] = Field(
        default_factory=list,
        description="Available room types with pricing",
    )

    # Additional info
    established_year: Optional[int] = Field(
        default=None,
        ge=1900,
        le=2100,
        description="Year established",
    )
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total number of rooms",
    )


class PublicHostelList(BaseSchema):
    """
    List of public hostels with metadata.
    
    Response schema for hostel listing pages.
    """

    hostels: List[PublicHostelCard] = Field(
        ...,
        description="List of hostels",
    )
    total_count: int = Field(
        ...,
        ge=0,
        description="Total number of hostels matching criteria",
    )
    filters_applied: Dict[str, str] = Field(
        default_factory=dict,
        description="Summary of applied filters",
    )
    page: int = Field(
        default=1,
        ge=1,
        description="Current page number",
    )
    page_size: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Items per page",
    )
    total_pages: int = Field(
        ...,
        ge=0,
        description="Total number of pages",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_response.py ---
# --- File: app/schemas/hostel/hostel_response.py ---
"""
Hostel response schemas for API responses.
"""

from __future__ import annotations

from datetime import datetime, time
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import HostelStatus, HostelType

__all__ = [
    "HostelResponse",
    "HostelDetail",
    "HostelListItem",
    "HostelStats",
]


class HostelResponse(BaseResponseSchema):
    """
    Basic hostel response schema.
    
    Standard response for hostel operations.
    """

    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")
    hostel_type: HostelType = Field(..., description="Hostel type")
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    starting_price_monthly: Optional[Decimal] = Field(
        default=None,
        description="Starting monthly price",
    )
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total number of rooms",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds",
    )
    is_public: bool = Field(..., description="Public visibility")
    is_featured: bool = Field(..., description="Featured status")
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image URL",
    )
    status: HostelStatus = Field(..., description="Operational status")


class HostelDetail(BaseResponseSchema):
    """
    Detailed hostel information.
    
    Comprehensive hostel data for detail views.
    """

    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")
    description: Optional[str] = Field(
        default=None,
        description="Hostel description",
    )

    # Type and contact
    hostel_type: HostelType = Field(..., description="Hostel type")
    contact_email: Optional[str] = Field(
        default=None,
        description="Contact email",
    )
    contact_phone: str = Field(..., description="Contact phone")
    alternate_phone: Optional[str] = Field(
        default=None,
        description="Alternate phone",
    )
    website_url: Optional[str] = Field(
        default=None,
        description="Website URL",
    )

    # Address
    address_line1: str = Field(..., description="Address line 1")
    address_line2: Optional[str] = Field(
        default=None,
        description="Address line 2",
    )
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    pincode: str = Field(..., description="Pincode")
    country: str = Field(..., description="Country")
    latitude: Optional[Decimal] = Field(
        default=None,
        description="Latitude",
    )
    longitude: Optional[Decimal] = Field(
        default=None,
        description="Longitude",
    )

    # Pricing
    starting_price_monthly: Optional[Decimal] = Field(
        default=None,
        description="Starting monthly price",
    )
    currency: str = Field(..., description="Currency code")

    # Capacity
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total number of rooms",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total number of beds",
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Occupied beds",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds",
    )

    # Ratings
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total reviews",
    )

    # Features
    amenities: List[str] = Field(
        default_factory=list,
        description="Available amenities",
    )
    facilities: List[str] = Field(
        default_factory=list,
        description="Available facilities",
    )
    security_features: List[str] = Field(
        default_factory=list,
        description="Security features",
    )

    # Policies
    rules: Optional[str] = Field(
        default=None,
        description="Hostel rules",
    )
    check_in_time: Optional[time] = Field(
        default=None,
        description="Check-in time",
    )
    check_out_time: Optional[time] = Field(
        default=None,
        description="Check-out time",
    )
    visitor_policy: Optional[str] = Field(
        default=None,
        description="Visitor policy",
    )
    late_entry_policy: Optional[str] = Field(
        default=None,
        description="Late entry policy",
    )

    # Location info
    nearby_landmarks: List[dict] = Field(
        default_factory=list,
        description="Nearby landmarks",
    )
    connectivity_info: Optional[str] = Field(
        default=None,
        description="Connectivity information",
    )

    # Media
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image URL",
    )
    gallery_images: List[str] = Field(
        default_factory=list,
        description="Gallery images",
    )
    virtual_tour_url: Optional[str] = Field(
        default=None,
        description="Virtual tour URL",
    )

    # Status
    is_public: bool = Field(..., description="Public visibility")
    is_featured: bool = Field(..., description="Featured status")
    is_verified: bool = Field(..., description="Verification status")
    status: HostelStatus = Field(..., description="Operational status")
    is_active: bool = Field(..., description="Active status")

    # SEO
    meta_title: Optional[str] = Field(
        default=None,
        description="SEO meta title",
    )
    meta_description: Optional[str] = Field(
        default=None,
        description="SEO meta description",
    )
    meta_keywords: Optional[str] = Field(
        default=None,
        description="SEO keywords",
    )


class HostelListItem(BaseSchema):
    """
    Hostel list item for list views.
    
    Minimal information for efficient list rendering.
    """

    id: UUID = Field(..., description="Hostel ID")
    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL slug")
    hostel_type: HostelType = Field(..., description="Hostel type")
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    starting_price_monthly: Optional[Decimal] = Field(
        default=None,
        description="Starting price",
    )
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total reviews",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds",
    )
    cover_image_url: Optional[str] = Field(
        default=None,
        description="Cover image",
    )
    is_featured: bool = Field(..., description="Featured status")
    distance_km: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Distance from search location",
    )


class HostelStats(BaseSchema):
    """
    Hostel statistics summary.
    
    Key metrics and statistics for a hostel.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")

    # Occupancy
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total rooms",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds",
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Occupied beds",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds",
    )
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Occupancy percentage",
    )

    # Revenue
    total_revenue_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Total monthly revenue",
    )
    total_outstanding: Decimal = Field(
        ...,
        ge=0,
        description="Total outstanding payments",
    )

    # Students
    total_students: int = Field(
        ...,
        ge=0,
        description="Total registered students",
    )
    active_students: int = Field(
        ...,
        ge=0,
        description="Active students",
    )

    # Complaints
    open_complaints: int = Field(
        ...,
        ge=0,
        description="Open complaints",
    )
    resolved_complaints: int = Field(
        ...,
        ge=0,
        description="Resolved complaints",
    )

    # Bookings
    pending_bookings: int = Field(
        ...,
        ge=0,
        description="Pending booking requests",
    )
    confirmed_bookings: int = Field(
        ...,
        ge=0,
        description="Confirmed bookings",
    )

    # Reviews
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Average rating",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total reviews",
    )

    # Last updated
    updated_at: datetime = Field(..., description="Last update timestamp")

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\hostel_search.py ---
# --- File: app/schemas/hostel/hostel_search.py ---
"""
Hostel search schemas with comprehensive search and filtering.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseFilterSchema, BaseSchema
from app.schemas.common.enums import HostelType, RoomType
from app.schemas.hostel.hostel_public import PublicHostelCard

__all__ = [
    "HostelSearchRequest",
    "HostelSearchResponse",
    "SearchFacets",
    "FacetItem",
    "PriceRangeFacet",
    "RatingFacet",
    "HostelSearchFilters",
]


class HostelSearchRequest(BaseFilterSchema):
    """
    Hostel search request with comprehensive filtering.
    
    Supports text search, location-based search, and various filters.
    """

    # Text search
    query: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=255,
        description="Search query (name, description, city)",
    )

    # Location filters
    city: Optional[str] = Field(
        default=None,
        description="Filter by city name",
    )
    state: Optional[str] = Field(
        default=None,
        description="Filter by state name",
    )
    pincode: Optional[str] = Field(
        default=None,
        pattern=r"^\d{6}$",
        description="Filter by 6-digit pincode",
    )

    # Location-based search (radius)
    latitude: Optional[Decimal] = Field(
        default=None,
        ge=-90,
        le=90,
        description="Latitude for radius search",
    )
    longitude: Optional[Decimal] = Field(
        default=None,
        ge=-180,
        le=180,
        description="Longitude for radius search",
    )
    radius_km: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=50,
        description="Search radius in kilometers",
    )

    # Type filter
    hostel_type: Optional[HostelType] = Field(
        default=None,
        description="Filter by hostel type",
    )

    # Price filter
    min_price: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Minimum monthly price",
    )
    max_price: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Maximum monthly price",
    )

    # Room type
    room_type: Optional[RoomType] = Field(
        default=None,
        description="Preferred room type",
    )

    # Amenities filter
    amenities: Optional[List[str]] = Field(
        default=None,
        max_length=10,
        description="Required amenities (all must be present)",
    )

    # Availability
    available_beds_min: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum available beds required",
    )

    # Rating filter
    min_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Minimum average rating",
    )

    # Features
    verified_only: bool = Field(
        default=False,
        description="Show only verified hostels",
    )
    featured_only: bool = Field(
        default=False,
        description="Show only featured hostels",
    )

    # Sort
    sort_by: str = Field(
        default="relevance",
        pattern=r"^(relevance|price_low|price_high|rating|distance|newest)$",
        description="Sort criteria",
    )

    # Pagination
    page: int = Field(
        default=1,
        ge=1,
        description="Page number",
    )
    page_size: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Results per page",
    )

    @model_validator(mode="after")
    def validate_location_search(self) -> "HostelSearchRequest":
        """Validate location-based search parameters."""
        # If radius search, both lat/lon and radius are required
        has_lat = self.latitude is not None
        has_lon = self.longitude is not None
        has_radius = self.radius_km is not None

        if any([has_lat, has_lon, has_radius]):
            if not all([has_lat, has_lon, has_radius]):
                raise ValueError(
                    "For radius search, latitude, longitude, and radius_km "
                    "are all required"
                )
        return self

    @field_validator("max_price")
    @classmethod
    def validate_price_range(cls, v: Optional[Decimal], info) -> Optional[Decimal]:
        """Validate price range."""
        if v is not None:
            min_price = info.data.get("min_price")
            if min_price is not None and v < min_price:
                raise ValueError("max_price must be >= min_price")
        return v


class FacetItem(BaseSchema):
    """
    Facet item with count.
    
    Represents a filter option with result count.
    """

    value: str = Field(..., description="Facet value")
    label: str = Field(..., description="Display label")
    count: int = Field(
        ...,
        ge=0,
        description="Number of results with this value",
    )


class PriceRangeFacet(BaseSchema):
    """
    Price range facet.
    
    Represents a price range filter option.
    """

    min_price: Decimal = Field(..., ge=0, description="Range minimum")
    max_price: Decimal = Field(..., ge=0, description="Range maximum")
    label: str = Field(..., description="Display label")
    count: int = Field(
        ...,
        ge=0,
        description="Number of results in range",
    )


class RatingFacet(BaseSchema):
    """
    Rating facet.
    
    Represents a rating filter option.
    """

    min_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        description="Minimum rating",
    )
    label: str = Field(..., description="Display label")
    count: int = Field(
        ...,
        ge=0,
        description="Number of results",
    )


class SearchFacets(BaseSchema):
    """
    Search facets for filtering.
    
    Provides available filter options with counts.
    """

    cities: List[FacetItem] = Field(
        default_factory=list,
        description="Available cities with result counts",
    )
    hostel_types: List[FacetItem] = Field(
        default_factory=list,
        description="Hostel types with result counts",
    )
    price_ranges: List[PriceRangeFacet] = Field(
        default_factory=list,
        description="Price ranges with result counts",
    )
    amenities: List[FacetItem] = Field(
        default_factory=list,
        description="Available amenities with result counts",
    )
    ratings: List[RatingFacet] = Field(
        default_factory=list,
        description="Rating distribution",
    )


class HostelSearchResponse(BaseSchema):
    """
    Hostel search response.
    
    Complete search results with metadata and facets.
    """

    results: List[PublicHostelCard] = Field(
        ...,
        description="Search results",
    )
    total_results: int = Field(
        ...,
        ge=0,
        description="Total matching hostels",
    )
    total_pages: int = Field(
        ...,
        ge=0,
        description="Total number of pages",
    )
    current_page: int = Field(
        ...,
        ge=1,
        description="Current page number",
    )
    filters_applied: dict = Field(
        default_factory=dict,
        description="Summary of applied filters",
    )
    facets: SearchFacets = Field(
        ...,
        description="Available filter facets",
    )


class HostelSearchFilters(BaseFilterSchema):
    """
    Advanced search filters.
    
    Additional filtering options for hostel search.
    """

    # Gender
    gender: Optional[str] = Field(
        default=None,
        pattern=r"^(boys|girls|co_ed)$",
        description="Gender preference",
    )

    # Facilities (boolean filters)
    has_wifi: Optional[bool] = Field(
        default=None,
        description="Has WiFi",
    )
    has_ac: Optional[bool] = Field(
        default=None,
        description="Has AC",
    )
    has_laundry: Optional[bool] = Field(
        default=None,
        description="Has laundry facility",
    )
    has_parking: Optional[bool] = Field(
        default=None,
        description="Has parking",
    )
    has_gym: Optional[bool] = Field(
        default=None,
        description="Has gym/fitness center",
    )
    has_mess: Optional[bool] = Field(
        default=None,
        description="Has mess/canteen",
    )

    # Security
    has_cctv: Optional[bool] = Field(
        default=None,
        description="Has CCTV surveillance",
    )
    has_security_guard: Optional[bool] = Field(
        default=None,
        description="Has security guard",
    )

    # Rules
    allow_visitors: Optional[bool] = Field(
        default=None,
        description="Allows visitors",
    )

    # Availability
    check_in_date: Optional[date] = Field(
        default=None,
        description="Desired check-in date",
    )

    @field_validator("check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate check-in date is not in the past."""
        if v is not None:
            from datetime import date as dt
            if v < dt.today():
                raise ValueError("Check-in date cannot be in the past")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\hostel\__init__.py ---
from __future__ import annotations

from app.schemas.hostel.hostel_admin import (
    HostelAdminView,
    HostelCapacityUpdate,
    HostelSettings,
    HostelStatusUpdate,
    HostelVisibilityUpdate,
)
from app.schemas.hostel.hostel_analytics import (
    AnalyticsRequest,
    BookingAnalytics,
    ComplaintAnalytics,
    HostelAnalytics,
    HostelOccupancyStats,
    HostelRevenueStats,
    OccupancyAnalytics,
    RevenueAnalytics,
    ReviewAnalytics,
)
from app.schemas.hostel.hostel_base import (
    HostelBase,
    HostelCreate,
    HostelMediaUpdate,
    HostelSEOUpdate,
    HostelUpdate,
)
from app.schemas.hostel.hostel_comparison import (
    ComparisonItem,
    ComparisonResult,
    HostelComparisonRequest,
)
from app.schemas.hostel.hostel_filter import (
    AdvancedFilters,
    BulkFilterParams,
    HostelFilterParams,
    HostelSortOptions,
)
from app.schemas.hostel.hostel_public import (
    PublicHostelCard,
    PublicHostelList,
    PublicHostelProfile,
    PublicRoomType,
)
from app.schemas.hostel.hostel_response import (
    HostelDetail,
    HostelListItem,
    HostelResponse,
    HostelStats,
)
from app.schemas.hostel.hostel_search import (
    HostelSearchFilters,
    HostelSearchRequest,
    HostelSearchResponse,
    SearchFacets,
)

__all__ = [
    # Base
    "HostelBase",
    "HostelCreate",
    "HostelUpdate",
    "HostelMediaUpdate",
    "HostelSEOUpdate",
    # Response
    "HostelResponse",
    "HostelDetail",
    "HostelListItem",
    "HostelStats",
    # Public
    "PublicHostelProfile",
    "PublicHostelList",
    "PublicHostelCard",
    "PublicRoomType",
    # Admin
    "HostelAdminView",
    "HostelSettings",
    "HostelVisibilityUpdate",
    "HostelCapacityUpdate",
    "HostelStatusUpdate",
    # Search
    "HostelSearchRequest",
    "HostelSearchResponse",
    "HostelSearchFilters",
    "SearchFacets",
    # Filter
    "HostelFilterParams",
    "HostelSortOptions",
    "AdvancedFilters",
    "BulkFilterParams",
    # Analytics
    "HostelAnalytics",
    "OccupancyAnalytics",
    "RevenueAnalytics",
    "BookingAnalytics",
    "ComplaintAnalytics",
    "ReviewAnalytics",
    "HostelOccupancyStats",
    "HostelRevenueStats",
    "AnalyticsRequest",
    # Comparison
    "HostelComparisonRequest",
    "ComparisonResult",
    "ComparisonItem",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\inquiry =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\inquiry\inquiry_base.py ---
# --- File: app/schemas/inquiry/inquiry_base.py ---
"""
Base visitor inquiry schemas with comprehensive validation.

This module defines the core inquiry schemas for managing visitor
inquiries about hostel availability and bookings.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import InquirySource, InquiryStatus, RoomType

__all__ = [
    "InquiryBase",
    "InquiryCreate",
    "InquiryUpdate",
]


class InquiryBase(BaseSchema):
    """
    Base visitor inquiry schema with common fields.
    
    Contains all core inquiry information including hostel selection,
    visitor contact details, preferences, and inquiry metadata.
    """

    hostel_id: UUID = Field(
        ...,
        description="Unique identifier of the hostel being inquired about",
    )

    # Visitor Contact Information
    visitor_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Full name of the visitor making the inquiry",
    )
    visitor_email: EmailStr = Field(
        ...,
        description="Email address for communication",
    )
    visitor_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact phone number (international format supported)",
    )

    # Inquiry Preferences
    preferred_check_in_date: Optional[date] = Field(
        None,
        description="Preferred or approximate check-in date",
    )
    stay_duration_months: Optional[int] = Field(
        None,
        ge=1,
        le=36,
        description="Intended stay duration in months (1-36)",
    )
    room_type_preference: Optional[RoomType] = Field(
        None,
        description="Preferred room type if any",
    )

    # Inquiry Details
    message: Optional[str] = Field(
        None,
        max_length=2000,
        description="Additional message or questions from visitor",
    )

    # Metadata
    inquiry_source: InquirySource = Field(
        InquirySource.WEBSITE,
        description="Source channel of the inquiry",
    )

    status: InquiryStatus = Field(
        InquiryStatus.NEW,
        description="Current status of the inquiry",
    )

    @field_validator("visitor_name")
    @classmethod
    def validate_visitor_name(cls, v: str) -> str:
        """Validate and normalize visitor name."""
        v = v.strip()
        
        if len(v) < 2:
            raise ValueError("Visitor name must be at least 2 characters")
        
        # Check for at least one word
        if not v.split():
            raise ValueError("Visitor name cannot be empty or only whitespace")
        
        # Check for numbers (names shouldn't contain digits)
        if any(char.isdigit() for char in v):
            raise ValueError("Visitor name should not contain numbers")
        
        return v

    @field_validator("visitor_phone")
    @classmethod
    def validate_and_normalize_phone(cls, v: str) -> str:
        """Validate and normalize phone number."""
        # Remove common formatting characters
        v = v.replace(" ", "").replace("-", "").replace("(", "").replace(")", "")
        
        # Check minimum length
        if len(v) < 10:
            raise ValueError("Phone number must be at least 10 digits")
        
        return v

    @field_validator("preferred_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate preferred check-in date."""
        if v is not None:
            # Allow past dates for inquiries (they might be inquiring for future)
            # but warn if too far in the past
            days_ago = (date.today() - v).days
            if days_ago > 7:
                # This might be an error, but we'll allow it
                # In production, you might want to log a warning
                pass
            
            # Warn if too far in the future (> 1 year)
            days_ahead = (v - date.today()).days
            if days_ahead > 365:
                # Log warning but allow
                pass
        
        return v

    @field_validator("message")
    @classmethod
    def clean_message(cls, v: Optional[str]) -> Optional[str]:
        """Clean and validate message."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
            
            # Check for excessive length
            if len(v) > 2000:
                raise ValueError("Message cannot exceed 2000 characters")
        
        return v

    @property
    def has_date_preference(self) -> bool:
        """Check if visitor has specified a preferred check-in date."""
        return self.preferred_check_in_date is not None

    @property
    def has_duration_preference(self) -> bool:
        """Check if visitor has specified stay duration."""
        return self.stay_duration_months is not None

    @property
    def has_room_preference(self) -> bool:
        """Check if visitor has specified room type preference."""
        return self.room_type_preference is not None

    @property
    def is_detailed_inquiry(self) -> bool:
        """Check if inquiry has detailed information."""
        return (
            self.has_date_preference
            and self.has_duration_preference
            and self.has_room_preference
        )


class InquiryCreate(InquiryBase, BaseCreateSchema):
    """
    Schema for creating a new visitor inquiry.
    
    All base fields are inherited. Status is automatically set to NEW.
    """

    # Override status to always start as NEW
    status: InquiryStatus = Field(
        InquiryStatus.NEW,
        description="Status is automatically set to NEW for new inquiries",
    )

    @field_validator("status")
    @classmethod
    def validate_initial_status(cls, v: InquiryStatus) -> InquiryStatus:
        """Ensure new inquiries start with NEW status."""
        if v != InquiryStatus.NEW:
            # Force to NEW regardless of input
            return InquiryStatus.NEW
        return v


class InquiryUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing inquiry.
    
    All fields are optional, allowing partial updates.
    Typically used by admins to add notes or update contact info.
    """

    # Visitor Contact (rarely updated, but allowed)
    visitor_name: Optional[str] = Field(
        None,
        min_length=2,
        max_length=255,
        description="Update visitor name",
    )
    visitor_email: Optional[EmailStr] = Field(
        None,
        description="Update visitor email",
    )
    visitor_phone: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Update visitor phone",
    )

    # Preferences (can be updated as inquiry is refined)
    preferred_check_in_date: Optional[date] = Field(
        None,
        description="Update preferred check-in date",
    )
    stay_duration_months: Optional[int] = Field(
        None,
        ge=1,
        le=36,
        description="Update stay duration",
    )
    room_type_preference: Optional[RoomType] = Field(
        None,
        description="Update room type preference",
    )

    # Message (can be appended or updated)
    message: Optional[str] = Field(
        None,
        max_length=2000,
        description="Update inquiry message",
    )

    # Status (usually updated via separate status update endpoint)
    status: Optional[InquiryStatus] = Field(
        None,
        description="Update inquiry status",
    )

    @field_validator("visitor_name")
    @classmethod
    def validate_visitor_name(cls, v: Optional[str]) -> Optional[str]:
        """Validate visitor name if provided."""
        if v is not None:
            v = v.strip()
            if len(v) < 2:
                raise ValueError("Visitor name must be at least 2 characters")
            if any(char.isdigit() for char in v):
                raise ValueError("Visitor name should not contain numbers")
        return v

    @field_validator("visitor_phone")
    @classmethod
    def validate_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone number if provided."""
        if v is not None:
            v = v.replace(" ", "").replace("-", "")
            if len(v) < 10:
                raise ValueError("Phone number must be at least 10 digits")
        return v

    @field_validator("message")
    @classmethod
    def clean_message(cls, v: Optional[str]) -> Optional[str]:
        """Clean message if provided."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\inquiry\inquiry_filters.py ---
# --- File: app/schemas/inquiry/inquiry_filters.py ---
"""
Inquiry filter and search schemas.

This module defines schemas for filtering, searching, and sorting
inquiry data.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import InquirySource, InquiryStatus, RoomType

__all__ = [
    "InquiryFilterParams",
    "InquirySearchRequest",
    "InquirySortOptions",
    "InquiryExportRequest",
]


class InquiryFilterParams(BaseFilterSchema):
    """
    Comprehensive inquiry filter parameters.
    
    Supports filtering by status, dates, hostel, source, and more.
    """

    # Text Search
    search: Optional[str] = Field(
        None,
        max_length=255,
        description="Search in visitor name, email, or phone",
    )

    # Hostel Filter
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by specific hostel",
    )
    hostel_ids: Optional[List[UUID]] = Field(
        None,
        max_length=20,
        description="Filter by multiple hostels",
    )

    # Status Filter
    status: Optional[InquiryStatus] = Field(
        None,
        description="Filter by specific status",
    )
    statuses: Optional[List[InquiryStatus]] = Field(
        None,
        max_length=10,
        description="Filter by multiple statuses",
    )

    # Source Filter
    source: Optional[InquirySource] = Field(
        None,
        description="Filter by inquiry source",
    )
    sources: Optional[List[InquirySource]] = Field(
        None,
        max_length=10,
        description="Filter by multiple sources",
    )

    # Date Filters
    created_from: Optional[date] = Field(
        None,
        description="Filter inquiries created from this date",
    )
    created_to: Optional[date] = Field(
        None,
        description="Filter inquiries created until this date",
    )

    # Check-in Date Filter
    check_in_from: Optional[date] = Field(
        None,
        description="Filter by preferred check-in date from",
    )
    check_in_to: Optional[date] = Field(
        None,
        description="Filter by preferred check-in date to",
    )

    # Room Type Filter
    room_type: Optional[RoomType] = Field(
        None,
        description="Filter by room type preference",
    )

    # Assignment Filters
    assigned_to: Optional[UUID] = Field(
        None,
        description="Filter by assigned admin",
    )
    is_assigned: Optional[bool] = Field(
        None,
        description="Filter by assignment status",
    )

    # Contact Status
    is_contacted: Optional[bool] = Field(
        None,
        description="Filter by whether inquiry has been contacted",
    )

    # Urgency Filters
    is_urgent: Optional[bool] = Field(
        None,
        description="Show only urgent inquiries (new and recent)",
    )
    is_stale: Optional[bool] = Field(
        None,
        description="Show only stale inquiries (old without contact)",
    )

    @field_validator("created_to")
    @classmethod
    def validate_created_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate created date range."""
        created_from = info.data.get("created_from")
        if v is not None and created_from is not None:
            if v < created_from:
                raise ValueError("created_to must be after or equal to created_from")
        return v

    @field_validator("check_in_to")
    @classmethod
    def validate_check_in_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate check-in date range."""
        check_in_from = info.data.get("check_in_from")
        if v is not None and check_in_from is not None:
            if v < check_in_from:
                raise ValueError("check_in_to must be after or equal to check_in_from")
        return v


class InquirySearchRequest(BaseFilterSchema):
    """
    Inquiry search request with pagination.
    
    Supports full-text search across inquiry fields.
    """

    query: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Search query string",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Limit search to specific hostel",
    )

    # Search Fields
    search_in_name: bool = Field(
        True,
        description="Search in visitor name",
    )
    search_in_email: bool = Field(
        True,
        description="Search in email address",
    )
    search_in_phone: bool = Field(
        True,
        description="Search in phone number",
    )
    search_in_message: bool = Field(
        False,
        description="Search in inquiry message",
    )

    # Status Filter
    status: Optional[InquiryStatus] = Field(
        None,
        description="Limit search to specific status",
    )

    # Pagination
    page: int = Field(
        1,
        ge=1,
        description="Page number",
    )
    page_size: int = Field(
        20,
        ge=1,
        le=100,
        description="Items per page",
    )

    @field_validator("query")
    @classmethod
    def validate_query(cls, v: str) -> str:
        """Validate search query."""
        v = v.strip()
        if len(v) == 0:
            raise ValueError("Search query cannot be empty")
        return v


class InquirySortOptions(BaseFilterSchema):
    """
    Inquiry sorting options.
    """

    sort_by: str = Field(
        "created_at",
        pattern=r"^(created_at|visitor_name|status|check_in_date)$",
        description="Field to sort by",
    )
    sort_order: str = Field(
        "desc",
        pattern=r"^(asc|desc)$",
        description="Sort order",
    )

    @field_validator("sort_by", "sort_order")
    @classmethod
    def normalize_sort_fields(cls, v: str) -> str:
        """Normalize sort fields."""
        return v.lower()


class InquiryExportRequest(BaseFilterSchema):
    """
    Request to export inquiries data.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Export inquiries for specific hostel",
    )
    filters: Optional[InquiryFilterParams] = Field(
        None,
        description="Apply filters to export",
    )

    # Export Format
    format: str = Field(
        "csv",
        pattern=r"^(csv|excel|pdf)$",
        description="Export format",
    )

    # Fields to Include
    include_message: bool = Field(
        True,
        description="Include inquiry message",
    )
    include_notes: bool = Field(
        False,
        description="Include internal notes",
    )
    include_timeline: bool = Field(
        False,
        description="Include timeline/history",
    )

    @field_validator("format")
    @classmethod
    def normalize_format(cls, v: str) -> str:
        """Normalize format."""
        return v.lower()

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\inquiry\inquiry_response.py ---
# --- File: app/schemas/inquiry/inquiry_response.py ---
"""
Inquiry response schemas for API responses.

This module defines response schemas for inquiry data including
basic responses, detailed information, and list items.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import InquirySource, InquiryStatus, RoomType

__all__ = [
    "InquiryResponse",
    "InquiryDetail",
    "InquiryListItem",
    "InquiryStats",
]


class InquiryResponse(BaseResponseSchema):
    """
    Standard inquiry response schema.
    
    Contains core inquiry information for API responses.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Name of the hostel",
    )

    # Visitor Information
    visitor_name: str = Field(
        ...,
        description="Visitor full name",
    )
    visitor_email: str = Field(
        ...,
        description="Visitor email",
    )
    visitor_phone: str = Field(
        ...,
        description="Visitor phone",
    )

    # Preferences
    preferred_check_in_date: Optional[date] = Field(
        None,
        description="Preferred check-in date",
    )
    stay_duration_months: Optional[int] = Field(
        None,
        description="Intended stay duration",
    )
    room_type_preference: Optional[RoomType] = Field(
        None,
        description="Room type preference",
    )

    # Status
    status: InquiryStatus = Field(
        ...,
        description="Current inquiry status",
    )

    created_at: datetime = Field(
        ...,
        description="When inquiry was created",
    )

    @computed_field
    @property
    def age_days(self) -> int:
        """Calculate age of inquiry in days."""
        return (datetime.utcnow() - self.created_at).days

    @computed_field
    @property
    def is_new(self) -> bool:
        """Check if inquiry is new (less than 24 hours old)."""
        return self.age_days < 1

    @computed_field
    @property
    def is_stale(self) -> bool:
        """Check if inquiry is stale (older than 7 days without contact)."""
        return self.age_days > 7 and self.status == InquiryStatus.NEW

    @computed_field
    @property
    def urgency_level(self) -> str:
        """
        Determine urgency level.
        
        Returns: "high", "medium", or "low"
        """
        if self.status == InquiryStatus.NEW and self.age_days < 1:
            return "high"
        elif self.status == InquiryStatus.NEW and self.age_days < 3:
            return "medium"
        else:
            return "low"


class InquiryDetail(BaseResponseSchema):
    """
    Detailed inquiry information.
    
    Contains complete inquiry details including contact history,
    notes, and assignment information.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )

    # Visitor Information
    visitor_name: str = Field(
        ...,
        description="Visitor name",
    )
    visitor_email: str = Field(
        ...,
        description="Visitor email",
    )
    visitor_phone: str = Field(
        ...,
        description="Visitor phone",
    )

    # Preferences
    preferred_check_in_date: Optional[date] = Field(
        None,
        description="Preferred check-in date",
    )
    stay_duration_months: Optional[int] = Field(
        None,
        description="Stay duration in months",
    )
    room_type_preference: Optional[RoomType] = Field(
        None,
        description="Room type preference",
    )

    # Inquiry Details
    message: Optional[str] = Field(
        None,
        description="Visitor's message or questions",
    )

    # Metadata
    inquiry_source: InquirySource = Field(
        ...,
        description="Source of the inquiry",
    )
    status: InquiryStatus = Field(
        ...,
        description="Current status",
    )

    # Contact/Follow-up Information
    contacted_by: Optional[UUID] = Field(
        None,
        description="Admin who contacted the visitor",
    )
    contacted_by_name: Optional[str] = Field(
        None,
        description="Name of admin who made contact",
    )
    contacted_at: Optional[datetime] = Field(
        None,
        description="When visitor was contacted",
    )

    # Assignment Information
    assigned_to: Optional[UUID] = Field(
        None,
        description="Admin assigned to handle this inquiry",
    )
    assigned_to_name: Optional[str] = Field(
        None,
        description="Name of assigned admin",
    )
    assigned_at: Optional[datetime] = Field(
        None,
        description="When inquiry was assigned",
    )

    # Internal Notes
    notes: Optional[str] = Field(
        None,
        description="Internal notes about this inquiry",
    )

    # Timestamps
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )
    updated_at: datetime = Field(
        ...,
        description="Last update timestamp",
    )

    @computed_field
    @property
    def age_days(self) -> int:
        """Calculate inquiry age in days."""
        return (datetime.utcnow() - self.created_at).days

    @computed_field
    @property
    def has_been_contacted(self) -> bool:
        """Check if visitor has been contacted."""
        return self.contacted_at is not None

    @computed_field
    @property
    def is_assigned(self) -> bool:
        """Check if inquiry has been assigned to someone."""
        return self.assigned_to is not None

    @computed_field
    @property
    def response_time_hours(self) -> Optional[float]:
        """Calculate response time in hours if contacted."""
        if self.contacted_at is None:
            return None
        
        delta = self.contacted_at - self.created_at
        return round(delta.total_seconds() / 3600, 2)

    @computed_field
    @property
    def days_since_contact(self) -> Optional[int]:
        """Calculate days since last contact."""
        if self.contacted_at is None:
            return None
        
        return (datetime.utcnow() - self.contacted_at).days


class InquiryListItem(BaseSchema):
    """
    Inquiry list item for summary views.
    
    Optimized schema for displaying multiple inquiries
    with essential information only.
    """

    id: UUID = Field(
        ...,
        description="Inquiry ID",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    visitor_name: str = Field(
        ...,
        description="Visitor name",
    )
    visitor_phone: str = Field(
        ...,
        description="Visitor phone",
    )

    # Preferences
    preferred_check_in_date: Optional[date] = Field(
        None,
        description="Preferred check-in date",
    )
    stay_duration_months: Optional[int] = Field(
        None,
        description="Stay duration",
    )
    room_type_preference: Optional[RoomType] = Field(
        None,
        description="Room type preference",
    )

    # Status and Timing
    status: InquiryStatus = Field(
        ...,
        description="Current status",
    )
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )

    # Quick Indicators
    is_urgent: bool = Field(
        ...,
        description="Whether inquiry requires urgent attention",
    )
    is_assigned: bool = Field(
        ...,
        description="Whether inquiry is assigned to someone",
    )

    @computed_field
    @property
    def age_days(self) -> int:
        """Calculate inquiry age."""
        return (datetime.utcnow() - self.created_at).days

    @computed_field
    @property
    def status_badge_color(self) -> str:
        """Get color code for status badge."""
        color_map = {
            InquiryStatus.NEW: "#FFA500",  # Orange
            InquiryStatus.CONTACTED: "#2196F3",  # Blue
            InquiryStatus.INTERESTED: "#4CAF50",  # Green
            InquiryStatus.NOT_INTERESTED: "#9E9E9E",  # Gray
            InquiryStatus.CONVERTED: "#9C27B0",  # Purple
        }
        return color_map.get(self.status, "#000000")


class InquiryStats(BaseSchema):
    """
    Inquiry statistics and analytics.
    
    Provides metrics about inquiry performance and conversion.
    """

    # Volume Metrics
    total_inquiries: int = Field(
        ...,
        ge=0,
        description="Total number of inquiries",
    )
    new_inquiries: int = Field(
        ...,
        ge=0,
        description="Inquiries with NEW status",
    )
    contacted_inquiries: int = Field(
        ...,
        ge=0,
        description="Inquiries that have been contacted",
    )
    converted_inquiries: int = Field(
        ...,
        ge=0,
        description="Inquiries converted to bookings",
    )

    # Response Metrics
    average_response_time_hours: Optional[float] = Field(
        None,
        ge=0,
        description="Average time to first contact in hours",
    )
    
    # Conversion Metrics
    conversion_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Inquiry to booking conversion rate (%)",
    )
    interest_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of inquiries showing interest",
    )

    # Source Breakdown
    inquiries_by_source: dict = Field(
        default_factory=dict,
        description="Breakdown of inquiries by source",
    )

    @computed_field
    @property
    def pending_action_count(self) -> int:
        """Count inquiries needing action (NEW + CONTACTED)."""
        return self.new_inquiries + self.contacted_inquiries

    @computed_field
    @property
    def response_rate(self) -> float:
        """Calculate percentage of inquiries that were contacted."""
        if self.total_inquiries == 0:
            return 0.0
        return round((self.contacted_inquiries / self.total_inquiries) * 100, 2)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\inquiry\inquiry_status.py ---
# --- File: app/schemas/inquiry/inquiry_status.py ---
"""
Inquiry status management schemas.

This module defines schemas for managing inquiry status changes,
assignments, timeline tracking, and follow-ups.
"""

from __future__ import annotations

from datetime import datetime
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import InquiryStatus

__all__ = [
    "InquiryStatusUpdate",
    "InquiryAssignment",
    "InquiryFollowUp",
    "InquiryTimelineEntry",
    "InquiryConversion",
    "BulkInquiryStatusUpdate",
]


class InquiryStatusUpdate(BaseCreateSchema):
    """
    Update inquiry status with notes.
    
    Used to track status changes throughout the inquiry lifecycle.
    """

    inquiry_id: UUID = Field(
        ...,
        description="Inquiry ID to update",
    )
    new_status: InquiryStatus = Field(
        ...,
        description="New status to set",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Notes about status change",
    )

    # Metadata
    updated_by: Optional[UUID] = Field(
        None,
        description="Admin updating the status",
    )

    @field_validator("notes")
    @classmethod
    def clean_notes(cls, v: Optional[str]) -> Optional[str]:
        """Clean notes field."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v

    @model_validator(mode="after")
    def validate_status_transition(self) -> "InquiryStatusUpdate":
        """
        Validate status transition is logical.
        
        Note: This is a soft validation - enforces best practices
        but doesn't block unusual transitions (admin override).
        """
        # Define logical status transitions
        valid_transitions = {
            InquiryStatus.NEW: [
                InquiryStatus.CONTACTED,
                InquiryStatus.NOT_INTERESTED,
            ],
            InquiryStatus.CONTACTED: [
                InquiryStatus.INTERESTED,
                InquiryStatus.NOT_INTERESTED,
                InquiryStatus.CONVERTED,
            ],
            InquiryStatus.INTERESTED: [
                InquiryStatus.CONVERTED,
                InquiryStatus.NOT_INTERESTED,
            ],
            InquiryStatus.NOT_INTERESTED: [],  # Terminal state
            InquiryStatus.CONVERTED: [],  # Terminal state
        }
        
        # This validation would need access to current status
        # In practice, this would be validated at the service layer
        # where we have access to the current inquiry data
        
        return self


class InquiryAssignment(BaseCreateSchema):
    """
    Assign inquiry to an admin/staff member.
    
    Used for distributing inquiries among team members
    for follow-up.
    """

    inquiry_id: UUID = Field(
        ...,
        description="Inquiry ID to assign",
    )
    assigned_to: UUID = Field(
        ...,
        description="Admin/staff member to assign to",
    )
    assigned_by: UUID = Field(
        ...,
        description="Admin making the assignment",
    )

    assignment_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Notes about the assignment",
    )

    # Due Date for Follow-up
    follow_up_due: Optional[datetime] = Field(
        None,
        description="When follow-up should be completed by",
    )

    @field_validator("assignment_notes")
    @classmethod
    def clean_notes(cls, v: Optional[str]) -> Optional[str]:
        """Clean assignment notes."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v

    @field_validator("follow_up_due")
    @classmethod
    def validate_follow_up_due(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate follow-up due date."""
        if v is not None:
            if v < datetime.utcnow():
                raise ValueError("Follow-up due date cannot be in the past")
        return v


class InquiryFollowUp(BaseCreateSchema):
    """
    Record a follow-up action on an inquiry.
    
    Used to track all interactions with the visitor.
    """

    inquiry_id: UUID = Field(
        ...,
        description="Inquiry ID",
    )
    followed_up_by: UUID = Field(
        ...,
        description="Admin who performed follow-up",
    )

    # Follow-up Details
    contact_method: str = Field(
        ...,
        pattern=r"^(phone|email|sms|whatsapp|in_person|other)$",
        description="Method of contact",
    )
    contact_outcome: str = Field(
        ...,
        pattern=r"^(connected|no_answer|voicemail|email_sent|interested|not_interested|callback_requested)$",
        description="Outcome of the follow-up attempt",
    )

    # Notes
    notes: str = Field(
        ...,
        min_length=10,
        max_length=1000,
        description="Detailed notes about the follow-up",
    )

    # Next Steps
    next_follow_up_date: Optional[datetime] = Field(
        None,
        description="When next follow-up should occur",
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: str) -> str:
        """Validate notes are meaningful."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Follow-up notes must be at least 10 characters")
        return v

    @field_validator("next_follow_up_date")
    @classmethod
    def validate_next_follow_up(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate next follow-up date."""
        if v is not None:
            if v < datetime.utcnow():
                raise ValueError("Next follow-up date cannot be in the past")
        return v


class InquiryTimelineEntry(BaseSchema):
    """
    Timeline entry for inquiry lifecycle.
    
    Represents a single event in the inquiry's history.
    """

    event_type: str = Field(
        ...,
        pattern=r"^(status_change|assignment|follow_up|note_added|conversion)$",
        description="Type of timeline event",
    )
    status: Optional[InquiryStatus] = Field(
        None,
        description="Status at this point (for status_change events)",
    )
    timestamp: datetime = Field(
        ...,
        description="When this event occurred",
    )
    changed_by: Optional[UUID] = Field(
        None,
        description="Admin who triggered this event",
    )
    changed_by_name: Optional[str] = Field(
        None,
        description="Name of admin who triggered event",
    )
    notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Notes about this event",
    )

    # Additional Context
    metadata: dict = Field(
        default_factory=dict,
        description="Additional event metadata",
    )


class InquiryConversion(BaseCreateSchema):
    """
    Record inquiry conversion to booking.
    
    Links inquiry to the resulting booking.
    """

    inquiry_id: UUID = Field(
        ...,
        description="Inquiry ID that converted",
    )
    booking_id: UUID = Field(
        ...,
        description="Resulting booking ID",
    )
    converted_by: UUID = Field(
        ...,
        description="Admin who facilitated conversion",
    )

    conversion_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Notes about the conversion",
    )

    @field_validator("conversion_notes")
    @classmethod
    def clean_notes(cls, v: Optional[str]) -> Optional[str]:
        """Clean conversion notes."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class BulkInquiryStatusUpdate(BaseCreateSchema):
    """
    Update status of multiple inquiries.
    
    Used for batch operations on inquiries.
    """

    inquiry_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of inquiry IDs to update (max 100)",
    )
    new_status: InquiryStatus = Field(
        ...,
        description="New status for all inquiries",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Common notes for all updates",
    )

    updated_by: UUID = Field(
        ...,
        description="Admin performing bulk update",
    )

    @field_validator("inquiry_ids")
    @classmethod
    def validate_inquiry_ids(cls, v: List[UUID]) -> List[UUID]:
        """Validate inquiry IDs list."""
        if len(v) == 0:
            raise ValueError("At least one inquiry ID is required")
        
        if len(v) > 100:
            raise ValueError("Maximum 100 inquiries can be updated at once")
        
        # Remove duplicates
        unique_ids = list(dict.fromkeys(v))
        
        return unique_ids

    @field_validator("notes")
    @classmethod
    def clean_notes(cls, v: Optional[str]) -> Optional[str]:
        """Clean notes."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\inquiry\__init__.py ---
# --- File: app/schemas/inquiry/__init__.py ---
"""
Visitor inquiry and contact schemas package.

This module exports all inquiry-related schemas for easy importing
across the application.
"""

from __future__ import annotations

from app.schemas.inquiry.inquiry_base import (
    InquiryBase,
    InquiryCreate,
    InquiryUpdate,
)
from app.schemas.inquiry.inquiry_filters import (
    InquiryExportRequest,
    InquiryFilterParams,
    InquirySearchRequest,
    InquirySortOptions,
)
from app.schemas.inquiry.inquiry_response import (
    InquiryDetail,
    InquiryListItem,
    InquiryResponse,
    InquiryStats,
)
from app.schemas.inquiry.inquiry_status import (
    BulkInquiryStatusUpdate,
    InquiryAssignment,
    InquiryConversion,
    InquiryFollowUp,
    InquiryStatusUpdate,
    InquiryTimelineEntry,
)

__all__ = [
    # Base schemas
    "InquiryBase",
    "InquiryCreate",
    "InquiryUpdate",
    # Response
    "InquiryResponse",
    "InquiryDetail",
    "InquiryListItem",
    "InquiryStats",
    # Status Management
    "InquiryStatusUpdate",
    "InquiryAssignment",
    "InquiryFollowUp",
    "InquiryTimelineEntry",
    "InquiryConversion",
    "BulkInquiryStatusUpdate",
    # Filters
    "InquiryFilterParams",
    "InquirySearchRequest",
    "InquirySortOptions",
    "InquiryExportRequest",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\leave =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\leave\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\leave ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\leave =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\leave\leave_application.py ---
"""
Leave application & cancellation request schemas
"""
from datetime import date
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema
from app.schemas.common.enums import LeaveType


class LeaveApplicationRequest(BaseCreateSchema):
    """Student-sent leave application request"""
    student_id: UUID
    hostel_id: UUID

    leave_type: LeaveType
    from_date: date
    to_date: date
    reason: str = Field(..., min_length=10, max_length=1000)

    contact_during_leave: Optional[str] = Field(None, max_length=20)
    emergency_contact: Optional[str] = Field(None, max_length=20)

    supporting_document_url: Optional[str] = None


class LeaveCancellationRequest(BaseCreateSchema):
    """Student request to cancel an already approved/pending leave"""
    leave_id: UUID
    student_id: UUID

    cancellation_reason: str = Field(..., min_length=10, max_length=500)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\leave\leave_approval.py ---
"""
Leave approval & workflow schemas
"""
from datetime import datetime
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import LeaveStatus


class LeaveApprovalRequest(BaseCreateSchema):
    """Supervisor/admin leave approval/rejection"""
    leave_id: UUID
    approver_id: UUID

    approve: bool
    approval_notes: Optional[str] = Field(
        None, max_length=500, description="Additional notes"
    )

    # If rejecting
    rejection_reason: Optional[str] = Field(None, max_length=500)


class LeaveApprovalResponse(BaseSchema):
    """Approval outcome"""
    leave_id: UUID
    status: LeaveStatus

    approved_by: Optional[UUID]
    approved_by_name: Optional[str]
    approved_at: Optional[datetime]

    rejected_by: Optional[UUID]
    rejected_by_name: Optional[str]
    rejected_at: Optional[datetime]

    message: str

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\leave\leave_balance.py ---
"""
Leave balance schemas
"""
from datetime import date
from typing import List
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import LeaveType


class LeaveBalance(BaseSchema):
    """Leave balance for a single leave type"""
    leave_type: LeaveType
    allocated_per_year: int = Field(..., ge=0)
    used_days: int = Field(..., ge=0)
    remaining_days: int = Field(..., ge=0)


class LeaveBalanceSummary(BaseSchema):
    """Overall leave balance for a student"""
    student_id: UUID
    student_name: str
    hostel_id: UUID
    hostel_name: str

    academic_year_start: date
    academic_year_end: date

    balances: List[LeaveBalance] = Field(default_factory=list)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\leave\leave_base.py ---
"""
Base leave schemas
"""
from datetime import date
from typing import Optional
from pydantic import Field, field_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseUpdateSchema
from app.schemas.common.enums import LeaveType, LeaveStatus


class LeaveBase(BaseSchema):
    """Base leave application fields"""
    student_id: UUID = Field(..., description="Student requesting leave")
    hostel_id: UUID = Field(..., description="Hostel context")

    leave_type: LeaveType = Field(..., description="Type of leave")
    from_date: date = Field(..., description="Start of leave")
    to_date: date = Field(..., description="End of leave")
    total_days: int = Field(..., ge=1, description="Computed total leave days")

    reason: str = Field(..., min_length=10, max_length=1000, description="Leave reason")

    contact_during_leave: Optional[str] = Field(
        None, max_length=20, description="Contact phone during leave"
    )
    emergency_contact: Optional[str] = Field(
        None, max_length=20, description="Emergency contact during leave"
    )

    supporting_document_url: Optional[str] = Field(
        None, description="Document URL (e.g. medical certificate)"
    )

    @field_validator("total_days")
    @classmethod
    def validate_total_days(cls, v: int, info):
        if "from_date" in info.data and "to_date" in info.data:
            fd = info.data["from_date"]
            td = info.data["to_date"]
            days = (td - fd).days + 1
            if days != v:
                raise ValueError("total_days must equal (to_date - from_date + 1)")
        return v


class LeaveCreate(LeaveBase, BaseCreateSchema):
    """Create leave application"""
    pass


class LeaveUpdate(BaseUpdateSchema):
    """Update leave application (typically before approval)"""
    leave_type: Optional[LeaveType] = None
    from_date: Optional[date] = None
    to_date: Optional[date] = None
    total_days: Optional[int] = Field(None, ge=1)
    reason: Optional[str] = None
    contact_during_leave: Optional[str] = None
    emergency_contact: Optional[str] = None
    supporting_document_url: Optional[str] = None
    status: Optional[LeaveStatus] = None

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\leave\leave_response.py ---
"""
Leave response schemas
"""
from datetime import date, datetime
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import LeaveType, LeaveStatus


class LeaveResponse(BaseResponseSchema):
    """Leave list item for basic display"""
    student_id: UUID
    student_name: str
    hostel_id: UUID
    hostel_name: str

    leave_type: LeaveType
    from_date: date
    to_date: date
    total_days: int

    status: LeaveStatus
    applied_at: datetime


class LeaveDetail(BaseResponseSchema):
    """Detailed leave view"""
    student_id: UUID
    student_name: str
    student_room: Optional[str]

    hostel_id: UUID
    hostel_name: str

    leave_type: LeaveType
    from_date: date
    to_date: date
    total_days: int
    reason: str

    contact_during_leave: Optional[str]
    emergency_contact: Optional[str]
    supporting_document_url: Optional[str]

    status: LeaveStatus
    applied_at: datetime
    approved_at: Optional[datetime]
    rejected_at: Optional[datetime]
    cancelled_at: Optional[datetime]

    approved_by: Optional[UUID]
    approved_by_name: Optional[str]
    rejected_by: Optional[UUID]
    rejected_by_name: Optional[str]

    rejection_reason: Optional[str]
    cancellation_reason: Optional[str]


class LeaveListItem(BaseSchema):
    """List row for leave applications"""
    id: UUID
    student_name: str
    room_number: Optional[str]
    leave_type: LeaveType
    from_date: date
    to_date: date
    total_days: int
    status: LeaveStatus
    applied_at: datetime

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\leave\__init__.py ---
"""
Leave management schemas package
"""

from app.schemas.leave.leave_base import (
    LeaveBase,
    LeaveCreate,
    LeaveUpdate,
)
from app.schemas.leave.leave_response import (
    LeaveResponse,
    LeaveDetail,
    LeaveListItem,
)
from app.schemas.leave.leave_application import (
    LeaveApplicationRequest,
    LeaveCancellationRequest,
)
from app.schemas.leave.leave_approval import (
    LeaveApprovalRequest,
    LeaveApprovalResponse,
)
from app.schemas.leave.leave_balance import (
    LeaveBalance,
    LeaveBalanceSummary,
)

__all__ = [
    # Base
    "LeaveBase",
    "LeaveCreate",
    "LeaveUpdate",
    # Response
    "LeaveResponse",
    "LeaveDetail",
    "LeaveListItem",
    # Application
    "LeaveApplicationRequest",
    "LeaveCancellationRequest",
    # Approval
    "LeaveApprovalRequest",
    "LeaveApprovalResponse",
    # Balance
    "LeaveBalance",
    "LeaveBalanceSummary",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\leave\leave_application.py ---
# --- File: app/schemas/leave/leave_application.py ---
"""
Leave application and cancellation request schemas.

Provides schemas for student-initiated leave requests and cancellations
with comprehensive validation.
"""

from __future__ import annotations

from datetime import date
from typing import Optional

from pydantic import Field, HttpUrl, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema
from app.schemas.common.enums import LeaveType

__all__ = [
    "LeaveApplicationRequest",
    "LeaveCancellationRequest",
]


class LeaveApplicationRequest(BaseCreateSchema):
    """
    Student-initiated leave application request.
    
    Streamlined schema for students to apply for leave with
    automatic calculation and validation.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    leave_type: LeaveType = Field(
        ...,
        description="Type of leave being requested",
    )
    from_date: date = Field(
        ...,
        description="Leave start date",
    )
    to_date: date = Field(
        ...,
        description="Leave end date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=1000,
        description="Detailed reason for leave",
    )
    contact_during_leave: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact phone number during leave",
    )
    emergency_contact: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone number",
    )
    emergency_contact_relation: Optional[str] = Field(
        None,
        max_length=50,
        description="Relation with emergency contact person",
    )
    supporting_document_url: Optional[HttpUrl] = Field(
        None,
        description="URL to supporting document",
    )
    destination_address: Optional[str] = Field(
        None,
        max_length=500,
        description="Destination address during leave",
    )
    expected_return_date: Optional[date] = Field(
        None,
        description="Expected return date (may differ from to_date)",
    )

    @field_validator("from_date")
    @classmethod
    def validate_from_date(cls, v: date) -> date:
        """
        Validate leave start date.
        
        Students can apply for leave up to 30 days in advance
        or up to 7 days in the past (for backdated applications).
        """
        today = date.today()
        
        # Allow backdated applications up to 7 days
        days_past = (today - v).days
        if days_past > 7:
            raise ValueError(
                "Cannot apply for leave starting more than 7 days in the past"
            )
        
        # Allow advance applications up to 30 days
        days_future = (v - today).days
        if days_future > 30:
            raise ValueError(
                "Cannot apply for leave more than 30 days in advance"
            )
        
        return v

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate leave reason is meaningful."""
        v = v.strip()
        
        if len(v) < 10:
            raise ValueError("Leave reason must be at least 10 characters")
        
        # Basic meaningfulness check
        if len(set(v.lower().replace(" ", ""))) < 5:
            raise ValueError("Please provide a detailed and meaningful reason")
        
        # Check for common placeholder/test text
        placeholder_patterns = [
            "test", "testing", "asdf", "qwerty", "aaaa", "bbbb",
            "xxxx", "leave", "urgent", "personal"
        ]
        
        reason_lower = v.lower()
        if any(
            pattern == reason_lower or reason_lower.startswith(pattern + " ")
            for pattern in placeholder_patterns
        ):
            if len(v) < 20:
                raise ValueError("Please provide a more detailed reason")
        
        return v

    @field_validator("contact_during_leave", "emergency_contact")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone numbers."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return None

    @field_validator("destination_address")
    @classmethod
    def validate_destination(cls, v: Optional[str]) -> Optional[str]:
        """Normalize destination address."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_leave_application(self) -> "LeaveApplicationRequest":
        """
        Validate complete leave application.
        
        Ensures:
        - Date range is valid
        - Duration meets requirements
        - Required documents are provided
        - Contact information is sufficient
        """
        # Validate date range
        if self.to_date < self.from_date:
            raise ValueError("End date must be after or equal to start date")
        
        # Calculate duration
        total_days = (self.to_date - self.from_date).days + 1
        
        # Validate duration limits by leave type
        max_days_by_type = {
            LeaveType.CASUAL: 30,
            LeaveType.SICK: 60,
            LeaveType.EMERGENCY: 15,
            LeaveType.VACATION: 90,
            LeaveType.OTHER: 30,
        }
        
        max_allowed = max_days_by_type.get(self.leave_type, 30)
        if total_days > max_allowed:
            raise ValueError(
                f"{self.leave_type.value} leave cannot exceed {max_allowed} days"
            )
        
        # Document requirements
        if self.leave_type == LeaveType.SICK and total_days > 3:
            if not self.supporting_document_url:
                raise ValueError(
                    "Medical certificate required for sick leave exceeding 3 days"
                )
        
        if total_days > 15:
            if not self.supporting_document_url:
                raise ValueError(
                    "Supporting documentation required for leave exceeding 15 days"
                )
        
        # Contact information requirements
        if total_days > 7:
            if not self.contact_during_leave and not self.emergency_contact:
                raise ValueError(
                    "Contact information required for leave exceeding 7 days"
                )
        
        # Emergency contact for long leaves
        if total_days > 15 and not self.emergency_contact:
            raise ValueError(
                "Emergency contact required for leave exceeding 15 days"
            )
        
        # Validate expected return date if provided
        if self.expected_return_date:
            if self.expected_return_date < self.to_date:
                raise ValueError(
                    "Expected return date cannot be before leave end date"
                )
            
            # Reasonable buffer (max 7 days after scheduled end)
            days_after = (self.expected_return_date - self.to_date).days
            if days_after > 7:
                raise ValueError(
                    "Expected return date cannot be more than 7 days after leave end date"
                )
        
        return self


class LeaveCancellationRequest(BaseCreateSchema):
    """
    Student request to cancel leave application.
    
    Allows students to cancel pending or approved leaves with
    proper justification.
    """

    leave_id: UUID = Field(
        ...,
        description="Leave application unique identifier",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier (for verification)",
    )
    cancellation_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for cancellation",
    )
    immediate_return: bool = Field(
        default=False,
        description="Whether student is returning immediately (for ongoing leaves)",
    )
    actual_return_date: Optional[date] = Field(
        None,
        description="Actual return date (for early return from ongoing leave)",
    )

    @field_validator("cancellation_reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate cancellation reason is meaningful."""
        v = v.strip()
        
        if len(v) < 10:
            raise ValueError(
                "Cancellation reason must be at least 10 characters"
            )
        
        # Basic meaningfulness check
        if len(set(v.lower().replace(" ", ""))) < 5:
            raise ValueError(
                "Please provide a detailed reason for cancellation"
            )
        
        return v

    @model_validator(mode="after")
    def validate_cancellation(self) -> "LeaveCancellationRequest":
        """
        Validate cancellation request consistency.
        
        Ensures immediate return and actual return date are consistent.
        """
        # If immediate return, actual_return_date should be today or not provided
        if self.immediate_return:
            if self.actual_return_date:
                if self.actual_return_date > date.today():
                    raise ValueError(
                        "immediate_return is True but actual_return_date is in future"
                    )
        
        # If actual_return_date provided, validate it's reasonable
        if self.actual_return_date:
            today = date.today()
            
            # Can't be in future for cancellation
            if self.actual_return_date > today:
                raise ValueError(
                    "Actual return date cannot be in the future"
                )
            
            # Shouldn't be too far in the past
            days_past = (today - self.actual_return_date).days
            if days_past > 30:
                raise ValueError(
                    "Actual return date cannot be more than 30 days in the past"
                )
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\leave\leave_approval.py ---
# --- File: app/schemas/leave/leave_approval.py ---
"""
Leave approval and workflow schemas.

Provides schemas for supervisor/admin leave approval decisions
with comprehensive tracking and validation.
"""

from __future__ import annotations

from datetime import datetime
from typing import Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import LeaveStatus

__all__ = [
    "LeaveApprovalRequest",
    "LeaveApprovalResponse",
    "LeaveApprovalAction",
]


class LeaveApprovalRequest(BaseCreateSchema):
    """
    Supervisor/admin leave approval or rejection request.
    
    Handles the approval workflow with proper validation and
    audit trail requirements.
    """

    leave_id: UUID = Field(
        ...,
        description="Leave application unique identifier",
    )
    approver_id: UUID = Field(
        ...,
        description="User ID of approver (supervisor/admin)",
    )
    approve: bool = Field(
        ...,
        description="True to approve, False to reject",
    )
    approval_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes or comments from approver",
    )
    rejection_reason: Optional[str] = Field(
        None,
        min_length=10,
        max_length=500,
        description="Detailed reason for rejection (required if rejecting)",
    )
    conditions: Optional[str] = Field(
        None,
        max_length=500,
        description="Conditions or requirements for approved leave",
    )
    notify_student: bool = Field(
        default=True,
        description="Send notification to student about decision",
    )
    notify_guardian: bool = Field(
        default=False,
        description="Send notification to guardian about decision",
    )

    @field_validator("approval_notes", "rejection_reason", "conditions")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_approval_decision(self) -> "LeaveApprovalRequest":
        """
        Validate approval decision consistency.
        
        Ensures:
        - Rejection reason is provided when rejecting
        - Conditions are only set when approving
        """
        # Rejection requires reason
        if not self.approve:
            if not self.rejection_reason:
                raise ValueError(
                    "rejection_reason is required when rejecting leave"
                )
            
            if len(self.rejection_reason.strip()) < 10:
                raise ValueError(
                    "Rejection reason must be at least 10 characters"
                )
            
            # Conditions shouldn't be set for rejection
            if self.conditions:
                raise ValueError(
                    "conditions should not be set when rejecting leave"
                )
        else:
            # Approval shouldn't have rejection reason
            if self.rejection_reason:
                raise ValueError(
                    "rejection_reason should not be set when approving leave"
                )
        
        return self


class LeaveApprovalAction(BaseCreateSchema):
    """
    Alternative approval action schema with explicit status.
    
    Provides more flexibility for complex approval workflows.
    """

    leave_id: UUID = Field(
        ...,
        description="Leave application unique identifier",
    )
    approver_id: UUID = Field(
        ...,
        description="Approver user ID",
    )
    action: str = Field(
        ...,
        pattern=r"^(approve|reject|request_changes|escalate)$",
        description="Approval action to take",
    )
    comments: str = Field(
        ...,
        min_length=10,
        max_length=1000,
        description="Comments explaining the action",
    )
    requested_changes: Optional[str] = Field(
        None,
        max_length=500,
        description="Specific changes requested (if action is 'request_changes')",
    )
    escalate_to: Optional[UUID] = Field(
        None,
        description="User ID to escalate to (if action is 'escalate')",
    )
    conditions: Optional[str] = Field(
        None,
        max_length=500,
        description="Approval conditions",
    )
    notify_student: bool = Field(
        default=True,
        description="Notify student of decision",
    )

    @field_validator("comments")
    @classmethod
    def validate_comments(cls, v: str) -> str:
        """Validate comments are meaningful."""
        v = v.strip()
        
        if len(v) < 10:
            raise ValueError("Comments must be at least 10 characters")
        
        return v

    @model_validator(mode="after")
    def validate_action_requirements(self) -> "LeaveApprovalAction":
        """
        Validate action-specific requirements.
        
        Ensures required fields are provided for each action type.
        """
        if self.action == "request_changes":
            if not self.requested_changes:
                raise ValueError(
                    "requested_changes is required for 'request_changes' action"
                )
        
        if self.action == "escalate":
            if not self.escalate_to:
                raise ValueError(
                    "escalate_to is required for 'escalate' action"
                )
        
        if self.action == "approve":
            # Conditions only make sense for approval
            pass
        else:
            # Other actions shouldn't have conditions
            if self.conditions:
                raise ValueError(
                    f"conditions should not be set for '{self.action}' action"
                )
        
        return self


class LeaveApprovalResponse(BaseSchema):
    """
    Leave approval decision response.
    
    Provides complete information about the approval decision
    with timestamps and responsible parties.
    """

    leave_id: UUID = Field(
        ...,
        description="Leave application unique identifier",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    status: LeaveStatus = Field(
        ...,
        description="Updated leave status after decision",
    )
    previous_status: Optional[LeaveStatus] = Field(
        None,
        description="Previous leave status",
    )

    # Approval details
    approved_by: Optional[UUID] = Field(
        None,
        description="Approver user ID (if approved)",
    )
    approved_by_name: Optional[str] = Field(
        None,
        description="Approver full name",
    )
    approved_at: Optional[datetime] = Field(
        None,
        description="Approval timestamp",
    )
    approval_notes: Optional[str] = Field(
        None,
        description="Approval notes",
    )
    conditions: Optional[str] = Field(
        None,
        description="Approval conditions",
    )

    # Rejection details
    rejected_by: Optional[UUID] = Field(
        None,
        description="Rejector user ID (if rejected)",
    )
    rejected_by_name: Optional[str] = Field(
        None,
        description="Rejector full name",
    )
    rejected_at: Optional[datetime] = Field(
        None,
        description="Rejection timestamp",
    )
    rejection_reason: Optional[str] = Field(
        None,
        description="Rejection reason",
    )

    # Response metadata
    message: str = Field(
        ...,
        description="Human-readable response message",
    )
    notifications_sent: bool = Field(
        default=False,
        description="Whether notifications were sent",
    )
    notification_recipients: Optional[list[str]] = Field(
        None,
        description="List of notification recipients",
    )

    @model_validator(mode="after")
    def validate_response_consistency(self) -> "LeaveApprovalResponse":
        """
        Validate response data consistency.
        
        Ensures approval/rejection fields match the status.
        """
        # Approved status should have approval details
        if self.status == LeaveStatus.APPROVED:
            if not self.approved_by or not self.approved_at:
                raise ValueError(
                    "Approval details required for APPROVED status"
                )
            
            # Shouldn't have rejection details
            if self.rejected_by or self.rejected_at or self.rejection_reason:
                raise ValueError(
                    "Rejection details should not be present for APPROVED status"
                )
        
        # Rejected status should have rejection details
        elif self.status == LeaveStatus.REJECTED:
            if not self.rejected_by or not self.rejected_at:
                raise ValueError(
                    "Rejection details required for REJECTED status"
                )
            
            if not self.rejection_reason:
                raise ValueError(
                    "Rejection reason required for REJECTED status"
                )
            
            # Shouldn't have approval details
            if self.approved_by or self.approved_at:
                raise ValueError(
                    "Approval details should not be present for REJECTED status"
                )
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\leave\leave_balance.py ---
# --- File: app/schemas/leave/leave_balance.py ---
"""
Leave balance and quota management schemas.

Provides schemas for tracking leave entitlements, usage,
and remaining balance with validation.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field, field_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import LeaveType

__all__ = [
    "LeaveBalance",
    "LeaveBalanceSummary",
    "LeaveQuota",
    "LeaveUsageDetail",
]


class LeaveBalance(BaseSchema):
    """
    Leave balance for a single leave type.
    
    Tracks allocation, usage, and remaining balance for
    a specific leave type.
    """

    leave_type: LeaveType = Field(
        ...,
        description="Type of leave",
    )
    allocated_per_year: int = Field(
        ...,
        ge=0,
        le=365,
        description="Total days allocated per year",
    )
    allocated_per_semester: Optional[int] = Field(
        None,
        ge=0,
        le=180,
        description="Days allocated per semester (if applicable)",
    )
    used_days: int = Field(
        ...,
        ge=0,
        description="Days already used/approved",
    )
    pending_days: int = Field(
        default=0,
        ge=0,
        description="Days in pending applications",
    )
    remaining_days: int = Field(
        ...,
        ge=0,
        description="Days remaining available",
    )
    carry_forward_days: int = Field(
        default=0,
        ge=0,
        description="Days carried forward from previous period",
    )
    max_consecutive_days: Optional[int] = Field(
        None,
        ge=1,
        description="Maximum consecutive days allowed for this leave type",
    )
    requires_approval: bool = Field(
        default=True,
        description="Whether this leave type requires approval",
    )

    @field_validator("remaining_days")
    @classmethod
    def validate_remaining_days(cls, v: int, info) -> int:
        """
        Validate remaining days calculation.
        
        Ensures remaining = allocated + carry_forward - used - pending.
        """
        if "allocated_per_year" in info.data and "used_days" in info.data:
            allocated = info.data["allocated_per_year"]
            used = info.data["used_days"]
            pending = info.data.get("pending_days", 0)
            carry_forward = info.data.get("carry_forward_days", 0)
            
            expected_remaining = allocated + carry_forward - used - pending
            
            # Allow small discrepancies due to rounding
            if abs(expected_remaining - v) > 1:
                raise ValueError(
                    f"remaining_days ({v}) doesn't match calculation "
                    f"({expected_remaining})"
                )
        
        return v

    @computed_field
    @property
    def usage_percentage(self) -> Decimal:
        """Calculate usage percentage."""
        total_available = self.allocated_per_year + self.carry_forward_days
        if total_available == 0:
            return Decimal("0.00")
        
        return round(
            Decimal(self.used_days) / Decimal(total_available) * 100,
            2,
        )

    @computed_field
    @property
    def is_exhausted(self) -> bool:
        """Check if leave balance is exhausted."""
        return self.remaining_days <= 0

    @computed_field
    @property
    def utilization_status(self) -> str:
        """Get utilization status indicator."""
        usage_pct = float(self.usage_percentage)
        
        if usage_pct >= 90:
            return "critical"
        elif usage_pct >= 75:
            return "high"
        elif usage_pct >= 50:
            return "moderate"
        elif usage_pct >= 25:
            return "low"
        else:
            return "minimal"


class LeaveBalanceSummary(BaseSchema):
    """
    Comprehensive leave balance summary for a student.
    
    Aggregates balance information across all leave types
    for a specific academic period.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Room number",
    )

    # Academic period
    academic_year_start: date = Field(
        ...,
        description="Academic year start date",
    )
    academic_year_end: date = Field(
        ...,
        description="Academic year end date",
    )
    current_semester: Optional[str] = Field(
        None,
        description="Current semester (if applicable)",
    )

    # Balance breakdown
    balances: List[LeaveBalance] = Field(
        ...,
        min_length=1,
        description="Balance for each leave type",
    )

    # Overall statistics
    total_allocated: int = Field(
        ...,
        ge=0,
        description="Total days allocated across all types",
    )
    total_used: int = Field(
        ...,
        ge=0,
        description="Total days used across all types",
    )
    total_pending: int = Field(
        default=0,
        ge=0,
        description="Total days in pending applications",
    )
    total_remaining: int = Field(
        ...,
        ge=0,
        description="Total days remaining",
    )

    # Last updated
    last_updated: date = Field(
        ...,
        description="Last balance update date",
    )

    @field_validator("academic_year_end")
    @classmethod
    def validate_academic_year(cls, v: date, info) -> date:
        """Validate academic year dates are logical."""
        if "academic_year_start" in info.data:
            if v <= info.data["academic_year_start"]:
                raise ValueError(
                    "academic_year_end must be after academic_year_start"
                )
        return v

    @computed_field
    @property
    def overall_usage_percentage(self) -> Decimal:
        """Calculate overall usage percentage."""
        if self.total_allocated == 0:
            return Decimal("0.00")
        
        return round(
            Decimal(self.total_used) / Decimal(self.total_allocated) * 100,
            2,
        )

    @computed_field
    @property
    def days_until_year_end(self) -> int:
        """Calculate days remaining in academic year."""
        today = date.today()
        if today > self.academic_year_end:
            return 0
        return (self.academic_year_end - today).days

    @computed_field
    @property
    def has_pending_applications(self) -> bool:
        """Check if there are pending applications."""
        return self.total_pending > 0


class LeaveQuota(BaseSchema):
    """
    Leave quota configuration for hostel/policy.
    
    Defines leave entitlements and rules for different
    leave types within a hostel.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    leave_type: LeaveType = Field(
        ...,
        description="Leave type",
    )
    annual_quota: int = Field(
        ...,
        ge=0,
        le=365,
        description="Annual leave quota in days",
    )
    semester_quota: Optional[int] = Field(
        None,
        ge=0,
        le=180,
        description="Semester quota (if applicable)",
    )
    monthly_quota: Optional[int] = Field(
        None,
        ge=0,
        le=31,
        description="Monthly quota (if applicable)",
    )
    max_consecutive_days: int = Field(
        ...,
        ge=1,
        le=90,
        description="Maximum consecutive days allowed",
    )
    min_notice_days: int = Field(
        default=0,
        ge=0,
        le=30,
        description="Minimum advance notice required (days)",
    )
    requires_document_after_days: Optional[int] = Field(
        None,
        ge=1,
        description="Requires supporting document after N days",
    )
    allow_carry_forward: bool = Field(
        default=False,
        description="Allow unused quota to carry forward",
    )
    carry_forward_max_days: Optional[int] = Field(
        None,
        ge=0,
        description="Maximum days that can be carried forward",
    )
    carry_forward_expiry_months: Optional[int] = Field(
        None,
        ge=1,
        le=12,
        description="Months after which carried forward days expire",
    )
    is_active: bool = Field(
        default=True,
        description="Whether this quota is currently active",
    )

    @field_validator("carry_forward_max_days")
    @classmethod
    def validate_carry_forward(cls, v: Optional[int], info) -> Optional[int]:
        """Validate carry forward configuration."""
        if v is not None:
            if not info.data.get("allow_carry_forward"):
                raise ValueError(
                    "carry_forward_max_days should only be set when allow_carry_forward is True"
                )
        return v


class LeaveUsageDetail(BaseSchema):
    """
    Detailed leave usage record for reporting.
    
    Provides granular information about leave consumption
    for analytics and reporting.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    leave_id: UUID = Field(
        ...,
        description="Leave application unique identifier",
    )
    leave_type: LeaveType = Field(
        ...,
        description="Leave type",
    )
    from_date: date = Field(
        ...,
        description="Leave start date",
    )
    to_date: date = Field(
        ...,
        description="Leave end date",
    )
    total_days: int = Field(
        ...,
        ge=1,
        description="Total leave days",
    )
    applied_at: date = Field(
        ...,
        description="Application date",
    )
    approved_at: Optional[date] = Field(
        None,
        description="Approval date",
    )
    days_notice: int = Field(
        ...,
        ge=0,
        description="Days notice given before leave start",
    )
    was_backdated: bool = Field(
        default=False,
        description="Whether application was backdated",
    )
    had_supporting_document: bool = Field(
        default=False,
        description="Whether supporting document was provided",
    )

    @computed_field
    @property
    def approval_turnaround_days(self) -> Optional[int]:
        """Calculate days taken for approval."""
        if self.approved_at is None:
            return None
        return (self.approved_at - self.applied_at).days

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\leave\leave_base.py ---
# --- File: app/schemas/leave/leave_base.py ---
"""
Base leave schemas with comprehensive validation and type safety.

This module provides foundational schemas for leave management including
applications, updates, and core validation logic.
"""

from __future__ import annotations

from datetime import date
from typing import Optional

from pydantic import Field, HttpUrl, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import LeaveStatus, LeaveType

__all__ = [
    "LeaveBase",
    "LeaveCreate",
    "LeaveUpdate",
]


class LeaveBase(BaseSchema):
    """
    Base leave application schema with core fields.
    
    Provides common leave attributes and validation logic used across
    create/update operations.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier requesting leave",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    leave_type: LeaveType = Field(
        ...,
        description="Type of leave being requested",
    )
    from_date: date = Field(
        ...,
        description="Leave start date (inclusive)",
    )
    to_date: date = Field(
        ...,
        description="Leave end date (inclusive)",
    )
    total_days: int = Field(
        ...,
        ge=1,
        le=365,
        description="Total number of leave days (auto-calculated)",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=1000,
        description="Detailed reason for leave request",
    )
    contact_during_leave: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact phone number during leave period",
    )
    emergency_contact: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone number",
    )
    supporting_document_url: Optional[HttpUrl] = Field(
        None,
        description="URL to supporting document (e.g., medical certificate)",
    )

    @field_validator("from_date")
    @classmethod
    def validate_from_date(cls, v: date) -> date:
        """
        Validate leave start date constraints.
        
        Ensures:
        - Start date is not too far in the past (max 30 days)
        - Start date is within reasonable future range (max 1 year)
        """
        today = date.today()
        
        # Don't allow leaves starting more than 30 days in the past
        days_past = (today - v).days
        if days_past > 30:
            raise ValueError(
                "Leave start date cannot be more than 30 days in the past"
            )
        
        # Don't allow leaves starting more than 1 year in the future
        days_future = (v - today).days
        if days_future > 365:
            raise ValueError(
                "Leave start date cannot be more than 1 year in the future"
            )
        
        return v

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """
        Validate and normalize leave reason.
        
        Ensures reason is meaningful and properly formatted.
        """
        v = v.strip()
        
        if len(v) < 10:
            raise ValueError("Leave reason must be at least 10 characters")
        
        # Check if reason is not just repeated characters or meaningless text
        if len(set(v.lower().replace(" ", ""))) < 5:
            raise ValueError("Leave reason must be meaningful and descriptive")
        
        return v

    @field_validator("contact_during_leave", "emergency_contact")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone numbers by removing spaces and dashes."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return None

    @model_validator(mode="after")
    def validate_leave_dates(self) -> "LeaveBase":
        """
        Validate leave date consistency and calculate total days.
        
        Ensures:
        - End date is after or equal to start date
        - Total days matches actual duration
        - Leave duration is reasonable (not too long)
        """
        # Validate end date is after start date
        if self.to_date < self.from_date:
            raise ValueError("Leave end date must be after or equal to start date")
        
        # Calculate expected total days
        expected_days = (self.to_date - self.from_date).days + 1
        
        # Validate total_days matches calculation
        if self.total_days != expected_days:
            raise ValueError(
                f"total_days ({self.total_days}) must equal calculated duration "
                f"({expected_days} days)"
            )
        
        # Validate reasonable leave duration based on leave type
        max_days_by_type = {
            LeaveType.CASUAL: 30,
            LeaveType.SICK: 60,
            LeaveType.EMERGENCY: 15,
            LeaveType.VACATION: 90,
            LeaveType.OTHER: 30,
        }
        
        max_allowed = max_days_by_type.get(self.leave_type, 30)
        if self.total_days > max_allowed:
            raise ValueError(
                f"{self.leave_type.value} leave cannot exceed {max_allowed} days"
            )
        
        return self

    @model_validator(mode="after")
    def validate_document_requirement(self) -> "LeaveBase":
        """
        Validate supporting document requirements.
        
        Certain leave types or durations require supporting documents.
        """
        # Sick leave > 3 days requires medical certificate
        if self.leave_type == LeaveType.SICK and self.total_days > 3:
            if not self.supporting_document_url:
                raise ValueError(
                    "Medical certificate required for sick leave exceeding 3 days"
                )
        
        # Any leave > 15 days requires documentation
        if self.total_days > 15:
            if not self.supporting_document_url:
                raise ValueError(
                    "Supporting documentation required for leave exceeding 15 days"
                )
        
        return self


class LeaveCreate(LeaveBase, BaseCreateSchema):
    """
    Create leave application request.
    
    Inherits all validation from LeaveBase and adds creation context.
    """

    # Override total_days to make it optional (will be auto-calculated)
    total_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Total leave days (auto-calculated if not provided)",
    )

    @model_validator(mode="after")
    def calculate_total_days(self) -> "LeaveCreate":
        """
        Auto-calculate total_days if not provided.
        
        Calculates duration from from_date and to_date.
        """
        if self.total_days is None:
            self.total_days = (self.to_date - self.from_date).days + 1
        return self


class LeaveUpdate(BaseUpdateSchema):
    """
    Update leave application with partial fields.
    
    All fields are optional for flexible updates. Typically used
    before leave approval to modify application details.
    """

    leave_type: Optional[LeaveType] = Field(
        None,
        description="Updated leave type",
    )
    from_date: Optional[date] = Field(
        None,
        description="Updated start date",
    )
    to_date: Optional[date] = Field(
        None,
        description="Updated end date",
    )
    total_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Updated total days",
    )
    reason: Optional[str] = Field(
        None,
        min_length=10,
        max_length=1000,
        description="Updated leave reason",
    )
    contact_during_leave: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Updated contact number",
    )
    emergency_contact: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Updated emergency contact",
    )
    supporting_document_url: Optional[HttpUrl] = Field(
        None,
        description="Updated supporting document URL",
    )
    status: Optional[LeaveStatus] = Field(
        None,
        description="Updated leave status (restricted to certain roles)",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: Optional[str]) -> Optional[str]:
        """Validate updated reason if provided."""
        if v is not None:
            v = v.strip()
            if len(v) < 10:
                raise ValueError("Leave reason must be at least 10 characters")
            if len(set(v.lower().replace(" ", ""))) < 5:
                raise ValueError("Leave reason must be meaningful")
            return v
        return None

    @field_validator("contact_during_leave", "emergency_contact")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone numbers."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return None

    @model_validator(mode="after")
    def validate_date_consistency(self) -> "LeaveUpdate":
        """
        Validate date consistency when both dates are updated.
        
        Ensures end date is after start date when both are provided.
        """
        # Only validate if both dates are being updated
        if self.from_date is not None and self.to_date is not None:
            if self.to_date < self.from_date:
                raise ValueError("End date must be after or equal to start date")
            
            # Recalculate total_days if dates changed but total_days not provided
            if self.total_days is None:
                self.total_days = (self.to_date - self.from_date).days + 1
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\leave\leave_response.py ---
# --- File: app/schemas/leave/leave_response.py ---
"""
Leave response schemas for API responses.

Provides various response formats for leave data including
detailed, summary, and list views with computed fields.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Optional

from pydantic import Field, computed_field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import LeaveStatus, LeaveType

__all__ = [
    "LeaveResponse",
    "LeaveDetail",
    "LeaveListItem",
    "LeaveSummary",
]


class LeaveResponse(BaseResponseSchema):
    """
    Standard leave response with essential information.
    
    Lightweight response schema for list views and basic queries.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    leave_type: LeaveType = Field(
        ...,
        description="Type of leave",
    )
    from_date: date = Field(
        ...,
        description="Leave start date",
    )
    to_date: date = Field(
        ...,
        description="Leave end date",
    )
    total_days: int = Field(
        ...,
        description="Total leave days",
    )
    status: LeaveStatus = Field(
        ...,
        description="Current leave status",
    )
    applied_at: datetime = Field(
        ...,
        description="Application submission timestamp",
    )
    reason: Optional[str] = Field(
        None,
        description="Leave reason (truncated for list view)",
    )

    @computed_field
    @property
    def status_display(self) -> str:
        """Human-readable status display."""
        status_map = {
            LeaveStatus.PENDING: "Pending Approval",
            LeaveStatus.APPROVED: "Approved",
            LeaveStatus.REJECTED: "Rejected",
            LeaveStatus.CANCELLED: "Cancelled",
        }
        return status_map.get(self.status, self.status.value)

    @computed_field
    @property
    def leave_type_display(self) -> str:
        """Human-readable leave type display."""
        type_map = {
            LeaveType.CASUAL: "Casual Leave",
            LeaveType.SICK: "Sick Leave",
            LeaveType.EMERGENCY: "Emergency Leave",
            LeaveType.VACATION: "Vacation",
            LeaveType.OTHER: "Other",
        }
        return type_map.get(self.leave_type, self.leave_type.value)

    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if leave is currently active."""
        if self.status != LeaveStatus.APPROVED:
            return False
        
        today = date.today()
        return self.from_date <= today <= self.to_date

    @computed_field
    @property
    def days_remaining(self) -> Optional[int]:
        """Calculate remaining days for active leave."""
        if not self.is_active:
            return None
        
        return (self.to_date - date.today()).days + 1


class LeaveDetail(BaseResponseSchema):
    """
    Detailed leave information with complete metadata.
    
    Comprehensive response including all leave details, approval workflow,
    and supporting information.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    student_email: Optional[str] = Field(
        None,
        description="Student email address",
    )
    student_phone: Optional[str] = Field(
        None,
        description="Student phone number",
    )
    student_room: Optional[str] = Field(
        None,
        description="Student room number",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )

    # Leave details
    leave_type: LeaveType = Field(
        ...,
        description="Type of leave",
    )
    from_date: date = Field(
        ...,
        description="Leave start date",
    )
    to_date: date = Field(
        ...,
        description="Leave end date",
    )
    total_days: int = Field(
        ...,
        description="Total leave days",
    )
    reason: str = Field(
        ...,
        description="Detailed leave reason",
    )

    # Contact information
    contact_during_leave: Optional[str] = Field(
        None,
        description="Contact number during leave",
    )
    emergency_contact: Optional[str] = Field(
        None,
        description="Emergency contact number",
    )
    emergency_contact_relation: Optional[str] = Field(
        None,
        description="Relation with emergency contact",
    )
    destination_address: Optional[str] = Field(
        None,
        description="Destination address",
    )

    # Supporting documents
    supporting_document_url: Optional[str] = Field(
        None,
        description="Supporting document URL",
    )

    # Status and workflow
    status: LeaveStatus = Field(
        ...,
        description="Current leave status",
    )
    applied_at: datetime = Field(
        ...,
        description="Application submission timestamp",
    )

    # Approval details
    approved_at: Optional[datetime] = Field(
        None,
        description="Approval timestamp",
    )
    approved_by: Optional[UUID] = Field(
        None,
        description="Approver user ID",
    )
    approved_by_name: Optional[str] = Field(
        None,
        description="Approver name",
    )
    approval_notes: Optional[str] = Field(
        None,
        description="Approval notes",
    )
    conditions: Optional[str] = Field(
        None,
        description="Approval conditions",
    )

    # Rejection details
    rejected_at: Optional[datetime] = Field(
        None,
        description="Rejection timestamp",
    )
    rejected_by: Optional[UUID] = Field(
        None,
        description="Rejector user ID",
    )
    rejected_by_name: Optional[str] = Field(
        None,
        description="Rejector name",
    )
    rejection_reason: Optional[str] = Field(
        None,
        description="Rejection reason",
    )

    # Cancellation details
    cancelled_at: Optional[datetime] = Field(
        None,
        description="Cancellation timestamp",
    )
    cancelled_by: Optional[UUID] = Field(
        None,
        description="User who cancelled",
    )
    cancellation_reason: Optional[str] = Field(
        None,
        description="Cancellation reason",
    )

    # Additional metadata
    last_modified_at: Optional[datetime] = Field(
        None,
        description="Last modification timestamp",
    )
    last_modified_by: Optional[UUID] = Field(
        None,
        description="Last modifier user ID",
    )

    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if leave is currently active."""
        if self.status != LeaveStatus.APPROVED:
            return False
        
        today = date.today()
        return self.from_date <= today <= self.to_date

    @computed_field
    @property
    def is_upcoming(self) -> bool:
        """Check if leave is upcoming."""
        if self.status != LeaveStatus.APPROVED:
            return False
        
        return self.from_date > date.today()

    @computed_field
    @property
    def is_past(self) -> bool:
        """Check if leave is in the past."""
        return self.to_date < date.today()

    @computed_field
    @property
    def can_be_cancelled(self) -> bool:
        """Check if leave can be cancelled by student."""
        # Can only cancel pending or approved (future/ongoing) leaves
        if self.status not in [LeaveStatus.PENDING, LeaveStatus.APPROVED]:
            return False
        
        # Can't cancel past leaves
        if self.is_past:
            return False
        
        return True


class LeaveListItem(BaseSchema):
    """
    Minimal leave list item for efficient list rendering.
    
    Optimized for pagination and list views with minimal data transfer.
    """

    id: UUID = Field(
        ...,
        description="Leave application unique identifier",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Room number",
    )
    leave_type: LeaveType = Field(
        ...,
        description="Leave type",
    )
    from_date: date = Field(
        ...,
        description="Start date",
    )
    to_date: date = Field(
        ...,
        description="End date",
    )
    total_days: int = Field(
        ...,
        description="Total days",
    )
    status: LeaveStatus = Field(
        ...,
        description="Leave status",
    )
    applied_at: datetime = Field(
        ...,
        description="Application date",
    )

    @computed_field
    @property
    def status_badge_color(self) -> str:
        """Get color code for status badge (for UI rendering)."""
        color_map = {
            LeaveStatus.PENDING: "yellow",
            LeaveStatus.APPROVED: "green",
            LeaveStatus.REJECTED: "red",
            LeaveStatus.CANCELLED: "gray",
        }
        return color_map.get(self.status, "gray")

    @computed_field
    @property
    def is_urgent(self) -> bool:
        """Check if leave requires urgent attention."""
        # Pending leaves starting soon are urgent
        if self.status == LeaveStatus.PENDING:
            days_until_start = (self.from_date - date.today()).days
            return days_until_start <= 2
        return False


class LeaveSummary(BaseSchema):
    """
    Leave summary statistics for dashboard.
    
    Provides aggregated view of leave status for reporting.
    """

    student_id: Optional[UUID] = Field(
        None,
        description="Student ID (if student-specific summary)",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID (if hostel-specific summary)",
    )
    period_start: date = Field(
        ...,
        description="Summary period start date",
    )
    period_end: date = Field(
        ...,
        description="Summary period end date",
    )

    # Count by status
    total_applications: int = Field(
        ...,
        ge=0,
        description="Total leave applications",
    )
    pending_count: int = Field(
        ...,
        ge=0,
        description="Pending applications",
    )
    approved_count: int = Field(
        ...,
        ge=0,
        description="Approved applications",
    )
    rejected_count: int = Field(
        ...,
        ge=0,
        description="Rejected applications",
    )
    cancelled_count: int = Field(
        ...,
        ge=0,
        description="Cancelled applications",
    )

    # Count by type
    casual_count: int = Field(
        default=0,
        ge=0,
        description="Casual leave count",
    )
    sick_count: int = Field(
        default=0,
        ge=0,
        description="Sick leave count",
    )
    emergency_count: int = Field(
        default=0,
        ge=0,
        description="Emergency leave count",
    )
    vacation_count: int = Field(
        default=0,
        ge=0,
        description="Vacation count",
    )

    # Day statistics
    total_days_requested: int = Field(
        ...,
        ge=0,
        description="Total days requested across all applications",
    )
    total_days_approved: int = Field(
        ...,
        ge=0,
        description="Total days approved",
    )
    active_leaves: int = Field(
        default=0,
        ge=0,
        description="Currently active leaves",
    )

    @computed_field
    @property
    def approval_rate(self) -> float:
        """Calculate approval rate percentage."""
        total_decided = self.approved_count + self.rejected_count
        if total_decided == 0:
            return 0.0
        return round((self.approved_count / total_decided) * 100, 2)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\leave\__init__.py ---
# --- File: app/schemas/leave/__init__.py ---
"""
Leave management schemas package.

Comprehensive leave application, approval, and balance tracking schemas
for hostel management system with enhanced validation and type safety.
"""

from __future__ import annotations

from app.schemas.leave.leave_application import (
    LeaveApplicationRequest,
    LeaveCancellationRequest,
)
from app.schemas.leave.leave_approval import (
    LeaveApprovalAction,
    LeaveApprovalRequest,
    LeaveApprovalResponse,
)
from app.schemas.leave.leave_balance import (
    LeaveBalance,
    LeaveBalanceSummary,
    LeaveQuota,
    LeaveUsageDetail,
)
from app.schemas.leave.leave_base import (
    LeaveBase,
    LeaveCreate,
    LeaveUpdate,
)
from app.schemas.leave.leave_response import (
    LeaveDetail,
    LeaveListItem,
    LeaveResponse,
    LeaveSummary,
)

__all__ = [
    # Base schemas
    "LeaveBase",
    "LeaveCreate",
    "LeaveUpdate",
    # Response schemas
    "LeaveResponse",
    "LeaveDetail",
    "LeaveListItem",
    "LeaveSummary",
    # Application schemas
    "LeaveApplicationRequest",
    "LeaveCancellationRequest",
    # Approval schemas
    "LeaveApprovalRequest",
    "LeaveApprovalAction",
    "LeaveApprovalResponse",
    # Balance schemas
    "LeaveBalance",
    "LeaveBalanceSummary",
    "LeaveQuota",
    "LeaveUsageDetail",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\maintenance =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\maintenance\maintenance_analytics.py ---
# --- File: app/schemas/maintenance/maintenance_analytics.py ---
"""
Maintenance analytics schemas for insights and reporting.

Provides comprehensive analytics with trends, performance metrics,
and vendor analysis for data-driven decision making.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, computed_field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "MaintenanceAnalytics",
    "TrendPoint",
    "CostTrendPoint",
    "CategoryBreakdown",
    "VendorPerformance",
    "PerformanceMetrics",
    "ProductivityMetrics",
]


class TrendPoint(BaseSchema):
    """
    Single data point in trend analysis.
    
    Represents metrics for a specific time period.
    """

    period: str = Field(
        ...,
        description="Period identifier (date, week, month, etc.)",
    )
    period_start: date = Field(
        ...,
        description="Period start date",
    )
    period_end: date = Field(
        ...,
        description="Period end date",
    )
    request_count: int = Field(
        ...,
        ge=0,
        description="Total requests in period",
    )
    completed_count: int = Field(
        ...,
        ge=0,
        description="Completed requests",
    )
    pending_count: int = Field(
        default=0,
        ge=0,
        description="Pending requests",
    )
    average_completion_days: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average days to complete",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate for period."""
        if self.request_count == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.completed_count) / Decimal(self.request_count) * 100,
            2,
        )


class CostTrendPoint(BaseSchema):
    """
    Cost trend data point.
    
    Tracks cost metrics over time periods.
    """

    period: str = Field(
        ...,
        description="Period identifier",
    )
    period_start: date = Field(
        ...,
        description="Period start date",
    )
    period_end: date = Field(
        ...,
        description="Period end date",
    )
    total_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total cost in period",
    )
    request_count: int = Field(
        ...,
        ge=0,
        description="Number of requests",
    )
    average_cost: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )
    budget_allocated: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Budget allocated for period",
    )
    variance_from_budget: Optional[Decimal] = Field(
        None,
        description="Variance from budget",
    )

    @computed_field
    @property
    def budget_utilization(self) -> Optional[Decimal]:
        """Calculate budget utilization percentage."""
        if self.budget_allocated is None or self.budget_allocated == 0:
            return None
        return round(
            self.total_cost / self.budget_allocated * 100,
            2,
        )


class CategoryBreakdown(BaseSchema):
    """
    Detailed breakdown by maintenance category.
    
    Provides comprehensive metrics for a specific category.
    """

    category: str = Field(
        ...,
        description="Maintenance category name",
    )
    category_code: Optional[str] = Field(
        None,
        description="Category code",
    )
    total_requests: int = Field(
        ...,
        ge=0,
        description="Total requests in category",
    )
    completed_requests: int = Field(
        ...,
        ge=0,
        description="Completed requests",
    )
    pending_requests: int = Field(
        default=0,
        ge=0,
        description="Pending requests",
    )
    cancelled_requests: int = Field(
        default=0,
        ge=0,
        description="Cancelled requests",
    )
    total_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total cost for category",
    )
    average_cost: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )
    median_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Median cost",
    )
    average_completion_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average completion time in hours",
    )
    average_completion_time_days: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average completion time in days",
    )
    on_time_completion_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage completed on time",
    )
    
    # Priority distribution
    high_priority_count: int = Field(
        default=0,
        ge=0,
        description="High priority requests",
    )
    urgent_priority_count: int = Field(
        default=0,
        ge=0,
        description="Urgent priority requests",
    )
    
    # Quality metrics
    quality_check_pass_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Quality check pass rate",
    )
    average_quality_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average quality rating",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate."""
        if self.total_requests == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.completed_requests) / Decimal(self.total_requests) * 100,
            2,
        )

    @computed_field
    @property
    def cost_per_completed(self) -> Decimal:
        """Calculate cost per completed request."""
        if self.completed_requests == 0:
            return Decimal("0.00")
        return round(
            self.total_cost / Decimal(self.completed_requests),
            2,
        )


class VendorPerformance(BaseSchema):
    """
    Vendor performance metrics and analysis.
    
    Tracks vendor efficiency, cost, quality, and reliability.
    """

    vendor_id: Optional[UUID] = Field(
        None,
        description="Vendor unique identifier",
    )
    vendor_name: str = Field(
        ...,
        description="Vendor company name",
    )
    vendor_category: Optional[str] = Field(
        None,
        description="Vendor specialization category",
    )
    
    # Job statistics
    total_jobs: int = Field(
        ...,
        ge=0,
        description="Total jobs assigned",
    )
    completed_jobs: int = Field(
        ...,
        ge=0,
        description="Jobs completed",
    )
    in_progress_jobs: int = Field(
        default=0,
        ge=0,
        description="Jobs currently in progress",
    )
    cancelled_jobs: int = Field(
        default=0,
        ge=0,
        description="Jobs cancelled",
    )
    
    # Timeliness metrics
    on_time_completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage completed on time",
    )
    average_delay_days: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average delay in days (for delayed jobs)",
    )
    
    # Cost metrics
    total_spent: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total amount paid to vendor",
    )
    average_cost: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per job",
    )
    cost_competitiveness: str = Field(
        ...,
        pattern=r"^(low|medium|high)$",
        description="Cost competitiveness rating",
    )
    cost_variance_percentage: Optional[Decimal] = Field(
        None,
        description="Average cost variance from estimates",
    )
    
    # Quality metrics
    quality_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average quality rating (1-5 stars)",
    )
    quality_check_pass_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Quality check pass rate",
    )
    rework_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Percentage requiring rework",
    )
    
    # Customer satisfaction
    customer_satisfaction_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Customer satisfaction score",
    )
    complaint_count: int = Field(
        default=0,
        ge=0,
        description="Number of complaints received",
    )
    
    # Reliability
    response_time_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average response time in hours",
    )
    availability_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Vendor availability score",
    )
    
    # Engagement period
    first_job_date: Optional[date] = Field(
        None,
        description="Date of first job",
    )
    last_job_date: Optional[date] = Field(
        None,
        description="Date of most recent job",
    )
    
    # Recommendations
    recommended: bool = Field(
        default=True,
        description="Whether vendor is recommended",
    )
    performance_tier: str = Field(
        ...,
        pattern=r"^(platinum|gold|silver|bronze|needs_improvement)$",
        description="Performance tier classification",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate job completion rate."""
        if self.total_jobs == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.completed_jobs) / Decimal(self.total_jobs) * 100,
            2,
        )

    @computed_field
    @property
    def overall_performance_score(self) -> Decimal:
        """
        Calculate overall performance score.
        
        Weighted average of completion rate, quality, and timeliness.
        """
        weights = {
            "completion": 0.3,
            "quality": 0.3,
            "timeliness": 0.4,
        }
        
        completion_score = float(self.completion_rate)
        quality_score = float(self.quality_rating or 3.0) * 20  # Convert 1-5 to 0-100
        timeliness_score = float(self.on_time_completion_rate)
        
        overall = (
            completion_score * weights["completion"]
            + quality_score * weights["quality"]
            + timeliness_score * weights["timeliness"]
        )
        
        return round(Decimal(str(overall)), 2)


class PerformanceMetrics(BaseSchema):
    """
    Overall maintenance performance metrics.
    
    Provides key performance indicators for maintenance operations.
    """

    period: DateRangeFilter = Field(
        ...,
        description="Analysis period",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID (if hostel-specific)",
    )
    
    # Request metrics
    total_requests: int = Field(
        ...,
        ge=0,
        description="Total maintenance requests",
    )
    completed_requests: int = Field(
        ...,
        ge=0,
        description="Completed requests",
    )
    pending_requests: int = Field(
        ...,
        ge=0,
        description="Pending requests",
    )
    cancelled_requests: int = Field(
        default=0,
        ge=0,
        description="Cancelled requests",
    )
    
    # Completion metrics
    completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall completion rate",
    )
    average_completion_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average time to complete (hours)",
    )
    average_completion_time_days: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average time to complete (days)",
    )
    median_completion_time_days: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Median completion time (days)",
    )
    on_time_completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage completed on time",
    )
    
    # Cost metrics
    total_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total maintenance cost",
    )
    average_cost_per_request: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )
    cost_variance_percentage: Decimal = Field(
        ...,
        decimal_places=2,
        description="Average cost variance from estimates",
    )
    within_budget_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage completed within budget",
    )
    
    # Quality metrics
    quality_check_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Percentage of requests quality checked",
    )
    quality_pass_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Quality check pass rate",
    )
    average_quality_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average quality rating",
    )
    rework_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Percentage requiring rework",
    )
    
    # Response metrics
    average_response_time_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average time to assign/respond (hours)",
    )
    average_assignment_time_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average time to assign (hours)",
    )
    
    # Priority distribution
    critical_requests: int = Field(
        default=0,
        ge=0,
        description="Critical priority requests",
    )
    urgent_requests: int = Field(
        default=0,
        ge=0,
        description="Urgent priority requests",
    )
    high_requests: int = Field(
        default=0,
        ge=0,
        description="High priority requests",
    )

    @computed_field
    @property
    def efficiency_score(self) -> Decimal:
        """
        Calculate overall efficiency score (0-100).
        
        Composite metric based on completion rate, timeliness, and quality.
        """
        weights = {
            "completion": 0.4,
            "timeliness": 0.3,
            "quality": 0.3,
        }
        
        completion_score = float(self.completion_rate)
        timeliness_score = float(self.on_time_completion_rate)
        quality_score = float(self.quality_pass_rate)
        
        efficiency = (
            completion_score * weights["completion"]
            + timeliness_score * weights["timeliness"]
            + quality_score * weights["quality"]
        )
        
        return round(Decimal(str(efficiency)), 2)


class ProductivityMetrics(BaseSchema):
    """
    Staff and team productivity metrics.
    
    Tracks productivity of maintenance teams and individuals.
    """

    period: DateRangeFilter = Field(
        ...,
        description="Analysis period",
    )
    team_id: Optional[UUID] = Field(
        None,
        description="Team ID (if team-specific)",
    )
    staff_member_id: Optional[UUID] = Field(
        None,
        description="Staff member ID (if individual)",
    )
    
    # Workload metrics
    total_assignments: int = Field(
        ...,
        ge=0,
        description="Total assignments",
    )
    completed_assignments: int = Field(
        ...,
        ge=0,
        description="Completed assignments",
    )
    active_assignments: int = Field(
        default=0,
        ge=0,
        description="Currently active assignments",
    )
    
    # Productivity metrics
    average_jobs_per_day: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average jobs completed per day",
    )
    average_hours_per_job: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average hours spent per job",
    )
    utilization_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Staff utilization rate",
    )
    
    # Quality and timeliness
    on_time_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="On-time completion rate",
    )
    quality_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Average quality score",
    )
    
    # Specialization
    top_categories: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top maintenance categories handled",
    )
    specialization_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Specialization/expertise score",
    )

    @computed_field
    @property
    def productivity_score(self) -> Decimal:
        """Calculate overall productivity score."""
        completion_rate = (
            Decimal(self.completed_assignments) / Decimal(self.total_assignments) * 100
            if self.total_assignments > 0
            else Decimal("0.00")
        )
        
        # Weighted average
        weights = {
            "completion": 0.4,
            "timeliness": 0.3,
            "quality": 0.3,
        }
        
        quality_component = float(self.quality_score or 70.0)
        
        score = (
            float(completion_rate) * weights["completion"]
            + float(self.on_time_rate) * weights["timeliness"]
            + quality_component * weights["quality"]
        )
        
        return round(Decimal(str(score)), 2)


class MaintenanceAnalytics(BaseSchema):
    """
    Comprehensive maintenance analytics dashboard.
    
    Aggregates all analytics components for complete insights.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID (None for system-wide)",
    )
    hostel_name: Optional[str] = Field(
        None,
        description="Hostel name",
    )
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period",
    )
    generated_at: datetime = Field(
        ...,
        description="Analytics generation timestamp",
    )
    
    # Summary metrics
    total_requests: int = Field(
        ...,
        ge=0,
        description="Total maintenance requests",
    )
    completed_requests: int = Field(
        ...,
        ge=0,
        description="Completed requests",
    )
    pending_requests: int = Field(
        ...,
        ge=0,
        description="Pending requests",
    )
    
    # Cost summary
    total_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total maintenance cost",
    )
    average_cost: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )
    budget_utilization: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Budget utilization percentage",
    )
    
    # Performance summary
    average_completion_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average completion time",
    )
    completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Completion rate",
    )
    on_time_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="On-time completion rate",
    )
    
    # Breakdowns
    requests_by_category: Dict[str, int] = Field(
        ...,
        description="Request count by category",
    )
    cost_by_category: Dict[str, Decimal] = Field(
        ...,
        description="Cost breakdown by category",
    )
    requests_by_priority: Dict[str, int] = Field(
        default_factory=dict,
        description="Request count by priority",
    )
    
    # Trends
    request_trend: List[TrendPoint] = Field(
        ...,
        description="Request volume trends over time",
    )
    cost_trend: List[CostTrendPoint] = Field(
        ...,
        description="Cost trends over time",
    )
    
    # Detailed breakdowns
    category_breakdown: Optional[List[CategoryBreakdown]] = Field(
        None,
        description="Detailed category analysis",
    )
    vendor_performance: Optional[List[VendorPerformance]] = Field(
        None,
        description="Vendor performance metrics",
    )
    
    # Insights and recommendations
    top_cost_drivers: Optional[List[str]] = Field(
        None,
        max_length=5,
        description="Top cost drivers",
    )
    efficiency_opportunities: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Identified efficiency opportunities",
    )
    risk_areas: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Identified risk areas",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\maintenance\maintenance_approval.py ---
# --- File: app/schemas/maintenance/maintenance_approval.py ---
"""
Maintenance approval workflow schemas.

Provides schemas for approval requests, responses, threshold configuration,
and rejection handling with comprehensive validation.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Dict, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "ApprovalRequest",
    "ApprovalResponse",
    "ThresholdConfig",
    "ApprovalWorkflow",
    "RejectionRequest",
]


class ApprovalRequest(BaseCreateSchema):
    """
    Request approval for maintenance work.
    
    Submitted by supervisor to admin when cost exceeds threshold
    or approval is required for other reasons.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Maintenance request number",
    )
    
    # Cost details
    estimated_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Estimated total cost",
    )
    cost_breakdown: Optional[Dict[str, Decimal]] = Field(
        None,
        description="Detailed cost breakdown by category",
    )
    cost_justification: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Detailed justification for cost estimate",
    )
    
    # Approval justification
    approval_reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Reason why approval is needed",
    )
    business_impact: Optional[str] = Field(
        None,
        max_length=500,
        description="Impact on business/operations if not approved",
    )
    
    # Urgency
    urgent: bool = Field(
        False,
        description="Whether approval is urgent",
    )
    urgency_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for urgency (if urgent)",
    )
    
    # Vendor information
    preferred_vendor: Optional[str] = Field(
        None,
        max_length=255,
        description="Preferred vendor/contractor",
    )
    vendor_quote: Optional[str] = Field(
        None,
        description="Vendor quote reference or URL",
    )
    alternative_quotes: Optional[int] = Field(
        None,
        ge=0,
        le=10,
        description="Number of alternative quotes obtained",
    )
    
    # Timeline
    requested_completion_date: Optional[date] = Field(
        None,
        description="Requested completion date",
    )
    
    # Requester
    requested_by: UUID = Field(
        ...,
        description="Supervisor requesting approval",
    )

    @field_validator("estimated_cost")
    @classmethod
    def round_cost(cls, v: Decimal) -> Decimal:
        """Round cost to 2 decimal places."""
        return round(v, 2)

    @field_validator("cost_breakdown")
    @classmethod
    def validate_cost_breakdown(
        cls,
        v: Optional[Dict[str, Decimal]],
    ) -> Optional[Dict[str, Decimal]]:
        """
        Validate cost breakdown values.
        
        Ensures all breakdown amounts are positive and reasonable.
        """
        if v is not None:
            for category, amount in v.items():
                if amount < 0:
                    raise ValueError(
                        f"Cost breakdown amount for '{category}' cannot be negative"
                    )
                
                # Round to 2 decimal places
                v[category] = round(amount, 2)
        
        return v

    @field_validator(
        "cost_justification",
        "approval_reason",
        "business_impact",
        "urgency_reason",
    )
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize text fields."""
        if v is not None:
            v = v.strip()
            
            # For required fields (cost_justification, approval_reason)
            if isinstance(v, str) and len(v) > 0:
                return v
            
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_urgency_requirements(self) -> "ApprovalRequest":
        """
        Validate urgency flag consistency.
        
        Urgent requests should have urgency reason.
        """
        if self.urgent and not self.urgency_reason:
            raise ValueError(
                "Urgency reason is required when approval is marked urgent"
            )
        
        return self

    @model_validator(mode="after")
    def validate_cost_breakdown_total(self) -> "ApprovalRequest":
        """
        Validate cost breakdown matches estimated cost.
        
        Sum of breakdown should match total estimate.
        """
        if self.cost_breakdown:
            breakdown_total = sum(self.cost_breakdown.values())
            
            # Allow 1% variance for rounding
            variance = abs(breakdown_total - self.estimated_cost)
            max_variance = self.estimated_cost * Decimal("0.01")
            
            if variance > max_variance and variance > Decimal("10.00"):
                raise ValueError(
                    f"Cost breakdown total ({breakdown_total}) doesn't match "
                    f"estimated cost ({self.estimated_cost})"
                )
        
        return self


class ApprovalResponse(BaseSchema):
    """
    Approval decision response.
    
    Provides complete information about approval or rejection
    with justification and conditions.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    
    # Decision
    approved: bool = Field(
        ...,
        description="Whether request was approved",
    )
    decision_maker: UUID = Field(
        ...,
        description="User ID who made decision",
    )
    decision_maker_name: str = Field(
        ...,
        description="Name of decision maker",
    )
    decision_maker_role: str = Field(
        ...,
        description="Role of decision maker",
    )
    decided_at: datetime = Field(
        ...,
        description="Decision timestamp",
    )
    
    # Approved details (if approved)
    approved_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Approved amount (may differ from requested)",
    )
    approval_conditions: Optional[str] = Field(
        None,
        max_length=1000,
        description="Conditions or requirements for approval",
    )
    approval_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional approval notes",
    )
    
    # Rejection details (if rejected)
    rejection_reason: Optional[str] = Field(
        None,
        max_length=1000,
        description="Detailed rejection reason",
    )
    suggested_alternative: Optional[str] = Field(
        None,
        max_length=500,
        description="Suggested alternative approach",
    )
    resubmission_allowed: bool = Field(
        default=True,
        description="Whether request can be resubmitted",
    )
    
    # Response message
    message: str = Field(
        ...,
        description="Human-readable response message",
    )
    
    # Notification tracking
    notifications_sent: bool = Field(
        default=False,
        description="Whether notifications were sent",
    )

    @field_validator("approved_amount")
    @classmethod
    def round_amount(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round approved amount to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_response_consistency(self) -> "ApprovalResponse":
        """
        Validate approval response consistency.
        
        Ensures approval/rejection fields are consistent with decision.
        """
        if self.approved:
            # Approved requests should have approved amount
            if self.approved_amount is None:
                raise ValueError(
                    "Approved amount is required for approved requests"
                )
            
            # Shouldn't have rejection details
            if self.rejection_reason:
                raise ValueError(
                    "Rejection reason should not be present for approved requests"
                )
        else:
            # Rejected requests must have rejection reason
            if not self.rejection_reason:
                raise ValueError(
                    "Rejection reason is required for rejected requests"
                )
            
            if len(self.rejection_reason.strip()) < 20:
                raise ValueError(
                    "Rejection reason must be at least 20 characters"
                )
            
            # Shouldn't have approval details
            if self.approval_conditions or self.approved_amount:
                raise ValueError(
                    "Approval details should not be present for rejected requests"
                )
        
        return self


class ThresholdConfig(BaseSchema):
    """
    Approval threshold configuration for hostel.
    
    Defines cost limits and approval requirements for
    different authorization levels.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    
    # Supervisor approval threshold
    supervisor_approval_limit: Decimal = Field(
        Decimal("5000.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Maximum amount supervisor can approve independently",
    )
    
    # Admin approval required above
    admin_approval_required_above: Decimal = Field(
        Decimal("5000.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Amount above which admin approval is required",
    )
    
    # Auto-approve threshold
    auto_approve_below: Decimal = Field(
        Decimal("1000.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Amount below which requests are auto-approved",
    )
    auto_approve_enabled: bool = Field(
        default=True,
        description="Whether auto-approval is enabled",
    )
    
    # Senior management threshold
    senior_management_required_above: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Amount requiring senior management approval",
    )
    
    # Emergency handling
    emergency_bypass_threshold: bool = Field(
        True,
        description="Allow emergency requests to bypass normal thresholds",
    )
    emergency_approval_limit: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Special limit for emergency approvals",
    )
    
    # Category-specific thresholds
    category_specific_limits: Optional[Dict[str, Decimal]] = Field(
        None,
        description="Custom limits per maintenance category",
    )
    
    # Approval workflow
    require_multiple_quotes_above: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Amount above which multiple quotes required",
    )
    minimum_quotes_required: int = Field(
        default=3,
        ge=1,
        le=5,
        description="Minimum number of quotes for high-value work",
    )
    
    # Configuration metadata
    last_updated: datetime = Field(
        ...,
        description="Last configuration update",
    )
    updated_by: UUID = Field(
        ...,
        description="User who last updated configuration",
    )

    @field_validator(
        "supervisor_approval_limit",
        "admin_approval_required_above",
        "auto_approve_below",
        "senior_management_required_above",
        "emergency_approval_limit",
        "require_multiple_quotes_above",
    )
    @classmethod
    def round_amounts(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round threshold amounts to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_threshold_hierarchy(self) -> "ThresholdConfig":
        """
        Validate threshold amounts are in logical hierarchy.
        
        Auto-approve < Supervisor < Admin < Senior Management
        """
        # Auto-approve should be less than supervisor limit
        if self.auto_approve_below > self.supervisor_approval_limit:
            raise ValueError(
                "Auto-approve limit must be less than supervisor approval limit"
            )
        
        # Supervisor limit should equal admin threshold
        if self.supervisor_approval_limit != self.admin_approval_required_above:
            raise ValueError(
                "Supervisor approval limit should match admin required threshold"
            )
        
        # Senior management should be higher than admin
        if self.senior_management_required_above:
            if self.senior_management_required_above <= self.admin_approval_required_above:
                raise ValueError(
                    "Senior management threshold must be higher than admin threshold"
                )
        
        return self


class ApprovalWorkflow(BaseSchema):
    """
    Current approval workflow status.
    
    Tracks approval process state and pending actions.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    
    # Cost information
    estimated_cost: Decimal = Field(
        ...,
        ge=0,
        description="Estimated cost",
    )
    threshold_exceeded: bool = Field(
        ...,
        description="Whether cost exceeds threshold",
    )
    exceeded_threshold_type: Optional[str] = Field(
        None,
        pattern=r"^(supervisor|admin|senior_management)$",
        description="Which threshold was exceeded",
    )
    
    # Approval status
    requires_approval: bool = Field(
        ...,
        description="Whether approval is required",
    )
    approval_pending: bool = Field(
        ...,
        description="Whether approval is currently pending",
    )
    approval_level_required: Optional[str] = Field(
        None,
        pattern=r"^(supervisor|admin|senior_management)$",
        description="Required approval level",
    )
    
    # Current approver
    pending_with: Optional[UUID] = Field(
        None,
        description="User ID of current pending approver",
    )
    pending_with_name: Optional[str] = Field(
        None,
        description="Name of current pending approver",
    )
    pending_with_role: Optional[str] = Field(
        None,
        description="Role of pending approver",
    )
    
    # Timeline
    submitted_for_approval_at: Optional[datetime] = Field(
        None,
        description="When request was submitted for approval",
    )
    approval_deadline: Optional[datetime] = Field(
        None,
        description="Deadline for approval decision",
    )
    is_overdue: bool = Field(
        default=False,
        description="Whether approval is overdue",
    )
    
    # Previous approvals (for multi-level)
    previous_approvals: Optional[List[Dict[str, any]]] = Field(
        None,
        description="Previous approval steps (for multi-level workflows)",
    )
    
    # Escalation
    escalation_count: int = Field(
        default=0,
        ge=0,
        description="Number of times escalated",
    )
    last_escalated_at: Optional[datetime] = Field(
        None,
        description="Last escalation timestamp",
    )

    @field_validator("estimated_cost")
    @classmethod
    def round_cost(cls, v: Decimal) -> Decimal:
        """Round cost to 2 decimal places."""
        return round(v, 2)


class RejectionRequest(BaseCreateSchema):
    """
    Reject maintenance approval request.
    
    Provides detailed rejection with alternatives and guidance.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    rejected_by: UUID = Field(
        ...,
        description="User ID rejecting the request",
    )
    rejection_reason: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Detailed rejection reason",
    )
    rejection_category: Optional[str] = Field(
        None,
        pattern=r"^(cost_too_high|insufficient_justification|alternative_available|budget_constraints|not_urgent|other)$",
        description="Rejection category",
    )
    
    # Alternatives and suggestions
    suggested_alternative: Optional[str] = Field(
        None,
        max_length=500,
        description="Suggested alternative approach",
    )
    suggested_cost_reduction: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Suggested reduced cost amount",
    )
    suggested_vendor: Optional[str] = Field(
        None,
        max_length=255,
        description="Suggested alternative vendor",
    )
    
    # Resubmission guidance
    resubmission_allowed: bool = Field(
        default=True,
        description="Whether request can be resubmitted",
    )
    resubmission_requirements: Optional[str] = Field(
        None,
        max_length=1000,
        description="Requirements for resubmission",
    )
    
    # Notification
    notify_requester: bool = Field(
        default=True,
        description="Send rejection notification",
    )
    notify_supervisor: bool = Field(
        default=True,
        description="Notify supervisor",
    )

    @field_validator("rejection_reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate rejection reason is comprehensive."""
        v = v.strip()
        
        if len(v) < 20:
            raise ValueError(
                "Rejection reason must be at least 20 characters"
            )
        
        # Check for meaningful content
        if len(set(v.lower().replace(" ", ""))) < 10:
            raise ValueError(
                "Please provide a detailed and specific rejection reason"
            )
        
        return v

    @field_validator("suggested_cost_reduction")
    @classmethod
    def round_cost(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round suggested cost to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_resubmission_guidance(self) -> "RejectionRequest":
        """
        Validate resubmission guidance.
        
        If resubmission allowed, provide requirements.
        """
        if self.resubmission_allowed:
            # Should provide guidance on what needs to change
            if not any([
                self.suggested_alternative,
                self.suggested_cost_reduction,
                self.resubmission_requirements,
            ]):
                raise ValueError(
                    "Please provide guidance for resubmission (suggested alternative, "
                    "cost reduction, or specific requirements)"
                )
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\maintenance\maintenance_assignment.py ---
# --- File: app/schemas/maintenance/maintenance_assignment.py ---
"""
Maintenance assignment schemas for task allocation.

Provides schemas for assigning maintenance tasks to staff, vendors,
and contractors with tracking and history management.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import EmailStr, Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "TaskAssignment",
    "VendorAssignment",
    "AssignmentUpdate",
    "BulkAssignment",
    "AssignmentHistory",
    "AssignmentEntry",
]


class TaskAssignment(BaseSchema):
    """
    Maintenance task assignment to internal staff.
    
    Tracks assignment of maintenance tasks to hostel staff
    with deadlines and instructions.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Human-readable request number",
    )
    assigned_to: UUID = Field(
        ...,
        description="Staff member user ID",
    )
    assigned_to_name: str = Field(
        ...,
        description="Staff member full name",
    )
    assigned_to_role: Optional[str] = Field(
        None,
        description="Staff member role/designation",
    )
    assigned_by: UUID = Field(
        ...,
        description="Supervisor/admin who assigned the task",
    )
    assigned_by_name: str = Field(
        ...,
        description="Assignor full name",
    )
    assigned_at: datetime = Field(
        ...,
        description="Assignment timestamp",
    )
    deadline: Optional[date] = Field(
        None,
        description="Task completion deadline",
    )
    priority_level: Optional[str] = Field(
        None,
        pattern=r"^(low|medium|high|urgent|critical)$",
        description="Assignment priority",
    )
    instructions: Optional[str] = Field(
        None,
        max_length=1000,
        description="Specific instructions for assigned staff",
    )
    estimated_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        decimal_places=2,
        description="Estimated hours to complete",
    )
    required_skills: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Skills required for the task",
    )
    tools_required: Optional[List[str]] = Field(
        None,
        max_length=20,
        description="Tools/equipment required",
    )

    @field_validator("deadline")
    @classmethod
    def validate_deadline(cls, v: Optional[date]) -> Optional[date]:
        """
        Validate deadline is in the future.
        
        Deadlines should be reasonable and not too far out.
        """
        if v is not None:
            today = date.today()
            
            if v < today:
                raise ValueError("Deadline cannot be in the past")
            
            # Max 6 months out for regular tasks
            days_ahead = (v - today).days
            if days_ahead > 180:
                raise ValueError(
                    "Deadline cannot be more than 6 months in the future"
                )
        
        return v

    @field_validator("instructions")
    @classmethod
    def normalize_instructions(cls, v: Optional[str]) -> Optional[str]:
        """Normalize instructions text."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None


class VendorAssignment(BaseCreateSchema):
    """
    Assignment to external vendor/contractor.
    
    Manages outsourced maintenance work with contract terms,
    quotes, and payment details.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    vendor_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Vendor/contractor company name",
    )
    vendor_contact_person: Optional[str] = Field(
        None,
        max_length=255,
        description="Vendor contact person name",
    )
    vendor_contact: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Vendor primary contact number",
    )
    vendor_email: Optional[EmailStr] = Field(
        None,
        description="Vendor email address",
    )
    vendor_address: Optional[str] = Field(
        None,
        max_length=500,
        description="Vendor business address",
    )

    # Quote and contract
    quoted_amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Vendor quoted amount",
    )
    quote_reference: Optional[str] = Field(
        None,
        max_length=100,
        description="Quote reference number",
    )
    quote_valid_until: Optional[date] = Field(
        None,
        description="Quote validity date",
    )
    payment_terms: Optional[str] = Field(
        None,
        max_length=500,
        description="Payment terms and conditions",
    )
    advance_payment_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Advance payment percentage",
    )
    advance_payment_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Advance payment amount",
    )

    # Timeline
    estimated_start_date: Optional[date] = Field(
        None,
        description="Estimated work start date",
    )
    estimated_completion_date: date = Field(
        ...,
        description="Estimated completion date",
    )
    
    # Contract details
    work_order_number: Optional[str] = Field(
        None,
        max_length=100,
        description="Work order reference number",
    )
    contract_details: Optional[str] = Field(
        None,
        max_length=2000,
        description="Contract terms and scope of work",
    )
    warranty_period_months: Optional[int] = Field(
        None,
        ge=0,
        le=120,
        description="Warranty period in months",
    )
    warranty_terms: Optional[str] = Field(
        None,
        max_length=1000,
        description="Warranty terms and conditions",
    )

    # Insurance and compliance
    vendor_insured: bool = Field(
        default=False,
        description="Whether vendor has liability insurance",
    )
    insurance_details: Optional[str] = Field(
        None,
        max_length=500,
        description="Insurance policy details",
    )
    compliance_certificates: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Required compliance certificates",
    )

    @field_validator("vendor_contact")
    @classmethod
    def normalize_phone(cls, v: str) -> str:
        """Normalize vendor phone number."""
        return v.replace(" ", "").replace("-", "").strip()

    @field_validator("quoted_amount", "advance_payment_amount")
    @classmethod
    def round_amounts(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round monetary amounts to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @field_validator(
        "vendor_address",
        "payment_terms",
        "contract_details",
        "warranty_terms",
        "insurance_details",
    )
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_dates_consistency(self) -> "VendorAssignment":
        """
        Validate date consistency.
        
        Ensures start date is before completion date and dates are reasonable.
        """
        # Completion date should be in future
        if self.estimated_completion_date < date.today():
            raise ValueError(
                "Estimated completion date cannot be in the past"
            )
        
        # Start date should be before completion
        if self.estimated_start_date:
            if self.estimated_start_date > self.estimated_completion_date:
                raise ValueError(
                    "Start date must be before completion date"
                )
        
        # Quote validity
        if self.quote_valid_until:
            if self.quote_valid_until < date.today():
                raise ValueError(
                    "Quote validity date cannot be in the past"
                )
        
        return self

    @model_validator(mode="after")
    def validate_advance_payment(self) -> "VendorAssignment":
        """
        Validate advance payment calculation.
        
        Ensures advance amount matches percentage if both provided.
        """
        if self.advance_payment_percentage and self.advance_payment_amount:
            expected_advance = (
                self.quoted_amount * self.advance_payment_percentage / 100
            )
            
            # Allow small rounding differences
            if abs(expected_advance - self.advance_payment_amount) > Decimal("1.00"):
                raise ValueError(
                    f"Advance payment amount ({self.advance_payment_amount}) "
                    f"doesn't match percentage ({self.advance_payment_percentage}%) "
                    f"of quoted amount ({self.quoted_amount})"
                )
        
        # If only percentage given, calculate amount
        if self.advance_payment_percentage and not self.advance_payment_amount:
            self.advance_payment_amount = round(
                self.quoted_amount * self.advance_payment_percentage / 100,
                2,
            )
        
        return self

    @model_validator(mode="after")
    def validate_warranty_requirements(self) -> "VendorAssignment":
        """
        Validate warranty information.
        
        If warranty period is specified, terms should be provided.
        """
        if self.warranty_period_months and self.warranty_period_months > 0:
            if not self.warranty_terms:
                raise ValueError(
                    "Warranty terms are required when warranty period is specified"
                )
        
        return self


class AssignmentUpdate(BaseCreateSchema):
    """
    Update existing maintenance assignment.
    
    Allows reassignment, deadline changes, and additional instructions.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )

    # Reassignment
    new_assigned_to: Optional[UUID] = Field(
        None,
        description="New assignee user ID (for reassignment)",
    )
    reassignment_reason: Optional[str] = Field(
        None,
        min_length=10,
        max_length=500,
        description="Reason for reassignment",
    )

    # Deadline modification
    new_deadline: Optional[date] = Field(
        None,
        description="Updated deadline",
    )
    deadline_change_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for deadline change",
    )

    # Additional information
    additional_instructions: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional instructions to append",
    )
    priority_change: Optional[str] = Field(
        None,
        pattern=r"^(low|medium|high|urgent|critical)$",
        description="Updated priority level",
    )

    # Update context
    updated_by: UUID = Field(
        ...,
        description="User making the update",
    )
    update_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Notes about the update",
    )

    @field_validator("reassignment_reason")
    @classmethod
    def validate_reassignment_reason(cls, v: Optional[str]) -> Optional[str]:
        """Validate reassignment reason if provided."""
        if v is not None:
            v = v.strip()
            if len(v) < 10:
                raise ValueError(
                    "Reassignment reason must be at least 10 characters"
                )
            return v
        return None

    @field_validator("new_deadline")
    @classmethod
    def validate_new_deadline(cls, v: Optional[date]) -> Optional[date]:
        """Validate new deadline is in future."""
        if v is not None and v < date.today():
            raise ValueError("New deadline cannot be in the past")
        return v

    @field_validator(
        "deadline_change_reason",
        "additional_instructions",
        "update_notes",
    )
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_update_requirements(self) -> "AssignmentUpdate":
        """
        Validate update field requirements.
        
        Ensures proper justification for changes.
        """
        # Reassignment requires reason
        if self.new_assigned_to and not self.reassignment_reason:
            raise ValueError(
                "Reassignment reason is required when changing assignee"
            )
        
        # Deadline extension should have reason
        if self.new_deadline and self.deadline_change_reason:
            # This is good practice
            pass
        
        return self


class BulkAssignment(BaseCreateSchema):
    """
    Assign multiple maintenance requests to same person.
    
    Efficient bulk assignment for batch processing of similar issues.
    """

    maintenance_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of maintenance request IDs",
    )
    assigned_to: UUID = Field(
        ...,
        description="User ID to assign all requests to",
    )
    assigned_by: UUID = Field(
        ...,
        description="User ID making the assignments",
    )
    common_deadline: Optional[date] = Field(
        None,
        description="Common deadline for all requests",
    )
    instructions: Optional[str] = Field(
        None,
        max_length=1000,
        description="Common instructions for all assignments",
    )
    priority_level: Optional[str] = Field(
        None,
        pattern=r"^(low|medium|high|urgent|critical)$",
        description="Common priority for all assignments",
    )
    send_notification: bool = Field(
        default=True,
        description="Send notification to assignee",
    )
    bulk_assignment_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Notes about bulk assignment",
    )

    @field_validator("maintenance_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[UUID]) -> List[UUID]:
        """
        Ensure no duplicate maintenance IDs.
        
        Prevents double-assignment errors.
        """
        if len(v) != len(set(v)):
            # Find duplicates
            seen = set()
            duplicates = set()
            for maintenance_id in v:
                if maintenance_id in seen:
                    duplicates.add(str(maintenance_id))
                seen.add(maintenance_id)
            
            raise ValueError(
                f"Duplicate maintenance IDs not allowed: {', '.join(duplicates)}"
            )
        
        return v

    @field_validator("common_deadline")
    @classmethod
    def validate_deadline(cls, v: Optional[date]) -> Optional[date]:
        """Validate deadline is in future."""
        if v is not None and v < date.today():
            raise ValueError("Deadline cannot be in the past")
        return v

    @field_validator("instructions", "bulk_assignment_notes")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None


class AssignmentEntry(BaseSchema):
    """
    Individual assignment history entry.
    
    Represents a single assignment in the history timeline.
    """

    assignment_id: UUID = Field(
        ...,
        description="Assignment unique identifier",
    )
    assigned_to: UUID = Field(
        ...,
        description="Assignee user ID",
    )
    assigned_to_name: str = Field(
        ...,
        description="Assignee full name",
    )
    assigned_to_role: Optional[str] = Field(
        None,
        description="Assignee role/designation",
    )
    assigned_by: UUID = Field(
        ...,
        description="Assignor user ID",
    )
    assigned_by_name: str = Field(
        ...,
        description="Assignor full name",
    )
    assigned_at: datetime = Field(
        ...,
        description="Assignment timestamp",
    )
    deadline: Optional[date] = Field(
        None,
        description="Task deadline",
    )
    instructions: Optional[str] = Field(
        None,
        description="Assignment instructions",
    )

    # Completion tracking
    completed: bool = Field(
        False,
        description="Whether task was completed by this assignee",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="Completion timestamp",
    )
    completion_notes: Optional[str] = Field(
        None,
        description="Completion notes",
    )

    # Reassignment tracking
    reassigned: bool = Field(
        False,
        description="Whether task was reassigned to someone else",
    )
    reassigned_at: Optional[datetime] = Field(
        None,
        description="Reassignment timestamp",
    )
    reassignment_reason: Optional[str] = Field(
        None,
        description="Reason for reassignment",
    )

    # Performance metrics
    time_to_complete_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Hours taken to complete (if completed)",
    )
    met_deadline: Optional[bool] = Field(
        None,
        description="Whether deadline was met (if completed)",
    )

    @model_validator(mode="after")
    def validate_completion_consistency(self) -> "AssignmentEntry":
        """
        Validate completion data consistency.
        
        Ensures completion timestamps and flags are consistent.
        """
        if self.completed:
            if not self.completed_at:
                raise ValueError(
                    "Completion timestamp required when task is completed"
                )
            
            # Can't be both completed and reassigned
            if self.reassigned:
                raise ValueError(
                    "Task cannot be both completed and reassigned"
                )
        
        if self.reassigned and not self.reassigned_at:
            raise ValueError(
                "Reassignment timestamp required when task is reassigned"
            )
        
        return self


class AssignmentHistory(BaseSchema):
    """
    Complete assignment history for maintenance request.
    
    Tracks all assignments, reassignments, and completions
    for audit trail and performance analysis.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    total_assignments: int = Field(
        ...,
        ge=0,
        description="Total number of times task was assigned",
    )
    current_assignee: Optional[str] = Field(
        None,
        description="Current assignee name (if still assigned)",
    )
    current_assignee_id: Optional[UUID] = Field(
        None,
        description="Current assignee user ID",
    )
    assignments: List[AssignmentEntry] = Field(
        ...,
        description="Chronological list of all assignments",
    )
    
    # Summary metrics
    average_assignment_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average time per assignment",
    )
    total_reassignments: int = Field(
        default=0,
        ge=0,
        description="Number of reassignments",
    )

    @field_validator("assignments")
    @classmethod
    def validate_assignments_order(cls, v: List[AssignmentEntry]) -> List[AssignmentEntry]:
        """
        Validate assignments are in chronological order.
        
        Ensures history timeline is logical.
        """
        if len(v) > 1:
            for i in range(len(v) - 1):
                if v[i].assigned_at > v[i + 1].assigned_at:
                    raise ValueError(
                        "Assignment history must be in chronological order"
                    )
        
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\maintenance\maintenance_base.py ---
# --- File: app/schemas/maintenance/maintenance_base.py ---
"""
Base maintenance schemas with comprehensive validation and type safety.

This module provides foundational schemas for maintenance request management
including creation, updates, and core validation logic.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import (
    MaintenanceCategory,
    MaintenanceIssueType,
    MaintenanceStatus,
    Priority,
)

__all__ = [
    "MaintenanceBase",
    "MaintenanceCreate",
    "MaintenanceUpdate",
    "MaintenanceStatusUpdate",
]


class MaintenanceBase(BaseSchema):
    """
    Base maintenance request schema with core fields.
    
    Provides common maintenance attributes and validation logic
    used across create/update operations.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    requested_by: UUID = Field(
        ...,
        description="User ID who requested maintenance",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Room where issue exists (if applicable)",
    )

    # Request details
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Brief issue summary",
    )
    description: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed issue description",
    )

    # Classification
    category: MaintenanceCategory = Field(
        ...,
        description="Maintenance category",
    )
    priority: Priority = Field(
        Priority.MEDIUM,
        description="Issue priority level",
    )
    issue_type: MaintenanceIssueType = Field(
        MaintenanceIssueType.ROUTINE,
        description="Type of maintenance issue",
    )

    # Location details
    location: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional location details",
    )
    floor: Optional[int] = Field(
        None,
        ge=0,
        le=50,
        description="Floor number (if applicable)",
    )
    specific_area: Optional[str] = Field(
        None,
        max_length=255,
        description="Specific area within location (e.g., bathroom, kitchen)",
    )

    # Attachments
    issue_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="URLs to issue photographs",
    )

    @field_validator("title")
    @classmethod
    def validate_title(cls, v: str) -> str:
        """
        Validate and normalize title.
        
        Ensures title is meaningful and properly formatted.
        """
        v = v.strip()
        
        if len(v) < 5:
            raise ValueError("Title must be at least 5 characters")
        
        # Basic meaningfulness check
        if len(set(v.lower().replace(" ", ""))) < 3:
            raise ValueError("Title must be meaningful and descriptive")
        
        return v

    @field_validator("description")
    @classmethod
    def validate_description(cls, v: str) -> str:
        """
        Validate and normalize description.
        
        Ensures description provides adequate detail.
        """
        v = v.strip()
        
        if len(v) < 20:
            raise ValueError("Description must be at least 20 characters")
        
        # Check for meaningful content
        if len(set(v.lower().replace(" ", ""))) < 10:
            raise ValueError("Description must provide detailed information")
        
        return v

    @field_validator("location", "specific_area")
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields by stripping whitespace."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @field_validator("issue_photos")
    @classmethod
    def validate_photos(cls, v: List[HttpUrl]) -> List[HttpUrl]:
        """Validate photo URLs list."""
        if len(v) > 10:
            raise ValueError("Maximum 10 photos allowed per request")
        return v

    @model_validator(mode="after")
    def validate_priority_consistency(self) -> "MaintenanceBase":
        """
        Validate priority consistency with issue type.
        
        Emergency issues should have high/urgent priority.
        """
        if self.issue_type == MaintenanceIssueType.EMERGENCY:
            if self.priority not in [Priority.HIGH, Priority.URGENT, Priority.CRITICAL]:
                raise ValueError(
                    "Emergency issues must have HIGH, URGENT, or CRITICAL priority"
                )
        
        return self


class MaintenanceCreate(MaintenanceBase, BaseCreateSchema):
    """
    Create maintenance request with additional context.
    
    Extends base schema with creation-specific fields and validation.
    """

    # Additional creation context
    preferred_completion_date: Optional[date] = Field(
        None,
        description="Preferred completion date (if any)",
    )
    notify_on_completion: bool = Field(
        default=True,
        description="Send notification when completed",
    )
    allow_cost_estimation: bool = Field(
        default=True,
        description="Allow supervisor to estimate costs",
    )

    @field_validator("preferred_completion_date")
    @classmethod
    def validate_completion_date(cls, v: Optional[date]) -> Optional[date]:
        """
        Validate preferred completion date.
        
        Ensures date is in the future and within reasonable range.
        """
        if v is not None:
            today = date.today()
            
            # Can't be in the past
            if v < today:
                raise ValueError(
                    "Preferred completion date cannot be in the past"
                )
            
            # Should be within reasonable timeframe (1 year)
            days_ahead = (v - today).days
            if days_ahead > 365:
                raise ValueError(
                    "Preferred completion date cannot be more than 1 year ahead"
                )
        
        return v

    @model_validator(mode="after")
    def validate_emergency_urgency(self) -> "MaintenanceCreate":
        """
        Validate emergency requests have appropriate urgency.
        
        Emergency issues should have immediate preferred completion.
        """
        if self.issue_type == MaintenanceIssueType.EMERGENCY:
            if self.preferred_completion_date:
                days_ahead = (
                    self.preferred_completion_date - date.today()
                ).days
                
                if days_ahead > 3:
                    raise ValueError(
                        "Emergency requests should have completion date within 3 days"
                    )
        
        return self


class MaintenanceUpdate(BaseUpdateSchema):
    """
    Update maintenance request with partial fields.
    
    All fields are optional for flexible updates. Typically used
    to modify pending requests or add information during processing.
    """

    title: Optional[str] = Field(
        None,
        min_length=5,
        max_length=255,
        description="Updated title",
    )
    description: Optional[str] = Field(
        None,
        min_length=20,
        max_length=2000,
        description="Updated description",
    )
    category: Optional[MaintenanceCategory] = Field(
        None,
        description="Updated category",
    )
    priority: Optional[Priority] = Field(
        None,
        description="Updated priority",
    )
    location: Optional[str] = Field(
        None,
        max_length=500,
        description="Updated location",
    )
    floor: Optional[int] = Field(
        None,
        ge=0,
        le=50,
        description="Updated floor",
    )
    specific_area: Optional[str] = Field(
        None,
        max_length=255,
        description="Updated specific area",
    )

    # Status
    status: Optional[MaintenanceStatus] = Field(
        None,
        description="Updated status (restricted to certain roles)",
    )

    # Cost information
    estimated_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Estimated repair cost",
    )
    actual_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Actual cost incurred",
    )

    # Timeline
    estimated_completion_date: Optional[date] = Field(
        None,
        description="Estimated completion date",
    )

    @field_validator("title", "description", "location", "specific_area")
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            if isinstance(v, str):
                # Different validation for different fields
                return v if v else None
        return None

    @field_validator("estimated_cost", "actual_cost")
    @classmethod
    def round_costs(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round costs to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_cost_consistency(self) -> "MaintenanceUpdate":
        """
        Validate cost fields consistency.
        
        Actual cost should not exceed estimated cost by too much.
        """
        if self.estimated_cost is not None and self.actual_cost is not None:
            # Allow 50% variance
            max_allowed = self.estimated_cost * Decimal("1.5")
            
            if self.actual_cost > max_allowed:
                raise ValueError(
                    f"Actual cost ({self.actual_cost}) exceeds estimated cost "
                    f"({self.estimated_cost}) by more than 50%"
                )
        
        return self


class MaintenanceStatusUpdate(BaseUpdateSchema):
    """
    Update maintenance status with tracking notes.
    
    Simplified schema for status transitions with audit trail.
    """

    status: MaintenanceStatus = Field(
        ...,
        description="New maintenance status",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Status change notes/reason",
    )
    notify_requester: bool = Field(
        default=True,
        description="Send notification to requester",
    )
    updated_by: UUID = Field(
        ...,
        description="User ID making the status change",
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize status notes."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_status_notes_requirement(self) -> "MaintenanceStatusUpdate":
        """
        Validate notes requirement for certain status changes.
        
        Rejection, cancellation require mandatory notes.
        """
        statuses_requiring_notes = {
            MaintenanceStatus.REJECTED,
            MaintenanceStatus.CANCELLED,
            MaintenanceStatus.ON_HOLD,
        }
        
        if self.status in statuses_requiring_notes:
            if not self.notes:
                raise ValueError(
                    f"Notes are required when changing status to {self.status.value}"
                )
            
            if len(self.notes.strip()) < 10:
                raise ValueError(
                    "Notes must be at least 10 characters for this status change"
                )
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\maintenance\maintenance_completion.py ---
# --- File: app/schemas/maintenance/maintenance_completion.py ---
"""
Maintenance completion schemas with quality tracking.

Provides schemas for marking maintenance as completed, quality checks,
material tracking, and completion certificates.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "CompletionRequest",
    "MaterialItem",
    "QualityCheck",
    "ChecklistItem",
    "CompletionResponse",
    "CompletionCertificate",
]


class MaterialItem(BaseSchema):
    """
    Material used in maintenance work.
    
    Tracks individual materials with quantities and costs
    for accurate billing and inventory management.
    """

    material_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Material/item name",
    )
    material_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Material code/SKU",
    )
    category: Optional[str] = Field(
        None,
        max_length=100,
        description="Material category",
    )
    quantity: Decimal = Field(
        ...,
        gt=0,
        max_digits=10,
        decimal_places=3,
        description="Quantity used",
    )
    unit: str = Field(
        ...,
        min_length=1,
        max_length=20,
        description="Unit of measurement (pcs, kg, liters, meters, etc.)",
    )
    unit_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Cost per unit",
    )
    total_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Total cost for this material",
    )
    supplier: Optional[str] = Field(
        None,
        max_length=255,
        description="Material supplier name",
    )
    supplier_invoice: Optional[str] = Field(
        None,
        max_length=100,
        description="Supplier invoice number",
    )
    warranty_months: Optional[int] = Field(
        None,
        ge=0,
        le=120,
        description="Material warranty period in months",
    )

    @field_validator("quantity", "unit_cost", "total_cost")
    @classmethod
    def round_decimals(cls, v: Decimal) -> Decimal:
        """Round decimal values appropriately."""
        # Quantity can have 3 decimals, costs have 2
        return v

    @field_validator("material_name", "category", "unit", "supplier")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_cost_calculation(self) -> "MaterialItem":
        """
        Validate total cost calculation.
        
        Ensures total_cost = quantity  unit_cost (with rounding tolerance).
        """
        calculated_total = self.quantity * self.unit_cost
        
        # Allow small rounding differences (0.01)
        if abs(calculated_total - self.total_cost) > Decimal("0.01"):
            raise ValueError(
                f"Total cost ({self.total_cost}) doesn't match "
                f"quantity ({self.quantity})  unit cost ({self.unit_cost}) "
                f"= {calculated_total}"
            )
        
        return self


class CompletionRequest(BaseCreateSchema):
    """
    Mark maintenance work as completed.
    
    Comprehensive completion with work notes, materials,
    labor tracking, and cost documentation.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    completed_by: UUID = Field(
        ...,
        description="User ID who completed the work",
    )
    
    # Completion details
    work_notes: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed notes about work performed",
    )
    work_summary: Optional[str] = Field(
        None,
        max_length=500,
        description="Brief work summary",
    )
    
    # Materials used
    materials_used: List[MaterialItem] = Field(
        default_factory=list,
        max_length=100,
        description="List of materials used",
    )
    
    # Labor tracking
    labor_hours: Decimal = Field(
        ...,
        ge=0,
        le=1000,
        decimal_places=2,
        description="Total labor hours spent",
    )
    labor_rate_per_hour: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Labor rate per hour",
    )
    number_of_workers: int = Field(
        default=1,
        ge=1,
        le=50,
        description="Number of workers involved",
    )
    
    # Cost breakdown
    materials_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Total materials cost",
    )
    labor_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Total labor cost",
    )
    vendor_charges: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="External vendor charges",
    )
    other_costs: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Other miscellaneous costs",
    )
    actual_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Total actual cost",
    )
    cost_breakdown: Optional[dict] = Field(
        None,
        description="Detailed cost breakdown",
    )
    
    # Photos
    completion_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=15,
        description="After-completion photographs",
    )
    before_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=15,
        description="Before work photographs (if available)",
    )
    
    # Timeline
    actual_start_date: Optional[date] = Field(
        None,
        description="Actual work start date",
    )
    actual_completion_date: date = Field(
        ...,
        description="Actual completion date",
    )
    total_working_days: Optional[int] = Field(
        None,
        ge=0,
        description="Total working days taken",
    )
    
    # Follow-up
    follow_up_required: bool = Field(
        False,
        description="Whether follow-up inspection needed",
    )
    follow_up_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Follow-up requirements",
    )
    follow_up_date: Optional[date] = Field(
        None,
        description="Scheduled follow-up date",
    )
    
    # Warranty
    warranty_applicable: bool = Field(
        default=False,
        description="Whether warranty applies to this work",
    )
    warranty_period_months: Optional[int] = Field(
        None,
        ge=0,
        le=120,
        description="Warranty period in months",
    )
    warranty_terms: Optional[str] = Field(
        None,
        max_length=1000,
        description="Warranty terms and conditions",
    )

    @field_validator(
        "labor_hours",
        "materials_cost",
        "labor_cost",
        "vendor_charges",
        "other_costs",
        "actual_cost",
        "labor_rate_per_hour",
    )
    @classmethod
    def round_decimals(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round decimal values to 2 places."""
        return round(v, 2) if v is not None else None

    @field_validator("work_notes", "work_summary", "follow_up_notes", "warranty_terms")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_completion_dates(self) -> "CompletionRequest":
        """
        Validate completion date consistency.
        
        Ensures dates are logical and in proper sequence.
        """
        # Completion date can't be in future
        if self.actual_completion_date > date.today():
            raise ValueError("Completion date cannot be in the future")
        
        # Start date should be before completion
        if self.actual_start_date:
            if self.actual_start_date > self.actual_completion_date:
                raise ValueError(
                    "Start date must be before or equal to completion date"
                )
            
            # Calculate working days if not provided
            if self.total_working_days is None:
                self.total_working_days = (
                    self.actual_completion_date - self.actual_start_date
                ).days + 1
        
        return self

    @model_validator(mode="after")
    def validate_cost_breakdown(self) -> "CompletionRequest":
        """
        Validate cost breakdown matches total.
        
        Sum of components should equal actual cost.
        """
        total_components = (
            self.materials_cost
            + self.labor_cost
            + self.vendor_charges
            + self.other_costs
        )
        
        # Allow small rounding differences
        if abs(total_components - self.actual_cost) > Decimal("1.00"):
            raise ValueError(
                f"Cost breakdown ({total_components}) doesn't match "
                f"actual cost ({self.actual_cost})"
            )
        
        return self

    @model_validator(mode="after")
    def validate_materials_cost(self) -> "CompletionRequest":
        """
        Validate materials cost matches materials list.
        
        Sum of material items should match materials_cost.
        """
        if self.materials_used:
            calculated_materials_cost = sum(
                item.total_cost for item in self.materials_used
            )
            
            # Allow small variance
            if abs(calculated_materials_cost - self.materials_cost) > Decimal("1.00"):
                raise ValueError(
                    f"Materials cost ({self.materials_cost}) doesn't match "
                    f"sum of material items ({calculated_materials_cost})"
                )
        
        return self

    @model_validator(mode="after")
    def validate_labor_cost(self) -> "CompletionRequest":
        """
        Validate labor cost calculation.
        
        If labor rate provided, cost should match hours  rate.
        """
        if self.labor_rate_per_hour is not None:
            calculated_labor_cost = self.labor_hours * self.labor_rate_per_hour
            
            if abs(calculated_labor_cost - self.labor_cost) > Decimal("1.00"):
                raise ValueError(
                    f"Labor cost ({self.labor_cost}) doesn't match "
                    f"hours ({self.labor_hours})  rate ({self.labor_rate_per_hour})"
                )
        
        return self

    @model_validator(mode="after")
    def validate_follow_up_requirements(self) -> "CompletionRequest":
        """
        Validate follow-up information.
        
        If follow-up required, notes and date should be provided.
        """
        if self.follow_up_required:
            if not self.follow_up_notes:
                raise ValueError(
                    "Follow-up notes are required when follow-up is needed"
                )
            
            if not self.follow_up_date:
                raise ValueError(
                    "Follow-up date is required when follow-up is needed"
                )
            
            # Follow-up date should be in future
            if self.follow_up_date <= self.actual_completion_date:
                raise ValueError(
                    "Follow-up date must be after completion date"
                )
        
        return self

    @model_validator(mode="after")
    def validate_warranty_requirements(self) -> "CompletionRequest":
        """
        Validate warranty information.
        
        If warranty applicable, period and terms should be provided.
        """
        if self.warranty_applicable:
            if not self.warranty_period_months:
                raise ValueError(
                    "Warranty period is required when warranty is applicable"
                )
            
            if not self.warranty_terms:
                raise ValueError(
                    "Warranty terms are required when warranty is applicable"
                )
        
        return self


class ChecklistItem(BaseSchema):
    """
    Quality check checklist item.
    
    Individual item in quality inspection checklist.
    """

    item_id: Optional[str] = Field(
        None,
        max_length=50,
        description="Checklist item unique ID",
    )
    item_description: str = Field(
        ...,
        min_length=5,
        max_length=500,
        description="What to check/verify",
    )
    category: Optional[str] = Field(
        None,
        max_length=100,
        description="Check category",
    )
    status: str = Field(
        ...,
        pattern=r"^(pass|fail|na|partial)$",
        description="Check result status",
    )
    is_critical: bool = Field(
        default=False,
        description="Whether this is a critical check",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes or observations",
    )
    checked_by: Optional[str] = Field(
        None,
        max_length=255,
        description="Person who performed this check",
    )
    photo_evidence: Optional[HttpUrl] = Field(
        None,
        description="Photo evidence URL",
    )

    @field_validator("item_description", "notes")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None


class QualityCheck(BaseCreateSchema):
    """
    Quality check for completed maintenance work.
    
    Inspection and verification of work quality with
    detailed checklist and approval/rejection.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    
    # Overall result
    quality_check_passed: bool = Field(
        ...,
        description="Overall quality check result",
    )
    overall_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Overall quality rating (1-5 stars)",
    )
    
    # Detailed checklist
    checklist_items: List[ChecklistItem] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Quality check checklist items",
    )
    
    # Inspection details
    quality_check_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Detailed quality check notes",
    )
    defects_found: Optional[str] = Field(
        None,
        max_length=1000,
        description="Any defects or issues found",
    )
    
    # Inspector
    checked_by: UUID = Field(
        ...,
        description="User ID who performed quality check",
    )
    inspection_date: date = Field(
        ...,
        description="Inspection date",
    )
    inspection_time: Optional[time] = Field(
        None,
        description="Inspection time",
    )
    
    # Rework requirements
    rework_required: bool = Field(
        False,
        description="Whether rework is needed",
    )
    rework_details: Optional[str] = Field(
        None,
        max_length=1000,
        description="Details of required rework",
    )
    rework_deadline: Optional[date] = Field(
        None,
        description="Deadline for completing rework",
    )
    
    # Sign-off
    customer_acceptance: Optional[bool] = Field(
        None,
        description="Customer/requester acceptance",
    )
    customer_feedback: Optional[str] = Field(
        None,
        max_length=1000,
        description="Customer feedback",
    )
    
    # Photos
    inspection_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=20,
        description="Quality inspection photographs",
    )

    @field_validator("inspection_date")
    @classmethod
    def validate_inspection_date(cls, v: date) -> date:
        """Validate inspection date is not in future."""
        if v > date.today():
            raise ValueError("Inspection date cannot be in the future")
        return v

    @field_validator(
        "quality_check_notes",
        "defects_found",
        "rework_details",
        "customer_feedback",
    )
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_rework_requirements(self) -> "QualityCheck":
        """
        Validate rework information consistency.
        
        If rework required, details and deadline should be provided.
        """
        if self.rework_required:
            if not self.rework_details:
                raise ValueError(
                    "Rework details are required when rework is needed"
                )
            
            if not self.rework_deadline:
                raise ValueError(
                    "Rework deadline is required when rework is needed"
                )
            
            # Rework deadline should be in future
            if self.rework_deadline < date.today():
                raise ValueError("Rework deadline cannot be in the past")
            
            # Quality check should fail if rework needed
            if self.quality_check_passed:
                raise ValueError(
                    "Quality check cannot pass if rework is required"
                )
        
        return self

    @model_validator(mode="after")
    def validate_critical_failures(self) -> "QualityCheck":
        """
        Validate critical checklist items.
        
        Quality check should fail if any critical item fails.
        """
        critical_failures = [
            item for item in self.checklist_items
            if item.is_critical and item.status == "fail"
        ]
        
        if critical_failures and self.quality_check_passed:
            raise ValueError(
                f"Quality check cannot pass with {len(critical_failures)} critical failures"
            )
        
        return self


class CompletionResponse(BaseSchema):
    """
    Maintenance completion response.
    
    Provides summary of completion with cost variance
    and quality status.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    
    # Completion status
    completed: bool = Field(
        ...,
        description="Whether work is marked as completed",
    )
    completed_at: datetime = Field(
        ...,
        description="Completion timestamp",
    )
    completed_by: UUID = Field(
        ...,
        description="User ID who completed",
    )
    completed_by_name: str = Field(
        ...,
        description="Name of person who completed",
    )
    
    # Cost summary
    estimated_cost: Decimal = Field(
        ...,
        ge=0,
        description="Original estimated cost",
    )
    actual_cost: Decimal = Field(
        ...,
        ge=0,
        description="Actual cost incurred",
    )
    cost_variance: Decimal = Field(
        ...,
        description="Cost variance (actual - estimated)",
    )
    cost_variance_percentage: Decimal = Field(
        ...,
        description="Cost variance as percentage",
    )
    within_budget: bool = Field(
        ...,
        description="Whether work was completed within budget",
    )
    
    # Quality status
    quality_checked: bool = Field(
        ...,
        description="Whether quality check was performed",
    )
    quality_check_passed: Optional[bool] = Field(
        None,
        description="Quality check result (if performed)",
    )
    quality_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Quality rating (1-5 stars)",
    )
    
    # Timeline
    actual_completion_date: date = Field(
        ...,
        description="Actual completion date",
    )
    total_days_taken: Optional[int] = Field(
        None,
        ge=0,
        description="Total days from request to completion",
    )
    
    # Response message
    message: str = Field(
        ...,
        description="Human-readable response message",
    )
    
    # Next steps
    follow_up_required: bool = Field(
        default=False,
        description="Whether follow-up is needed",
    )
    warranty_applicable: bool = Field(
        default=False,
        description="Whether warranty applies",
    )

    @field_validator(
        "estimated_cost",
        "actual_cost",
        "cost_variance",
        "cost_variance_percentage",
    )
    @classmethod
    def round_decimals(cls, v: Decimal) -> Decimal:
        """Round decimal values to 2 places."""
        return round(v, 2)


class CompletionCertificate(BaseSchema):
    """
    Work completion certificate.
    
    Formal certificate documenting completed maintenance work
    with all details, parties, and warranties.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    certificate_number: str = Field(
        ...,
        description="Unique certificate number",
    )
    
    # Work details
    work_title: str = Field(
        ...,
        description="Work title/description",
    )
    work_description: str = Field(
        ...,
        description="Detailed work description",
    )
    work_category: str = Field(
        ...,
        description="Work category",
    )
    materials_used: List[MaterialItem] = Field(
        default_factory=list,
        description="Materials used in work",
    )
    labor_hours: Decimal = Field(
        ...,
        ge=0,
        description="Total labor hours",
    )
    
    # Cost summary
    total_cost: Decimal = Field(
        ...,
        ge=0,
        description="Total work cost",
    )
    cost_breakdown: Optional[dict] = Field(
        None,
        description="Detailed cost breakdown",
    )
    
    # Parties involved
    completed_by: str = Field(
        ...,
        description="Person/team who completed work",
    )
    completed_by_designation: Optional[str] = Field(
        None,
        description="Designation of person who completed",
    )
    verified_by: str = Field(
        ...,
        description="Person who verified completion",
    )
    verified_by_designation: Optional[str] = Field(
        None,
        description="Designation of verifier",
    )
    approved_by: str = Field(
        ...,
        description="Person who approved completion",
    )
    approved_by_designation: Optional[str] = Field(
        None,
        description="Designation of approver",
    )
    
    # Dates
    work_start_date: date = Field(
        ...,
        description="Work start date",
    )
    completion_date: date = Field(
        ...,
        description="Work completion date",
    )
    verification_date: date = Field(
        ...,
        description="Verification date",
    )
    certificate_issue_date: date = Field(
        ...,
        description="Certificate issue date",
    )
    
    # Warranty
    warranty_applicable: bool = Field(
        default=False,
        description="Whether warranty applies",
    )
    warranty_period_months: Optional[int] = Field(
        None,
        ge=0,
        le=120,
        description="Warranty period in months",
    )
    warranty_terms: Optional[str] = Field(
        None,
        description="Warranty terms and conditions",
    )
    warranty_valid_until: Optional[date] = Field(
        None,
        description="Warranty expiry date",
    )
    
    # Quality assurance
    quality_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Quality rating",
    )
    quality_remarks: Optional[str] = Field(
        None,
        description="Quality remarks",
    )
    
    # Digital signatures (placeholders)
    completed_by_signature: Optional[str] = Field(
        None,
        description="Completed by signature data",
    )
    verified_by_signature: Optional[str] = Field(
        None,
        description="Verified by signature data",
    )
    approved_by_signature: Optional[str] = Field(
        None,
        description="Approved by signature data",
    )

    @field_validator("total_cost", "labor_hours")
    @classmethod
    def round_decimals(cls, v: Decimal) -> Decimal:
        """Round decimal values."""
        return round(v, 2)

    @model_validator(mode="after")
    def validate_dates_sequence(self) -> "CompletionCertificate":
        """
        Validate dates are in logical sequence.
        
        Start < Completion <= Verification <= Certificate Issue
        """
        if self.work_start_date > self.completion_date:
            raise ValueError("Start date must be before completion date")
        
        if self.completion_date > self.verification_date:
            raise ValueError("Completion date must be before verification date")
        
        if self.verification_date > self.certificate_issue_date:
            raise ValueError("Verification date must be before certificate issue date")
        
        return self

    @model_validator(mode="after")
    def validate_warranty_details(self) -> "CompletionCertificate":
        """
        Validate warranty information.
        
        If warranty applicable, all warranty details should be provided.
        """
        if self.warranty_applicable:
            if not self.warranty_period_months:
                raise ValueError(
                    "Warranty period is required when warranty is applicable"
                )
            
            if not self.warranty_terms:
                raise ValueError(
                    "Warranty terms are required when warranty is applicable"
                )
            
            if not self.warranty_valid_until:
                raise ValueError(
                    "Warranty expiry date is required when warranty is applicable"
                )
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\maintenance\maintenance_cost.py ---
# --- File: app/schemas/maintenance/maintenance_cost.py ---
"""
Maintenance cost tracking and budget management schemas.

Provides comprehensive cost tracking, budget allocation, expense reporting,
and vendor invoice management with detailed analytics.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "CostTracking",
    "BudgetAllocation",
    "CategoryBudget",
    "ExpenseReport",
    "MonthlyExpense",
    "ExpenseItem",
    "VendorInvoice",
    "InvoiceLineItem",
    "CostAnalysis",
]


class CostTracking(BaseSchema):
    """
    Cost tracking for maintenance request.
    
    Tracks estimated vs actual costs with variance analysis.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    estimated_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Original estimated cost",
    )
    approved_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Approved budget amount",
    )
    actual_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Actual cost incurred",
    )
    variance: Decimal = Field(
        ...,
        max_digits=10,
        decimal_places=2,
        description="Cost variance (actual - approved)",
    )
    variance_percentage: Decimal = Field(
        ...,
        decimal_places=2,
        description="Variance as percentage of approved",
    )
    within_budget: bool = Field(
        ...,
        description="Whether actual cost is within approved budget",
    )
    materials_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Materials cost component",
    )
    labor_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Labor cost component",
    )
    vendor_charges: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="External vendor charges",
    )
    other_costs: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Other miscellaneous costs",
    )
    tax_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Tax component",
    )

    @field_validator(
        "estimated_cost",
        "approved_cost",
        "actual_cost",
        "variance",
        "variance_percentage",
        "materials_cost",
        "labor_cost",
        "vendor_charges",
        "other_costs",
        "tax_amount",
    )
    @classmethod
    def round_amounts(cls, v: Decimal) -> Decimal:
        """Round monetary amounts to 2 decimal places."""
        return round(v, 2)

    @computed_field
    @property
    def cost_breakdown_total(self) -> Decimal:
        """Calculate total from breakdown components."""
        return round(
            self.materials_cost
            + self.labor_cost
            + self.vendor_charges
            + self.other_costs
            + self.tax_amount,
            2,
        )


class CategoryBudget(BaseSchema):
    """
    Budget allocation for specific maintenance category.
    
    Tracks allocation, spending, and utilization per category.
    """

    category: str = Field(
        ...,
        description="Maintenance category name",
    )
    category_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Category code",
    )
    allocated: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Allocated budget amount",
    )
    spent: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Amount spent",
    )
    committed: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Amount committed (approved but not paid)",
    )
    remaining: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Remaining budget",
    )
    utilization_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Budget utilization percentage",
    )
    request_count: int = Field(
        default=0,
        ge=0,
        description="Number of maintenance requests",
    )
    average_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )

    @field_validator(
        "allocated",
        "spent",
        "committed",
        "remaining",
        "utilization_percentage",
        "average_cost",
    )
    @classmethod
    def round_amounts(cls, v: Decimal) -> Decimal:
        """Round amounts to 2 decimal places."""
        return round(v, 2)

    @computed_field
    @property
    def is_over_budget(self) -> bool:
        """Check if category is over budget."""
        return self.spent > self.allocated

    @computed_field
    @property
    def available_for_commitment(self) -> Decimal:
        """Calculate amount available for new commitments."""
        return round(
            max(Decimal("0.00"), self.allocated - self.spent - self.committed),
            2,
        )


class BudgetAllocation(BaseSchema):
    """
    Overall budget allocation for hostel maintenance.
    
    Tracks fiscal year budget with category-wise breakdown
    and utilization metrics.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    fiscal_year: str = Field(
        ...,
        pattern=r"^\d{4}$",
        description="Fiscal year (YYYY format)",
    )
    fiscal_year_start: date = Field(
        ...,
        description="Fiscal year start date",
    )
    fiscal_year_end: date = Field(
        ...,
        description="Fiscal year end date",
    )
    total_budget: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total allocated budget",
    )
    allocated_budget: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Budget allocated to categories",
    )
    spent_amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total amount spent",
    )
    committed_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Committed but not yet spent",
    )
    remaining_budget: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Remaining unallocated budget",
    )
    utilization_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall budget utilization",
    )
    budget_by_category: Dict[str, CategoryBudget] = Field(
        ...,
        description="Budget breakdown by category",
    )
    reserve_fund: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Emergency reserve fund",
    )
    
    # Forecasting
    projected_annual_spend: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Projected annual spending",
    )
    burn_rate_monthly: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average monthly spending rate",
    )

    @field_validator("fiscal_year_end")
    @classmethod
    def validate_fiscal_year(cls, v: date, info) -> date:
        """Validate fiscal year dates."""
        if "fiscal_year_start" in info.data:
            if v <= info.data["fiscal_year_start"]:
                raise ValueError("Fiscal year end must be after start")
        return v

    @computed_field
    @property
    def is_over_budget(self) -> bool:
        """Check if overall budget is exceeded."""
        return self.spent_amount > self.total_budget

    @computed_field
    @property
    def months_remaining(self) -> int:
        """Calculate months remaining in fiscal year."""
        today = date.today()
        if today > self.fiscal_year_end:
            return 0
        
        months = (
            (self.fiscal_year_end.year - today.year) * 12
            + (self.fiscal_year_end.month - today.month)
        )
        return max(0, months)


class MonthlyExpense(BaseSchema):
    """
    Monthly expense summary.
    
    Aggregates maintenance expenses for a specific month.
    """

    month: str = Field(
        ...,
        pattern=r"^\d{4}-(0[1-9]|1[0-2])$",
        description="Month in YYYY-MM format",
    )
    month_name: str = Field(
        ...,
        description="Month name (January, February, etc.)",
    )
    year: int = Field(
        ...,
        ge=2000,
        le=2100,
        description="Year",
    )
    total_expenses: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total expenses for the month",
    )
    request_count: int = Field(
        ...,
        ge=0,
        description="Number of maintenance requests",
    )
    completed_count: int = Field(
        default=0,
        ge=0,
        description="Number of completed requests",
    )
    average_cost: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )
    budget_allocated: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Budget allocated for the month",
    )
    variance_from_budget: Optional[Decimal] = Field(
        None,
        description="Variance from monthly budget",
    )

    @computed_field
    @property
    def within_budget(self) -> Optional[bool]:
        """Check if monthly expenses are within budget."""
        if self.budget_allocated is None:
            return None
        return self.total_expenses <= self.budget_allocated


class ExpenseItem(BaseSchema):
    """
    Individual expense item in reports.
    
    Represents single maintenance request in expense listings.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    title: str = Field(
        ...,
        description="Request title",
    )
    category: str = Field(
        ...,
        description="Maintenance category",
    )
    priority: str = Field(
        ...,
        description="Priority level",
    )
    estimated_cost: Decimal = Field(
        ...,
        ge=0,
        description="Estimated cost",
    )
    actual_cost: Decimal = Field(
        ...,
        ge=0,
        description="Actual cost incurred",
    )
    cost_variance: Decimal = Field(
        ...,
        description="Cost variance amount",
    )
    completion_date: date = Field(
        ...,
        description="Completion date",
    )
    vendor_name: Optional[str] = Field(
        None,
        description="Vendor name (if applicable)",
    )

    @computed_field
    @property
    def over_budget(self) -> bool:
        """Check if expense was over estimated cost."""
        return self.actual_cost > self.estimated_cost


class ExpenseReport(BaseSchema):
    """
    Comprehensive maintenance expense report.
    
    Provides detailed expense analysis with multiple dimensions
    and top expense listings.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID (if hostel-specific)",
    )
    hostel_name: Optional[str] = Field(
        None,
        description="Hostel name",
    )
    report_period: DateRangeFilter = Field(
        ...,
        description="Report period",
    )
    generated_at: datetime = Field(
        ...,
        description="Report generation timestamp",
    )
    generated_by: Optional[UUID] = Field(
        None,
        description="User who generated report",
    )
    
    # Summary statistics
    total_expenses: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total expenses in period",
    )
    total_requests: int = Field(
        ...,
        ge=0,
        description="Total maintenance requests",
    )
    completed_requests: int = Field(
        ...,
        ge=0,
        description="Completed requests",
    )
    average_cost_per_request: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )
    
    # Budget comparison
    total_budget: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Total budget for period",
    )
    budget_utilization: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Budget utilization percentage",
    )
    
    # Breakdown by category
    expenses_by_category: Dict[str, Decimal] = Field(
        ...,
        description="Expenses grouped by category",
    )
    requests_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Request count by category",
    )
    
    # Monthly breakdown
    monthly_expenses: List[MonthlyExpense] = Field(
        ...,
        description="Month-by-month expenses",
    )
    
    # Priority-based breakdown
    expenses_by_priority: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Expenses grouped by priority",
    )
    
    # Top expenses
    top_expensive_requests: List[ExpenseItem] = Field(
        default_factory=list,
        max_length=50,
        description="Highest cost maintenance requests",
    )
    
    # Vendor analysis
    top_vendors_by_spending: Optional[List[Dict[str, any]]] = Field(
        None,
        max_length=20,
        description="Top vendors by total spending",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate percentage."""
        if self.total_requests == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.completed_requests) / Decimal(self.total_requests) * 100,
            2,
        )


class InvoiceLineItem(BaseSchema):
    """
    Line item in vendor invoice.
    
    Represents individual item/service in invoice.
    """

    line_number: int = Field(
        ...,
        ge=1,
        description="Line item number",
    )
    description: str = Field(
        ...,
        min_length=3,
        max_length=500,
        description="Item/service description",
    )
    item_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Item code/SKU",
    )
    quantity: Decimal = Field(
        ...,
        gt=0,
        max_digits=10,
        decimal_places=3,
        description="Quantity",
    )
    unit: str = Field(
        ...,
        max_length=20,
        description="Unit of measurement",
    )
    unit_price: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Price per unit",
    )
    total_price: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Total line price",
    )
    tax_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Tax rate percentage",
    )
    tax_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Tax amount",
    )

    @model_validator(mode="after")
    def validate_pricing(self) -> "InvoiceLineItem":
        """
        Validate pricing calculations.
        
        Ensures total_price = quantity  unit_price (pre-tax).
        """
        calculated_total = self.quantity * self.unit_price
        
        # Allow small rounding differences
        if abs(calculated_total - self.total_price) > Decimal("0.01"):
            raise ValueError(
                f"Total price ({self.total_price}) doesn't match "
                f"quantity ({self.quantity})  unit price ({self.unit_price})"
            )
        
        # Validate tax calculation if tax_rate > 0
        if self.tax_rate > 0:
            calculated_tax = self.total_price * self.tax_rate / 100
            if abs(calculated_tax - self.tax_amount) > Decimal("0.01"):
                raise ValueError(
                    f"Tax amount ({self.tax_amount}) doesn't match "
                    f"total price ({self.total_price})  tax rate ({self.tax_rate}%)"
                )
        
        return self


class VendorInvoice(BaseCreateSchema):
    """
    Vendor invoice for maintenance work.
    
    Comprehensive invoice tracking with line items, taxes,
    and payment terms.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    vendor_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Vendor company name",
    )
    vendor_id: Optional[UUID] = Field(
        None,
        description="Vendor ID in system (if registered)",
    )
    vendor_address: Optional[str] = Field(
        None,
        max_length=500,
        description="Vendor billing address",
    )
    vendor_tax_id: Optional[str] = Field(
        None,
        max_length=50,
        description="Vendor tax ID/GST number",
    )
    invoice_number: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Vendor invoice number",
    )
    invoice_date: date = Field(
        ...,
        description="Invoice issue date",
    )
    purchase_order_number: Optional[str] = Field(
        None,
        max_length=100,
        description="Our purchase order number",
    )
    line_items: List[InvoiceLineItem] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Invoice line items",
    )
    subtotal: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Subtotal (before tax)",
    )
    tax_amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total tax amount",
    )
    discount_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Discount amount",
    )
    total_amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total invoice amount",
    )
    payment_terms: str = Field(
        ...,
        max_length=200,
        description="Payment terms (e.g., Net 30, Due on receipt)",
    )
    due_date: date = Field(
        ...,
        description="Payment due date",
    )
    currency: str = Field(
        default="INR",
        max_length=3,
        description="Currency code (ISO 4217)",
    )
    invoice_document_url: Optional[str] = Field(
        None,
        description="URL to invoice document/PDF",
    )
    notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional notes",
    )

    @field_validator("invoice_date", "due_date")
    @classmethod
    def validate_dates(cls, v: date) -> date:
        """Validate invoice dates are reasonable."""
        # Invoice date shouldn't be too far in past or future
        days_diff = abs((date.today() - v).days)
        if days_diff > 365:
            raise ValueError(
                "Invoice date cannot be more than 1 year from today"
            )
        return v

    @model_validator(mode="after")
    def validate_invoice_totals(self) -> "VendorInvoice":
        """
        Validate invoice calculations.
        
        Ensures subtotal matches line items and total is calculated correctly.
        """
        # Validate subtotal matches line items
        line_items_total = sum(item.total_price for item in self.line_items)
        
        if abs(line_items_total - self.subtotal) > Decimal("0.01"):
            raise ValueError(
                f"Subtotal ({self.subtotal}) doesn't match sum of line items ({line_items_total})"
            )
        
        # Validate total calculation
        calculated_total = self.subtotal + self.tax_amount - self.discount_amount
        
        if abs(calculated_total - self.total_amount) > Decimal("0.01"):
            raise ValueError(
                f"Total amount ({self.total_amount}) doesn't match "
                f"subtotal ({self.subtotal}) + tax ({self.tax_amount}) - discount ({self.discount_amount})"
            )
        
        # Due date should be on or after invoice date
        if self.due_date < self.invoice_date:
            raise ValueError("Due date cannot be before invoice date")
        
        return self


class CostAnalysis(BaseSchema):
    """
    Cost analysis and trends.
    
    Provides insights into cost patterns, trends, and efficiency metrics.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    analysis_period: DateRangeFilter = Field(
        ...,
        description="Analysis period",
    )
    previous_period: Optional[DateRangeFilter] = Field(
        None,
        description="Previous period for comparison",
    )
    
    # Cost trends
    cost_trend: str = Field(
        ...,
        pattern=r"^(increasing|decreasing|stable)$",
        description="Overall cost trend direction",
    )
    trend_percentage: Decimal = Field(
        ...,
        decimal_places=2,
        description="Trend change percentage",
    )
    
    # Cost drivers
    highest_cost_category: str = Field(
        ...,
        description="Category with highest total cost",
    )
    highest_cost_category_amount: Decimal = Field(
        ...,
        ge=0,
        description="Amount spent in highest cost category",
    )
    most_frequent_category: str = Field(
        ...,
        description="Most frequently occurring category",
    )
    most_frequent_category_count: int = Field(
        ...,
        ge=0,
        description="Request count for most frequent category",
    )
    
    # Efficiency metrics
    cost_per_student: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average maintenance cost per student",
    )
    cost_per_room: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average maintenance cost per room",
    )
    cost_per_sqft: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Cost per square foot",
    )
    
    # Performance benchmarks
    comparison_to_previous_period: Decimal = Field(
        ...,
        decimal_places=2,
        description="Percentage change from previous period",
    )
    comparison_to_budget: Optional[Decimal] = Field(
        None,
        decimal_places=2,
        description="Percentage variance from budget",
    )
    
    # Predictive insights
    projected_annual_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Projected annual cost based on trends",
    )
    seasonal_variation: Optional[Decimal] = Field(
        None,
        description="Seasonal variation coefficient",
    )
    
    # Recommendations
    cost_saving_opportunities: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Identified cost-saving opportunities",
    )
    risk_areas: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Areas of cost risk",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\maintenance\maintenance_filters.py ---
# --- File: app/schemas/maintenance/maintenance_filters.py ---
"""
Maintenance filter schemas for querying and exporting.

Provides comprehensive filtering capabilities with validation
for searches, exports, and advanced queries.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import (
    MaintenanceCategory,
    MaintenanceIssueType,
    MaintenanceStatus,
    Priority,
)

__all__ = [
    "MaintenanceFilterParams",
    "SearchRequest",
    "MaintenanceExportRequest",
    "AdvancedFilterParams",
]


class MaintenanceFilterParams(BaseFilterSchema):
    """
    Comprehensive maintenance filter parameters.
    
    Supports multi-dimensional filtering for maintenance requests
    with text search, date ranges, and status filters.
    """

    # Text search
    search: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Search in title, description, request number",
    )
    search_fields: Optional[List[str]] = Field(
        None,
        description="Fields to search in (title, description, notes, etc.)",
    )
    
    # Hostel filters
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by specific hostel",
    )
    hostel_ids: Optional[List[UUID]] = Field(
        None,
        min_length=1,
        max_length=100,
        description="Filter by multiple hostels",
    )
    
    # User filters
    requested_by: Optional[UUID] = Field(
        None,
        description="Filter by requester",
    )
    requested_by_role: Optional[str] = Field(
        None,
        pattern=r"^(student|supervisor|admin)$",
        description="Filter by requester role",
    )
    
    # Assignment filters
    assigned_to: Optional[UUID] = Field(
        None,
        description="Filter by assignee",
    )
    assigned_to_role: Optional[str] = Field(
        None,
        pattern=r"^(staff|vendor|contractor)$",
        description="Filter by assignee role",
    )
    unassigned_only: Optional[bool] = Field(
        None,
        description="Show only unassigned requests",
    )
    
    # Room filters
    room_id: Optional[UUID] = Field(
        None,
        description="Filter by specific room",
    )
    room_ids: Optional[List[UUID]] = Field(
        None,
        min_length=1,
        max_length=100,
        description="Filter by multiple rooms",
    )
    floor: Optional[int] = Field(
        None,
        ge=0,
        le=50,
        description="Filter by floor number",
    )
    
    # Category filters
    category: Optional[MaintenanceCategory] = Field(
        None,
        description="Filter by specific category",
    )
    categories: Optional[List[MaintenanceCategory]] = Field(
        None,
        min_length=1,
        description="Filter by multiple categories",
    )
    exclude_categories: Optional[List[MaintenanceCategory]] = Field(
        None,
        description="Exclude specific categories",
    )
    
    # Priority filters
    priority: Optional[Priority] = Field(
        None,
        description="Filter by specific priority",
    )
    priorities: Optional[List[Priority]] = Field(
        None,
        min_length=1,
        description="Filter by multiple priorities",
    )
    min_priority: Optional[Priority] = Field(
        None,
        description="Minimum priority level (inclusive)",
    )
    
    # Status filters
    status: Optional[MaintenanceStatus] = Field(
        None,
        description="Filter by specific status",
    )
    statuses: Optional[List[MaintenanceStatus]] = Field(
        None,
        min_length=1,
        description="Filter by multiple statuses",
    )
    exclude_statuses: Optional[List[MaintenanceStatus]] = Field(
        None,
        description="Exclude specific statuses",
    )
    
    # Issue type filter
    issue_type: Optional[MaintenanceIssueType] = Field(
        None,
        description="Filter by issue type",
    )
    
    # Date filters
    created_date_from: Optional[date] = Field(
        None,
        description="Filter requests created from this date",
    )
    created_date_to: Optional[date] = Field(
        None,
        description="Filter requests created until this date",
    )
    completion_date_from: Optional[date] = Field(
        None,
        description="Filter by completion date from",
    )
    completion_date_to: Optional[date] = Field(
        None,
        description="Filter by completion date to",
    )
    due_date_from: Optional[date] = Field(
        None,
        description="Filter by due date from",
    )
    due_date_to: Optional[date] = Field(
        None,
        description="Filter by due date to",
    )
    
    # Cost filters
    estimated_cost_min: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Minimum estimated cost",
    )
    estimated_cost_max: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Maximum estimated cost",
    )
    actual_cost_min: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Minimum actual cost",
    )
    actual_cost_max: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Maximum actual cost",
    )
    
    # Special filters
    approval_pending: Optional[bool] = Field(
        None,
        description="Filter requests pending approval",
    )
    overdue_only: Optional[bool] = Field(
        None,
        description="Show only overdue requests",
    )
    is_preventive: Optional[bool] = Field(
        None,
        description="Filter preventive maintenance",
    )
    has_vendor: Optional[bool] = Field(
        None,
        description="Filter requests with vendor assignment",
    )
    quality_checked: Optional[bool] = Field(
        None,
        description="Filter by quality check status",
    )
    within_budget: Optional[bool] = Field(
        None,
        description="Filter requests within approved budget",
    )

    @field_validator("search")
    @classmethod
    def normalize_search(cls, v: Optional[str]) -> Optional[str]:
        """Normalize search query."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @field_validator(
        "estimated_cost_min",
        "estimated_cost_max",
        "actual_cost_min",
        "actual_cost_max",
    )
    @classmethod
    def round_costs(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round cost values to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_filter_consistency(self) -> "MaintenanceFilterParams":
        """
        Validate filter parameter consistency.
        
        Ensures compatible filters are used together and
        no conflicting options are specified.
        """
        # Validate date ranges
        if self.created_date_from and self.created_date_to:
            if self.created_date_to < self.created_date_from:
                raise ValueError(
                    "created_date_to must be after or equal to created_date_from"
                )
        
        if self.completion_date_from and self.completion_date_to:
            if self.completion_date_to < self.completion_date_from:
                raise ValueError(
                    "completion_date_to must be after or equal to completion_date_from"
                )
        
        # Validate cost ranges
        if self.estimated_cost_min and self.estimated_cost_max:
            if self.estimated_cost_max < self.estimated_cost_min:
                raise ValueError(
                    "estimated_cost_max must be greater than or equal to estimated_cost_min"
                )
        
        if self.actual_cost_min and self.actual_cost_max:
            if self.actual_cost_max < self.actual_cost_min:
                raise ValueError(
                    "actual_cost_max must be greater than or equal to actual_cost_min"
                )
        
        # Validate status filters
        if self.status and self.statuses:
            raise ValueError(
                "Cannot use both 'status' and 'statuses' filters"
            )
        
        if self.statuses and self.exclude_statuses:
            overlap = set(self.statuses) & set(self.exclude_statuses)
            if overlap:
                raise ValueError(
                    "Cannot include and exclude the same statuses"
                )
        
        # Validate category filters
        if self.category and self.categories:
            raise ValueError(
                "Cannot use both 'category' and 'categories' filters"
            )
        
        if self.categories and self.exclude_categories:
            overlap = set(self.categories) & set(self.exclude_categories)
            if overlap:
                raise ValueError(
                    "Cannot include and exclude the same categories"
                )
        
        # Validate priority filters
        if self.priority and self.priorities:
            raise ValueError(
                "Cannot use both 'priority' and 'priorities' filters"
            )
        
        # Validate hostel/room filters
        if self.hostel_id and self.hostel_ids:
            raise ValueError(
                "Cannot use both 'hostel_id' and 'hostel_ids' filters"
            )
        
        return self


class SearchRequest(BaseFilterSchema):
    """
    Maintenance search request with full-text capabilities.
    
    Optimized for text-based searches with field-specific targeting.
    """

    query: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Search query string",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Limit search to specific hostel",
    )
    search_in_title: bool = Field(
        True,
        description="Search in title field",
    )
    search_in_description: bool = Field(
        True,
        description="Search in description field",
    )
    search_in_number: bool = Field(
        True,
        description="Search in request number",
    )
    search_in_notes: bool = Field(
        False,
        description="Search in notes/comments",
    )
    status: Optional[MaintenanceStatus] = Field(
        None,
        description="Filter by status",
    )
    category: Optional[MaintenanceCategory] = Field(
        None,
        description="Filter by category",
    )
    priority: Optional[Priority] = Field(
        None,
        description="Filter by priority",
    )
    date_from: Optional[date] = Field(
        None,
        description="Search from this date",
    )
    date_to: Optional[date] = Field(
        None,
        description="Search until this date",
    )
    fuzzy_search: bool = Field(
        False,
        description="Enable fuzzy/approximate matching",
    )
    page: int = Field(
        1,
        ge=1,
        description="Page number",
    )
    page_size: int = Field(
        20,
        ge=1,
        le=100,
        description="Results per page",
    )

    @field_validator("query")
    @classmethod
    def normalize_query(cls, v: str) -> str:
        """Normalize search query."""
        v = v.strip()
        
        if len(v) < 1:
            raise ValueError("Search query cannot be empty")
        
        return v

    @model_validator(mode="after")
    def validate_search_fields(self) -> "SearchRequest":
        """
        Validate at least one search field is selected.
        
        Ensures meaningful search configuration.
        """
        if not any([
            self.search_in_title,
            self.search_in_description,
            self.search_in_number,
            self.search_in_notes,
        ]):
            raise ValueError(
                "At least one search field must be enabled"
            )
        
        return self


class AdvancedFilterParams(MaintenanceFilterParams):
    """
    Advanced filter parameters with additional criteria.
    
    Extends basic filters with complex queries and analytics filters.
    """

    # Time-based filters
    created_in_last_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Created in last N days",
    )
    completed_in_last_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Completed in last N days",
    )
    pending_for_days: Optional[int] = Field(
        None,
        ge=1,
        description="Pending for more than N days",
    )
    
    # Performance filters
    completion_time_min_days: Optional[int] = Field(
        None,
        ge=0,
        description="Minimum completion time in days",
    )
    completion_time_max_days: Optional[int] = Field(
        None,
        ge=0,
        description="Maximum completion time in days",
    )
    
    # Quality filters
    quality_rating_min: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Minimum quality rating",
    )
    quality_check_failed: Optional[bool] = Field(
        None,
        description="Filter failed quality checks",
    )
    rework_required: Optional[bool] = Field(
        None,
        description="Filter requests requiring rework",
    )
    
    # Cost variance filters
    over_budget: Optional[bool] = Field(
        None,
        description="Filter requests over budget",
    )
    cost_variance_min_percentage: Optional[Decimal] = Field(
        None,
        description="Minimum cost variance percentage",
    )
    cost_variance_max_percentage: Optional[Decimal] = Field(
        None,
        description="Maximum cost variance percentage",
    )
    
    # Vendor filters
    vendor_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Filter by vendor name (partial match)",
    )
    vendor_id: Optional[UUID] = Field(
        None,
        description="Filter by vendor ID",
    )
    
    # Warranty filters
    has_warranty: Optional[bool] = Field(
        None,
        description="Filter by warranty applicability",
    )
    warranty_active: Optional[bool] = Field(
        None,
        description="Filter by active warranty status",
    )
    
    # Grouping for analytics
    group_by: Optional[str] = Field(
        None,
        pattern=r"^(category|priority|status|month|assignee|vendor)$",
        description="Group results by field",
    )
    
    # Sorting
    sort_by: str = Field(
        "created_at",
        pattern=r"^(created_at|priority|estimated_cost|actual_cost|completion_date|status)$",
        description="Sort results by field",
    )
    sort_order: str = Field(
        "desc",
        pattern=r"^(asc|desc)$",
        description="Sort order",
    )

    @field_validator("vendor_name")
    @classmethod
    def normalize_vendor_name(cls, v: Optional[str]) -> Optional[str]:
        """Normalize vendor name."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_advanced_filters(self) -> "AdvancedFilterParams":
        """Validate advanced filter combinations."""
        # Validate completion time range
        if self.completion_time_min_days and self.completion_time_max_days:
            if self.completion_time_max_days < self.completion_time_min_days:
                raise ValueError(
                    "completion_time_max_days must be >= completion_time_min_days"
                )
        
        return self


class MaintenanceExportRequest(BaseFilterSchema):
    """
    Export maintenance data with format and options.
    
    Supports multiple export formats with customizable content
    and field selection.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Export data for specific hostel",
    )
    filters: Optional[MaintenanceFilterParams] = Field(
        None,
        description="Apply filters to export",
    )
    format: str = Field(
        "csv",
        pattern=r"^(csv|excel|pdf|json)$",
        description="Export format",
    )
    
    # Content options
    include_cost_details: bool = Field(
        True,
        description="Include cost breakdown",
    )
    include_assignment_details: bool = Field(
        True,
        description="Include assignment information",
    )
    include_completion_details: bool = Field(
        True,
        description="Include completion details",
    )
    include_quality_check: bool = Field(
        False,
        description="Include quality check results",
    )
    include_materials: bool = Field(
        False,
        description="Include materials used",
    )
    include_photos: bool = Field(
        False,
        description="Include photo URLs",
    )
    include_vendor_details: bool = Field(
        False,
        description="Include vendor information",
    )
    include_notes: bool = Field(
        False,
        description="Include notes and comments",
    )
    
    # Field selection
    selected_fields: Optional[List[str]] = Field(
        None,
        max_length=50,
        description="Specific fields to include (overrides include_* options)",
    )
    
    # Grouping and summary
    include_summary: bool = Field(
        True,
        description="Include summary statistics",
    )
    include_charts: bool = Field(
        False,
        description="Include charts/graphs (PDF only)",
    )
    group_by: Optional[str] = Field(
        None,
        pattern=r"^(category|priority|status|month|assignee)$",
        description="Group export by field",
    )
    
    # Sorting
    sort_by: str = Field(
        "created_at",
        description="Sort export by field",
    )
    sort_order: str = Field(
        "desc",
        pattern=r"^(asc|desc)$",
        description="Sort order",
    )
    
    # Output options
    file_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Custom filename (without extension)",
    )
    include_timestamp: bool = Field(
        True,
        description="Include timestamp in filename",
    )
    compress: bool = Field(
        False,
        description="Compress export file (zip)",
    )
    
    # Date range for export
    date_from: Optional[date] = Field(
        None,
        description="Export data from this date",
    )
    date_to: Optional[date] = Field(
        None,
        description="Export data until this date",
    )
    
    # Limits
    max_records: int = Field(
        10000,
        ge=1,
        le=100000,
        description="Maximum records to export",
    )

    @field_validator("file_name")
    @classmethod
    def validate_filename(cls, v: Optional[str]) -> Optional[str]:
        """Validate and sanitize filename."""
        if v is not None:
            import re
            # Remove invalid characters
            v = re.sub(r'[<>:"/\\|?*]', '', v)
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_export_config(self) -> "MaintenanceExportRequest":
        """
        Validate export configuration.
        
        Ensures valid combinations and format-specific requirements.
        """
        # PDF-specific validations
        if self.format == "pdf":
            if self.max_records > 5000:
                raise ValueError(
                    "PDF exports are limited to 5000 records"
                )
            
            if self.include_charts and not self.include_summary:
                raise ValueError(
                    "Charts require summary to be included"
                )
        
        # JSON format validations
        if self.format == "json":
            if self.include_charts:
                raise ValueError(
                    "Charts are not supported in JSON format"
                )
        
        # Validate date range
        if self.date_from and self.date_to:
            if self.date_to < self.date_from:
                raise ValueError(
                    "date_to must be after or equal to date_from"
                )
            
            # Warn for large date ranges
            days_diff = (self.date_to - self.date_from).days
            if days_diff > 365 and self.format == "pdf":
                raise ValueError(
                    "PDF exports cannot exceed 365 days of data"
                )
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\maintenance\maintenance_request.py ---
# --- File: app/schemas/maintenance/maintenance_request.py ---
"""
Maintenance request submission schemas.

Provides schemas for different types of maintenance requests including
standard, detailed supervisor submissions, and emergency requests.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema
from app.schemas.common.enums import MaintenanceCategory, Priority

__all__ = [
    "MaintenanceRequest",
    "RequestSubmission",
    "EmergencyRequest",
]


class MaintenanceRequest(BaseCreateSchema):
    """
    Standard maintenance request submission.
    
    Simplified schema for students/residents to submit maintenance
    issues with essential information.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Room where issue exists",
    )
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Brief issue summary",
    )
    description: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed issue description",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Issue category",
    )
    priority: Priority = Field(
        Priority.MEDIUM,
        description="Requested priority (may be adjusted by supervisor)",
    )
    location: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional location details",
    )
    issue_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="Issue photographs",
    )
    preferred_time_slot: Optional[str] = Field(
        None,
        pattern=r"^(morning|afternoon|evening|any)$",
        description="Preferred time for repair work",
    )
    contact_number: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact number for follow-up",
    )

    @field_validator("title", "description")
    @classmethod
    def validate_text_fields(cls, v: str) -> str:
        """Validate text fields are meaningful."""
        v = v.strip()
        
        field_name = cls.model_fields.get("title") or cls.model_fields.get("description")
        min_length = 5 if field_name == "title" else 20
        
        if len(v) < min_length:
            raise ValueError(f"Field must be at least {min_length} characters")
        
        # Check for meaningful content
        min_unique_chars = 3 if min_length == 5 else 10
        if len(set(v.lower().replace(" ", ""))) < min_unique_chars:
            raise ValueError("Please provide meaningful and descriptive text")
        
        return v

    @field_validator("contact_number")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone number."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return None

    @field_validator("location")
    @classmethod
    def normalize_location(cls, v: Optional[str]) -> Optional[str]:
        """Normalize location field."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None


class RequestSubmission(BaseCreateSchema):
    """
    Detailed maintenance request submission by supervisor.
    
    Enhanced schema with cost estimation, vendor preferences,
    and timeline planning capabilities.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Room where issue exists",
    )
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Issue title",
    )
    description: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed description",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Maintenance category",
    )
    priority: Priority = Field(
        ...,
        description="Issue priority",
    )
    location: Optional[str] = Field(
        None,
        max_length=500,
        description="Location details",
    )
    issue_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="Issue photographs",
    )

    # Supervisor-specific fields
    estimated_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Estimated repair cost",
    )
    cost_justification: Optional[str] = Field(
        None,
        max_length=500,
        description="Justification for estimated cost",
    )
    preferred_vendor: Optional[str] = Field(
        None,
        max_length=255,
        description="Preferred vendor/contractor name",
    )
    vendor_contact: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Vendor contact number",
    )
    estimated_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Estimated days to complete work",
    )
    requires_immediate_attention: bool = Field(
        False,
        description="Flag for urgent/emergency issues",
    )
    approval_required: bool = Field(
        False,
        description="Whether admin approval is required",
    )
    materials_needed: Optional[str] = Field(
        None,
        max_length=1000,
        description="List of materials/parts needed",
    )

    @field_validator("estimated_cost")
    @classmethod
    def round_cost(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round cost to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @field_validator("vendor_contact")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize vendor phone number."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return None

    @field_validator("cost_justification", "materials_needed")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_vendor_information(self) -> "RequestSubmission":
        """
        Validate vendor information completeness.
        
        If vendor is specified, contact should be provided.
        """
        if self.preferred_vendor and not self.vendor_contact:
            raise ValueError(
                "Vendor contact is required when preferred vendor is specified"
            )
        
        return self

    @model_validator(mode="after")
    def validate_cost_information(self) -> "RequestSubmission":
        """
        Validate cost estimation requirements.
        
        High-cost estimates should have justification.
        """
        if self.estimated_cost is not None:
            # Cost above threshold requires justification
            if self.estimated_cost > Decimal("5000.00"):
                if not self.cost_justification:
                    raise ValueError(
                        "Cost justification required for estimates above 5000"
                    )
                
                if len(self.cost_justification.strip()) < 20:
                    raise ValueError(
                        "Cost justification must be at least 20 characters"
                    )
        
        return self

    @model_validator(mode="after")
    def validate_urgency_consistency(self) -> "RequestSubmission":
        """
        Validate urgency and priority consistency.
        
        Immediate attention requests should have high priority.
        """
        if self.requires_immediate_attention:
            if self.priority not in [Priority.HIGH, Priority.URGENT, Priority.CRITICAL]:
                raise ValueError(
                    "Requests requiring immediate attention must have HIGH, "
                    "URGENT, or CRITICAL priority"
                )
        
        return self


class EmergencyRequest(BaseCreateSchema):
    """
    Emergency maintenance request with safety protocols.
    
    Handles critical situations requiring immediate response
    with safety tracking and authority notification.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    emergency_type: str = Field(
        ...,
        pattern=r"^(fire|flood|electrical_hazard|gas_leak|structural_damage|lift_malfunction|other)$",
        description="Type of emergency",
    )
    description: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed emergency description",
    )
    location: str = Field(
        ...,
        min_length=5,
        max_length=500,
        description="Exact emergency location",
    )
    affected_area: Optional[str] = Field(
        None,
        max_length=500,
        description="Area/rooms affected by emergency",
    )

    # Safety information
    immediate_actions_taken: Optional[str] = Field(
        None,
        max_length=1000,
        description="Immediate actions already taken",
    )
    evacuated: bool = Field(
        False,
        description="Whether area has been evacuated",
    )
    evacuation_details: Optional[str] = Field(
        None,
        max_length=500,
        description="Evacuation details if applicable",
    )
    authorities_notified: bool = Field(
        False,
        description="Whether emergency services have been notified",
    )
    authority_details: Optional[str] = Field(
        None,
        max_length=500,
        description="Details of authorities notified",
    )

    # Contact information
    contact_person: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="On-site contact person name",
    )
    contact_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact person phone number",
    )
    alternate_contact: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Alternate contact number",
    )

    # Severity assessment
    injuries_reported: bool = Field(
        default=False,
        description="Whether there are any injuries",
    )
    injury_details: Optional[str] = Field(
        None,
        max_length=500,
        description="Details of injuries if any",
    )
    property_damage_estimated: Optional[str] = Field(
        None,
        pattern=r"^(minor|moderate|major|severe|catastrophic)$",
        description="Estimated property damage level",
    )

    # Supporting evidence
    emergency_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=15,
        description="Emergency situation photographs",
    )

    @field_validator("description", "location")
    @classmethod
    def validate_required_text(cls, v: str) -> str:
        """Validate required text fields."""
        v = v.strip()
        
        if len(v) < 20:
            raise ValueError("Emergency details must be comprehensive (min 20 chars)")
        
        return v

    @field_validator("contact_phone", "alternate_contact")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone numbers."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return None

    @field_validator(
        "immediate_actions_taken",
        "evacuation_details",
        "authority_details",
        "injury_details",
    )
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize optional text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_evacuation_consistency(self) -> "EmergencyRequest":
        """
        Validate evacuation information consistency.
        
        If evacuated, details should be provided.
        """
        if self.evacuated and not self.evacuation_details:
            raise ValueError(
                "Evacuation details are required when area has been evacuated"
            )
        
        return self

    @model_validator(mode="after")
    def validate_injury_reporting(self) -> "EmergencyRequest":
        """
        Validate injury reporting requirements.
        
        If injuries reported, details must be provided.
        """
        if self.injuries_reported and not self.injury_details:
            raise ValueError(
                "Injury details are required when injuries are reported"
            )
        
        return self

    @model_validator(mode="after")
    def validate_authority_notification(self) -> "EmergencyRequest":
        """
        Validate authority notification for serious emergencies.
        
        Certain emergency types should have authorities notified.
        """
        serious_emergencies = {"fire", "gas_leak", "structural_damage"}
        
        if self.emergency_type in serious_emergencies:
            if not self.authorities_notified:
                raise ValueError(
                    f"{self.emergency_type} emergencies should have authorities notified. "
                    "If not yet notified, please notify immediately."
                )
            
            if not self.authority_details:
                raise ValueError(
                    "Authority notification details are required for serious emergencies"
                )
        
        return self

    @model_validator(mode="after")
    def validate_safety_actions(self) -> "EmergencyRequest":
        """
        Validate safety action documentation.
        
        Emergency requests should document immediate actions.
        """
        dangerous_types = {"fire", "gas_leak", "electrical_hazard"}
        
        if self.emergency_type in dangerous_types:
            if not self.immediate_actions_taken:
                raise ValueError(
                    f"Immediate actions taken must be documented for {self.emergency_type}"
                )
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\maintenance\maintenance_response.py ---
# --- File: app/schemas/maintenance/maintenance_response.py ---
"""
Maintenance response schemas for API responses.

Provides various response formats for maintenance data including
detailed, summary, and list views with computed fields.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import (
    MaintenanceCategory,
    MaintenanceIssueType,
    MaintenanceStatus,
    Priority,
)

__all__ = [
    "MaintenanceResponse",
    "MaintenanceDetail",
    "RequestListItem",
    "MaintenanceSummary",
]


class MaintenanceResponse(BaseResponseSchema):
    """
    Standard maintenance response with essential information.
    
    Lightweight response schema for list views and basic queries.
    """

    request_number: str = Field(
        ...,
        description="Human-readable request number",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    requested_by: UUID = Field(
        ...,
        description="Requester user ID",
    )
    requested_by_name: str = Field(
        ...,
        description="Requester full name",
    )
    title: str = Field(
        ...,
        description="Issue title",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Maintenance category",
    )
    priority: Priority = Field(
        ...,
        description="Issue priority",
    )
    status: MaintenanceStatus = Field(
        ...,
        description="Current status",
    )
    assigned_to: Optional[UUID] = Field(
        None,
        description="Assignee user ID",
    )
    assigned_to_name: Optional[str] = Field(
        None,
        description="Assignee name",
    )
    estimated_cost: Optional[Decimal] = Field(
        None,
        description="Estimated cost",
    )
    actual_cost: Optional[Decimal] = Field(
        None,
        description="Actual cost",
    )
    created_at: datetime = Field(
        ...,
        description="Request creation timestamp",
    )
    estimated_completion_date: Optional[date] = Field(
        None,
        description="Estimated completion date",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="Completion timestamp",
    )

    @computed_field
    @property
    def status_display(self) -> str:
        """Human-readable status display."""
        status_map = {
            MaintenanceStatus.PENDING: "Pending",
            MaintenanceStatus.APPROVED: "Approved",
            MaintenanceStatus.ASSIGNED: "Assigned",
            MaintenanceStatus.IN_PROGRESS: "In Progress",
            MaintenanceStatus.ON_HOLD: "On Hold",
            MaintenanceStatus.COMPLETED: "Completed",
            MaintenanceStatus.REJECTED: "Rejected",
            MaintenanceStatus.CANCELLED: "Cancelled",
        }
        return status_map.get(self.status, self.status.value)

    @computed_field
    @property
    def priority_display(self) -> str:
        """Human-readable priority display."""
        priority_map = {
            Priority.LOW: "Low",
            Priority.MEDIUM: "Medium",
            Priority.HIGH: "High",
            Priority.URGENT: "Urgent",
            Priority.CRITICAL: "Critical",
        }
        return priority_map.get(self.priority, self.priority.value)

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if request is overdue."""
        if not self.estimated_completion_date:
            return False
        
        if self.status == MaintenanceStatus.COMPLETED:
            return False
        
        return self.estimated_completion_date < date.today()

    @computed_field
    @property
    def days_since_creation(self) -> int:
        """Calculate days since request was created."""
        return (datetime.now() - self.created_at).days


class MaintenanceDetail(BaseResponseSchema):
    """
    Detailed maintenance information with complete metadata.
    
    Comprehensive response including all maintenance details, workflow,
    and supporting information.
    """

    request_number: str = Field(
        ...,
        description="Request number",
    )
    
    # Hostel information
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    
    # Requester information
    requested_by: UUID = Field(
        ...,
        description="Requester user ID",
    )
    requested_by_name: str = Field(
        ...,
        description="Requester full name",
    )
    requested_by_email: Optional[str] = Field(
        None,
        description="Requester email",
    )
    requested_by_phone: Optional[str] = Field(
        None,
        description="Requester phone",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Room ID",
    )
    room_number: Optional[str] = Field(
        None,
        description="Room number",
    )
    
    # Request details
    title: str = Field(
        ...,
        description="Issue title",
    )
    description: str = Field(
        ...,
        description="Detailed description",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Maintenance category",
    )
    priority: Priority = Field(
        ...,
        description="Priority level",
    )
    issue_type: MaintenanceIssueType = Field(
        ...,
        description="Issue type",
    )
    
    # Location details
    location: Optional[str] = Field(
        None,
        description="Location details",
    )
    floor: Optional[int] = Field(
        None,
        description="Floor number",
    )
    specific_area: Optional[str] = Field(
        None,
        description="Specific area",
    )
    
    # Photos and documents
    issue_photos: List[str] = Field(
        default_factory=list,
        description="Issue photographs",
    )
    completion_photos: List[str] = Field(
        default_factory=list,
        description="Completion photographs",
    )
    
    # Assignment information
    assigned_to: Optional[UUID] = Field(
        None,
        description="Assignee user ID",
    )
    assigned_to_name: Optional[str] = Field(
        None,
        description="Assignee name",
    )
    assigned_to_role: Optional[str] = Field(
        None,
        description="Assignee role",
    )
    assigned_by: Optional[UUID] = Field(
        None,
        description="Assignor user ID",
    )
    assigned_by_name: Optional[str] = Field(
        None,
        description="Assignor name",
    )
    assigned_at: Optional[datetime] = Field(
        None,
        description="Assignment timestamp",
    )
    
    # Vendor information (if applicable)
    vendor_name: Optional[str] = Field(
        None,
        description="Vendor company name",
    )
    vendor_contact: Optional[str] = Field(
        None,
        description="Vendor contact number",
    )
    vendor_email: Optional[str] = Field(
        None,
        description="Vendor email",
    )
    
    # Status workflow
    status: MaintenanceStatus = Field(
        ...,
        description="Current status",
    )
    status_history: Optional[List[dict]] = Field(
        None,
        description="Status change history",
    )
    
    # Approval workflow
    requires_approval: bool = Field(
        default=False,
        description="Whether approval is required",
    )
    approval_pending: bool = Field(
        default=False,
        description="Whether approval is pending",
    )
    approved_by: Optional[UUID] = Field(
        None,
        description="Approver user ID",
    )
    approved_by_name: Optional[str] = Field(
        None,
        description="Approver name",
    )
    approved_at: Optional[datetime] = Field(
        None,
        description="Approval timestamp",
    )
    rejected_by: Optional[UUID] = Field(
        None,
        description="Rejector user ID",
    )
    rejected_at: Optional[datetime] = Field(
        None,
        description="Rejection timestamp",
    )
    rejection_reason: Optional[str] = Field(
        None,
        description="Rejection reason",
    )
    
    # Timeline
    started_at: Optional[datetime] = Field(
        None,
        description="Work start timestamp",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="Completion timestamp",
    )
    
    # Cost tracking
    estimated_cost: Optional[Decimal] = Field(
        None,
        description="Estimated cost",
    )
    actual_cost: Optional[Decimal] = Field(
        None,
        description="Actual cost incurred",
    )
    cost_approved: bool = Field(
        default=False,
        description="Whether cost was approved",
    )
    approval_threshold_exceeded: bool = Field(
        default=False,
        description="Whether cost exceeded approval threshold",
    )
    
    # Timeline estimates
    estimated_completion_date: Optional[date] = Field(
        None,
        description="Estimated completion date",
    )
    actual_completion_date: Optional[date] = Field(
        None,
        description="Actual completion date",
    )
    deadline: Optional[date] = Field(
        None,
        description="Completion deadline",
    )
    
    # Work details
    work_notes: Optional[str] = Field(
        None,
        description="Work performed notes",
    )
    materials_used: List[dict] = Field(
        default_factory=list,
        description="Materials used in work",
    )
    labor_hours: Optional[Decimal] = Field(
        None,
        description="Labor hours spent",
    )
    
    # Quality check
    quality_checked: bool = Field(
        default=False,
        description="Whether quality check was performed",
    )
    quality_checked_by: Optional[UUID] = Field(
        None,
        description="Quality checker user ID",
    )
    quality_check_passed: Optional[bool] = Field(
        None,
        description="Quality check result",
    )
    quality_check_notes: Optional[str] = Field(
        None,
        description="Quality check notes",
    )
    quality_checked_at: Optional[datetime] = Field(
        None,
        description="Quality check timestamp",
    )
    quality_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Quality rating (1-5 stars)",
    )
    
    # Preventive maintenance
    is_preventive: bool = Field(
        default=False,
        description="Whether this is preventive maintenance",
    )
    preventive_schedule_id: Optional[UUID] = Field(
        None,
        description="Related preventive schedule ID",
    )
    next_scheduled_date: Optional[date] = Field(
        None,
        description="Next scheduled maintenance date",
    )
    recurrence: Optional[str] = Field(
        None,
        description="Recurrence pattern",
    )
    
    # Warranty
    warranty_applicable: bool = Field(
        default=False,
        description="Whether warranty applies",
    )
    warranty_period_months: Optional[int] = Field(
        None,
        description="Warranty period in months",
    )
    warranty_expiry_date: Optional[date] = Field(
        None,
        description="Warranty expiry date",
    )

    @computed_field
    @property
    def is_completed(self) -> bool:
        """Check if maintenance is completed."""
        return self.status == MaintenanceStatus.COMPLETED

    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if maintenance is currently active/in-progress."""
        active_statuses = {
            MaintenanceStatus.ASSIGNED,
            MaintenanceStatus.IN_PROGRESS,
        }
        return self.status in active_statuses

    @computed_field
    @property
    def cost_variance(self) -> Optional[Decimal]:
        """Calculate cost variance if both costs available."""
        if self.estimated_cost and self.actual_cost:
            return round(self.actual_cost - self.estimated_cost, 2)
        return None

    @computed_field
    @property
    def cost_variance_percentage(self) -> Optional[Decimal]:
        """Calculate cost variance percentage."""
        if self.estimated_cost and self.actual_cost and self.estimated_cost > 0:
            variance_pct = (
                (self.actual_cost - self.estimated_cost) / self.estimated_cost * 100
            )
            return round(variance_pct, 2)
        return None

    @computed_field
    @property
    def time_to_complete_days(self) -> Optional[int]:
        """Calculate total days from creation to completion."""
        if self.completed_at:
            return (self.completed_at - self.created_at).days
        return None


class RequestListItem(BaseSchema):
    """
    Minimal maintenance list item for efficient list rendering.
    
    Optimized for pagination and list views with minimal data transfer.
    """

    id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    title: str = Field(
        ...,
        description="Issue title",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Category",
    )
    priority: Priority = Field(
        ...,
        description="Priority",
    )
    status: MaintenanceStatus = Field(
        ...,
        description="Status",
    )
    room_number: Optional[str] = Field(
        None,
        description="Room number",
    )
    estimated_cost: Optional[Decimal] = Field(
        None,
        description="Estimated cost",
    )
    assigned_to_name: Optional[str] = Field(
        None,
        description="Assignee name",
    )
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )
    estimated_completion_date: Optional[date] = Field(
        None,
        description="Estimated completion",
    )

    @computed_field
    @property
    def status_badge_color(self) -> str:
        """Get color code for status badge (for UI rendering)."""
        color_map = {
            MaintenanceStatus.PENDING: "yellow",
            MaintenanceStatus.APPROVED: "blue",
            MaintenanceStatus.ASSIGNED: "cyan",
            MaintenanceStatus.IN_PROGRESS: "orange",
            MaintenanceStatus.ON_HOLD: "gray",
            MaintenanceStatus.COMPLETED: "green",
            MaintenanceStatus.REJECTED: "red",
            MaintenanceStatus.CANCELLED: "gray",
        }
        return color_map.get(self.status, "gray")

    @computed_field
    @property
    def priority_badge_color(self) -> str:
        """Get color code for priority badge."""
        color_map = {
            Priority.LOW: "green",
            Priority.MEDIUM: "yellow",
            Priority.HIGH: "orange",
            Priority.URGENT: "red",
            Priority.CRITICAL: "purple",
        }
        return color_map.get(self.priority, "gray")

    @computed_field
    @property
    def is_urgent(self) -> bool:
        """Check if request is urgent or critical."""
        return self.priority in [Priority.URGENT, Priority.CRITICAL]


class MaintenanceSummary(BaseSchema):
    """
    Maintenance summary statistics for hostel dashboard.
    
    Provides aggregated metrics for monitoring and reporting.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    period_start: Optional[date] = Field(
        None,
        description="Summary period start",
    )
    period_end: Optional[date] = Field(
        None,
        description="Summary period end",
    )
    
    # Request counts by status
    total_requests: int = Field(
        ...,
        ge=0,
        description="Total maintenance requests",
    )
    pending_requests: int = Field(
        ...,
        ge=0,
        description="Pending requests",
    )
    in_progress_requests: int = Field(
        ...,
        ge=0,
        description="In-progress requests",
    )
    completed_requests: int = Field(
        ...,
        ge=0,
        description="Completed requests",
    )
    on_hold_requests: int = Field(
        default=0,
        ge=0,
        description="On-hold requests",
    )
    cancelled_requests: int = Field(
        default=0,
        ge=0,
        description="Cancelled requests",
    )
    
    # Priority breakdown
    high_priority_count: int = Field(
        ...,
        ge=0,
        description="High priority requests",
    )
    urgent_priority_count: int = Field(
        ...,
        ge=0,
        description="Urgent priority requests",
    )
    critical_priority_count: int = Field(
        default=0,
        ge=0,
        description="Critical priority requests",
    )
    
    # Cost summary
    total_estimated_cost: Decimal = Field(
        ...,
        ge=0,
        description="Total estimated costs",
    )
    total_actual_cost: Decimal = Field(
        ...,
        ge=0,
        description="Total actual costs",
    )
    average_cost_per_request: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average cost per request",
    )
    
    # Performance metrics
    average_completion_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average completion time in hours",
    )
    average_completion_time_days: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average completion time in days",
    )
    on_time_completion_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Percentage completed on time",
    )
    
    # Quality metrics
    quality_check_pass_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Quality check pass rate",
    )
    average_quality_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average quality rating",
    )
    
    # Category breakdown
    requests_by_category: Optional[dict] = Field(
        None,
        description="Request count by category",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate percentage."""
        if self.total_requests == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.completed_requests) / Decimal(self.total_requests) * 100,
            2,
        )

    @computed_field
    @property
    def cost_variance_total(self) -> Decimal:
        """Calculate total cost variance."""
        return round(self.total_actual_cost - self.total_estimated_cost, 2)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\maintenance\maintenance_schedule.py ---
# --- File: app/schemas/maintenance/maintenance_schedule.py ---
"""
Preventive maintenance schedule schemas.

Provides schemas for scheduled preventive maintenance with recurrence,
execution tracking, and checklist management.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import MaintenanceCategory, MaintenanceRecurrence

__all__ = [
    "PreventiveSchedule",
    "ScheduleCreate",
    "ScheduleChecklistItem",
    "RecurrenceConfig",
    "ScheduleExecution",
    "ChecklistResult",
    "ScheduleUpdate",
    "ScheduleHistory",
    "ExecutionHistoryItem",
]


class ScheduleChecklistItem(BaseSchema):
    """
    Checklist item for scheduled maintenance task.
    
    Defines specific checks to be performed during maintenance.
    """

    item_id: Optional[str] = Field(
        None,
        max_length=50,
        description="Unique item identifier",
    )
    item_description: str = Field(
        ...,
        min_length=5,
        max_length=500,
        description="Description of check/task to perform",
    )
    category: Optional[str] = Field(
        None,
        max_length=100,
        description="Item category",
    )
    is_required: bool = Field(
        True,
        description="Whether this item is mandatory",
    )
    is_critical: bool = Field(
        default=False,
        description="Whether this is a critical safety check",
    )
    item_order: int = Field(
        ...,
        ge=1,
        le=1000,
        description="Display order in checklist",
    )
    estimated_time_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Estimated time for this item in minutes",
    )
    instructions: Optional[str] = Field(
        None,
        max_length=1000,
        description="Detailed instructions for this check",
    )

    @field_validator("item_description", "instructions")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None


class PreventiveSchedule(BaseResponseSchema):
    """
    Preventive maintenance schedule.
    
    Defines recurring maintenance tasks with scheduling
    and assignment information.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    schedule_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Schedule code/reference",
    )
    title: str = Field(
        ...,
        description="Schedule title",
    )
    description: Optional[str] = Field(
        None,
        description="Schedule description",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Maintenance category",
    )
    recurrence: MaintenanceRecurrence = Field(
        ...,
        description="Recurrence pattern",
    )
    next_due_date: date = Field(
        ...,
        description="Next scheduled execution date",
    )
    last_execution_date: Optional[date] = Field(
        None,
        description="Last execution date",
    )
    assigned_to: Optional[UUID] = Field(
        None,
        description="Default assignee user ID",
    )
    assigned_to_name: Optional[str] = Field(
        None,
        description="Default assignee name",
    )
    estimated_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Estimated cost per execution",
    )
    estimated_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Estimated duration in hours",
    )
    is_active: bool = Field(
        True,
        description="Whether schedule is active",
    )
    total_executions: int = Field(
        default=0,
        ge=0,
        description="Total times executed",
    )
    last_completed_date: Optional[date] = Field(
        None,
        description="Last successful completion date",
    )
    priority_level: Optional[str] = Field(
        None,
        pattern=r"^(low|medium|high)$",
        description="Default priority level",
    )

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if schedule is overdue."""
        return self.next_due_date < date.today()

    @computed_field
    @property
    def days_until_due(self) -> int:
        """Calculate days until next due date."""
        return (self.next_due_date - date.today()).days


class ScheduleCreate(BaseCreateSchema):
    """
    Create preventive maintenance schedule.
    
    Defines new recurring maintenance with checklist and recurrence rules.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    schedule_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Schedule code/reference",
    )
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Schedule title",
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Detailed description",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Maintenance category",
    )
    recurrence: MaintenanceRecurrence = Field(
        ...,
        description="Recurrence pattern",
    )
    start_date: date = Field(
        ...,
        description="First scheduled date",
    )
    end_date: Optional[date] = Field(
        None,
        description="Last scheduled date (optional)",
    )
    assigned_to: Optional[UUID] = Field(
        None,
        description="Default assignee",
    )
    estimated_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Estimated cost per execution",
    )
    estimated_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        decimal_places=2,
        description="Estimated duration in hours",
    )
    checklist: List[ScheduleChecklistItem] = Field(
        default_factory=list,
        max_length=100,
        description="Maintenance checklist items",
    )
    auto_create_requests: bool = Field(
        default=True,
        description="Auto-create maintenance requests on due date",
    )
    notification_days_before: int = Field(
        default=3,
        ge=0,
        le=30,
        description="Days before due date to send notification",
    )
    priority_level: Optional[str] = Field(
        None,
        pattern=r"^(low|medium|high)$",
        description="Default priority level",
    )

    @field_validator("start_date")
    @classmethod
    def validate_start_date(cls, v: date) -> date:
        """Validate start date is reasonable."""
        # Can't be too far in past
        days_past = (date.today() - v).days
        if days_past > 365:
            raise ValueError(
                "Start date cannot be more than 1 year in the past"
            )
        
        return v

    @field_validator("title", "description")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @field_validator("estimated_cost", "estimated_duration_hours")
    @classmethod
    def round_decimals(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round decimal values."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_date_range(self) -> "ScheduleCreate":
        """
        Validate schedule date range.
        
        End date should be after start date if provided.
        """
        if self.end_date:
            if self.end_date <= self.start_date:
                raise ValueError("End date must be after start date")
            
            # Reasonable maximum duration
            duration_years = (self.end_date - self.start_date).days / 365
            if duration_years > 10:
                raise ValueError(
                    "Schedule duration cannot exceed 10 years"
                )
        
        return self

    @model_validator(mode="after")
    def validate_checklist_order(self) -> "ScheduleCreate":
        """
        Validate checklist item ordering.
        
        Ensures no duplicate order numbers.
        """
        if self.checklist:
            orders = [item.item_order for item in self.checklist]
            if len(orders) != len(set(orders)):
                raise ValueError(
                    "Checklist items must have unique order numbers"
                )
        
        return self


class RecurrenceConfig(BaseSchema):
    """
    Advanced recurrence configuration.
    
    Defines detailed recurrence rules for complex scheduling patterns.
    """

    recurrence_type: MaintenanceRecurrence = Field(
        ...,
        description="Recurrence type",
    )
    interval_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Interval for custom recurrence (in days)",
    )
    day_of_week: Optional[int] = Field(
        None,
        ge=0,
        le=6,
        description="Day of week (0=Monday, 6=Sunday) for weekly recurrence",
    )
    day_of_month: Optional[int] = Field(
        None,
        ge=1,
        le=31,
        description="Day of month for monthly recurrence",
    )
    month_of_year: Optional[int] = Field(
        None,
        ge=1,
        le=12,
        description="Month for yearly recurrence",
    )
    end_date: Optional[date] = Field(
        None,
        description="Stop recurring after this date",
    )
    max_occurrences: Optional[int] = Field(
        None,
        ge=1,
        le=1000,
        description="Maximum number of occurrences",
    )
    skip_weekends: bool = Field(
        default=False,
        description="Skip weekends when scheduling",
    )
    skip_holidays: bool = Field(
        default=False,
        description="Skip holidays when scheduling",
    )

    @model_validator(mode="after")
    def validate_recurrence_rules(self) -> "RecurrenceConfig":
        """
        Validate recurrence configuration consistency.
        
        Ensures appropriate fields are set for recurrence type.
        """
        # Weekly should have day_of_week
        if self.recurrence_type == MaintenanceRecurrence.WEEKLY:
            if self.day_of_week is None:
                raise ValueError(
                    "day_of_week is required for weekly recurrence"
                )
        
        # Monthly should have day_of_month
        if self.recurrence_type == MaintenanceRecurrence.MONTHLY:
            if self.day_of_month is None:
                raise ValueError(
                    "day_of_month is required for monthly recurrence"
                )
        
        # Yearly should have month
        if self.recurrence_type == MaintenanceRecurrence.YEARLY:
            if self.month_of_year is None:
                raise ValueError(
                    "month_of_year is required for yearly recurrence"
                )
        
        # End condition validation
        if self.end_date and self.max_occurrences:
            # Both provided is okay, will use whichever comes first
            pass
        
        return self


class ChecklistResult(BaseSchema):
    """
    Result of individual checklist item execution.
    
    Records completion status and findings for checklist item.
    """

    item_id: Optional[str] = Field(
        None,
        description="Checklist item ID",
    )
    item_description: str = Field(
        ...,
        description="Item description",
    )
    completed: bool = Field(
        ...,
        description="Whether item was completed",
    )
    status: str = Field(
        ...,
        pattern=r"^(pass|fail|na|skipped)$",
        description="Item completion status",
    )
    notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Notes or observations",
    )
    issues_found: Optional[str] = Field(
        None,
        max_length=500,
        description="Issues found during check",
    )
    action_taken: Optional[str] = Field(
        None,
        max_length=500,
        description="Action taken to resolve issues",
    )
    time_taken_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Time taken for this item",
    )

    @field_validator("notes", "issues_found", "action_taken")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None


class ScheduleExecution(BaseCreateSchema):
    """
    Execute scheduled preventive maintenance.
    
    Records execution of scheduled maintenance with results
    and next occurrence scheduling.
    """

    schedule_id: UUID = Field(
        ...,
        description="Schedule unique identifier",
    )
    execution_date: date = Field(
        ...,
        description="Execution date",
    )
    executed_by: UUID = Field(
        ...,
        description="User who executed the maintenance",
    )
    completed: bool = Field(
        ...,
        description="Whether execution was completed successfully",
    )
    completion_notes: Optional[str] = Field(
        None,
        max_length=2000,
        description="Detailed completion notes",
    )
    actual_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Actual cost incurred",
    )
    actual_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        decimal_places=2,
        description="Actual time taken in hours",
    )
    checklist_results: List[ChecklistResult] = Field(
        default_factory=list,
        max_length=100,
        description="Results for each checklist item",
    )
    materials_used: Optional[List[dict]] = Field(
        None,
        max_length=100,
        description="Materials used in execution",
    )
    issues_found: Optional[str] = Field(
        None,
        max_length=1000,
        description="Issues or concerns identified",
    )
    recommendations: Optional[str] = Field(
        None,
        max_length=1000,
        description="Recommendations for future maintenance",
    )
    skip_next_occurrence: bool = Field(
        False,
        description="Skip the next scheduled occurrence",
    )
    reschedule_next_to: Optional[date] = Field(
        None,
        description="Reschedule next occurrence to specific date",
    )
    execution_photos: Optional[List[str]] = Field(
        None,
        max_length=20,
        description="Execution photographs",
    )

    @field_validator("execution_date")
    @classmethod
    def validate_execution_date(cls, v: date) -> date:
        """Validate execution date is not in future."""
        if v > date.today():
            raise ValueError("Execution date cannot be in the future")
        return v

    @field_validator("actual_cost", "actual_duration_hours")
    @classmethod
    def round_decimals(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round decimal values."""
        return round(v, 2) if v is not None else None

    @field_validator(
        "completion_notes",
        "issues_found",
        "recommendations",
    )
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_completion_requirements(self) -> "ScheduleExecution":
        """
        Validate completion information.
        
        Completed executions should have notes.
        """
        if self.completed and not self.completion_notes:
            raise ValueError(
                "Completion notes are required for completed executions"
            )
        
        return self

    @model_validator(mode="after")
    def validate_rescheduling(self) -> "ScheduleExecution":
        """
        Validate rescheduling logic.
        
        Can't both skip and reschedule next occurrence.
        """
        if self.skip_next_occurrence and self.reschedule_next_to:
            raise ValueError(
                "Cannot both skip and reschedule next occurrence"
            )
        
        if self.reschedule_next_to:
            # Rescheduled date should be in future
            if self.reschedule_next_to <= date.today():
                raise ValueError(
                    "Rescheduled date must be in the future"
                )
        
        return self


class ScheduleUpdate(BaseUpdateSchema):
    """
    Update preventive maintenance schedule.
    
    Allows modification of schedule parameters and status.
    """

    title: Optional[str] = Field(
        None,
        min_length=5,
        max_length=255,
        description="Updated title",
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Updated description",
    )
    recurrence: Optional[MaintenanceRecurrence] = Field(
        None,
        description="Updated recurrence pattern",
    )
    next_due_date: Optional[date] = Field(
        None,
        description="Updated next due date",
    )
    assigned_to: Optional[UUID] = Field(
        None,
        description="Updated default assignee",
    )
    estimated_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Updated estimated cost",
    )
    estimated_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        decimal_places=2,
        description="Updated estimated duration",
    )
    is_active: Optional[bool] = Field(
        None,
        description="Active status",
    )
    auto_create_requests: Optional[bool] = Field(
        None,
        description="Auto-create maintenance requests",
    )
    notification_days_before: Optional[int] = Field(
        None,
        ge=0,
        le=30,
        description="Notification days before due date",
    )
    priority_level: Optional[str] = Field(
        None,
        pattern=r"^(low|medium|high)$",
        description="Updated priority level",
    )

    @field_validator("title", "description")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @field_validator("estimated_cost", "estimated_duration_hours")
    @classmethod
    def round_decimals(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round decimal values."""
        return round(v, 2) if v is not None else None

    @field_validator("next_due_date")
    @classmethod
    def validate_due_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate next due date is reasonable."""
        if v is not None:
            # Should not be too far in past
            days_past = (date.today() - v).days
            if days_past > 30:
                raise ValueError(
                    "Next due date cannot be more than 30 days in the past"
                )
        return v


class ExecutionHistoryItem(BaseSchema):
    """
    Individual execution history record.
    
    Represents single execution in schedule history.
    """

    execution_id: UUID = Field(
        ...,
        description="Execution unique identifier",
    )
    execution_date: date = Field(
        ...,
        description="Execution date",
    )
    scheduled_date: date = Field(
        ...,
        description="Originally scheduled date",
    )
    executed_by: UUID = Field(
        ...,
        description="User who executed",
    )
    executed_by_name: str = Field(
        ...,
        description="Executor name",
    )
    completed: bool = Field(
        ...,
        description="Whether completed successfully",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="Completion timestamp",
    )
    actual_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Actual cost",
    )
    actual_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Actual duration",
    )
    completion_notes: Optional[str] = Field(
        None,
        description="Completion notes",
    )
    issues_found: Optional[str] = Field(
        None,
        description="Issues found",
    )
    was_on_time: bool = Field(
        ...,
        description="Whether executed on scheduled date",
    )
    days_delay: int = Field(
        default=0,
        description="Days delayed from scheduled date",
    )
    quality_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Quality rating for execution",
    )

    @computed_field
    @property
    def execution_status(self) -> str:
        """Get execution status summary."""
        if not self.completed:
            return "incomplete"
        elif self.was_on_time:
            return "on_time"
        else:
            return "delayed"


class ScheduleHistory(BaseSchema):
    """
    Complete execution history for schedule.
    
    Tracks all executions with statistics and trends.
    """

    schedule_id: UUID = Field(
        ...,
        description="Schedule unique identifier",
    )
    schedule_title: str = Field(
        ...,
        description="Schedule title",
    )
    schedule_code: Optional[str] = Field(
        None,
        description="Schedule code",
    )
    total_executions: int = Field(
        ...,
        ge=0,
        description="Total number of executions",
    )
    completed_executions: int = Field(
        ...,
        ge=0,
        description="Successfully completed executions",
    )
    skipped_executions: int = Field(
        ...,
        ge=0,
        description="Skipped executions",
    )
    delayed_executions: int = Field(
        default=0,
        ge=0,
        description="Delayed executions",
    )
    on_time_executions: int = Field(
        default=0,
        ge=0,
        description="On-time executions",
    )
    executions: List[ExecutionHistoryItem] = Field(
        ...,
        description="Chronological execution history",
    )
    total_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Total cost across all executions",
    )
    average_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average cost per execution",
    )
    average_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average execution duration",
    )
    average_quality_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average quality rating",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate percentage."""
        if self.total_executions == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.completed_executions) / Decimal(self.total_executions) * 100,
            2,
        )

    @computed_field
    @property
    def on_time_rate(self) -> Decimal:
        """Calculate on-time execution rate."""
        if self.completed_executions == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.on_time_executions) / Decimal(self.completed_executions) * 100,
            2,
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\maintenance\__init__.py ---
# --- File: app/schemas/maintenance/__init__.py ---
"""
Maintenance management schemas package.

Comprehensive maintenance request, scheduling, cost tracking, and analytics
schemas for hostel management system with enhanced validation and type safety.
"""

from __future__ import annotations

from app.schemas.maintenance.maintenance_analytics import (
    CategoryBreakdown,
    CostTrendPoint,
    MaintenanceAnalytics,
    PerformanceMetrics,
    ProductivityMetrics,
    TrendPoint,
    VendorPerformance,
)
from app.schemas.maintenance.maintenance_approval import (
    ApprovalRequest,
    ApprovalResponse,
    ApprovalWorkflow,
    RejectionRequest,
    ThresholdConfig,
)
from app.schemas.maintenance.maintenance_assignment import (
    AssignmentEntry,
    AssignmentHistory,
    AssignmentUpdate,
    BulkAssignment,
    TaskAssignment,
    VendorAssignment,
)
from app.schemas.maintenance.maintenance_base import (
    MaintenanceBase,
    MaintenanceCreate,
    MaintenanceStatusUpdate,
    MaintenanceUpdate,
)
from app.schemas.maintenance.maintenance_completion import (
    ChecklistItem,
    CompletionCertificate,
    CompletionRequest,
    CompletionResponse,
    MaterialItem,
    QualityCheck,
)
from app.schemas.maintenance.maintenance_cost import (
    BudgetAllocation,
    CategoryBudget,
    CostAnalysis,
    CostTracking,
    ExpenseItem,
    ExpenseReport,
    InvoiceLineItem,
    MonthlyExpense,
    VendorInvoice,
)
from app.schemas.maintenance.maintenance_filters import (
    AdvancedFilterParams,
    MaintenanceExportRequest,
    MaintenanceFilterParams,
    SearchRequest,
)
from app.schemas.maintenance.maintenance_request import (
    EmergencyRequest,
    MaintenanceRequest,
    RequestSubmission,
)
from app.schemas.maintenance.maintenance_response import (
    MaintenanceDetail,
    MaintenanceResponse,
    MaintenanceSummary,
    RequestListItem,
)
from app.schemas.maintenance.maintenance_schedule import (
    ChecklistResult,
    ExecutionHistoryItem,
    PreventiveSchedule,
    RecurrenceConfig,
    ScheduleChecklistItem,
    ScheduleCreate,
    ScheduleExecution,
    ScheduleHistory,
    ScheduleUpdate,
)

__all__ = [
    # Base schemas
    "MaintenanceBase",
    "MaintenanceCreate",
    "MaintenanceUpdate",
    "MaintenanceStatusUpdate",
    # Request schemas
    "MaintenanceRequest",
    "RequestSubmission",
    "EmergencyRequest",
    # Response schemas
    "MaintenanceResponse",
    "MaintenanceDetail",
    "RequestListItem",
    "MaintenanceSummary",
    # Assignment schemas
    "TaskAssignment",
    "VendorAssignment",
    "AssignmentUpdate",
    "BulkAssignment",
    "AssignmentEntry",
    "AssignmentHistory",
    # Approval schemas
    "ApprovalRequest",
    "ApprovalResponse",
    "ApprovalWorkflow",
    "RejectionRequest",
    "ThresholdConfig",
    # Completion schemas
    "CompletionRequest",
    "CompletionResponse",
    "CompletionCertificate",
    "MaterialItem",
    "QualityCheck",
    "ChecklistItem",
    # Schedule schemas
    "PreventiveSchedule",
    "ScheduleCreate",
    "ScheduleUpdate",
    "ScheduleChecklistItem",
    "RecurrenceConfig",
    "ScheduleExecution",
    "ChecklistResult",
    "ScheduleHistory",
    "ExecutionHistoryItem",
    # Cost schemas
    "CostTracking",
    "BudgetAllocation",
    "CategoryBudget",
    "ExpenseReport",
    "MonthlyExpense",
    "ExpenseItem",
    "VendorInvoice",
    "InvoiceLineItem",
    "CostAnalysis",
    # Filter schemas
    "MaintenanceFilterParams",
    "AdvancedFilterParams",
    "SearchRequest",
    "MaintenanceExportRequest",
    # Analytics schemas
    "MaintenanceAnalytics",
    "TrendPoint",
    "CostTrendPoint",
    "CategoryBreakdown",
    "VendorPerformance",
    "PerformanceMetrics",
    "ProductivityMetrics",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\mess =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\mess ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\mess =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\meal_items.py ---
"""
Meal items and dietary schemas
"""
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class MealItems(BaseSchema):
    """Meal items definition"""
    meal_type: str = Field(..., pattern="^(breakfast|lunch|snacks|dinner)$")
    items: List["MenuItem"]


class MenuItem(BaseSchema):
    """Individual menu item"""
    item_name: str = Field(..., min_length=2, max_length=100)
    item_description: Optional[str] = Field(None, max_length=255)
    
    # Dietary classification
    is_vegetarian: bool = Field(True)
    is_vegan: bool = Field(False)
    is_jain: bool = Field(False)
    is_gluten_free: bool = Field(False)
    
    # Allergens
    contains_dairy: bool = Field(False)
    contains_nuts: bool = Field(False)
    contains_soy: bool = Field(False)
    
    # Category
    category: str = Field(..., description="main_course, side_dish, dessert, beverage")


class DietaryOptions(BaseSchema):
    """Dietary options configuration"""
    hostel_id: UUID
    
    # Available options
    vegetarian_menu: bool = Field(True)
    non_vegetarian_menu: bool = Field(False)
    vegan_menu: bool = Field(False)
    jain_menu: bool = Field(False)
    gluten_free_options: bool = Field(False)
    
    # Customization allowed
    allow_meal_customization: bool = Field(False)
    
    # Allergen warnings
    display_allergen_warnings: bool = Field(True)


class NutritionalInfo(BaseSchema):
    """Nutritional information for menu item"""
    item_name: str
    
    # Per serving
    serving_size: str
    calories: Optional[int] = Field(None, ge=0)
    
    # Macros (grams)
    protein: Optional[Decimal] = Field(None, ge=0)
    carbohydrates: Optional[Decimal] = Field(None, ge=0)
    fat: Optional[Decimal] = Field(None, ge=0)
    fiber: Optional[Decimal] = Field(None, ge=0)
    
    # Micros
    sodium_mg: Optional[Decimal] = Field(None, ge=0)
    sugar_g: Optional[Decimal] = Field(None, ge=0)


class ItemMasterList(BaseSchema):
    """Master list of menu items"""
    hostel_id: UUID
    
    categories: List["ItemCategory"]


class ItemCategory(BaseSchema):
    """Category of menu items"""
    category_name: str
    items: List[str]

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\menu_approval.py ---
"""
Menu approval schemas
"""
from datetime import datetime
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class MenuApprovalRequest(BaseCreateSchema):
    """Request menu approval (supervisor to admin)"""
    menu_id: UUID
    
    # Submission notes
    submission_notes: Optional[str] = Field(None, max_length=500)
    
    # Budget info
    estimated_cost_per_person: Optional[Decimal] = None


class MenuApprovalResponse(BaseSchema):
    """Menu approval response"""
    menu_id: UUID
    menu_date: date
    
    approved: bool
    approved_by: UUID
    approved_by_name: str
    approved_at: datetime
    
    # Feedback
    approval_notes: Optional[str]
    
    message: str


class ApprovalWorkflow(BaseSchema):
    """Menu approval workflow status"""
    menu_id: UUID
    menu_date: date
    
    requires_approval: bool
    approval_status: str = Field(
        ...,
        pattern="^(pending|approved|rejected|not_required)$"
    )
    
    # Timeline
    submitted_for_approval_at: Optional[datetime]
    approved_at: Optional[datetime]
    rejected_at: Optional[datetime]
    
    # Approver
    pending_with: Optional[UUID]
    pending_with_name: Optional[str]


class BulkApproval(BaseCreateSchema):
    """Approve multiple menus"""
    menu_ids: List[UUID] = Field(..., min_items=1)
    
    approved: bool
    approval_notes: Optional[str] = None

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\menu_duplication.py ---
"""
Menu duplication schemas
"""
from datetime import date
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class DuplicateMenuRequest(BaseCreateSchema):
    """Duplicate menu to another date"""
    source_menu_id: UUID = Field(..., description="Menu to duplicate")
    target_date: date = Field(..., description="Date for duplicated menu")
    
    # Modifications
    modify_items: bool = Field(False, description="Allow modifications during duplication")
    modifications: Optional[dict] = None


class BulkMenuCreate(BaseCreateSchema):
    """Create menus for multiple dates using template"""
    hostel_id: UUID
    
    # Date range
    start_date: date
    end_date: date
    
    # Source
    source_type: str = Field(..., pattern="^(template|existing_menu|weekly_pattern)$")
    
    # If using template
    template_id: Optional[UUID] = None
    
    # If using existing menu
    source_menu_id: Optional[UUID] = None
    
    # If using weekly pattern
    weekly_pattern: Optional[dict] = Field(
        None,
        description="Day of week -> menu items mapping"
    )
    
    # Options
    skip_existing: bool = Field(True, description="Skip dates that already have menus")
    override_existing: bool = Field(False, description="Override existing menus")


class DuplicateResponse(BaseSchema):
    """Duplication response"""
    source_menu_id: UUID
    created_menus: List[UUID]
    
    total_created: int
    skipped: int
    
    message: str


class CrossHostelDuplication(BaseCreateSchema):
    """Duplicate menu to other hostels"""
    source_menu_id: UUID
    source_hostel_id: UUID
    
    target_hostel_ids: List[UUID] = Field(..., min_items=1)
    target_date: date
    
    # Adjust for hostel-specific preferences
    adapt_to_hostel_preferences: bool = Field(True)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\menu_feedback.py ---
"""
Mess menu feedback schemas
"""
from datetime import datetime, date
from decimal import Decimal
from typing import List, Optional, Dict
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema
from app.schemas.common.enums import MealType


class FeedbackRequest(BaseCreateSchema):
    """Submit menu feedback"""
    menu_id: UUID = Field(..., description="Menu ID")
    student_id: UUID = Field(..., description="Student ID")
    
    meal_type: MealType = Field(..., description="Which meal")
    rating: int = Field(..., ge=1, le=5, description="Rating 1-5")
    
    comments: Optional[str] = Field(None, max_length=1000)
    
    # Specific aspects
    taste_rating: Optional[int] = Field(None, ge=1, le=5)
    quantity_rating: Optional[int] = Field(None, ge=1, le=5)
    quality_rating: Optional[int] = Field(None, ge=1, le=5)
    hygiene_rating: Optional[int] = Field(None, ge=1, le=5)


class FeedbackResponse(BaseResponseSchema):
    """Feedback response"""
    menu_id: UUID
    student_id: UUID
    student_name: str
    
    meal_type: MealType
    rating: int
    comments: Optional[str]
    
    submitted_at: datetime


class RatingsSummary(BaseSchema):
    """Ratings summary for menu"""
    menu_id: UUID
    menu_date: date
    
    total_feedbacks: int
    average_rating: Decimal
    
    # By meal
    breakfast_rating: Optional[Decimal]
    lunch_rating: Optional[Decimal]
    snacks_rating: Optional[Decimal]
    dinner_rating: Optional[Decimal]
    
    # Rating distribution
    rating_5_count: int
    rating_4_count: int
    rating_3_count: int
    rating_2_count: int
    rating_1_count: int
    
    # Aspect ratings
    average_taste_rating: Decimal
    average_quantity_rating: Decimal
    average_quality_rating: Decimal
    average_hygiene_rating: Decimal


class QualityMetrics(BaseSchema):
    """Menu quality metrics"""
    hostel_id: UUID
    period_start: date
    period_end: date
    
    # Overall
    overall_average_rating: Decimal
    total_feedbacks: int
    
    # Trends
    rating_trend: str = Field(..., pattern="^(improving|declining|stable)$")
    trend_percentage: Optional[Decimal]
    
    # Best and worst
    best_rated_items: List["ItemRating"]
    worst_rated_items: List["ItemRating"]
    
    # By day of week
    ratings_by_day: Dict[str, Decimal]


class ItemRating(BaseSchema):
    """Rating for specific menu item"""
    item_name: str
    average_rating: Decimal
    feedback_count: int


class FeedbackAnalysis(BaseSchema):
    """Feedback analysis and insights"""
    hostel_id: UUID
    analysis_period: DateRangeFilter
    
    # Sentiment
    positive_feedback_percentage: Decimal
    negative_feedback_percentage: Decimal
    
    # Common themes
    common_complaints: List[str]
    common_compliments: List[str]
    
    # Recommendations
    items_to_keep: List[str]
    items_to_improve: List[str]
    items_to_remove: List[str]

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\menu_planning.py ---
"""
Menu planning schemas
"""
from datetime import date
from typing import List, Optional, Dict
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class MenuPlanRequest(BaseCreateSchema):
    """Request to create menu plan"""
    hostel_id: UUID
    
    # Planning period
    start_date: date
    end_date: date
    
    # Template to use (if any)
    use_template: bool = Field(False)
    template_id: Optional[UUID] = None
    
    # Variety preferences
    ensure_variety: bool = Field(True, description="Avoid repeating items too often")
    min_days_between_repeat: int = Field(3, ge=1, le=7)
    
    # Dietary requirements
    vegetarian_days_per_week: int = Field(7, ge=0, le=7)
    
    # Budget
    target_cost_per_day: Optional[Decimal] = None


class WeeklyPlan(BaseCreateSchema):
    """Weekly menu plan"""
    hostel_id: UUID
    week_start_date: date
    
    # Daily menus
    monday: "DailyMenuPlan"
    tuesday: "DailyMenuPlan"
    wednesday: "DailyMenuPlan"
    thursday: "DailyMenuPlan"
    friday: "DailyMenuPlan"
    saturday: "DailyMenuPlan"
    sunday: "DailyMenuPlan"
    
    # Metadata
    created_by: UUID
    notes: Optional[str] = None


class DailyMenuPlan(BaseSchema):
    """Daily menu plan"""
    breakfast: List[str]
    lunch: List[str]
    snacks: List[str]
    dinner: List[str]
    
    is_special: bool = Field(False)
    special_occasion: Optional[str] = None


class MonthlyPlan(BaseCreateSchema):
    """Monthly menu plan"""
    hostel_id: UUID
    month: str  # YYYY-MM format
    
    # Weekly plans
    weeks: List[WeeklyPlan]
    
    # Special days
    special_days: List["SpecialDayMenu"] = Field(default_factory=list)


class SpecialMenu(BaseCreateSchema):
    """Special occasion menu"""
    hostel_id: UUID
    occasion_date: date
    occasion_name: str = Field(..., min_length=3, max_length=255)
    
    # Enhanced menu
    breakfast: List[str]
    lunch: List[str]
    snacks: List[str]
    dinner: List[str]
    
    # Additional items
    special_items: List[str] = Field(default_factory=list, description="Extra special items")
    
    # Budget
    budget: Optional[Decimal] = None


class SpecialDayMenu(BaseSchema):
    """Special day in monthly plan"""
    date: date
    occasion: str
    menu: DailyMenuPlan


class MenuTemplate(BaseCreateSchema):
    """Reusable menu template"""
    hostel_id: UUID
    template_name: str = Field(..., min_length=3, max_length=100)
    description: Optional[str] = None
    
    # Template type
    template_type: str = Field(..., pattern="^(weekly|festival|summer|winter)$")
    
    # Menu structure
    daily_menus: Dict[str, DailyMenuPlan] = Field(
        ...,
        description="Day name -> menu plan"
    )


class MenuSuggestion(BaseSchema):
    """AI/System generated menu suggestions"""
    hostel_id: UUID
    date: date
    
    suggested_breakfast: List[str]
    suggested_lunch: List[str]
    suggested_dinner: List[str]
    
    reason: str = Field(..., description="Why these items are suggested")
    
    # Scores
    variety_score: Decimal = Field(..., ge=0, le=10)
    nutrition_score: Decimal = Field(..., ge=0, le=10)
    cost_score: Decimal = Field(..., ge=0, le=10)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\mess_menu_base.py ---
"""
Mess menu base schemas
"""
from datetime import date, time
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseUpdateSchema, BaseSchema


class MessMenuBase(BaseSchema):
    """Base mess menu schema"""
    hostel_id: UUID = Field(..., description="Hostel ID")
    menu_date: date = Field(..., description="Menu date")
    day_of_week: str = Field(..., description="Day of week")
    
    # Meals
    breakfast_items: List[str] = Field(default_factory=list, description="Breakfast items")
    lunch_items: List[str] = Field(default_factory=list, description="Lunch items")
    snacks_items: List[str] = Field(default_factory=list, description="Snacks items")
    dinner_items: List[str] = Field(default_factory=list, description="Dinner items")
    
    # Timings
    breakfast_time: Optional[time] = Field(None, description="Breakfast serving time")
    lunch_time: Optional[time] = Field(None, description="Lunch serving time")
    snacks_time: Optional[time] = Field(None, description="Snacks serving time")
    dinner_time: Optional[time] = Field(None, description="Dinner serving time")
    
    # Special
    is_special_menu: bool = Field(False, description="Special occasion menu")
    special_occasion: Optional[str] = Field(None, max_length=255, description="Occasion name")
    
    # Dietary options
    vegetarian_available: bool = Field(True)
    non_vegetarian_available: bool = Field(False)
    vegan_available: bool = Field(False)
    jain_available: bool = Field(False)


class MessMenuCreate(MessMenuBase, BaseCreateSchema):
    """Create mess menu"""
    created_by: UUID = Field(..., description="Supervisor/Admin who created")


class MessMenuUpdate(BaseUpdateSchema):
    """Update mess menu"""
    breakfast_items: Optional[List[str]] = None
    lunch_items: Optional[List[str]] = None
    snacks_items: Optional[List[str]] = None
    dinner_items: Optional[List[str]] = None
    
    breakfast_time: Optional[time] = None
    lunch_time: Optional[time] = None
    snacks_time: Optional[time] = None
    dinner_time: Optional[time] = None
    
    is_special_menu: Optional[bool] = None
    special_occasion: Optional[str] = None
    
    vegetarian_available: Optional[bool] = None
    non_vegetarian_available: Optional[bool] = None

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\mess_menu_response.py ---
"""
Mess menu response schemas
"""
from datetime import date, time, datetime
from decimal import Decimal
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema


class MenuResponse(BaseResponseSchema):
    """Mess menu response"""
    hostel_id: UUID
    hostel_name: str
    menu_date: date
    day_of_week: str
    
    breakfast_items: List[str]
    lunch_items: List[str]
    snacks_items: List[str]
    dinner_items: List[str]
    
    is_special_menu: bool
    special_occasion: Optional[str]
    
    is_published: bool
    average_rating: Decimal


class MenuDetail(BaseResponseSchema):
    """Detailed menu information"""
    hostel_id: UUID
    hostel_name: str
    menu_date: date
    day_of_week: str
    
    # Meals with timings
    breakfast_items: List[str]
    breakfast_time: Optional[time]
    
    lunch_items: List[str]
    lunch_time: Optional[time]
    
    snacks_items: List[str]
    snacks_time: Optional[time]
    
    dinner_items: List[str]
    dinner_time: Optional[time]
    
    # Dietary options
    vegetarian_available: bool
    non_vegetarian_available: bool
    vegan_available: bool
    jain_available: bool
    
    # Special
    is_special_menu: bool
    special_occasion: Optional[str]
    
    # Management
    created_by: UUID
    created_by_name: str
    approved_by: Optional[UUID]
    approved_by_name: Optional[str]
    approved_at: Optional[datetime]
    
    is_published: bool
    published_at: Optional[datetime]
    
    # Feedback
    average_rating: Decimal
    total_feedback_count: int


class WeeklyMenu(BaseSchema):
    """Weekly menu display"""
    hostel_id: UUID
    hostel_name: str
    week_start_date: date
    week_end_date: date
    
    menus: List["DailyMenuSummary"]


class DailyMenuSummary(BaseSchema):
    """Daily menu summary for weekly view"""
    menu_id: UUID
    date: date
    day_of_week: str
    
    breakfast: List[str]
    lunch: List[str]
    dinner: List[str]
    
    is_special: bool
    average_rating: Optional[Decimal]


class MonthlyMenu(BaseSchema):
    """Monthly menu calendar"""
    hostel_id: UUID
    hostel_name: str
    month: str  # YYYY-MM format
    
    menus_by_date: dict = Field(..., description="Date -> DailyMenuSummary")
    
    # Summary
    total_days: int
    special_days: int
    average_rating: Decimal


class TodayMenu(BaseSchema):
    """Today's menu for student view"""
    hostel_id: UUID
    hostel_name: str
    date: date
    day_of_week: str
    
    breakfast: List[str]
    breakfast_time: str
    
    lunch: List[str]
    lunch_time: str
    
    snacks: List[str]
    snacks_time: str
    
    dinner: List[str]
    dinner_time: str
    
    is_special: bool
    special_occasion: Optional[str]
    
    dietary_note: Optional[str]

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\__init__.py ---
"""
Mess menu schemas package
"""
from app.schemas.mess.mess_menu_base import (
    MessMenuBase,
    MessMenuCreate,
    MessMenuUpdate
)
from app.schemas.mess.mess_menu_response import (
    MenuResponse,
    MenuDetail,
    WeeklyMenu,
    MonthlyMenu
)
from app.schemas.mess.meal_items import (
    MealItems,
    DietaryOptions,
    NutritionalInfo
)
from app.schemas.mess.menu_planning import (
    MenuPlanRequest,
    WeeklyPlan,
    MonthlyPlan,
    SpecialMenu
)
from app.schemas.mess.menu_feedback import (
    FeedbackRequest,
    FeedbackResponse,
    RatingsSummary,
    QualityMetrics
)
from app.schemas.mess.menu_approval import (
    MenuApprovalRequest,
    ApprovalWorkflow
)
from app.schemas.mess.menu_duplication import (
    DuplicateMenuRequest,
    BulkMenuCreate
)

__all__ = [
    # Base
    "MessMenuBase",
    "MessMenuCreate",
    "MessMenuUpdate",
    
    # Response
    "MenuResponse",
    "MenuDetail",
    "WeeklyMenu",
    "MonthlyMenu",
    
    # Meal Items
    "MealItems",
    "DietaryOptions",
    "NutritionalInfo",
    
    # Planning
    "MenuPlanRequest",
    "WeeklyPlan",
    "MonthlyPlan",
    "SpecialMenu",
    
    # Feedback
    "FeedbackRequest",
    "FeedbackResponse",
    "RatingsSummary",
    "QualityMetrics",
    
    # Approval
    "MenuApprovalRequest",
    "ApprovalWorkflow",
    
    # Duplication
    "DuplicateMenuRequest",
    "BulkMenuCreate",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\meal_items.py ---
# --- File: app/schemas/mess/meal_items.py ---
"""
Meal items, dietary preferences, and nutritional information schemas.

Provides comprehensive schemas for menu item definitions, dietary classifications,
allergen tracking, and nutritional data management.
"""

from __future__ import annotations

from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import DietaryPreference, MealType

__all__ = [
    "MealItems",
    "MenuItem",
    "DietaryOptions",
    "NutritionalInfo",
    "ItemMasterList",
    "ItemCategory",
    "AllergenInfo",
]


class MenuItem(BaseSchema):
    """
    Individual menu item with dietary and allergen information.
    
    Represents a single dish/food item with complete classification
    for dietary preferences and allergen warnings.
    """

    item_id: Optional[str] = Field(
        None,
        max_length=50,
        description="Unique item identifier/code",
    )
    item_name: str = Field(
        ...,
        min_length=2,
        max_length=100,
        description="Menu item name",
    )
    item_name_local: Optional[str] = Field(
        None,
        max_length=100,
        description="Item name in local language",
    )
    item_description: Optional[str] = Field(
        None,
        max_length=255,
        description="Brief item description",
    )

    # Category and type
    category: str = Field(
        ...,
        pattern=r"^(main_course|side_dish|bread|rice|dal|curry|dessert|beverage|salad|soup|starter)$",
        description="Item category",
    )
    meal_type: Optional[MealType] = Field(
        None,
        description="Typical meal type for this item",
    )

    # Dietary classification
    is_vegetarian: bool = Field(
        True,
        description="Suitable for vegetarians",
    )
    is_vegan: bool = Field(
        False,
        description="Suitable for vegans (no animal products)",
    )
    is_jain: bool = Field(
        False,
        description="Suitable for Jain diet (no root vegetables, etc.)",
    )
    is_gluten_free: bool = Field(
        False,
        description="Gluten-free item",
    )
    is_lactose_free: bool = Field(
        False,
        description="Lactose-free item",
    )

    # Common allergen flags
    contains_dairy: bool = Field(
        False,
        description="Contains dairy products",
    )
    contains_nuts: bool = Field(
        False,
        description="Contains tree nuts or peanuts",
    )
    contains_soy: bool = Field(
        False,
        description="Contains soy",
    )
    contains_gluten: bool = Field(
        False,
        description="Contains gluten (wheat, barley, rye)",
    )
    contains_eggs: bool = Field(
        False,
        description="Contains eggs",
    )
    contains_shellfish: bool = Field(
        False,
        description="Contains shellfish",
    )

    # Additional properties
    is_spicy: bool = Field(
        False,
        description="Spicy food item",
    )
    spice_level: Optional[int] = Field(
        None,
        ge=0,
        le=5,
        description="Spice level (0-5, 0=mild, 5=very spicy)",
    )
    is_popular: bool = Field(
        False,
        description="Popular/frequently requested item",
    )
    is_seasonal: bool = Field(
        False,
        description="Seasonal availability",
    )
    serving_size: Optional[str] = Field(
        None,
        max_length=50,
        description="Standard serving size description",
    )

    @field_validator("item_name", "item_name_local", "item_description")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_dietary_consistency(self) -> "MenuItem":
        """
        Validate dietary classification consistency.
        
        Ensures logical consistency between dietary flags and allergen flags.
        """
        # Vegan items must be vegetarian
        if self.is_vegan and not self.is_vegetarian:
            raise ValueError("Vegan items must also be vegetarian")
        
        # Vegan items cannot contain dairy or eggs
        if self.is_vegan:
            if self.contains_dairy:
                raise ValueError("Vegan items cannot contain dairy")
            if self.contains_eggs:
                raise ValueError("Vegan items cannot contain eggs")
        
        # Jain items must be vegetarian
        if self.is_jain and not self.is_vegetarian:
            raise ValueError("Jain items must be vegetarian")
        
        # Gluten-free items shouldn't contain gluten
        if self.is_gluten_free and self.contains_gluten:
            raise ValueError(
                "Item marked as gluten-free cannot contain gluten"
            )
        
        # Lactose-free items shouldn't contain dairy
        if self.is_lactose_free and self.contains_dairy:
            raise ValueError(
                "Lactose-free items should not contain dairy"
            )
        
        return self

    @model_validator(mode="after")
    def validate_spice_level(self) -> "MenuItem":
        """Validate spice level consistency."""
        if self.is_spicy and self.spice_level is None:
            # Default to medium spice if marked as spicy
            self.spice_level = 3
        
        if not self.is_spicy and self.spice_level and self.spice_level > 0:
            # If spice level is set, item should be marked as spicy
            self.is_spicy = True
        
        return self


class MealItems(BaseSchema):
    """
    Collection of menu items for a specific meal type.
    
    Groups items by meal with complete item information.
    """

    meal_type: MealType = Field(
        ...,
        description="Type of meal",
    )
    meal_name: Optional[str] = Field(
        None,
        description="Custom meal name (e.g., 'Continental Breakfast')",
    )
    items: List[MenuItem] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of menu items for this meal",
    )
    serving_start_time: Optional[time] = Field(
        None,
        description="Meal serving start time",
    )
    serving_end_time: Optional[time] = Field(
        None,
        description="Meal serving end time",
    )

    @field_validator("items")
    @classmethod
    def validate_unique_items(cls, v: List[MenuItem]) -> List[MenuItem]:
        """Ensure no duplicate item names in the meal."""
        item_names = [item.item_name.lower() for item in v]
        
        if len(item_names) != len(set(item_names)):
            raise ValueError("Duplicate items found in meal")
        
        return v


class DietaryOptions(BaseSchema):
    """
    Dietary options configuration for hostel mess.
    
    Defines available dietary preferences and customization settings.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )

    # Available dietary options
    vegetarian_menu: bool = Field(
        True,
        description="Vegetarian menu available",
    )
    non_vegetarian_menu: bool = Field(
        False,
        description="Non-vegetarian menu available",
    )
    vegan_menu: bool = Field(
        False,
        description="Vegan menu available",
    )
    jain_menu: bool = Field(
        False,
        description="Jain dietary menu available",
    )
    gluten_free_options: bool = Field(
        False,
        description="Gluten-free options available",
    )
    lactose_free_options: bool = Field(
        False,
        description="Lactose-free options available",
    )

    # Customization settings
    allow_meal_customization: bool = Field(
        False,
        description="Allow students to customize meals",
    )
    allow_special_requests: bool = Field(
        False,
        description="Accept special dietary requests",
    )
    advance_notice_required_days: int = Field(
        default=1,
        ge=0,
        le=7,
        description="Days advance notice required for special requests",
    )

    # Allergen management
    display_allergen_warnings: bool = Field(
        True,
        description="Display allergen information on menus",
    )
    mandatory_allergen_declaration: bool = Field(
        True,
        description="Require allergen declaration for all items",
    )

    # Dietary preference tracking
    track_student_preferences: bool = Field(
        default=True,
        description="Track and remember student dietary preferences",
    )
    auto_suggest_menu: bool = Field(
        default=False,
        description="Auto-suggest menu based on preferences",
    )

    @model_validator(mode="after")
    def validate_menu_availability(self) -> "DietaryOptions":
        """Ensure at least one menu type is available."""
        if not any([
            self.vegetarian_menu,
            self.non_vegetarian_menu,
            self.vegan_menu,
            self.jain_menu,
        ]):
            raise ValueError("At least one menu type must be available")
        
        return self


class AllergenInfo(BaseSchema):
    """
    Detailed allergen information for menu item.
    
    Provides comprehensive allergen tracking with severity levels.
    """

    item_name: str = Field(
        ...,
        description="Menu item name",
    )
    allergen_name: str = Field(
        ...,
        description="Allergen name",
    )
    allergen_type: str = Field(
        ...,
        pattern=r"^(dairy|nuts|soy|gluten|eggs|shellfish|fish|sesame|mustard|celery|other)$",
        description="Allergen category",
    )
    severity: str = Field(
        ...,
        pattern=r"^(trace|contains|may_contain)$",
        description="Allergen presence level",
    )
    details: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional allergen details",
    )


class NutritionalInfo(BaseSchema):
    """
    Nutritional information for menu item.
    
    Provides macros, micros, and calorie information per serving.
    """

    item_name: str = Field(
        ...,
        description="Menu item name",
    )
    item_id: Optional[str] = Field(
        None,
        description="Item identifier",
    )

    # Serving information
    serving_size: str = Field(
        ...,
        max_length=50,
        description="Serving size description (e.g., '1 cup', '150g')",
    )
    servings_per_container: Optional[int] = Field(
        None,
        ge=1,
        description="Number of servings in container",
    )

    # Calories
    calories: Optional[int] = Field(
        None,
        ge=0,
        le=10000,
        description="Calories per serving",
    )
    calories_from_fat: Optional[int] = Field(
        None,
        ge=0,
        description="Calories from fat",
    )

    # Macronutrients (grams)
    protein_g: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        decimal_places=2,
        description="Protein in grams",
    )
    carbohydrates_g: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        decimal_places=2,
        description="Carbohydrates in grams",
    )
    fat_g: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        decimal_places=2,
        description="Total fat in grams",
    )
    saturated_fat_g: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Saturated fat in grams",
    )
    trans_fat_g: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Trans fat in grams",
    )
    fiber_g: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Dietary fiber in grams",
    )

    # Micronutrients
    sodium_mg: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Sodium in milligrams",
    )
    sugar_g: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Total sugars in grams",
    )
    cholesterol_mg: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Cholesterol in milligrams",
    )
    potassium_mg: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Potassium in milligrams",
    )

    # Vitamins and minerals (% daily value)
    vitamin_a_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        description="Vitamin A % daily value",
    )
    vitamin_c_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        description="Vitamin C % daily value",
    )
    calcium_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        description="Calcium % daily value",
    )
    iron_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        description="Iron % daily value",
    )

    # Additional info
    ingredients: Optional[str] = Field(
        None,
        max_length=1000,
        description="List of ingredients",
    )
    preparation_method: Optional[str] = Field(
        None,
        max_length=500,
        description="Preparation method",
    )

    @field_validator("serving_size")
    @classmethod
    def normalize_serving_size(cls, v: str) -> str:
        """Normalize serving size description."""
        return v.strip()

    @model_validator(mode="after")
    def validate_nutritional_data(self) -> "NutritionalInfo":
        """Validate nutritional data consistency."""
        # Calories from fat shouldn't exceed total calories
        if self.calories and self.calories_from_fat:
            if self.calories_from_fat > self.calories:
                raise ValueError(
                    "Calories from fat cannot exceed total calories"
                )
        
        # Saturated and trans fat shouldn't exceed total fat
        if self.fat_g:
            total_specific_fats = Decimal("0.00")
            
            if self.saturated_fat_g:
                total_specific_fats += self.saturated_fat_g
            if self.trans_fat_g:
                total_specific_fats += self.trans_fat_g
            
            if total_specific_fats > self.fat_g:
                raise ValueError(
                    "Saturated + trans fat cannot exceed total fat"
                )
        
        return self


class ItemCategory(BaseSchema):
    """
    Category of menu items for organization.
    
    Groups related items for easier menu planning.
    """

    category_id: Optional[str] = Field(
        None,
        max_length=50,
        description="Category identifier",
    )
    category_name: str = Field(
        ...,
        min_length=2,
        max_length=100,
        description="Category name",
    )
    category_description: Optional[str] = Field(
        None,
        max_length=255,
        description="Category description",
    )
    items: List[str] = Field(
        ...,
        min_length=1,
        max_length=200,
        description="Item names in this category",
    )
    display_order: int = Field(
        default=0,
        ge=0,
        description="Display order for category",
    )
    is_active: bool = Field(
        default=True,
        description="Whether category is active",
    )


class ItemMasterList(BaseSchema):
    """
    Master list of all available menu items.
    
    Central repository of items organized by categories for
    a hostel's menu planning.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    list_name: Optional[str] = Field(
        None,
        description="Master list name/version",
    )
    categories: List[ItemCategory] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Item categories",
    )
    total_items: int = Field(
        default=0,
        ge=0,
        description="Total number of items across all categories",
    )
    last_updated: Optional[datetime] = Field(
        None,
        description="Last update timestamp",
    )

    @model_validator(mode="after")
    def calculate_total_items(self) -> "ItemMasterList":
        """Calculate total items across all categories."""
        total = sum(len(category.items) for category in self.categories)
        self.total_items = total
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\menu_approval.py ---
# --- File: app/schemas/mess/menu_approval.py ---
"""
Menu approval workflow schemas.

Provides schemas for menu approval requests, responses,
and workflow tracking with comprehensive validation.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "MenuApprovalRequest",
    "MenuApprovalResponse",
    "ApprovalWorkflow",
    "BulkApproval",
    "ApprovalHistory",
]


class MenuApprovalRequest(BaseCreateSchema):
    """
    Request menu approval from supervisor to admin.
    
    Submits menu for review with cost estimates and justification.
    """

    menu_id: UUID = Field(
        ...,
        description="Menu unique identifier",
    )
    requested_by: UUID = Field(
        ...,
        description="Supervisor requesting approval",
    )
    
    # Submission details
    submission_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Notes for approver",
    )
    urgency: str = Field(
        default="normal",
        pattern=r"^(low|normal|high|urgent)$",
        description="Approval urgency level",
    )
    
    # Budget information
    estimated_cost_per_person: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Estimated cost per person",
    )
    total_estimated_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total estimated cost",
    )
    expected_students: Optional[int] = Field(
        None,
        ge=1,
        le=10000,
        description="Expected number of students",
    )
    
    # Special requirements
    requires_special_procurement: bool = Field(
        default=False,
        description="Requires special ingredient procurement",
    )
    special_items: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Special items requiring approval",
    )
    
    # Justification
    reason_for_special_menu: Optional[str] = Field(
        None,
        max_length=1000,
        description="Justification for special/expensive menu",
    )

    @field_validator("submission_notes", "reason_for_special_menu")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_cost_information(self) -> "MenuApprovalRequest":
        """
        Validate cost information consistency.
        
        If per-person cost is high, justification should be provided.
        """
        if self.estimated_cost_per_person:
            # If cost is above threshold (e.g., 100), require justification
            if self.estimated_cost_per_person > Decimal("100.00"):
                if not self.reason_for_special_menu:
                    raise ValueError(
                        "Justification required for high per-person cost"
                    )
        
        # Validate total cost calculation
        if (
            self.estimated_cost_per_person
            and self.expected_students
            and self.total_estimated_cost
        ):
            calculated_total = (
                self.estimated_cost_per_person * Decimal(self.expected_students)
            )
            
            # Allow 10% variance
            variance = abs(calculated_total - self.total_estimated_cost)
            max_variance = calculated_total * Decimal("0.1")
            
            if variance > max_variance:
                raise ValueError(
                    "Total estimated cost doesn't match per-person cost calculation"
                )
        
        return self


class MenuApprovalResponse(BaseSchema):
    """
    Menu approval decision response.
    
    Provides complete information about approval or rejection decision.
    """

    menu_id: UUID = Field(
        ...,
        description="Menu unique identifier",
    )
    menu_date: date = Field(
        ...,
        description="Menu date",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    
    # Decision
    approved: bool = Field(
        ...,
        description="Whether menu was approved",
    )
    approval_status: str = Field(
        ...,
        pattern=r"^(approved|rejected|approved_with_conditions|pending_revision)$",
        description="Approval status",
    )
    
    # Approver details
    approved_by: UUID = Field(
        ...,
        description="Approver user ID",
    )
    approved_by_name: str = Field(
        ...,
        description="Approver full name",
    )
    approved_by_role: str = Field(
        ...,
        description="Approver role",
    )
    approved_at: datetime = Field(
        ...,
        description="Approval timestamp",
    )
    
    # Feedback and conditions
    approval_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Approver's notes",
    )
    conditions: Optional[str] = Field(
        None,
        max_length=500,
        description="Conditions for approval (if any)",
    )
    rejection_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for rejection",
    )
    suggested_changes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Suggested modifications",
    )
    
    # Cost approval
    approved_budget: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Approved budget amount",
    )
    budget_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Notes about budget approval",
    )
    
    # Response message
    message: str = Field(
        ...,
        description="Human-readable response message",
    )
    
    # Next steps
    requires_resubmission: bool = Field(
        default=False,
        description="Whether resubmission is required",
    )
    can_publish: bool = Field(
        ...,
        description="Whether menu can be published",
    )

    @model_validator(mode="after")
    def validate_response_consistency(self) -> "MenuApprovalResponse":
        """Validate approval response consistency."""
        if self.approved:
            # Approved menus shouldn't have rejection reason
            if self.rejection_reason:
                raise ValueError(
                    "Rejection reason should not be present for approved menus"
                )
        else:
            # Rejected menus must have rejection reason
            if not self.rejection_reason:
                raise ValueError(
                    "Rejection reason is required for rejected menus"
                )
        
        return self


class ApprovalWorkflow(BaseSchema):
    """
    Menu approval workflow status tracking.
    
    Tracks current state of approval process with timeline.
    """

    menu_id: UUID = Field(
        ...,
        description="Menu unique identifier",
    )
    menu_date: date = Field(
        ...,
        description="Menu date",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    
    # Workflow status
    requires_approval: bool = Field(
        ...,
        description="Whether approval is required",
    )
    approval_status: str = Field(
        ...,
        pattern=r"^(pending|approved|rejected|not_required|revision_requested)$",
        description="Current approval status",
    )
    
    # Workflow stage
    current_stage: str = Field(
        ...,
        pattern=r"^(draft|submitted|under_review|approved|rejected|published)$",
        description="Current workflow stage",
    )
    
    # Timeline
    created_at: datetime = Field(
        ...,
        description="Menu creation timestamp",
    )
    submitted_for_approval_at: Optional[datetime] = Field(
        None,
        description="Submission timestamp",
    )
    approved_at: Optional[datetime] = Field(
        None,
        description="Approval timestamp",
    )
    rejected_at: Optional[datetime] = Field(
        None,
        description="Rejection timestamp",
    )
    published_at: Optional[datetime] = Field(
        None,
        description="Publication timestamp",
    )
    
    # Current approver
    pending_with: Optional[UUID] = Field(
        None,
        description="User ID of current approver",
    )
    pending_with_name: Optional[str] = Field(
        None,
        description="Name of current approver",
    )
    pending_with_role: Optional[str] = Field(
        None,
        description="Role of current approver",
    )
    
    # Deadlines
    approval_deadline: Optional[datetime] = Field(
        None,
        description="Approval deadline",
    )
    is_overdue: bool = Field(
        default=False,
        description="Whether approval is overdue",
    )
    
    # Revision tracking
    revision_count: int = Field(
        default=0,
        ge=0,
        description="Number of revisions made",
    )
    last_revision_at: Optional[datetime] = Field(
        None,
        description="Last revision timestamp",
    )

    @computed_field
    @property
    def days_pending(self) -> Optional[int]:
        """Calculate days approval has been pending."""
        if self.submitted_for_approval_at and self.approval_status == "pending":
            return (datetime.now() - self.submitted_for_approval_at).days
        return None

    @computed_field
    @property
    def time_to_approval_hours(self) -> Optional[Decimal]:
        """Calculate hours taken for approval."""
        if self.submitted_for_approval_at and self.approved_at:
            hours = (self.approved_at - self.submitted_for_approval_at).total_seconds() / 3600
            return round(Decimal(str(hours)), 2)
        return None


class BulkApproval(BaseCreateSchema):
    """
    Approve or reject multiple menus in bulk.
    
    Efficient bulk approval for routine or similar menus.
    """

    menu_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of menu IDs to approve/reject",
    )
    approved: bool = Field(
        ...,
        description="True to approve all, False to reject all",
    )
    approver_id: UUID = Field(
        ...,
        description="Approver user ID",
    )
    approval_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Common notes for all menus",
    )
    rejection_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Common rejection reason (if rejecting)",
    )
    apply_conditions: Optional[str] = Field(
        None,
        max_length=500,
        description="Common conditions to apply",
    )
    
    # Budget approval
    approved_budget_per_menu: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Approved budget for each menu",
    )

    @model_validator(mode="after")
    def validate_bulk_approval(self) -> "BulkApproval":
        """Validate bulk approval request."""
        # Rejection requires reason
        if not self.approved and not self.rejection_reason:
            raise ValueError(
                "Rejection reason is required for bulk rejection"
            )
        
        # Can't have both approval notes and rejection reason
        if self.approved and self.rejection_reason:
            raise ValueError(
                "Rejection reason should not be provided when approving"
            )
        
        return self


class ApprovalHistory(BaseSchema):
    """
    Complete approval history for menu.
    
    Tracks all approval attempts and decisions for audit trail.
    """

    menu_id: UUID = Field(
        ...,
        description="Menu unique identifier",
    )
    menu_date: date = Field(
        ...,
        description="Menu date",
    )
    total_submissions: int = Field(
        ...,
        ge=0,
        description="Total approval submissions",
    )
    approval_attempts: List["ApprovalAttempt"] = Field(
        ...,
        description="Chronological list of approval attempts",
    )
    current_status: str = Field(
        ...,
        description="Current approval status",
    )
    final_approver: Optional[str] = Field(
        None,
        description="Final approver name",
    )


class ApprovalAttempt(BaseSchema):
    """
    Individual approval attempt record.
    
    Represents single submission in approval workflow.
    """

    attempt_number: int = Field(
        ...,
        ge=1,
        description="Attempt sequence number",
    )
    submitted_by: UUID = Field(
        ...,
        description="Submitter user ID",
    )
    submitted_by_name: str = Field(
        ...,
        description="Submitter name",
    )
    submitted_at: datetime = Field(
        ...,
        description="Submission timestamp",
    )
    reviewed_by: Optional[UUID] = Field(
        None,
        description="Reviewer user ID",
    )
    reviewed_by_name: Optional[str] = Field(
        None,
        description="Reviewer name",
    )
    reviewed_at: Optional[datetime] = Field(
        None,
        description="Review timestamp",
    )
    decision: Optional[str] = Field(
        None,
        pattern=r"^(approved|rejected|revision_requested|pending)$",
        description="Approval decision",
    )
    feedback: Optional[str] = Field(
        None,
        description="Reviewer feedback",
    )
    changes_made: Optional[str] = Field(
        None,
        description="Changes made in this revision",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\menu_duplication.py ---
# --- File: app/schemas/mess/menu_duplication.py ---
"""
Menu duplication and bulk creation schemas.

Provides efficient menu replication capabilities for
recurring patterns and multi-hostel deployment.
"""

from __future__ import annotations

from datetime import date
from typing import Dict, List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "DuplicateMenuRequest",
    "BulkMenuCreate",
    "DuplicateResponse",
    "CrossHostelDuplication",
    "MenuCloneConfig",
]


class DuplicateMenuRequest(BaseCreateSchema):
    """
    Duplicate existing menu to another date.
    
    Creates copy of menu with optional modifications for
    efficient menu planning.
    """

    source_menu_id: UUID = Field(
        ...,
        description="Menu to duplicate",
    )
    target_date: date = Field(
        ...,
        description="Date for duplicated menu",
    )
    
    # Duplication options
    copy_all_meals: bool = Field(
        default=True,
        description="Copy all meal items",
    )
    copy_breakfast: bool = Field(
        default=True,
        description="Copy breakfast items",
    )
    copy_lunch: bool = Field(
        default=True,
        description="Copy lunch items",
    )
    copy_snacks: bool = Field(
        default=True,
        description="Copy snacks items",
    )
    copy_dinner: bool = Field(
        default=True,
        description="Copy dinner items",
    )
    
    # Modification options
    modify_items: bool = Field(
        False,
        description="Allow item modifications during duplication",
    )
    modifications: Optional[Dict[str, List[str]]] = Field(
        None,
        description="Meal-wise item modifications {meal_type: [items]}",
    )
    
    # Additional settings
    preserve_special_status: bool = Field(
        default=True,
        description="Keep special menu status",
    )
    auto_publish: bool = Field(
        default=False,
        description="Automatically publish duplicated menu",
    )
    created_by: UUID = Field(
        ...,
        description="User creating the duplicate",
    )

    @field_validator("target_date")
    @classmethod
    def validate_target_date(cls, v: date) -> date:
        """Validate target date is appropriate for duplication."""
        # Can't duplicate to past dates
        if v < date.today():
            raise ValueError("Cannot duplicate menu to past dates")
        
        # Limit advance duplication
        days_ahead = (v - date.today()).days
        if days_ahead > 90:
            raise ValueError(
                "Cannot duplicate menu more than 90 days in advance"
            )
        
        return v

    @model_validator(mode="after")
    def validate_meal_selection(self) -> "DuplicateMenuRequest":
        """Ensure at least one meal is selected for copying."""
        if not self.copy_all_meals:
            if not any([
                self.copy_breakfast,
                self.copy_lunch,
                self.copy_snacks,
                self.copy_dinner,
            ]):
                raise ValueError(
                    "At least one meal must be selected for duplication"
                )
        
        return self


class BulkMenuCreate(BaseCreateSchema):
    """
    Create menus for multiple dates using template or pattern.
    
    Efficiently generates menus for date range using various sources.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    
    # Date range
    start_date: date = Field(
        ...,
        description="Start date for menu creation",
    )
    end_date: date = Field(
        ...,
        description="End date for menu creation",
    )
    
    # Source configuration
    source_type: str = Field(
        ...,
        pattern=r"^(template|existing_menu|weekly_pattern|daily_rotation)$",
        description="Source for menu creation",
    )
    
    # Template-based
    template_id: Optional[UUID] = Field(
        None,
        description="Template ID (if source_type is 'template')",
    )
    
    # Existing menu-based
    source_menu_id: Optional[UUID] = Field(
        None,
        description="Source menu ID (if source_type is 'existing_menu')",
    )
    
    # Weekly pattern-based
    weekly_pattern: Optional[Dict[str, Dict[str, List[str]]]] = Field(
        None,
        description="Day of week -> meal_type -> items mapping",
    )
    
    # Daily rotation
    rotation_items: Optional[List[Dict[str, List[str]]]] = Field(
        None,
        description="List of daily menus to rotate through",
    )
    rotation_interval_days: Optional[int] = Field(
        None,
        ge=1,
        le=30,
        description="Days before rotation repeats",
    )
    
    # Creation options
    skip_existing: bool = Field(
        True,
        description="Skip dates that already have menus",
    )
    override_existing: bool = Field(
        False,
        description="Override existing menus",
    )
    skip_weekends: bool = Field(
        False,
        description="Skip Saturday and Sunday",
    )
    skip_holidays: bool = Field(
        False,
        description="Skip public holidays",
    )
    
    # Auto-publish
    auto_publish_all: bool = Field(
        default=False,
        description="Automatically publish all created menus",
    )
    
    # Creator
    created_by: UUID = Field(
        ...,
        description="User creating menus",
    )

    @field_validator("start_date")
    @classmethod
    def validate_start_date(cls, v: date) -> date:
        """Validate start date constraints."""
        # Allow starting from yesterday for convenience
        if v < date.today() - timedelta(days=1):
            raise ValueError(
                "Start date cannot be more than 1 day in the past"
            )
        return v

    @model_validator(mode="after")
    def validate_bulk_create(self) -> "BulkMenuCreate":
        """Validate bulk creation configuration."""
        # Validate date range
        if self.end_date < self.start_date:
            raise ValueError("End date must be after start date")
        
        # Limit bulk creation period
        days_span = (self.end_date - self.start_date).days + 1
        if days_span > 90:
            raise ValueError(
                "Bulk creation period cannot exceed 90 days"
            )
        
        # Validate source-specific requirements
        if self.source_type == "template":
            if not self.template_id:
                raise ValueError(
                    "template_id is required when source_type is 'template'"
                )
        
        elif self.source_type == "existing_menu":
            if not self.source_menu_id:
                raise ValueError(
                    "source_menu_id is required when source_type is 'existing_menu'"
                )
        
        elif self.source_type == "weekly_pattern":
            if not self.weekly_pattern:
                raise ValueError(
                    "weekly_pattern is required when source_type is 'weekly_pattern'"
                )
        
        elif self.source_type == "daily_rotation":
            if not self.rotation_items:
                raise ValueError(
                    "rotation_items is required when source_type is 'daily_rotation'"
                )
        
        # Can't both skip and override existing
        if self.skip_existing and self.override_existing:
            raise ValueError(
                "Cannot both skip and override existing menus"
            )
        
        return self


class DuplicateResponse(BaseSchema):
    """
    Menu duplication response with results.
    
    Provides summary of duplication operation results.
    """

    source_menu_id: UUID = Field(
        ...,
        description="Source menu ID",
    )
    source_menu_date: date = Field(
        ...,
        description="Source menu date",
    )
    created_menus: List[UUID] = Field(
        ...,
        description="IDs of created menus",
    )
    created_dates: List[date] = Field(
        ...,
        description="Dates for which menus were created",
    )
    total_created: int = Field(
        ...,
        ge=0,
        description="Total menus created",
    )
    skipped: int = Field(
        default=0,
        ge=0,
        description="Dates skipped (already had menus)",
    )
    failed: int = Field(
        default=0,
        ge=0,
        description="Failed creation attempts",
    )
    message: str = Field(
        ...,
        description="Operation summary message",
    )
    warnings: List[str] = Field(
        default_factory=list,
        description="Warnings during operation",
    )
    errors: List[str] = Field(
        default_factory=list,
        description="Errors encountered",
    )

    @computed_field
    @property
    def success_rate(self) -> Decimal:
        """Calculate success rate percentage."""
        total_attempted = self.total_created + self.failed
        
        if total_attempted == 0:
            return Decimal("0.00")
        
        return round(
            Decimal(self.total_created) / Decimal(total_attempted) * 100,
            2,
        )


class CrossHostelDuplication(BaseCreateSchema):
    """
    Duplicate menu across multiple hostels.
    
    Replicates menu to other hostels with optional adaptation
    for hostel-specific preferences.
    """

    source_menu_id: UUID = Field(
        ...,
        description="Source menu unique identifier",
    )
    source_hostel_id: UUID = Field(
        ...,
        description="Source hostel ID",
    )
    target_hostel_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Target hostel IDs",
    )
    target_date: date = Field(
        ...,
        description="Date for duplicated menus in target hostels",
    )
    
    # Adaptation options
    adapt_to_hostel_preferences: bool = Field(
        True,
        description="Adapt menu to each hostel's dietary preferences",
    )
    adapt_dietary_options: bool = Field(
        default=True,
        description="Adjust vegetarian/non-veg based on hostel settings",
    )
    adapt_regional_preferences: bool = Field(
        default=True,
        description="Adapt to regional food preferences",
    )
    
    # Item substitution
    allow_item_substitution: bool = Field(
        default=True,
        description="Allow substituting unavailable items",
    )
    substitution_rules: Optional[Dict[str, str]] = Field(
        None,
        description="Item substitution mapping {original: substitute}",
    )
    
    # Cost adjustment
    adjust_for_hostel_budget: bool = Field(
        default=False,
        description="Adjust menu to fit hostel budget",
    )
    
    # Creation options
    skip_existing: bool = Field(
        default=True,
        description="Skip hostels that already have menu for date",
    )
    created_by: UUID = Field(
        ...,
        description="User performing cross-hostel duplication",
    )

    @field_validator("target_hostel_ids")
    @classmethod
    def validate_unique_hostels(cls, v: List[UUID]) -> List[UUID]:
        """Ensure no duplicate hostel IDs."""
        if len(v) != len(set(v)):
            raise ValueError("Duplicate hostel IDs not allowed")
        return v

    @model_validator(mode="after")
    def validate_source_not_in_targets(self) -> "CrossHostelDuplication":
        """Ensure source hostel is not in target list."""
        if self.source_hostel_id in self.target_hostel_ids:
            raise ValueError(
                "Source hostel cannot be in target hostel list"
            )
        return self


class MenuCloneConfig(BaseSchema):
    """
    Configuration for menu cloning operations.
    
    Defines rules and preferences for menu duplication.
    """

    preserve_special_occasions: bool = Field(
        default=True,
        description="Keep special menu flags when cloning",
    )
    preserve_meal_timings: bool = Field(
        default=True,
        description="Copy meal serving times",
    )
    preserve_dietary_options: bool = Field(
        default=True,
        description="Copy dietary option flags",
    )
    
    # Item handling
    remove_seasonal_items: bool = Field(
        default=False,
        description="Remove seasonal items from cloned menu",
    )
    remove_expensive_items: bool = Field(
        default=False,
        description="Remove high-cost items",
    )
    cost_threshold: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Cost threshold for expensive items",
    )
    
    # Auto-adjustments
    auto_adjust_portions: bool = Field(
        default=False,
        description="Automatically adjust portion sizes",
    )
    target_cost_per_person: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Target cost per person for adjustments",
    )
    
    # Naming
    add_clone_suffix: bool = Field(
        default=False,
        description="Add '(Copy)' suffix to cloned menu names",
    )
    custom_suffix: Optional[str] = Field(
        None,
        max_length=50,
        description="Custom suffix for cloned menus",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\menu_feedback.py ---
# --- File: app/schemas/mess/menu_feedback.py ---
"""
Mess menu feedback and rating schemas.

Provides comprehensive feedback collection, rating analysis,
and quality metrics for menu improvement.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, model_validator, computed_field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import MealType
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "FeedbackRequest",
    "FeedbackResponse",
    "RatingsSummary",
    "QualityMetrics",
    "ItemRating",
    "FeedbackAnalysis",
    "SentimentAnalysis",
]


class FeedbackRequest(BaseCreateSchema):
    """
    Submit menu feedback and ratings.
    
    Allows students to rate menu quality and provide detailed feedback
    with multi-dimensional ratings.
    """

    menu_id: UUID = Field(
        ...,
        description="Menu unique identifier",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    meal_type: MealType = Field(
        ...,
        description="Which meal is being rated",
    )
    
    # Overall rating
    rating: int = Field(
        ...,
        ge=1,
        le=5,
        description="Overall rating (1-5 stars)",
    )
    
    # Detailed feedback
    comments: Optional[str] = Field(
        None,
        max_length=1000,
        description="Detailed comments and feedback",
    )
    
    # Aspect-specific ratings
    taste_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Taste rating (1-5)",
    )
    quantity_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Portion size rating (1-5)",
    )
    quality_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Food quality rating (1-5)",
    )
    hygiene_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Hygiene and cleanliness rating (1-5)",
    )
    presentation_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Food presentation rating (1-5)",
    )
    service_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Service quality rating (1-5)",
    )
    
    # Item-specific feedback
    liked_items: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Items student liked",
    )
    disliked_items: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Items student disliked",
    )
    
    # Suggestions
    improvement_suggestions: Optional[str] = Field(
        None,
        max_length=500,
        description="Suggestions for improvement",
    )
    
    # Would recommend
    would_recommend: Optional[bool] = Field(
        None,
        description="Would recommend this menu to others",
    )

    @field_validator("comments", "improvement_suggestions")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize text fields."""
        if v is not None:
            v = v.strip()
            
            # Check for meaningful content
            if len(v) > 0 and len(set(v.lower().replace(" ", ""))) < 3:
                raise ValueError("Please provide meaningful feedback")
            
            return v if v else None
        return None

    @field_validator("liked_items", "disliked_items")
    @classmethod
    def validate_item_lists(cls, v: List[str]) -> List[str]:
        """Validate and normalize item lists."""
        if not v:
            return v
        
        # Normalize and deduplicate
        normalized = []
        seen = set()
        
        for item in v:
            item = item.strip()
            if item and len(item) >= 2:
                item_lower = item.lower()
                if item_lower not in seen:
                    seen.add(item_lower)
                    normalized.append(item)
        
        return normalized

    @model_validator(mode="after")
    def validate_feedback_completeness(self) -> "FeedbackRequest":
        """
        Validate feedback has sufficient information.
        
        Low ratings should have comments explaining the issue.
        """
        # If overall rating is low, encourage detailed feedback
        if self.rating <= 2:
            if not self.comments and not self.improvement_suggestions:
                raise ValueError(
                    "Please provide comments or suggestions for low ratings"
                )
        
        return self


class FeedbackResponse(BaseResponseSchema):
    """
    Feedback submission response.
    
    Provides confirmation of feedback submission with context.
    """

    menu_id: UUID = Field(
        ...,
        description="Menu unique identifier",
    )
    menu_date: date = Field(
        ...,
        description="Menu date",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    meal_type: MealType = Field(
        ...,
        description="Meal type rated",
    )
    rating: int = Field(
        ...,
        ge=1,
        le=5,
        description="Overall rating",
    )
    comments: Optional[str] = Field(
        None,
        description="Feedback comments",
    )
    submitted_at: datetime = Field(
        ...,
        description="Submission timestamp",
    )
    is_verified: bool = Field(
        default=False,
        description="Whether feedback is verified",
    )
    helpful_count: int = Field(
        default=0,
        ge=0,
        description="Number of users who found this helpful",
    )

    @computed_field
    @property
    def rating_display(self) -> str:
        """Get star rating display."""
        return "" * self.rating + "" * (5 - self.rating)


class ItemRating(BaseSchema):
    """
    Rating for specific menu item.
    
    Aggregates ratings for individual food items.
    """

    item_name: str = Field(
        ...,
        description="Menu item name",
    )
    item_category: Optional[str] = Field(
        None,
        description="Item category",
    )
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average rating for this item",
    )
    feedback_count: int = Field(
        ...,
        ge=0,
        description="Number of feedbacks received",
    )
    liked_count: int = Field(
        default=0,
        ge=0,
        description="Times marked as liked",
    )
    disliked_count: int = Field(
        default=0,
        ge=0,
        description="Times marked as disliked",
    )
    popularity_score: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Popularity score (0-100)",
    )
    last_served: Optional[date] = Field(
        None,
        description="Last date item was served",
    )

    @computed_field
    @property
    def sentiment(self) -> str:
        """Calculate overall sentiment for item."""
        if self.feedback_count == 0:
            return "neutral"
        
        rating = float(self.average_rating)
        
        if rating >= 4.0:
            return "positive"
        elif rating >= 3.0:
            return "neutral"
        else:
            return "negative"

    @computed_field
    @property
    def like_ratio(self) -> Decimal:
        """Calculate like to dislike ratio."""
        total = self.liked_count + self.disliked_count
        
        if total == 0:
            return Decimal("0.00")
        
        return round(
            Decimal(self.liked_count) / Decimal(total) * 100,
            2,
        )


class RatingsSummary(BaseSchema):
    """
    Comprehensive ratings summary for menu.
    
    Provides aggregated statistics and distribution of ratings.
    """

    menu_id: UUID = Field(
        ...,
        description="Menu unique identifier",
    )
    menu_date: date = Field(
        ...,
        description="Menu date",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    
    # Overall statistics
    total_feedbacks: int = Field(
        ...,
        ge=0,
        description="Total feedback count",
    )
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        decimal_places=2,
        description="Overall average rating",
    )
    median_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Median rating",
    )
    
    # Meal-specific ratings
    breakfast_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Breakfast average rating",
    )
    breakfast_feedback_count: int = Field(
        default=0,
        ge=0,
        description="Breakfast feedback count",
    )
    
    lunch_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Lunch average rating",
    )
    lunch_feedback_count: int = Field(
        default=0,
        ge=0,
        description="Lunch feedback count",
    )
    
    snacks_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Snacks average rating",
    )
    snacks_feedback_count: int = Field(
        default=0,
        ge=0,
        description="Snacks feedback count",
    )
    
    dinner_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Dinner average rating",
    )
    dinner_feedback_count: int = Field(
        default=0,
        ge=0,
        description="Dinner feedback count",
    )
    
    # Rating distribution
    rating_5_count: int = Field(
        ...,
        ge=0,
        description="5-star ratings count",
    )
    rating_4_count: int = Field(
        ...,
        ge=0,
        description="4-star ratings count",
    )
    rating_3_count: int = Field(
        ...,
        ge=0,
        description="3-star ratings count",
    )
    rating_2_count: int = Field(
        ...,
        ge=0,
        description="2-star ratings count",
    )
    rating_1_count: int = Field(
        ...,
        ge=0,
        description="1-star ratings count",
    )
    
    # Aspect ratings
    average_taste_rating: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=5,
        decimal_places=2,
        description="Average taste rating",
    )
    average_quantity_rating: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=5,
        decimal_places=2,
        description="Average quantity rating",
    )
    average_quality_rating: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=5,
        decimal_places=2,
        description="Average quality rating",
    )
    average_hygiene_rating: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=5,
        decimal_places=2,
        description="Average hygiene rating",
    )
    average_presentation_rating: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=5,
        decimal_places=2,
        description="Average presentation rating",
    )
    average_service_rating: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=5,
        decimal_places=2,
        description="Average service rating",
    )
    
    # Recommendation
    would_recommend_percentage: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage who would recommend",
    )

    @computed_field
    @property
    def participation_rate(self) -> Decimal:
        """Calculate feedback participation rate (if total students known)."""
        # This would need total students count from context
        # Placeholder for illustration
        return Decimal("0.00")

    @computed_field
    @property
    def satisfaction_level(self) -> str:
        """Determine overall satisfaction level."""
        rating = float(self.average_rating)
        
        if rating >= 4.5:
            return "excellent"
        elif rating >= 4.0:
            return "very_good"
        elif rating >= 3.5:
            return "good"
        elif rating >= 3.0:
            return "satisfactory"
        elif rating >= 2.0:
            return "needs_improvement"
        else:
            return "poor"


class SentimentAnalysis(BaseSchema):
    """
    Sentiment analysis of feedback comments.
    
    Analyzes text feedback for sentiment and themes.
    """

    menu_id: UUID = Field(
        ...,
        description="Menu unique identifier",
    )
    total_comments: int = Field(
        ...,
        ge=0,
        description="Total comments analyzed",
    )
    
    # Sentiment distribution
    positive_count: int = Field(
        ...,
        ge=0,
        description="Positive sentiment count",
    )
    neutral_count: int = Field(
        ...,
        ge=0,
        description="Neutral sentiment count",
    )
    negative_count: int = Field(
        ...,
        ge=0,
        description="Negative sentiment count",
    )
    
    # Percentages
    positive_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Positive sentiment percentage",
    )
    negative_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Negative sentiment percentage",
    )
    
    # Common themes
    common_positive_keywords: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Most frequent positive keywords",
    )
    common_negative_keywords: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Most frequent negative keywords",
    )


class QualityMetrics(BaseSchema):
    """
    Menu quality metrics and trends.
    
    Provides insights into menu quality over time with
    comparative analysis.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    period_start: date = Field(
        ...,
        description="Analysis period start",
    )
    period_end: date = Field(
        ...,
        description="Analysis period end",
    )
    
    # Overall metrics
    overall_average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        decimal_places=2,
        description="Overall average rating for period",
    )
    total_feedbacks: int = Field(
        ...,
        ge=0,
        description="Total feedback count",
    )
    total_menus_rated: int = Field(
        ...,
        ge=0,
        description="Number of menus that received ratings",
    )
    
    # Trends
    rating_trend: str = Field(
        ...,
        pattern=r"^(improving|declining|stable)$",
        description="Rating trend direction",
    )
    trend_percentage: Optional[Decimal] = Field(
        None,
        decimal_places=2,
        description="Trend change percentage",
    )
    
    # Best and worst performers
    best_rated_items: List[ItemRating] = Field(
        default_factory=list,
        max_length=10,
        description="Top rated items",
    )
    worst_rated_items: List[ItemRating] = Field(
        default_factory=list,
        max_length=10,
        description="Lowest rated items",
    )
    most_popular_items: List[ItemRating] = Field(
        default_factory=list,
        max_length=10,
        description="Most popular items by feedback count",
    )
    
    # Day of week analysis
    ratings_by_day: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Average rating by day of week",
    )
    best_day: Optional[str] = Field(
        None,
        description="Day with highest average rating",
    )
    worst_day: Optional[str] = Field(
        None,
        description="Day with lowest average rating",
    )
    
    # Meal analysis
    best_meal_type: Optional[str] = Field(
        None,
        description="Meal type with highest rating",
    )
    worst_meal_type: Optional[str] = Field(
        None,
        description="Meal type with lowest rating",
    )
    
    # Satisfaction metrics
    satisfaction_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Percentage of ratings >= 4 stars",
    )
    dissatisfaction_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Percentage of ratings <= 2 stars",
    )

    @computed_field
    @property
    def quality_score(self) -> Decimal:
        """
        Calculate overall quality score (0-100).
        
        Composite metric based on ratings and satisfaction.
        """
        # Simple formula: (avg_rating / 5) * 100
        return round(
            self.overall_average_rating / Decimal("5") * 100,
            2,
        )


class FeedbackAnalysis(BaseSchema):
    """
    Comprehensive feedback analysis with actionable insights.
    
    Provides detailed analysis of feedback data with recommendations
    for menu improvement.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    analysis_period: DateRangeFilter = Field(
        ...,
        description="Analysis time period",
    )
    generated_at: datetime = Field(
        ...,
        description="Analysis generation timestamp",
    )
    
    # Sentiment analysis
    positive_feedback_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Positive feedback percentage",
    )
    negative_feedback_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Negative feedback percentage",
    )
    neutral_feedback_percentage: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Neutral feedback percentage",
    )
    
    # Common themes
    common_complaints: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Most common complaints/issues",
    )
    common_compliments: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Most common positive feedback",
    )
    recurring_issues: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Issues appearing repeatedly",
    )
    
    # Item-level insights
    items_to_keep: List[str] = Field(
        default_factory=list,
        max_length=30,
        description="High-rated items to continue serving",
    )
    items_to_improve: List[str] = Field(
        default_factory=list,
        max_length=30,
        description="Items needing quality improvement",
    )
    items_to_remove: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Consistently low-rated items to remove",
    )
    items_to_introduce: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Suggested new items based on requests",
    )
    
    # Improvement recommendations
    priority_improvements: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="High-priority improvement areas",
    )
    quick_wins: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Easy improvements with high impact",
    )
    
    # Cost-benefit analysis
    high_satisfaction_low_cost_items: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Items with good rating and low cost",
    )
    
    # Student preferences
    dietary_preference_trends: Dict[str, int] = Field(
        default_factory=dict,
        description="Emerging dietary preference trends",
    )
    requested_cuisines: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Cuisines students are requesting",
    )
    
    # Timing insights
    peak_feedback_times: List[str] = Field(
        default_factory=list,
        description="Times when most feedback is received",
    )
    low_engagement_meals: List[str] = Field(
        default_factory=list,
        description="Meals with low feedback participation",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\menu_planning.py ---
# --- File: app/schemas/mess/menu_planning.py ---
"""
Menu planning schemas for advance planning and templates.

Provides comprehensive menu planning capabilities including weekly plans,
monthly schedules, special menus, and reusable templates.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "MenuPlanRequest",
    "WeeklyPlan",
    "DailyMenuPlan",
    "MonthlyPlan",
    "SpecialMenu",
    "SpecialDayMenu",
    "MenuTemplate",
    "MenuSuggestion",
]


class DailyMenuPlan(BaseSchema):
    """
    Daily menu plan structure.
    
    Defines items for all meals of a single day.
    """

    breakfast: List[str] = Field(
        ...,
        min_length=1,
        max_length=20,
        description="Breakfast items",
    )
    lunch: List[str] = Field(
        ...,
        min_length=1,
        max_length=30,
        description="Lunch items",
    )
    snacks: List[str] = Field(
        default_factory=list,
        max_length=15,
        description="Snacks items",
    )
    dinner: List[str] = Field(
        ...,
        min_length=1,
        max_length=30,
        description="Dinner items",
    )
    is_special: bool = Field(
        False,
        description="Special menu indicator",
    )
    special_occasion: Optional[str] = Field(
        None,
        max_length=255,
        description="Special occasion name",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Planning notes",
    )

    @field_validator("breakfast", "lunch", "snacks", "dinner")
    @classmethod
    def validate_menu_items(cls, v: List[str]) -> List[str]:
        """Validate and normalize menu items."""
        normalized = []
        for item in v:
            item = item.strip()
            if item and len(item) >= 2:
                normalized.append(item)
        
        # Remove duplicates while preserving order
        seen = set()
        unique_items = []
        for item in normalized:
            if item.lower() not in seen:
                seen.add(item.lower())
                unique_items.append(item)
        
        return unique_items

    @model_validator(mode="after")
    def validate_special_occasion(self) -> "DailyMenuPlan":
        """Validate special occasion requirements."""
        if self.is_special and not self.special_occasion:
            raise ValueError(
                "special_occasion is required when is_special is True"
            )
        return self


class MenuPlanRequest(BaseCreateSchema):
    """
    Request to create comprehensive menu plan.
    
    Initiates menu planning for a date range with various
    configuration options.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    
    # Planning period
    start_date: date = Field(
        ...,
        description="Plan start date",
    )
    end_date: date = Field(
        ...,
        description="Plan end date",
    )
    
    # Template usage
    use_template: bool = Field(
        False,
        description="Use existing template",
    )
    template_id: Optional[UUID] = Field(
        None,
        description="Template ID to use",
    )
    
    # Variety and preferences
    ensure_variety: bool = Field(
        True,
        description="Ensure item variety across days",
    )
    min_days_between_repeat: int = Field(
        3,
        ge=1,
        le=7,
        description="Minimum days before repeating items",
    )
    avoid_consecutive_repeats: bool = Field(
        True,
        description="Avoid same item on consecutive days",
    )
    
    # Dietary requirements
    vegetarian_days_per_week: int = Field(
        7,
        ge=0,
        le=7,
        description="Days with vegetarian-only menu",
    )
    include_vegan_options: bool = Field(
        False,
        description="Include vegan options",
    )
    include_jain_options: bool = Field(
        False,
        description="Include Jain dietary options",
    )
    
    # Budget constraints
    target_cost_per_day: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Target daily cost per person",
    )
    max_cost_per_day: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Maximum daily cost per person",
    )
    
    # Nutritional goals
    target_calories_per_day: Optional[int] = Field(
        None,
        ge=1000,
        le=5000,
        description="Target daily calories",
    )
    ensure_balanced_nutrition: bool = Field(
        default=True,
        description="Ensure balanced macros",
    )
    
    # Planning preferences
    prefer_seasonal_items: bool = Field(
        default=True,
        description="Prefer seasonal ingredients",
    )
    include_regional_favorites: bool = Field(
        default=True,
        description="Include regional favorites",
    )

    @field_validator("start_date")
    @classmethod
    def validate_start_date(cls, v: date) -> date:
        """Validate start date is not too far in past."""
        today = date.today()
        
        days_past = (today - v).days
        if days_past > 7:
            raise ValueError(
                "Start date cannot be more than 7 days in the past"
            )
        
        return v

    @model_validator(mode="after")
    def validate_plan_request(self) -> "MenuPlanRequest":
        """Validate menu plan request consistency."""
        # Validate date range
        if self.end_date < self.start_date:
            raise ValueError("End date must be after start date")
        
        # Limit planning period
        days_span = (self.end_date - self.start_date).days + 1
        if days_span > 90:
            raise ValueError("Planning period cannot exceed 90 days")
        
        # Template validation
        if self.use_template and not self.template_id:
            raise ValueError(
                "template_id is required when use_template is True"
            )
        
        # Cost validation
        if self.target_cost_per_day and self.max_cost_per_day:
            if self.max_cost_per_day < self.target_cost_per_day:
                raise ValueError(
                    "max_cost_per_day must be >= target_cost_per_day"
                )
        
        return self


class WeeklyPlan(BaseCreateSchema):
    """
    Complete weekly menu plan.
    
    Defines menus for all seven days of the week.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    week_start_date: date = Field(
        ...,
        description="Week start date (Monday)",
    )
    week_number: int = Field(
        ...,
        ge=1,
        le=53,
        description="Week number in year",
    )
    year: int = Field(
        ...,
        ge=2000,
        description="Year",
    )
    
    # Daily menus
    monday: DailyMenuPlan = Field(
        ...,
        description="Monday menu",
    )
    tuesday: DailyMenuPlan = Field(
        ...,
        description="Tuesday menu",
    )
    wednesday: DailyMenuPlan = Field(
        ...,
        description="Wednesday menu",
    )
    thursday: DailyMenuPlan = Field(
        ...,
        description="Thursday menu",
    )
    friday: DailyMenuPlan = Field(
        ...,
        description="Friday menu",
    )
    saturday: DailyMenuPlan = Field(
        ...,
        description="Saturday menu",
    )
    sunday: DailyMenuPlan = Field(
        ...,
        description="Sunday menu",
    )
    
    # Metadata
    created_by: UUID = Field(
        ...,
        description="Creator user ID",
    )
    plan_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Plan name/title",
    )
    notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Planning notes",
    )
    estimated_total_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Estimated total cost for the week",
    )

    @field_validator("week_start_date")
    @classmethod
    def validate_monday(cls, v: date) -> date:
        """Ensure week starts on Monday."""
        if v.weekday() != 0:  # 0 = Monday
            raise ValueError("Week must start on Monday")
        return v


class SpecialDayMenu(BaseSchema):
    """
    Special day menu in monthly plan.
    
    Associates special occasion with specific date and menu.
    """

    date: date = Field(
        ...,
        description="Special day date",
    )
    occasion: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Occasion name",
    )
    occasion_type: str = Field(
        ...,
        pattern=r"^(festival|holiday|celebration|event|birthday|other)$",
        description="Occasion type",
    )
    menu: DailyMenuPlan = Field(
        ...,
        description="Special menu for the day",
    )
    budget: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Special budget allocation",
    )
    expected_guests: Optional[int] = Field(
        None,
        ge=0,
        description="Expected number of guests",
    )


class MonthlyPlan(BaseCreateSchema):
    """
    Comprehensive monthly menu plan.
    
    Organizes weekly plans and special occasions for entire month.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    month: str = Field(
        ...,
        pattern=r"^\d{4}-(0[1-9]|1[0-2])$",
        description="Month in YYYY-MM format",
    )
    month_name: str = Field(
        ...,
        description="Month name",
    )
    year: int = Field(
        ...,
        ge=2000,
        description="Year",
    )
    
    # Weekly plans
    weeks: List[WeeklyPlan] = Field(
        ...,
        min_length=4,
        max_length=5,
        description="Weekly menu plans",
    )
    
    # Special days
    special_days: List[SpecialDayMenu] = Field(
        default_factory=list,
        max_length=31,
        description="Special occasion menus",
    )
    
    # Monthly summary
    total_budget: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Total monthly budget",
    )
    created_by: UUID = Field(
        ...,
        description="Creator user ID",
    )
    approved_by: Optional[UUID] = Field(
        None,
        description="Approver user ID",
    )
    notes: Optional[str] = Field(
        None,
        max_length=2000,
        description="Monthly planning notes",
    )

    @model_validator(mode="after")
    def validate_special_days(self) -> "MonthlyPlan":
        """Ensure special days are unique and within month."""
        if self.special_days:
            dates = [day.date for day in self.special_days]
            
            # Check for duplicates
            if len(dates) != len(set(dates)):
                raise ValueError("Duplicate special day dates found")
        
        return self


class SpecialMenu(BaseCreateSchema):
    """
    Special occasion menu configuration.
    
    Defines enhanced menu for festivals, celebrations, and events.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    occasion_date: date = Field(
        ...,
        description="Occasion date",
    )
    occasion_name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Occasion name",
    )
    occasion_type: str = Field(
        ...,
        pattern=r"^(festival|holiday|celebration|cultural_event|sports_event|founder_day|other)$",
        description="Type of occasion",
    )
    
    # Enhanced menu
    breakfast: List[str] = Field(
        ...,
        min_length=1,
        max_length=25,
        description="Special breakfast items",
    )
    lunch: List[str] = Field(
        ...,
        min_length=1,
        max_length=40,
        description="Special lunch items",
    )
    snacks: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Special snacks items",
    )
    dinner: List[str] = Field(
        ...,
        min_length=1,
        max_length=40,
        description="Special dinner items",
    )
    
    # Additional special items
    special_items: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Extra special delicacies",
    )
    desserts: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Special desserts",
    )
    
    # Budget and planning
    budget: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Special occasion budget",
    )
    estimated_cost_per_person: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Estimated cost per person",
    )
    expected_attendees: Optional[int] = Field(
        None,
        ge=1,
        description="Expected number of attendees",
    )
    
    # Execution details
    decoration_theme: Optional[str] = Field(
        None,
        max_length=255,
        description="Decoration theme",
    )
    serving_style: Optional[str] = Field(
        None,
        pattern=r"^(buffet|table_service|plated|family_style)$",
        description="Serving style",
    )
    special_instructions: Optional[str] = Field(
        None,
        max_length=1000,
        description="Special preparation instructions",
    )
    
    # Notifications
    send_advance_notification: bool = Field(
        default=True,
        description="Send advance notification to students",
    )
    notification_days_before: int = Field(
        default=3,
        ge=0,
        le=30,
        description="Days before to send notification",
    )

    @field_validator("occasion_date")
    @classmethod
    def validate_occasion_date(cls, v: date) -> date:
        """Validate occasion date is not too far in future."""
        days_ahead = (v - date.today()).days
        
        if days_ahead < -7:
            raise ValueError(
                "Cannot create special menu for dates more than 7 days in past"
            )
        
        if days_ahead > 365:
            raise ValueError(
                "Cannot create special menu more than 1 year in advance"
            )
        
        return v


class MenuTemplate(BaseCreateSchema):
    """
    Reusable menu template for recurring patterns.
    
    Stores menu patterns that can be applied to multiple dates.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    template_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Template name",
    )
    template_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Template code/identifier",
    )
    description: Optional[str] = Field(
        None,
        max_length=500,
        description="Template description",
    )
    
    # Template type and applicability
    template_type: str = Field(
        ...,
        pattern=r"^(weekly|festival|summer|winter|monsoon|exam_period|vacation|regular)$",
        description="Template type/category",
    )
    applicable_season: Optional[str] = Field(
        None,
        pattern=r"^(spring|summer|monsoon|autumn|winter|all)$",
        description="Applicable season",
    )
    
    # Menu structure (day-wise or meal-wise)
    daily_menus: Dict[str, DailyMenuPlan] = Field(
        ...,
        description="Day name/identifier -> menu plan mapping",
    )
    
    # Template metadata
    created_by: UUID = Field(
        ...,
        description="Creator user ID",
    )
    is_active: bool = Field(
        default=True,
        description="Whether template is active",
    )
    is_default: bool = Field(
        default=False,
        description="Whether this is default template",
    )
    usage_count: int = Field(
        default=0,
        ge=0,
        description="Number of times template has been used",
    )
    average_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average rating when template was used",
    )
    
    # Cost information
    estimated_daily_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Estimated daily cost per person",
    )
    
    # Tags for categorization
    tags: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Template tags for search/filter",
    )

    @field_validator("daily_menus")
    @classmethod
    def validate_daily_menus(cls, v: Dict[str, DailyMenuPlan]) -> Dict[str, DailyMenuPlan]:
        """Validate daily menus structure."""
        if not v:
            raise ValueError("Template must have at least one daily menu")
        
        # Validate keys are proper day names or identifiers
        valid_days = {
            "monday", "tuesday", "wednesday", "thursday",
            "friday", "saturday", "sunday",
            "day1", "day2", "day3", "day4", "day5", "day6", "day7"
        }
        
        for key in v.keys():
            if key.lower() not in valid_days:
                # Allow custom keys but validate they're reasonable
                if len(key) > 20:
                    raise ValueError(f"Daily menu key '{key}' is too long")
        
        return v


class MenuSuggestion(BaseSchema):
    """
    AI/system generated menu suggestions.
    
    Provides intelligent menu recommendations based on various factors.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    suggestion_date: date = Field(
        ...,
        description="Date for suggested menu",
    )
    
    # Suggested items
    suggested_breakfast: List[str] = Field(
        ...,
        min_length=1,
        max_length=20,
        description="Breakfast suggestions",
    )
    suggested_lunch: List[str] = Field(
        ...,
        min_length=1,
        max_length=30,
        description="Lunch suggestions",
    )
    suggested_snacks: List[str] = Field(
        default_factory=list,
        max_length=15,
        description="Snacks suggestions",
    )
    suggested_dinner: List[str] = Field(
        ...,
        min_length=1,
        max_length=30,
        description="Dinner suggestions",
    )
    
    # Suggestion rationale
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Why these items are suggested",
    )
    based_on: List[str] = Field(
        default_factory=list,
        description="Factors considered (past ratings, season, etc.)",
    )
    
    # Scoring
    variety_score: Decimal = Field(
        ...,
        ge=0,
        le=10,
        decimal_places=2,
        description="Menu variety score (0-10)",
    )
    nutrition_score: Decimal = Field(
        ...,
        ge=0,
        le=10,
        decimal_places=2,
        description="Nutritional balance score (0-10)",
    )
    cost_score: Decimal = Field(
        ...,
        ge=0,
        le=10,
        decimal_places=2,
        description="Cost efficiency score (0-10)",
    )
    popularity_score: Decimal = Field(
        ...,
        ge=0,
        le=10,
        decimal_places=2,
        description="Based on past ratings (0-10)",
    )
    overall_score: Decimal = Field(
        ...,
        ge=0,
        le=10,
        decimal_places=2,
        description="Overall recommendation score (0-10)",
    )
    
    # Additional context
    seasonal_items_count: int = Field(
        default=0,
        ge=0,
        description="Number of seasonal items included",
    )
    estimated_cost_per_person: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Estimated cost per person",
    )
    estimated_calories: Optional[int] = Field(
        None,
        ge=0,
        description="Estimated daily calories",
    )
    
    # Suggestion metadata
    generated_at: datetime = Field(
        ...,
        description="Suggestion generation timestamp",
    )
    algorithm_version: Optional[str] = Field(
        None,
        description="Suggestion algorithm version",
    )

    @computed_field
    @property
    def recommendation_strength(self) -> str:
        """Get recommendation strength label."""
        score = float(self.overall_score)
        
        if score >= 9:
            return "highly_recommended"
        elif score >= 7:
            return "recommended"
        elif score >= 5:
            return "moderate"
        else:
            return "consider_alternatives"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\mess_menu_base.py ---
# --- File: app/schemas/mess/mess_menu_base.py ---
"""
Base mess menu schemas with comprehensive validation and type safety.

This module provides foundational schemas for mess/cafeteria menu management
including creation, updates, and core validation logic.
"""

from __future__ import annotations

from datetime import date, time
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema

__all__ = [
    "MessMenuBase",
    "MessMenuCreate",
    "MessMenuUpdate",
]


class MessMenuBase(BaseSchema):
    """
    Base mess menu schema with core fields.
    
    Provides common menu attributes and validation logic used across
    create/update operations for hostel meal planning.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    menu_date: date = Field(
        ...,
        description="Date for which menu is planned",
    )
    day_of_week: str = Field(
        ...,
        pattern=r"^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)$",
        description="Day of the week",
    )

    # Meal items
    breakfast_items: List[str] = Field(
        default_factory=list,
        min_length=0,
        max_length=20,
        description="Breakfast menu items",
    )
    lunch_items: List[str] = Field(
        default_factory=list,
        min_length=0,
        max_length=30,
        description="Lunch menu items",
    )
    snacks_items: List[str] = Field(
        default_factory=list,
        min_length=0,
        max_length=15,
        description="Snacks/evening tea items",
    )
    dinner_items: List[str] = Field(
        default_factory=list,
        min_length=0,
        max_length=30,
        description="Dinner menu items",
    )

    # Meal timings
    breakfast_time: Optional[time] = Field(
        None,
        description="Breakfast serving time",
    )
    lunch_time: Optional[time] = Field(
        None,
        description="Lunch serving time",
    )
    snacks_time: Optional[time] = Field(
        None,
        description="Snacks serving time",
    )
    dinner_time: Optional[time] = Field(
        None,
        description="Dinner serving time",
    )

    # Special menu flags
    is_special_menu: bool = Field(
        False,
        description="Whether this is a special occasion menu",
    )
    special_occasion: Optional[str] = Field(
        None,
        max_length=255,
        description="Special occasion name (festival, celebration, etc.)",
    )
    special_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes about the special menu",
    )

    # Dietary options availability
    vegetarian_available: bool = Field(
        True,
        description="Vegetarian options available",
    )
    non_vegetarian_available: bool = Field(
        False,
        description="Non-vegetarian options available",
    )
    vegan_available: bool = Field(
        False,
        description="Vegan options available",
    )
    jain_available: bool = Field(
        False,
        description="Jain dietary options available",
    )

    @field_validator("menu_date")
    @classmethod
    def validate_menu_date(cls, v: date) -> date:
        """
        Validate menu date constraints.
        
        Menu can be created for today or future dates, but not too far ahead.
        """
        today = date.today()
        
        # Can't create menu for past dates (except today)
        if v < today:
            raise ValueError("Menu date cannot be in the past")
        
        # Limit advance menu planning to 90 days
        days_ahead = (v - today).days
        if days_ahead > 90:
            raise ValueError(
                "Menu cannot be created more than 90 days in advance"
            )
        
        return v

    @field_validator("day_of_week")
    @classmethod
    def validate_day_consistency(cls, v: str, info) -> str:
        """
        Validate day of week matches the menu date.
        
        Ensures data consistency between date and day name.
        """
        if "menu_date" in info.data:
            menu_date = info.data["menu_date"]
            expected_day = menu_date.strftime("%A")
            
            if v != expected_day:
                raise ValueError(
                    f"Day of week '{v}' doesn't match menu date {menu_date} "
                    f"(should be {expected_day})"
                )
        
        return v

    @field_validator(
        "breakfast_items",
        "lunch_items",
        "snacks_items",
        "dinner_items",
    )
    @classmethod
    def validate_menu_items(cls, v: List[str]) -> List[str]:
        """
        Validate and normalize menu items.
        
        Ensures items are properly formatted and not empty.
        """
        if not v:
            return v
        
        # Normalize and validate each item
        normalized_items = []
        for item in v:
            item = item.strip()
            
            if not item:
                continue
            
            if len(item) < 2:
                raise ValueError("Menu items must be at least 2 characters long")
            
            if len(item) > 100:
                raise ValueError("Menu items cannot exceed 100 characters")
            
            normalized_items.append(item)
        
        # Remove duplicates while preserving order
        seen = set()
        unique_items = []
        for item in normalized_items:
            item_lower = item.lower()
            if item_lower not in seen:
                seen.add(item_lower)
                unique_items.append(item)
        
        return unique_items

    @field_validator("special_occasion", "special_notes")
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields by stripping whitespace."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_special_menu_requirements(self) -> "MessMenuBase":
        """
        Validate special menu configuration.
        
        Special menus should have occasion name and at least one meal.
        """
        if self.is_special_menu:
            if not self.special_occasion:
                raise ValueError(
                    "special_occasion is required when is_special_menu is True"
                )
            
            # Special menus should have at least one meal with items
            has_items = any([
                self.breakfast_items,
                self.lunch_items,
                self.snacks_items,
                self.dinner_items,
            ])
            
            if not has_items:
                raise ValueError(
                    "Special menu must have at least one meal with items"
                )
        
        return self

    @model_validator(mode="after")
    def validate_meal_times_sequence(self) -> "MessMenuBase":
        """
        Validate meal times are in logical sequence.
        
        Breakfast < Lunch < Snacks < Dinner
        """
        times = []
        
        if self.breakfast_time:
            times.append(("breakfast", self.breakfast_time))
        if self.lunch_time:
            times.append(("lunch", self.lunch_time))
        if self.snacks_time:
            times.append(("snacks", self.snacks_time))
        if self.dinner_time:
            times.append(("dinner", self.dinner_time))
        
        # Check sequence
        for i in range(len(times) - 1):
            current_meal, current_time = times[i]
            next_meal, next_time = times[i + 1]
            
            if current_time >= next_time:
                raise ValueError(
                    f"{next_meal.capitalize()} time must be after {current_meal} time"
                )
        
        return self

    @model_validator(mode="after")
    def validate_dietary_options(self) -> "MessMenuBase":
        """
        Validate at least one dietary option is available.
        
        Menu must cater to at least one dietary preference.
        """
        if not any([
            self.vegetarian_available,
            self.non_vegetarian_available,
            self.vegan_available,
            self.jain_available,
        ]):
            raise ValueError(
                "At least one dietary option must be available"
            )
        
        return self


class MessMenuCreate(MessMenuBase, BaseCreateSchema):
    """
    Create mess menu with creator tracking.
    
    Extends base schema with creation context and additional validation.
    """

    created_by: UUID = Field(
        ...,
        description="Supervisor/Admin user ID who created the menu",
    )
    
    # Additional creation flags
    auto_publish: bool = Field(
        default=False,
        description="Automatically publish menu after creation",
    )
    send_notification: bool = Field(
        default=True,
        description="Send notification to students about new menu",
    )

    @model_validator(mode="after")
    def validate_menu_completeness(self) -> "MessMenuCreate":
        """
        Validate menu has sufficient items for creation.
        
        At least main meals (breakfast and lunch/dinner) should have items.
        """
        main_meals_count = sum([
            bool(self.breakfast_items),
            bool(self.lunch_items),
            bool(self.dinner_items),
        ])
        
        if main_meals_count < 2:
            raise ValueError(
                "Menu must have items for at least 2 main meals "
                "(breakfast, lunch, or dinner)"
            )
        
        return self


class MessMenuUpdate(BaseUpdateSchema):
    """
    Update mess menu with partial fields.
    
    All fields are optional for flexible updates. Typically used
    to modify draft menus before publication.
    """

    breakfast_items: Optional[List[str]] = Field(
        None,
        max_length=20,
        description="Updated breakfast items",
    )
    lunch_items: Optional[List[str]] = Field(
        None,
        max_length=30,
        description="Updated lunch items",
    )
    snacks_items: Optional[List[str]] = Field(
        None,
        max_length=15,
        description="Updated snacks items",
    )
    dinner_items: Optional[List[str]] = Field(
        None,
        max_length=30,
        description="Updated dinner items",
    )

    breakfast_time: Optional[time] = Field(
        None,
        description="Updated breakfast time",
    )
    lunch_time: Optional[time] = Field(
        None,
        description="Updated lunch time",
    )
    snacks_time: Optional[time] = Field(
        None,
        description="Updated snacks time",
    )
    dinner_time: Optional[time] = Field(
        None,
        description="Updated dinner time",
    )

    is_special_menu: Optional[bool] = Field(
        None,
        description="Updated special menu flag",
    )
    special_occasion: Optional[str] = Field(
        None,
        max_length=255,
        description="Updated special occasion",
    )
    special_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Updated special notes",
    )

    vegetarian_available: Optional[bool] = None
    non_vegetarian_available: Optional[bool] = None
    vegan_available: Optional[bool] = None
    jain_available: Optional[bool] = None

    @field_validator(
        "breakfast_items",
        "lunch_items",
        "snacks_items",
        "dinner_items",
    )
    @classmethod
    def validate_menu_items(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """Validate and normalize menu items if provided."""
        if v is None:
            return None
        
        # Apply same validation as base schema
        normalized_items = []
        for item in v:
            item = item.strip()
            
            if not item:
                continue
            
            if len(item) < 2:
                raise ValueError("Menu items must be at least 2 characters long")
            
            if len(item) > 100:
                raise ValueError("Menu items cannot exceed 100 characters")
            
            normalized_items.append(item)
        
        # Remove duplicates
        seen = set()
        unique_items = []
        for item in normalized_items:
            item_lower = item.lower()
            if item_lower not in seen:
                seen.add(item_lower)
                unique_items.append(item)
        
        return unique_items if unique_items else None

    @field_validator("special_occasion", "special_notes")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\mess_menu_response.py ---
# --- File: app/schemas/mess/mess_menu_response.py ---
"""
Mess menu response schemas for API responses.

Provides various response formats for menu data including
detailed, summary, weekly, and monthly views with computed fields.
"""

from __future__ import annotations

from datetime import date, datetime, time
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, computed_field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import MealType

__all__ = [
    "MenuResponse",
    "MenuDetail",
    "WeeklyMenu",
    "DailyMenuSummary",
    "MonthlyMenu",
    "TodayMenu",
    "MenuListItem",
]


class MenuResponse(BaseResponseSchema):
    """
    Standard menu response with essential information.
    
    Lightweight response schema for list views and basic queries.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    menu_date: date = Field(
        ...,
        description="Menu date",
    )
    day_of_week: str = Field(
        ...,
        description="Day of the week",
    )
    breakfast_items: List[str] = Field(
        default_factory=list,
        description="Breakfast items",
    )
    lunch_items: List[str] = Field(
        default_factory=list,
        description="Lunch items",
    )
    snacks_items: List[str] = Field(
        default_factory=list,
        description="Snacks items",
    )
    dinner_items: List[str] = Field(
        default_factory=list,
        description="Dinner items",
    )
    is_special_menu: bool = Field(
        ...,
        description="Whether this is a special menu",
    )
    special_occasion: Optional[str] = Field(
        None,
        description="Special occasion name",
    )
    is_published: bool = Field(
        ...,
        description="Whether menu is published to students",
    )
    average_rating: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=5,
        description="Average student rating",
    )

    @computed_field
    @property
    def total_items_count(self) -> int:
        """Calculate total number of items across all meals."""
        return (
            len(self.breakfast_items)
            + len(self.lunch_items)
            + len(self.snacks_items)
            + len(self.dinner_items)
        )

    @computed_field
    @property
    def is_complete(self) -> bool:
        """Check if menu has items for all main meals."""
        return bool(
            self.breakfast_items
            and (self.lunch_items or self.dinner_items)
        )


class MenuDetail(BaseResponseSchema):
    """
    Detailed menu information with complete metadata.
    
    Comprehensive response including all menu details, ratings,
    and management information.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    menu_date: date = Field(
        ...,
        description="Menu date",
    )
    day_of_week: str = Field(
        ...,
        description="Day of the week",
    )

    # Meals with timings
    breakfast_items: List[str] = Field(
        default_factory=list,
        description="Breakfast menu items",
    )
    breakfast_time: Optional[time] = Field(
        None,
        description="Breakfast serving time",
    )
    
    lunch_items: List[str] = Field(
        default_factory=list,
        description="Lunch menu items",
    )
    lunch_time: Optional[time] = Field(
        None,
        description="Lunch serving time",
    )
    
    snacks_items: List[str] = Field(
        default_factory=list,
        description="Snacks menu items",
    )
    snacks_time: Optional[time] = Field(
        None,
        description="Snacks serving time",
    )
    
    dinner_items: List[str] = Field(
        default_factory=list,
        description="Dinner menu items",
    )
    dinner_time: Optional[time] = Field(
        None,
        description="Dinner serving time",
    )

    # Dietary options
    vegetarian_available: bool = Field(
        ...,
        description="Vegetarian options available",
    )
    non_vegetarian_available: bool = Field(
        ...,
        description="Non-vegetarian options available",
    )
    vegan_available: bool = Field(
        ...,
        description="Vegan options available",
    )
    jain_available: bool = Field(
        ...,
        description="Jain dietary options available",
    )

    # Special menu information
    is_special_menu: bool = Field(
        ...,
        description="Special menu indicator",
    )
    special_occasion: Optional[str] = Field(
        None,
        description="Special occasion name",
    )
    special_notes: Optional[str] = Field(
        None,
        description="Special menu notes",
    )

    # Management information
    created_by: UUID = Field(
        ...,
        description="Creator user ID",
    )
    created_by_name: str = Field(
        ...,
        description="Creator name",
    )
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )
    
    approved_by: Optional[UUID] = Field(
        None,
        description="Approver user ID",
    )
    approved_by_name: Optional[str] = Field(
        None,
        description="Approver name",
    )
    approved_at: Optional[datetime] = Field(
        None,
        description="Approval timestamp",
    )

    # Publication status
    is_published: bool = Field(
        ...,
        description="Publication status",
    )
    published_at: Optional[datetime] = Field(
        None,
        description="Publication timestamp",
    )
    published_by: Optional[UUID] = Field(
        None,
        description="Publisher user ID",
    )

    # Feedback and ratings
    average_rating: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=5,
        decimal_places=2,
        description="Average rating",
    )
    total_feedback_count: int = Field(
        default=0,
        ge=0,
        description="Total feedback count",
    )
    rating_breakdown: Optional[Dict[str, int]] = Field(
        None,
        description="Rating distribution (1-5 stars)",
    )

    # Metadata
    last_updated: datetime = Field(
        ...,
        description="Last update timestamp",
    )
    last_updated_by: Optional[UUID] = Field(
        None,
        description="Last updater user ID",
    )

    @computed_field
    @property
    def approval_status(self) -> str:
        """Get approval status label."""
        if self.approved_by:
            return "approved"
        elif self.is_published:
            return "published_without_approval"
        else:
            return "pending"

    @computed_field
    @property
    def has_ratings(self) -> bool:
        """Check if menu has received any ratings."""
        return self.total_feedback_count > 0


class DailyMenuSummary(BaseSchema):
    """
    Daily menu summary for weekly/monthly views.
    
    Compact representation of single day's menu for
    calendar and list views.
    """

    menu_id: UUID = Field(
        ...,
        description="Menu unique identifier",
    )
    date: date = Field(
        ...,
        description="Menu date",
    )
    day_of_week: str = Field(
        ...,
        description="Day of the week",
    )
    breakfast: List[str] = Field(
        default_factory=list,
        description="Breakfast items (top 3 shown)",
    )
    lunch: List[str] = Field(
        default_factory=list,
        description="Lunch items (top 3 shown)",
    )
    dinner: List[str] = Field(
        default_factory=list,
        description="Dinner items (top 3 shown)",
    )
    is_special: bool = Field(
        ...,
        description="Special menu indicator",
    )
    special_occasion: Optional[str] = Field(
        None,
        description="Special occasion name",
    )
    average_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average rating",
    )
    is_published: bool = Field(
        default=False,
        description="Publication status",
    )

    @computed_field
    @property
    def has_complete_menu(self) -> bool:
        """Check if menu has all main meals."""
        return bool(self.breakfast and self.lunch and self.dinner)

    @computed_field
    @property
    def rating_stars(self) -> str:
        """Get star rating display string."""
        if self.average_rating is None:
            return "No ratings"
        
        rating = float(self.average_rating)
        full_stars = int(rating)
        half_star = rating - full_stars >= 0.5
        
        stars = "" * full_stars
        if half_star:
            stars += ""
        
        return f"{stars} ({rating:.1f})"


class WeeklyMenu(BaseSchema):
    """
    Weekly menu display with all days.
    
    Provides complete week view for menu planning and
    student information.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    week_number: int = Field(
        ...,
        ge=1,
        le=53,
        description="Week number in year",
    )
    year: int = Field(
        ...,
        ge=2000,
        description="Year",
    )
    week_start_date: date = Field(
        ...,
        description="Week start date (Monday)",
    )
    week_end_date: date = Field(
        ...,
        description="Week end date (Sunday)",
    )
    menus: List[DailyMenuSummary] = Field(
        ...,
        min_length=0,
        max_length=7,
        description="Daily menus for the week",
    )
    total_menus: int = Field(
        default=0,
        ge=0,
        le=7,
        description="Number of menus available",
    )
    special_days_count: int = Field(
        default=0,
        ge=0,
        le=7,
        description="Number of special menus",
    )
    average_weekly_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average rating for the week",
    )

    @computed_field
    @property
    def completion_percentage(self) -> Decimal:
        """Calculate percentage of days with menus."""
        if self.total_menus == 0:
            return Decimal("0.00")
        return round(Decimal(self.total_menus) / Decimal("7") * 100, 2)

    @computed_field
    @property
    def is_complete(self) -> bool:
        """Check if all 7 days have menus."""
        return self.total_menus == 7


class MonthlyMenu(BaseSchema):
    """
    Monthly menu calendar view.
    
    Provides complete month overview with all menus
    and summary statistics.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    month: str = Field(
        ...,
        pattern=r"^\d{4}-(0[1-9]|1[0-2])$",
        description="Month in YYYY-MM format",
    )
    month_name: str = Field(
        ...,
        description="Month name (January, February, etc.)",
    )
    year: int = Field(
        ...,
        ge=2000,
        description="Year",
    )
    menus_by_date: Dict[str, DailyMenuSummary] = Field(
        ...,
        description="Menus indexed by date (YYYY-MM-DD)",
    )
    
    # Summary statistics
    total_days: int = Field(
        ...,
        ge=28,
        le=31,
        description="Total days in month",
    )
    menus_created: int = Field(
        ...,
        ge=0,
        description="Number of menus created",
    )
    menus_published: int = Field(
        default=0,
        ge=0,
        description="Number of published menus",
    )
    special_days: int = Field(
        default=0,
        ge=0,
        description="Number of special occasion menus",
    )
    average_rating: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=5,
        decimal_places=2,
        description="Average monthly rating",
    )
    total_feedbacks: int = Field(
        default=0,
        ge=0,
        description="Total feedback count for month",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate menu completion rate for month."""
        if self.total_days == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.menus_created) / Decimal(self.total_days) * 100,
            2,
        )

    @computed_field
    @property
    def publication_rate(self) -> Decimal:
        """Calculate publication rate."""
        if self.menus_created == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.menus_published) / Decimal(self.menus_created) * 100,
            2,
        )


class TodayMenu(BaseSchema):
    """
    Today's menu for student view.
    
    Simplified, student-friendly view of current day's menu
    with timing and dietary information.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    date: date = Field(
        ...,
        description="Today's date",
    )
    day_of_week: str = Field(
        ...,
        description="Day of the week",
    )

    # Breakfast
    breakfast: List[str] = Field(
        ...,
        description="Breakfast items",
    )
    breakfast_time: str = Field(
        ...,
        description="Breakfast timing (formatted)",
    )
    
    # Lunch
    lunch: List[str] = Field(
        ...,
        description="Lunch items",
    )
    lunch_time: str = Field(
        ...,
        description="Lunch timing (formatted)",
    )
    
    # Snacks
    snacks: List[str] = Field(
        default_factory=list,
        description="Snacks items",
    )
    snacks_time: Optional[str] = Field(
        None,
        description="Snacks timing (formatted)",
    )
    
    # Dinner
    dinner: List[str] = Field(
        ...,
        description="Dinner items",
    )
    dinner_time: str = Field(
        ...,
        description="Dinner timing (formatted)",
    )

    # Special menu
    is_special: bool = Field(
        ...,
        description="Special menu indicator",
    )
    special_occasion: Optional[str] = Field(
        None,
        description="Special occasion name",
    )
    special_message: Optional[str] = Field(
        None,
        description="Special message for students",
    )

    # Dietary information
    dietary_note: Optional[str] = Field(
        None,
        description="Dietary information note",
    )
    allergen_warning: Optional[str] = Field(
        None,
        description="Allergen warning",
    )

    # Student interaction
    can_provide_feedback: bool = Field(
        default=True,
        description="Whether student can provide feedback",
    )
    already_rated: bool = Field(
        default=False,
        description="Whether student has already rated",
    )

    @computed_field
    @property
    def next_meal(self) -> str:
        """Determine next upcoming meal based on current time."""
        from datetime import datetime
        
        current_time = datetime.now().time()
        
        # Parse times (assuming format like "07:30 AM")
        def parse_time(time_str: str) -> time:
            try:
                return datetime.strptime(time_str, "%I:%M %p").time()
            except:
                return time(0, 0)
        
        breakfast_time = parse_time(self.breakfast_time)
        lunch_time = parse_time(self.lunch_time)
        dinner_time = parse_time(self.dinner_time)
        
        if current_time < breakfast_time:
            return "Breakfast"
        elif current_time < lunch_time:
            return "Lunch"
        elif self.snacks_time and current_time < parse_time(self.snacks_time):
            return "Snacks"
        elif current_time < dinner_time:
            return "Dinner"
        else:
            return "Dinner service ended"


class MenuListItem(BaseSchema):
    """
    Minimal menu list item for efficient list rendering.
    
    Optimized for pagination and management list views.
    """

    id: UUID = Field(
        ...,
        description="Menu unique identifier",
    )
    menu_date: date = Field(
        ...,
        description="Menu date",
    )
    day_of_week: str = Field(
        ...,
        description="Day of the week",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    total_items: int = Field(
        ...,
        ge=0,
        description="Total menu items across all meals",
    )
    is_special: bool = Field(
        ...,
        description="Special menu indicator",
    )
    is_published: bool = Field(
        ...,
        description="Publication status",
    )
    average_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average rating",
    )
    feedback_count: int = Field(
        default=0,
        ge=0,
        description="Number of feedbacks",
    )

    @computed_field
    @property
    def status_badge_color(self) -> str:
        """Get status badge color for UI."""
        if self.is_published:
            return "green"
        else:
            return "yellow"

    @computed_field
    @property
    def rating_badge_color(self) -> str:
        """Get rating badge color based on average rating."""
        if self.average_rating is None:
            return "gray"
        
        rating = float(self.average_rating)
        if rating >= 4.5:
            return "green"
        elif rating >= 3.5:
            return "yellow"
        elif rating >= 2.5:
            return "orange"
        else:
            return "red"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\mess\__init__.py ---
# --- File: app/schemas/mess/__init__.py ---
"""
Mess management schemas package.

Comprehensive mess/cafeteria menu management schemas including planning,
feedback, approval workflows, and duplication with enhanced validation.
"""

from __future__ import annotations

from app.schemas.mess.meal_items import (
    AllergenInfo,
    DietaryOptions,
    ItemCategory,
    ItemMasterList,
    MealItems,
    MenuItem,
    NutritionalInfo,
)
from app.schemas.mess.menu_approval import (
    ApprovalHistory,
    ApprovalWorkflow,
    BulkApproval,
    MenuApprovalRequest,
    MenuApprovalResponse,
)
from app.schemas.mess.menu_duplication import (
    BulkMenuCreate,
    CrossHostelDuplication,
    DuplicateMenuRequest,
    DuplicateResponse,
    MenuCloneConfig,
)
from app.schemas.mess.menu_feedback import (
    FeedbackAnalysis,
    FeedbackRequest,
    FeedbackResponse,
    ItemRating,
    QualityMetrics,
    RatingsSummary,
    SentimentAnalysis,
)
from app.schemas.mess.menu_planning import (
    DailyMenuPlan,
    MenuPlanRequest,
    MenuSuggestion,
    MenuTemplate,
    MonthlyPlan,
    SpecialDayMenu,
    SpecialMenu,
    WeeklyPlan,
)
from app.schemas.mess.mess_menu_base import (
    MessMenuBase,
    MessMenuCreate,
    MessMenuUpdate,
)
from app.schemas.mess.mess_menu_response import (
    DailyMenuSummary,
    MenuDetail,
    MenuListItem,
    MenuResponse,
    MonthlyMenu,
    TodayMenu,
    WeeklyMenu,
)

__all__ = [
    # Base schemas
    "MessMenuBase",
    "MessMenuCreate",
    "MessMenuUpdate",
    # Response schemas
    "MenuResponse",
    "MenuDetail",
    "MenuListItem",
    "WeeklyMenu",
    "DailyMenuSummary",
    "MonthlyMenu",
    "TodayMenu",
    # Meal items
    "MealItems",
    "MenuItem",
    "DietaryOptions",
    "NutritionalInfo",
    "AllergenInfo",
    "ItemMasterList",
    "ItemCategory",
    # Planning
    "MenuPlanRequest",
    "WeeklyPlan",
    "DailyMenuPlan",
    "MonthlyPlan",
    "SpecialMenu",
    "SpecialDayMenu",
    "MenuTemplate",
    "MenuSuggestion",
    # Feedback
    "FeedbackRequest",
    "FeedbackResponse",
    "RatingsSummary",
    "ItemRating",
    "QualityMetrics",
    "FeedbackAnalysis",
    "SentimentAnalysis",
    # Approval
    "MenuApprovalRequest",
    "MenuApprovalResponse",
    "ApprovalWorkflow",
    "BulkApproval",
    "ApprovalHistory",
    # Duplication
    "DuplicateMenuRequest",
    "BulkMenuCreate",
    "DuplicateResponse",
    "CrossHostelDuplication",
    "MenuCloneConfig",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\notification =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\notification\all_folders_files_content.txt ---
### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\notification ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\notification =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\notification\email_notification.py ---
"""
Email notification schemas
"""
from datetime import datetime
from typing import List, Optional, Dict
from pydantic import EmailStr, Field, HttpUrl
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class EmailRequest(BaseCreateSchema):
    """Send email notification"""
    recipient_email: EmailStr = Field(..., description="Recipient email address")
    
    # CC and BCC
    cc_emails: List[EmailStr] = Field(default_factory=list)
    bcc_emails: List[EmailStr] = Field(default_factory=list)
    
    # Content
    subject: str = Field(..., min_length=1, max_length=255)
    body_html: str = Field(..., description="HTML email body")
    body_text: Optional[str] = Field(None, description="Plain text fallback")
    
    # Attachments
    attachments: List[HttpUrl] = Field(default_factory=list, description="Attachment URLs")
    
    # Template
    template_code: Optional[str] = None
    template_variables: Optional[Dict[str, str]] = None
    
    # Settings
    reply_to: Optional[EmailStr] = None
    from_name: Optional[str] = Field(None, description="Sender name")
    
    # Tracking
    track_opens: bool = Field(True)
    track_clicks: bool = Field(True)
    
    # Priority
    priority: str = Field("normal", pattern="^(low|normal|high)$")


class EmailConfig(BaseSchema):
    """Email configuration"""
    # SMTP/Service settings
    service_provider: str = Field(..., pattern="^(sendgrid|ses|smtp)$")
    
    smtp_host: Optional[str] = None
    smtp_port: Optional[int] = None
    smtp_username: Optional[str] = None
    
    # From address
    from_email: EmailStr
    from_name: str
    
    # Reply-to
    reply_to_email: Optional[EmailStr] = None
    
    # Rate limiting
    max_emails_per_hour: int = Field(100, ge=1)
    
    # Tracking
    enable_open_tracking: bool = Field(True)
    enable_click_tracking: bool = Field(True)


class EmailTracking(BaseSchema):
    """Email tracking information"""
    email_id: UUID
    recipient_email: str
    
    # Delivery
    sent_at: datetime
    delivered_at: Optional[datetime]
    bounced_at: Optional[datetime]
    
    delivery_status: str = Field(
        ...,
        pattern="^(sent|delivered|bounced|failed|spam)$"
    )
    
    # Engagement
    opened: bool = Field(False)
    first_opened_at: Optional[datetime]
    open_count: int = Field(0)
    
    clicked: bool = Field(False)
    first_clicked_at: Optional[datetime]
    click_count: int = Field(0)
    
    # Errors
    bounce_type: Optional[str] = Field(None, description="hard/soft bounce")
    error_message: Optional[str]


class EmailTemplate(BaseSchema):
    """Email-specific template"""
    template_code: str
    
    subject: str
    html_body: str
    text_body: Optional[str]
    
    # Styling
    header_image_url: Optional[HttpUrl]
    footer_text: Optional[str]
    
    # Variables
    required_variables: List[str]
    optional_variables: List[str] = Field(default_factory=list)


class BulkEmailRequest(BaseCreateSchema):
    """Send bulk emails"""
    recipients: List[EmailStr] = Field(..., min_items=1, max_items=1000)
    
    subject: str
    body_html: str
    
    # Template
    template_code: Optional[str] = None
    
    # Per-recipient variables
    recipient_variables: Optional[Dict[str, Dict[str, str]]] = Field(
        None,
        description="Email -> variable mapping"
    )
    
    # Batch settings
    batch_size: int = Field(100, ge=10, le=1000)
    delay_between_batches_seconds: int = Field(5, ge=1, le=60)


class EmailStats(BaseSchema):
    """Email statistics"""
    total_sent: int
    total_delivered: int
    total_bounced: int
    total_failed: int
    
    delivery_rate: Decimal
    bounce_rate: Decimal
    
    total_opened: int
    open_rate: Decimal
    
    total_clicked: int
    click_rate: Decimal
    
    # By period
    period_start: date
    period_end: date

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\notification\notification_base.py ---
"""
Notification base schemas
"""
from datetime import datetime
from typing import Dict, Any, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseUpdateSchema, BaseSchema
from app.schemas.common.enums import NotificationType, Priority


class NotificationBase(BaseSchema):
    """Base notification schema"""
    recipient_user_id: Optional[UUID] = Field(None, description="Recipient user ID")
    recipient_email: Optional[str] = Field(None, description="Recipient email")
    recipient_phone: Optional[str] = Field(None, description="Recipient phone")
    
    notification_type: NotificationType = Field(..., description="Notification channel")
    
    # Template
    template_code: Optional[str] = Field(None, description="Template code to use")
    
    # Content
    subject: Optional[str] = Field(None, max_length=255, description="Subject/Title")
    message_body: str = Field(..., description="Message content")
    
    # Priority
    priority: Priority = Field(Priority.MEDIUM, description="Delivery priority")
    
    # Schedule
    scheduled_at: Optional[datetime] = Field(None, description="When to send (null = immediate)")
    
    # Metadata
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional context data")
    
    # Related entity
    hostel_id: Optional[UUID] = Field(None, description="Related hostel")


class NotificationCreate(NotificationBase, BaseCreateSchema):
    """Create notification"""
    pass


class NotificationUpdate(BaseUpdateSchema):
    """Update notification (limited fields)"""
    scheduled_at: Optional[datetime] = None
    priority: Optional[Priority] = None
    status: Optional[str] = None


class MarkAsRead(BaseCreateSchema):
    """Mark notification as read"""
    notification_id: UUID
    user_id: UUID


class BulkMarkAsRead(BaseCreateSchema):
    """Mark multiple notifications as read"""
    notification_ids: List[UUID] = Field(..., min_items=1)
    user_id: UUID


class NotificationDelete(BaseCreateSchema):
    """Delete notification"""
    notification_id: UUID
    user_id: UUID
    
    # Soft delete
    permanent: bool = Field(False, description="Permanently delete vs soft delete")

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\notification\notification_preferences.py ---
"""
Notification preferences schemas
"""
from typing import Dict, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseUpdateSchema


class UserPreferences(BaseSchema):
    """User notification preferences"""
    user_id: UUID
    
    # Global settings
    notifications_enabled: bool = Field(True)
    
    # Channel preferences
    email_enabled: bool = Field(True)
    sms_enabled: bool = Field(True)
    push_enabled: bool = Field(True)
    
    # Frequency
    frequency_settings: "FrequencySettings"
    
    # Quiet hours
    quiet_hours_enabled: bool = Field(False)
    quiet_hours_start: Optional[str] = Field(None, description="HH:MM format")
    quiet_hours_end: Optional[str] = Field(None, description="HH:MM format")
    
    # Category preferences
    payment_notifications: bool = Field(True)
    booking_notifications: bool = Field(True)
    complaint_notifications: bool = Field(True)
    announcement_notifications: bool = Field(True)
    maintenance_notifications: bool = Field(True)
    attendance_notifications: bool = Field(True)
    marketing_notifications: bool = Field(False)


class ChannelPreferences(BaseSchema):
    """Channel-specific preferences"""
    user_id: UUID
    
    # Email preferences
    email: "EmailPreferences"
    
    # SMS preferences
    sms: "SMSPreferences"
    
    # Push preferences
    push: "PushPreferences"


class EmailPreferences(BaseSchema):
    """Email notification preferences"""
    enabled: bool = Field(True)
    
    # Digest settings
    daily_digest: bool = Field(False)
    weekly_digest: bool = Field(False)
    
    # Categories
    receive_payment_emails: bool = Field(True)
    receive_booking_emails: bool = Field(True)
    receive_announcement_emails: bool = Field(True)
    receive_marketing_emails: bool = Field(False)


class SMSPreferences(BaseSchema):
    """SMS notification preferences"""
    enabled: bool = Field(True)
    
    # Only critical by default
    urgent_only: bool = Field(True)
    
    # Categories
    receive_payment_sms: bool = Field(True)
    receive_booking_sms: bool = Field(True)
    receive_emergency_sms: bool = Field(True)


class PushPreferences(BaseSchema):
    """Push notification preferences"""
    enabled: bool = Field(True)
    
    # Sound
    sound_enabled: bool = Field(True)
    
    # Badge
    badge_enabled: bool = Field(True)
    
    # Preview
    show_preview: bool = Field(True, description="Show message preview on lock screen")


class FrequencySettings(BaseSchema):
    """Notification frequency settings"""
    # Immediate
    immediate_notifications: bool = Field(True)
    
    # Batching
    batch_notifications: bool = Field(False)
    batch_interval_hours: int = Field(4, ge=1, le=24)
    
    # Digest
    daily_digest_time: Optional[str] = Field(None, description="HH:MM format")
    weekly_digest_day: Optional[str] = Field(None, description="Monday, Tuesday, etc.")


class PreferenceUpdate(BaseUpdateSchema):
    """Update notification preferences"""
    notifications_enabled: Optional[bool] = None
    email_enabled: Optional[bool] = None
    sms_enabled: Optional[bool] = None
    push_enabled: Optional[bool] = None
    
    quiet_hours_enabled: Optional[bool] = None
    quiet_hours_start: Optional[str] = None
    quiet_hours_end: Optional[str] = None
    
    # Category toggles
    payment_notifications: Optional[bool] = None
    booking_notifications: Optional[bool] = None
    complaint_notifications: Optional[bool] = None
    announcement_notifications: Optional[bool] = None
    marketing_notifications: Optional[bool] = None


class UnsubscribeRequest(BaseSchema):
    """Unsubscribe from notifications"""
    user_id: UUID
    unsubscribe_token: str
    
    # What to unsubscribe from
    unsubscribe_type: str = Field(
        ...,
        pattern="^(all|email|sms|marketing|specific_category)$"
    )
    
    category: Optional[str] = None

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\notification\notification_queue.py ---
"""
Notification queue schemas
"""
from datetime import datetime
from typing import Optional, List
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import NotificationType, NotificationStatus, Priority


class QueueStatus(BaseSchema):
    """Notification queue status"""
    total_queued: int
    total_processing: int
    total_failed: int
    
    # By priority
    urgent_queued: int
    high_queued: int
    medium_queued: int
    low_queued: int
    
    # By type
    email_queued: int
    sms_queued: int
    push_queued: int
    
    # Processing rate
    avg_processing_time_seconds: Decimal
    throughput_per_minute: Decimal


class QueuedNotification(BaseSchema):
    """Queued notification details"""
    notification_id: UUID
    
    notification_type: NotificationType
    priority: Priority
    status: NotificationStatus
    
    recipient: str = Field(..., description="Email/phone/user_id")
    
    scheduled_at: Optional[datetime]
    queued_at: datetime
    
    retry_count: int
    max_retries: int
    
    estimated_send_time: Optional[datetime]


class BatchProcessing(BaseSchema):
    """Batch processing status"""
    batch_id: UUID
    
    total_notifications: int
    processed: int
    successful: int
    failed: int
    
    status: str = Field(..., pattern="^(queued|processing|completed|failed)$")
    
    started_at: Optional[datetime]
    completed_at: Optional[datetime]
    
    estimated_completion: Optional[datetime]


class QueueStats(BaseSchema):
    """Queue statistics"""
    # Current state
    current_queue_size: int
    oldest_queued_age_minutes: Optional[int]
    
    # Today's stats
    today_processed: int
    today_successful: int
    today_failed: int
    
    # Rates
    success_rate: Decimal
    failure_rate: Decimal
    
    # Performance
    average_queue_time_minutes: Decimal
    average_processing_time_seconds: Decimal

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\notification\notification_response.py ---
"""
Notification response schemas
"""
from datetime import datetime
from typing import Dict, Any, List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import NotificationType, NotificationStatus


class NotificationResponse(BaseResponseSchema):
    """Notification response"""
    recipient_user_id: Optional[UUID]
    recipient_email: Optional[str]
    recipient_phone: Optional[str]
    
    notification_type: NotificationType
    
    subject: Optional[str]
    message_body: str
    
    priority: str
    status: NotificationStatus
    
    scheduled_at: Optional[datetime]
    sent_at: Optional[datetime]
    
    created_at: datetime


class NotificationDetail(BaseResponseSchema):
    """Detailed notification information"""
    recipient_user_id: Optional[UUID]
    recipient_email: Optional[str]
    recipient_phone: Optional[str]
    
    notification_type: NotificationType
    template_code: Optional[str]
    
    subject: Optional[str]
    message_body: str
    
    priority: str
    status: NotificationStatus
    
    # Schedule
    scheduled_at: Optional[datetime]
    sent_at: Optional[datetime]
    failed_at: Optional[datetime]
    
    # Delivery
    failure_reason: Optional[str]
    retry_count: int
    max_retries: int
    
    # Metadata
    metadata: Dict[str, Any]
    
    # Related
    hostel_id: Optional[UUID]
    
    # Timestamps
    created_at: datetime
    updated_at: datetime


class NotificationList(BaseSchema):
    """List of notifications for user"""
    user_id: UUID
    
    total_notifications: int
    unread_count: int
    
    notifications: List["NotificationListItem"]


class NotificationListItem(BaseSchema):
    """Notification list item"""
    id: UUID
    notification_type: NotificationType
    
    subject: Optional[str]
    message_preview: str = Field(..., description="First 100 characters")
    
    priority: str
    
    is_read: bool = Field(False)
    read_at: Optional[datetime]
    
    created_at: datetime
    
    # Quick actions
    action_url: Optional[str] = Field(None, description="URL to navigate to")
    icon: Optional[str] = Field(None, description="Icon identifier")


class UnreadCount(BaseSchema):
    """Unread notification count"""
    user_id: UUID
    
    total_unread: int
    
    # By type
    email_unread: int
    sms_unread: int
    push_unread: int
    in_app_unread: int
    
    # By priority
    urgent_unread: int
    high_unread: int


class NotificationSummary(BaseSchema):
    """Notification summary for user"""
    user_id: UUID
    
    # Counts
    total_notifications: int
    unread_notifications: int
    
    # Recent
    last_notification_at: Optional[datetime]
    
    # By type
    notifications_by_type: Dict[str, int]
    
    # By status
    notifications_by_status: Dict[str, int]

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\notification\notification_routing.py ---
"""
Notification routing schemas
"""
from typing import List, Optional, Dict
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema
from app.schemas.common.enums import UserRole, Priority


class RoutingConfig(BaseSchema):
    """Notification routing configuration"""
    hostel_id: UUID
    
    # Routing rules
    rules: List["RoutingRule"]
    
    # Escalation settings
    enable_escalation: bool = Field(True)
    escalation_timeout_hours: int = Field(24, ge=1, le=168)


class RoutingRule(BaseSchema):
    """Individual routing rule"""
    rule_name: str
    
    # Condition
    event_type: str = Field(..., description="complaint, payment, maintenance, etc.")
    priority: Optional[Priority] = None
    
    # Recipients
    recipient_roles: List[UserRole]
    specific_users: List[UUID] = Field(default_factory=list)
    
    # Channels
    channels: List[str] = Field(..., description="email, sms, push")
    
    # Active
    is_active: bool = Field(True)


class HierarchicalRouting(BaseSchema):
    """Hierarchical notification routing"""
    hostel_id: UUID
    event_type: str
    
    # Routing chain
    primary_recipients: List[UUID] = Field(..., description="Supervisors")
    secondary_recipients: List[UUID] = Field(default_factory=list, description="Admins")
    tertiary_recipients: List[UUID] = Field(default_factory=list, description="Super admin")
    
    # Escalation timing
    escalate_to_secondary_after_hours: int = Field(24)
    escalate_to_tertiary_after_hours: int = Field(48)


class EscalationRouting(BaseCreateSchema):
    """Escalation routing configuration"""
    notification_id: UUID
    
    # Escalation path
    escalation_chain: List["EscalationLevel"]
    
    # Current level
    current_level: int = Field(0)
    
    # Auto-escalate
    auto_escalate: bool = Field(True)


class EscalationLevel(BaseSchema):
    """Single level in escalation chain"""
    level: int
    recipients: List[UUID]
    escalate_after_hours: int
    channels: List[str]


class NotificationRoute(BaseSchema):
    """Determined notification route"""
    notification_id: UUID
    
    # Recipients
    primary_recipients: List[UUID]
    cc_recipients: List[UUID] = Field(default_factory=list)
    
    # Channels by recipient
    recipient_channels: Dict[UUID, List[str]]
    
    # Escalation
    escalation_enabled: bool
    escalation_path: Optional[List[EscalationLevel]]

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\notification\notification_template.py ---
"""
Notification template schemas
"""
from typing import Dict, List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseUpdateSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import NotificationType


class TemplateCreate(BaseCreateSchema):
    """Create notification template"""
    template_code: str = Field(..., min_length=3, max_length=100, description="Unique template code")
    template_name: str = Field(..., min_length=3, max_length=255, description="Template name")
    
    template_type: NotificationType = Field(..., description="Email, SMS, or Push")
    
    # Content
    subject: Optional[str] = Field(None, max_length=255, description="Subject (for email/push)")
    body_template: str = Field(..., description="Template with {{variable}} placeholders")
    
    # Variables
    variables: List[str] = Field(..., description="List of required variables")
    
    # Settings
    is_active: bool = Field(True)
    
    # Description
    description: Optional[str] = Field(None, max_length=500)


class TemplateUpdate(BaseUpdateSchema):
    """Update template"""
    template_name: Optional[str] = Field(None, min_length=3, max_length=255)
    subject: Optional[str] = None
    body_template: Optional[str] = None
    variables: Optional[List[str]] = None
    is_active: Optional[bool] = None
    description: Optional[str] = None


class TemplateResponse(BaseResponseSchema):
    """Template response"""
    template_code: str
    template_name: str
    template_type: NotificationType
    
    subject: Optional[str]
    body_template: str
    
    variables: List[str]
    
    is_active: bool
    description: Optional[str]
    
    # Usage stats
    usage_count: int = Field(0, description="Times this template has been used")
    last_used_at: Optional[datetime]


class VariableMapping(BaseSchema):
    """Variable mapping for template rendering"""
    template_code: str
    variables: Dict[str, str] = Field(..., description="Variable name -> value mapping")


class TemplatePreview(BaseCreateSchema):
    """Preview rendered template"""
    template_code: str
    variables: Dict[str, str]


class TemplatePreviewResponse(BaseSchema):
    """Rendered template preview"""
    subject: Optional[str]
    rendered_body: str
    
    # Validation
    all_variables_provided: bool
    missing_variables: List[str] = Field(default_factory=list)


class TemplateList(BaseSchema):
    """List of templates"""
    total_templates: int
    active_templates: int
    
    templates: List[TemplateResponse]


class TemplateCategory(BaseSchema):
    """Template category/group"""
    category_name: str
    templates: List[TemplateResponse]

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\notification\push_notification.py ---
"""
Push notification schemas
"""
from datetime import datetime
from typing import Dict, Optional, List, Any
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema
from app.schemas.common.enums import DeviceType


class PushRequest(BaseCreateSchema):
    """Send push notification"""
    # Recipients
    user_id: Optional[UUID] = Field(None, description="Send to all devices of this user")
    device_token: Optional[str] = Field(None, description="Send to specific device")
    device_tokens: Optional[List[str]] = Field(None, description="Send to multiple devices")
    
    # Content
    title: str = Field(..., min_length=1, max_length=100)
    body: str = Field(..., min_length=1, max_length=500)
    
    # Additional data
    data: Dict[str, Any] = Field(default_factory=dict, description="Custom data payload")
    
    # Action
    action_url: Optional[str] = Field(None, description="Deep link or URL to open")
    
    # Appearance
    icon: Optional[str] = None
    image_url: Optional[str] = None
    badge_count: Optional[int] = Field(None, ge=0)
    
    # Sound
    sound: Optional[str] = Field("default", description="Notification sound")
    
    # Priority
    priority: str = Field("normal", pattern="^(low|normal|high)$")
    
    # Time to live
    ttl: int = Field(86400, ge=0, description="Time to live in seconds")


class PushConfig(BaseSchema):
    """Push notification configuration"""
    # Firebase
    firebase_project_id: str
    firebase_server_key: str
    
    # APNs (iOS)
    apns_key_id: Optional[str]
    apns_team_id: Optional[str]
    apns_bundle_id: Optional[str]
    
    # Settings
    collapse_key: Optional[str] = Field(None, description="Notification grouping")
    
    # Badge management
    auto_increment_badge: bool = Field(True)


class DeviceToken(BaseResponseSchema):
    """Device token registration"""
    user_id: UUID
    device_token: str
    device_type: DeviceType
    
    device_name: Optional[str]
    device_model: Optional[str]
    os_version: Optional[str]
    app_version: Optional[str]
    
    is_active: bool
    last_used_at: datetime
    registered_at: datetime


class DeviceRegistration(BaseCreateSchema):
    """Register device for push notifications"""
    user_id: UUID
    device_token: str = Field(..., min_length=10)
    device_type: DeviceType
    
    # Device details
    device_name: Optional[str] = None
    device_model: Optional[str] = None
    os_version: Optional[str] = None
    app_version: Optional[str] = None
    
    # Timezone
    timezone: Optional[str] = Field(None, description="Device timezone")


class DeviceUnregistration(BaseCreateSchema):
    """Unregister device"""
    device_token: str
    user_id: Optional[UUID] = None


class PushTemplate(BaseSchema):
    """Push notification template"""
    template_code: str
    
    title: str
    body: str
    
    # Default settings
    default_icon: Optional[str]
    default_sound: str = Field("default")
    
    # Variables
    required_variables: List[str]
    
    # Actions
    default_action_url: Optional[str]


class PushDeliveryStatus(BaseSchema):
    """Push notification delivery status"""
    notification_id: UUID
    device_token: str
    
    status: str = Field(
        ...,
        pattern="^(queued|sent|delivered|failed|expired)$"
    )
    
    sent_at: Optional[datetime]
    delivered_at: Optional[datetime]
    failed_at: Optional[datetime]
    
    error_code: Optional[str]
    error_message: Optional[str]
    
    # Provider details
    provider_message_id: Optional[str]


class PushStats(BaseSchema):
    """Push notification statistics"""
    total_sent: int
    total_delivered: int
    total_failed: int
    
    delivery_rate: Decimal
    
    # By platform
    ios_sent: int
    android_sent: int
    web_sent: int
    
    # Engagement
    total_opened: int
    open_rate: Decimal
    
    period_start: date
    period_end: date

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\notification\sms_notification.py ---
"""
SMS notification schemas
"""
from datetime import datetime
from typing import Optional, Dict, List
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class SMSRequest(BaseCreateSchema):
    """Send SMS notification"""
    recipient_phone: str = Field(..., pattern=r'^\+?[1-9]\d{9,14}$', description="Phone number")
    
    message: str = Field(..., min_length=1, max_length=160, description="SMS message (160 chars)")
    
    # Template
    template_code: Optional[str] = None
    template_variables: Optional[Dict[str, str]] = None
    
    # Settings
    sender_id: Optional[str] = Field(None, max_length=11, description="Sender ID/Name")
    
    # Priority
    priority: str = Field("normal", pattern="^(low|normal|high)$")
    
    # DLT (India-specific)
    dlt_template_id: Optional[str] = Field(None, description="DLT template ID for India")


class SMSConfig(BaseSchema):
    """SMS configuration"""
    # Service provider
    service_provider: str = Field(..., pattern="^(twilio|aws_sns|msg91|custom)$")
    
    # Credentials
    account_sid: Optional[str] = None
    auth_token: Optional[str] = None
    
    # Sender
    default_sender_id: str = Field(..., max_length=11)
    
    # Rate limiting
    max_sms_per_hour: int = Field(100, ge=1)
    max_sms_per_day: int = Field(1000, ge=1)
    
    # Country settings
    default_country_code: str = Field("+91", description="Default country code")


class DeliveryStatus(BaseSchema):
    """SMS delivery status"""
    sms_id: UUID
    recipient_phone: str
    
    # Status
    status: str = Field(
        ...,
        pattern="^(queued|sent|delivered|failed|undelivered)$"
    )
    
    # Timeline
    queued_at: datetime
    sent_at: Optional[datetime]
    delivered_at: Optional[datetime]
    failed_at: Optional[datetime]
    
    # Error
    error_code: Optional[str]
    error_message: Optional[str]
    
    # Provider details
    provider_message_id: Optional[str]
    segments_count: int = Field(1, description="Number of SMS segments")
    
    # Cost
    cost: Optional[Decimal] = Field(None, description="Cost per SMS")


class SMSTemplate(BaseSchema):
    """SMS template"""
    template_code: str
    message_template: str = Field(..., max_length=160)
    
    # Variables
    required_variables: List[str]
    
    # DLT (India)
    dlt_template_id: Optional[str]
    dlt_approved: bool = Field(False)


class BulkSMSRequest(BaseCreateSchema):
    """Send bulk SMS"""
    recipients: List[str] = Field(
        ...,
        min_items=1,
        max_items=10000,
        description="List of phone numbers"
    )
    
    message: str = Field(..., max_length=160)
    
    # Template
    template_code: Optional[str] = None
    
    # Per-recipient variables
    recipient_variables: Optional[Dict[str, Dict[str, str]]] = None
    
    # Batch settings
    batch_size: int = Field(100, ge=10, le=1000)
    delay_between_batches_seconds: int = Field(2, ge=1, le=10)


class SMSStats(BaseSchema):
    """SMS statistics"""
    total_sent: int
    total_delivered: int
    total_failed: int
    
    delivery_rate: Decimal
    failure_rate: Decimal
    
    # Cost
    total_cost: Decimal
    average_cost_per_sms: Decimal
    
    # Segments
    total_segments: int
    average_segments_per_sms: Decimal
    
    period_start: date
    period_end: date

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\notification\__init__.py ---
"""
Notification schemas package
"""
from app.schemas.notification.notification_base import (
    NotificationBase,
    NotificationCreate,
    NotificationUpdate
)
from app.schemas.notification.notification_response import (
    NotificationResponse,
    NotificationList,
    UnreadCount,
    NotificationDetail
)
from app.schemas.notification.notification_template import (
    TemplateCreate,
    TemplateUpdate,
    TemplateResponse,
    VariableMapping
)
from app.schemas.notification.email_notification import (
    EmailRequest,
    EmailConfig,
    EmailTracking,
    EmailTemplate
)
from app.schemas.notification.sms_notification import (
    SMSRequest,
    SMSConfig,
    DeliveryStatus,
    SMSTemplate
)
from app.schemas.notification.push_notification import (
    PushRequest,
    PushConfig,
    DeviceToken,
    DeviceRegistration,
    PushTemplate
)
from app.schemas.notification.notification_queue import (
    QueueStatus,
    QueuedNotification,
    BatchProcessing,
    QueueStats
)
from app.schemas.notification.notification_preferences import (
    UserPreferences,
    ChannelPreferences,
    FrequencySettings,
    PreferenceUpdate
)
from app.schemas.notification.notification_routing import (
    RoutingConfig,
    HierarchicalRouting,
    EscalationRouting,
    RoutingRule
)

__all__ = [
    # Base
    "NotificationBase",
    "NotificationCreate",
    "NotificationUpdate",
    
    # Response
    "NotificationResponse",
    "NotificationList",
    "UnreadCount",
    "NotificationDetail",
    
    # Template
    "TemplateCreate",
    "TemplateUpdate",
    "TemplateResponse",
    "VariableMapping",
    
    # Email
    "EmailRequest",
    "EmailConfig",
    "EmailTracking",
    "EmailTemplate",
    
    # SMS
    "SMSRequest",
    "SMSConfig",
    "DeliveryStatus",
    "SMSTemplate",
    
    # Push
    "PushRequest",
    "PushConfig",
    "DeviceToken",
    "DeviceRegistration",
    "PushTemplate",
    
    # Queue
    "QueueStatus",
    "QueuedNotification",
    "BatchProcessing",
    "QueueStats",
    
    # Preferences
    "UserPreferences",
    "ChannelPreferences",
    "FrequencySettings",
    "PreferenceUpdate",
    
    # Routing
    "RoutingConfig",
    "HierarchicalRouting",
    "EscalationRouting",
    "RoutingRule",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\notification\email_notification.py ---
# --- File: app/schemas/notification/email_notification.py ---
"""
Email notification schemas.

This module provides schemas for email-specific notifications including
sending, tracking, templates, and bulk operations.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import EmailStr, Field, HttpUrl, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "EmailRequest",
    "EmailConfig",
    "EmailTracking",
    "EmailTemplate",
    "BulkEmailRequest",
    "EmailStats",
    "EmailAttachment",
    "EmailSchedule",
]


class EmailAttachment(BaseSchema):
    """Email attachment details."""

    filename: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Attachment filename",
    )
    url: HttpUrl = Field(
        ...,
        description="URL to attachment file",
    )
    mime_type: Optional[str] = Field(
        None,
        max_length=100,
        description="MIME type of attachment",
    )
    size_bytes: Optional[int] = Field(
        None,
        ge=0,
        le=26214400,  # 25MB max
        description="File size in bytes",
    )


class EmailRequest(BaseCreateSchema):
    """
    Send email notification request.

    Supports both direct content and template-based emails with
    advanced features like CC/BCC, attachments, and tracking.
    """

    # Recipients
    recipient_email: EmailStr = Field(
        ...,
        description="Primary recipient email address",
    )
    cc_emails: List[EmailStr] = Field(
        default_factory=list,
        max_length=10,
        description="CC recipients (max 10)",
    )
    bcc_emails: List[EmailStr] = Field(
        default_factory=list,
        max_length=10,
        description="BCC recipients (max 10)",
    )

    # Content
    subject: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Email subject line",
    )
    body_html: str = Field(
        ...,
        min_length=1,
        max_length=102400,  # 100KB max
        description="HTML email body",
    )
    body_text: Optional[str] = Field(
        None,
        max_length=102400,
        description="Plain text fallback body",
    )

    # Attachments
    attachments: List[EmailAttachment] = Field(
        default_factory=list,
        max_length=10,
        description="Email attachments (max 10)",
    )

    # Template support
    template_code: Optional[str] = Field(
        None,
        min_length=3,
        max_length=100,
        description="Template code (overrides direct content)",
    )
    template_variables: Optional[Dict[str, str]] = Field(
        None,
        description="Variables for template rendering",
    )

    # Sender customization
    reply_to: Optional[EmailStr] = Field(
        None,
        description="Reply-to email address",
    )
    from_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=100,
        description="Sender display name",
    )

    # Tracking settings
    track_opens: bool = Field(
        default=True,
        description="Enable open tracking",
    )
    track_clicks: bool = Field(
        default=True,
        description="Enable click tracking",
    )

    # Priority
    priority: str = Field(
        default="normal",
        pattern="^(low|normal|high)$",
        description="Email priority level",
    )

    # Scheduling
    send_at: Optional[datetime] = Field(
        None,
        description="Schedule email for future delivery",
    )

    # Metadata
    tags: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Tags for categorization and filtering",
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Custom metadata",
    )

    @field_validator("cc_emails", "bcc_emails")
    @classmethod
    def validate_unique_emails(cls, v: List[EmailStr]) -> List[EmailStr]:
        """Ensure email lists don't contain duplicates."""
        if len(v) != len(set(v)):
            raise ValueError("Duplicate email addresses not allowed")
        return v

    @field_validator("send_at")
    @classmethod
    def validate_send_time(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate scheduled send time is in the future."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Scheduled send time must be in the future")
        return v

    @model_validator(mode="after")
    def validate_content_or_template(self) -> "EmailRequest":
        """Ensure either direct content or template is provided."""
        if self.template_code:
            # Template mode - variables should be provided
            if not self.template_variables:
                raise ValueError(
                    "template_variables required when using template_code"
                )
        else:
            # Direct content mode - HTML body is required
            if not self.body_html:
                raise ValueError(
                    "body_html required when not using template_code"
                )
        return self

    @model_validator(mode="after")
    def validate_total_attachments_size(self) -> "EmailRequest":
        """Validate total attachments size doesn't exceed limit."""
        if self.attachments:
            total_size = sum(
                att.size_bytes for att in self.attachments if att.size_bytes
            )
            if total_size > 26214400:  # 25MB total
                raise ValueError("Total attachments size cannot exceed 25MB")
        return self


class EmailConfig(BaseSchema):
    """
    Email service configuration.

    Supports multiple email service providers with unified configuration.
    """

    # Service provider
    service_provider: str = Field(
        ...,
        pattern="^(sendgrid|ses|smtp|mailgun|postmark)$",
        description="Email service provider",
    )

    # SMTP configuration (for SMTP provider)
    smtp_host: Optional[str] = Field(
        None,
        max_length=255,
        description="SMTP server hostname",
    )
    smtp_port: Optional[int] = Field(
        None,
        ge=1,
        le=65535,
        description="SMTP server port",
    )
    smtp_username: Optional[str] = Field(
        None,
        max_length=255,
        description="SMTP authentication username",
    )
    smtp_use_tls: bool = Field(
        default=True,
        description="Use TLS for SMTP connection",
    )

    # API configuration (for API-based providers)
    api_key: Optional[str] = Field(
        None,
        max_length=500,
        description="API key for email service",
    )

    # Sender configuration
    from_email: EmailStr = Field(
        ...,
        description="Default sender email address",
    )
    from_name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Default sender name",
    )
    reply_to_email: Optional[EmailStr] = Field(
        None,
        description="Default reply-to address",
    )

    # Rate limiting
    max_emails_per_hour: int = Field(
        default=100,
        ge=1,
        le=10000,
        description="Maximum emails per hour",
    )
    max_emails_per_day: int = Field(
        default=1000,
        ge=1,
        le=100000,
        description="Maximum emails per day",
    )

    # Tracking defaults
    enable_open_tracking: bool = Field(
        default=True,
        description="Enable open tracking by default",
    )
    enable_click_tracking: bool = Field(
        default=True,
        description="Enable click tracking by default",
    )

    # Bounce handling
    bounce_webhook_url: Optional[HttpUrl] = Field(
        None,
        description="Webhook URL for bounce notifications",
    )

    @model_validator(mode="after")
    def validate_smtp_config(self) -> "EmailConfig":
        """Validate SMTP-specific configuration."""
        if self.service_provider == "smtp":
            if not all([self.smtp_host, self.smtp_port, self.smtp_username]):
                raise ValueError(
                    "SMTP configuration requires host, port, and username"
                )
        return self

    @model_validator(mode="after")
    def validate_api_config(self) -> "EmailConfig":
        """Validate API-based provider configuration."""
        if self.service_provider in ["sendgrid", "ses", "mailgun", "postmark"]:
            if not self.api_key:
                raise ValueError(
                    f"API key required for {self.service_provider}"
                )
        return self


class EmailTracking(BaseSchema):
    """
    Email tracking and delivery information.

    Tracks the complete lifecycle of an email from send to engagement.
    """

    email_id: UUID = Field(
        ...,
        description="Email notification ID",
    )
    recipient_email: EmailStr = Field(
        ...,
        description="Recipient email address",
    )

    # Delivery status
    sent_at: datetime = Field(
        ...,
        description="When email was sent",
    )
    delivered_at: Optional[datetime] = Field(
        None,
        description="When email was delivered",
    )
    bounced_at: Optional[datetime] = Field(
        None,
        description="When email bounced",
    )

    delivery_status: str = Field(
        ...,
        pattern="^(sent|delivered|bounced|failed|spam|rejected)$",
        description="Current delivery status",
    )

    # Engagement tracking
    opened: bool = Field(
        default=False,
        description="Whether email was opened",
    )
    first_opened_at: Optional[datetime] = Field(
        None,
        description="When email was first opened",
    )
    last_opened_at: Optional[datetime] = Field(
        None,
        description="When email was last opened",
    )
    open_count: int = Field(
        default=0,
        ge=0,
        description="Number of times email was opened",
    )

    clicked: bool = Field(
        default=False,
        description="Whether any link was clicked",
    )
    first_clicked_at: Optional[datetime] = Field(
        None,
        description="When first link was clicked",
    )
    last_clicked_at: Optional[datetime] = Field(
        None,
        description="When last link was clicked",
    )
    click_count: int = Field(
        default=0,
        ge=0,
        description="Total number of link clicks",
    )

    # Link-level tracking
    clicked_links: List[str] = Field(
        default_factory=list,
        description="URLs that were clicked",
    )

    # Error information
    bounce_type: Optional[str] = Field(
        None,
        pattern="^(hard|soft|complaint)$",
        description="Type of bounce if bounced",
    )
    error_message: Optional[str] = Field(
        None,
        max_length=1000,
        description="Error or bounce reason",
    )

    # Provider information
    provider_message_id: Optional[str] = Field(
        None,
        max_length=255,
        description="Provider's message ID",
    )

    # Spam reports
    marked_as_spam: bool = Field(
        default=False,
        description="Whether recipient marked as spam",
    )
    spam_reported_at: Optional[datetime] = Field(
        None,
        description="When marked as spam",
    )


class EmailTemplate(BaseSchema):
    """
    Email-specific template configuration.

    Extends base template with email-specific features like
    header images and footer text.
    """

    template_code: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Unique template identifier",
    )

    # Email content
    subject: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Email subject template",
    )
    html_body: str = Field(
        ...,
        min_length=1,
        max_length=102400,
        description="HTML body template",
    )
    text_body: Optional[str] = Field(
        None,
        max_length=102400,
        description="Plain text body template",
    )

    # Styling and branding
    header_image_url: Optional[HttpUrl] = Field(
        None,
        description="Header/logo image URL",
    )
    footer_text: Optional[str] = Field(
        None,
        max_length=1000,
        description="Footer text (company info, unsubscribe link, etc.)",
    )
    primary_color: Optional[str] = Field(
        None,
        pattern="^#[0-9A-Fa-f]{6}$",
        description="Primary brand color (hex code)",
    )

    # Variables
    required_variables: List[str] = Field(
        ...,
        description="Required template variables",
    )
    optional_variables: List[str] = Field(
        default_factory=list,
        description="Optional template variables",
    )

    # Preheader
    preheader_text: Optional[str] = Field(
        None,
        max_length=150,
        description="Email preheader/preview text",
    )


class BulkEmailRequest(BaseCreateSchema):
    """
    Send bulk emails to multiple recipients.

    Optimized for batch sending with per-recipient variable substitution.
    """

    recipients: List[EmailStr] = Field(
        ...,
        min_length=1,
        max_length=1000,
        description="List of recipient email addresses (max 1000)",
    )

    # Content (same for all recipients or use template)
    subject: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Email subject",
    )
    body_html: str = Field(
        ...,
        min_length=1,
        max_length=102400,
        description="HTML email body",
    )

    # Template support
    template_code: Optional[str] = Field(
        None,
        description="Template code for all emails",
    )

    # Per-recipient customization
    recipient_variables: Optional[Dict[EmailStr, Dict[str, str]]] = Field(
        None,
        description="Per-recipient variable mapping (email -> variables)",
    )

    # Batch settings
    batch_size: int = Field(
        default=100,
        ge=10,
        le=1000,
        description="Number of emails per batch",
    )
    delay_between_batches_seconds: int = Field(
        default=5,
        ge=1,
        le=60,
        description="Delay between batches in seconds",
    )

    # Tracking
    track_opens: bool = Field(
        default=True,
        description="Enable open tracking",
    )
    track_clicks: bool = Field(
        default=True,
        description="Enable click tracking",
    )

    # Metadata
    tags: List[str] = Field(
        default_factory=list,
        description="Tags for this bulk send campaign",
    )

    @field_validator("recipients")
    @classmethod
    def validate_unique_recipients(cls, v: List[EmailStr]) -> List[EmailStr]:
        """Ensure recipient list doesn't contain duplicates."""
        if len(v) != len(set(v)):
            raise ValueError("Duplicate email addresses in recipients list")
        return v

    @model_validator(mode="after")
    def validate_recipient_variables(self) -> "BulkEmailRequest":
        """Validate recipient variables match recipients list."""
        if self.recipient_variables:
            # Check all recipients have variables if any are provided
            missing = set(self.recipients) - set(self.recipient_variables.keys())
            if missing:
                raise ValueError(
                    f"Missing variables for recipients: {', '.join(missing)}"
                )
        return self


class EmailStats(BaseSchema):
    """
    Email campaign statistics and metrics.

    Provides comprehensive analytics for email performance.
    """

    # Send statistics
    total_sent: int = Field(
        ...,
        ge=0,
        description="Total emails sent",
    )
    total_delivered: int = Field(
        ...,
        ge=0,
        description="Total emails delivered",
    )
    total_bounced: int = Field(
        ...,
        ge=0,
        description="Total emails bounced",
    )
    total_failed: int = Field(
        ...,
        ge=0,
        description="Total send failures",
    )

    # Delivery rates
    delivery_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Delivery rate percentage",
    )
    bounce_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Bounce rate percentage",
    )

    # Engagement statistics
    total_opened: int = Field(
        ...,
        ge=0,
        description="Total unique opens",
    )
    total_opens: int = Field(
        ...,
        ge=0,
        description="Total opens (including repeats)",
    )
    open_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Open rate percentage",
    )

    total_clicked: int = Field(
        ...,
        ge=0,
        description="Total unique clicks",
    )
    total_clicks: int = Field(
        ...,
        ge=0,
        description="Total clicks (including repeats)",
    )
    click_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Click rate percentage",
    )
    click_to_open_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Click-to-open rate percentage",
    )

    # Spam and complaints
    total_spam_reports: int = Field(
        default=0,
        ge=0,
        description="Number of spam complaints",
    )
    spam_rate: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        le=100,
        description="Spam complaint rate percentage",
    )

    # Unsubscribes
    total_unsubscribed: int = Field(
        default=0,
        ge=0,
        description="Number of unsubscribes",
    )
    unsubscribe_rate: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        le=100,
        description="Unsubscribe rate percentage",
    )

    # Time period
    period_start: date = Field(
        ...,
        description="Statistics period start date",
    )
    period_end: date = Field(
        ...,
        description="Statistics period end date",
    )

    @field_validator("period_end")
    @classmethod
    def validate_period(cls, v: date, info) -> date:
        """Validate period end is after period start."""
        period_start = info.data.get("period_start")
        if period_start and v < period_start:
            raise ValueError("period_end must be after or equal to period_start")
        return v


class EmailSchedule(BaseCreateSchema):
    """
    Schedule an email for future delivery.

    Supports recurring emails and timezone-aware scheduling.
    """

    email_request: EmailRequest = Field(
        ...,
        description="Email to schedule",
    )
    scheduled_for: datetime = Field(
        ...,
        description="When to send the email",
    )
    timezone: str = Field(
        default="UTC",
        description="Timezone for scheduled time",
    )
    is_recurring: bool = Field(
        default=False,
        description="Whether this is a recurring email",
    )
    recurrence_pattern: Optional[str] = Field(
        None,
        pattern="^(daily|weekly|monthly|yearly)$",
        description="Recurrence pattern if recurring",
    )
    recurrence_end_date: Optional[date] = Field(
        None,
        description="When to stop recurring",
    )

    @field_validator("scheduled_for")
    @classmethod
    def validate_scheduled_time(cls, v: datetime) -> datetime:
        """Validate scheduled time is in the future."""
        if v <= datetime.utcnow():
            raise ValueError("Scheduled time must be in the future")
        return v

    @model_validator(mode="after")
    def validate_recurrence(self) -> "EmailSchedule":
        """Validate recurrence configuration."""
        if self.is_recurring:
            if not self.recurrence_pattern:
                raise ValueError(
                    "recurrence_pattern required for recurring emails"
                )
            if not self.recurrence_end_date:
                raise ValueError(
                    "recurrence_end_date required for recurring emails"
                )
            if self.recurrence_end_date <= date.today():
                raise ValueError(
                    "recurrence_end_date must be in the future"
                )
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\notification\notification_base.py ---
# --- File: app/schemas/notification/notification_base.py ---
"""
Notification base schemas.

This module provides core notification schemas for creating, updating,
and managing notifications across different channels (email, SMS, push).
"""

from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import NotificationType, Priority

__all__ = [
    "NotificationBase",
    "NotificationCreate",
    "NotificationUpdate",
    "MarkAsRead",
    "BulkMarkAsRead",
    "NotificationDelete",
]


class NotificationBase(BaseSchema):
    """
    Base notification schema with common fields.

    Contains recipient information, content, priority, and scheduling options
    for notifications across all channels.
    """

    # Recipient information (at least one must be provided)
    recipient_user_id: Optional[UUID] = Field(
        None,
        description="Recipient user ID for user-based routing",
    )
    recipient_email: Optional[str] = Field(
        None,
        description="Recipient email address for email notifications",
    )
    recipient_phone: Optional[str] = Field(
        None,
        description="Recipient phone number for SMS notifications",
    )

    # Notification channel
    notification_type: NotificationType = Field(
        ...,
        description="Notification delivery channel (email/sms/push)",
    )

    # Template support
    template_code: Optional[str] = Field(
        None,
        min_length=3,
        max_length=100,
        description="Template code for pre-defined notification templates",
    )

    # Content
    subject: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Notification subject/title (required for email and push)",
    )
    message_body: str = Field(
        ...,
        min_length=1,
        max_length=5000,
        description="Notification message content",
    )

    # Priority and scheduling
    priority: Priority = Field(
        default=Priority.MEDIUM,
        description="Notification delivery priority",
    )
    scheduled_at: Optional[datetime] = Field(
        None,
        description="Scheduled delivery time (null for immediate delivery)",
    )

    # Metadata and context
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional context data for the notification",
    )

    # Related entity
    hostel_id: Optional[UUID] = Field(
        None,
        description="Associated hostel ID for hostel-specific notifications",
    )

    @field_validator("recipient_email")
    @classmethod
    def validate_email(cls, v: Optional[str]) -> Optional[str]:
        """Validate email format if provided."""
        if v is not None:
            # Basic email validation
            import re
            email_pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
            if not re.match(email_pattern, v):
                raise ValueError("Invalid email format")
        return v

    @field_validator("recipient_phone")
    @classmethod
    def validate_phone(cls, v: Optional[str]) -> Optional[str]:
        """Validate phone number format if provided."""
        if v is not None:
            import re
            # International phone number pattern
            phone_pattern = r"^\+?[1-9]\d{9,14}$"
            if not re.match(phone_pattern, v):
                raise ValueError(
                    "Invalid phone number format. Must be 10-15 digits, optionally starting with +"
                )
        return v

    @field_validator("scheduled_at")
    @classmethod
    def validate_scheduled_time(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate scheduled time is in the future."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Scheduled time must be in the future")
        return v

    @model_validator(mode="after")
    def validate_recipients(self) -> "NotificationBase":
        """Ensure at least one recipient identifier is provided."""
        if not any([
            self.recipient_user_id,
            self.recipient_email,
            self.recipient_phone,
        ]):
            raise ValueError(
                "At least one recipient identifier (user_id, email, or phone) must be provided"
            )
        return self

    @model_validator(mode="after")
    def validate_subject_requirement(self) -> "NotificationBase":
        """Validate subject is provided for email and push notifications."""
        if self.notification_type in [NotificationType.EMAIL, NotificationType.PUSH]:
            if not self.subject:
                raise ValueError(
                    f"Subject is required for {self.notification_type.value} notifications"
                )
        return self

    @model_validator(mode="after")
    def validate_message_length(self) -> "NotificationBase":
        """Validate message length based on notification type."""
        if self.notification_type == NotificationType.SMS:
            # SMS has stricter length limits
            if len(self.message_body) > 1600:  # 10 segments max
                raise ValueError(
                    "SMS message body cannot exceed 1600 characters (10 segments)"
                )
        return self


class NotificationCreate(NotificationBase, BaseCreateSchema):
    """
    Schema for creating a new notification.

    Inherits all fields from NotificationBase with creation-specific validation.
    """

    @field_validator("metadata")
    @classmethod
    def validate_metadata_size(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        """Ensure metadata doesn't exceed reasonable size."""
        import json
        if len(json.dumps(v)) > 10000:  # 10KB limit
            raise ValueError("Metadata size cannot exceed 10KB")
        return v


class NotificationUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing notification.

    Only allows updating limited fields: scheduling, priority, and status.
    Content updates are not permitted to maintain audit trail.
    """

    scheduled_at: Optional[datetime] = Field(
        None,
        description="Update scheduled delivery time",
    )
    priority: Optional[Priority] = Field(
        None,
        description="Update notification priority",
    )
    status: Optional[str] = Field(
        None,
        pattern="^(queued|processing|sent|delivered|failed|cancelled)$",
        description="Update notification status",
    )

    @field_validator("scheduled_at")
    @classmethod
    def validate_scheduled_time(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate scheduled time is in the future if provided."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Scheduled time must be in the future")
        return v

    @model_validator(mode="after")
    def validate_at_least_one_field(self) -> "NotificationUpdate":
        """Ensure at least one field is being updated."""
        if not any([self.scheduled_at, self.priority, self.status]):
            raise ValueError("At least one field must be provided for update")
        return self


class MarkAsRead(BaseCreateSchema):
    """Schema for marking a notification as read by a user."""

    notification_id: UUID = Field(
        ...,
        description="ID of the notification to mark as read",
    )
    user_id: UUID = Field(
        ...,
        description="ID of the user marking the notification as read",
    )
    read_at: Optional[datetime] = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when the notification was read",
    )


class BulkMarkAsRead(BaseCreateSchema):
    """Schema for marking multiple notifications as read in a single operation."""

    notification_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of notification IDs to mark as read (max 100)",
    )
    user_id: UUID = Field(
        ...,
        description="ID of the user marking notifications as read",
    )
    read_at: Optional[datetime] = Field(
        default_factory=datetime.utcnow,
        description="Timestamp for all read operations",
    )

    @field_validator("notification_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[UUID]) -> List[UUID]:
        """Ensure notification IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Duplicate notification IDs are not allowed")
        return v


class NotificationDelete(BaseCreateSchema):
    """
    Schema for deleting a notification.

    Supports both soft delete (default) and permanent deletion.
    """

    notification_id: UUID = Field(
        ...,
        description="ID of the notification to delete",
    )
    user_id: UUID = Field(
        ...,
        description="ID of the user performing the deletion",
    )
    permanent: bool = Field(
        default=False,
        description="If True, permanently delete; if False, soft delete",
    )
    deletion_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for deletion (optional, for audit purposes)",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\notification\notification_preferences.py ---
# --- File: app/schemas/notification/notification_preferences.py ---
"""
Notification preferences schemas.

This module provides schemas for managing user notification preferences
including channel selection, frequency settings, and quiet hours.
"""

from __future__ import annotations

from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseSchema, BaseUpdateSchema

__all__ = [
    "UserPreferences",
    "ChannelPreferences",
    "EmailPreferences",
    "SMSPreferences",
    "PushPreferences",
    "FrequencySettings",
    "PreferenceUpdate",
    "UnsubscribeRequest",
    "QuietHours",
]


class FrequencySettings(BaseSchema):
    """
    Notification frequency settings.

    Controls how often and when notifications are delivered.
    """

    # Delivery mode
    immediate_notifications: bool = Field(
        default=True,
        description="Send notifications immediately",
    )

    # Batching
    batch_notifications: bool = Field(
        default=False,
        description="Batch notifications instead of immediate delivery",
    )
    batch_interval_hours: int = Field(
        default=4,
        ge=1,
        le=24,
        description="Hours between batched notifications",
    )

    # Digest
    daily_digest_enabled: bool = Field(
        default=False,
        description="Enable daily digest",
    )
    daily_digest_time: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Daily digest time in HH:MM format (24-hour)",
    )

    weekly_digest_enabled: bool = Field(
        default=False,
        description="Enable weekly digest",
    )
    weekly_digest_day: Optional[str] = Field(
        None,
        pattern="^(monday|tuesday|wednesday|thursday|friday|saturday|sunday)$",
        description="Day for weekly digest",
    )
    weekly_digest_time: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Weekly digest time in HH:MM format",
    )

    @model_validator(mode="after")
    def validate_digest_settings(self) -> "FrequencySettings":
        """Validate digest configuration."""
        if self.daily_digest_enabled and not self.daily_digest_time:
            raise ValueError("daily_digest_time required when daily digest is enabled")

        if self.weekly_digest_enabled:
            if not self.weekly_digest_day or not self.weekly_digest_time:
                raise ValueError(
                    "weekly_digest_day and weekly_digest_time required when weekly digest is enabled"
                )

        return self


class QuietHours(BaseSchema):
    """
    Quiet hours configuration.

    Defines time periods when notifications should not be sent.
    """

    enabled: bool = Field(
        default=False,
        description="Enable quiet hours",
    )

    start_time: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Quiet hours start time (HH:MM, 24-hour format)",
    )
    end_time: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Quiet hours end time (HH:MM, 24-hour format)",
    )

    # Days of week
    apply_on_weekdays: bool = Field(
        default=True,
        description="Apply quiet hours on weekdays",
    )
    apply_on_weekends: bool = Field(
        default=True,
        description="Apply quiet hours on weekends",
    )

    # Exceptions
    allow_urgent: bool = Field(
        default=True,
        description="Allow urgent/critical notifications during quiet hours",
    )

    # Timezone
    timezone: str = Field(
        default="UTC",
        max_length=100,
        description="Timezone for quiet hours",
    )

    @model_validator(mode="after")
    def validate_quiet_hours(self) -> "QuietHours":
        """Validate quiet hours configuration."""
        if self.enabled:
            if not self.start_time or not self.end_time:
                raise ValueError(
                    "start_time and end_time required when quiet hours are enabled"
                )
        return self


class EmailPreferences(BaseSchema):
    """
    Email notification preferences.

    Fine-grained control over email notifications.
    """

    enabled: bool = Field(
        default=True,
        description="Enable email notifications",
    )

    # Digest settings
    daily_digest: bool = Field(
        default=False,
        description="Receive daily digest email",
    )
    weekly_digest: bool = Field(
        default=False,
        description="Receive weekly digest email",
    )

    # Category preferences
    receive_payment_emails: bool = Field(
        default=True,
        description="Receive payment-related emails",
    )
    receive_booking_emails: bool = Field(
        default=True,
        description="Receive booking-related emails",
    )
    receive_complaint_emails: bool = Field(
        default=True,
        description="Receive complaint-related emails",
    )
    receive_announcement_emails: bool = Field(
        default=True,
        description="Receive announcement emails",
    )
    receive_maintenance_emails: bool = Field(
        default=True,
        description="Receive maintenance notification emails",
    )
    receive_marketing_emails: bool = Field(
        default=False,
        description="Receive marketing and promotional emails",
    )

    # Format preferences
    html_emails: bool = Field(
        default=True,
        description="Receive HTML formatted emails",
    )
    text_emails_fallback: bool = Field(
        default=True,
        description="Include plain text fallback",
    )


class SMSPreferences(BaseSchema):
    """
    SMS notification preferences.

    Control over SMS delivery with cost considerations.
    """

    enabled: bool = Field(
        default=True,
        description="Enable SMS notifications",
    )

    # Filtering
    urgent_only: bool = Field(
        default=True,
        description="Only receive urgent/high priority SMS",
    )

    # Category preferences
    receive_payment_sms: bool = Field(
        default=True,
        description="Receive payment-related SMS",
    )
    receive_booking_sms: bool = Field(
        default=True,
        description="Receive booking-related SMS",
    )
    receive_emergency_sms: bool = Field(
        default=True,
        description="Receive emergency SMS",
    )
    receive_otp_sms: bool = Field(
        default=True,
        description="Receive OTP and verification SMS",
    )

    # Frequency limits
    max_sms_per_day: int = Field(
        default=10,
        ge=1,
        le=50,
        description="Maximum SMS per day",
    )


class PushPreferences(BaseSchema):
    """
    Push notification preferences.

    Control over mobile and web push notifications.
    """

    enabled: bool = Field(
        default=True,
        description="Enable push notifications",
    )

    # Sound and alerts
    sound_enabled: bool = Field(
        default=True,
        description="Play notification sound",
    )
    vibration_enabled: bool = Field(
        default=True,
        description="Enable vibration",
    )

    # Badge
    badge_enabled: bool = Field(
        default=True,
        description="Show badge count on app icon",
    )

    # Preview
    show_preview: bool = Field(
        default=True,
        description="Show message preview on lock screen",
    )

    # Lock screen
    show_on_lock_screen: bool = Field(
        default=True,
        description="Show notifications on lock screen",
    )

    # Category preferences
    receive_payment_push: bool = Field(
        default=True,
        description="Receive payment push notifications",
    )
    receive_booking_push: bool = Field(
        default=True,
        description="Receive booking push notifications",
    )
    receive_complaint_push: bool = Field(
        default=True,
        description="Receive complaint push notifications",
    )
    receive_announcement_push: bool = Field(
        default=True,
        description="Receive announcement push notifications",
    )


class ChannelPreferences(BaseSchema):
    """
    Channel-specific notification preferences.

    Aggregates preferences for all notification channels.
    """

    user_id: UUID = Field(
        ...,
        description="User ID",
    )

    # Email preferences
    email: EmailPreferences = Field(
        default_factory=EmailPreferences,
        description="Email notification preferences",
    )

    # SMS preferences
    sms: SMSPreferences = Field(
        default_factory=SMSPreferences,
        description="SMS notification preferences",
    )

    # Push preferences
    push: PushPreferences = Field(
        default_factory=PushPreferences,
        description="Push notification preferences",
    )


class UserPreferences(BaseSchema):
    """
    Complete user notification preferences.

    Master preferences including global settings, channel preferences,
    and scheduling options.
    """

    user_id: UUID = Field(
        ...,
        description="User ID",
    )

    # Global settings
    notifications_enabled: bool = Field(
        default=True,
        description="Master notification toggle",
    )

    # Channel toggles
    email_enabled: bool = Field(
        default=True,
        description="Enable email notifications",
    )
    sms_enabled: bool = Field(
        default=True,
        description="Enable SMS notifications",
    )
    push_enabled: bool = Field(
        default=True,
        description="Enable push notifications",
    )

    # Frequency
    frequency_settings: FrequencySettings = Field(
        default_factory=FrequencySettings,
        description="Notification frequency settings",
    )

    # Quiet hours
    quiet_hours: QuietHours = Field(
        default_factory=QuietHours,
        description="Quiet hours configuration",
    )

    # Category preferences (global overrides)
    payment_notifications: bool = Field(
        default=True,
        description="Receive payment notifications",
    )
    booking_notifications: bool = Field(
        default=True,
        description="Receive booking notifications",
    )
    complaint_notifications: bool = Field(
        default=True,
        description="Receive complaint notifications",
    )
    announcement_notifications: bool = Field(
        default=True,
        description="Receive announcement notifications",
    )
    maintenance_notifications: bool = Field(
        default=True,
        description="Receive maintenance notifications",
    )
    attendance_notifications: bool = Field(
        default=True,
        description="Receive attendance notifications",
    )
    marketing_notifications: bool = Field(
        default=False,
        description="Receive marketing notifications",
    )

    # Language
    preferred_language: str = Field(
        default="en",
        min_length=2,
        max_length=5,
        description="Preferred language for notifications",
    )

    # Timezone
    timezone: str = Field(
        default="UTC",
        max_length=100,
        description="User timezone for scheduling",
    )


class PreferenceUpdate(BaseUpdateSchema):
    """
    Update notification preferences.

    Allows partial updates to user preferences.
    """

    # Global toggles
    notifications_enabled: Optional[bool] = Field(
        None,
        description="Update master notification toggle",
    )
    email_enabled: Optional[bool] = Field(
        None,
        description="Update email notifications",
    )
    sms_enabled: Optional[bool] = Field(
        None,
        description="Update SMS notifications",
    )
    push_enabled: Optional[bool] = Field(
        None,
        description="Update push notifications",
    )

    # Quiet hours
    quiet_hours_enabled: Optional[bool] = Field(
        None,
        description="Enable/disable quiet hours",
    )
    quiet_hours_start: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Update quiet hours start time",
    )
    quiet_hours_end: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Update quiet hours end time",
    )

    # Category toggles
    payment_notifications: Optional[bool] = None
    booking_notifications: Optional[bool] = None
    complaint_notifications: Optional[bool] = None
    announcement_notifications: Optional[bool] = None
    maintenance_notifications: Optional[bool] = None
    attendance_notifications: Optional[bool] = None
    marketing_notifications: Optional[bool] = None

    # Frequency
    immediate_notifications: Optional[bool] = None
    batch_notifications: Optional[bool] = None
    daily_digest_enabled: Optional[bool] = None
    weekly_digest_enabled: Optional[bool] = None

    # Language and timezone
    preferred_language: Optional[str] = Field(
        None,
        min_length=2,
        max_length=5,
        description="Update preferred language",
    )
    timezone: Optional[str] = Field(
        None,
        max_length=100,
        description="Update timezone",
    )


class UnsubscribeRequest(BaseSchema):
    """
    Unsubscribe from notifications.

    Allows users to opt-out of specific notification types.
    """

    user_id: UUID = Field(
        ...,
        description="User ID to unsubscribe",
    )
    unsubscribe_token: str = Field(
        ...,
        min_length=32,
        max_length=128,
        description="Secure unsubscribe token",
    )

    # What to unsubscribe from
    unsubscribe_type: str = Field(
        ...,
        pattern="^(all|email|sms|push|marketing|specific_category)$",
        description="Type of unsubscription",
    )

    # Category (if specific_category)
    category: Optional[str] = Field(
        None,
        max_length=100,
        description="Specific category to unsubscribe from",
    )

    # Reason
    reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for unsubscribing (optional)",
    )

    @model_validator(mode="after")
    def validate_category_requirement(self) -> "UnsubscribeRequest":
        """Validate category is provided when needed."""
        if self.unsubscribe_type == "specific_category" and not self.category:
            raise ValueError(
                "category required when unsubscribe_type is 'specific_category'"
            )
        return self

    @field_validator("unsubscribe_token")
    @classmethod
    def validate_token_format(cls, v: str) -> str:
        """Validate token is alphanumeric."""
        if not v.replace("-", "").replace("_", "").isalnum():
            raise ValueError("Invalid unsubscribe token format")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\notification\notification_queue.py ---
# --- File: app/schemas/notification/notification_queue.py ---
"""
Notification queue schemas.

This module provides schemas for managing notification queues, batch
processing, and monitoring queue performance and health.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import NotificationStatus, NotificationType, Priority

__all__ = [
    "QueueStatus",
    "QueuedNotification",
    "BatchProcessing",
    "QueueStats",
    "QueueHealth",
    "QueuePriority",
]


class QueueStatus(BaseSchema):
    """
    Current notification queue status.

    Provides real-time overview of queue state across all channels
    and priorities.
    """

    # Overall queue counts
    total_queued: int = Field(
        ...,
        ge=0,
        description="Total notifications in queue",
    )
    total_processing: int = Field(
        ...,
        ge=0,
        description="Notifications currently being processed",
    )
    total_failed: int = Field(
        ...,
        ge=0,
        description="Failed notifications awaiting retry",
    )

    # By priority
    urgent_queued: int = Field(
        default=0,
        ge=0,
        description="Urgent/critical priority notifications queued",
    )
    high_queued: int = Field(
        default=0,
        ge=0,
        description="High priority notifications queued",
    )
    medium_queued: int = Field(
        default=0,
        ge=0,
        description="Medium priority notifications queued",
    )
    low_queued: int = Field(
        default=0,
        ge=0,
        description="Low priority notifications queued",
    )

    # By notification type
    email_queued: int = Field(
        default=0,
        ge=0,
        description="Email notifications queued",
    )
    sms_queued: int = Field(
        default=0,
        ge=0,
        description="SMS notifications queued",
    )
    push_queued: int = Field(
        default=0,
        ge=0,
        description="Push notifications queued",
    )

    # Processing performance
    avg_processing_time_seconds: Decimal = Field(
        ...,
        ge=0,
        description="Average processing time per notification",
    )
    throughput_per_minute: Decimal = Field(
        ...,
        ge=0,
        description="Notifications processed per minute",
    )

    # Queue health
    is_healthy: bool = Field(
        ...,
        description="Whether queue is operating normally",
    )
    oldest_queued_age_minutes: Optional[int] = Field(
        None,
        ge=0,
        description="Age of oldest queued notification in minutes",
    )

    # Timestamp
    checked_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When status was checked",
    )

    @computed_field
    @property
    def total_in_system(self) -> int:
        """Calculate total notifications in the system."""
        return self.total_queued + self.total_processing + self.total_failed

    @computed_field
    @property
    def queue_utilization_percent(self) -> float:
        """Calculate queue utilization as a percentage."""
        # Assuming a max queue size (configurable)
        max_queue_size = 10000
        if self.total_queued == 0:
            return 0.0
        return round((self.total_queued / max_queue_size) * 100, 2)


class QueuedNotification(BaseSchema):
    """
    Individual queued notification details.

    Represents a notification waiting in queue for processing.
    """

    notification_id: UUID = Field(
        ...,
        description="Notification ID",
    )

    # Notification details
    notification_type: NotificationType = Field(
        ...,
        description="Notification channel",
    )
    priority: Priority = Field(
        ...,
        description="Delivery priority",
    )
    status: NotificationStatus = Field(
        ...,
        description="Current status",
    )

    # Recipient
    recipient: str = Field(
        ...,
        max_length=255,
        description="Recipient identifier (email/phone/user_id)",
    )

    # Timing
    scheduled_at: Optional[datetime] = Field(
        None,
        description="Scheduled delivery time",
    )
    queued_at: datetime = Field(
        ...,
        description="When notification was queued",
    )
    processing_started_at: Optional[datetime] = Field(
        None,
        description="When processing started",
    )

    # Retry information
    retry_count: int = Field(
        default=0,
        ge=0,
        description="Number of retry attempts",
    )
    max_retries: int = Field(
        default=3,
        ge=0,
        description="Maximum allowed retries",
    )
    next_retry_at: Optional[datetime] = Field(
        None,
        description="When next retry will be attempted",
    )

    # Estimates
    estimated_send_time: Optional[datetime] = Field(
        None,
        description="Estimated send time based on queue position",
    )
    queue_position: Optional[int] = Field(
        None,
        ge=1,
        description="Position in queue (by priority)",
    )

    # Error tracking
    last_error: Optional[str] = Field(
        None,
        max_length=500,
        description="Last error message if failed",
    )

    @computed_field
    @property
    def age_minutes(self) -> int:
        """Calculate how long notification has been in queue."""
        return int((datetime.utcnow() - self.queued_at).total_seconds() / 60)

    @computed_field
    @property
    def can_retry(self) -> bool:
        """Check if notification can be retried."""
        return (
            self.status == NotificationStatus.FAILED
            and self.retry_count < self.max_retries
        )


class BatchProcessing(BaseSchema):
    """
    Batch processing status and progress.

    Tracks bulk notification sends with detailed progress metrics.
    """

    batch_id: UUID = Field(
        ...,
        description="Unique batch identifier",
    )

    # Batch details
    batch_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Batch/campaign name",
    )
    notification_type: NotificationType = Field(
        ...,
        description="Type of notifications in batch",
    )

    # Counts
    total_notifications: int = Field(
        ...,
        ge=1,
        description="Total notifications in batch",
    )
    processed: int = Field(
        ...,
        ge=0,
        description="Notifications processed so far",
    )
    successful: int = Field(
        ...,
        ge=0,
        description="Successfully sent notifications",
    )
    failed: int = Field(
        ...,
        ge=0,
        description="Failed notifications",
    )
    pending: int = Field(
        ...,
        ge=0,
        description="Notifications still pending",
    )

    # Status
    status: str = Field(
        ...,
        pattern="^(queued|processing|paused|completed|failed|cancelled)$",
        description="Batch processing status",
    )

    # Timing
    created_at: datetime = Field(
        ...,
        description="When batch was created",
    )
    started_at: Optional[datetime] = Field(
        None,
        description="When processing started",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="When processing completed",
    )

    # Estimates
    estimated_completion: Optional[datetime] = Field(
        None,
        description="Estimated completion time",
    )
    estimated_duration_seconds: Optional[int] = Field(
        None,
        ge=0,
        description="Estimated total duration",
    )

    # Performance
    current_throughput_per_minute: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        description="Current processing rate",
    )
    average_processing_time_seconds: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        description="Average time per notification",
    )

    # Error summary
    error_summary: Optional[str] = Field(
        None,
        max_length=1000,
        description="Summary of errors encountered",
    )

    @computed_field
    @property
    def progress_percentage(self) -> float:
        """Calculate batch progress percentage."""
        if self.total_notifications == 0:
            return 0.0
        return round((self.processed / self.total_notifications) * 100, 2)

    @computed_field
    @property
    def success_rate(self) -> float:
        """Calculate success rate percentage."""
        if self.processed == 0:
            return 0.0
        return round((self.successful / self.processed) * 100, 2)

    @computed_field
    @property
    def failure_rate(self) -> float:
        """Calculate failure rate percentage."""
        if self.processed == 0:
            return 0.0
        return round((self.failed / self.processed) * 100, 2)

    @computed_field
    @property
    def is_complete(self) -> bool:
        """Check if batch processing is complete."""
        return self.status in ["completed", "failed", "cancelled"]


class QueueStats(BaseSchema):
    """
    Comprehensive queue statistics.

    Provides historical and current performance metrics for the
    notification queue system.
    """

    # Current state
    current_queue_size: int = Field(
        ...,
        ge=0,
        description="Current number of queued notifications",
    )
    oldest_queued_age_minutes: Optional[int] = Field(
        None,
        ge=0,
        description="Age of oldest notification in queue",
    )

    # Today's statistics
    today_processed: int = Field(
        ...,
        ge=0,
        description="Notifications processed today",
    )
    today_successful: int = Field(
        ...,
        ge=0,
        description="Successful notifications today",
    )
    today_failed: int = Field(
        ...,
        ge=0,
        description="Failed notifications today",
    )

    # Success/failure rates
    success_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall success rate percentage",
    )
    failure_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall failure rate percentage",
    )

    # Performance metrics
    average_queue_time_minutes: Decimal = Field(
        ...,
        ge=0,
        description="Average time notifications spend in queue",
    )
    average_processing_time_seconds: Decimal = Field(
        ...,
        ge=0,
        description="Average processing time per notification",
    )
    average_total_time_seconds: Decimal = Field(
        ...,
        ge=0,
        description="Average total time from queue to delivery",
    )

    # Throughput
    current_throughput_per_minute: Decimal = Field(
        ...,
        ge=0,
        description="Current processing throughput",
    )
    peak_throughput_per_minute: Decimal = Field(
        ...,
        ge=0,
        description="Peak throughput achieved today",
    )
    average_throughput_per_minute: Decimal = Field(
        ...,
        ge=0,
        description="Average throughput",
    )

    # By type breakdown
    email_processed_today: int = Field(default=0, ge=0)
    sms_processed_today: int = Field(default=0, ge=0)
    push_processed_today: int = Field(default=0, ge=0)

    # By priority breakdown
    urgent_processed_today: int = Field(default=0, ge=0)
    high_processed_today: int = Field(default=0, ge=0)
    medium_processed_today: int = Field(default=0, ge=0)
    low_processed_today: int = Field(default=0, ge=0)

    # Retry statistics
    total_retries_today: int = Field(
        default=0,
        ge=0,
        description="Total retry attempts today",
    )
    retry_success_rate: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        le=100,
        description="Percentage of retries that succeeded",
    )

    # Worker health
    active_workers: int = Field(
        ...,
        ge=0,
        description="Number of active queue workers",
    )
    idle_workers: int = Field(
        ...,
        ge=0,
        description="Number of idle workers",
    )

    # Timestamp
    stats_generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When statistics were generated",
    )

    @computed_field
    @property
    def total_workers(self) -> int:
        """Calculate total number of workers."""
        return self.active_workers + self.idle_workers

    @computed_field
    @property
    def worker_utilization_percent(self) -> float:
        """Calculate worker utilization percentage."""
        if self.total_workers == 0:
            return 0.0
        return round((self.active_workers / self.total_workers) * 100, 2)


class QueueHealth(BaseSchema):
    """
    Queue health monitoring and diagnostics.

    Provides health status and alerts for queue system monitoring.
    """

    # Overall health
    is_healthy: bool = Field(
        ...,
        description="Overall queue health status",
    )
    health_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Health score (0-100)",
    )

    # Component health
    queue_healthy: bool = Field(
        ...,
        description="Queue is processing normally",
    )
    workers_healthy: bool = Field(
        ...,
        description="Workers are functioning properly",
    )
    database_healthy: bool = Field(
        ...,
        description="Database connection is healthy",
    )
    external_services_healthy: bool = Field(
        ...,
        description="External notification services are reachable",
    )

    # Issues and alerts
    active_issues: List[str] = Field(
        default_factory=list,
        description="List of active issues",
    )
    warnings: List[str] = Field(
        default_factory=list,
        description="List of warnings",
    )

    # Performance indicators
    queue_backlog_minutes: int = Field(
        ...,
        ge=0,
        description="Estimated backlog in minutes",
    )
    is_overloaded: bool = Field(
        ...,
        description="Whether queue is overloaded",
    )
    is_underutilized: bool = Field(
        ...,
        description="Whether queue has excess capacity",
    )

    # Resource usage
    memory_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Memory usage percentage",
    )
    cpu_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="CPU usage percentage",
    )

    # Recommendations
    recommendations: List[str] = Field(
        default_factory=list,
        description="Recommended actions",
    )

    # Timestamp
    checked_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When health check was performed",
    )

    @computed_field
    @property
    def has_critical_issues(self) -> bool:
        """Check if there are any critical issues."""
        return len(self.active_issues) > 0

    @computed_field
    @property
    def needs_attention(self) -> bool:
        """Check if queue needs administrator attention."""
        return not self.is_healthy or self.has_critical_issues


class QueuePriority(BaseSchema):
    """
    Queue priority configuration and status.

    Manages priority-based queue processing rules.
    """

    priority_level: Priority = Field(
        ...,
        description="Priority level",
    )

    # Processing rules
    processing_weight: int = Field(
        ...,
        ge=1,
        le=100,
        description="Relative processing weight (higher = more priority)",
    )
    max_concurrent: int = Field(
        ...,
        ge=1,
        description="Maximum concurrent processing for this priority",
    )

    # Current state
    queued_count: int = Field(
        ...,
        ge=0,
        description="Currently queued notifications",
    )
    processing_count: int = Field(
        ...,
        ge=0,
        description="Currently processing notifications",
    )

    # Performance
    average_wait_time_seconds: Decimal = Field(
        ...,
        ge=0,
        description="Average wait time for this priority",
    )
    throughput_per_minute: Decimal = Field(
        ...,
        ge=0,
        description="Processing throughput for this priority",
    )

    # SLA
    target_processing_time_seconds: int = Field(
        ...,
        ge=1,
        description="Target processing time SLA",
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage meeting SLA",
    )

    @computed_field
    @property
    def is_meeting_sla(self) -> bool:
        """Check if priority level is meeting SLA targets."""
        return self.sla_compliance_rate >= 95.0  # 95% threshold

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\notification\notification_response.py ---
# --- File: app/schemas/notification/notification_response.py ---
"""
Notification response schemas.

This module provides response models for notification queries, lists,
and detailed information returned by the API.
"""

from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import NotificationStatus, NotificationType, Priority

__all__ = [
    "NotificationResponse",
    "NotificationDetail",
    "NotificationList",
    "NotificationListItem",
    "UnreadCount",
    "NotificationSummary",
]


class NotificationResponse(BaseResponseSchema):
    """
    Standard notification response.

    Used for single notification queries and list items.
    """

    # Recipient information
    recipient_user_id: Optional[UUID] = Field(
        None,
        description="Recipient user ID",
    )
    recipient_email: Optional[str] = Field(
        None,
        description="Recipient email address",
    )
    recipient_phone: Optional[str] = Field(
        None,
        description="Recipient phone number",
    )

    # Notification details
    notification_type: NotificationType = Field(
        ...,
        description="Notification delivery channel",
    )
    subject: Optional[str] = Field(
        None,
        description="Notification subject/title",
    )
    message_body: str = Field(
        ...,
        description="Notification message content",
    )

    # Status and priority
    priority: Priority = Field(
        ...,
        description="Notification priority level",
    )
    status: NotificationStatus = Field(
        ...,
        description="Current notification status",
    )

    # Timing
    scheduled_at: Optional[datetime] = Field(
        None,
        description="Scheduled delivery time",
    )
    sent_at: Optional[datetime] = Field(
        None,
        description="Actual send time",
    )
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )

    @computed_field
    @property
    def is_sent(self) -> bool:
        """Check if notification has been sent."""
        return self.status in [
            NotificationStatus.SENT,
            NotificationStatus.COMPLETED,
        ]

    @computed_field
    @property
    def is_pending(self) -> bool:
        """Check if notification is pending delivery."""
        return self.status in [
            NotificationStatus.QUEUED,
            NotificationStatus.PROCESSING,
        ]


class NotificationDetail(BaseResponseSchema):
    """
    Detailed notification information.

    Includes extended fields for comprehensive notification data,
    delivery tracking, and metadata.
    """

    # Recipient information
    recipient_user_id: Optional[UUID] = Field(
        None,
        description="Recipient user ID",
    )
    recipient_email: Optional[str] = Field(
        None,
        description="Recipient email address",
    )
    recipient_phone: Optional[str] = Field(
        None,
        description="Recipient phone number",
    )

    # Template and content
    notification_type: NotificationType = Field(
        ...,
        description="Notification delivery channel",
    )
    template_code: Optional[str] = Field(
        None,
        description="Template code used",
    )
    subject: Optional[str] = Field(
        None,
        description="Notification subject/title",
    )
    message_body: str = Field(
        ...,
        description="Notification message content",
    )

    # Status and priority
    priority: Priority = Field(
        ...,
        description="Notification priority level",
    )
    status: NotificationStatus = Field(
        ...,
        description="Current notification status",
    )

    # Scheduling and delivery
    scheduled_at: Optional[datetime] = Field(
        None,
        description="Scheduled delivery time",
    )
    sent_at: Optional[datetime] = Field(
        None,
        description="Actual send time",
    )
    delivered_at: Optional[datetime] = Field(
        None,
        description="Delivery confirmation time",
    )
    failed_at: Optional[datetime] = Field(
        None,
        description="Failure timestamp",
    )

    # Retry and error handling
    failure_reason: Optional[str] = Field(
        None,
        max_length=1000,
        description="Reason for delivery failure",
    )
    retry_count: int = Field(
        default=0,
        ge=0,
        description="Number of retry attempts",
    )
    max_retries: int = Field(
        default=3,
        ge=0,
        description="Maximum allowed retries",
    )

    # Engagement tracking
    read_at: Optional[datetime] = Field(
        None,
        description="When the notification was read",
    )
    clicked_at: Optional[datetime] = Field(
        None,
        description="When any link in the notification was clicked",
    )

    # Metadata and context
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional notification metadata",
    )

    # Related entities
    hostel_id: Optional[UUID] = Field(
        None,
        description="Associated hostel ID",
    )

    # Audit timestamps
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )
    updated_at: datetime = Field(
        ...,
        description="Last update timestamp",
    )

    @computed_field
    @property
    def is_read(self) -> bool:
        """Check if notification has been read."""
        return self.read_at is not None

    @computed_field
    @property
    def can_retry(self) -> bool:
        """Check if notification can be retried."""
        return (
            self.status == NotificationStatus.FAILED
            and self.retry_count < self.max_retries
        )

    @computed_field
    @property
    def delivery_duration_seconds(self) -> Optional[int]:
        """Calculate delivery duration in seconds."""
        if self.sent_at and self.delivered_at:
            return int((self.delivered_at - self.sent_at).total_seconds())
        return None


class NotificationListItem(BaseSchema):
    """
    Compact notification item for list views.

    Optimized for performance with minimal data for displaying
    notification lists efficiently.
    """

    id: UUID = Field(
        ...,
        description="Notification ID",
    )
    notification_type: NotificationType = Field(
        ...,
        description="Notification channel",
    )

    # Content preview
    subject: Optional[str] = Field(
        None,
        description="Notification subject",
    )
    message_preview: str = Field(
        ...,
        max_length=150,
        description="Message preview (first 150 characters)",
    )

    # Status
    priority: Priority = Field(
        ...,
        description="Priority level",
    )
    status: NotificationStatus = Field(
        ...,
        description="Current status",
    )

    # Read status
    is_read: bool = Field(
        default=False,
        description="Whether notification has been read",
    )
    read_at: Optional[datetime] = Field(
        None,
        description="When notification was read",
    )

    # Timing
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )

    # Actions and UI
    action_url: Optional[str] = Field(
        None,
        max_length=500,
        description="URL to navigate to when notification is clicked",
    )
    icon: Optional[str] = Field(
        None,
        max_length=50,
        description="Icon identifier for UI rendering",
    )
    category: Optional[str] = Field(
        None,
        max_length=50,
        description="Notification category for grouping",
    )

    @computed_field
    @property
    def is_urgent(self) -> bool:
        """Check if notification is urgent."""
        return self.priority in [Priority.URGENT, Priority.CRITICAL]


class NotificationList(BaseSchema):
    """
    Paginated list of notifications for a user.

    Includes summary statistics and list items.
    """

    user_id: UUID = Field(
        ...,
        description="User ID for this notification list",
    )
    total_notifications: int = Field(
        ...,
        ge=0,
        description="Total number of notifications",
    )
    unread_count: int = Field(
        ...,
        ge=0,
        description="Number of unread notifications",
    )
    notifications: List[NotificationListItem] = Field(
        ...,
        description="List of notification items",
    )

    @computed_field
    @property
    def read_count(self) -> int:
        """Calculate number of read notifications."""
        return self.total_notifications - self.unread_count

    @computed_field
    @property
    def has_unread(self) -> bool:
        """Check if there are any unread notifications."""
        return self.unread_count > 0


class UnreadCount(BaseSchema):
    """
    Unread notification count breakdown.

    Provides granular unread counts by type and priority.
    """

    user_id: UUID = Field(
        ...,
        description="User ID",
    )

    # Total unread
    total_unread: int = Field(
        ...,
        ge=0,
        description="Total unread notifications",
    )

    # By notification type
    email_unread: int = Field(
        default=0,
        ge=0,
        description="Unread email notifications",
    )
    sms_unread: int = Field(
        default=0,
        ge=0,
        description="Unread SMS notifications",
    )
    push_unread: int = Field(
        default=0,
        ge=0,
        description="Unread push notifications",
    )
    in_app_unread: int = Field(
        default=0,
        ge=0,
        description="Unread in-app notifications",
    )

    # By priority
    urgent_unread: int = Field(
        default=0,
        ge=0,
        description="Unread urgent/critical notifications",
    )
    high_unread: int = Field(
        default=0,
        ge=0,
        description="Unread high priority notifications",
    )

    # Timestamp
    last_checked_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When counts were last calculated",
    )


class NotificationSummary(BaseSchema):
    """
    Comprehensive notification summary for a user.

    Provides aggregate statistics and insights.
    """

    user_id: UUID = Field(
        ...,
        description="User ID",
    )

    # Overall counts
    total_notifications: int = Field(
        ...,
        ge=0,
        description="Total notifications received",
    )
    unread_notifications: int = Field(
        ...,
        ge=0,
        description="Unread notification count",
    )

    # Recent activity
    last_notification_at: Optional[datetime] = Field(
        None,
        description="Timestamp of most recent notification",
    )
    last_read_at: Optional[datetime] = Field(
        None,
        description="When user last read a notification",
    )

    # Breakdown by type
    notifications_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of notifications by type",
    )

    # Breakdown by status
    notifications_by_status: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of notifications by status",
    )

    # Breakdown by priority
    notifications_by_priority: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of notifications by priority",
    )

    # Summary period
    summary_period_days: int = Field(
        default=30,
        ge=1,
        le=365,
        description="Number of days included in summary",
    )

    @computed_field
    @property
    def read_percentage(self) -> float:
        """Calculate percentage of read notifications."""
        if self.total_notifications == 0:
            return 0.0
        read_count = self.total_notifications - self.unread_notifications
        return round((read_count / self.total_notifications) * 100, 2)

    @computed_field
    @property
    def has_recent_activity(self) -> bool:
        """Check if there's been activity in the last 24 hours."""
        if not self.last_notification_at:
            return False
        time_diff = datetime.utcnow() - self.last_notification_at
        return time_diff.total_seconds() < 86400  # 24 hours

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\notification\notification_routing.py ---
# --- File: app/schemas/notification/notification_routing.py ---
"""
Notification routing schemas.

This module provides schemas for routing notifications to appropriate
recipients with hierarchical escalation and rule-based routing.
"""

from __future__ import annotations

from datetime import datetime
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import Priority, UserRole

__all__ = [
    "RoutingConfig",
    "RoutingRule",
    "HierarchicalRouting",
    "EscalationRouting",
    "EscalationLevel",
    "NotificationRoute",
    "RoutingCondition",
]


class RoutingCondition(BaseSchema):
    """
    Condition for routing rule matching.

    Defines when a routing rule should be applied.
    """

    # Event matching
    event_type: Optional[str] = Field(
        None,
        max_length=100,
        description="Event type to match (e.g., 'complaint', 'payment')",
    )
    event_category: Optional[str] = Field(
        None,
        max_length=100,
        description="Event category",
    )

    # Priority matching
    priority: Optional[Priority] = Field(
        None,
        description="Priority level to match",
    )
    min_priority: Optional[Priority] = Field(
        None,
        description="Minimum priority level",
    )

    # Entity matching
    hostel_id: Optional[UUID] = Field(
        None,
        description="Specific hostel ID",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Specific room ID",
    )

    # Time-based
    time_of_day_start: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Start time for time-based routing (HH:MM)",
    )
    time_of_day_end: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="End time for time-based routing (HH:MM)",
    )

    # Custom attributes
    custom_attributes: Dict[str, str] = Field(
        default_factory=dict,
        description="Custom attribute matching",
    )


class RoutingRule(BaseSchema):
    """
    Individual routing rule configuration.

    Defines how notifications should be routed based on conditions.
    """

    rule_id: Optional[UUID] = Field(
        None,
        description="Rule ID (auto-generated if not provided)",
    )
    rule_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Human-readable rule name",
    )
    description: Optional[str] = Field(
        None,
        max_length=500,
        description="Rule description",
    )

    # Priority (for rule ordering)
    rule_priority: int = Field(
        default=0,
        ge=0,
        le=100,
        description="Rule priority (higher = evaluated first)",
    )

    # Conditions
    conditions: RoutingCondition = Field(
        default_factory=RoutingCondition,
        description="Conditions for this rule",
    )

    # Recipients
    recipient_roles: List[UserRole] = Field(
        default_factory=list,
        description="User roles to notify",
    )
    specific_users: List[UUID] = Field(
        default_factory=list,
        description="Specific user IDs to notify",
    )
    recipient_groups: List[str] = Field(
        default_factory=list,
        description="User groups to notify",
    )

    # Channels
    channels: List[str] = Field(
        ...,
        min_length=1,
        pattern_items="^(email|sms|push)$",
        description="Notification channels to use",
    )

    # Template
    template_code: Optional[str] = Field(
        None,
        description="Template to use for this rule",
    )

    # Settings
    is_active: bool = Field(
        default=True,
        description="Whether rule is active",
    )
    stop_on_match: bool = Field(
        default=False,
        description="Stop processing rules after this one matches",
    )

    @field_validator("channels")
    @classmethod
    def validate_channels(cls, v: List[str]) -> List[str]:
        """Validate and deduplicate channels."""
        valid_channels = ["email", "sms", "push"]
        for channel in v:
            if channel not in valid_channels:
                raise ValueError(f"Invalid channel: {channel}")
        return list(set(v))  # Remove duplicates

    @model_validator(mode="after")
    def validate_recipients(self) -> "RoutingRule":
        """Ensure at least one recipient is specified."""
        if not any([
            self.recipient_roles,
            self.specific_users,
            self.recipient_groups,
        ]):
            raise ValueError(
                "At least one recipient (roles, users, or groups) must be specified"
            )
        return self


class RoutingConfig(BaseSchema):
    """
    Complete routing configuration for a hostel.

    Defines all routing rules and escalation settings.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID for this routing config",
    )

    # Routing rules
    rules: List[RoutingRule] = Field(
        default_factory=list,
        description="List of routing rules (evaluated in order)",
    )

    # Default routing
    default_recipient_roles: List[UserRole] = Field(
        default_factory=lambda: [UserRole.HOSTEL_ADMIN],
        description="Default recipients if no rules match",
    )
    default_channels: List[str] = Field(
        default_factory=lambda: ["email"],
        description="Default notification channels",
    )

    # Escalation settings
    enable_escalation: bool = Field(
        default=True,
        description="Enable automatic escalation",
    )
    escalation_timeout_hours: int = Field(
        default=24,
        ge=1,
        le=168,  # 1 week max
        description="Hours before escalating unhandled notifications",
    )

    # Settings
    is_active: bool = Field(
        default=True,
        description="Whether routing config is active",
    )

    @field_validator("rules")
    @classmethod
    def sort_rules_by_priority(cls, v: List[RoutingRule]) -> List[RoutingRule]:
        """Sort rules by priority (highest first)."""
        return sorted(v, key=lambda r: r.rule_priority, reverse=True)


class EscalationLevel(BaseSchema):
    """
    Single level in an escalation chain.

    Defines recipients and timing for one escalation level.
    """

    level: int = Field(
        ...,
        ge=1,
        le=10,
        description="Escalation level (1 = first, higher = later)",
    )
    level_name: str = Field(
        ...,
        max_length=100,
        description="Level name (e.g., 'Supervisor', 'Admin', 'Manager')",
    )

    # Recipients
    recipients: List[UUID] = Field(
        ...,
        min_length=1,
        description="User IDs to notify at this level",
    )
    recipient_roles: List[UserRole] = Field(
        default_factory=list,
        description="User roles to notify at this level",
    )

    # Timing
    escalate_after_hours: int = Field(
        ...,
        ge=1,
        le=168,
        description="Hours to wait before escalating to this level",
    )

    # Channels
    channels: List[str] = Field(
        ...,
        min_length=1,
        description="Notification channels for this level",
    )

    # Template
    template_code: Optional[str] = Field(
        None,
        description="Template for escalation notification",
    )

    @field_validator("channels")
    @classmethod
    def validate_channels(cls, v: List[str]) -> List[str]:
        """Validate channels."""
        valid_channels = ["email", "sms", "push"]
        for channel in v:
            if channel not in valid_channels:
                raise ValueError(f"Invalid channel: {channel}")
        return list(set(v))


class HierarchicalRouting(BaseSchema):
    """
    Hierarchical notification routing configuration.

    Defines multi-level routing with fallback recipients.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    event_type: str = Field(
        ...,
        max_length=100,
        description="Event type this routing applies to",
    )

    # Routing hierarchy
    primary_recipients: List[UUID] = Field(
        ...,
        min_length=1,
        description="Primary recipients (e.g., supervisors)",
    )
    secondary_recipients: List[UUID] = Field(
        default_factory=list,
        description="Secondary recipients (e.g., admins)",
    )
    tertiary_recipients: List[UUID] = Field(
        default_factory=list,
        description="Tertiary recipients (e.g., super admin)",
    )

    # Escalation timing
    escalate_to_secondary_after_hours: int = Field(
        default=24,
        ge=1,
        le=168,
        description="Hours before escalating to secondary",
    )
    escalate_to_tertiary_after_hours: int = Field(
        default=48,
        ge=1,
        le=336,  # 2 weeks
        description="Hours before escalating to tertiary",
    )

    # Channels by level
    primary_channels: List[str] = Field(
        default_factory=lambda: ["email", "push"],
        description="Channels for primary recipients",
    )
    secondary_channels: List[str] = Field(
        default_factory=lambda: ["email", "sms", "push"],
        description="Channels for secondary recipients",
    )
    tertiary_channels: List[str] = Field(
        default_factory=lambda: ["email", "sms", "push"],
        description="Channels for tertiary recipients",
    )

    # Settings
    is_active: bool = Field(
        default=True,
        description="Whether routing is active",
    )


class EscalationRouting(BaseCreateSchema):
    """
    Escalation routing for a specific notification.

    Defines the escalation path and current state.
    """

    notification_id: UUID = Field(
        ...,
        description="Notification ID",
    )

    # Escalation chain
    escalation_chain: List[EscalationLevel] = Field(
        ...,
        min_length=1,
        description="Escalation levels in order",
    )

    # Current state
    current_level: int = Field(
        default=0,
        ge=0,
        description="Current escalation level (0 = not escalated)",
    )
    last_escalated_at: Optional[datetime] = Field(
        None,
        description="When last escalation occurred",
    )

    # Settings
    auto_escalate: bool = Field(
        default=True,
        description="Automatically escalate based on timing",
    )
    is_resolved: bool = Field(
        default=False,
        description="Whether notification has been resolved",
    )

    @field_validator("escalation_chain")
    @classmethod
    def validate_escalation_levels(
        cls,
        v: List[EscalationLevel],
    ) -> List[EscalationLevel]:
        """Validate escalation levels are sequential and sorted."""
        if not v:
            raise ValueError("At least one escalation level required")

        # Check levels are sequential
        levels = [level.level for level in v]
        if levels != list(range(1, len(levels) + 1)):
            raise ValueError("Escalation levels must be sequential starting from 1")

        # Sort by level
        return sorted(v, key=lambda x: x.level)

    @field_validator("escalation_chain")
    @classmethod
    def validate_escalation_timing(
        cls,
        v: List[EscalationLevel],
    ) -> List[EscalationLevel]:
        """Validate escalation timing is increasing."""
        hours = [level.escalate_after_hours for level in v]
        if hours != sorted(hours):
            raise ValueError(
                "Escalation hours must increase with each level"
            )
        return v


class NotificationRoute(BaseSchema):
    """
    Determined notification route.

    Represents the final routing decision for a notification.
    """

    notification_id: UUID = Field(
        ...,
        description="Notification ID",
    )

    # Matched rule
    matched_rule_id: Optional[UUID] = Field(
        None,
        description="ID of routing rule that matched",
    )
    matched_rule_name: Optional[str] = Field(
        None,
        description="Name of matched routing rule",
    )

    # Recipients
    primary_recipients: List[UUID] = Field(
        ...,
        min_length=1,
        description="Primary notification recipients",
    )
    cc_recipients: List[UUID] = Field(
        default_factory=list,
        description="CC recipients",
    )

    # Channels by recipient
    recipient_channels: Dict[UUID, List[str]] = Field(
        default_factory=dict,
        description="Notification channels for each recipient",
    )

    # Template
    template_code: Optional[str] = Field(
        None,
        description="Template to use",
    )

    # Escalation
    escalation_enabled: bool = Field(
        default=False,
        description="Whether escalation is enabled",
    )
    escalation_path: Optional[List[EscalationLevel]] = Field(
        None,
        description="Escalation levels if enabled",
    )

    # Metadata
    routing_metadata: Dict[str, str] = Field(
        default_factory=dict,
        description="Additional routing metadata",
    )

    # Timing
    routed_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When routing was determined",
    )

    @field_validator("recipient_channels")
    @classmethod
    def validate_recipient_channels(
        cls,
        v: Dict[UUID, List[str]],
    ) -> Dict[UUID, List[str]]:
        """Validate channels for each recipient."""
        valid_channels = {"email", "sms", "push"}
        for user_id, channels in v.items():
            for channel in channels:
                if channel not in valid_channels:
                    raise ValueError(
                        f"Invalid channel '{channel}' for user {user_id}"
                    )
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\notification\notification_template.py ---
# --- File: app/schemas/notification/notification_template.py ---
"""
Notification template schemas.

This module provides schemas for managing reusable notification templates
with variable substitution and template rendering.
"""

from __future__ import annotations

from datetime import datetime
from typing import Dict, List, Optional, Set
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import NotificationType

__all__ = [
    "TemplateCreate",
    "TemplateUpdate",
    "TemplateResponse",
    "VariableMapping",
    "TemplatePreview",
    "TemplatePreviewResponse",
    "TemplateList",
    "TemplateCategory",
    "TemplateCopyRequest",
]


class TemplateCreate(BaseCreateSchema):
    """
    Schema for creating a notification template.

    Templates support variable substitution using {{variable_name}} syntax.
    """

    template_code: str = Field(
        ...,
        min_length=3,
        max_length=100,
        pattern="^[a-z0-9_]+$",
        description="Unique template code (lowercase, numbers, underscores only)",
    )
    template_name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Human-readable template name",
    )

    # Template type
    template_type: NotificationType = Field(
        ...,
        description="Notification channel this template is for",
    )

    # Content with variable support
    subject: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Subject template (required for email/push, supports {{variables}})",
    )
    body_template: str = Field(
        ...,
        min_length=1,
        max_length=10000,
        description="Body template with {{variable}} placeholders",
    )

    # Variables
    variables: List[str] = Field(
        default_factory=list,
        description="List of required template variables",
    )
    optional_variables: List[str] = Field(
        default_factory=list,
        description="List of optional template variables",
    )

    # Metadata
    category: Optional[str] = Field(
        None,
        max_length=100,
        description="Template category for organization",
    )
    tags: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Tags for template discovery",
    )

    # Settings
    is_active: bool = Field(
        default=True,
        description="Whether template is active and available for use",
    )
    description: Optional[str] = Field(
        None,
        max_length=500,
        description="Template description and usage notes",
    )

    # Localization
    language: str = Field(
        default="en",
        min_length=2,
        max_length=5,
        description="Template language code (e.g., 'en', 'hi')",
    )

    @field_validator("template_code")
    @classmethod
    def validate_template_code(cls, v: str) -> str:
        """Ensure template code follows naming conventions."""
        if not v.islower():
            raise ValueError("Template code must be lowercase")
        if "__" in v:
            raise ValueError("Template code cannot contain consecutive underscores")
        if v.startswith("_") or v.endswith("_"):
            raise ValueError("Template code cannot start or end with underscore")
        return v

    @field_validator("variables", "optional_variables")
    @classmethod
    def validate_variable_names(cls, v: List[str]) -> List[str]:
        """Validate variable names are valid identifiers."""
        for var in v:
            if not var.replace("_", "").isalnum():
                raise ValueError(
                    f"Invalid variable name '{var}'. Must contain only letters, numbers, and underscores"
                )
            if var.startswith("_"):
                raise ValueError(f"Variable name '{var}' cannot start with underscore")
        return v

    @field_validator("tags")
    @classmethod
    def validate_tags(cls, v: List[str]) -> List[str]:
        """Validate and normalize tags."""
        # Remove duplicates and normalize
        normalized = list(set(tag.lower().strip() for tag in v if tag.strip()))
        if len(normalized) > 20:
            raise ValueError("Maximum 20 tags allowed")
        return normalized

    @model_validator(mode="after")
    def validate_subject_for_type(self) -> "TemplateCreate":
        """Ensure subject is provided for email and push templates."""
        if self.template_type in [NotificationType.EMAIL, NotificationType.PUSH]:
            if not self.subject:
                raise ValueError(
                    f"Subject is required for {self.template_type.value} templates"
                )
        return self

    @model_validator(mode="after")
    def validate_variables_in_template(self) -> "TemplateCreate":
        """Validate that declared variables exist in templates."""
        import re

        # Extract variables from templates
        variable_pattern = r"\{\{(\w+)\}\}"
        subject_vars = set(re.findall(variable_pattern, self.subject or ""))
        body_vars = set(re.findall(variable_pattern, self.body_template))
        all_template_vars = subject_vars | body_vars

        # Check declared variables
        declared_vars = set(self.variables + self.optional_variables)

        # Undeclared variables
        undeclared = all_template_vars - declared_vars
        if undeclared:
            raise ValueError(
                f"Template contains undeclared variables: {', '.join(undeclared)}"
            )

        # Unused variables (warning-level, but we'll allow it)
        # unused = declared_vars - all_template_vars

        return self


class TemplateUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing template.

    Template code cannot be changed after creation.
    """

    template_name: Optional[str] = Field(
        None,
        min_length=3,
        max_length=255,
        description="Updated template name",
    )
    subject: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Updated subject template",
    )
    body_template: Optional[str] = Field(
        None,
        min_length=1,
        max_length=10000,
        description="Updated body template",
    )
    variables: Optional[List[str]] = Field(
        None,
        description="Updated required variables list",
    )
    optional_variables: Optional[List[str]] = Field(
        None,
        description="Updated optional variables list",
    )
    category: Optional[str] = Field(
        None,
        max_length=100,
        description="Updated category",
    )
    tags: Optional[List[str]] = Field(
        None,
        description="Updated tags",
    )
    is_active: Optional[bool] = Field(
        None,
        description="Updated active status",
    )
    description: Optional[str] = Field(
        None,
        max_length=500,
        description="Updated description",
    )


class TemplateResponse(BaseResponseSchema):
    """
    Template response schema.

    Includes template details and usage statistics.
    """

    template_code: str = Field(
        ...,
        description="Unique template identifier",
    )
    template_name: str = Field(
        ...,
        description="Template name",
    )
    template_type: NotificationType = Field(
        ...,
        description="Notification channel",
    )

    # Content
    subject: Optional[str] = Field(
        None,
        description="Subject template",
    )
    body_template: str = Field(
        ...,
        description="Body template",
    )

    # Variables
    variables: List[str] = Field(
        ...,
        description="Required variables",
    )
    optional_variables: List[str] = Field(
        default_factory=list,
        description="Optional variables",
    )

    # Metadata
    category: Optional[str] = Field(
        None,
        description="Template category",
    )
    tags: List[str] = Field(
        default_factory=list,
        description="Template tags",
    )
    language: str = Field(
        ...,
        description="Template language",
    )

    # Status
    is_active: bool = Field(
        ...,
        description="Active status",
    )
    description: Optional[str] = Field(
        None,
        description="Template description",
    )

    # Usage statistics
    usage_count: int = Field(
        default=0,
        ge=0,
        description="Number of times template has been used",
    )
    last_used_at: Optional[datetime] = Field(
        None,
        description="When template was last used",
    )

    # Audit
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )
    updated_at: datetime = Field(
        ...,
        description="Last update timestamp",
    )
    created_by: Optional[UUID] = Field(
        None,
        description="User who created the template",
    )


class VariableMapping(BaseSchema):
    """
    Variable mapping for template rendering.

    Maps template variable names to their runtime values.
    """

    template_code: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Template code to render",
    )
    variables: Dict[str, str] = Field(
        ...,
        description="Variable name to value mapping",
    )

    @field_validator("variables")
    @classmethod
    def validate_variable_values(cls, v: Dict[str, str]) -> Dict[str, str]:
        """Validate variable values are non-empty strings."""
        for key, value in v.items():
            if not isinstance(value, str):
                raise ValueError(f"Variable '{key}' must be a string value")
            if not value.strip():
                raise ValueError(f"Variable '{key}' cannot be empty")
        return v


class TemplatePreview(BaseCreateSchema):
    """
    Request schema for previewing a rendered template.

    Useful for testing templates before deployment.
    """

    template_code: str = Field(
        ...,
        description="Template code to preview",
    )
    variables: Dict[str, str] = Field(
        ...,
        description="Variable values for rendering",
    )
    use_defaults: bool = Field(
        default=False,
        description="Use default values for missing optional variables",
    )


class TemplatePreviewResponse(BaseSchema):
    """
    Rendered template preview response.

    Shows the final rendered content and validation results.
    """

    template_code: str = Field(
        ...,
        description="Template code",
    )
    subject: Optional[str] = Field(
        None,
        description="Rendered subject",
    )
    rendered_body: str = Field(
        ...,
        description="Rendered message body",
    )

    # Validation results
    all_variables_provided: bool = Field(
        ...,
        description="Whether all required variables were provided",
    )
    missing_variables: List[str] = Field(
        default_factory=list,
        description="List of missing required variables",
    )
    unused_variables: List[str] = Field(
        default_factory=list,
        description="Provided variables not used in template",
    )

    # Character counts (useful for SMS)
    subject_length: Optional[int] = Field(
        None,
        description="Length of rendered subject",
    )
    body_length: int = Field(
        ...,
        description="Length of rendered body",
    )
    estimated_sms_segments: Optional[int] = Field(
        None,
        description="Estimated SMS segments (if applicable)",
    )


class TemplateList(BaseSchema):
    """
    List of templates with summary statistics.
    """

    total_templates: int = Field(
        ...,
        ge=0,
        description="Total number of templates",
    )
    active_templates: int = Field(
        ...,
        ge=0,
        description="Number of active templates",
    )
    templates_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Template count by notification type",
    )
    templates: List[TemplateResponse] = Field(
        ...,
        description="List of templates",
    )


class TemplateCategory(BaseSchema):
    """
    Templates grouped by category.

    Useful for organizing templates in UI.
    """

    category_name: str = Field(
        ...,
        description="Category name",
    )
    category_description: Optional[str] = Field(
        None,
        description="Category description",
    )
    template_count: int = Field(
        ...,
        ge=0,
        description="Number of templates in category",
    )
    templates: List[TemplateResponse] = Field(
        ...,
        description="Templates in this category",
    )


class TemplateCopyRequest(BaseCreateSchema):
    """
    Request to copy an existing template.

    Creates a new template based on an existing one.
    """

    source_template_code: str = Field(
        ...,
        description="Template code to copy from",
    )
    new_template_code: str = Field(
        ...,
        min_length=3,
        max_length=100,
        pattern="^[a-z0-9_]+$",
        description="New template code",
    )
    new_template_name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="New template name",
    )
    copy_metadata: bool = Field(
        default=True,
        description="Copy category, tags, and description",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\notification\push_notification.py ---
# --- File: app/schemas/notification/push_notification.py ---
"""
Push notification schemas.

This module provides schemas for push notification delivery across
mobile platforms (iOS, Android) and web with device management.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import DeviceType

__all__ = [
    "PushRequest",
    "PushConfig",
    "DeviceToken",
    "DeviceRegistration",
    "DeviceUnregistration",
    "PushTemplate",
    "PushDeliveryStatus",
    "PushStats",
    "BulkPushRequest",
]


class PushRequest(BaseCreateSchema):
    """
    Send push notification request.

    Supports targeted delivery to specific users/devices with rich
    content including images, actions, and custom data.
    """

    # Recipients (at least one required)
    user_id: Optional[UUID] = Field(
        None,
        description="Send to all active devices of this user",
    )
    device_token: Optional[str] = Field(
        None,
        min_length=10,
        max_length=500,
        description="Send to specific device token",
    )
    device_tokens: Optional[List[str]] = Field(
        None,
        max_length=1000,
        description="Send to multiple specific devices (max 1000)",
    )
    segment: Optional[str] = Field(
        None,
        max_length=100,
        description="Send to user segment",
    )

    # Content
    title: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Notification title",
    )
    body: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Notification body text",
    )

    # Rich content
    image_url: Optional[str] = Field(
        None,
        max_length=500,
        description="Large image URL for rich notification",
    )
    icon: Optional[str] = Field(
        None,
        max_length=100,
        description="Small icon identifier",
    )

    # Custom data payload
    data: Dict[str, Any] = Field(
        default_factory=dict,
        description="Custom data payload (sent to app)",
    )

    # Actions
    action_url: Optional[str] = Field(
        None,
        max_length=500,
        description="Deep link or URL to open on tap",
    )
    actions: List["PushAction"] = Field(
        default_factory=list,
        max_length=3,
        description="Action buttons (max 3)",
    )

    # Badge (iOS)
    badge_count: Optional[int] = Field(
        None,
        ge=0,
        le=99999,
        description="Badge count for app icon",
    )
    badge_strategy: Optional[str] = Field(
        None,
        pattern="^(set|increment|decrement)$",
        description="How to update badge count",
    )

    # Sound
    sound: str = Field(
        default="default",
        max_length=100,
        description="Notification sound (default or custom)",
    )
    sound_volume: Optional[float] = Field(
        None,
        ge=0.0,
        le=1.0,
        description="Sound volume (0.0 to 1.0)",
    )

    # Priority and delivery
    priority: str = Field(
        default="normal",
        pattern="^(low|normal|high)$",
        description="Notification priority",
    )
    ttl: int = Field(
        default=86400,  # 24 hours
        ge=0,
        le=2419200,  # 28 days max
        description="Time to live in seconds",
    )

    # Collapse/grouping
    collapse_key: Optional[str] = Field(
        None,
        max_length=100,
        description="Collapse key for grouping notifications",
    )
    thread_id: Optional[str] = Field(
        None,
        max_length=100,
        description="Thread ID for notification grouping",
    )

    # Platform-specific
    android_channel_id: Optional[str] = Field(
        None,
        max_length=100,
        description="Android notification channel ID",
    )
    ios_category: Optional[str] = Field(
        None,
        max_length=100,
        description="iOS notification category",
    )

    # Scheduling
    send_at: Optional[datetime] = Field(
        None,
        description="Schedule for future delivery",
    )

    # Metadata
    tags: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Tags for categorization",
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Custom metadata",
    )

    @model_validator(mode="after")
    def validate_recipients(self) -> "PushRequest":
        """Ensure at least one recipient target is provided."""
        if not any([self.user_id, self.device_token, self.device_tokens, self.segment]):
            raise ValueError(
                "At least one recipient (user_id, device_token, device_tokens, or segment) required"
            )
        
        # Ensure only one targeting method is used
        targets = sum([
            bool(self.user_id),
            bool(self.device_token),
            bool(self.device_tokens),
            bool(self.segment),
        ])
        if targets > 1:
            raise ValueError(
                "Only one targeting method allowed (user_id, device_token, device_tokens, or segment)"
            )
        
        return self

    @field_validator("data")
    @classmethod
    def validate_data_size(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        """Validate data payload size."""
        import json
        if len(json.dumps(v)) > 4096:  # 4KB limit
            raise ValueError("Data payload cannot exceed 4KB")
        return v

    @field_validator("send_at")
    @classmethod
    def validate_send_time(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate scheduled send time is in the future."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Scheduled send time must be in the future")
        return v


class PushAction(BaseSchema):
    """
    Push notification action button.

    Allows users to take quick actions from notification.
    """

    action_id: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Unique action identifier",
    )
    title: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Action button text",
    )
    action_url: Optional[str] = Field(
        None,
        max_length=500,
        description="URL to open when action is tapped",
    )
    icon: Optional[str] = Field(
        None,
        max_length=50,
        description="Action icon identifier",
    )


class PushConfig(BaseSchema):
    """
    Push notification service configuration.

    Supports Firebase Cloud Messaging (FCM) and Apple Push Notification
    Service (APNs) with unified configuration.
    """

    # Firebase (Android + Web)
    firebase_project_id: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Firebase project ID",
    )
    firebase_server_key: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Firebase server key / FCM API key",
    )
    firebase_service_account_json: Optional[str] = Field(
        None,
        description="Firebase service account JSON (for v1 API)",
    )

    # APNs (iOS)
    apns_enabled: bool = Field(
        default=False,
        description="Enable APNs for iOS",
    )
    apns_key_id: Optional[str] = Field(
        None,
        max_length=100,
        description="APNs key ID",
    )
    apns_team_id: Optional[str] = Field(
        None,
        max_length=100,
        description="Apple team ID",
    )
    apns_bundle_id: Optional[str] = Field(
        None,
        max_length=255,
        description="iOS app bundle ID",
    )
    apns_key_path: Optional[str] = Field(
        None,
        max_length=500,
        description="Path to APNs .p8 key file",
    )
    apns_production: bool = Field(
        default=False,
        description="Use production APNs (vs sandbox)",
    )

    # Default settings
    default_sound: str = Field(
        default="default",
        description="Default notification sound",
    )
    default_priority: str = Field(
        default="normal",
        pattern="^(low|normal|high)$",
        description="Default priority",
    )
    default_ttl: int = Field(
        default=86400,
        ge=0,
        description="Default TTL in seconds",
    )

    # Collapse key
    collapse_key: Optional[str] = Field(
        None,
        description="Default collapse key for grouping",
    )

    # Badge management
    auto_increment_badge: bool = Field(
        default=True,
        description="Auto-increment badge count",
    )

    # Rate limiting
    max_notifications_per_hour: int = Field(
        default=1000,
        ge=1,
        description="Max push notifications per hour",
    )

    @model_validator(mode="after")
    def validate_apns_config(self) -> "PushConfig":
        """Validate APNs configuration if enabled."""
        if self.apns_enabled:
            required_fields = [
                self.apns_key_id,
                self.apns_team_id,
                self.apns_bundle_id,
                self.apns_key_path,
            ]
            if not all(required_fields):
                raise ValueError(
                    "APNs requires key_id, team_id, bundle_id, and key_path"
                )
        return self


class DeviceToken(BaseResponseSchema):
    """
    Registered device token for push notifications.

    Tracks device information and token lifecycle.
    """

    user_id: UUID = Field(
        ...,
        description="User who owns this device",
    )
    device_token: str = Field(
        ...,
        description="Device push token",
    )
    device_type: DeviceType = Field(
        ...,
        description="Device platform",
    )

    # Device details
    device_name: Optional[str] = Field(
        None,
        max_length=100,
        description="User-set device name",
    )
    device_model: Optional[str] = Field(
        None,
        max_length=100,
        description="Device model",
    )
    os_version: Optional[str] = Field(
        None,
        max_length=50,
        description="OS version",
    )
    app_version: Optional[str] = Field(
        None,
        max_length=50,
        description="App version",
    )

    # Location and timezone
    timezone: Optional[str] = Field(
        None,
        max_length=100,
        description="Device timezone",
    )
    locale: Optional[str] = Field(
        None,
        max_length=10,
        description="Device locale (e.g., en_US)",
    )

    # Status
    is_active: bool = Field(
        ...,
        description="Whether device token is active",
    )
    last_used_at: datetime = Field(
        ...,
        description="When device was last active",
    )
    registered_at: datetime = Field(
        ...,
        description="When device was registered",
    )

    # Badge count
    current_badge_count: int = Field(
        default=0,
        ge=0,
        description="Current badge count for this device",
    )


class DeviceRegistration(BaseCreateSchema):
    """
    Register a device for push notifications.

    Associates a device token with a user account.
    """

    user_id: UUID = Field(
        ...,
        description="User ID to register device for",
    )
    device_token: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Device push notification token",
    )
    device_type: DeviceType = Field(
        ...,
        description="Device platform type",
    )

    # Optional device details
    device_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Device name",
    )
    device_model: Optional[str] = Field(
        None,
        max_length=100,
        description="Device model",
    )
    os_version: Optional[str] = Field(
        None,
        max_length=50,
        description="Operating system version",
    )
    app_version: Optional[str] = Field(
        None,
        max_length=50,
        description="Application version",
    )

    # Timezone
    timezone: Optional[str] = Field(
        None,
        max_length=100,
        description="Device timezone",
    )
    locale: Optional[str] = Field(
        None,
        max_length=10,
        description="Device locale",
    )


class DeviceUnregistration(BaseCreateSchema):
    """
    Unregister a device from push notifications.

    Removes device token to stop receiving notifications.
    """

    device_token: str = Field(
        ...,
        description="Device token to unregister",
    )
    user_id: Optional[UUID] = Field(
        None,
        description="User ID (for verification)",
    )
    reason: Optional[str] = Field(
        None,
        max_length=200,
        description="Reason for unregistration",
    )


class PushTemplate(BaseSchema):
    """
    Push notification template.

    Defines reusable push notification structures with variables.
    """

    template_code: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Unique template identifier",
    )

    # Content templates
    title: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Title template with {{variables}}",
    )
    body: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Body template with {{variables}}",
    )

    # Default settings
    default_icon: Optional[str] = Field(
        None,
        description="Default notification icon",
    )
    default_sound: str = Field(
        default="default",
        description="Default notification sound",
    )
    default_image_url: Optional[str] = Field(
        None,
        description="Default image URL",
    )

    # Variables
    required_variables: List[str] = Field(
        ...,
        description="Required template variables",
    )
    optional_variables: List[str] = Field(
        default_factory=list,
        description="Optional template variables",
    )

    # Actions
    default_action_url: Optional[str] = Field(
        None,
        description="Default deep link/URL",
    )
    default_actions: List[PushAction] = Field(
        default_factory=list,
        description="Default action buttons",
    )

    # Platform-specific
    android_channel_id: Optional[str] = Field(
        None,
        description="Default Android channel ID",
    )
    ios_category: Optional[str] = Field(
        None,
        description="Default iOS category",
    )


class PushDeliveryStatus(BaseSchema):
    """
    Push notification delivery status.

    Tracks delivery and engagement for individual notifications.
    """

    notification_id: UUID = Field(
        ...,
        description="Push notification ID",
    )
    device_token: str = Field(
        ...,
        description="Target device token",
    )

    # Delivery status
    status: str = Field(
        ...,
        pattern="^(queued|sent|delivered|failed|expired|clicked)$",
        description="Current delivery status",
    )

    # Timeline
    sent_at: Optional[datetime] = Field(
        None,
        description="When notification was sent",
    )
    delivered_at: Optional[datetime] = Field(
        None,
        description="When notification was delivered to device",
    )
    clicked_at: Optional[datetime] = Field(
        None,
        description="When notification was clicked",
    )
    failed_at: Optional[datetime] = Field(
        None,
        description="When delivery failed",
    )

    # Error information
    error_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Error code from provider",
    )
    error_message: Optional[str] = Field(
        None,
        max_length=500,
        description="Error message",
    )

    # Provider details
    provider_message_id: Optional[str] = Field(
        None,
        max_length=255,
        description="Provider's message ID",
    )
    provider_response: Optional[Dict[str, Any]] = Field(
        None,
        description="Raw provider response",
    )

    # Engagement
    was_clicked: bool = Field(
        default=False,
        description="Whether notification was clicked",
    )
    action_taken: Optional[str] = Field(
        None,
        description="Which action button was clicked (if any)",
    )


class PushStats(BaseSchema):
    """
    Push notification campaign statistics.

    Provides analytics for push notification performance.
    """

    # Send statistics
    total_sent: int = Field(
        ...,
        ge=0,
        description="Total notifications sent",
    )
    total_delivered: int = Field(
        ...,
        ge=0,
        description="Total notifications delivered",
    )
    total_failed: int = Field(
        ...,
        ge=0,
        description="Total delivery failures",
    )

    # Delivery rate
    delivery_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Delivery rate percentage",
    )

    # Platform breakdown
    ios_sent: int = Field(default=0, ge=0, description="iOS notifications sent")
    android_sent: int = Field(default=0, ge=0, description="Android notifications sent")
    web_sent: int = Field(default=0, ge=0, description="Web notifications sent")

    ios_delivered: int = Field(default=0, ge=0, description="iOS delivered")
    android_delivered: int = Field(default=0, ge=0, description="Android delivered")
    web_delivered: int = Field(default=0, ge=0, description="Web delivered")

    # Engagement statistics
    total_opened: int = Field(
        ...,
        ge=0,
        description="Total notifications clicked/opened",
    )
    open_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Click/open rate percentage",
    )

    # Action engagement
    total_action_clicks: int = Field(
        default=0,
        ge=0,
        description="Total action button clicks",
    )
    actions_breakdown: Dict[str, int] = Field(
        default_factory=dict,
        description="Click count by action ID",
    )

    # Time period
    period_start: date = Field(
        ...,
        description="Statistics period start",
    )
    period_end: date = Field(
        ...,
        description="Statistics period end",
    )

    @field_validator("period_end")
    @classmethod
    def validate_period(cls, v: date, info) -> date:
        """Validate period end is after period start."""
        period_start = info.data.get("period_start")
        if period_start and v < period_start:
            raise ValueError("period_end must be after or equal to period_start")
        return v


class BulkPushRequest(BaseCreateSchema):
    """
    Send push notifications to multiple users/devices in bulk.

    Optimized for mass delivery with batching and rate limiting.
    """

    # Recipients
    user_ids: Optional[List[UUID]] = Field(
        None,
        max_length=100000,
        description="List of user IDs (max 100,000)",
    )
    device_tokens: Optional[List[str]] = Field(
        None,
        max_length=100000,
        description="List of device tokens (max 100,000)",
    )
    segment: Optional[str] = Field(
        None,
        description="User segment to target",
    )

    # Content
    title: str = Field(..., min_length=1, max_length=100)
    body: str = Field(..., min_length=1, max_length=500)

    # Template support
    template_code: Optional[str] = Field(None, description="Template to use")

    # Per-user customization
    user_variables: Optional[Dict[UUID, Dict[str, str]]] = Field(
        None,
        description="Per-user variable mapping",
    )

    # Default settings
    image_url: Optional[str] = None
    icon: Optional[str] = None
    sound: str = Field(default="default")
    priority: str = Field(default="normal", pattern="^(low|normal|high)$")

    # Batch settings
    batch_size: int = Field(
        default=1000,
        ge=100,
        le=10000,
        description="Notifications per batch",
    )
    delay_between_batches_seconds: int = Field(
        default=1,
        ge=0,
        le=10,
        description="Delay between batches",
    )

    # Metadata
    campaign_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Campaign name",
    )
    tags: List[str] = Field(default_factory=list)

    @model_validator(mode="after")
    def validate_recipients(self) -> "BulkPushRequest":
        """Ensure at least one recipient group is provided."""
        if not any([self.user_ids, self.device_tokens, self.segment]):
            raise ValueError(
                "At least one recipient group (user_ids, device_tokens, or segment) required"
            )
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\notification\sms_notification.py ---
# --- File: app/schemas/notification/sms_notification.py ---
"""
SMS notification schemas.

This module provides schemas for SMS-specific notifications including
sending, delivery tracking, templates, and bulk operations.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "SMSRequest",
    "SMSConfig",
    "DeliveryStatus",
    "SMSTemplate",
    "BulkSMSRequest",
    "SMSStats",
    "SMSQuota",
]


class SMSRequest(BaseCreateSchema):
    """
    Send SMS notification request.

    Supports both direct message and template-based SMS with
    delivery tracking and priority handling.
    """

    # Recipient
    recipient_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Recipient phone number in E.164 format",
    )

    # Message content
    message: str = Field(
        ...,
        min_length=1,
        max_length=1600,  # 10 SMS segments max
        description="SMS message content (max 1600 chars)",
    )

    # Template support
    template_code: Optional[str] = Field(
        None,
        min_length=3,
        max_length=100,
        description="Template code (overrides direct message)",
    )
    template_variables: Optional[Dict[str, str]] = Field(
        None,
        description="Variables for template rendering",
    )

    # Sender configuration
    sender_id: Optional[str] = Field(
        None,
        min_length=3,
        max_length=11,
        pattern="^[a-zA-Z0-9]+$",
        description="Sender ID/Name (alphanumeric, max 11 chars)",
    )

    # Priority
    priority: str = Field(
        default="normal",
        pattern="^(low|normal|high)$",
        description="SMS delivery priority",
    )

    # DLT compliance (India-specific)
    dlt_template_id: Optional[str] = Field(
        None,
        max_length=50,
        description="DLT template ID for regulatory compliance (India)",
    )
    dlt_entity_id: Optional[str] = Field(
        None,
        max_length=50,
        description="DLT entity ID (India)",
    )

    # Scheduling
    send_at: Optional[datetime] = Field(
        None,
        description="Schedule SMS for future delivery",
    )

    # Tracking
    track_delivery: bool = Field(
        default=True,
        description="Enable delivery status tracking",
    )

    # Metadata
    tags: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Tags for categorization",
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Custom metadata",
    )

    @field_validator("message")
    @classmethod
    def validate_message_length(cls, v: str) -> str:
        """Validate message length and estimate segments."""
        # GSM-7 encoding: 160 chars per segment
        # Unicode encoding: 70 chars per segment
        if len(v) > 1600:
            raise ValueError("Message cannot exceed 1600 characters (10 segments)")
        return v

    @field_validator("recipient_phone")
    @classmethod
    def normalize_phone_number(cls, v: str) -> str:
        """Normalize phone number to E.164 format."""
        # Remove any spaces, hyphens, or parentheses
        normalized = v.replace(" ", "").replace("-", "").replace("(", "").replace(")", "")
        
        # Ensure it starts with +
        if not normalized.startswith("+"):
            # Assume +91 for India if no country code
            if len(normalized) == 10:
                normalized = f"+91{normalized}"
            else:
                normalized = f"+{normalized}"
        
        return normalized

    @field_validator("send_at")
    @classmethod
    def validate_send_time(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate scheduled send time is in the future."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Scheduled send time must be in the future")
        return v

    @model_validator(mode="after")
    def validate_content_or_template(self) -> "SMSRequest":
        """Ensure either direct message or template is provided."""
        if self.template_code:
            if not self.template_variables:
                raise ValueError(
                    "template_variables required when using template_code"
                )
        else:
            if not self.message:
                raise ValueError(
                    "message required when not using template_code"
                )
        return self


class SMSConfig(BaseSchema):
    """
    SMS service configuration.

    Supports multiple SMS gateway providers with unified configuration.
    """

    # Service provider
    service_provider: str = Field(
        ...,
        pattern="^(twilio|aws_sns|msg91|vonage|plivo|custom)$",
        description="SMS service provider",
    )

    # API credentials
    account_sid: Optional[str] = Field(
        None,
        max_length=255,
        description="Account SID/ID",
    )
    auth_token: Optional[str] = Field(
        None,
        max_length=500,
        description="Authentication token/API key",
    )
    api_key: Optional[str] = Field(
        None,
        max_length=500,
        description="API key (alternative to auth_token)",
    )

    # Sender configuration
    default_sender_id: str = Field(
        ...,
        min_length=3,
        max_length=11,
        description="Default sender ID",
    )

    # Rate limiting
    max_sms_per_hour: int = Field(
        default=100,
        ge=1,
        le=10000,
        description="Maximum SMS per hour",
    )
    max_sms_per_day: int = Field(
        default=1000,
        ge=1,
        le=100000,
        description="Maximum SMS per day",
    )
    max_sms_per_recipient_per_day: int = Field(
        default=10,
        ge=1,
        le=100,
        description="Maximum SMS per recipient per day",
    )

    # Country settings
    default_country_code: str = Field(
        default="+91",
        pattern=r"^\+\d{1,3}$",
        description="Default country code",
    )
    allowed_country_codes: List[str] = Field(
        default_factory=lambda: ["+91"],
        description="Allowed destination country codes",
    )

    # DLT settings (India)
    dlt_enabled: bool = Field(
        default=False,
        description="Enable DLT compliance checking",
    )
    dlt_entity_id: Optional[str] = Field(
        None,
        description="Default DLT entity ID",
    )

    # Delivery reports
    delivery_report_webhook_url: Optional[str] = Field(
        None,
        max_length=500,
        description="Webhook URL for delivery reports",
    )

    # Cost settings
    cost_per_sms: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Cost per SMS unit",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        description="Currency code (ISO 4217)",
    )


class DeliveryStatus(BaseSchema):
    """
    SMS delivery status and tracking information.

    Tracks the complete lifecycle of an SMS from queue to delivery.
    """

    sms_id: UUID = Field(
        ...,
        description="SMS notification ID",
    )
    recipient_phone: str = Field(
        ...,
        description="Recipient phone number",
    )

    # Delivery status
    status: str = Field(
        ...,
        pattern="^(queued|sent|delivered|failed|undelivered|expired|rejected)$",
        description="Current delivery status",
    )

    # Timeline
    queued_at: datetime = Field(
        ...,
        description="When SMS was queued",
    )
    sent_at: Optional[datetime] = Field(
        None,
        description="When SMS was sent to provider",
    )
    delivered_at: Optional[datetime] = Field(
        None,
        description="When SMS was delivered to recipient",
    )
    failed_at: Optional[datetime] = Field(
        None,
        description="When delivery failed",
    )

    # Error information
    error_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Error code from provider",
    )
    error_message: Optional[str] = Field(
        None,
        max_length=500,
        description="Human-readable error message",
    )

    # Provider details
    provider_message_id: Optional[str] = Field(
        None,
        max_length=255,
        description="Provider's unique message ID",
    )
    provider_status: Optional[str] = Field(
        None,
        max_length=100,
        description="Raw status from provider",
    )

    # Message details
    segments_count: int = Field(
        default=1,
        ge=1,
        le=10,
        description="Number of SMS segments used",
    )
    character_count: int = Field(
        ...,
        ge=1,
        description="Total character count",
    )
    encoding: str = Field(
        default="GSM-7",
        pattern="^(GSM-7|Unicode)$",
        description="Message encoding used",
    )

    # Cost
    cost: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Cost for this SMS",
    )
    currency: Optional[str] = Field(
        None,
        min_length=3,
        max_length=3,
        description="Currency code",
    )

    # Retry information
    retry_count: int = Field(
        default=0,
        ge=0,
        description="Number of retry attempts",
    )


class SMSTemplate(BaseSchema):
    """
    SMS-specific template configuration.

    Optimized for SMS constraints with character counting and
    DLT compliance support.
    """

    template_code: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Unique template identifier",
    )

    # Message template
    message_template: str = Field(
        ...,
        min_length=1,
        max_length=1600,
        description="SMS message template with {{variables}}",
    )

    # Variables
    required_variables: List[str] = Field(
        ...,
        description="Required template variables",
    )
    optional_variables: List[str] = Field(
        default_factory=list,
        description="Optional template variables",
    )

    # Character analysis
    estimated_length: int = Field(
        ...,
        ge=1,
        description="Estimated character length (without variables)",
    )
    estimated_segments: int = Field(
        ...,
        ge=1,
        le=10,
        description="Estimated SMS segments",
    )

    # DLT compliance (India)
    dlt_template_id: Optional[str] = Field(
        None,
        max_length=50,
        description="DLT approved template ID",
    )
    dlt_approved: bool = Field(
        default=False,
        description="Whether template is DLT approved",
    )
    dlt_approval_date: Optional[date] = Field(
        None,
        description="Date of DLT approval",
    )

    # Category
    category: Optional[str] = Field(
        None,
        max_length=50,
        pattern="^(transactional|promotional|otp|alert)$",
        description="SMS category",
    )


class BulkSMSRequest(BaseCreateSchema):
    """
    Send bulk SMS to multiple recipients.

    Optimized for batch sending with rate limiting and cost estimation.
    """

    recipients: List[str] = Field(
        ...,
        min_length=1,
        max_length=10000,
        description="List of recipient phone numbers (max 10,000)",
    )

    # Message content
    message: str = Field(
        ...,
        min_length=1,
        max_length=1600,
        description="SMS message content",
    )

    # Template support
    template_code: Optional[str] = Field(
        None,
        description="Template code for all SMS",
    )

    # Per-recipient customization
    recipient_variables: Optional[Dict[str, Dict[str, str]]] = Field(
        None,
        description="Per-recipient variable mapping (phone -> variables)",
    )

    # Sender
    sender_id: Optional[str] = Field(
        None,
        max_length=11,
        description="Sender ID for all SMS",
    )

    # Batch settings
    batch_size: int = Field(
        default=100,
        ge=10,
        le=1000,
        description="Number of SMS per batch",
    )
    delay_between_batches_seconds: int = Field(
        default=2,
        ge=1,
        le=10,
        description="Delay between batches in seconds",
    )

    # Scheduling
    send_at: Optional[datetime] = Field(
        None,
        description="Schedule bulk send for future",
    )

    # DLT (India)
    dlt_template_id: Optional[str] = Field(
        None,
        description="DLT template ID for all SMS",
    )

    # Metadata
    campaign_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Campaign name for tracking",
    )
    tags: List[str] = Field(
        default_factory=list,
        description="Tags for this bulk send",
    )

    @field_validator("recipients")
    @classmethod
    def validate_unique_recipients(cls, v: List[str]) -> List[str]:
        """Ensure recipient list doesn't contain duplicates."""
        if len(v) != len(set(v)):
            raise ValueError("Duplicate phone numbers in recipients list")
        return v

    @field_validator("recipients")
    @classmethod
    def validate_phone_numbers(cls, v: List[str]) -> List[str]:
        """Validate all phone numbers are in correct format."""
        import re
        phone_pattern = r"^\+?[1-9]\d{9,14}$"
        for phone in v:
            if not re.match(phone_pattern, phone):
                raise ValueError(f"Invalid phone number format: {phone}")
        return v


class SMSStats(BaseSchema):
    """
    SMS campaign statistics and metrics.

    Provides comprehensive analytics for SMS performance and costs.
    """

    # Send statistics
    total_sent: int = Field(
        ...,
        ge=0,
        description="Total SMS sent",
    )
    total_delivered: int = Field(
        ...,
        ge=0,
        description="Total SMS delivered",
    )
    total_failed: int = Field(
        ...,
        ge=0,
        description="Total SMS failed",
    )
    total_pending: int = Field(
        default=0,
        ge=0,
        description="Total SMS pending delivery",
    )

    # Delivery rates
    delivery_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Delivery rate percentage",
    )
    failure_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Failure rate percentage",
    )

    # Cost analysis
    total_cost: Decimal = Field(
        ...,
        ge=0,
        description="Total cost for period",
    )
    average_cost_per_sms: Decimal = Field(
        ...,
        ge=0,
        description="Average cost per SMS",
    )
    currency: str = Field(
        ...,
        min_length=3,
        max_length=3,
        description="Currency code",
    )

    # Segment analysis
    total_segments: int = Field(
        ...,
        ge=0,
        description="Total SMS segments used",
    )
    average_segments_per_sms: Decimal = Field(
        ...,
        ge=0,
        description="Average segments per SMS",
    )

    # Breakdown by status
    delivered_count: int = Field(..., ge=0)
    failed_count: int = Field(..., ge=0)
    pending_count: int = Field(..., ge=0)
    expired_count: int = Field(default=0, ge=0)
    rejected_count: int = Field(default=0, ge=0)

    # Time period
    period_start: date = Field(
        ...,
        description="Statistics period start date",
    )
    period_end: date = Field(
        ...,
        description="Statistics period end date",
    )

    @field_validator("period_end")
    @classmethod
    def validate_period(cls, v: date, info) -> date:
        """Validate period end is after period start."""
        period_start = info.data.get("period_start")
        if period_start and v < period_start:
            raise ValueError("period_end must be after or equal to period_start")
        return v


class SMSQuota(BaseSchema):
    """
    SMS quota and usage tracking.

    Tracks SMS usage against configured limits.
    """

    # Quotas
    hourly_quota: int = Field(..., ge=0, description="Hourly SMS quota")
    daily_quota: int = Field(..., ge=0, description="Daily SMS quota")
    monthly_quota: int = Field(..., ge=0, description="Monthly SMS quota")

    # Usage
    hourly_usage: int = Field(..., ge=0, description="SMS sent this hour")
    daily_usage: int = Field(..., ge=0, description="SMS sent today")
    monthly_usage: int = Field(..., ge=0, description="SMS sent this month")

    # Remaining
    hourly_remaining: int = Field(..., ge=0, description="Remaining hourly quota")
    daily_remaining: int = Field(..., ge=0, description="Remaining daily quota")
    monthly_remaining: int = Field(..., ge=0, description="Remaining monthly quota")

    # Reset times
    hourly_reset_at: datetime = Field(..., description="When hourly quota resets")
    daily_reset_at: datetime = Field(..., description="When daily quota resets")
    monthly_reset_at: datetime = Field(..., description="When monthly quota resets")

    # Status
    is_quota_exceeded: bool = Field(
        ...,
        description="Whether any quota is exceeded",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\notification\__init__.py ---
# --- File: app/schemas/notification/__init__.py ---
"""
Notification schemas package.

Provides comprehensive schemas for notification management including
email, SMS, push notifications, templates, preferences, routing, and queues.
"""

from __future__ import annotations

# Base notification schemas
from app.schemas.notification.notification_base import (
    BulkMarkAsRead,
    MarkAsRead,
    NotificationBase,
    NotificationCreate,
    NotificationDelete,
    NotificationUpdate,
)

# Response schemas
from app.schemas.notification.notification_response import (
    NotificationDetail,
    NotificationList,
    NotificationListItem,
    NotificationResponse,
    NotificationSummary,
    UnreadCount,
)

# Template schemas
from app.schemas.notification.notification_template import (
    TemplateCategory,
    TemplateCopyRequest,
    TemplateCreate,
    TemplateList,
    TemplatePreview,
    TemplatePreviewResponse,
    TemplateResponse,
    TemplateUpdate,
    VariableMapping,
)

# Email schemas
from app.schemas.notification.email_notification import (
    BulkEmailRequest,
    EmailAttachment,
    EmailConfig,
    EmailRequest,
    EmailSchedule,
    EmailStats,
    EmailTemplate,
    EmailTracking,
)

# SMS schemas
from app.schemas.notification.sms_notification import (
    BulkSMSRequest,
    DeliveryStatus,
    SMSConfig,
    SMSQuota,
    SMSRequest,
    SMSStats,
    SMSTemplate,
)

# Push notification schemas
from app.schemas.notification.push_notification import (
    BulkPushRequest,
    DeviceRegistration,
    DeviceToken,
    DeviceUnregistration,
    PushAction,
    PushConfig,
    PushDeliveryStatus,
    PushRequest,
    PushStats,
    PushTemplate,
)

# Queue schemas
from app.schemas.notification.notification_queue import (
    BatchProcessing,
    QueuedNotification,
    QueueHealth,
    QueuePriority,
    QueueStats,
    QueueStatus,
)

# Preference schemas
from app.schemas.notification.notification_preferences import (
    ChannelPreferences,
    EmailPreferences,
    FrequencySettings,
    PreferenceUpdate,
    PushPreferences,
    QuietHours,
    SMSPreferences,
    UnsubscribeRequest,
    UserPreferences,
)

# Routing schemas
from app.schemas.notification.notification_routing import (
    EscalationLevel,
    EscalationRouting,
    HierarchicalRouting,
    NotificationRoute,
    RoutingCondition,
    RoutingConfig,
    RoutingRule,
)

__all__ = [
    # Base
    "NotificationBase",
    "NotificationCreate",
    "NotificationUpdate",
    "MarkAsRead",
    "BulkMarkAsRead",
    "NotificationDelete",
    # Response
    "NotificationResponse",
    "NotificationDetail",
    "NotificationList",
    "NotificationListItem",
    "UnreadCount",
    "NotificationSummary",
    # Template
    "TemplateCreate",
    "TemplateUpdate",
    "TemplateResponse",
    "VariableMapping",
    "TemplatePreview",
    "TemplatePreviewResponse",
    "TemplateList",
    "TemplateCategory",
    "TemplateCopyRequest",
    # Email
    "EmailRequest",
    "EmailConfig",
    "EmailTracking",
    "EmailTemplate",
    "BulkEmailRequest",
    "EmailStats",
    "EmailAttachment",
    "EmailSchedule",
    # SMS
    "SMSRequest",
    "SMSConfig",
    "DeliveryStatus",
    "SMSTemplate",
    "BulkSMSRequest",
    "SMSStats",
    "SMSQuota",
    # Push
    "PushRequest",
    "PushConfig",
    "DeviceToken",
    "DeviceRegistration",
    "DeviceUnregistration",
    "PushTemplate",
    "PushDeliveryStatus",
    "PushStats",
    "PushAction",
    "BulkPushRequest",
    # Queue
    "QueueStatus",
    "QueuedNotification",
    "BatchProcessing",
    "QueueStats",
    "QueueHealth",
    "QueuePriority",
    # Preferences
    "UserPreferences",
    "ChannelPreferences",
    "EmailPreferences",
    "SMSPreferences",
    "PushPreferences",
    "FrequencySettings",
    "PreferenceUpdate",
    "UnsubscribeRequest",
    "QuietHours",
    # Routing
    "RoutingConfig",
    "RoutingRule",
    "RoutingCondition",
    "HierarchicalRouting",
    "EscalationRouting",
    "EscalationLevel",
    "NotificationRoute",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\payment =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\payment ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\payment =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_base.py ---
"""
Payment base schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseUpdateSchema, BaseSchema
from app.schemas.common.enums import PaymentType, PaymentMethod, PaymentStatus


class PaymentBase(BaseSchema):
    """Base payment schema"""
    payer_id: UUID = Field(..., description="User making payment")
    hostel_id: UUID = Field(..., description="Hostel receiving payment")
    student_id: Optional[UUID] = Field(None, description="Student profile (for recurring fees)")
    booking_id: Optional[UUID] = Field(None, description="Booking (for booking payments)")
    
    # Payment details
    payment_type: PaymentType = Field(..., description="Type of payment")
    amount: Decimal = Field(..., ge=0, max_digits=10, decimal_places=2, description="Payment amount")
    currency: str = Field("INR", min_length=3, max_length=3, description="Currency code")
    
    # Period covered (for recurring fees)
    payment_period_start: Optional[date] = Field(None, description="Period start date")
    payment_period_end: Optional[date] = Field(None, description="Period end date")
    
    # Payment method
    payment_method: PaymentMethod = Field(..., description="Payment method")
    payment_gateway: Optional[str] = Field(None, description="Gateway used (razorpay/stripe/paytm)")
    
    # Due date (for scheduled payments)
    due_date: Optional[date] = Field(None, description="Payment due date")


class PaymentCreate(PaymentBase, BaseCreateSchema):
    """Create payment schema"""
    # Additional creation fields
    transaction_id: Optional[str] = Field(None, description="External transaction ID")
    collected_by: Optional[UUID] = Field(None, description="Staff who collected (for cash/cheque)")


class PaymentUpdate(BaseUpdateSchema):
    """Update payment schema"""
    payment_status: Optional[PaymentStatus] = None
    transaction_id: Optional[str] = None
    paid_at: Optional[datetime] = None
    failed_at: Optional[datetime] = None
    failure_reason: Optional[str] = None
    
    # Receipt
    receipt_number: Optional[str] = None
    receipt_url: Optional[str] = None

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_filters.py ---
"""
Payment filter and search schemas
"""
from datetime import date
from decimal import Decimal
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import PaymentType, PaymentMethod, PaymentStatus


class PaymentFilterParams(BaseFilterSchema):
    """Payment filter parameters"""
    # Text search
    search: Optional[str] = Field(None, description="Search in reference, payer name, transaction ID")
    
    # Entity filters
    hostel_id: Optional[UUID] = None
    hostel_ids: Optional[List[UUID]] = None
    student_id: Optional[UUID] = None
    payer_id: Optional[UUID] = None
    
    # Payment type
    payment_type: Optional[PaymentType] = None
    payment_types: Optional[List[PaymentType]] = None
    
    # Payment method
    payment_method: Optional[PaymentMethod] = None
    payment_methods: Optional[List[PaymentMethod]] = None
    
    # Status
    payment_status: Optional[PaymentStatus] = None
    payment_statuses: Optional[List[PaymentStatus]] = None
    
    # Amount range
    amount_min: Optional[Decimal] = Field(None, ge=0)
    amount_max: Optional[Decimal] = Field(None, ge=0)
    
    # Date filters
    paid_date_from: Optional[date] = None
    paid_date_to: Optional[date] = None
    due_date_from: Optional[date] = None
    due_date_to: Optional[date] = None
    created_date_from: Optional[date] = None
    created_date_to: Optional[date] = None
    
    # Overdue filter
    overdue_only: Optional[bool] = None
    
    # Gateway
    payment_gateway: Optional[str] = None


class PaymentSearchRequest(BaseFilterSchema):
    """Payment search request"""
    query: str = Field(..., min_length=1, description="Search query")
    hostel_id: Optional[UUID] = None
    
    # Search fields
    search_in_reference: bool = Field(True)
    search_in_payer_name: bool = Field(True)
    search_in_transaction_id: bool = Field(True)
    
    # Filters
    payment_status: Optional[PaymentStatus] = None
    
    # Pagination
    page: int = Field(1, ge=1)
    page_size: int = Field(20, ge=1, le=100)


class PaymentReportRequest(BaseFilterSchema):
    """Payment report generation request"""
    hostel_id: Optional[UUID] = None
    
    # Date range (required)
    date_from: date = Field(..., description="Report start date")
    date_to: date = Field(..., description="Report end date")
    
    # Filters
    payment_types: Optional[List[PaymentType]] = None
    payment_methods: Optional[List[PaymentMethod]] = None
    
    # Grouping
    group_by: str = Field("day", pattern="^(day|week|month|payment_type|payment_method)$")
    
    # Format
    format: str = Field("pdf", pattern="^(pdf|excel|csv)$")
    
    # Include details
    include_transaction_details: bool = Field(True)
    include_student_details: bool = Field(True)
    include_charts: bool = Field(True, description="Include charts/graphs")


class PaymentExportRequest(BaseFilterSchema):
    """Export payments data"""
    filters: PaymentFilterParams = Field(..., description="Filter criteria")
    
    format: str = Field("csv", pattern="^(csv|excel|pdf)$")
    
    # Fields to include
    include_payer_details: bool = Field(True)
    include_gateway_details: bool = Field(False)
    include_refund_details: bool = Field(True)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_gateway.py ---
"""
Payment gateway integration schemas
"""
from datetime import datetime
from decimal import Decimal
from typing import Optional, Dict, Any
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class GatewayRequest(BaseSchema):
    """Payment gateway request"""
    payment_id: UUID
    amount: Decimal
    currency: str
    
    # Customer details
    customer_name: str
    customer_email: str
    customer_phone: str
    
    # Order details
    order_id: str
    description: str
    
    # Callback URLs
    callback_url: str
    success_url: Optional[str]
    failure_url: Optional[str]
    
    # Additional metadata
    metadata: Dict[str, Any] = Field(default_factory=dict)


class GatewayResponse(BaseSchema):
    """Payment gateway response"""
    payment_id: UUID
    gateway_order_id: str
    gateway_payment_id: Optional[str]
    
    status: str = Field(..., pattern="^(created|pending|authorized|captured|failed)$")
    
    amount: Decimal
    currency: str
    
    # Gateway-specific data
    gateway_response: Dict[str, Any]
    
    # Timestamps
    created_at: datetime
    updated_at: datetime


class GatewayWebhook(BaseCreateSchema):
    """Payment gateway webhook payload"""
    event_type: str = Field(..., description="Event type from gateway")
    
    # Gateway identifiers
    gateway_order_id: str
    gateway_payment_id: Optional[str]
    
    # Payment details
    amount: Decimal
    currency: str
    status: str
    
    # Full webhook payload
    raw_payload: Dict[str, Any] = Field(..., description="Complete webhook payload")
    
    # Signature verification
    signature: str = Field(..., description="Webhook signature")
    
    # Timestamp
    event_timestamp: datetime


class GatewayCallback(BaseSchema):
    """Payment gateway callback processing"""
    payment_id: UUID
    gateway_payment_id: str
    
    success: bool
    status: str
    
    amount_paid: Decimal
    
    # Error details (if failed)
    error_code: Optional[str] = None
    error_message: Optional[str] = None
    
    # Additional data
    callback_data: Dict[str, Any]


class GatewayRefundRequest(BaseCreateSchema):
    """Refund request to gateway"""
    payment_id: UUID
    gateway_payment_id: str
    
    refund_amount: Decimal
    reason: str = Field(..., min_length=10, max_length=500)
    
    # Speed
    refund_speed: str = Field("normal", pattern="^(normal|instant)$")


class GatewayRefundResponse(BaseSchema):
    """Refund response from gateway"""
    refund_id: str
    gateway_refund_id: str
    
    status: str
    amount: Decimal
    
    # Estimated timeline
    estimated_completion_date: Optional[date]
    
    gateway_response: Dict[str, Any]

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_ledger.py ---
"""
Payment ledger and account statement schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseResponseSchema


class LedgerEntry(BaseResponseSchema):
    """Individual ledger entry"""
    student_id: UUID
    hostel_id: UUID
    
    entry_date: date
    entry_type: str = Field(..., pattern="^(debit|credit)$")
    
    # Transaction details
    transaction_type: str = Field(..., description="Type of transaction")
    amount: Decimal
    
    # Running balance
    balance_before: Decimal
    balance_after: Decimal
    
    # Reference
    payment_id: Optional[UUID] = None
    payment_reference: Optional[str] = None
    
    description: str
    
    # Metadata
    created_by: Optional[UUID] = None
    notes: Optional[str] = None


class LedgerSummary(BaseSchema):
    """Ledger summary for student"""
    student_id: UUID
    student_name: str
    hostel_id: UUID
    
    # Current balance
    current_balance: Decimal
    
    # Breakdown
    total_charges: Decimal
    total_payments: Decimal
    total_refunds: Decimal
    
    # Outstanding
    total_due: Decimal
    overdue_amount: Decimal
    
    # Last transaction
    last_transaction_date: Optional[date]
    last_payment_date: Optional[date]


class AccountStatement(BaseSchema):
    """Account statement for period"""
    student_id: UUID
    student_name: str
    hostel_id: UUID
    hostel_name: str
    
    statement_period_start: date
    statement_period_end: date
    generated_at: datetime
    
    # Opening balance
    opening_balance: Decimal
    
    # Transactions
    entries: List[LedgerEntry]
    
    # Summary
    total_debits: Decimal
    total_credits: Decimal
    
    # Closing balance
    closing_balance: Decimal
    
    # Download link
    pdf_url: Optional[str] = None


class TransactionHistory(BaseSchema):
    """Transaction history"""
    student_id: UUID
    
    transactions: List["TransactionItem"]
    
    # Pagination
    total_transactions: int
    page: int
    page_size: int


class TransactionItem(BaseSchema):
    """Individual transaction in history"""
    transaction_id: UUID
    transaction_date: datetime
    transaction_type: str
    
    amount: Decimal
    balance_after: Decimal
    
    description: str
    payment_reference: Optional[str]
    
    status: str


class BalanceAdjustment(BaseSchema):
    """Manual balance adjustment (admin only)"""
    student_id: UUID
    hostel_id: UUID
    
    adjustment_type: str = Field(..., pattern="^(debit|credit)$")
    amount: Decimal = Field(..., ge=0)
    
    reason: str = Field(..., min_length=20, max_length=500)
    
    adjusted_by: UUID
    adjustment_date: date
    
    notes: Optional[str] = None


class WriteOff(BaseSchema):
    """Write off outstanding amount"""
    student_id: UUID
    amount: Decimal = Field(..., ge=0)
    
    reason: str = Field(..., min_length=20, max_length=500)
    
    approved_by: UUID
    approval_date: date
    
    # Documentation
    supporting_documents: List[str] = Field(default_factory=list)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_refund.py ---
"""
Payment refund schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema


class RefundRequest(BaseCreateSchema):
    """Request payment refund"""
    payment_id: UUID = Field(..., description="Payment ID to refund")
    refund_amount: Decimal = Field(..., ge=0, description="Amount to refund")
    
    refund_reason: str = Field(..., min_length=10, max_length=500, description="Reason for refund")
    
    # Refund type
    refund_type: str = Field(
        "full",
        pattern="^(full|partial)$",
        description="Full or partial refund"
    )
    
    # Processing
    refund_method: str = Field(
        "original_source",
        pattern="^(original_source|bank_transfer|cash|cheque)$",
        description="How to refund"
    )
    
    # Bank details (if bank_transfer)
    bank_account_number: Optional[str] = Field(None, description="Bank account number")
    bank_ifsc_code: Optional[str] = Field(None, description="IFSC code")
    account_holder_name: Optional[str] = Field(None, description="Account holder name")
    
    # Additional details
    admin_notes: Optional[str] = Field(None, max_length=500)


class RefundResponse(BaseResponseSchema):
    """Refund response"""
    refund_id: UUID
    payment_id: UUID
    payment_reference: str
    
    refund_amount: Decimal
    refund_status: str = Field(..., pattern="^(pending|processing|completed|failed)$")
    
    # Processing details
    refund_method: str
    refund_reference: Optional[str] = Field(None, description="Refund transaction reference")
    
    # Timeline
    requested_at: datetime
    processed_at: Optional[datetime]
    completed_at: Optional[datetime]
    estimated_completion_date: Optional[date]
    
    # Refund to
    refunded_to: str = Field(..., description="Destination of refund")
    
    message: str


class RefundStatus(BaseSchema):
    """Refund status tracking"""
    refund_id: UUID
    payment_reference: str
    
    refund_amount: Decimal
    currency: str
    
    status: str = Field(..., pattern="^(pending|processing|completed|failed|cancelled)$")
    
    # Timeline
    requested_at: datetime
    processing_started_at: Optional[datetime]
    completed_at: Optional[datetime]
    
    # Days elapsed
    days_since_request: int
    
    # Failure details
    failure_reason: Optional[str] = None
    
    # Next steps
    next_action: Optional[str] = None
    expected_completion_date: Optional[date] = None


class RefundApproval(BaseCreateSchema):
    """Approve refund request (admin)"""
    refund_id: UUID
    approved: bool
    
    # If approved
    processing_notes: Optional[str] = None
    
    # If rejected
    rejection_reason: Optional[str] = None


class RefundList(BaseSchema):
    """List of refunds"""
    total_refunds: int
    total_amount_refunded: Decimal
    
    refunds: List["RefundListItem"]


class RefundListItem(BaseSchema):
    """Refund list item"""
    refund_id: UUID
    payment_reference: str
    student_name: str
    
    refund_amount: Decimal
    status: str
    
    requested_at: datetime
    completed_at: Optional[datetime]

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_reminder.py ---
"""
Payment reminder schemas
"""
from datetime import datetime, date
from typing import Optional, List
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema


class ReminderConfig(BaseSchema):
    """Payment reminder configuration"""
    hostel_id: UUID
    
    # Reminder timing
    days_before_due: List[int] = Field(
        default_factory=lambda: [7, 3, 1],
        description="Days before due date to send reminders"
    )
    days_after_due: List[int] = Field(
        default_factory=lambda: [1, 3, 7, 15],
        description="Days after due date for overdue reminders"
    )
    
    # Channels
    send_email: bool = Field(True)
    send_sms: bool = Field(True)
    send_push: bool = Field(True)
    
    # Escalation
    escalate_after_days: int = Field(15, description="Escalate to admin after days")
    
    # Template
    email_template_id: Optional[UUID] = None
    sms_template_id: Optional[UUID] = None
    
    is_active: bool = Field(True)


class ReminderLog(BaseResponseSchema):
    """Payment reminder log entry"""
    payment_id: UUID
    payment_reference: str
    
    student_id: UUID
    student_name: str
    student_email: str
    student_phone: str
    
    # Reminder details
    reminder_type: str = Field(..., pattern="^(due_soon|overdue|final_notice)$")
    reminder_channel: str = Field(..., pattern="^(email|sms|push)$")
    
    # Status
    sent_at: datetime
    delivery_status: str = Field(..., pattern="^(sent|delivered|failed|bounced)$")
    
    # Content
    subject: Optional[str] = None
    message_preview: str
    
    # Response
    opened: bool = Field(False, description="Email opened")
    clicked: bool = Field(False, description="Link clicked")


class SendReminderRequest(BaseCreateSchema):
    """Send payment reminder manually"""
    payment_id: Optional[UUID] = Field(None, description="Specific payment")
    student_id: Optional[UUID] = Field(None, description="All due payments for student")
    hostel_id: Optional[UUID] = Field(None, description="All due payments for hostel")
    
    # Reminder settings
    reminder_type: str = Field("overdue", pattern="^(due_soon|overdue|final_notice)$")
    
    channels: List[str] = Field(
        default_factory=lambda: ["email", "sms"],
        description="Channels to use"
    )
    
    # Custom message
    custom_message: Optional[str] = Field(None, max_length=500)


class ReminderBatch(BaseSchema):
    """Batch reminder sending"""
    batch_id: UUID
    
    total_payments: int
    reminders_sent: int
    reminders_failed: int
    
    # Breakdown by channel
    email_sent: int
    sms_sent: int
    push_sent: int
    
    started_at: datetime
    completed_at: Optional[datetime]
    
    status: str = Field(..., pattern="^(processing|completed|failed)$")


class ReminderStats(BaseSchema):
    """Reminder statistics"""
    hostel_id: UUID
    period_start: date
    period_end: date
    
    total_reminders_sent: int
    
    # By type
    due_soon_reminders: int
    overdue_reminders: int
    final_notices: int
    
    # By channel
    email_reminders: int
    sms_reminders: int
    push_reminders: int
    
    # Effectiveness
    payment_rate_after_reminder: Decimal = Field(..., description="% who paid after reminder")
    average_days_to_payment: Decimal

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_request.py ---
"""
Payment request schemas
"""
from datetime import date
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import PaymentType, PaymentMethod


class PaymentRequest(BaseCreateSchema):
    """Online payment request"""
    hostel_id: UUID = Field(..., description="Hostel ID")
    student_id: Optional[UUID] = Field(None, description="Student ID (for recurring fees)")
    booking_id: Optional[UUID] = Field(None, description="Booking ID (for booking payment)")
    
    payment_type: PaymentType = Field(..., description="Type of payment")
    amount: Decimal = Field(..., ge=0, description="Amount to pay")
    
    # For recurring fees
    payment_period_start: Optional[date] = None
    payment_period_end: Optional[date] = None
    
    # Payment method
    payment_method: PaymentMethod = Field(PaymentMethod.PAYMENT_GATEWAY, description="Payment method")
    payment_gateway: str = Field("razorpay", pattern="^(razorpay|stripe|paytm)$")
    
    # Return URLs
    success_url: Optional[str] = Field(None, description="URL to redirect on success")
    failure_url: Optional[str] = Field(None, description="URL to redirect on failure")
    cancel_url: Optional[str] = Field(None, description="URL if payment cancelled")


class PaymentInitiation(BaseSchema):
    """Payment initiation response"""
    payment_id: UUID
    payment_reference: str
    
    amount: Decimal
    currency: str
    
    # Gateway details
    gateway: str
    gateway_order_id: str
    gateway_key: str
    
    # Checkout info
    checkout_url: Optional[str] = None
    checkout_token: Optional[str] = None
    
    # For client-side integration
    gateway_options: dict = Field(..., description="Gateway-specific options")


class ManualPaymentRequest(BaseCreateSchema):
    """Manual payment recording (cash/cheque)"""
    hostel_id: UUID
    student_id: UUID
    
    payment_type: PaymentType
    amount: Decimal = Field(..., ge=0)
    
    payment_method: PaymentMethod = Field(..., pattern="^(cash|cheque|bank_transfer)$")
    
    # For cheque
    cheque_number: Optional[str] = None
    cheque_date: Optional[date] = None
    bank_name: Optional[str] = None
    
    # For bank transfer
    transaction_reference: Optional[str] = None
    transfer_date: Optional[date] = None
    
    # Period
    payment_period_start: Optional[date] = None
    payment_period_end: Optional[date] = None
    
    # Collection details
    collected_by: UUID = Field(..., description="Staff member who collected")
    collection_date: date = Field(..., description="Date of collection")
    
    notes: Optional[str] = Field(None, max_length=500)


class BulkPaymentRequest(BaseCreateSchema):
    """Record multiple payments"""
    hostel_id: UUID
    payments: List["SinglePaymentRecord"] = Field(..., min_items=1, max_items=100)
    
    collected_by: UUID
    collection_date: date


class SinglePaymentRecord(BaseSchema):
    """Single payment in bulk"""
    student_id: UUID
    payment_type: PaymentType
    amount: Decimal
    payment_method: PaymentMethod
    
    # Optional fields
    transaction_reference: Optional[str] = None
    notes: Optional[str] = None

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_response.py ---
"""
Payment response schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import PaymentType, PaymentMethod, PaymentStatus


class PaymentResponse(BaseResponseSchema):
    """Payment response schema"""
    payment_reference: str
    transaction_id: Optional[str]
    
    payer_id: UUID
    payer_name: str
    hostel_id: UUID
    hostel_name: str
    
    payment_type: PaymentType
    amount: Decimal
    currency: str
    
    payment_method: PaymentMethod
    payment_status: PaymentStatus
    
    paid_at: Optional[datetime]
    due_date: Optional[date]
    is_overdue: bool
    
    receipt_number: Optional[str]
    receipt_url: Optional[str]


class PaymentDetail(BaseResponseSchema):
    """Detailed payment information"""
    payment_reference: str
    transaction_id: Optional[str]
    
    # Payer details
    payer_id: UUID
    payer_name: str
    payer_email: str
    payer_phone: str
    
    # Payee details
    hostel_id: UUID
    hostel_name: str
    
    # Related entities
    student_id: Optional[UUID]
    student_name: Optional[str]
    booking_id: Optional[UUID]
    booking_reference: Optional[str]
    
    # Payment details
    payment_type: PaymentType
    amount: Decimal
    currency: str
    
    # Period
    payment_period_start: Optional[date]
    payment_period_end: Optional[date]
    
    # Method
    payment_method: PaymentMethod
    payment_gateway: Optional[str]
    
    # Status
    payment_status: PaymentStatus
    paid_at: Optional[datetime]
    failed_at: Optional[datetime]
    failure_reason: Optional[str]
    
    # Gateway response
    gateway_response: Optional[dict]
    
    # Receipt
    receipt_number: Optional[str]
    receipt_url: Optional[str]
    receipt_generated_at: Optional[datetime]
    
    # Refund
    refund_amount: Decimal
    refund_status: str
    refunded_at: Optional[datetime]
    refund_transaction_id: Optional[str]
    refund_reason: Optional[str]
    
    # Collection
    collected_by: Optional[UUID]
    collected_by_name: Optional[str]
    collected_at: Optional[datetime]
    
    # Due date
    due_date: Optional[date]
    is_overdue: bool
    
    # Reminders
    reminder_sent_count: int
    last_reminder_sent_at: Optional[datetime]


class PaymentReceipt(BaseSchema):
    """Payment receipt"""
    receipt_number: str
    payment_reference: str
    
    # Payer
    payer_name: str
    payer_email: str
    payer_phone: str
    
    # Hostel
    hostel_name: str
    hostel_address: str
    hostel_phone: str
    
    # Payment details
    payment_type: str
    amount: Decimal
    amount_in_words: str
    currency: str
    
    payment_method: str
    transaction_id: Optional[str]
    
    # Period
    payment_for_period: Optional[str] = Field(None, description="e.g., 'January 2024'")
    
    # Dates
    payment_date: datetime
    due_date: Optional[date]
    
    # Receipt metadata
    receipt_generated_at: datetime
    receipt_url: str
    
    # Tax/GST details (if applicable)
    tax_details: Optional[dict] = None


class PaymentListItem(BaseSchema):
    """Payment list item"""
    id: UUID
    payment_reference: str
    payer_name: str
    hostel_name: str
    
    payment_type: str
    amount: Decimal
    
    payment_method: str
    payment_status: PaymentStatus
    
    paid_at: Optional[datetime]
    due_date: Optional[date]
    is_overdue: bool
    
    created_at: datetime


class PaymentSummary(BaseSchema):
    """Payment summary for student/hostel"""
    entity_id: UUID
    entity_type: str = Field(..., pattern="^(student|hostel)$")
    
    # Totals
    total_paid: Decimal
    total_pending: Decimal
    total_overdue: Decimal
    
    # Last payment
    last_payment_date: Optional[date]
    last_payment_amount: Optional[Decimal]
    
    # Next payment
    next_payment_due_date: Optional[date]
    next_payment_amount: Optional[Decimal]
    
    # Count
    total_payments: int
    completed_payments: int
    pending_payments: int

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_schedule.py ---
"""
Payment schedule schemas
"""
from datetime import date
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseUpdateSchema, BaseResponseSchema
from app.schemas.common.enums import FeeType, PaymentType


class PaymentSchedule(BaseResponseSchema):
    """Payment schedule"""
    student_id: UUID
    student_name: str
    hostel_id: UUID
    hostel_name: str
    
    fee_type: FeeType
    amount: Decimal
    
    start_date: date
    end_date: Optional[date]
    next_due_date: date
    
    auto_generate_invoice: bool
    is_active: bool


class ScheduleCreate(BaseCreateSchema):
    """Create payment schedule"""
    student_id: UUID = Field(..., description="Student ID")
    hostel_id: UUID = Field(..., description="Hostel ID")
    
    fee_type: FeeType = Field(..., description="Fee type (monthly/quarterly/etc)")
    amount: Decimal = Field(..., ge=0, description="Amount per period")
    
    start_date: date = Field(..., description="Schedule start date")
    end_date: Optional[date] = Field(None, description="Schedule end date (null for indefinite)")
    
    # First due date
    first_due_date: date = Field(..., description="First payment due date")
    
    # Settings
    auto_generate_invoice: bool = Field(True, description="Auto-generate invoices")
    send_reminders: bool = Field(True, description="Send payment reminders")


class ScheduleUpdate(BaseUpdateSchema):
    """Update payment schedule"""
    amount: Optional[Decimal] = Field(None, ge=0)
    next_due_date: Optional[date] = None
    end_date: Optional[date] = None
    auto_generate_invoice: Optional[bool] = None
    is_active: Optional[bool] = None


class ScheduleGeneration(BaseSchema):
    """Generate scheduled payments"""
    schedule_id: UUID
    
    # Generate for period
    generate_from_date: date
    generate_to_date: date
    
    # Options
    skip_if_already_paid: bool = Field(True)
    send_notifications: bool = Field(True)


class ScheduledPaymentGenerated(BaseSchema):
    """Result of schedule generation"""
    schedule_id: UUID
    
    payments_generated: int
    payments_skipped: int
    
    generated_payment_ids: List[UUID]
    
    next_generation_date: date


class BulkScheduleCreate(BaseCreateSchema):
    """Create schedules for multiple students"""
    hostel_id: UUID
    student_ids: List[UUID] = Field(..., min_items=1)
    
    fee_type: FeeType
    amount: Decimal = Field(..., ge=0)
    
    start_date: date
    first_due_date: date


class ScheduleSuspension(BaseCreateSchema):
    """Suspend payment schedule temporarily"""
    schedule_id: UUID
    suspension_reason: str = Field(..., min_length=10, max_length=500)
    
    suspend_from_date: date
    suspend_to_date: date
    
    skip_dues_during_suspension: bool = Field(True, description="Skip generating dues during suspension")

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\__init__.py ---
"""
Payment schemas package
"""
from app.schemas.payment.payment_base import (
    PaymentBase,
    PaymentCreate,
    PaymentUpdate
)
from app.schemas.payment.payment_response import (
    PaymentResponse,
    PaymentDetail,
    PaymentReceipt,
    PaymentListItem
)
from app.schemas.payment.payment_request import (
    PaymentRequest,
    PaymentInitiation,
    ManualPaymentRequest
)
from app.schemas.payment.payment_gateway import (
    GatewayRequest,
    GatewayResponse,
    GatewayWebhook,
    GatewayCallback
)
from app.schemas.payment.payment_refund import (
    RefundRequest,
    RefundResponse,
    RefundStatus
)
from app.schemas.payment.payment_schedule import (
    PaymentSchedule,
    ScheduleCreate,
    ScheduleUpdate,
    ScheduleGeneration
)
from app.schemas.payment.payment_reminder import (
    ReminderConfig,
    ReminderLog,
    SendReminderRequest
)
from app.schemas.payment.payment_ledger import (
    LedgerEntry,
    LedgerSummary,
    AccountStatement
)
from app.schemas.payment.payment_filters import (
    PaymentFilterParams,
    PaymentSearchRequest,
    PaymentReportRequest
)

__all__ = [
    # Base
    "PaymentBase",
    "PaymentCreate",
    "PaymentUpdate",
    
    # Response
    "PaymentResponse",
    "PaymentDetail",
    "PaymentReceipt",
    "PaymentListItem",
    
    # Request
    "PaymentRequest",
    "PaymentInitiation",
    "ManualPaymentRequest",
    
    # Gateway
    "GatewayRequest",
    "GatewayResponse",
    "GatewayWebhook",
    "GatewayCallback",
    
    # Refund
    "RefundRequest",
    "RefundResponse",
    "RefundStatus",
    
    # Schedule
    "PaymentSchedule",
    "ScheduleCreate",
    "ScheduleUpdate",
    "ScheduleGeneration",
    
    # Reminder
    "ReminderConfig",
    "ReminderLog",
    "SendReminderRequest",
    
    # Ledger
    "LedgerEntry",
    "LedgerSummary",
    "AccountStatement",
    
    # Filters
    "PaymentFilterParams",
    "PaymentSearchRequest",
    "PaymentReportRequest",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_base.py ---
# --- File: app/schemas/payment/payment_base.py ---
"""
Payment base schemas with comprehensive validation.

This module defines the core payment schemas including creation,
updates, and base validation logic for the payment lifecycle.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import PaymentMethod, PaymentStatus, PaymentType

__all__ = [
    "PaymentBase",
    "PaymentCreate",
    "PaymentUpdate",
]


class PaymentBase(BaseSchema):
    """
    Base payment schema with common fields and validation.
    
    Contains all core payment information including payer details,
    payment type, amount, method, and period information.
    """

    payer_id: UUID = Field(
        ...,
        description="Unique identifier of the user making the payment",
    )
    hostel_id: UUID = Field(
        ...,
        description="Unique identifier of the hostel receiving payment",
    )
    student_id: Optional[UUID] = Field(
        None,
        description="Student profile ID (for recurring fee payments)",
    )
    booking_id: Optional[UUID] = Field(
        None,
        description="Booking ID (for booking-related payments)",
    )

    # Payment Details
    payment_type: PaymentType = Field(
        ...,
        description="Type of payment (rent, deposit, mess, etc.)",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Payment amount (up to 10 digits with 2 decimal places)",
    )
    currency: str = Field(
        "INR",
        min_length=3,
        max_length=3,
        description="Currency code (ISO 4217)",
    )

    # Payment Period (for recurring fees)
    payment_period_start: Optional[date] = Field(
        None,
        description="Start date of the period this payment covers",
    )
    payment_period_end: Optional[date] = Field(
        None,
        description="End date of the period this payment covers",
    )

    # Payment Method Details
    payment_method: PaymentMethod = Field(
        ...,
        description="Method of payment (cash, UPI, card, etc.)",
    )
    payment_gateway: Optional[str] = Field(
        None,
        max_length=50,
        description="Payment gateway used (razorpay, stripe, paytm)",
    )

    # Due Date
    due_date: Optional[date] = Field(
        None,
        description="Payment due date (for scheduled payments)",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate payment amount is positive and reasonable."""
        if v <= 0:
            raise ValueError("Payment amount must be greater than zero")
        
        # Sanity check: Maximum payment amount
        max_amount = Decimal("1000000.00")  # 10 lakhs
        if v > max_amount:
            raise ValueError(
                f"Payment amount ({v}) exceeds maximum allowed ({max_amount})"
            )
        
        # Ensure exactly 2 decimal places
        if v.as_tuple().exponent < -2:
            raise ValueError("Payment amount can have at most 2 decimal places")
        
        return v.quantize(Decimal("0.01"))

    @field_validator("currency")
    @classmethod
    def validate_currency(cls, v: str) -> str:
        """Validate and normalize currency code."""
        v = v.upper().strip()
        
        # Validate ISO 4217 format (3 uppercase letters)
        if not v.isalpha() or len(v) != 3:
            raise ValueError("Currency must be a valid 3-letter ISO code")
        
        # Currently only support INR
        supported_currencies = ["INR"]
        if v not in supported_currencies:
            raise ValueError(
                f"Currency {v} not supported. Supported: {', '.join(supported_currencies)}"
            )
        
        return v

    @model_validator(mode="after")
    def validate_payment_period(self) -> "PaymentBase":
        """Validate payment period dates if provided."""
        if self.payment_period_start and self.payment_period_end:
            if self.payment_period_end < self.payment_period_start:
                raise ValueError(
                    f"Payment period end ({self.payment_period_end}) must be "
                    f"after or equal to start ({self.payment_period_start})"
                )
            
            # Check period is not too long (max 1 year for single payment)
            days_diff = (self.payment_period_end - self.payment_period_start).days
            if days_diff > 365:
                raise ValueError(
                    f"Payment period cannot exceed 365 days (got {days_diff} days)"
                )
        
        return self

    @model_validator(mode="after")
    def validate_entity_references(self) -> "PaymentBase":
        """Validate entity references are consistent."""
        # At least one of student_id or booking_id should be present for most payment types
        if self.payment_type not in [PaymentType.OTHER]:
            if not self.student_id and not self.booking_id:
                # Warning: Payment should be linked to a student or booking
                # In production, you might want to log this
                pass
        
        return self

    @field_validator("payment_gateway")
    @classmethod
    def validate_payment_gateway(cls, v: Optional[str]) -> Optional[str]:
        """Validate payment gateway if provided."""
        if v is not None:
            v = v.lower().strip()
            
            supported_gateways = ["razorpay", "stripe", "paytm", "phonepe", "googlepay"]
            if v not in supported_gateways:
                raise ValueError(
                    f"Payment gateway '{v}' not supported. "
                    f"Supported: {', '.join(supported_gateways)}"
                )
        
        return v

    @field_validator("due_date")
    @classmethod
    def validate_due_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate due date is reasonable."""
        if v is not None:
            # Warn if due date is too far in the past
            days_ago = (date.today() - v).days
            if days_ago > 365:
                # Log warning - might be data migration
                pass
            
            # Warn if due date is too far in the future
            days_ahead = (v - date.today()).days
            if days_ahead > 365:
                # Log warning
                pass
        
        return v

    @property
    def is_overdue(self) -> bool:
        """Check if payment is overdue."""
        if self.due_date is None:
            return False
        return date.today() > self.due_date

    @property
    def days_overdue(self) -> int:
        """Calculate days overdue (0 if not overdue)."""
        if not self.is_overdue:
            return 0
        return (date.today() - self.due_date).days


class PaymentCreate(PaymentBase, BaseCreateSchema):
    """
    Schema for creating a new payment.
    
    Includes all base fields plus creation-specific fields like
    transaction ID and collection details.
    """

    # Additional Creation Fields
    transaction_id: Optional[str] = Field(
        None,
        max_length=100,
        description="External transaction ID from payment gateway or bank",
    )
    collected_by: Optional[UUID] = Field(
        None,
        description="Staff member who collected the payment (for offline payments)",
    )

    # Additional Notes
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes about the payment",
    )

    @field_validator("transaction_id")
    @classmethod
    def validate_transaction_id(cls, v: Optional[str]) -> Optional[str]:
        """Validate and clean transaction ID."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
            
            # Ensure it doesn't exceed max length
            if len(v) > 100:
                raise ValueError("Transaction ID cannot exceed 100 characters")
        
        return v

    @model_validator(mode="after")
    def validate_offline_payment(self) -> "PaymentCreate":
        """Validate offline payment requires collection details."""
        offline_methods = [
            PaymentMethod.CASH,
            PaymentMethod.CHEQUE,
            PaymentMethod.BANK_TRANSFER,
        ]
        
        if self.payment_method in offline_methods:
            if not self.collected_by:
                raise ValueError(
                    f"collected_by is required for {self.payment_method.value} payments"
                )
        
        return self

    @field_validator("notes")
    @classmethod
    def clean_notes(cls, v: Optional[str]) -> Optional[str]:
        """Clean notes field."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class PaymentUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing payment.
    
    All fields are optional, allowing partial updates.
    Primarily used for status updates and adding receipt information.
    """

    payment_status: Optional[PaymentStatus] = Field(
        None,
        description="Update payment status",
    )
    transaction_id: Optional[str] = Field(
        None,
        max_length=100,
        description="Update transaction ID",
    )
    
    # Status Timestamps
    paid_at: Optional[datetime] = Field(
        None,
        description="Timestamp when payment was completed",
    )
    failed_at: Optional[datetime] = Field(
        None,
        description="Timestamp when payment failed",
    )
    failure_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for payment failure",
    )

    # Receipt Information
    receipt_number: Optional[str] = Field(
        None,
        max_length=50,
        description="Receipt number",
    )
    receipt_url: Optional[str] = Field(
        None,
        description="URL to download receipt",
    )

    # Additional Notes
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Update notes",
    )

    @field_validator("failure_reason")
    @classmethod
    def validate_failure_reason(cls, v: Optional[str]) -> Optional[str]:
        """Validate failure reason is meaningful."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
            
            if len(v) < 5:
                raise ValueError(
                    "Failure reason must be at least 5 characters if provided"
                )
        
        return v

    @model_validator(mode="after")
    def validate_status_consistency(self) -> "PaymentUpdate":
        """Validate status-related fields are consistent."""
        # If status is COMPLETED, paid_at should be set
        if self.payment_status == PaymentStatus.COMPLETED:
            if not self.paid_at:
                # Set to current time if not provided
                self.paid_at = datetime.utcnow()
        
        # If status is FAILED, failed_at and failure_reason should be set
        if self.payment_status == PaymentStatus.FAILED:
            if not self.failed_at:
                self.failed_at = datetime.utcnow()
            
            if not self.failure_reason:
                raise ValueError(
                    "failure_reason is required when payment_status is FAILED"
                )
        
        return self

    @field_validator("transaction_id", "receipt_number", "notes")
    @classmethod
    def clean_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Clean text fields."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_filters.py ---
# --- File: app/schemas/payment/payment_filters.py ---
"""
Payment filter and search schemas.

This module defines schemas for filtering, searching, sorting,
and exporting payment data with comprehensive analytics support.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import PaymentMethod, PaymentStatus, PaymentType

__all__ = [
    "PaymentFilterParams",
    "PaymentSearchRequest",
    "PaymentSortOptions",
    "PaymentReportRequest",
    "PaymentExportRequest",
    "PaymentAnalyticsRequest",
]


class PaymentFilterParams(BaseFilterSchema):
    """
    Comprehensive payment filter parameters.
    
    Supports filtering by various criteria including status, dates,
    amounts, payment methods, and entity relationships.
    """

    # Text Search
    search: Optional[str] = Field(
        None,
        max_length=255,
        description="Search in reference, payer name, transaction ID",
    )

    # Entity Filters
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by specific hostel",
    )
    hostel_ids: Optional[List[UUID]] = Field(
        None,
        max_length=20,
        description="Filter by multiple hostels (max 20)",
    )
    student_id: Optional[UUID] = Field(
        None,
        description="Filter by specific student",
    )
    payer_id: Optional[UUID] = Field(
        None,
        description="Filter by specific payer",
    )

    # Payment Type Filters
    payment_type: Optional[PaymentType] = Field(
        None,
        description="Filter by specific payment type",
    )
    payment_types: Optional[List[PaymentType]] = Field(
        None,
        max_length=10,
        description="Filter by multiple payment types",
    )

    # Payment Method Filters
    payment_method: Optional[PaymentMethod] = Field(
        None,
        description="Filter by specific payment method",
    )
    payment_methods: Optional[List[PaymentMethod]] = Field(
        None,
        max_length=10,
        description="Filter by multiple payment methods",
    )

    # Status Filters
    payment_status: Optional[PaymentStatus] = Field(
        None,
        description="Filter by specific status",
    )
    payment_statuses: Optional[List[PaymentStatus]] = Field(
        None,
        max_length=10,
        description="Filter by multiple statuses",
    )

    # Amount Range Filters
    amount_min: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Minimum payment amount",
    )
    amount_max: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Maximum payment amount",
    )

    # Date Filters
    paid_date_from: Optional[date] = Field(
        None,
        description="Filter payments paid from this date",
    )
    paid_date_to: Optional[date] = Field(
        None,
        description="Filter payments paid until this date",
    )
    due_date_from: Optional[date] = Field(
        None,
        description="Filter by due date from",
    )
    due_date_to: Optional[date] = Field(
        None,
        description="Filter by due date to",
    )
    created_date_from: Optional[date] = Field(
        None,
        description="Filter by creation date from",
    )
    created_date_to: Optional[date] = Field(
        None,
        description="Filter by creation date to",
    )

    # Special Filters
    overdue_only: Optional[bool] = Field(
        None,
        description="Show only overdue payments",
    )
    pending_only: Optional[bool] = Field(
        None,
        description="Show only pending payments",
    )
    refunded_only: Optional[bool] = Field(
        None,
        description="Show only refunded payments",
    )

    # Gateway Filter
    payment_gateway: Optional[str] = Field(
        None,
        max_length=50,
        description="Filter by payment gateway",
    )

    @model_validator(mode="after")
    def validate_amount_range(self) -> "PaymentFilterParams":
        """Validate amount range."""
        if self.amount_min is not None and self.amount_max is not None:
            if self.amount_max < self.amount_min:
                raise ValueError(
                    f"Maximum amount ({self.amount_max}) must be greater than "
                    f"or equal to minimum amount ({self.amount_min})"
                )
        return self

    @model_validator(mode="after")
    def validate_paid_date_range(self) -> "PaymentFilterParams":
        """Validate paid date range."""
        if self.paid_date_from is not None and self.paid_date_to is not None:
            if self.paid_date_to < self.paid_date_from:
                raise ValueError(
                    "paid_date_to must be after or equal to paid_date_from"
                )
        return self

    @model_validator(mode="after")
    def validate_due_date_range(self) -> "PaymentFilterParams":
        """Validate due date range."""
        if self.due_date_from is not None and self.due_date_to is not None:
            if self.due_date_to < self.due_date_from:
                raise ValueError(
                    "due_date_to must be after or equal to due_date_from"
                )
        return self

    @model_validator(mode="after")
    def validate_created_date_range(self) -> "PaymentFilterParams":
        """Validate created date range."""
        if self.created_date_from is not None and self.created_date_to is not None:
            if self.created_date_to < self.created_date_from:
                raise ValueError(
                    "created_date_to must be after or equal to created_date_from"
                )
        return self


class PaymentSearchRequest(BaseFilterSchema):
    """
    Payment search request with pagination.
    
    Supports full-text search across payment fields.
    """

    query: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Search query string",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Limit search to specific hostel",
    )

    # Search Fields
    search_in_reference: bool = Field(
        True,
        description="Search in payment reference",
    )
    search_in_payer_name: bool = Field(
        True,
        description="Search in payer name",
    )
    search_in_transaction_id: bool = Field(
        True,
        description="Search in transaction ID",
    )

    # Status Filter
    payment_status: Optional[PaymentStatus] = Field(
        None,
        description="Limit search to specific status",
    )

    # Pagination
    page: int = Field(
        1,
        ge=1,
        description="Page number (1-indexed)",
    )
    page_size: int = Field(
        20,
        ge=1,
        le=100,
        description="Items per page (max 100)",
    )

    @field_validator("query")
    @classmethod
    def validate_query(cls, v: str) -> str:
        """Validate and clean search query."""
        v = v.strip()
        if len(v) == 0:
            raise ValueError("Search query cannot be empty")
        return v


class PaymentSortOptions(BaseFilterSchema):
    """
    Payment sorting options.
    
    Defines how to sort payment results.
    """

    sort_by: str = Field(
        "created_at",
        pattern=r"^(created_at|paid_at|due_date|amount|payment_reference|payer_name|status)$",
        description="Field to sort by",
    )
    sort_order: str = Field(
        "desc",
        pattern=r"^(asc|desc)$",
        description="Sort order: ascending or descending",
    )

    @field_validator("sort_by", "sort_order")
    @classmethod
    def normalize_sort_fields(cls, v: str) -> str:
        """Normalize sort field values."""
        return v.lower()


class PaymentReportRequest(BaseFilterSchema):
    """
    Payment report generation request.
    
    Generates comprehensive payment reports with analytics.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Generate report for specific hostel (or all)",
    )

    # Date Range (Required)
    date_from: date = Field(
        ...,
        description="Report start date",
    )
    date_to: date = Field(
        ...,
        description="Report end date",
    )

    # Filters
    payment_types: Optional[List[PaymentType]] = Field(
        None,
        max_length=10,
        description="Include specific payment types",
    )
    payment_methods: Optional[List[PaymentMethod]] = Field(
        None,
        max_length=10,
        description="Include specific payment methods",
    )

    # Grouping
    group_by: str = Field(
        "day",
        pattern=r"^(day|week|month|payment_type|payment_method)$",
        description="How to group report data",
    )

    # Format
    format: str = Field(
        "pdf",
        pattern=r"^(pdf|excel|csv)$",
        description="Report format",
    )

    # Include Details
    include_transaction_details: bool = Field(
        True,
        description="Include detailed transaction list",
    )
    include_student_details: bool = Field(
        True,
        description="Include student information",
    )
    include_charts: bool = Field(
        True,
        description="Include charts and visualizations",
    )

    @field_validator("date_to")
    @classmethod
    def validate_date_range(cls, v: date, info) -> date:
        """Validate date range."""
        date_from = info.data.get("date_from")
        if date_from is not None:
            if v < date_from:
                raise ValueError("date_to must be after or equal to date_from")
            
            # Limit report period to reasonable range
            days_diff = (v - date_from).days
            if days_diff > 365:
                raise ValueError(
                    f"Report period cannot exceed 365 days (got {days_diff} days)"
                )
        
        return v

    @field_validator("format", "group_by")
    @classmethod
    def normalize_enum_fields(cls, v: str) -> str:
        """Normalize enum fields."""
        return v.lower()


class PaymentExportRequest(BaseFilterSchema):
    """
    Export payments data request.
    
    Supports multiple export formats with customizable fields.
    """

    filters: PaymentFilterParams = Field(
        ...,
        description="Filter criteria for export",
    )

    # Format
    format: str = Field(
        "csv",
        pattern=r"^(csv|excel|pdf)$",
        description="Export format",
    )

    # Fields to Include
    include_payer_details: bool = Field(
        True,
        description="Include payer personal details",
    )
    include_gateway_details: bool = Field(
        False,
        description="Include payment gateway response data",
    )
    include_refund_details: bool = Field(
        True,
        description="Include refund information",
    )
    include_receipt_urls: bool = Field(
        True,
        description="Include receipt download URLs",
    )

    # Export Options
    split_by_status: bool = Field(
        False,
        description="Create separate sheets/files for each status",
    )
    include_summary_sheet: bool = Field(
        True,
        description="Include summary/analytics sheet (for Excel)",
    )

    @field_validator("format")
    @classmethod
    def normalize_format(cls, v: str) -> str:
        """Normalize format."""
        return v.lower()


class PaymentAnalyticsRequest(BaseFilterSchema):
    """
    Payment analytics request.
    
    Generates analytics and insights for payments within
    a specified date range.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Generate analytics for specific hostel (or all)",
    )

    # Date Range (Required)
    date_from: date = Field(
        ...,
        description="Analytics start date",
    )
    date_to: date = Field(
        ...,
        description="Analytics end date",
    )

    # Grouping/Aggregation
    group_by: str = Field(
        "day",
        pattern=r"^(day|week|month)$",
        description="Aggregate analytics by: day, week, or month",
    )

    # Metrics to Include
    include_revenue_metrics: bool = Field(
        True,
        description="Include revenue and collection metrics",
    )
    include_method_breakdown: bool = Field(
        True,
        description="Breakdown by payment method",
    )
    include_type_breakdown: bool = Field(
        True,
        description="Breakdown by payment type",
    )
    include_trends: bool = Field(
        True,
        description="Include trend analysis",
    )
    include_comparisons: bool = Field(
        False,
        description="Compare with previous period",
    )

    @field_validator("date_to")
    @classmethod
    def validate_date_range(cls, v: date, info) -> date:
        """Validate analytics date range."""
        date_from = info.data.get("date_from")
        if date_from is not None:
            if v < date_from:
                raise ValueError("date_to must be after or equal to date_from")
            
            # Limit to reasonable range (e.g., max 2 years)
            days_diff = (v - date_from).days
            if days_diff > 730:
                raise ValueError(
                    f"Analytics period cannot exceed 730 days (got {days_diff} days)"
                )
        
        return v

    @field_validator("group_by")
    @classmethod
    def normalize_group_by(cls, v: str) -> str:
        """Normalize group_by value."""
        return v.lower()

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_gateway.py ---
# --- File: app/schemas/payment/payment_gateway.py ---
"""
Payment gateway integration schemas.

This module defines schemas for payment gateway integration including
requests, responses, webhooks, callbacks, and refund operations.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, Optional
from uuid import UUID

from pydantic import Field, HttpUrl, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "GatewayRequest",
    "GatewayResponse",
    "GatewayWebhook",
    "GatewayCallback",
    "GatewayRefundRequest",
    "GatewayRefundResponse",
    "GatewayVerification",
]


class GatewayRequest(BaseSchema):
    """
    Payment gateway request payload.
    
    Contains all information needed to initiate payment
    with a payment gateway.
    """

    payment_id: UUID = Field(
        ...,
        description="Internal payment ID",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Payment amount",
    )
    currency: str = Field(
        ...,
        min_length=3,
        max_length=3,
        description="Currency code (ISO 4217)",
    )

    # Customer Details
    customer_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Customer full name",
    )
    customer_email: str = Field(
        ...,
        description="Customer email",
    )
    customer_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Customer phone",
    )

    # Order Details
    order_id: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Unique order ID",
    )
    description: str = Field(
        ...,
        min_length=5,
        max_length=500,
        description="Payment description",
    )

    # Callback URLs
    callback_url: HttpUrl = Field(
        ...,
        description="Server callback/webhook URL",
    )
    success_url: Optional[HttpUrl] = Field(
        None,
        description="Redirect URL on success",
    )
    failure_url: Optional[HttpUrl] = Field(
        None,
        description="Redirect URL on failure",
    )

    # Additional Metadata
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional gateway-specific metadata",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate amount is positive."""
        if v <= 0:
            raise ValueError("Amount must be greater than zero")
        return v.quantize(Decimal("0.01"))

    @field_validator("currency")
    @classmethod
    def validate_currency(cls, v: str) -> str:
        """Normalize currency code."""
        return v.upper().strip()


class GatewayResponse(BaseSchema):
    """
    Payment gateway response.
    
    Contains gateway response after payment initiation.
    """

    payment_id: UUID = Field(
        ...,
        description="Internal payment ID",
    )
    gateway_order_id: str = Field(
        ...,
        description="Gateway order/transaction ID",
    )
    gateway_payment_id: Optional[str] = Field(
        None,
        description="Gateway payment ID (set after completion)",
    )

    status: str = Field(
        ...,
        pattern=r"^(created|pending|authorized|captured|failed)$",
        description="Payment status from gateway",
    )

    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Payment amount",
    )
    currency: str = Field(
        ...,
        description="Currency code",
    )

    # Gateway-Specific Data
    gateway_response: Dict[str, Any] = Field(
        ...,
        description="Complete gateway response payload",
    )

    # Timestamps
    created_at: datetime = Field(
        ...,
        description="When gateway order was created",
    )
    updated_at: datetime = Field(
        ...,
        description="Last update timestamp",
    )

    # Checkout Details (for client-side integration)
    checkout_url: Optional[HttpUrl] = Field(
        None,
        description="Gateway checkout page URL",
    )
    checkout_token: Optional[str] = Field(
        None,
        description="Checkout session token",
    )


class GatewayWebhook(BaseCreateSchema):
    """
    Payment gateway webhook payload.
    
    Represents webhook/callback received from payment gateway
    for payment status updates.
    """

    event_type: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Event type from gateway (e.g., payment.success)",
    )

    # Gateway Identifiers
    gateway_order_id: str = Field(
        ...,
        description="Gateway order ID",
    )
    gateway_payment_id: Optional[str] = Field(
        None,
        description="Gateway payment ID",
    )

    # Payment Details
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Payment amount",
    )
    currency: str = Field(
        ...,
        description="Currency code",
    )
    status: str = Field(
        ...,
        description="Payment status",
    )

    # Full Webhook Payload
    raw_payload: Dict[str, Any] = Field(
        ...,
        description="Complete webhook payload for auditing",
    )

    # Signature Verification
    signature: str = Field(
        ...,
        description="Webhook signature for verification",
    )

    # Timestamp
    event_timestamp: datetime = Field(
        ...,
        description="When event occurred (from gateway)",
    )

    @field_validator("event_type")
    @classmethod
    def normalize_event_type(cls, v: str) -> str:
        """Normalize event type."""
        return v.lower().strip()


class GatewayCallback(BaseSchema):
    """
    Payment gateway callback processing result.
    
    Represents processed callback data after verification.
    """

    payment_id: UUID = Field(
        ...,
        description="Internal payment ID",
    )
    gateway_payment_id: str = Field(
        ...,
        description="Gateway payment ID",
    )

    success: bool = Field(
        ...,
        description="Whether payment was successful",
    )
    status: str = Field(
        ...,
        description="Payment status",
    )

    amount_paid: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount actually paid",
    )

    # Error Details (if failed)
    error_code: Optional[str] = Field(
        None,
        description="Error code if payment failed",
    )
    error_message: Optional[str] = Field(
        None,
        description="Error message if payment failed",
    )

    # Additional Data
    callback_data: Dict[str, Any] = Field(
        ...,
        description="Processed callback data",
    )

    # Verification
    signature_verified: bool = Field(
        ...,
        description="Whether signature was verified",
    )


class GatewayRefundRequest(BaseCreateSchema):
    """
    Refund request to payment gateway.
    
    Initiates refund through payment gateway.
    """

    payment_id: UUID = Field(
        ...,
        description="Payment ID to refund",
    )
    gateway_payment_id: str = Field(
        ...,
        description="Gateway payment ID",
    )

    refund_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount to refund",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for refund",
    )

    # Refund Speed
    refund_speed: str = Field(
        "normal",
        pattern=r"^(normal|instant)$",
        description="Refund processing speed",
    )

    # Metadata
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional refund metadata",
    )

    @field_validator("refund_amount")
    @classmethod
    def validate_refund_amount(cls, v: Decimal) -> Decimal:
        """Validate refund amount."""
        if v <= 0:
            raise ValueError("Refund amount must be greater than zero")
        return v.quantize(Decimal("0.01"))

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate refund reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Refund reason must be at least 10 characters")
        return v


class GatewayRefundResponse(BaseSchema):
    """
    Refund response from payment gateway.
    
    Contains refund processing details from gateway.
    """

    refund_id: str = Field(
        ...,
        description="Internal refund ID",
    )
    gateway_refund_id: str = Field(
        ...,
        description="Gateway refund transaction ID",
    )

    status: str = Field(
        ...,
        description="Refund status (pending/processed/failed)",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Refund amount",
    )

    # Timeline
    estimated_completion_date: Optional[date] = Field(
        None,
        description="Estimated date when refund will be completed",
    )

    # Gateway Response
    gateway_response: Dict[str, Any] = Field(
        ...,
        description="Complete gateway refund response",
    )

    # Additional Information
    refund_mode: Optional[str] = Field(
        None,
        description="Refund mode (source/bank_transfer/etc)",
    )
    refund_arn: Optional[str] = Field(
        None,
        description="Acquirer Reference Number for refund",
    )


class GatewayVerification(BaseSchema):
    """
    Payment verification request.
    
    Used to verify payment status with gateway.
    """

    payment_id: UUID = Field(
        ...,
        description="Internal payment ID",
    )
    gateway_payment_id: str = Field(
        ...,
        description="Gateway payment ID to verify",
    )

    # Verification Result
    verified: bool = Field(
        ...,
        description="Whether payment is verified",
    )
    status: str = Field(
        ...,
        description="Verified payment status",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Verified amount",
    )

    # Gateway Response
    verification_response: Dict[str, Any] = Field(
        ...,
        description="Gateway verification response",
    )

    # Timestamp
    verified_at: datetime = Field(
        ...,
        description="Verification timestamp",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_ledger.py ---
# --- File: app/schemas/payment/payment_ledger.py ---
"""
Payment ledger and account statement schemas.

This module defines schemas for financial ledger management including
ledger entries, summaries, statements, and adjustments.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema

__all__ = [
    "LedgerEntry",
    "LedgerSummary",
    "AccountStatement",
    "TransactionHistory",
    "TransactionItem",
    "BalanceAdjustment",
    "WriteOff",
]


class LedgerEntry(BaseResponseSchema):
    """
    Individual ledger entry.
    
    Represents a single financial transaction in the student's ledger.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )

    # Entry Details
    entry_date: date = Field(
        ...,
        description="Date of entry",
    )
    entry_type: str = Field(
        ...,
        pattern=r"^(debit|credit)$",
        description="Entry type (debit increases balance, credit decreases)",
    )

    # Transaction Details
    transaction_type: str = Field(
        ...,
        description="Type of transaction (payment, charge, adjustment, etc.)",
    )
    amount: Decimal = Field(
        ...,
        decimal_places=2,
        description="Transaction amount",
    )

    # Running Balance
    balance_before: Decimal = Field(
        ...,
        decimal_places=2,
        description="Balance before this entry",
    )
    balance_after: Decimal = Field(
        ...,
        decimal_places=2,
        description="Balance after this entry",
    )

    # Reference
    payment_id: Optional[UUID] = Field(
        None,
        description="Associated payment ID",
    )
    payment_reference: Optional[str] = Field(
        None,
        description="Payment reference number",
    )

    # Description
    description: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Entry description",
    )

    # Metadata
    created_by: Optional[UUID] = Field(
        None,
        description="User who created this entry",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes",
    )

    @computed_field
    @property
    def is_debit(self) -> bool:
        """Check if entry is a debit."""
        return self.entry_type == "debit"

    @computed_field
    @property
    def is_credit(self) -> bool:
        """Check if entry is a credit."""
        return self.entry_type == "credit"


class LedgerSummary(BaseSchema):
    """
    Ledger summary for a student.
    
    Provides aggregate financial information.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    student_name: str = Field(
        ...,
        description="Student name",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )

    # Current Balance
    current_balance: Decimal = Field(
        ...,
        decimal_places=2,
        description="Current outstanding balance",
    )

    # Breakdown
    total_charges: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total charges (debits)",
    )
    total_payments: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total payments (credits)",
    )
    total_refunds: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total refunds received",
    )

    # Outstanding
    total_due: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total amount currently due",
    )
    overdue_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount that is overdue",
    )

    # Last Transaction
    last_transaction_date: Optional[date] = Field(
        None,
        description="Date of last transaction",
    )
    last_payment_date: Optional[date] = Field(
        None,
        description="Date of last payment",
    )

    @computed_field
    @property
    def net_amount(self) -> Decimal:
        """Calculate net amount (charges - payments)."""
        return (self.total_charges - self.total_payments).quantize(Decimal("0.01"))

    @computed_field
    @property
    def has_overdue_balance(self) -> bool:
        """Check if there's any overdue amount."""
        return self.overdue_amount > Decimal("0")

    @computed_field
    @property
    def account_status(self) -> str:
        """
        Determine account status.
        
        Returns: "current", "due", or "overdue"
        """
        if self.overdue_amount > 0:
            return "overdue"
        elif self.total_due > 0:
            return "due"
        else:
            return "current"


class AccountStatement(BaseSchema):
    """
    Account statement for a period.
    
    Detailed statement of all transactions for a student.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    student_name: str = Field(
        ...,
        description="Student name",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )

    # Statement Period
    statement_period_start: date = Field(
        ...,
        description="Statement period start date",
    )
    statement_period_end: date = Field(
        ...,
        description="Statement period end date",
    )
    generated_at: datetime = Field(
        ...,
        description="When statement was generated",
    )

    # Opening Balance
    opening_balance: Decimal = Field(
        ...,
        decimal_places=2,
        description="Balance at start of period",
    )

    # Transactions
    entries: List[LedgerEntry] = Field(
        default_factory=list,
        description="List of ledger entries for the period",
    )

    # Summary
    total_debits: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total debits in period",
    )
    total_credits: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total credits in period",
    )

    # Closing Balance
    closing_balance: Decimal = Field(
        ...,
        decimal_places=2,
        description="Balance at end of period",
    )

    # Download Link
    pdf_url: Optional[str] = Field(
        None,
        description="URL to download PDF statement",
    )

    @computed_field
    @property
    def net_change(self) -> Decimal:
        """Calculate net change in balance."""
        return (self.closing_balance - self.opening_balance).quantize(Decimal("0.01"))

    @computed_field
    @property
    def transaction_count(self) -> int:
        """Get total number of transactions."""
        return len(self.entries)


class TransactionItem(BaseSchema):
    """
    Individual transaction in history.
    
    Simplified transaction for history views.
    """

    transaction_id: UUID = Field(
        ...,
        description="Transaction ID",
    )
    transaction_date: datetime = Field(
        ...,
        description="Transaction timestamp",
    )
    transaction_type: str = Field(
        ...,
        description="Type of transaction",
    )

    amount: Decimal = Field(
        ...,
        decimal_places=2,
        description="Transaction amount",
    )
    balance_after: Decimal = Field(
        ...,
        decimal_places=2,
        description="Balance after transaction",
    )

    description: str = Field(
        ...,
        description="Transaction description",
    )
    payment_reference: Optional[str] = Field(
        None,
        description="Payment reference if applicable",
    )

    status: str = Field(
        ...,
        description="Transaction status",
    )


class TransactionHistory(BaseSchema):
    """
    Transaction history for a student.
    
    Paginated list of transactions with metadata.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )

    # Transactions
    transactions: List[TransactionItem] = Field(
        default_factory=list,
        description="List of transactions",
    )

    # Pagination
    total_transactions: int = Field(
        ...,
        ge=0,
        description="Total number of transactions",
    )
    page: int = Field(
        ...,
        ge=1,
        description="Current page number",
    )
    page_size: int = Field(
        ...,
        ge=1,
        description="Items per page",
    )

    @computed_field
    @property
    def total_pages(self) -> int:
        """Calculate total pages."""
        if self.page_size == 0:
            return 0
        return (self.total_transactions + self.page_size - 1) // self.page_size


class BalanceAdjustment(BaseSchema):
    """
    Manual balance adjustment (admin only).
    
    Used for corrections, waivers, or special adjustments.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )

    # Adjustment Details
    adjustment_type: str = Field(
        ...,
        pattern=r"^(debit|credit)$",
        description="Type of adjustment",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Adjustment amount",
    )

    # Justification
    reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Detailed reason for adjustment",
    )

    # Authorization
    adjusted_by: UUID = Field(
        ...,
        description="Admin who made the adjustment",
    )
    adjustment_date: date = Field(
        ...,
        description="Date of adjustment",
    )

    # Documentation
    notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional notes",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate amount is positive."""
        if v <= 0:
            raise ValueError("Adjustment amount must be greater than zero")
        return v.quantize(Decimal("0.01"))

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reason is detailed."""
        v = v.strip()
        if len(v) < 20:
            raise ValueError("Adjustment reason must be at least 20 characters")
        return v


class WriteOff(BaseSchema):
    """
    Write off outstanding amount.
    
    Used to formally write off uncollectable debts.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount to write off",
    )

    # Justification
    reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Detailed reason for write-off",
    )

    # Authorization
    approved_by: UUID = Field(
        ...,
        description="Admin who approved write-off",
    )
    approval_date: date = Field(
        ...,
        description="Date of approval",
    )

    # Documentation
    supporting_documents: List[str] = Field(
        default_factory=list,
        description="URLs to supporting documents",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate amount."""
        if v <= 0:
            raise ValueError("Write-off amount must be greater than zero")
        return v.quantize(Decimal("0.01"))

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reason is detailed."""
        v = v.strip()
        if len(v) < 20:
            raise ValueError("Write-off reason must be at least 20 characters")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_refund.py ---
# --- File: app/schemas/payment/payment_refund.py ---
"""
Payment refund schemas.

This module defines schemas for refund requests, responses,
status tracking, and approval workflows.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "RefundRequest",
    "RefundResponse",
    "RefundStatus",
    "RefundApproval",
    "RefundList",
    "RefundListItem",
]


class RefundRequest(BaseCreateSchema):
    """
    Payment refund request schema.
    
    Used to initiate refund of a completed payment.
    """

    payment_id: UUID = Field(
        ...,
        description="Payment ID to refund",
    )
    refund_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount to refund (must not exceed payment amount)",
    )

    refund_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for refund",
    )

    # Refund Type
    refund_type: str = Field(
        "full",
        pattern=r"^(full|partial)$",
        description="Whether this is a full or partial refund",
    )

    # Refund Method
    refund_method: str = Field(
        "original_source",
        pattern=r"^(original_source|bank_transfer|cash|cheque)$",
        description="How to process the refund",
    )

    # Bank Details (if refund_method is bank_transfer)
    bank_account_number: Optional[str] = Field(
        None,
        max_length=20,
        description="Bank account number for transfer",
    )
    bank_ifsc_code: Optional[str] = Field(
        None,
        pattern=r"^[A-Z]{4}0[A-Z0-9]{6}$",
        description="IFSC code for bank transfer",
    )
    account_holder_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Name of account holder",
    )

    # Additional Details
    admin_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Internal admin notes",
    )

    @field_validator("refund_amount")
    @classmethod
    def validate_refund_amount(cls, v: Decimal) -> Decimal:
        """Validate refund amount is positive."""
        if v <= 0:
            raise ValueError("Refund amount must be greater than zero")
        return v.quantize(Decimal("0.01"))

    @field_validator("refund_reason")
    @classmethod
    def validate_refund_reason(cls, v: str) -> str:
        """Validate refund reason is meaningful."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Refund reason must be at least 10 characters")
        return v

    @model_validator(mode="after")
    def validate_bank_details(self) -> "RefundRequest":
        """Validate bank details if refund method is bank transfer."""
        if self.refund_method == "bank_transfer":
            if not all([
                self.bank_account_number,
                self.bank_ifsc_code,
                self.account_holder_name,
            ]):
                raise ValueError(
                    "Bank account details (account_number, IFSC, account_holder_name) "
                    "are required for bank transfer refunds"
                )
        
        return self

    @field_validator("bank_ifsc_code")
    @classmethod
    def validate_ifsc_code(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize IFSC code."""
        if v is not None:
            v = v.upper().strip()
            # IFSC format: 4 letters, 0, then 6 alphanumeric
            if not v or len(v) != 11:
                raise ValueError("IFSC code must be 11 characters")
        return v


class RefundResponse(BaseResponseSchema):
    """
    Refund response after processing refund request.
    
    Contains refund details and processing information.
    """

    refund_id: UUID = Field(
        ...,
        description="Unique refund identifier",
    )
    payment_id: UUID = Field(
        ...,
        description="Original payment ID",
    )
    payment_reference: str = Field(
        ...,
        description="Original payment reference",
    )

    refund_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Refund amount",
    )
    refund_status: str = Field(
        ...,
        pattern=r"^(pending|processing|completed|failed)$",
        description="Current refund status",
    )

    # Processing Details
    refund_method: str = Field(
        ...,
        description="Refund method",
    )
    refund_reference: Optional[str] = Field(
        None,
        description="Refund transaction reference number",
    )

    # Timeline
    requested_at: datetime = Field(
        ...,
        description="When refund was requested",
    )
    processed_at: Optional[datetime] = Field(
        None,
        description="When refund processing started",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="When refund was completed",
    )
    estimated_completion_date: Optional[date] = Field(
        None,
        description="Estimated completion date",
    )

    # Destination
    refunded_to: str = Field(
        ...,
        description="Where refund was sent (account details/original source)",
    )

    message: str = Field(
        ...,
        description="User-friendly message about refund status",
    )


class RefundStatus(BaseSchema):
    """
    Refund status tracking schema.
    
    Provides detailed status information about a refund.
    """

    refund_id: UUID = Field(
        ...,
        description="Refund ID",
    )
    payment_reference: str = Field(
        ...,
        description="Original payment reference",
    )

    refund_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Refund amount",
    )
    currency: str = Field(
        ...,
        description="Currency code",
    )

    status: str = Field(
        ...,
        pattern=r"^(pending|processing|completed|failed|cancelled)$",
        description="Current refund status",
    )

    # Timeline
    requested_at: datetime = Field(
        ...,
        description="Request timestamp",
    )
    processing_started_at: Optional[datetime] = Field(
        None,
        description="Processing start timestamp",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="Completion timestamp",
    )

    # Progress Tracking
    days_since_request: int = Field(
        ...,
        ge=0,
        description="Number of days since refund was requested",
    )

    # Failure Details
    failure_reason: Optional[str] = Field(
        None,
        description="Reason for refund failure if applicable",
    )

    # Next Steps
    next_action: Optional[str] = Field(
        None,
        description="Next action required (if any)",
    )
    expected_completion_date: Optional[date] = Field(
        None,
        description="Expected completion date",
    )

    @computed_field
    @property
    def is_completed(self) -> bool:
        """Check if refund is completed."""
        return self.status == "completed"

    @computed_field
    @property
    def is_pending_approval(self) -> bool:
        """Check if refund is pending approval."""
        return self.status == "pending"


class RefundApproval(BaseCreateSchema):
    """
    Refund approval/rejection schema (admin only).
    
    Used by admins to approve or reject refund requests.
    """

    refund_id: UUID = Field(
        ...,
        description="Refund ID to approve/reject",
    )
    approved: bool = Field(
        ...,
        description="Whether to approve (True) or reject (False)",
    )

    # If Approved
    processing_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Processing notes (visible to staff)",
    )

    # If Rejected
    rejection_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for rejection (sent to requester)",
    )

    @model_validator(mode="after")
    def validate_approval_fields(self) -> "RefundApproval":
        """Validate approval/rejection fields."""
        if not self.approved and not self.rejection_reason:
            raise ValueError(
                "rejection_reason is required when refund is rejected"
            )
        
        return self

    @field_validator("rejection_reason")
    @classmethod
    def validate_rejection_reason(cls, v: Optional[str]) -> Optional[str]:
        """Validate rejection reason."""
        if v is not None:
            v = v.strip()
            if len(v) < 10:
                raise ValueError(
                    "Rejection reason must be at least 10 characters"
                )
        return v


class RefundListItem(BaseSchema):
    """
    Refund list item for summary views.
    
    Minimal schema for displaying refunds in lists.
    """

    refund_id: UUID = Field(..., description="Refund ID")
    payment_reference: str = Field(..., description="Payment reference")
    student_name: str = Field(..., description="Student/payer name")

    refund_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Refund amount",
    )
    status: str = Field(..., description="Refund status")

    requested_at: datetime = Field(..., description="Request timestamp")
    completed_at: Optional[datetime] = Field(None, description="Completion timestamp")

    @computed_field
    @property
    def processing_days(self) -> int:
        """Calculate days taken to process."""
        if self.completed_at:
            return (self.completed_at - self.requested_at).days
        return (datetime.utcnow() - self.requested_at).days


class RefundList(BaseSchema):
    """
    List of refunds with summary.
    
    Contains collection of refunds with aggregate information.
    """

    total_refunds: int = Field(
        ...,
        ge=0,
        description="Total number of refunds",
    )
    total_amount_refunded: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total amount refunded",
    )

    refunds: List[RefundListItem] = Field(
        default_factory=list,
        description="List of refund items",
    )

    @computed_field
    @property
    def average_refund_amount(self) -> Decimal:
        """Calculate average refund amount."""
        if self.total_refunds == 0:
            return Decimal("0.00")
        return (self.total_amount_refunded / self.total_refunds).quantize(
            Decimal("0.01")
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_reminder.py ---
# --- File: app/schemas/payment/payment_reminder.py ---
"""
Payment reminder schemas.

This module defines schemas for payment reminder configuration,
logging, manual sending, and statistics.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator, computed_field

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
)

__all__ = [
    "ReminderConfig",
    "ReminderLog",
    "SendReminderRequest",
    "ReminderBatch",
    "ReminderStats",
]


class ReminderConfig(BaseSchema):
    """
    Payment reminder configuration for a hostel.
    
    Defines when and how payment reminders should be sent.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )

    # Reminder Timing
    days_before_due: List[int] = Field(
        default_factory=lambda: [7, 3, 1],
        min_length=1,
        max_length=10,
        description="Days before due date to send reminders",
    )
    days_after_due: List[int] = Field(
        default_factory=lambda: [1, 3, 7, 15],
        min_length=1,
        max_length=10,
        description="Days after due date for overdue reminders",
    )

    # Communication Channels
    send_email: bool = Field(
        True,
        description="Send email reminders",
    )
    send_sms: bool = Field(
        True,
        description="Send SMS reminders",
    )
    send_push: bool = Field(
        True,
        description="Send push notifications",
    )

    # Escalation
    escalate_after_days: int = Field(
        15,
        ge=1,
        le=90,
        description="Escalate to admin after this many days overdue",
    )

    # Templates
    email_template_id: Optional[UUID] = Field(
        None,
        description="Custom email template ID",
    )
    sms_template_id: Optional[UUID] = Field(
        None,
        description="Custom SMS template ID",
    )

    # Status
    is_active: bool = Field(
        True,
        description="Whether reminder system is active",
    )

    @field_validator("days_before_due", "days_after_due")
    @classmethod
    def validate_days_list(cls, v: List[int]) -> List[int]:
        """Validate days lists."""
        if not v:
            raise ValueError("At least one reminder day must be configured")
        
        # Ensure all values are positive
        if any(day < 0 for day in v):
            raise ValueError("Days must be non-negative")
        
        # Remove duplicates and sort
        return sorted(set(v))

    @model_validator(mode="after")
    def validate_channels(self) -> "ReminderConfig":
        """Ensure at least one channel is enabled."""
        if not any([self.send_email, self.send_sms, self.send_push]):
            raise ValueError(
                "At least one communication channel must be enabled"
            )
        return self


class ReminderLog(BaseResponseSchema):
    """
    Payment reminder log entry.
    
    Records details of a sent reminder.
    """

    payment_id: UUID = Field(
        ...,
        description="Payment ID",
    )
    payment_reference: str = Field(
        ...,
        description="Payment reference",
    )

    # Student Information
    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    student_name: str = Field(
        ...,
        description="Student name",
    )
    student_email: str = Field(
        ...,
        description="Student email",
    )
    student_phone: str = Field(
        ...,
        description="Student phone",
    )

    # Reminder Details
    reminder_type: str = Field(
        ...,
        pattern=r"^(due_soon|overdue|final_notice)$",
        description="Type of reminder",
    )
    reminder_channel: str = Field(
        ...,
        pattern=r"^(email|sms|push)$",
        description="Communication channel used",
    )

    # Delivery Status
    sent_at: datetime = Field(
        ...,
        description="When reminder was sent",
    )
    delivery_status: str = Field(
        ...,
        pattern=r"^(sent|delivered|failed|bounced)$",
        description="Delivery status",
    )

    # Content
    subject: Optional[str] = Field(
        None,
        description="Email subject (if email)",
    )
    message_preview: str = Field(
        ...,
        max_length=200,
        description="First 200 characters of message",
    )

    # Engagement Tracking
    opened: bool = Field(
        False,
        description="Whether email was opened",
    )
    clicked: bool = Field(
        False,
        description="Whether any link was clicked",
    )

    # Error Details (if failed)
    error_message: Optional[str] = Field(
        None,
        description="Error message if delivery failed",
    )

    @computed_field
    @property
    def was_successful(self) -> bool:
        """Check if reminder was successfully delivered."""
        return self.delivery_status in ["sent", "delivered"]


class SendReminderRequest(BaseCreateSchema):
    """
    Request to send payment reminder manually.
    
    Allows manual triggering of reminders for specific payments,
    students, or entire hostel.
    """

    # Target Selection (one of these must be provided)
    payment_id: Optional[UUID] = Field(
        None,
        description="Send reminder for specific payment",
    )
    student_id: Optional[UUID] = Field(
        None,
        description="Send reminders for all due payments of student",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Send reminders for all due payments in hostel",
    )

    # Reminder Settings
    reminder_type: str = Field(
        "overdue",
        pattern=r"^(due_soon|overdue|final_notice)$",
        description="Type of reminder to send",
    )

    # Channel Selection
    channels: List[str] = Field(
        default_factory=lambda: ["email", "sms"],
        description="Channels to use for reminder",
    )

    # Custom Message
    custom_message: Optional[str] = Field(
        None,
        max_length=500,
        description="Custom message to append to reminder",
    )

    @model_validator(mode="after")
    def validate_target_selection(self) -> "SendReminderRequest":
        """Ensure exactly one target is selected."""
        targets = [self.payment_id, self.student_id, self.hostel_id]
        selected = sum(1 for t in targets if t is not None)
        
        if selected == 0:
            raise ValueError(
                "One of payment_id, student_id, or hostel_id must be provided"
            )
        
        if selected > 1:
            raise ValueError(
                "Only one of payment_id, student_id, or hostel_id can be provided"
            )
        
        return self

    @field_validator("channels")
    @classmethod
    def validate_channels(cls, v: List[str]) -> List[str]:
        """Validate channels list."""
        if not v:
            raise ValueError("At least one channel must be specified")
        
        valid_channels = ["email", "sms", "push"]
        invalid = [ch for ch in v if ch not in valid_channels]
        if invalid:
            raise ValueError(
                f"Invalid channels: {', '.join(invalid)}. "
                f"Valid: {', '.join(valid_channels)}"
            )
        
        # Remove duplicates
        return list(dict.fromkeys(v))


class ReminderBatch(BaseSchema):
    """
    Batch reminder sending result.
    
    Contains information about a bulk reminder operation.
    """

    batch_id: UUID = Field(
        ...,
        description="Unique batch identifier",
    )

    # Processing Stats
    total_payments: int = Field(
        ...,
        ge=0,
        description="Total payments processed",
    )
    reminders_sent: int = Field(
        ...,
        ge=0,
        description="Number of reminders successfully sent",
    )
    reminders_failed: int = Field(
        ...,
        ge=0,
        description="Number of failed reminders",
    )

    # Breakdown by Channel
    email_sent: int = Field(
        ...,
        ge=0,
        description="Emails sent",
    )
    sms_sent: int = Field(
        ...,
        ge=0,
        description="SMS sent",
    )
    push_sent: int = Field(
        ...,
        ge=0,
        description="Push notifications sent",
    )

    # Timing
    started_at: datetime = Field(
        ...,
        description="When batch processing started",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="When batch processing completed",
    )

    # Status
    status: str = Field(
        ...,
        pattern=r"^(processing|completed|failed)$",
        description="Batch processing status",
    )

    @computed_field
    @property
    def success_rate(self) -> float:
        """Calculate success rate as percentage."""
        total = self.reminders_sent + self.reminders_failed
        if total == 0:
            return 0.0
        return round((self.reminders_sent / total) * 100, 2)

    @computed_field
    @property
    def total_channels_used(self) -> int:
        """Count total reminder sends across all channels."""
        return self.email_sent + self.sms_sent + self.push_sent


class ReminderStats(BaseSchema):
    """
    Payment reminder statistics.
    
    Provides analytics about reminder effectiveness.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    period_start: date = Field(
        ...,
        description="Statistics period start",
    )
    period_end: date = Field(
        ...,
        description="Statistics period end",
    )

    # Volume
    total_reminders_sent: int = Field(
        ...,
        ge=0,
        description="Total reminders sent in period",
    )

    # By Type
    due_soon_reminders: int = Field(
        ...,
        ge=0,
        description="Due soon reminders",
    )
    overdue_reminders: int = Field(
        ...,
        ge=0,
        description="Overdue reminders",
    )
    final_notices: int = Field(
        ...,
        ge=0,
        description="Final notices",
    )

    # By Channel
    email_reminders: int = Field(
        ...,
        ge=0,
        description="Email reminders",
    )
    sms_reminders: int = Field(
        ...,
        ge=0,
        description="SMS reminders",
    )
    push_reminders: int = Field(
        ...,
        ge=0,
        description="Push notifications",
    )

    # Effectiveness
    payment_rate_after_reminder: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of reminded students who paid",
    )
    average_days_to_payment: Decimal = Field(
        ...,
        ge=0,
        description="Average days from reminder to payment",
    )

    @computed_field
    @property
    def most_effective_channel(self) -> str:
        """Determine most used channel."""
        channels = {
            "email": self.email_reminders,
            "sms": self.sms_reminders,
            "push": self.push_reminders,
        }
        return max(channels, key=channels.get)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_request.py ---
# --- File: app/schemas/payment/payment_request.py ---
"""
Payment request schemas for initiating payments.

This module defines schemas for various types of payment requests
including online payments, manual payments, and bulk operations.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, HttpUrl, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import PaymentMethod, PaymentType

__all__ = [
    "PaymentRequest",
    "PaymentInitiation",
    "ManualPaymentRequest",
    "BulkPaymentRequest",
    "SinglePaymentRecord",
]


class PaymentRequest(BaseCreateSchema):
    """
    Online payment request schema.
    
    Used to initiate online payments through payment gateways.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    student_id: Optional[UUID] = Field(
        None,
        description="Student ID (for recurring fee payments)",
    )
    booking_id: Optional[UUID] = Field(
        None,
        description="Booking ID (for booking-related payments)",
    )

    payment_type: PaymentType = Field(
        ...,
        description="Type of payment",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Amount to pay",
    )

    # Payment Period (for recurring fees)
    payment_period_start: Optional[date] = Field(
        None,
        description="Period start date",
    )
    payment_period_end: Optional[date] = Field(
        None,
        description="Period end date",
    )

    # Payment Gateway Selection
    payment_method: PaymentMethod = Field(
        PaymentMethod.PAYMENT_GATEWAY,
        description="Payment method (must be online for this request type)",
    )
    payment_gateway: str = Field(
        "razorpay",
        pattern=r"^(razorpay|stripe|paytm|phonepe)$",
        description="Preferred payment gateway",
    )

    # Return URLs
    success_url: Optional[HttpUrl] = Field(
        None,
        description="URL to redirect on successful payment",
    )
    failure_url: Optional[HttpUrl] = Field(
        None,
        description="URL to redirect on payment failure",
    )
    cancel_url: Optional[HttpUrl] = Field(
        None,
        description="URL to redirect if payment is cancelled",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate payment amount."""
        if v <= 0:
            raise ValueError("Payment amount must be greater than zero")
        
        # Minimum online payment amount (to avoid gateway fees being higher than payment)
        min_amount = Decimal("1.00")
        if v < min_amount:
            raise ValueError(
                f"Minimum payment amount for online payments is {min_amount}"
            )
        
        return v.quantize(Decimal("0.01"))

    @model_validator(mode="after")
    def validate_payment_method(self) -> "PaymentRequest":
        """Ensure payment method is suitable for online payment."""
        online_methods = [
            PaymentMethod.PAYMENT_GATEWAY,
            PaymentMethod.UPI,
            PaymentMethod.CARD,
            PaymentMethod.NET_BANKING,
        ]
        
        if self.payment_method not in online_methods:
            raise ValueError(
                f"Payment method {self.payment_method} not supported for online payments. "
                f"Use ManualPaymentRequest for offline payments."
            )
        
        return self

    @model_validator(mode="after")
    def validate_entity_reference(self) -> "PaymentRequest":
        """Ensure at least student_id or booking_id is provided."""
        if not self.student_id and not self.booking_id:
            raise ValueError(
                "Either student_id or booking_id must be provided"
            )
        
        return self


class PaymentInitiation(BaseSchema):
    """
    Payment initiation response from gateway.
    
    Contains all information needed to complete payment on client side.
    """

    payment_id: UUID = Field(
        ...,
        description="Internal payment ID",
    )
    payment_reference: str = Field(
        ...,
        description="Human-readable payment reference",
    )

    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Payment amount",
    )
    currency: str = Field(
        ...,
        min_length=3,
        max_length=3,
        description="Currency code",
    )

    # Gateway Details
    gateway: str = Field(
        ...,
        description="Payment gateway being used",
    )
    gateway_order_id: str = Field(
        ...,
        description="Order ID from payment gateway",
    )
    gateway_key: str = Field(
        ...,
        description="Gateway API key for client-side integration",
    )

    # Checkout Information
    checkout_url: Optional[HttpUrl] = Field(
        None,
        description="Direct checkout URL (for redirect-based flows)",
    )
    checkout_token: Optional[str] = Field(
        None,
        description="Checkout session token",
    )

    # Gateway-Specific Options
    gateway_options: dict = Field(
        ...,
        description="Gateway-specific configuration for client SDK",
    )

    # Expiry
    expires_at: Optional[datetime] = Field(
        None,
        description="When this payment initiation expires",
    )


class ManualPaymentRequest(BaseCreateSchema):
    """
    Manual payment recording schema.
    
    Used for recording offline payments (cash, cheque, bank transfer)
    collected by hostel staff.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    student_id: UUID = Field(
        ...,
        description="Student ID",
    )

    payment_type: PaymentType = Field(
        ...,
        description="Type of payment",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Payment amount",
    )

    payment_method: PaymentMethod = Field(
        ...,
        description="Payment method (cash, cheque, bank_transfer)",
    )

    # Cheque Details
    cheque_number: Optional[str] = Field(
        None,
        max_length=50,
        description="Cheque number (if payment_method is cheque)",
    )
    cheque_date: Optional[date] = Field(
        None,
        description="Cheque date",
    )
    bank_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Bank name (for cheque/bank transfer)",
    )

    # Bank Transfer Details
    transaction_reference: Optional[str] = Field(
        None,
        max_length=100,
        description="Bank transaction reference number",
    )
    transfer_date: Optional[date] = Field(
        None,
        description="Date of bank transfer",
    )

    # Payment Period
    payment_period_start: Optional[date] = Field(
        None,
        description="Period start date",
    )
    payment_period_end: Optional[date] = Field(
        None,
        description="Period end date",
    )

    # Collection Details
    collected_by: UUID = Field(
        ...,
        description="Staff member who collected the payment",
    )
    collection_date: date = Field(
        ...,
        description="Date payment was collected",
    )

    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes",
    )

    @field_validator("payment_method")
    @classmethod
    def validate_payment_method(cls, v: PaymentMethod) -> PaymentMethod:
        """Ensure payment method is suitable for manual recording."""
        manual_methods = [
            PaymentMethod.CASH,
            PaymentMethod.CHEQUE,
            PaymentMethod.BANK_TRANSFER,
        ]
        
        if v not in manual_methods:
            raise ValueError(
                f"Payment method {v} not supported for manual recording. "
                f"Supported: {', '.join(m.value for m in manual_methods)}"
            )
        
        return v

    @model_validator(mode="after")
    def validate_cheque_details(self) -> "ManualPaymentRequest":
        """Validate cheque details if payment method is cheque."""
        if self.payment_method == PaymentMethod.CHEQUE:
            if not self.cheque_number:
                raise ValueError("cheque_number is required for cheque payments")
            
            if not self.cheque_date:
                raise ValueError("cheque_date is required for cheque payments")
            
            # Validate cheque date is not in the future
            if self.cheque_date > date.today():
                raise ValueError("Cheque date cannot be in the future")
        
        return self

    @model_validator(mode="after")
    def validate_bank_transfer_details(self) -> "ManualPaymentRequest":
        """Validate bank transfer details if applicable."""
        if self.payment_method == PaymentMethod.BANK_TRANSFER:
            if not self.transaction_reference:
                raise ValueError(
                    "transaction_reference is required for bank transfers"
                )
            
            if not self.transfer_date:
                raise ValueError("transfer_date is required for bank transfers")
        
        return self

    @field_validator("collection_date")
    @classmethod
    def validate_collection_date(cls, v: date) -> date:
        """Validate collection date."""
        if v > date.today():
            raise ValueError("Collection date cannot be in the future")
        
        # Warn if collection date is too old
        days_ago = (date.today() - v).days
        if days_ago > 90:
            # Log warning
            pass
        
        return v


class SinglePaymentRecord(BaseSchema):
    """
    Single payment record in bulk operation.
    
    Minimal schema for individual payment within bulk request.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    payment_type: PaymentType = Field(
        ...,
        description="Payment type",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Payment amount",
    )
    payment_method: PaymentMethod = Field(
        ...,
        description="Payment method",
    )

    # Optional Fields
    transaction_reference: Optional[str] = Field(
        None,
        max_length=100,
        description="Transaction reference",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Payment notes",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate amount."""
        if v <= 0:
            raise ValueError("Amount must be greater than zero")
        return v.quantize(Decimal("0.01"))


class BulkPaymentRequest(BaseCreateSchema):
    """
    Record multiple payments in one operation.
    
    Used for batch recording of offline payments.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID for all payments",
    )
    payments: List[SinglePaymentRecord] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of payments to record (max 100)",
    )

    collected_by: UUID = Field(
        ...,
        description="Staff member who collected all payments",
    )
    collection_date: date = Field(
        ...,
        description="Date all payments were collected",
    )

    @field_validator("payments")
    @classmethod
    def validate_payments(cls, v: List[SinglePaymentRecord]) -> List[SinglePaymentRecord]:
        """Validate payments list."""
        if len(v) == 0:
            raise ValueError("At least one payment is required")
        
        if len(v) > 100:
            raise ValueError("Maximum 100 payments allowed per bulk operation")
        
        # Check for duplicate student IDs
        student_ids = [p.student_id for p in v]
        if len(student_ids) != len(set(student_ids)):
            raise ValueError(
                "Duplicate student IDs found. Each student can only appear once per bulk operation."
            )
        
        return v

    @field_validator("collection_date")
    @classmethod
    def validate_collection_date(cls, v: date) -> date:
        """Validate collection date."""
        if v > date.today():
            raise ValueError("Collection date cannot be in the future")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_response.py ---
# --- File: app/schemas/payment/payment_response.py ---
"""
Payment response schemas for API responses.

This module defines response schemas for payment data including
basic responses, detailed information, receipts, and summaries.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import PaymentMethod, PaymentStatus, PaymentType

__all__ = [
    "PaymentResponse",
    "PaymentDetail",
    "PaymentReceipt",
    "PaymentListItem",
    "PaymentSummary",
    "PaymentAnalytics",
]


class PaymentResponse(BaseResponseSchema):
    """
    Standard payment response schema.
    
    Contains core payment information for API responses.
    """

    payment_reference: str = Field(
        ...,
        description="Unique payment reference number",
    )
    transaction_id: Optional[str] = Field(
        None,
        description="External transaction ID",
    )

    # Payer Information
    payer_id: UUID = Field(
        ...,
        description="Payer user ID",
    )
    payer_name: str = Field(
        ...,
        description="Payer full name",
    )

    # Hostel Information
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )

    # Payment Details
    payment_type: PaymentType = Field(
        ...,
        description="Type of payment",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Payment amount",
    )
    currency: str = Field(
        ...,
        description="Currency code",
    )

    # Payment Method
    payment_method: PaymentMethod = Field(
        ...,
        description="Payment method used",
    )
    payment_status: PaymentStatus = Field(
        ...,
        description="Current payment status",
    )

    # Timestamps
    paid_at: Optional[datetime] = Field(
        None,
        description="When payment was completed",
    )
    due_date: Optional[date] = Field(
        None,
        description="Payment due date",
    )
    is_overdue: bool = Field(
        ...,
        description="Whether payment is overdue",
    )

    # Receipt
    receipt_number: Optional[str] = Field(
        None,
        description="Receipt number if generated",
    )
    receipt_url: Optional[str] = Field(
        None,
        description="URL to download receipt",
    )

    @computed_field
    @property
    def amount_display(self) -> str:
        """Get formatted amount for display."""
        return f"{self.currency} {self.amount:,.2f}"

    @computed_field
    @property
    def status_badge_color(self) -> str:
        """Get color code for status badge."""
        color_map = {
            PaymentStatus.PENDING: "#FFA500",  # Orange
            PaymentStatus.PROCESSING: "#2196F3",  # Blue
            PaymentStatus.COMPLETED: "#4CAF50",  # Green
            PaymentStatus.FAILED: "#F44336",  # Red
            PaymentStatus.REFUNDED: "#9C27B0",  # Purple
            PaymentStatus.PARTIALLY_REFUNDED: "#FF9800",  # Amber
        }
        return color_map.get(self.payment_status, "#000000")


class PaymentDetail(BaseResponseSchema):
    """
    Detailed payment information schema.
    
    Contains complete payment details including payer info,
    gateway response, refund details, and collection information.
    """

    payment_reference: str = Field(
        ...,
        description="Payment reference",
    )
    transaction_id: Optional[str] = Field(
        None,
        description="Transaction ID",
    )

    # Payer Details
    payer_id: UUID = Field(..., description="Payer ID")
    payer_name: str = Field(..., description="Payer name")
    payer_email: str = Field(..., description="Payer email")
    payer_phone: str = Field(..., description="Payer phone")

    # Hostel Details
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")

    # Related Entities
    student_id: Optional[UUID] = Field(None, description="Student ID")
    student_name: Optional[str] = Field(None, description="Student name")
    booking_id: Optional[UUID] = Field(None, description="Booking ID")
    booking_reference: Optional[str] = Field(None, description="Booking reference")

    # Payment Details
    payment_type: PaymentType = Field(..., description="Payment type")
    amount: Decimal = Field(..., ge=0, decimal_places=2, description="Amount")
    currency: str = Field(..., description="Currency")

    # Payment Period
    payment_period_start: Optional[date] = Field(None, description="Period start")
    payment_period_end: Optional[date] = Field(None, description="Period end")

    # Payment Method
    payment_method: PaymentMethod = Field(..., description="Payment method")
    payment_gateway: Optional[str] = Field(None, description="Gateway used")

    # Status
    payment_status: PaymentStatus = Field(..., description="Payment status")
    paid_at: Optional[datetime] = Field(None, description="Payment completion time")
    failed_at: Optional[datetime] = Field(None, description="Payment failure time")
    failure_reason: Optional[str] = Field(None, description="Failure reason")

    # Gateway Response
    gateway_response: Optional[Dict] = Field(
        None,
        description="Raw gateway response data",
    )

    # Receipt
    receipt_number: Optional[str] = Field(None, description="Receipt number")
    receipt_url: Optional[str] = Field(None, description="Receipt download URL")
    receipt_generated_at: Optional[datetime] = Field(None, description="Receipt generation time")

    # Refund Information
    refund_amount: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Total refunded amount",
    )
    refund_status: str = Field(
        "none",
        description="Refund status",
    )
    refunded_at: Optional[datetime] = Field(None, description="Refund completion time")
    refund_transaction_id: Optional[str] = Field(None, description="Refund transaction ID")
    refund_reason: Optional[str] = Field(None, description="Refund reason")

    # Collection Information (for offline payments)
    collected_by: Optional[UUID] = Field(None, description="Staff who collected")
    collected_by_name: Optional[str] = Field(None, description="Collector name")
    collected_at: Optional[datetime] = Field(None, description="Collection timestamp")

    # Due Date
    due_date: Optional[date] = Field(None, description="Due date")
    is_overdue: bool = Field(..., description="Overdue status")

    # Reminders
    reminder_sent_count: int = Field(
        0,
        ge=0,
        description="Number of reminders sent",
    )
    last_reminder_sent_at: Optional[datetime] = Field(
        None,
        description="Last reminder timestamp",
    )

    # Notes
    notes: Optional[str] = Field(None, description="Additional notes")

    @computed_field
    @property
    def net_amount(self) -> Decimal:
        """Calculate net amount after refunds."""
        return (self.amount - self.refund_amount).quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_fully_refunded(self) -> bool:
        """Check if payment is fully refunded."""
        return self.refund_amount >= self.amount

    @computed_field
    @property
    def is_partially_refunded(self) -> bool:
        """Check if payment is partially refunded."""
        return Decimal("0") < self.refund_amount < self.amount

    @computed_field
    @property
    def days_overdue(self) -> int:
        """Calculate days overdue."""
        if not self.is_overdue or self.due_date is None:
            return 0
        return (date.today() - self.due_date).days

    @computed_field
    @property
    def payment_period_display(self) -> Optional[str]:
        """Get formatted payment period."""
        if self.payment_period_start and self.payment_period_end:
            return (
                f"{self.payment_period_start.strftime('%b %d, %Y')} - "
                f"{self.payment_period_end.strftime('%b %d, %Y')}"
            )
        return None


class PaymentReceipt(BaseSchema):
    """
    Payment receipt schema for printing/download.
    
    Contains all information needed for a formal payment receipt.
    """

    receipt_number: str = Field(
        ...,
        description="Unique receipt number",
    )
    payment_reference: str = Field(
        ...,
        description="Payment reference",
    )

    # Payer Information
    payer_name: str = Field(..., description="Payer name")
    payer_email: str = Field(..., description="Payer email")
    payer_phone: str = Field(..., description="Payer phone")

    # Hostel Information
    hostel_name: str = Field(..., description="Hostel name")
    hostel_address: str = Field(..., description="Hostel full address")
    hostel_phone: str = Field(..., description="Hostel contact phone")
    hostel_email: Optional[str] = Field(None, description="Hostel email")
    hostel_gstin: Optional[str] = Field(None, description="Hostel GST number")

    # Payment Details
    payment_type: str = Field(..., description="Payment type")
    amount: Decimal = Field(..., ge=0, decimal_places=2, description="Payment amount")
    amount_in_words: str = Field(..., description="Amount in words")
    currency: str = Field(..., description="Currency")

    payment_method: str = Field(..., description="Payment method")
    transaction_id: Optional[str] = Field(None, description="Transaction ID")

    # Payment Period
    payment_for_period: Optional[str] = Field(
        None,
        description="Period description (e.g., 'January 2024')",
    )

    # Dates
    payment_date: datetime = Field(..., description="Payment date")
    due_date: Optional[date] = Field(None, description="Due date")

    # Receipt Metadata
    receipt_generated_at: datetime = Field(..., description="Receipt generation time")
    receipt_url: str = Field(..., description="Receipt download URL")

    # Tax/GST Details
    tax_details: Optional[Dict] = Field(
        None,
        description="Tax breakdown if applicable",
    )

    # Additional Information
    remarks: Optional[str] = Field(None, description="Additional remarks")

    @computed_field
    @property
    def receipt_display_id(self) -> str:
        """Get formatted receipt ID for display."""
        return f"RCP-{self.receipt_number}"


class PaymentListItem(BaseSchema):
    """
    Payment list item for summary views.
    
    Optimized schema for displaying multiple payments.
    """

    id: UUID = Field(..., description="Payment ID")
    payment_reference: str = Field(..., description="Payment reference")
    payer_name: str = Field(..., description="Payer name")
    hostel_name: str = Field(..., description="Hostel name")

    payment_type: str = Field(..., description="Payment type")
    amount: Decimal = Field(..., ge=0, decimal_places=2, description="Amount")

    payment_method: str = Field(..., description="Payment method")
    payment_status: PaymentStatus = Field(..., description="Status")

    paid_at: Optional[datetime] = Field(None, description="Payment time")
    due_date: Optional[date] = Field(None, description="Due date")
    is_overdue: bool = Field(..., description="Overdue status")

    created_at: datetime = Field(..., description="Creation time")

    @computed_field
    @property
    def status_display(self) -> str:
        """Get user-friendly status display."""
        status_map = {
            PaymentStatus.PENDING: "Pending",
            PaymentStatus.PROCESSING: "Processing",
            PaymentStatus.COMPLETED: "Completed",
            PaymentStatus.FAILED: "Failed",
            PaymentStatus.REFUNDED: "Refunded",
            PaymentStatus.PARTIALLY_REFUNDED: "Partially Refunded",
        }
        return status_map.get(self.payment_status, "Unknown")


class PaymentSummary(BaseSchema):
    """
    Payment summary for student or hostel.
    
    Provides aggregate payment information and statistics.
    """

    entity_id: UUID = Field(
        ...,
        description="Entity ID (student or hostel)",
    )
    entity_type: str = Field(
        ...,
        pattern=r"^(student|hostel)$",
        description="Entity type",
    )

    # Totals
    total_paid: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total amount paid",
    )
    total_pending: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total pending amount",
    )
    total_overdue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total overdue amount",
    )

    # Last Payment
    last_payment_date: Optional[date] = Field(
        None,
        description="Date of last payment",
    )
    last_payment_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Amount of last payment",
    )

    # Next Payment
    next_payment_due_date: Optional[date] = Field(
        None,
        description="Next payment due date",
    )
    next_payment_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Next payment amount",
    )

    # Counts
    total_payments: int = Field(
        ...,
        ge=0,
        description="Total number of payments",
    )
    completed_payments: int = Field(
        ...,
        ge=0,
        description="Number of completed payments",
    )
    pending_payments: int = Field(
        ...,
        ge=0,
        description="Number of pending payments",
    )

    @computed_field
    @property
    def payment_health_score(self) -> str:
        """
        Calculate payment health status.
        
        Returns: "excellent", "good", "warning", or "critical"
        """
        if self.total_overdue > 0:
            return "critical"
        elif self.total_pending > self.total_paid:
            return "warning"
        elif self.pending_payments == 0:
            return "excellent"
        else:
            return "good"

    @computed_field
    @property
    def completion_rate(self) -> float:
        """Calculate payment completion rate as percentage."""
        if self.total_payments == 0:
            return 0.0
        return round((self.completed_payments / self.total_payments) * 100, 2)


class PaymentAnalytics(BaseSchema):
    """
    Payment analytics and statistics.
    
    Provides comprehensive analytics for reporting and insights.
    """

    # Time Period
    period_start: date = Field(..., description="Analytics period start")
    period_end: date = Field(..., description="Analytics period end")

    # Volume Metrics
    total_transactions: int = Field(..., ge=0, description="Total transactions")
    total_amount: Decimal = Field(..., ge=0, decimal_places=2, description="Total amount")
    
    # Status Breakdown
    completed_transactions: int = Field(..., ge=0)
    completed_amount: Decimal = Field(..., ge=0, decimal_places=2)
    pending_transactions: int = Field(..., ge=0)
    pending_amount: Decimal = Field(..., ge=0, decimal_places=2)
    failed_transactions: int = Field(..., ge=0)
    failed_amount: Decimal = Field(..., ge=0, decimal_places=2)

    # Payment Method Breakdown
    payment_by_method: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Amount by payment method",
    )

    # Payment Type Breakdown
    payment_by_type: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Amount by payment type",
    )

    # Averages
    average_transaction_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average transaction amount",
    )

    # Success Metrics
    success_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Transaction success rate (%)",
    )

    # Collection Metrics
    collection_efficiency: float = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of dues collected on time",
    )

    @computed_field
    @property
    def total_revenue(self) -> Decimal:
        """Calculate total revenue (completed payments only)."""
        return self.completed_amount

    @computed_field
    @property
    def failure_rate(self) -> float:
        """Calculate transaction failure rate."""
        if self.total_transactions == 0:
            return 0.0
        return round((self.failed_transactions / self.total_transactions) * 100, 2)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\payment_schedule.py ---
# --- File: app/schemas/payment/payment_schedule.py ---
"""
Payment schedule schemas for recurring payments.

This module defines schemas for managing payment schedules including
creation, updates, generation, and suspension of scheduled payments.
"""

from __future__ import annotations

from datetime import date, timedelta
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator, computed_field

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import FeeType, PaymentType

__all__ = [
    "PaymentSchedule",
    "ScheduleCreate",
    "ScheduleUpdate",
    "ScheduleGeneration",
    "ScheduledPaymentGenerated",
    "BulkScheduleCreate",
    "ScheduleSuspension",
]


class PaymentSchedule(BaseResponseSchema):
    """
    Payment schedule schema.
    
    Represents a recurring payment schedule for a student.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )

    # Schedule Details
    fee_type: FeeType = Field(
        ...,
        description="Fee type (monthly, quarterly, etc.)",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount per period",
    )

    # Schedule Period
    start_date: date = Field(
        ...,
        description="Schedule start date",
    )
    end_date: Optional[date] = Field(
        None,
        description="Schedule end date (null for indefinite)",
    )
    next_due_date: date = Field(
        ...,
        description="Next payment due date",
    )

    # Settings
    auto_generate_invoice: bool = Field(
        ...,
        description="Automatically generate invoices",
    )
    is_active: bool = Field(
        ...,
        description="Whether schedule is currently active",
    )

    @computed_field
    @property
    def is_indefinite(self) -> bool:
        """Check if schedule has no end date."""
        return self.end_date is None

    @computed_field
    @property
    def days_until_next_payment(self) -> int:
        """Calculate days until next payment."""
        return (self.next_due_date - date.today()).days

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if next payment is overdue."""
        return self.next_due_date < date.today()


class ScheduleCreate(BaseCreateSchema):
    """
    Create payment schedule schema.
    
    Used to set up a new recurring payment schedule for a student.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )

    # Schedule Configuration
    fee_type: FeeType = Field(
        ...,
        description="Fee type (monthly, quarterly, half-yearly, yearly)",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount to charge per period",
    )

    # Schedule Period
    start_date: date = Field(
        ...,
        description="When schedule should start",
    )
    end_date: Optional[date] = Field(
        None,
        description="When schedule should end (null for indefinite)",
    )

    # First Payment
    first_due_date: date = Field(
        ...,
        description="Due date for first payment",
    )

    # Settings
    auto_generate_invoice: bool = Field(
        True,
        description="Automatically generate invoices on due dates",
    )
    send_reminders: bool = Field(
        True,
        description="Send payment reminders",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate amount is positive."""
        if v <= 0:
            raise ValueError("Schedule amount must be greater than zero")
        
        # Sanity check
        max_amount = Decimal("100000.00")
        if v > max_amount:
            raise ValueError(
                f"Schedule amount ({v}) exceeds maximum ({max_amount})"
            )
        
        return v.quantize(Decimal("0.01"))

    @field_validator("start_date")
    @classmethod
    def validate_start_date(cls, v: date) -> date:
        """Validate start date is reasonable."""
        # Allow past dates for backdated schedules, but warn
        days_ago = (date.today() - v).days
        if days_ago > 365:
            # Log warning - might be data migration
            pass
        
        return v

    @model_validator(mode="after")
    def validate_date_range(self) -> "ScheduleCreate":
        """Validate schedule date range."""
        if self.end_date is not None:
            if self.end_date < self.start_date:
                raise ValueError(
                    f"End date ({self.end_date}) must be after "
                    f"start date ({self.start_date})"
                )
            
            # Check if end date is reasonable
            days_diff = (self.end_date - self.start_date).days
            if days_diff > 1825:  # 5 years
                # Log warning - very long schedule
                pass
        
        return self

    @model_validator(mode="after")
    def validate_first_due_date(self) -> "ScheduleCreate":
        """Validate first due date is within schedule period."""
        if self.first_due_date < self.start_date:
            raise ValueError(
                f"First due date ({self.first_due_date}) cannot be "
                f"before start date ({self.start_date})"
            )
        
        if self.end_date is not None and self.first_due_date > self.end_date:
            raise ValueError(
                f"First due date ({self.first_due_date}) cannot be "
                f"after end date ({self.end_date})"
            )
        
        return self


class ScheduleUpdate(BaseUpdateSchema):
    """
    Update payment schedule schema.
    
    Allows modification of schedule parameters.
    """

    amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Update amount per period",
    )
    next_due_date: Optional[date] = Field(
        None,
        description="Update next due date",
    )
    end_date: Optional[date] = Field(
        None,
        description="Update end date",
    )
    auto_generate_invoice: Optional[bool] = Field(
        None,
        description="Update auto-generation setting",
    )
    is_active: Optional[bool] = Field(
        None,
        description="Activate or deactivate schedule",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Validate amount if provided."""
        if v is not None:
            if v <= 0:
                raise ValueError("Amount must be greater than zero")
            return v.quantize(Decimal("0.01"))
        return v


class ScheduleGeneration(BaseSchema):
    """
    Generate scheduled payments schema.
    
    Used to manually trigger generation of scheduled payments
    for a specific period.
    """

    schedule_id: UUID = Field(
        ...,
        description="Schedule ID",
    )

    # Generation Period
    generate_from_date: date = Field(
        ...,
        description="Start date for payment generation",
    )
    generate_to_date: date = Field(
        ...,
        description="End date for payment generation",
    )

    # Options
    skip_if_already_paid: bool = Field(
        True,
        description="Skip generation if payment already exists and is paid",
    )
    send_notifications: bool = Field(
        True,
        description="Send notifications for generated payments",
    )

    @model_validator(mode="after")
    def validate_generation_period(self) -> "ScheduleGeneration":
        """Validate generation period."""
        if self.generate_to_date < self.generate_from_date:
            raise ValueError(
                f"End date ({self.generate_to_date}) must be after "
                f"start date ({self.generate_from_date})"
            )
        
        # Limit generation period to 1 year
        days_diff = (self.generate_to_date - self.generate_from_date).days
        if days_diff > 365:
            raise ValueError(
                f"Generation period cannot exceed 365 days (got {days_diff} days)"
            )
        
        return self


class ScheduledPaymentGenerated(BaseSchema):
    """
    Result of scheduled payment generation.
    
    Contains information about payments generated from schedule.
    """

    schedule_id: UUID = Field(
        ...,
        description="Schedule ID",
    )

    # Generation Results
    payments_generated: int = Field(
        ...,
        ge=0,
        description="Number of payments generated",
    )
    payments_skipped: int = Field(
        ...,
        ge=0,
        description="Number of payments skipped",
    )

    # Generated Payment IDs
    generated_payment_ids: List[UUID] = Field(
        default_factory=list,
        description="IDs of generated payments",
    )

    # Next Generation
    next_generation_date: date = Field(
        ...,
        description="When next generation should occur",
    )

    @computed_field
    @property
    def total_processed(self) -> int:
        """Calculate total payments processed."""
        return self.payments_generated + self.payments_skipped

    @computed_field
    @property
    def generation_success_rate(self) -> float:
        """Calculate percentage of successful generations."""
        if self.total_processed == 0:
            return 0.0
        return round((self.payments_generated / self.total_processed) * 100, 2)


class BulkScheduleCreate(BaseCreateSchema):
    """
    Create schedules for multiple students.
    
    Used for batch creation of payment schedules.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID for all schedules",
    )
    student_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of student IDs (max 100)",
    )

    # Common Schedule Configuration
    fee_type: FeeType = Field(
        ...,
        description="Fee type for all schedules",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount per period for all schedules",
    )

    # Common Schedule Period
    start_date: date = Field(
        ...,
        description="Start date for all schedules",
    )
    first_due_date: date = Field(
        ...,
        description="First due date for all schedules",
    )

    @field_validator("student_ids")
    @classmethod
    def validate_student_ids(cls, v: List[UUID]) -> List[UUID]:
        """Validate student IDs list."""
        if len(v) == 0:
            raise ValueError("At least one student ID is required")
        
        if len(v) > 100:
            raise ValueError("Maximum 100 students allowed per bulk operation")
        
        # Check for duplicates
        if len(v) != len(set(v)):
            raise ValueError("Duplicate student IDs found")
        
        return v

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate amount."""
        if v <= 0:
            raise ValueError("Amount must be greater than zero")
        return v.quantize(Decimal("0.01"))

    @model_validator(mode="after")
    def validate_dates(self) -> "BulkScheduleCreate":
        """Validate date consistency."""
        if self.first_due_date < self.start_date:
            raise ValueError(
                f"First due date ({self.first_due_date}) cannot be "
                f"before start date ({self.start_date})"
            )
        return self


class ScheduleSuspension(BaseCreateSchema):
    """
    Suspend payment schedule temporarily.
    
    Used to pause schedule for a specific period (e.g., vacation).
    """

    schedule_id: UUID = Field(
        ...,
        description="Schedule ID to suspend",
    )
    suspension_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for suspension",
    )

    # Suspension Period
    suspend_from_date: date = Field(
        ...,
        description="Suspension start date",
    )
    suspend_to_date: date = Field(
        ...,
        description="Suspension end date",
    )

    # Handling Options
    skip_dues_during_suspension: bool = Field(
        True,
        description="Skip generating payment dues during suspension period",
    )

    @field_validator("suspension_reason")
    @classmethod
    def validate_suspension_reason(cls, v: str) -> str:
        """Validate suspension reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Suspension reason must be at least 10 characters")
        return v

    @model_validator(mode="after")
    def validate_suspension_period(self) -> "ScheduleSuspension":
        """Validate suspension period."""
        if self.suspend_to_date <= self.suspend_from_date:
            raise ValueError(
                f"Suspension end date ({self.suspend_to_date}) must be "
                f"after start date ({self.suspend_from_date})"
            )
        
        # Limit suspension to 1 year
        days_diff = (self.suspend_to_date - self.suspend_from_date).days
        if days_diff > 365:
            raise ValueError(
                f"Suspension period cannot exceed 365 days (got {days_diff} days)"
            )
        
        # Warn if suspension starts in the past
        if self.suspend_from_date < date.today():
            # Log warning
            pass
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\payment\__init__.py ---
# --- File: app/schemas/payment/__init__.py ---
"""
Payment schemas package.

This module exports all payment-related schemas for easy importing
across the application.
"""

from __future__ import annotations

from app.schemas.payment.payment_base import (
    PaymentBase,
    PaymentCreate,
    PaymentUpdate,
)
from app.schemas.payment.payment_filters import (
    PaymentAnalyticsRequest,
    PaymentExportRequest,
    PaymentFilterParams,
    PaymentReportRequest,
    PaymentSearchRequest,
    PaymentSortOptions,
)
from app.schemas.payment.payment_gateway import (
    GatewayCallback,
    GatewayRefundRequest,
    GatewayRefundResponse,
    GatewayRequest,
    GatewayResponse,
    GatewayVerification,
    GatewayWebhook,
)
from app.schemas.payment.payment_ledger import (
    AccountStatement,
    BalanceAdjustment,
    LedgerEntry,
    LedgerSummary,
    TransactionHistory,
    TransactionItem,
    WriteOff,
)
from app.schemas.payment.payment_refund import (
    RefundApproval,
    RefundList,
    RefundListItem,
    RefundRequest,
    RefundResponse,
    RefundStatus,
)
from app.schemas.payment.payment_reminder import (
    ReminderBatch,
    ReminderConfig,
    ReminderLog,
    ReminderStats,
    SendReminderRequest,
)
from app.schemas.payment.payment_request import (
    BulkPaymentRequest,
    ManualPaymentRequest,
    PaymentInitiation,
    PaymentRequest,
    SinglePaymentRecord,
)
from app.schemas.payment.payment_response import (
    PaymentAnalytics,
    PaymentDetail,
    PaymentListItem,
    PaymentReceipt,
    PaymentResponse,
    PaymentSummary,
)
from app.schemas.payment.payment_schedule import (
    BulkScheduleCreate,
    PaymentSchedule,
    ScheduleCreate,
    ScheduleGeneration,
    ScheduleSuspension,
    ScheduleUpdate,
    ScheduledPaymentGenerated,
)

__all__ = [
    # Base
    "PaymentBase",
    "PaymentCreate",
    "PaymentUpdate",
    # Request
    "PaymentRequest",
    "PaymentInitiation",
    "ManualPaymentRequest",
    "BulkPaymentRequest",
    "SinglePaymentRecord",
    # Response
    "PaymentResponse",
    "PaymentDetail",
    "PaymentReceipt",
    "PaymentListItem",
    "PaymentSummary",
    "PaymentAnalytics",
    # Gateway
    "GatewayRequest",
    "GatewayResponse",
    "GatewayWebhook",
    "GatewayCallback",
    "GatewayRefundRequest",
    "GatewayRefundResponse",
    "GatewayVerification",
    # Refund
    "RefundRequest",
    "RefundResponse",
    "RefundStatus",
    "RefundApproval",
    "RefundList",
    "RefundListItem",
    # Schedule
    "PaymentSchedule",
    "ScheduleCreate",
    "ScheduleUpdate",
    "ScheduleGeneration",
    "ScheduledPaymentGenerated",
    "BulkScheduleCreate",
    "ScheduleSuspension",
    # Reminder
    "ReminderConfig",
    "ReminderLog",
    "SendReminderRequest",
    "ReminderBatch",
    "ReminderStats",
    # Ledger
    "LedgerEntry",
    "LedgerSummary",
    "AccountStatement",
    "TransactionHistory",
    "TransactionItem",
    "BalanceAdjustment",
    "WriteOff",
    # Filters
    "PaymentFilterParams",
    "PaymentSearchRequest",
    "PaymentSortOptions",
    "PaymentReportRequest",
    "PaymentExportRequest",
    "PaymentAnalyticsRequest",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\referral =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\referral\all_folders_files_content.txt ---
### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\referral ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\referral =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\referral\referral_base.py ---
"""
Referral tracking schemas
"""
from datetime import datetime
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import ReferralStatus, RewardStatus


class ReferralBase(BaseSchema):
    """Base referral record"""
    program_id: UUID
    referrer_id: UUID

    referee_email: Optional[str] = None
    referee_phone: Optional[str] = None
    referee_user_id: Optional[UUID] = None

    referral_code: str = Field(..., max_length=50)
    status: ReferralStatus = Field(ReferralStatus.PENDING)


class ReferralCreate(ReferralBase, BaseCreateSchema):
    """Create referral (generate code or track share)"""
    pass

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\referral\referral_code.py ---
"""
Referral code generation/validation schemas
"""
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema


class ReferralCodeGenerate(BaseCreateSchema):
    """Generate referral code for user"""
    user_id: UUID
    program_id: UUID

    # Optional custom prefix
    prefix: str = Field("HOSTEL", max_length=10)


class ReferralCodeResponse(BaseSchema):
    """Referral code response"""
    user_id: UUID
    program_id: UUID
    referral_code: str


class CodeValidationRequest(BaseCreateSchema):
    """Validate referral code"""
    referral_code: str = Field(..., max_length=50)


class CodeValidationResponse(BaseSchema):
    """Validation result"""
    referral_code: str
    is_valid: bool
    program_id: Optional[UUID]
    referrer_id: Optional[UUID]
    message: str

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\referral\referral_program_base.py ---
"""
Referral program definition schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import Optional, List
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseUpdateSchema, BaseResponseSchema
from app.schemas.common.enums import PaymentType


class ReferralProgramBase(BaseSchema):
    """Base referral program schema"""
    program_name: str = Field(..., min_length=3, max_length=100)
    program_type: str = Field(
        ...,
        pattern="^(student_referral|visitor_referral|affiliate)$",
    )

    reward_type: str = Field(
        ...,
        pattern="^(cash|discount|voucher|free_month)$",
    )
    referrer_reward_amount: Optional[Decimal] = Field(None, ge=0)
    referee_reward_amount: Optional[Decimal] = Field(None, ge=0)
    currency: str = Field("INR", min_length=3, max_length=3)

    min_booking_amount: Optional[Decimal] = Field(None, ge=0)
    min_stay_months: Optional[int] = Field(None, ge=1)

    terms_and_conditions: Optional[str] = Field(None, max_length=5000)

    is_active: bool = Field(True)
    valid_from: Optional[date] = None
    valid_to: Optional[date] = None


class ProgramCreate(ReferralProgramBase, BaseCreateSchema):
    """Create referral program"""
    pass


class ProgramUpdate(BaseUpdateSchema):
    """Update referral program"""
    program_name: Optional[str] = None
    reward_type: Optional[str] = None
    referrer_reward_amount: Optional[Decimal] = Field(None, ge=0)
    referee_reward_amount: Optional[Decimal] = Field(None, ge=0)
    min_booking_amount: Optional[Decimal] = Field(None, ge=0)
    min_stay_months: Optional[int] = Field(None, ge=1)
    terms_and_conditions: Optional[str] = None
    is_active: Optional[bool] = None
    valid_from: Optional[date] = None
    valid_to: Optional[date] = None

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\referral\referral_program_response.py ---
"""
Referral program response schemas
"""
from datetime import date
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema


class ProgramResponse(BaseResponseSchema):
    """Referral program response"""
    program_name: str
    program_type: str
    reward_type: str
    referrer_reward_amount: Optional[Decimal]
    referee_reward_amount: Optional[Decimal]
    currency: str

    min_booking_amount: Optional[Decimal]
    min_stay_months: Optional[int]

    is_active: bool
    valid_from: Optional[date]
    valid_to: Optional[date]

    terms_and_conditions: Optional[str]


class ProgramList(BaseSchema):
    """List of active programs"""
    programs: List[ProgramResponse]

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\referral\referral_response.py ---
"""
Referral record response schemas
"""
from datetime import datetime
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import ReferralStatus, RewardStatus


class ReferralResponse(BaseResponseSchema):
    """Referral record response"""
    program_id: UUID
    program_name: str

    referrer_id: UUID
    referrer_name: str

    referee_email: Optional[str]
    referee_phone: Optional[str]
    referee_user_id: Optional[UUID]

    referral_code: str
    status: ReferralStatus

    booking_id: Optional[UUID]
    completed_at: Optional[datetime]

    referrer_reward_amount: Optional[Decimal]
    referee_reward_amount: Optional[Decimal]
    currency: str

    referrer_reward_status: RewardStatus
    referee_reward_status: RewardStatus


class ReferralStats(BaseSchema):
    """Referral statistics for a user"""
    user_id: UUID

    total_referrals: int
    successful_referrals: int
    pending_referrals: int

    total_earned: Decimal
    total_paid_out: Decimal
    total_pending_rewards: Decimal

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\referral\referral_rewards.py ---
"""
Referral reward tracking schemas
"""
from datetime import datetime
from decimal import Decimal
from typing import Optional, List
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import RewardStatus, PaymentMethod


class RewardConfig(BaseSchema):
    """Global referral reward config (for payouts)"""
    min_payout_amount: Decimal = Field(
        Decimal("100.00"), ge=0, description="Minimum amount before payout"
    )
    payout_methods: List[PaymentMethod] = Field(
        default_factory=lambda: [PaymentMethod.BANK_TRANSFER, PaymentMethod.UPI]
    )


class RewardTracking(BaseSchema):
    """Track rewards for user"""
    user_id: UUID

    total_rewards_earned: Decimal
    total_rewards_paid: Decimal
    pending_rewards: Decimal

    # Breakdown
    rewards_by_program: dict[str, Decimal]


class PayoutRequest(BaseCreateSchema):
    """Request payout of referral rewards"""
    user_id: UUID
    amount: Decimal = Field(..., ge=0)

    payout_method: PaymentMethod
    payout_details: dict = Field(
        ..., description="Method-specific details (UPI ID, bank account, etc.)"
    )


class PayoutRequestResponse(BaseSchema):
    """Payout request status"""
    payout_request_id: UUID
    user_id: UUID
    amount: Decimal
    payout_method: PaymentMethod

    status: RewardStatus
    requested_at: datetime
    processed_at: Optional[datetime]
    failure_reason: Optional[str] = None

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\referral\__init__.py ---



# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\referral\referral_base.py ---
# --- File: app/schemas/referral/referral_base.py ---
"""
Referral tracking schemas.

This module provides schemas for tracking individual referrals,
their status, and associated rewards.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import ReferralStatus, RewardStatus

__all__ = [
    "ReferralBase",
    "ReferralCreate",
    "ReferralUpdate",
    "ReferralConversion",
]


class ReferralBase(BaseSchema):
    """
    Base referral record schema.

    Tracks a single referral from one user to another with status
    and reward information.
    """

    # Program and referrer
    program_id: UUID = Field(
        ...,
        description="Referral program ID",
    )
    referrer_id: UUID = Field(
        ...,
        description="User ID of the person making the referral",
    )

    # Referee information (at least one required)
    referee_email: Optional[EmailStr] = Field(
        None,
        description="Email address of referred person",
    )
    referee_phone: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number of referred person",
    )
    referee_user_id: Optional[UUID] = Field(
        None,
        description="User ID of referred person (after registration)",
    )
    referee_name: Optional[str] = Field(
        None,
        min_length=2,
        max_length=100,
        description="Name of referred person",
    )

    # Referral code
    referral_code: str = Field(
        ...,
        min_length=5,
        max_length=50,
        pattern="^[A-Z0-9-]+$",
        description="Unique referral code used",
    )

    # Status tracking
    status: ReferralStatus = Field(
        default=ReferralStatus.PENDING,
        description="Current referral status",
    )

    # Conversion tracking
    booking_id: Optional[UUID] = Field(
        None,
        description="Booking ID if referral converted",
    )
    conversion_date: Optional[datetime] = Field(
        None,
        description="When referral converted to booking",
    )

    # Reward tracking
    referrer_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Reward amount for referrer",
    )
    referee_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Reward amount for referee",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        description="Currency code",
    )

    # Reward status
    referrer_reward_status: RewardStatus = Field(
        default=RewardStatus.PENDING,
        description="Status of referrer's reward",
    )
    referee_reward_status: RewardStatus = Field(
        default=RewardStatus.PENDING,
        description="Status of referee's reward",
    )

    # Source tracking
    referral_source: Optional[str] = Field(
        None,
        max_length=100,
        description="Source of referral (e.g., 'whatsapp', 'email', 'social')",
    )
    campaign_id: Optional[UUID] = Field(
        None,
        description="Marketing campaign ID if applicable",
    )

    # Metadata
    notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional notes or context",
    )

    @field_validator("referral_code")
    @classmethod
    def validate_referral_code(cls, v: str) -> str:
        """Validate and normalize referral code."""
        v = v.upper().strip()
        if not v:
            raise ValueError("Referral code cannot be empty")
        return v

    @field_validator("referee_phone")
    @classmethod
    def normalize_phone_number(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone number format."""
        if v is None:
            return None
        
        # Remove spaces, hyphens, parentheses
        normalized = v.replace(" ", "").replace("-", "").replace("(", "").replace(")", "")
        
        # Add + prefix if missing
        if not normalized.startswith("+"):
            if len(normalized) == 10:
                normalized = f"+91{normalized}"  # Assume India
            else:
                normalized = f"+{normalized}"
        
        return normalized

    @model_validator(mode="after")
    def validate_referee_info(self) -> "ReferralBase":
        """Ensure at least one referee identifier is provided."""
        if not any([self.referee_email, self.referee_phone, self.referee_user_id]):
            raise ValueError(
                "At least one referee identifier (email, phone, or user_id) is required"
            )
        return self

    @model_validator(mode="after")
    def validate_conversion_data(self) -> "ReferralBase":
        """Validate conversion-related data consistency."""
        # If status is COMPLETED, booking_id and conversion_date should be set
        if self.status == ReferralStatus.COMPLETED:
            if not self.booking_id:
                raise ValueError(
                    "booking_id required when status is COMPLETED"
                )
            if not self.conversion_date:
                raise ValueError(
                    "conversion_date required when status is COMPLETED"
                )
        
        # If booking_id is set, conversion_date should also be set
        if self.booking_id and not self.conversion_date:
            raise ValueError(
                "conversion_date required when booking_id is provided"
            )
        
        return self


class ReferralCreate(ReferralBase, BaseCreateSchema):
    """
    Schema for creating a new referral record.

    Generated when a user shares a referral code or when a referred
    person uses the code.
    """

    # Override to make some fields optional for creation
    referral_code: Optional[str] = Field(
        None,
        description="Referral code (auto-generated if not provided)",
    )
    
    @field_validator("referral_code")
    @classmethod
    def generate_referral_code(cls, v: Optional[str], info) -> str:
        """Generate referral code if not provided."""
        if v is None:
            # Generate unique code
            import secrets
            import string
            
            # Get referrer_id for personalization
            referrer_id = info.data.get("referrer_id")
            if referrer_id:
                # Use last 6 chars of UUID + random string
                user_suffix = str(referrer_id).replace("-", "")[-6:].upper()
            else:
                user_suffix = ""
            
            # Generate random alphanumeric string
            random_part = ''.join(
                secrets.choice(string.ascii_uppercase + string.digits)
                for _ in range(6)
            )
            
            return f"REF-{user_suffix}{random_part}"
        
        return v.upper()


class ReferralUpdate(BaseSchema):
    """
    Schema for updating a referral record.

    Allows updating status, conversion information, and reward status.
    """

    # Referee information updates
    referee_user_id: Optional[UUID] = Field(
        None,
        description="Update referee user ID after registration",
    )
    referee_name: Optional[str] = Field(
        None,
        min_length=2,
        max_length=100,
        description="Update referee name",
    )

    # Status updates
    status: Optional[ReferralStatus] = Field(
        None,
        description="Update referral status",
    )

    # Conversion updates
    booking_id: Optional[UUID] = Field(
        None,
        description="Link booking to referral",
    )
    conversion_date: Optional[datetime] = Field(
        None,
        description="Set conversion date",
    )

    # Reward updates
    referrer_reward_status: Optional[RewardStatus] = Field(
        None,
        description="Update referrer reward status",
    )
    referee_reward_status: Optional[RewardStatus] = Field(
        None,
        description="Update referee reward status",
    )

    # Notes
    notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Add or update notes",
    )


class ReferralConversion(BaseCreateSchema):
    """
    Schema for converting a referral to a booking.

    Used when a referred person completes a booking.
    """

    referral_id: UUID = Field(
        ...,
        description="Referral record ID",
    )
    booking_id: UUID = Field(
        ...,
        description="Booking ID",
    )
    booking_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Booking amount",
    )
    stay_duration_months: int = Field(
        ...,
        ge=1,
        le=24,
        description="Stay duration in months",
    )
    conversion_date: Optional[datetime] = Field(
        default_factory=datetime.utcnow,
        description="Conversion timestamp",
    )

    @model_validator(mode="after")
    def validate_conversion_date(self) -> "ReferralConversion":
        """Ensure conversion date is not in future."""
        if self.conversion_date > datetime.utcnow():
            raise ValueError("Conversion date cannot be in the future")
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\referral\referral_code.py ---
# --- File: app/schemas/referral/referral_code.py ---
"""
Referral code generation and validation schemas.

This module provides schemas for generating unique referral codes
and validating their usage.
"""

from __future__ import annotations

from datetime import datetime
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "ReferralCodeGenerate",
    "ReferralCodeResponse",
    "CodeValidationRequest",
    "CodeValidationResponse",
    "ReferralCodeStats",
]


class ReferralCodeGenerate(BaseCreateSchema):
    """
    Schema for generating a referral code for a user.

    Creates a unique, personalized referral code for sharing.
    """

    user_id: UUID = Field(
        ...,
        description="User ID to generate code for",
    )
    program_id: UUID = Field(
        ...,
        description="Referral program ID",
    )

    # Optional customization
    prefix: str = Field(
        default="HOSTEL",
        min_length=3,
        max_length=10,
        pattern="^[A-Z]+$",
        description="Code prefix (uppercase letters only)",
    )
    custom_suffix: Optional[str] = Field(
        None,
        min_length=3,
        max_length=10,
        pattern="^[A-Z0-9]+$",
        description="Optional custom suffix",
    )

    # Validity
    expires_at: Optional[datetime] = Field(
        None,
        description="Code expiration date (optional)",
    )
    max_uses: int = Field(
        default=100,
        ge=1,
        le=1000,
        description="Maximum number of times code can be used",
    )

    @field_validator("prefix")
    @classmethod
    def validate_prefix(cls, v: str) -> str:
        """Validate and normalize prefix."""
        v = v.upper().strip()
        if not v.isalpha():
            raise ValueError("Prefix must contain only letters")
        return v

    @field_validator("expires_at")
    @classmethod
    def validate_expiration(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate expiration date is in future."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Expiration date must be in the future")
        return v


class ReferralCodeResponse(BaseSchema):
    """
    Response schema for generated referral code.

    Returns the code and associated metadata.
    """

    user_id: UUID = Field(..., description="User ID")
    program_id: UUID = Field(..., description="Program ID")
    referral_code: str = Field(..., description="Generated referral code")
    
    # Code details
    share_url: str = Field(
        ...,
        description="Shareable URL with embedded code",
    )
    qr_code_url: Optional[str] = Field(
        None,
        description="QR code image URL",
    )
    
    # Usage tracking
    times_used: int = Field(
        default=0,
        ge=0,
        description="Number of times code has been used",
    )
    max_uses: int = Field(
        ...,
        ge=1,
        description="Maximum allowed uses",
    )
    remaining_uses: int = Field(
        ...,
        ge=0,
        description="Remaining uses available",
    )
    
    # Validity
    is_active: bool = Field(..., description="Whether code is currently active")
    created_at: datetime = Field(..., description="Code creation time")
    expires_at: Optional[datetime] = Field(None, description="Expiration time")


class CodeValidationRequest(BaseCreateSchema):
    """
    Request schema for validating a referral code.

    Used when a user attempts to use a referral code.
    """

    referral_code: str = Field(
        ...,
        min_length=5,
        max_length=50,
        description="Referral code to validate",
    )
    user_id: Optional[UUID] = Field(
        None,
        description="User ID attempting to use the code",
    )
    context: Optional[str] = Field(
        None,
        max_length=100,
        description="Context where code is being used (e.g., 'booking', 'registration')",
    )

    @field_validator("referral_code")
    @classmethod
    def normalize_code(cls, v: str) -> str:
        """Normalize referral code."""
        return v.upper().strip()


class CodeValidationResponse(BaseSchema):
    """
    Response schema for code validation.

    Indicates whether code is valid and provides relevant details.
    """

    referral_code: str = Field(..., description="Validated code")
    is_valid: bool = Field(..., description="Whether code is valid")
    
    # Program details (if valid)
    program_id: Optional[UUID] = Field(
        None,
        description="Associated program ID",
    )
    program_name: Optional[str] = Field(
        None,
        description="Program name",
    )
    
    # Referrer details (if valid)
    referrer_id: Optional[UUID] = Field(
        None,
        description="Referrer user ID",
    )
    referrer_name: Optional[str] = Field(
        None,
        description="Referrer name",
    )
    
    # Reward information (if valid)
    referee_reward_amount: Optional[str] = Field(
        None,
        description="Reward amount for new user",
    )
    reward_type: Optional[str] = Field(
        None,
        description="Type of reward",
    )
    
    # Validation result
    message: str = Field(
        ...,
        description="Validation message or error reason",
    )
    validation_errors: list[str] = Field(
        default_factory=list,
        description="List of validation errors if invalid",
    )
    
    # Usage information
    times_used: int = Field(default=0, ge=0, description="Times code has been used")
    max_uses: int = Field(default=0, ge=0, description="Maximum allowed uses")
    expires_at: Optional[datetime] = Field(None, description="Expiration date")


class ReferralCodeStats(BaseSchema):
    """
    Statistics for a referral code.

    Provides detailed analytics for code performance.
    """

    referral_code: str = Field(..., description="Referral code")
    user_id: UUID = Field(..., description="Code owner")
    program_id: UUID = Field(..., description="Program ID")
    
    # Usage statistics
    total_shares: int = Field(
        default=0,
        ge=0,
        description="Total times code was shared",
    )
    total_clicks: int = Field(
        default=0,
        ge=0,
        description="Total clicks on referral link",
    )
    total_uses: int = Field(
        default=0,
        ge=0,
        description="Total successful uses",
    )
    
    # Conversion statistics
    total_registrations: int = Field(
        default=0,
        ge=0,
        description="Registrations from this code",
    )
    total_bookings: int = Field(
        default=0,
        ge=0,
        description="Bookings from this code",
    )
    conversion_rate: float = Field(
        default=0.0,
        ge=0,
        le=100,
        description="Click-to-booking conversion rate",
    )
    
    # Rewards earned
    total_rewards_earned: str = Field(
        default="0.00",
        description="Total rewards earned from this code",
    )
    pending_rewards: str = Field(
        default="0.00",
        description="Pending reward amount",
    )
    
    # Time period
    created_at: datetime = Field(..., description="Code creation date")
    last_used_at: Optional[datetime] = Field(None, description="Last usage date")

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\referral\referral_program_base.py ---
# --- File: app/schemas/referral/referral_program_base.py ---
"""
Referral program definition schemas.

This module provides schemas for creating and managing referral programs
with reward structures, eligibility criteria, and validity periods.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
    BaseUpdateSchema,
)

__all__ = [
    "ReferralProgramBase",
    "ProgramCreate",
    "ProgramUpdate",
    "ProgramResponse",
    "ProgramList",
    "ProgramType",
    "RewardType",
]


class ProgramType(str):
    """Referral program types."""

    STUDENT_REFERRAL = "student_referral"
    VISITOR_REFERRAL = "visitor_referral"
    AFFILIATE = "affiliate"
    CORPORATE = "corporate"


class RewardType(str):
    """Reward types for referral programs."""

    CASH = "cash"
    DISCOUNT = "discount"
    VOUCHER = "voucher"
    FREE_MONTH = "free_month"
    POINTS = "points"


class ReferralProgramBase(BaseSchema):
    """
    Base referral program schema.

    Defines the structure and rules for a referral program including
    reward types, eligibility criteria, and validity periods.
    """

    # Program identification
    program_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Unique program name",
    )
    program_code: Optional[str] = Field(
        None,
        min_length=3,
        max_length=50,
        pattern="^[A-Z0-9_]+$",
        description="Unique program code (auto-generated if not provided)",
    )
    program_type: str = Field(
        ...,
        pattern="^(student_referral|visitor_referral|affiliate|corporate)$",
        description="Type of referral program",
    )

    # Program description
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Program description and benefits",
    )

    # Reward configuration
    reward_type: str = Field(
        ...,
        pattern="^(cash|discount|voucher|free_month|points)$",
        description="Type of reward offered",
    )
    referrer_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Reward amount for the referrer",
    )
    referee_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Reward amount for the referee (new user)",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern="^[A-Z]{3}$",
        description="Currency code (ISO 4217)",
    )

    # Reward caps
    max_referrer_rewards_per_month: Optional[int] = Field(
        None,
        ge=1,
        le=100,
        description="Maximum rewards referrer can earn per month",
    )
    max_total_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Maximum total reward amount per referrer",
    )

    # Eligibility criteria
    min_booking_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Minimum booking amount to qualify for reward",
    )
    min_stay_months: Optional[int] = Field(
        None,
        ge=1,
        le=24,
        description="Minimum stay duration in months to qualify",
    )
    min_referrer_stay_months: Optional[int] = Field(
        None,
        ge=0,
        le=12,
        description="Minimum months referrer must have stayed",
    )

    # Referral limitations
    max_referrals_per_user: Optional[int] = Field(
        None,
        ge=1,
        le=1000,
        description="Maximum referrals allowed per user",
    )
    allowed_user_roles: List[str] = Field(
        default_factory=lambda: ["student", "alumni"],
        description="User roles eligible to participate",
    )

    # Validity period
    is_active: bool = Field(
        default=True,
        description="Whether program is currently active",
    )
    valid_from: Optional[date] = Field(
        None,
        description="Program start date",
    )
    valid_to: Optional[date] = Field(
        None,
        description="Program end date",
    )

    # Terms and conditions
    terms_and_conditions: Optional[str] = Field(
        None,
        max_length=5000,
        description="Detailed terms and conditions",
    )
    auto_approve_rewards: bool = Field(
        default=False,
        description="Automatically approve rewards without manual review",
    )

    # Tracking
    track_conversion: bool = Field(
        default=True,
        description="Track conversion metrics",
    )

    @field_validator("program_name")
    @classmethod
    def validate_program_name(cls, v: str) -> str:
        """Validate program name is unique and well-formed."""
        # Remove extra spaces
        v = " ".join(v.split())
        if len(v) < 3:
            raise ValueError("Program name must be at least 3 characters")
        return v

    @field_validator("currency")
    @classmethod
    def validate_currency(cls, v: str) -> str:
        """Validate currency code."""
        v = v.upper()
        # Common currency codes
        valid_currencies = {
            "INR", "USD", "EUR", "GBP", "AED", "SGD", "MYR", "AUD", "CAD"
        }
        if v not in valid_currencies:
            raise ValueError(
                f"Invalid currency code. Supported: {', '.join(valid_currencies)}"
            )
        return v

    @field_validator("allowed_user_roles")
    @classmethod
    def validate_allowed_roles(cls, v: List[str]) -> List[str]:
        """Validate user roles."""
        valid_roles = {"student", "alumni", "visitor", "supervisor", "admin"}
        for role in v:
            if role not in valid_roles:
                raise ValueError(f"Invalid user role: {role}")
        return list(set(v))  # Remove duplicates

    @model_validator(mode="after")
    def validate_reward_amounts(self) -> "ReferralProgramBase":
        """Validate reward amounts are provided for reward types that need them."""
        if self.reward_type in ["cash", "discount", "voucher"]:
            if self.referrer_reward_amount is None and self.referee_reward_amount is None:
                raise ValueError(
                    f"At least one reward amount required for reward_type '{self.reward_type}'"
                )
            
            # Ensure amounts are reasonable
            if self.referrer_reward_amount and self.referrer_reward_amount > 100000:
                raise ValueError("Referrer reward amount seems unreasonably high")
            
            if self.referee_reward_amount and self.referee_reward_amount > 100000:
                raise ValueError("Referee reward amount seems unreasonably high")
        
        return self

    @model_validator(mode="after")
    def validate_validity_period(self) -> "ReferralProgramBase":
        """Validate validity period dates."""
        if self.valid_from and self.valid_to:
            if self.valid_to <= self.valid_from:
                raise ValueError("valid_to must be after valid_from")
            
            # Check if period is too long (e.g., more than 2 years)
            days_difference = (self.valid_to - self.valid_from).days
            if days_difference > 730:  # 2 years
                raise ValueError("Program validity period cannot exceed 2 years")
        
        return self

    @model_validator(mode="after")
    def validate_eligibility_criteria(self) -> "ReferralProgramBase":
        """Validate eligibility criteria are logical."""
        if self.min_stay_months and self.min_booking_amount:
            # If stay duration is required, booking amount should be reasonable
            monthly_rate = self.min_booking_amount / self.min_stay_months
            if monthly_rate < 1000:  # Minimum monthly rate threshold
                raise ValueError(
                    "Minimum booking amount seems too low for required stay duration"
                )
        
        return self


class ProgramCreate(ReferralProgramBase, BaseCreateSchema):
    """
    Schema for creating a new referral program.

    Inherits all fields from ReferralProgramBase with creation-specific validation.
    """

    @field_validator("program_code")
    @classmethod
    def generate_program_code(cls, v: Optional[str], info) -> str:
        """Generate program code if not provided."""
        if v is None:
            # Generate from program name
            program_name = info.data.get("program_name", "")
            code = program_name.upper().replace(" ", "_")[:20]
            
            # Add timestamp suffix for uniqueness
            import time
            timestamp = str(int(time.time()))[-6:]
            return f"{code}_{timestamp}"
        
        return v.upper()


class ProgramUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing referral program.

    Allows partial updates with proper validation.
    """

    program_name: Optional[str] = Field(
        None,
        min_length=3,
        max_length=100,
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
    )
    reward_type: Optional[str] = Field(
        None,
        pattern="^(cash|discount|voucher|free_month|points)$",
    )
    referrer_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
    )
    referee_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
    )
    min_booking_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
    )
    min_stay_months: Optional[int] = Field(
        None,
        ge=1,
        le=24,
    )
    min_referrer_stay_months: Optional[int] = Field(
        None,
        ge=0,
        le=12,
    )
    max_referrals_per_user: Optional[int] = Field(
        None,
        ge=1,
        le=1000,
    )
    max_referrer_rewards_per_month: Optional[int] = Field(
        None,
        ge=1,
        le=100,
    )
    max_total_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
    )
    allowed_user_roles: Optional[List[str]] = None
    terms_and_conditions: Optional[str] = Field(
        None,
        max_length=5000,
    )
    is_active: Optional[bool] = None
    valid_from: Optional[date] = None
    valid_to: Optional[date] = None
    auto_approve_rewards: Optional[bool] = None
    track_conversion: Optional[bool] = None

    @model_validator(mode="after")
    def validate_at_least_one_field(self) -> "ProgramUpdate":
        """Ensure at least one field is being updated."""
        if not any([
            self.program_name,
            self.description,
            self.reward_type,
            self.referrer_reward_amount is not None,
            self.referee_reward_amount is not None,
            self.min_booking_amount is not None,
            self.min_stay_months,
            self.max_referrals_per_user,
            self.terms_and_conditions,
            self.is_active is not None,
            self.valid_from,
            self.valid_to,
        ]):
            raise ValueError("At least one field must be provided for update")
        return self


class ProgramResponse(BaseResponseSchema):
    """
    Referral program response schema.

    Includes program details and statistics.
    """

    program_name: str = Field(..., description="Program name")
    program_code: str = Field(..., description="Program code")
    program_type: str = Field(..., description="Program type")
    description: Optional[str] = Field(None, description="Program description")

    # Reward details
    reward_type: str = Field(..., description="Reward type")
    referrer_reward_amount: Optional[Decimal] = Field(None, description="Referrer reward")
    referee_reward_amount: Optional[Decimal] = Field(None, description="Referee reward")
    currency: str = Field(..., description="Currency code")

    # Eligibility criteria
    min_booking_amount: Optional[Decimal] = Field(None, description="Minimum booking amount")
    min_stay_months: Optional[int] = Field(None, description="Minimum stay duration")
    min_referrer_stay_months: Optional[int] = Field(None, description="Minimum referrer stay")
    max_referrals_per_user: Optional[int] = Field(None, description="Max referrals per user")
    max_referrer_rewards_per_month: Optional[int] = Field(None, description="Max rewards per month")

    # Status
    is_active: bool = Field(..., description="Active status")
    valid_from: Optional[date] = Field(None, description="Start date")
    valid_to: Optional[date] = Field(None, description="End date")

    # Terms
    terms_and_conditions: Optional[str] = Field(None, description="T&C")
    auto_approve_rewards: bool = Field(..., description="Auto-approve rewards")

    # Statistics (computed fields can be added here)
    total_referrals: int = Field(default=0, ge=0, description="Total referrals made")
    successful_referrals: int = Field(default=0, ge=0, description="Successful referrals")
    total_rewards_distributed: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        description="Total rewards paid out",
    )

    # Timestamps
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")


class ProgramList(BaseSchema):
    """
    List of referral programs.

    Provides summary and pagination for multiple programs.
    """

    total_programs: int = Field(
        ...,
        ge=0,
        description="Total number of programs",
    )
    active_programs: int = Field(
        ...,
        ge=0,
        description="Number of active programs",
    )
    programs: List[ProgramResponse] = Field(
        ...,
        description="List of referral programs",
    )


class ProgramStats(BaseSchema):
    """
    Detailed program statistics.

    Provides comprehensive analytics for a referral program.
    """

    program_id: UUID = Field(..., description="Program ID")
    program_name: str = Field(..., description="Program name")

    # Referral statistics
    total_referrals: int = Field(..., ge=0, description="Total referrals")
    pending_referrals: int = Field(..., ge=0, description="Pending referrals")
    successful_referrals: int = Field(..., ge=0, description="Successful referrals")
    failed_referrals: int = Field(..., ge=0, description="Failed referrals")

    # Conversion metrics
    conversion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Conversion rate percentage",
    )
    average_conversion_time_days: Decimal = Field(
        ...,
        ge=0,
        description="Average time to convert in days",
    )

    # Reward statistics
    total_rewards_earned: Decimal = Field(..., ge=0, description="Total rewards earned")
    total_rewards_paid: Decimal = Field(..., ge=0, description="Total rewards paid")
    pending_rewards: Decimal = Field(..., ge=0, description="Pending reward payments")

    # Top referrers
    top_referrers: List[Dict[str, any]] = Field(
        default_factory=list,
        description="Top 10 referrers",
    )

    # Time period
    period_start: date = Field(..., description="Statistics start date")
    period_end: date = Field(..., description="Statistics end date")

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\referral\referral_program_response.py ---
# --- File: app/schemas/referral/referral_program_base.py ---
"""
Referral program definition schemas.

This module provides schemas for creating and managing referral programs
with reward structures, eligibility criteria, and validity periods.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
    BaseUpdateSchema,
)

__all__ = [
    "ReferralProgramBase",
    "ProgramCreate",
    "ProgramUpdate",
    "ProgramResponse",
    "ProgramList",
    "ProgramType",
    "RewardType",
]


class ProgramType(str):
    """Referral program types."""

    STUDENT_REFERRAL = "student_referral"
    VISITOR_REFERRAL = "visitor_referral"
    AFFILIATE = "affiliate"
    CORPORATE = "corporate"


class RewardType(str):
    """Reward types for referral programs."""

    CASH = "cash"
    DISCOUNT = "discount"
    VOUCHER = "voucher"
    FREE_MONTH = "free_month"
    POINTS = "points"


class ReferralProgramBase(BaseSchema):
    """
    Base referral program schema.

    Defines the structure and rules for a referral program including
    reward types, eligibility criteria, and validity periods.
    """

    # Program identification
    program_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Unique program name",
    )
    program_code: Optional[str] = Field(
        None,
        min_length=3,
        max_length=50,
        pattern="^[A-Z0-9_]+$",
        description="Unique program code (auto-generated if not provided)",
    )
    program_type: str = Field(
        ...,
        pattern="^(student_referral|visitor_referral|affiliate|corporate)$",
        description="Type of referral program",
    )

    # Program description
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Program description and benefits",
    )

    # Reward configuration
    reward_type: str = Field(
        ...,
        pattern="^(cash|discount|voucher|free_month|points)$",
        description="Type of reward offered",
    )
    referrer_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Reward amount for the referrer",
    )
    referee_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Reward amount for the referee (new user)",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern="^[A-Z]{3}$",
        description="Currency code (ISO 4217)",
    )

    # Reward caps
    max_referrer_rewards_per_month: Optional[int] = Field(
        None,
        ge=1,
        le=100,
        description="Maximum rewards referrer can earn per month",
    )
    max_total_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Maximum total reward amount per referrer",
    )

    # Eligibility criteria
    min_booking_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Minimum booking amount to qualify for reward",
    )
    min_stay_months: Optional[int] = Field(
        None,
        ge=1,
        le=24,
        description="Minimum stay duration in months to qualify",
    )
    min_referrer_stay_months: Optional[int] = Field(
        None,
        ge=0,
        le=12,
        description="Minimum months referrer must have stayed",
    )

    # Referral limitations
    max_referrals_per_user: Optional[int] = Field(
        None,
        ge=1,
        le=1000,
        description="Maximum referrals allowed per user",
    )
    allowed_user_roles: List[str] = Field(
        default_factory=lambda: ["student", "alumni"],
        description="User roles eligible to participate",
    )

    # Validity period
    is_active: bool = Field(
        default=True,
        description="Whether program is currently active",
    )
    valid_from: Optional[date] = Field(
        None,
        description="Program start date",
    )
    valid_to: Optional[date] = Field(
        None,
        description="Program end date",
    )

    # Terms and conditions
    terms_and_conditions: Optional[str] = Field(
        None,
        max_length=5000,
        description="Detailed terms and conditions",
    )
    auto_approve_rewards: bool = Field(
        default=False,
        description="Automatically approve rewards without manual review",
    )

    # Tracking
    track_conversion: bool = Field(
        default=True,
        description="Track conversion metrics",
    )

    @field_validator("program_name")
    @classmethod
    def validate_program_name(cls, v: str) -> str:
        """Validate program name is unique and well-formed."""
        # Remove extra spaces
        v = " ".join(v.split())
        if len(v) < 3:
            raise ValueError("Program name must be at least 3 characters")
        return v

    @field_validator("currency")
    @classmethod
    def validate_currency(cls, v: str) -> str:
        """Validate currency code."""
        v = v.upper()
        # Common currency codes
        valid_currencies = {
            "INR", "USD", "EUR", "GBP", "AED", "SGD", "MYR", "AUD", "CAD"
        }
        if v not in valid_currencies:
            raise ValueError(
                f"Invalid currency code. Supported: {', '.join(valid_currencies)}"
            )
        return v

    @field_validator("allowed_user_roles")
    @classmethod
    def validate_allowed_roles(cls, v: List[str]) -> List[str]:
        """Validate user roles."""
        valid_roles = {"student", "alumni", "visitor", "supervisor", "admin"}
        for role in v:
            if role not in valid_roles:
                raise ValueError(f"Invalid user role: {role}")
        return list(set(v))  # Remove duplicates

    @model_validator(mode="after")
    def validate_reward_amounts(self) -> "ReferralProgramBase":
        """Validate reward amounts are provided for reward types that need them."""
        if self.reward_type in ["cash", "discount", "voucher"]:
            if self.referrer_reward_amount is None and self.referee_reward_amount is None:
                raise ValueError(
                    f"At least one reward amount required for reward_type '{self.reward_type}'"
                )
            
            # Ensure amounts are reasonable
            if self.referrer_reward_amount and self.referrer_reward_amount > 100000:
                raise ValueError("Referrer reward amount seems unreasonably high")
            
            if self.referee_reward_amount and self.referee_reward_amount > 100000:
                raise ValueError("Referee reward amount seems unreasonably high")
        
        return self

    @model_validator(mode="after")
    def validate_validity_period(self) -> "ReferralProgramBase":
        """Validate validity period dates."""
        if self.valid_from and self.valid_to:
            if self.valid_to <= self.valid_from:
                raise ValueError("valid_to must be after valid_from")
            
            # Check if period is too long (e.g., more than 2 years)
            days_difference = (self.valid_to - self.valid_from).days
            if days_difference > 730:  # 2 years
                raise ValueError("Program validity period cannot exceed 2 years")
        
        return self

    @model_validator(mode="after")
    def validate_eligibility_criteria(self) -> "ReferralProgramBase":
        """Validate eligibility criteria are logical."""
        if self.min_stay_months and self.min_booking_amount:
            # If stay duration is required, booking amount should be reasonable
            monthly_rate = self.min_booking_amount / self.min_stay_months
            if monthly_rate < 1000:  # Minimum monthly rate threshold
                raise ValueError(
                    "Minimum booking amount seems too low for required stay duration"
                )
        
        return self


class ProgramCreate(ReferralProgramBase, BaseCreateSchema):
    """
    Schema for creating a new referral program.

    Inherits all fields from ReferralProgramBase with creation-specific validation.
    """

    @field_validator("program_code")
    @classmethod
    def generate_program_code(cls, v: Optional[str], info) -> str:
        """Generate program code if not provided."""
        if v is None:
            # Generate from program name
            program_name = info.data.get("program_name", "")
            code = program_name.upper().replace(" ", "_")[:20]
            
            # Add timestamp suffix for uniqueness
            import time
            timestamp = str(int(time.time()))[-6:]
            return f"{code}_{timestamp}"
        
        return v.upper()


class ProgramUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing referral program.

    Allows partial updates with proper validation.
    """

    program_name: Optional[str] = Field(
        None,
        min_length=3,
        max_length=100,
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
    )
    reward_type: Optional[str] = Field(
        None,
        pattern="^(cash|discount|voucher|free_month|points)$",
    )
    referrer_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
    )
    referee_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
    )
    min_booking_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
    )
    min_stay_months: Optional[int] = Field(
        None,
        ge=1,
        le=24,
    )
    min_referrer_stay_months: Optional[int] = Field(
        None,
        ge=0,
        le=12,
    )
    max_referrals_per_user: Optional[int] = Field(
        None,
        ge=1,
        le=1000,
    )
    max_referrer_rewards_per_month: Optional[int] = Field(
        None,
        ge=1,
        le=100,
    )
    max_total_reward_amount: Optional[Decimal] = Field(
        None,
        ge=0,
    )
    allowed_user_roles: Optional[List[str]] = None
    terms_and_conditions: Optional[str] = Field(
        None,
        max_length=5000,
    )
    is_active: Optional[bool] = None
    valid_from: Optional[date] = None
    valid_to: Optional[date] = None
    auto_approve_rewards: Optional[bool] = None
    track_conversion: Optional[bool] = None

    @model_validator(mode="after")
    def validate_at_least_one_field(self) -> "ProgramUpdate":
        """Ensure at least one field is being updated."""
        if not any([
            self.program_name,
            self.description,
            self.reward_type,
            self.referrer_reward_amount is not None,
            self.referee_reward_amount is not None,
            self.min_booking_amount is not None,
            self.min_stay_months,
            self.max_referrals_per_user,
            self.terms_and_conditions,
            self.is_active is not None,
            self.valid_from,
            self.valid_to,
        ]):
            raise ValueError("At least one field must be provided for update")
        return self


class ProgramResponse(BaseResponseSchema):
    """
    Referral program response schema.

    Includes program details and statistics.
    """

    program_name: str = Field(..., description="Program name")
    program_code: str = Field(..., description="Program code")
    program_type: str = Field(..., description="Program type")
    description: Optional[str] = Field(None, description="Program description")

    # Reward details
    reward_type: str = Field(..., description="Reward type")
    referrer_reward_amount: Optional[Decimal] = Field(None, description="Referrer reward")
    referee_reward_amount: Optional[Decimal] = Field(None, description="Referee reward")
    currency: str = Field(..., description="Currency code")

    # Eligibility criteria
    min_booking_amount: Optional[Decimal] = Field(None, description="Minimum booking amount")
    min_stay_months: Optional[int] = Field(None, description="Minimum stay duration")
    min_referrer_stay_months: Optional[int] = Field(None, description="Minimum referrer stay")
    max_referrals_per_user: Optional[int] = Field(None, description="Max referrals per user")
    max_referrer_rewards_per_month: Optional[int] = Field(None, description="Max rewards per month")

    # Status
    is_active: bool = Field(..., description="Active status")
    valid_from: Optional[date] = Field(None, description="Start date")
    valid_to: Optional[date] = Field(None, description="End date")

    # Terms
    terms_and_conditions: Optional[str] = Field(None, description="T&C")
    auto_approve_rewards: bool = Field(..., description="Auto-approve rewards")

    # Statistics (computed fields can be added here)
    total_referrals: int = Field(default=0, ge=0, description="Total referrals made")
    successful_referrals: int = Field(default=0, ge=0, description="Successful referrals")
    total_rewards_distributed: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        description="Total rewards paid out",
    )

    # Timestamps
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")


class ProgramList(BaseSchema):
    """
    List of referral programs.

    Provides summary and pagination for multiple programs.
    """

    total_programs: int = Field(
        ...,
        ge=0,
        description="Total number of programs",
    )
    active_programs: int = Field(
        ...,
        ge=0,
        description="Number of active programs",
    )
    programs: List[ProgramResponse] = Field(
        ...,
        description="List of referral programs",
    )


class ProgramStats(BaseSchema):
    """
    Detailed program statistics.

    Provides comprehensive analytics for a referral program.
    """

    program_id: UUID = Field(..., description="Program ID")
    program_name: str = Field(..., description="Program name")

    # Referral statistics
    total_referrals: int = Field(..., ge=0, description="Total referrals")
    pending_referrals: int = Field(..., ge=0, description="Pending referrals")
    successful_referrals: int = Field(..., ge=0, description="Successful referrals")
    failed_referrals: int = Field(..., ge=0, description="Failed referrals")

    # Conversion metrics
    conversion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Conversion rate percentage",
    )
    average_conversion_time_days: Decimal = Field(
        ...,
        ge=0,
        description="Average time to convert in days",
    )

    # Reward statistics
    total_rewards_earned: Decimal = Field(..., ge=0, description="Total rewards earned")
    total_rewards_paid: Decimal = Field(..., ge=0, description="Total rewards paid")
    pending_rewards: Decimal = Field(..., ge=0, description="Pending reward payments")

    # Top referrers
    top_referrers: List[Dict[str, any]] = Field(
        default_factory=list,
        description="Top 10 referrers",
    )

    # Time period
    period_start: date = Field(..., description="Statistics start date")
    period_end: date = Field(..., description="Statistics end date")

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\referral\referral_response.py ---
# --- File: app/schemas/referral/referral_response.py ---
"""
Referral record response schemas.

This module provides response schemas for referral queries including
detailed information, statistics, and analytics.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import ReferralStatus, RewardStatus

__all__ = [
    "ReferralResponse",
    "ReferralDetail",
    "ReferralStats",
    "ReferralLeaderboard",
    "ReferralTimeline",
]


class ReferralResponse(BaseResponseSchema):
    """
    Standard referral response schema.

    Used for single referral queries and list items.
    """

    # Program information
    program_id: UUID = Field(..., description="Referral program ID")
    program_name: str = Field(..., description="Program name")
    program_type: str = Field(..., description="Program type")

    # Referrer information
    referrer_id: UUID = Field(..., description="Referrer user ID")
    referrer_name: str = Field(..., description="Referrer name")
    referrer_email: Optional[str] = Field(None, description="Referrer email")

    # Referee information
    referee_email: Optional[str] = Field(None, description="Referee email")
    referee_phone: Optional[str] = Field(None, description="Referee phone")
    referee_user_id: Optional[UUID] = Field(None, description="Referee user ID")
    referee_name: Optional[str] = Field(None, description="Referee name")

    # Referral details
    referral_code: str = Field(..., description="Referral code used")
    status: ReferralStatus = Field(..., description="Referral status")
    referral_source: Optional[str] = Field(None, description="Referral source")

    # Conversion information
    booking_id: Optional[UUID] = Field(None, description="Associated booking ID")
    conversion_date: Optional[datetime] = Field(None, description="Conversion date")
    booking_amount: Optional[Decimal] = Field(None, description="Booking amount")

    # Reward information
    referrer_reward_amount: Optional[Decimal] = Field(
        None,
        description="Referrer reward amount",
    )
    referee_reward_amount: Optional[Decimal] = Field(
        None,
        description="Referee reward amount",
    )
    currency: str = Field(..., description="Currency code")

    # Reward status
    referrer_reward_status: RewardStatus = Field(
        ...,
        description="Referrer reward status",
    )
    referee_reward_status: RewardStatus = Field(
        ...,
        description="Referee reward status",
    )

    # Timestamps
    created_at: datetime = Field(..., description="Referral creation time")
    updated_at: datetime = Field(..., description="Last update time")

    @computed_field
    @property
    def is_converted(self) -> bool:
        """Check if referral has converted to booking."""
        return self.status == ReferralStatus.COMPLETED and self.booking_id is not None

    @computed_field
    @property
    def total_reward_amount(self) -> Decimal:
        """Calculate total reward amount (referrer + referee)."""
        referrer = self.referrer_reward_amount or Decimal("0")
        referee = self.referee_reward_amount or Decimal("0")
        return referrer + referee

    @computed_field
    @property
    def days_since_referral(self) -> int:
        """Calculate days since referral was created."""
        return (datetime.utcnow() - self.created_at).days


class ReferralDetail(BaseResponseSchema):
    """
    Detailed referral information.

    Includes extended fields for comprehensive referral data and history.
    """

    # Program information
    program_id: UUID = Field(..., description="Program ID")
    program_name: str = Field(..., description="Program name")
    program_type: str = Field(..., description="Program type")
    program_description: Optional[str] = Field(None, description="Program description")

    # Referrer information
    referrer_id: UUID = Field(..., description="Referrer ID")
    referrer_name: str = Field(..., description="Referrer name")
    referrer_email: Optional[str] = Field(None, description="Referrer email")
    referrer_phone: Optional[str] = Field(None, description="Referrer phone")
    referrer_total_referrals: int = Field(
        default=0,
        ge=0,
        description="Total referrals made by referrer",
    )

    # Referee information
    referee_email: Optional[str] = Field(None, description="Referee email")
    referee_phone: Optional[str] = Field(None, description="Referee phone")
    referee_user_id: Optional[UUID] = Field(None, description="Referee user ID")
    referee_name: Optional[str] = Field(None, description="Referee name")
    referee_registration_date: Optional[datetime] = Field(
        None,
        description="When referee registered",
    )

    # Referral details
    referral_code: str = Field(..., description="Referral code")
    status: ReferralStatus = Field(..., description="Current status")
    referral_source: Optional[str] = Field(None, description="Referral source")
    campaign_id: Optional[UUID] = Field(None, description="Campaign ID")

    # Conversion tracking
    booking_id: Optional[UUID] = Field(None, description="Booking ID")
    booking_amount: Optional[Decimal] = Field(None, description="Booking amount")
    booking_date: Optional[datetime] = Field(None, description="Booking date")
    conversion_date: Optional[datetime] = Field(None, description="Conversion date")
    stay_duration_months: Optional[int] = Field(None, description="Stay duration")
    hostel_id: Optional[UUID] = Field(None, description="Hostel ID")
    hostel_name: Optional[str] = Field(None, description="Hostel name")

    # Reward information
    referrer_reward_amount: Optional[Decimal] = Field(
        None,
        description="Referrer reward",
    )
    referee_reward_amount: Optional[Decimal] = Field(
        None,
        description="Referee reward",
    )
    currency: str = Field(..., description="Currency")

    # Reward status and payment
    referrer_reward_status: RewardStatus = Field(..., description="Referrer reward status")
    referee_reward_status: RewardStatus = Field(..., description="Referee reward status")
    referrer_reward_paid_at: Optional[datetime] = Field(
        None,
        description="When referrer reward was paid",
    )
    referee_reward_paid_at: Optional[datetime] = Field(
        None,
        description="When referee reward was paid",
    )

    # Status history
    status_history: List[Dict[str, any]] = Field(
        default_factory=list,
        description="History of status changes",
    )

    # Notes and metadata
    notes: Optional[str] = Field(None, description="Additional notes")
    admin_notes: Optional[str] = Field(None, description="Admin-only notes")

    # Timestamps
    created_at: datetime = Field(..., description="Creation time")
    updated_at: datetime = Field(..., description="Last update time")
    completed_at: Optional[datetime] = Field(None, description="Completion time")

    @computed_field
    @property
    def conversion_time_days(self) -> Optional[int]:
        """Calculate days from referral to conversion."""
        if self.conversion_date:
            return (self.conversion_date - self.created_at).days
        return None

    @computed_field
    @property
    def total_reward_value(self) -> Decimal:
        """Calculate total reward value."""
        referrer = self.referrer_reward_amount or Decimal("0")
        referee = self.referee_reward_amount or Decimal("0")
        return referrer + referee

    @computed_field
    @property
    def is_reward_fully_paid(self) -> bool:
        """Check if both rewards have been paid."""
        return (
            self.referrer_reward_status == RewardStatus.PAID
            and self.referee_reward_status == RewardStatus.PAID
        )


class ReferralStats(BaseSchema):
    """
    Referral statistics for a user.

    Provides comprehensive analytics for a referrer's performance.
    """

    user_id: UUID = Field(..., description="User ID")
    user_name: str = Field(..., description="User name")

    # Referral counts
    total_referrals: int = Field(
        ...,
        ge=0,
        description="Total referrals made",
    )
    successful_referrals: int = Field(
        ...,
        ge=0,
        description="Successfully converted referrals",
    )
    pending_referrals: int = Field(
        ...,
        ge=0,
        description="Pending referrals",
    )
    failed_referrals: int = Field(
        ...,
        ge=0,
        description="Failed/expired referrals",
    )
    cancelled_referrals: int = Field(
        ...,
        ge=0,
        description="Cancelled referrals",
    )

    # Conversion metrics
    conversion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Conversion rate percentage",
    )
    average_conversion_time_days: Decimal = Field(
        ...,
        ge=0,
        decimal_places=1,
        description="Average days to convert",
    )

    # Reward statistics
    total_earned: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total rewards earned",
    )
    total_paid_out: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total rewards paid out",
    )
    total_pending_rewards: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total pending rewards",
    )
    currency: str = Field(default="INR", description="Currency code")

    # Breakdown by program
    referrals_by_program: Dict[str, int] = Field(
        default_factory=dict,
        description="Referral count by program",
    )
    rewards_by_program: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Rewards earned by program",
    )

    # Time-based statistics
    referrals_this_month: int = Field(
        default=0,
        ge=0,
        description="Referrals made this month",
    )
    referrals_last_month: int = Field(
        default=0,
        ge=0,
        description="Referrals made last month",
    )

    # Ranking
    user_rank: Optional[int] = Field(
        None,
        ge=1,
        description="User's rank among all referrers",
    )
    total_referrers: Optional[int] = Field(
        None,
        ge=1,
        description="Total number of active referrers",
    )

    # Activity
    last_referral_date: Optional[datetime] = Field(
        None,
        description="Date of last referral",
    )
    most_active_program: Optional[str] = Field(
        None,
        description="Program with most referrals",
    )

    @computed_field
    @property
    def success_rate(self) -> Decimal:
        """Calculate success rate percentage."""
        if self.total_referrals == 0:
            return Decimal("0")
        return Decimal(
            (self.successful_referrals / self.total_referrals * 100)
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def pending_payout_amount(self) -> Decimal:
        """Calculate amount pending for payout."""
        return self.total_pending_rewards

    @computed_field
    @property
    def average_reward_per_referral(self) -> Decimal:
        """Calculate average reward per successful referral."""
        if self.successful_referrals == 0:
            return Decimal("0")
        return (self.total_earned / self.successful_referrals).quantize(
            Decimal("0.01")
        )


class ReferralLeaderboard(BaseSchema):
    """
    Leaderboard of top referrers.

    Ranks users by referral performance.
    """

    period: str = Field(
        ...,
        pattern="^(all_time|this_month|last_month|this_year)$",
        description="Time period for leaderboard",
    )
    total_users: int = Field(
        ...,
        ge=0,
        description="Total users on leaderboard",
    )
    top_referrers: List["LeaderboardEntry"] = Field(
        ...,
        max_length=100,
        description="Top referrers list",
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When leaderboard was generated",
    )


class LeaderboardEntry(BaseSchema):
    """Individual leaderboard entry."""

    rank: int = Field(..., ge=1, description="User's rank")
    user_id: UUID = Field(..., description="User ID")
    user_name: str = Field(..., description="User name")
    user_avatar: Optional[str] = Field(None, description="User avatar URL")

    total_referrals: int = Field(..., ge=0, description="Total referrals")
    successful_referrals: int = Field(..., ge=0, description="Successful referrals")
    total_rewards_earned: Decimal = Field(..., ge=0, description="Total rewards earned")
    
    conversion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Conversion rate percentage",
    )

    # Badge/achievement
    badge: Optional[str] = Field(
        None,
        description="Achievement badge (e.g., 'Top Referrer', 'Rising Star')",
    )


class ReferralTimeline(BaseSchema):
    """
    Timeline of referral activities.

    Chronological view of referral events and milestones.
    """

    referral_id: UUID = Field(..., description="Referral ID")
    timeline_events: List["TimelineEvent"] = Field(
        ...,
        description="Chronological events",
    )


class TimelineEvent(BaseSchema):
    """Single timeline event."""

    event_type: str = Field(
        ...,
        pattern="^(created|shared|clicked|registered|booked|converted|reward_approved|reward_paid|cancelled|expired)$",
        description="Event type",
    )
    event_title: str = Field(..., description="Event title")
    event_description: Optional[str] = Field(None, description="Event description")
    event_date: datetime = Field(..., description="Event timestamp")
    event_data: Dict[str, any] = Field(
        default_factory=dict,
        description="Additional event data",
    )
    actor_id: Optional[UUID] = Field(None, description="User who triggered event")
    actor_name: Optional[str] = Field(None, description="Actor name")


class ReferralAnalytics(BaseSchema):
    """
    Advanced analytics for referral performance.

    Provides insights and trends for referral programs.
    """

    program_id: Optional[UUID] = Field(None, description="Program ID (null for all)")
    
    # Time period
    period_start: datetime = Field(..., description="Analysis start date")
    period_end: datetime = Field(..., description="Analysis end date")

    # Overall metrics
    total_referrals: int = Field(..., ge=0, description="Total referrals")
    total_conversions: int = Field(..., ge=0, description="Total conversions")
    total_revenue_generated: Decimal = Field(
        ...,
        ge=0,
        description="Total revenue from referrals",
    )
    total_rewards_distributed: Decimal = Field(
        ...,
        ge=0,
        description="Total rewards paid",
    )

    # Performance metrics
    conversion_rate: Decimal = Field(..., ge=0, le=100, description="Conversion rate")
    average_conversion_time_days: Decimal = Field(
        ...,
        ge=0,
        description="Average conversion time",
    )
    average_booking_value: Decimal = Field(
        ...,
        ge=0,
        description="Average booking value from referrals",
    )

    # ROI metrics
    roi_percentage: Decimal = Field(
        ...,
        description="Return on investment percentage",
    )
    cost_per_acquisition: Decimal = Field(
        ...,
        ge=0,
        description="Cost per acquired customer",
    )

    # Trends
    referral_trend: List[Dict[str, any]] = Field(
        default_factory=list,
        description="Daily/weekly referral trend data",
    )
    conversion_trend: List[Dict[str, any]] = Field(
        default_factory=list,
        description="Conversion trend data",
    )

    # Top performers
    top_referrers: List[Dict[str, any]] = Field(
        default_factory=list,
        max_length=10,
        description="Top 10 referrers",
    )
    top_sources: List[Dict[str, any]] = Field(
        default_factory=list,
        description="Top referral sources",
    )

    # Geographic distribution
    referrals_by_location: Dict[str, int] = Field(
        default_factory=dict,
        description="Referrals by city/region",
    )

    # Status breakdown
    status_breakdown: Dict[str, int] = Field(
        default_factory=dict,
        description="Referrals by status",
    )

    @computed_field
    @property
    def effective_conversion_rate(self) -> Decimal:
        """Calculate effective conversion rate."""
        if self.total_referrals == 0:
            return Decimal("0")
        return Decimal(
            (self.total_conversions / self.total_referrals * 100)
        ).quantize(Decimal("0.01"))

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\referral\referral_rewards.py ---
# --- File: app/schemas/referral/referral_rewards.py ---
"""
Referral reward tracking schemas.

This module provides schemas for managing reward calculations,
payouts, and tracking for referral programs.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import PaymentMethod, RewardStatus

__all__ = [
    "RewardConfig",
    "RewardTracking",
    "RewardCalculation",
    "PayoutRequest",
    "PayoutRequestResponse",
    "PayoutHistory",
    "RewardSummary",
]


class RewardConfig(BaseSchema):
    """
    Global referral reward configuration.

    Defines payout rules, minimum thresholds, and payment methods.
    """

    # Payout thresholds
    min_payout_amount: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        decimal_places=2,
        description="Minimum amount required before payout",
    )
    max_payout_amount: Decimal = Field(
        default=Decimal("100000.00"),
        ge=0,
        decimal_places=2,
        description="Maximum amount per payout transaction",
    )

    # Payment methods
    payout_methods: List[PaymentMethod] = Field(
        default_factory=lambda: [
            PaymentMethod.BANK_TRANSFER,
            PaymentMethod.UPI,
        ],
        min_length=1,
        description="Allowed payout methods",
    )

    # Processing settings
    auto_approve_payouts: bool = Field(
        default=False,
        description="Auto-approve payout requests",
    )
    payout_processing_time_days: int = Field(
        default=7,
        ge=1,
        le=30,
        description="Estimated processing time in days",
    )

    # Fees and charges
    payout_fee_percentage: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=10,
        decimal_places=2,
        description="Payout processing fee percentage",
    )
    min_payout_fee: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Minimum payout fee",
    )
    max_payout_fee: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        decimal_places=2,
        description="Maximum payout fee",
    )

    # Frequency limits
    max_payouts_per_month: int = Field(
        default=4,
        ge=1,
        le=30,
        description="Maximum payouts allowed per month",
    )
    min_days_between_payouts: int = Field(
        default=7,
        ge=1,
        le=30,
        description="Minimum days between payout requests",
    )

    # Tax settings
    tax_deduction_applicable: bool = Field(
        default=False,
        description="Whether tax deduction is applicable",
    )
    tax_deduction_percentage: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=30,
        decimal_places=2,
        description="Tax deduction percentage",
    )

    @field_validator("payout_methods")
    @classmethod
    def validate_payout_methods(cls, v: List[PaymentMethod]) -> List[PaymentMethod]:
        """Ensure unique payout methods."""
        return list(set(v))


class RewardTracking(BaseSchema):
    """
    Track rewards earned by a user across all programs.

    Provides comprehensive reward balance and history.
    """

    user_id: UUID = Field(..., description="User ID")
    user_name: str = Field(..., description="User name")

    # Overall balances
    total_rewards_earned: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total rewards earned (all time)",
    )
    total_rewards_paid: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total rewards paid out",
    )
    pending_rewards: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Pending rewards awaiting payout",
    )
    available_for_payout: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount available for immediate payout",
    )
    currency: str = Field(default="INR", description="Currency code")

    # Breakdown by program
    rewards_by_program: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Rewards earned per program",
    )

    # Breakdown by status
    approved_rewards: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        description="Approved but not paid rewards",
    )
    pending_approval: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        description="Rewards pending approval",
    )
    cancelled_rewards: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        description="Cancelled reward amount",
    )

    # Payout information
    last_payout_date: Optional[datetime] = Field(
        None,
        description="Date of last payout",
    )
    last_payout_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Amount of last payout",
    )
    next_payout_eligible_date: Optional[datetime] = Field(
        None,
        description="When user is eligible for next payout",
    )

    # Statistics
    total_payouts: int = Field(
        default=0,
        ge=0,
        description="Total number of payouts received",
    )
    average_payout_amount: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        description="Average payout amount",
    )


class RewardCalculation(BaseSchema):
    """
    Reward calculation for a referral.

    Shows breakdown of reward amounts and eligibility.
    """

    referral_id: UUID = Field(..., description="Referral ID")
    program_id: UUID = Field(..., description="Program ID")
    
    # Booking details
    booking_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Booking amount",
    )
    stay_duration_months: int = Field(
        ...,
        ge=1,
        description="Stay duration in months",
    )

    # Eligibility
    is_eligible: bool = Field(..., description="Whether referral is eligible for reward")
    eligibility_reasons: List[str] = Field(
        default_factory=list,
        description="Reasons for eligibility/ineligibility",
    )

    # Calculated rewards
    referrer_base_reward: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Base reward for referrer",
    )
    referrer_bonus: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        decimal_places=2,
        description="Bonus for referrer (if any)",
    )
    referrer_total_reward: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total reward for referrer",
    )

    referee_base_reward: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Base reward for referee",
    )
    referee_bonus: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        decimal_places=2,
        description="Bonus for referee (if any)",
    )
    referee_total_reward: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total reward for referee",
    )

    # Deductions
    tax_deduction: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        decimal_places=2,
        description="Tax deduction amount",
    )
    processing_fee: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        decimal_places=2,
        description="Processing fee",
    )

    # Net amounts
    referrer_net_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Net amount for referrer after deductions",
    )
    referee_net_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Net amount for referee after deductions",
    )

    currency: str = Field(default="INR", description="Currency code")
    calculated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Calculation timestamp",
    )


class PayoutRequest(BaseCreateSchema):
    """
    Request payout of accumulated referral rewards.

    User initiates withdrawal of earned rewards.
    """

    user_id: UUID = Field(..., description="User requesting payout")
    
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount to withdraw",
    )

    # Payment details
    payout_method: PaymentMethod = Field(
        ...,
        description="Preferred payout method",
    )
    payout_details: Dict[str, str] = Field(
        ...,
        description="Method-specific payout details",
    )

    # Optional preferences
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        description="Currency for payout",
    )
    urgent_payout: bool = Field(
        default=False,
        description="Request urgent processing (may incur extra fees)",
    )

    # Notes
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes or instructions",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate payout amount."""
        if v <= 0:
            raise ValueError("Payout amount must be greater than zero")
        if v < Decimal("100.00"):
            raise ValueError("Minimum payout amount is 100.00")
        if v > Decimal("100000.00"):
            raise ValueError("Maximum payout amount is 100,000.00")
        return v

    @model_validator(mode="after")
    def validate_payout_details(self) -> "PayoutRequest":
        """Validate payout details based on method."""
        if self.payout_method == PaymentMethod.UPI:
            if "upi_id" not in self.payout_details:
                raise ValueError("UPI ID required for UPI payout")
            # Validate UPI ID format
            upi_id = self.payout_details["upi_id"]
            if "@" not in upi_id:
                raise ValueError("Invalid UPI ID format")

        elif self.payout_method == PaymentMethod.BANK_TRANSFER:
            required_fields = [
                "account_number",
                "account_holder_name",
                "ifsc_code",
                "bank_name",
            ]
            for field in required_fields:
                if field not in self.payout_details:
                    raise ValueError(f"{field} required for bank transfer")

        return self


class PayoutRequestResponse(BaseResponseSchema):
    """
    Payout request status and tracking.

    Tracks the lifecycle of a payout request.
    """

    payout_request_id: UUID = Field(..., description="Payout request ID")
    user_id: UUID = Field(..., description="User ID")
    user_name: str = Field(..., description="User name")

    # Amount details
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Requested payout amount",
    )
    processing_fee: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        decimal_places=2,
        description="Processing fee",
    )
    tax_deduction: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        decimal_places=2,
        description="Tax deduction",
    )
    net_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Net amount to be paid",
    )
    currency: str = Field(..., description="Currency code")

    # Payment details
    payout_method: PaymentMethod = Field(..., description="Payout method")
    payout_details_masked: Dict[str, str] = Field(
        default_factory=dict,
        description="Masked payout details for security",
    )

    # Status tracking
    status: RewardStatus = Field(..., description="Payout status")
    requested_at: datetime = Field(..., description="Request timestamp")
    approved_at: Optional[datetime] = Field(None, description="Approval timestamp")
    processed_at: Optional[datetime] = Field(None, description="Processing timestamp")
    completed_at: Optional[datetime] = Field(None, description="Completion timestamp")

    # Additional information
    transaction_id: Optional[str] = Field(
        None,
        description="External transaction ID",
    )
    failure_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for failure (if applicable)",
    )
    admin_notes: Optional[str] = Field(
        None,
        description="Admin notes",
    )

    # Estimated completion
    estimated_completion_date: Optional[datetime] = Field(
        None,
        description="Estimated completion date",
    )

    # Audit
    approved_by: Optional[UUID] = Field(None, description="Admin who approved")
    processed_by: Optional[UUID] = Field(None, description="Admin who processed")


class PayoutHistory(BaseSchema):
    """
    Payout history for a user.

    Lists all payout transactions.
    """

    user_id: UUID = Field(..., description="User ID")
    total_payouts: int = Field(..., ge=0, description="Total payout count")
    total_amount_paid: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total amount paid out",
    )
    currency: str = Field(default="INR", description="Currency")

    payouts: List[PayoutRequestResponse] = Field(
        ...,
        description="List of payout transactions",
    )


class RewardSummary(BaseSchema):
    """
    Summary of rewards for reporting.

    Provides aggregated reward data for a time period.
    """

    # Time period
    period_start: datetime = Field(..., description="Period start date")
    period_end: datetime = Field(..., description="Period end date")

    # User filter (optional)
    user_id: Optional[UUID] = Field(None, description="User ID (null for all users)")
    program_id: Optional[UUID] = Field(None, description="Program ID (null for all)")

    # Reward statistics
    total_rewards_earned: Decimal = Field(
        ...,
        ge=0,
        description="Total rewards earned in period",
    )
    total_rewards_approved: Decimal = Field(
        ...,
        ge=0,
        description="Total rewards approved",
    )
    total_rewards_paid: Decimal = Field(
        ...,
        ge=0,
        description="Total rewards paid out",
    )
    total_rewards_pending: Decimal = Field(
        ...,
        ge=0,
        description="Total rewards pending",
    )
    total_rewards_cancelled: Decimal = Field(
        ...,
        ge=0,
        description="Total rewards cancelled",
    )

    # Breakdown
    rewards_by_status: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Rewards by status",
    )
    rewards_by_program: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Rewards by program",
    )
    rewards_by_month: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Monthly reward distribution",
    )

    # Payout statistics
    total_payout_requests: int = Field(
        default=0,
        ge=0,
        description="Total payout requests",
    )
    successful_payouts: int = Field(
        default=0,
        ge=0,
        description="Successful payouts",
    )
    failed_payouts: int = Field(
        default=0,
        ge=0,
        description="Failed payouts",
    )

    # Averages
    average_reward_amount: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        description="Average reward amount",
    )
    average_payout_amount: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        description="Average payout amount",
    )

    currency: str = Field(default="INR", description="Currency code")

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\referral\__init__.py ---
# --- File: app/schemas/referral/__init__.py ---
"""
Referral schemas package.

Provides comprehensive schemas for referral program management including
programs, referrals, codes, rewards, and analytics.
"""

from __future__ import annotations

# Program schemas
from app.schemas.referral.referral_program_base import (
    ProgramCreate,
    ProgramList,
    ProgramResponse,
    ProgramStats,
    ProgramType,
    ProgramUpdate,
    ReferralProgramBase,
    RewardType,
)

# Referral base schemas
from app.schemas.referral.referral_base import (
    ReferralBase,
    ReferralConversion,
    ReferralCreate,
    ReferralUpdate,
)

# Referral code schemas
from app.schemas.referral.referral_code import (
    CodeValidationRequest,
    CodeValidationResponse,
    ReferralCodeGenerate,
    ReferralCodeResponse,
    ReferralCodeStats,
)

# Response schemas
from app.schemas.referral.referral_response import (
    LeaderboardEntry,
    ReferralAnalytics,
    ReferralDetail,
    ReferralLeaderboard,
    ReferralResponse,
    ReferralStats,
    ReferralTimeline,
    TimelineEvent,
)

# Reward schemas
from app.schemas.referral.referral_rewards import (
    PayoutHistory,
    PayoutRequest,
    PayoutRequestResponse,
    RewardCalculation,
    RewardConfig,
    RewardSummary,
    RewardTracking,
)

__all__ = [
    # Program
    "ReferralProgramBase",
    "ProgramCreate",
    "ProgramUpdate",
    "ProgramResponse",
    "ProgramList",
    "ProgramStats",
    "ProgramType",
    "RewardType",
    # Base
    "ReferralBase",
    "ReferralCreate",
    "ReferralUpdate",
    "ReferralConversion",
    # Code
    "ReferralCodeGenerate",
    "ReferralCodeResponse",
    "CodeValidationRequest",
    "CodeValidationResponse",
    "ReferralCodeStats",
    # Response
    "ReferralResponse",
    "ReferralDetail",
    "ReferralStats",
    "ReferralLeaderboard",
    "LeaderboardEntry",
    "ReferralTimeline",
    "TimelineEvent",
    "ReferralAnalytics",
    # Rewards
    "RewardConfig",
    "RewardTracking",
    "RewardCalculation",
    "PayoutRequest",
    "PayoutRequestResponse",
    "PayoutHistory",
    "RewardSummary",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\review =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\review ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\review =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_analytics.py ---
"""
Review analytics schemas
"""
from datetime import date
from decimal import Decimal
from typing import Dict, List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter


class ReviewAnalytics(BaseSchema):
    """Comprehensive review analytics"""
    hostel_id: UUID
    hostel_name: str
    
    analysis_period: Optional[DateRangeFilter] = None
    generated_at: datetime
    
    # Summary
    total_reviews: int
    average_rating: Decimal
    
    # Rating distribution
    rating_distribution: "RatingDistribution"
    
    # Detailed ratings
    detailed_ratings_average: Dict[str, Decimal] = Field(
        ...,
        description="Aspect -> average rating"
    )
    
    # Trends
    rating_trend: "TrendAnalysis"
    
    # Sentiment
    sentiment_analysis: Optional["SentimentAnalysis"] = None
    
    # Verification
    verified_reviews_count: int
    verification_rate: Decimal
    
    # Engagement
    average_helpful_votes: Decimal
    response_rate: Decimal


class RatingDistribution(BaseSchema):
    """Rating distribution breakdown"""
    rating_5_count: int
    rating_4_count: int
    rating_3_count: int
    rating_2_count: int
    rating_1_count: int
    
    rating_5_percentage: Decimal
    rating_4_percentage: Decimal
    rating_3_percentage: Decimal
    rating_2_percentage: Decimal
    rating_1_percentage: Decimal
    
    # Aggregated
    positive_reviews: int = Field(..., description="4-5 star reviews")
    neutral_reviews: int = Field(..., description="3 star reviews")
    negative_reviews: int = Field(..., description="1-2 star reviews")
    
    positive_percentage: Decimal
    neutral_percentage: Decimal
    negative_percentage: Decimal


class TrendAnalysis(BaseSchema):
    """Rating trend analysis"""
    trend_direction: str = Field(..., pattern="^(improving|declining|stable)$")
    trend_percentage: Optional[Decimal] = Field(None, description="% change")
    
    # Monthly trend
    monthly_ratings: List["MonthlyRating"] = Field(default_factory=list)
    
    # Recent vs older
    last_30_days_rating: Decimal
    last_90_days_rating: Decimal
    all_time_rating: Decimal


class MonthlyRating(BaseSchema):
    """Monthly rating data"""
    month: str  # YYYY-MM
    average_rating: Decimal
    review_count: int


class SentimentAnalysis(BaseSchema):
    """Sentiment analysis of reviews"""
    overall_sentiment: str = Field(..., pattern="^(positive|neutral|negative)$")
    
    sentiment_score: Decimal = Field(..., ge=-1, le=1, description="Sentiment score")
    
    # Distribution
    positive_count: int
    neutral_count: int
    negative_count: int
    
    # Common themes
    positive_themes: List[str] = Field(default_factory=list, description="Common positive mentions")
    negative_themes: List[str] = Field(default_factory=list, description="Common complaints")
    
    # Keywords
    most_mentioned_positive: List[str] = Field(default_factory=list)
    most_mentioned_negative: List[str] = Field(default_factory=list)


class AspectAnalysis(BaseSchema):
    """Analysis by specific aspects"""
    aspect: str = Field(..., description="cleanliness, food, staff, etc.")
    
    average_rating: Decimal
    total_ratings: int
    
    # Distribution
    rating_distribution: Dict[int, int] = Field(..., description="Rating -> count")
    
    # Trend
    trend: str = Field(..., pattern="^(improving|declining|stable)$")
    
    # Mentions
    mention_count: int
    positive_mentions: int
    negative_mentions: int
    
    # Top comments
    top_positive_comments: List[str] = Field(default_factory=list, max_items=5)
    top_negative_comments: List[str] = Field(default_factory=list, max_items=5)


class CompetitorComparison(BaseSchema):
    """Compare reviews with competitors (if data available)"""
    hostel_id: UUID
    hostel_name: str
    
    this_hostel_rating: Decimal
    competitor_average_rating: Decimal
    
    rating_difference: Decimal
    percentile_rank: Decimal = Field(..., description="Percentile among competitors")
    
    # Strengths
    competitive_advantages: List[str] = Field(
        default_factory=list,
        description="Aspects rated higher than competitors"
    )
    
    # Weaknesses
    improvement_areas: List[str] = Field(
        default_factory=list,
        description="Aspects rated lower than competitors"
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_base.py ---
"""
Review base schemas
"""
from decimal import Decimal
from typing import List, Optional
from pydantic import Field, HttpUrl, field_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseUpdateSchema, BaseSchema


class ReviewBase(BaseSchema):
    """Base review schema"""
    hostel_id: UUID = Field(..., description="Hostel being reviewed")
    reviewer_id: UUID = Field(..., description="User writing review")
    student_id: Optional[UUID] = Field(None, description="Student profile (if verified stay)")
    booking_id: Optional[UUID] = Field(None, description="Related booking")
    
    # Overall rating
    overall_rating: Decimal = Field(..., ge=1, le=5, description="Overall rating 1-5")
    
    # Review content
    title: str = Field(..., min_length=5, max_length=255, description="Review title")
    review_text: str = Field(..., min_length=50, max_length=5000, description="Review text")
    
    # Detailed ratings
    cleanliness_rating: Optional[int] = Field(None, ge=1, le=5)
    food_quality_rating: Optional[int] = Field(None, ge=1, le=5)
    staff_behavior_rating: Optional[int] = Field(None, ge=1, le=5)
    security_rating: Optional[int] = Field(None, ge=1, le=5)
    value_for_money_rating: Optional[int] = Field(None, ge=1, le=5)
    amenities_rating: Optional[int] = Field(None, ge=1, le=5)
    
    # Photos
    photos: List[HttpUrl] = Field(default_factory=list, max_items=10, description="Review photos")
    
    @field_validator('overall_rating')
    @classmethod
    def round_rating(cls, v: Decimal) -> Decimal:
        """Round rating to 0.5"""
        return round(v * 2) / 2


class ReviewCreate(ReviewBase, BaseCreateSchema):
    """Create review"""
    pass


class ReviewUpdate(BaseUpdateSchema):
    """Update review (limited time after posting)"""
    title: Optional[str] = Field(None, min_length=5, max_length=255)
    review_text: Optional[str] = Field(None, min_length=50, max_length=5000)
    
    overall_rating: Optional[Decimal] = Field(None, ge=1, le=5)
    
    cleanliness_rating: Optional[int] = Field(None, ge=1, le=5)
    food_quality_rating: Optional[int] = Field(None, ge=1, le=5)
    staff_behavior_rating: Optional[int] = Field(None, ge=1, le=5)
    security_rating: Optional[int] = Field(None, ge=1, le=5)
    value_for_money_rating: Optional[int] = Field(None, ge=1, le=5)
    amenities_rating: Optional[int] = Field(None, ge=1, le=5)
    
    photos: Optional[List[HttpUrl]] = None

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_filters.py ---
"""
Review filter schemas
"""
from datetime import date
from decimal import Decimal
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseFilterSchema


class ReviewFilterParams(BaseFilterSchema):
    """Review filter parameters"""
    # Hostel filter
    hostel_id: Optional[UUID] = None
    hostel_ids: Optional[List[UUID]] = None
    
    # Rating filter
    min_rating: Optional[Decimal] = Field(None, ge=1, le=5)
    max_rating: Optional[Decimal] = Field(None, ge=1, le=5)
    rating: Optional[int] = Field(None, ge=1, le=5, description="Exact rating")
    
    # Verification
    verified_only: Optional[bool] = None
    
    # Date filter
    posted_date_from: Optional[date] = None
    posted_date_to: Optional[date] = None
    
    # Status
    approved_only: bool = Field(True, description="Show only approved reviews")
    flagged_only: Optional[bool] = None
    
    # Response
    with_hostel_response: Optional[bool] = None
    
    # Helpfulness
    min_helpful_count: Optional[int] = Field(None, ge=0)
    
    # Photos
    with_photos_only: Optional[bool] = None


class SearchRequest(BaseFilterSchema):
    """Search reviews"""
    query: str = Field(..., min_length=1)
    hostel_id: Optional[UUID] = None
    
    search_in_title: bool = Field(True)
    search_in_content: bool = Field(True)
    
    min_rating: Optional[Decimal] = None
    
    page: int = Field(1, ge=1)
    page_size: int = Field(20, ge=1, le=100)


class SortOptions(BaseFilterSchema):
    """Review sorting options"""
    sort_by: str = Field(
        "helpful",
        pattern="^(helpful|recent|rating_high|rating_low|verified)$"
    )
    
    # Additional sort logic
    verified_first: bool = Field(True, description="Show verified reviews first")
    with_photos_first: bool = Field(False, description="Prioritize reviews with photos")


class ReviewExportRequest(BaseFilterSchema):
    """Export reviews"""
    hostel_id: UUID
    filters: Optional[ReviewFilterParams] = None
    
    format: str = Field("csv", pattern="^(csv|excel|pdf)$")
    
    include_detailed_ratings: bool = Field(True)
    include_hostel_responses: bool = Field(True)
    include_voter_stats: bool = Field(False)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_moderation.py ---
"""
Review moderation schemas
"""
from datetime import datetime
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class ModerationRequest(BaseCreateSchema):
    """Submit review for moderation"""
    review_id: UUID
    
    action: str = Field(..., pattern="^(approve|reject|flag|unflag)$")
    
    # If rejecting
    rejection_reason: Optional[str] = Field(None, min_length=20, max_length=500)
    
    # If flagging
    flag_reason: Optional[str] = Field(
        None,
        pattern="^(inappropriate|spam|fake|offensive|other)$"
    )
    flag_details: Optional[str] = Field(None, max_length=1000)
    
    # Moderator notes (internal)
    moderator_notes: Optional[str] = Field(None, max_length=500)


class ModerationResponse(BaseSchema):
    """Moderation response"""
    review_id: UUID
    
    action_taken: str
    moderated_by: UUID
    moderated_by_name: str
    moderated_at: datetime
    
    # Notification sent
    reviewer_notified: bool
    
    message: str


class ModerationQueue(BaseSchema):
    """Moderation queue for reviews"""
    hostel_id: Optional[UUID] = None
    
    total_pending: int
    flagged_reviews: int
    auto_approved: int
    
    pending_reviews: List["PendingReview"]


class PendingReview(BaseSchema):
    """Pending review in moderation queue"""
    review_id: UUID
    hostel_id: UUID
    hostel_name: str
    
    reviewer_name: str
    overall_rating: Decimal
    
    title: str
    review_excerpt: str
    
    is_verified_stay: bool
    
    # Flags
    is_flagged: bool
    flag_count: int
    
    submitted_at: datetime
    
    # Auto-moderation score
    spam_score: Optional[Decimal] = Field(None, ge=0, le=1, description="AI spam detection score")
    sentiment_score: Optional[Decimal] = Field(None, ge=-1, le=1, description="Sentiment analysis")


class ApprovalWorkflow(BaseSchema):
    """Review approval workflow"""
    review_id: UUID
    
    requires_moderation: bool
    moderation_status: str = Field(
        ...,
        pattern="^(pending|approved|rejected|flagged)$"
    )
    
    # Timeline
    submitted_at: datetime
    moderated_at: Optional[datetime]
    
    # Moderator
    moderated_by: Optional[UUID]
    moderated_by_name: Optional[str]
    
    # Reason (if rejected)
    rejection_reason: Optional[str]


class BulkModeration(BaseCreateSchema):
    """Moderate multiple reviews"""
    review_ids: List[UUID] = Field(..., min_items=1, max_items=50)
    
    action: str = Field(..., pattern="^(approve|reject)$")
    
    # Common reason
    reason: Optional[str] = None


class ModerationStats(BaseSchema):
    """Moderation statistics"""
    hostel_id: Optional[UUID]
    period_start: date
    period_end: date
    
    total_reviews: int
    auto_approved: int
    manually_approved: int
    rejected: int
    flagged: int
    
    average_moderation_time_hours: Decimal
    
    # By moderator
    moderations_by_user: dict = Field(default_factory=dict)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_response.py ---
"""
Review response schemas
"""
from datetime import datetime
from decimal import Decimal
from typing import List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema


class ReviewResponse(BaseResponseSchema):
    """Review response"""
    hostel_id: UUID
    hostel_name: str
    
    reviewer_id: UUID
    reviewer_name: str
    
    overall_rating: Decimal
    title: str
    review_text: str
    
    is_verified_stay: bool
    verified_at: Optional[datetime]
    
    is_approved: bool
    
    helpful_count: int
    not_helpful_count: int
    
    created_at: datetime


class ReviewDetail(BaseResponseSchema):
    """Detailed review information"""
    hostel_id: UUID
    hostel_name: str
    
    # Reviewer
    reviewer_id: UUID
    reviewer_name: str
    reviewer_profile_image: Optional[str]
    
    student_id: Optional[UUID]
    booking_id: Optional[UUID]
    
    # Ratings
    overall_rating: Decimal
    cleanliness_rating: Optional[int]
    food_quality_rating: Optional[int]
    staff_behavior_rating: Optional[int]
    security_rating: Optional[int]
    value_for_money_rating: Optional[int]
    amenities_rating: Optional[int]
    
    # Content
    title: str
    review_text: str
    
    # Photos
    photos: List[str]
    
    # Verification
    is_verified_stay: bool
    verified_at: Optional[datetime]
    
    # Moderation
    is_approved: bool
    approved_by: Optional[UUID]
    approved_at: Optional[datetime]
    
    is_flagged: bool
    flag_reason: Optional[str]
    flagged_by: Optional[UUID]
    flagged_at: Optional[datetime]
    
    # Engagement
    helpful_count: int
    not_helpful_count: int
    report_count: int
    
    # Hostel response
    hostel_response: Optional["HostelResponseDetail"]
    
    # Dates
    created_at: datetime
    updated_at: datetime
    
    # Visibility
    is_published: bool


class HostelResponseDetail(BaseSchema):
    """Hostel's response to review"""
    response_text: str
    responded_by: UUID
    responded_by_name: str
    responded_at: datetime


class ReviewListItem(BaseSchema):
    """Review list item"""
    id: UUID
    reviewer_name: str
    overall_rating: Decimal
    title: str
    review_excerpt: str = Field(..., description="First 150 characters")
    
    is_verified_stay: bool
    helpful_count: int
    
    created_at: datetime
    
    has_hostel_response: bool


class ReviewSummary(BaseSchema):
    """Review summary for hostel"""
    hostel_id: UUID
    hostel_name: str
    
    total_reviews: int
    average_rating: Decimal
    
    # Rating distribution
    rating_5_count: int
    rating_4_count: int
    rating_3_count: int
    rating_2_count: int
    rating_1_count: int
    
    # Verified reviews
    verified_reviews_count: int
    verified_reviews_percentage: Decimal
    
    # Recent reviews
    recent_reviews: List[ReviewListItem] = Field(default_factory=list, max_items=5)
    
    # Recommendation
    would_recommend_percentage: Decimal = Field(
        ...,
        description="% of reviewers who would recommend"
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_response_schema.py ---
"""
Hostel response to review schemas
"""
from datetime import datetime
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema


class HostelResponseCreate(BaseCreateSchema):
    """Create hostel response to review"""
    review_id: UUID = Field(..., description="Review being responded to")
    
    response_text: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Response text"
    )
    
    responded_by: UUID = Field(..., description="Admin/owner responding")


class OwnerResponse(BaseResponseSchema):
    """Owner/hostel response to review"""
    review_id: UUID
    
    response_text: str
    
    responded_by: UUID
    responded_by_name: str
    responded_by_role: str
    
    responded_at: datetime


class ResponseUpdate(BaseCreateSchema):
    """Update hostel response"""
    response_id: UUID
    
    response_text: str = Field(..., min_length=20, max_length=2000)


class ResponseGuidelines(BaseSchema):
    """Guidelines for hostel responses"""
    guidelines: List[str] = Field(
        default_factory=lambda: [
            "Thank the reviewer for their feedback",
            "Address specific concerns mentioned",
            "Be professional and courteous",
            "Explain any misunderstandings",
            "Mention improvements made",
            "Invite them to connect directly if needed"
        ]
    )
    
    best_practices: List[str] = Field(
        default_factory=lambda: [
            "Respond within 48 hours",
            "Personalize your response",
            "Acknowledge both positive and negative points",
            "Don't be defensive or argumentative",
            "Keep it concise and relevant"
        ]
    )


class ResponseStats(BaseSchema):
    """Hostel response statistics"""
    hostel_id: UUID
    
    total_reviews: int
    total_responses: int
    response_rate: Decimal = Field(..., description="% of reviews with responses")
    
    average_response_time_hours: Decimal
    
    # By rating
    response_rate_5_star: Decimal
    response_rate_4_star: Decimal
    response_rate_3_star: Decimal
    response_rate_2_star: Decimal
    response_rate_1_star: Decimal

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_submission.py ---
"""
Review submission schemas
"""
from decimal import Decimal
from typing import List, Optional
from pydantic import Field, HttpUrl
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema


class ReviewSubmissionRequest(BaseCreateSchema):
    """Submit review request"""
    hostel_id: UUID = Field(..., description="Hostel to review")
    
    # Verification (optional, helps verify stay)
    booking_id: Optional[UUID] = Field(None, description="Related booking ID")
    student_id: Optional[UUID] = Field(None, description="Student profile ID")
    
    # Basic review
    overall_rating: Decimal = Field(..., ge=1, le=5, description="Overall rating")
    title: str = Field(..., min_length=5, max_length=255)
    review_text: str = Field(..., min_length=50, max_length=5000)
    
    # Detailed ratings
    detailed_ratings: "DetailedRatings"
    
    # Media
    photos: List[HttpUrl] = Field(default_factory=list, max_items=10)
    
    # Recommendations
    would_recommend: bool = Field(..., description="Would recommend this hostel?")
    
    # Stay details (helps verification)
    stay_duration_months: Optional[int] = Field(None, ge=1, le=24)
    check_in_date: Optional[date] = None
    
    # Terms
    agree_to_guidelines: bool = Field(..., description="Agrees to review guidelines")


class DetailedRatings(BaseSchema):
    """Detailed aspect ratings"""
    cleanliness: int = Field(..., ge=1, le=5, description="Cleanliness rating")
    food_quality: Optional[int] = Field(None, ge=1, le=5, description="Food quality (if applicable)")
    staff_behavior: int = Field(..., ge=1, le=5, description="Staff behavior")
    security: int = Field(..., ge=1, le=5, description="Security")
    value_for_money: int = Field(..., ge=1, le=5, description="Value for money")
    amenities: int = Field(..., ge=1, le=5, description="Amenities quality")
    location: Optional[int] = Field(None, ge=1, le=5, description="Location convenience")
    wifi_quality: Optional[int] = Field(None, ge=1, le=5, description="WiFi quality")
    maintenance: Optional[int] = Field(None, ge=1, le=5, description="Maintenance responsiveness")


class VerifiedReview(BaseSchema):
    """Verified review marker"""
    review_id: UUID
    
    is_verified: bool
    verification_method: str = Field(
        ...,
        pattern="^(booking_verified|student_verified|admin_verified|auto_verified)$"
    )
    
    verified_by: Optional[UUID] = None
    verified_at: datetime
    
    verification_details: Optional[dict] = Field(
        None,
        description="Additional verification information"
    )


class ReviewGuidelines(BaseSchema):
    """Review guidelines"""
    guidelines: List[str] = Field(
        default_factory=lambda: [
            "Be honest and fair",
            "Focus on your experience",
            "Avoid offensive language",
            "Don't include personal information",
            "Be specific and constructive",
            "Reviews are public and visible to all"
        ]
    )
    
    prohibited_content: List[str] = Field(
        default_factory=lambda: [
            "Offensive or abusive language",
            "Personal attacks",
            "Spam or promotional content",
            "Fake or fraudulent reviews",
            "Reviews for competing businesses"
        ]
    )


class ReviewEligibility(BaseSchema):
    """Check if user can review hostel"""
    user_id: UUID
    hostel_id: UUID
    
    can_review: bool
    reason: str
    
    # Details
    has_stayed: bool
    has_booking: bool
    already_reviewed: bool
    
    # If already reviewed
    existing_review_id: Optional[UUID] = None
    can_edit: bool = Field(False, description="Can edit existing review")

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_voting.py ---
"""
Review voting (helpful/not helpful) schemas
"""
from datetime import datetime
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema
from app.schemas.common.enums import VoteType


class VoteRequest(BaseCreateSchema):
    """Vote on review helpfulness"""
    review_id: UUID = Field(..., description="Review ID")
    voter_id: UUID = Field(..., description="User voting")
    
    vote_type: VoteType = Field(..., description="helpful or not_helpful")


class VoteResponse(BaseSchema):
    """Vote response"""
    review_id: UUID
    vote_type: VoteType
    
    # Updated counts
    helpful_count: int
    not_helpful_count: int
    
    message: str


class HelpfulnessScore(BaseSchema):
    """Helpfulness score for review"""
    review_id: UUID
    
    helpful_count: int
    not_helpful_count: int
    total_votes: int
    
    helpfulness_percentage: Decimal = Field(
        ...,
        description="% of voters who found it helpful"
    )
    
    helpfulness_score: Decimal = Field(
        ...,
        ge=0,
        le=1,
        description="Wilson score for ranking"
    )


class VoteHistory(BaseSchema):
    """User's voting history"""
    user_id: UUID
    
    total_votes: int
    helpful_votes: int
    not_helpful_votes: int
    
    recent_votes: List["VoteHistoryItem"] = Field(default_factory=list, max_items=10)


class VoteHistoryItem(BaseSchema):
    """Individual vote in history"""
    review_id: UUID
    hostel_name: str
    vote_type: VoteType
    voted_at: datetime


class RemoveVote(BaseCreateSchema):
    """Remove vote (change mind)"""
    review_id: UUID
    voter_id: UUID

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\__init__.py ---
"""
Review schemas package
"""
from app.schemas.review.review_base import (
    ReviewBase,
    ReviewCreate,
    ReviewUpdate
)
from app.schemas.review.review_response import (
    ReviewResponse,
    ReviewDetail,
    ReviewListItem
)
from app.schemas.review.review_submission import (
    ReviewSubmissionRequest,
    DetailedRatings,
    VerifiedReview
)
from app.schemas.review.review_moderation import (
    ModerationRequest,
    ModerationQueue,
    ApprovalWorkflow
)
from app.schemas.review.review_voting import (
    VoteRequest,
    VoteResponse,
    HelpfulnessScore
)
from app.schemas.review.review_response_schema import (
    HostelResponseCreate,
    OwnerResponse
)
from app.schemas.review.review_filters import (
    ReviewFilterParams,
    SearchRequest,
    SortOptions
)
from app.schemas.review.review_analytics import (
    ReviewAnalytics,
    RatingDistribution,
    SentimentAnalysis,
    TrendAnalysis
)

__all__ = [
    # Base
    "ReviewBase",
    "ReviewCreate",
    "ReviewUpdate",
    
    # Response
    "ReviewResponse",
    "ReviewDetail",
    "ReviewListItem",
    
    # Submission
    "ReviewSubmissionRequest",
    "DetailedRatings",
    "VerifiedReview",
    
    # Moderation
    "ModerationRequest",
    "ModerationQueue",
    "ApprovalWorkflow",
    
    # Voting
    "VoteRequest",
    "VoteResponse",
    "HelpfulnessScore",
    
    # Hostel Response
    "HostelResponseCreate",
    "OwnerResponse",
    
    # Filters
    "ReviewFilterParams",
    "SearchRequest",
    "SortOptions",
    
    # Analytics
    "ReviewAnalytics",
    "RatingDistribution",
    "SentimentAnalysis",
    "TrendAnalysis",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_analytics.py ---
# --- File: app/schemas/review/review_analytics.py ---
"""
Review analytics schemas with comprehensive metrics and trend analysis.

Provides detailed analytics, sentiment analysis, and competitive insights
for hostel reviews.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, computed_field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "ReviewAnalytics",
    "RatingDistribution",
    "TrendAnalysis",
    "MonthlyRating",
    "SentimentAnalysis",
    "AspectAnalysis",
    "CompetitorComparison",
]


class MonthlyRating(BaseSchema):
    """
    Monthly rating aggregation.
    
    Tracks average rating and review volume by month.
    """
    
    month: str = Field(
        ...,
        pattern=r"^\d{4}-\d{2}$",
        description="Month in YYYY-MM format",
        examples=["2024-01", "2024-02"],
    )
    average_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        decimal_places=2,
        description="Average rating for the month",
    )
    review_count: int = Field(
        ...,
        ge=0,
        description="Total reviews received in the month",
    )
    
    @field_validator("average_rating")
    @classmethod
    def round_to_half(cls, v: Decimal) -> Decimal:
        """Round rating to nearest 0.5."""
        return Decimal(str(round(float(v) * 2) / 2))


class RatingDistribution(BaseSchema):
    """
    Rating distribution breakdown with percentages.
    
    Provides detailed analysis of rating spread across 1-5 stars.
    """
    
    # Raw counts
    rating_5_count: int = Field(..., ge=0, description="5-star reviews count")
    rating_4_count: int = Field(..., ge=0, description="4-star reviews count")
    rating_3_count: int = Field(..., ge=0, description="3-star reviews count")
    rating_2_count: int = Field(..., ge=0, description="2-star reviews count")
    rating_1_count: int = Field(..., ge=0, description="1-star reviews count")
    
    # Percentages
    rating_5_percentage: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Percentage of 5-star reviews",
    )
    rating_4_percentage: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Percentage of 4-star reviews",
    )
    rating_3_percentage: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Percentage of 3-star reviews",
    )
    rating_2_percentage: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Percentage of 2-star reviews",
    )
    rating_1_percentage: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Percentage of 1-star reviews",
    )
    
    # Aggregated metrics
    positive_reviews: int = Field(
        ...,
        ge=0,
        description="Count of positive reviews (4-5 stars)",
    )
    neutral_reviews: int = Field(
        ...,
        ge=0,
        description="Count of neutral reviews (3 stars)",
    )
    negative_reviews: int = Field(
        ...,
        ge=0,
        description="Count of negative reviews (1-2 stars)",
    )
    
    positive_percentage: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Percentage of positive reviews",
    )
    neutral_percentage: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Percentage of neutral reviews",
    )
    negative_percentage: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Percentage of negative reviews",
    )
    
    @computed_field
    @property
    def total_reviews(self) -> int:
        """Calculate total number of reviews."""
        return (
            self.rating_5_count
            + self.rating_4_count
            + self.rating_3_count
            + self.rating_2_count
            + self.rating_1_count
        )
    
    @computed_field
    @property
    def recommendation_score(self) -> Decimal:
        """
        Calculate recommendation score.
        
        Based on ratio of positive reviews to total reviews.
        """
        if self.total_reviews == 0:
            return Decimal("0")
        return Decimal(
            str(round((self.positive_reviews / self.total_reviews) * 100, 2))
        )


class TrendAnalysis(BaseSchema):
    """
    Rating trend analysis over time.
    
    Tracks rating changes and provides directional indicators.
    """
    
    trend_direction: str = Field(
        ...,
        pattern=r"^(improving|declining|stable)$",
        description="Overall trend direction",
    )
    trend_percentage: Optional[Decimal] = Field(
        None,
        ge=Decimal("-100"),
        le=Decimal("100"),
        decimal_places=2,
        description="Percentage change in rating",
    )
    
    # Time-based ratings
    last_30_days_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        decimal_places=2,
        description="Average rating in last 30 days",
    )
    last_90_days_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        decimal_places=2,
        description="Average rating in last 90 days",
    )
    all_time_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        decimal_places=2,
        description="All-time average rating",
    )
    
    # Monthly breakdown
    monthly_ratings: List[MonthlyRating] = Field(
        default_factory=list,
        description="Monthly rating history",
    )
    
    @field_validator("trend_direction")
    @classmethod
    def normalize_trend(cls, v: str) -> str:
        """Normalize trend direction to lowercase."""
        return v.lower().strip()
    
    @classmethod
    def calculate_trend(
        cls,
        current_rating: Decimal,
        previous_rating: Decimal,
        threshold: Decimal = Decimal("0.1"),
    ) -> str:
        """
        Calculate trend direction based on rating change.
        
        Args:
            current_rating: Current period average rating
            previous_rating: Previous period average rating
            threshold: Minimum change to consider as trend
            
        Returns:
            Trend direction: improving, declining, or stable
        """
        difference = current_rating - previous_rating
        
        if abs(difference) < threshold:
            return "stable"
        return "improving" if difference > 0 else "declining"


class SentimentAnalysis(BaseSchema):
    """
    Sentiment analysis of review content.
    
    Provides AI-powered sentiment scoring and theme extraction.
    """
    
    overall_sentiment: str = Field(
        ...,
        pattern=r"^(positive|neutral|negative)$",
        description="Overall sentiment classification",
    )
    
    sentiment_score: Decimal = Field(
        ...,
        ge=Decimal("-1"),
        le=Decimal("1"),
        decimal_places=3,
        description="Sentiment score (-1 to 1, where 1 is most positive)",
    )
    
    # Distribution
    positive_count: int = Field(..., ge=0, description="Positive reviews count")
    neutral_count: int = Field(..., ge=0, description="Neutral reviews count")
    negative_count: int = Field(..., ge=0, description="Negative reviews count")
    
    # Themes and keywords
    positive_themes: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Common positive themes extracted from reviews",
        examples=[["clean", "friendly staff", "good food"]],
    )
    negative_themes: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Common complaints extracted from reviews",
        examples=[["noise", "maintenance issues"]],
    )
    
    most_mentioned_positive: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Most frequently mentioned positive keywords",
    )
    most_mentioned_negative: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Most frequently mentioned negative keywords",
    )
    
    @field_validator("overall_sentiment")
    @classmethod
    def normalize_sentiment(cls, v: str) -> str:
        """Normalize sentiment to lowercase."""
        return v.lower().strip()
    
    @computed_field
    @property
    def total_analyzed(self) -> int:
        """Total reviews analyzed for sentiment."""
        return self.positive_count + self.neutral_count + self.negative_count
    
    @computed_field
    @property
    def positive_percentage(self) -> Decimal:
        """Percentage of positive sentiment reviews."""
        if self.total_analyzed == 0:
            return Decimal("0")
        return Decimal(
            str(round((self.positive_count / self.total_analyzed) * 100, 2))
        )


class AspectAnalysis(BaseSchema):
    """
    Analysis of specific review aspects (cleanliness, food, staff, etc.).
    
    Provides granular insights into individual service aspects.
    """
    
    aspect: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Aspect name (e.g., cleanliness, food, staff)",
        examples=["cleanliness", "food_quality", "staff_behavior"],
    )
    
    average_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        decimal_places=2,
        description="Average rating for this aspect",
    )
    total_ratings: int = Field(
        ...,
        ge=0,
        description="Total number of ratings for this aspect",
    )
    
    # Rating distribution for this aspect
    rating_distribution: Dict[int, int] = Field(
        default_factory=dict,
        description="Rating value to count mapping",
        examples=[{1: 5, 2: 10, 3: 20, 4: 40, 5: 25}],
    )
    
    # Trend
    trend: str = Field(
        ...,
        pattern=r"^(improving|declining|stable)$",
        description="Trend direction for this aspect",
    )
    
    # Mentions in review text
    mention_count: int = Field(
        ...,
        ge=0,
        description="Times this aspect was mentioned in reviews",
    )
    positive_mentions: int = Field(
        ...,
        ge=0,
        description="Positive mentions count",
    )
    negative_mentions: int = Field(
        ...,
        ge=0,
        description="Negative mentions count",
    )
    
    # Sample comments
    top_positive_comments: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top positive comments about this aspect",
    )
    top_negative_comments: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top negative comments about this aspect",
    )
    
    @field_validator("rating_distribution")
    @classmethod
    def validate_rating_keys(cls, v: Dict[int, int]) -> Dict[int, int]:
        """Ensure rating distribution keys are valid (1-5)."""
        invalid_keys = [k for k in v.keys() if k < 1 or k > 5]
        if invalid_keys:
            raise ValueError(
                f"Invalid rating keys found: {invalid_keys}. "
                "Rating keys must be between 1 and 5."
            )
        return v
    
    @computed_field
    @property
    def sentiment_ratio(self) -> Decimal:
        """
        Calculate sentiment ratio for this aspect.
        
        Returns ratio of positive to total mentions.
        """
        total_mentions = self.positive_mentions + self.negative_mentions
        if total_mentions == 0:
            return Decimal("0.5")  # Neutral if no mentions
        return Decimal(
            str(round(self.positive_mentions / total_mentions, 3))
        )


class CompetitorComparison(BaseSchema):
    """
    Competitive analysis comparing hostel with nearby competitors.
    
    Provides benchmarking insights and competitive positioning.
    """
    
    hostel_id: UUID = Field(..., description="Subject hostel ID")
    hostel_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Subject hostel name",
    )
    
    # Ratings comparison
    this_hostel_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        decimal_places=2,
        description="This hostel's average rating",
    )
    competitor_average_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        decimal_places=2,
        description="Average rating of competitors in area",
    )
    
    rating_difference: Decimal = Field(
        ...,
        ge=Decimal("-4.0"),
        le=Decimal("4.0"),
        decimal_places=2,
        description="Rating difference from competitor average",
    )
    percentile_rank: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Percentile rank among competitors (0-100)",
    )
    
    # Competitive advantages and weaknesses
    competitive_advantages: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Aspects rated higher than competitors",
        examples=[["cleanliness", "staff_behavior", "security"]],
    )
    improvement_areas: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Aspects rated lower than competitors",
        examples=[["food_quality", "wifi", "amenities"]],
    )
    
    @computed_field
    @property
    def competitive_position(self) -> str:
        """
        Determine competitive position based on percentile rank.
        
        Returns:
            Position category: leader, above_average, average, or below_average
        """
        rank = float(self.percentile_rank)
        if rank >= 75:
            return "leader"
        elif rank >= 60:
            return "above_average"
        elif rank >= 40:
            return "average"
        else:
            return "below_average"
    
    @computed_field
    @property
    def is_outperforming(self) -> bool:
        """Check if hostel is outperforming competitors."""
        return self.rating_difference > Decimal("0")


class ReviewAnalytics(BaseSchema):
    """
    Comprehensive review analytics for a hostel.
    
    Aggregates all review metrics, trends, and insights.
    """
    
    hostel_id: UUID = Field(..., description="Hostel identifier")
    hostel_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Hostel name",
    )
    
    # Analysis period
    analysis_period: Optional[DateRangeFilter] = Field(
        None,
        description="Period for which analytics are calculated",
    )
    generated_at: datetime = Field(
        ...,
        description="Analytics generation timestamp",
    )
    
    # Summary metrics
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )
    average_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        decimal_places=2,
        description="Overall average rating",
    )
    
    # Detailed breakdowns
    rating_distribution: RatingDistribution = Field(
        ...,
        description="Rating distribution across 1-5 stars",
    )
    
    # Aspect ratings
    detailed_ratings_average: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Average ratings by aspect (cleanliness, food, etc.)",
        examples=[
            {
                "cleanliness": Decimal("4.5"),
                "food_quality": Decimal("4.2"),
                "staff_behavior": Decimal("4.7"),
            }
        ],
    )
    
    # Trends
    rating_trend: TrendAnalysis = Field(
        ...,
        description="Rating trend analysis over time",
    )
    
    # Sentiment
    sentiment_analysis: Optional[SentimentAnalysis] = Field(
        None,
        description="AI-powered sentiment analysis",
    )
    
    # Verification metrics
    verified_reviews_count: int = Field(
        ...,
        ge=0,
        description="Number of verified reviews",
    )
    verification_rate: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Percentage of reviews that are verified",
    )
    
    # Engagement metrics
    average_helpful_votes: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Average helpful votes per review",
    )
    response_rate: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Percentage of reviews with hostel responses",
    )
    
    @field_validator("detailed_ratings_average")
    @classmethod
    def validate_aspect_ratings(cls, v: Dict[str, Decimal]) -> Dict[str, Decimal]:
        """Validate aspect ratings are within valid range."""
        for aspect, rating in v.items():
            if not (Decimal("1.0") <= rating <= Decimal("5.0")):
                raise ValueError(
                    f"Rating for '{aspect}' must be between 1.0 and 5.0, "
                    f"got {rating}"
                )
        return v
    
    @computed_field
    @property
    def quality_score(self) -> Decimal:
        """
        Calculate overall quality score (0-100).
        
        Composite score based on rating, verification rate, and engagement.
        """
        # Base score from rating (max 70 points)
        rating_score = (float(self.average_rating) / 5.0) * 70
        
        # Verification bonus (max 15 points)
        verification_score = (float(self.verification_rate) / 100) * 15
        
        # Engagement bonus (max 15 points)
        engagement_score = min(
            (float(self.average_helpful_votes) / 10) * 15, 15
        )
        
        total = rating_score + verification_score + engagement_score
        return Decimal(str(round(total, 2)))
    
    @computed_field
    @property
    def health_indicator(self) -> str:
        """
        Overall review health indicator.
        
        Returns:
            Health status: excellent, good, fair, or poor
        """
        score = float(self.quality_score)
        if score >= 80:
            return "excellent"
        elif score >= 65:
            return "good"
        elif score >= 50:
            return "fair"
        else:
            return "poor"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_base.py ---
# --- File: app/schemas/review/review_base.py ---
"""
Base review schemas with comprehensive validation.

Provides foundation schemas for review creation and updates.
"""

from __future__ import annotations

from decimal import Decimal
from typing import List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseUpdateSchema, BaseSchema

__all__ = [
    "ReviewBase",
    "ReviewCreate",
    "ReviewUpdate",
    "DetailedRatings",
]


class DetailedRatings(BaseSchema):
    """
    Detailed aspect-based ratings for comprehensive feedback.
    
    Allows reviewers to rate specific aspects of their experience.
    """
    
    cleanliness_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Cleanliness and hygiene rating",
    )
    food_quality_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Food quality rating (if mess facility available)",
    )
    staff_behavior_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Staff courtesy and helpfulness rating",
    )
    security_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Safety and security measures rating",
    )
    value_for_money_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Value for money rating",
    )
    amenities_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Facilities and amenities quality rating",
    )
    location_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Location convenience rating",
    )
    wifi_quality_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Internet/WiFi quality rating",
    )
    maintenance_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Maintenance responsiveness rating",
    )


class ReviewBase(BaseSchema):
    """
    Base review schema with all core fields.
    
    Foundation for review creation with comprehensive validation.
    """
    
    # Identifiers
    hostel_id: UUID = Field(..., description="Hostel being reviewed")
    reviewer_id: UUID = Field(..., description="User submitting the review")
    student_id: Optional[UUID] = Field(
        None,
        description="Student profile ID (for verified stay reviews)",
    )
    booking_id: Optional[UUID] = Field(
        None,
        description="Related booking reference for verification",
    )
    
    # Overall rating
    overall_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        decimal_places=1,
        description="Overall rating (1.0 to 5.0, in 0.5 increments)",
        examples=[Decimal("4.5"), Decimal("3.0")],
    )
    
    # Review content
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Review title/headline",
        examples=["Great hostel with excellent facilities"],
    )
    review_text: str = Field(
        ...,
        min_length=50,
        max_length=5000,
        description="Detailed review text",
    )
    
    # Detailed aspect ratings (optional but encouraged)
    cleanliness_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Cleanliness rating",
    )
    food_quality_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Food quality rating",
    )
    staff_behavior_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Staff behavior rating",
    )
    security_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Security rating",
    )
    value_for_money_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Value for money rating",
    )
    amenities_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Amenities rating",
    )
    
    # Media attachments
    photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="Review photos (max 10)",
        examples=[
            [
                "https://example.com/photos/room1.jpg",
                "https://example.com/photos/facilities.jpg",
            ]
        ],
    )
    
    @field_validator("overall_rating")
    @classmethod
    def round_rating_to_half(cls, v: Decimal) -> Decimal:
        """
        Round overall rating to nearest 0.5.
        
        Ensures consistent rating increments (1.0, 1.5, 2.0, etc.).
        """
        return Decimal(str(round(float(v) * 2) / 2))
    
    @field_validator("title")
    @classmethod
    def validate_title(cls, v: str) -> str:
        """Validate and clean review title."""
        v = v.strip()
        if not v:
            raise ValueError("Review title cannot be empty")
        
        # Check for excessive capitalization (possible spam)
        if len(v) > 10 and v.isupper():
            raise ValueError(
                "Please avoid using all caps in your review title"
            )
        
        return v
    
    @field_validator("review_text")
    @classmethod
    def validate_review_text(cls, v: str) -> str:
        """Validate and clean review text."""
        v = v.strip()
        if not v:
            raise ValueError("Review text cannot be empty")
        
        # Check minimum word count (approximately 10 words)
        word_count = len(v.split())
        if word_count < 10:
            raise ValueError(
                "Please provide a more detailed review (minimum 10 words)"
            )
        
        # Check for excessive capitalization
        if len(v) > 50 and sum(1 for c in v if c.isupper()) / len(v) > 0.5:
            raise ValueError(
                "Please avoid excessive use of capital letters in your review"
            )
        
        return v
    
    @field_validator("photos")
    @classmethod
    def validate_photos(cls, v: List[HttpUrl]) -> List[HttpUrl]:
        """Validate photo URLs."""
        if len(v) > 10:
            raise ValueError("Maximum 10 photos allowed per review")
        
        # Convert to list of strings and back to ensure consistency
        return v
    
    @model_validator(mode="after")
    def validate_rating_consistency(self) -> "ReviewBase":
        """
        Validate that overall rating is consistent with detailed ratings.
        
        If detailed ratings are provided, checks that overall rating
        is reasonably aligned with the average of detailed ratings.
        """
        detailed_ratings = [
            r for r in [
                self.cleanliness_rating,
                self.food_quality_rating,
                self.staff_behavior_rating,
                self.security_rating,
                self.value_for_money_rating,
                self.amenities_rating,
            ]
            if r is not None
        ]
        
        if detailed_ratings:
            avg_detailed = sum(detailed_ratings) / len(detailed_ratings)
            overall = float(self.overall_rating)
            
            # Allow some variance (1 star)
            if abs(overall - avg_detailed) > 1.5:
                raise ValueError(
                    "Overall rating seems inconsistent with detailed ratings. "
                    "Please review your ratings."
                )
        
        return self


class ReviewCreate(ReviewBase, BaseCreateSchema):
    """
    Schema for creating a new review.
    
    Inherits all validation from ReviewBase and adds creation-specific rules.
    """
    
    # Additional fields for creation context
    would_recommend: bool = Field(
        ...,
        description="Would the reviewer recommend this hostel?",
    )
    
    stay_duration_months: Optional[int] = Field(
        None,
        ge=1,
        le=24,
        description="Duration of stay in months (helps with verification)",
    )
    
    @model_validator(mode="after")
    def validate_recommendation_consistency(self) -> "ReviewCreate":
        """
        Validate recommendation aligns with rating.
        
        Warns if low-rated review has recommendation or vice versa.
        """
        rating = float(self.overall_rating)
        
        # High rating (4+) but not recommending seems inconsistent
        if rating >= 4.0 and not self.would_recommend:
            # This is allowed but logged for review
            pass
        
        # Low rating (<3) but recommending seems inconsistent
        if rating < 3.0 and self.would_recommend:
            # This is allowed but logged for review
            pass
        
        return self


class ReviewUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing review.
    
    Allows partial updates with time-limited edit window.
    All fields are optional to support partial updates.
    """
    
    # Content updates
    title: Optional[str] = Field(
        None,
        min_length=5,
        max_length=255,
        description="Updated review title",
    )
    review_text: Optional[str] = Field(
        None,
        min_length=50,
        max_length=5000,
        description="Updated review text",
    )
    
    # Rating updates
    overall_rating: Optional[Decimal] = Field(
        None,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        decimal_places=1,
        description="Updated overall rating",
    )
    
    # Detailed ratings updates
    cleanliness_rating: Optional[int] = Field(None, ge=1, le=5)
    food_quality_rating: Optional[int] = Field(None, ge=1, le=5)
    staff_behavior_rating: Optional[int] = Field(None, ge=1, le=5)
    security_rating: Optional[int] = Field(None, ge=1, le=5)
    value_for_money_rating: Optional[int] = Field(None, ge=1, le=5)
    amenities_rating: Optional[int] = Field(None, ge=1, le=5)
    
    # Media updates
    photos: Optional[List[HttpUrl]] = Field(
        None,
        max_length=10,
        description="Updated photo list",
    )
    
    @field_validator("overall_rating")
    @classmethod
    def round_rating_to_half(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round overall rating to nearest 0.5."""
        if v is None:
            return v
        return Decimal(str(round(float(v) * 2) / 2))
    
    @field_validator("title")
    @classmethod
    def validate_title(cls, v: Optional[str]) -> Optional[str]:
        """Validate updated title."""
        if v is None:
            return v
        
        v = v.strip()
        if not v:
            raise ValueError("Review title cannot be empty")
        
        if len(v) > 10 and v.isupper():
            raise ValueError(
                "Please avoid using all caps in your review title"
            )
        
        return v
    
    @field_validator("review_text")
    @classmethod
    def validate_review_text(cls, v: Optional[str]) -> Optional[str]:
        """Validate updated review text."""
        if v is None:
            return v
        
        v = v.strip()
        if not v:
            raise ValueError("Review text cannot be empty")
        
        word_count = len(v.split())
        if word_count < 10:
            raise ValueError(
                "Please provide a more detailed review (minimum 10 words)"
            )
        
        return v
    
    @field_validator("photos")
    @classmethod
    def validate_photos(cls, v: Optional[List[HttpUrl]]) -> Optional[List[HttpUrl]]:
        """Validate updated photos."""
        if v is None:
            return v
        
        if len(v) > 10:
            raise ValueError("Maximum 10 photos allowed per review")
        
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_filters.py ---
# --- File: app/schemas/review/review_filters.py ---
"""
Review filter and search schemas with advanced filtering options.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator
from uuid import UUID

from app.schemas.common.base import BaseFilterSchema

__all__ = [
    "ReviewFilterParams",
    "ReviewSearchRequest",
    "ReviewSortOptions",
    "ReviewExportRequest",
]


class ReviewFilterParams(BaseFilterSchema):
    """
    Comprehensive review filtering parameters.
    
    Supports filtering by hostel, ratings, verification, dates, and more.
    """
    
    # Hostel filters
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by specific hostel",
    )
    hostel_ids: Optional[List[UUID]] = Field(
        None,
        max_length=50,
        description="Filter by multiple hostels (max 50)",
    )
    
    # Rating filters
    min_rating: Optional[Decimal] = Field(
        None,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        description="Minimum overall rating",
    )
    max_rating: Optional[Decimal] = Field(
        None,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        description="Maximum overall rating",
    )
    rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Exact rating (1-5 stars)",
    )
    
    # Verification filters
    verified_only: Optional[bool] = Field(
        None,
        description="Show only verified stay reviews",
    )
    
    # Date filters
    posted_date_from: Optional[date] = Field(
        None,
        description="Reviews posted on or after this date",
    )
    posted_date_to: Optional[date] = Field(
        None,
        description="Reviews posted on or before this date",
    )
    
    # Status filters
    approved_only: bool = Field(
        True,
        description="Show only approved/published reviews",
    )
    flagged_only: Optional[bool] = Field(
        None,
        description="Show only flagged reviews",
    )
    
    # Response filter
    with_hostel_response: Optional[bool] = Field(
        None,
        description="Filter by presence of hostel response",
    )
    
    # Engagement filters
    min_helpful_count: Optional[int] = Field(
        None,
        ge=0,
        description="Minimum helpful vote count",
    )
    
    # Media filter
    with_photos_only: Optional[bool] = Field(
        None,
        description="Show only reviews with photos",
    )
    
    @field_validator("hostel_ids")
    @classmethod
    def validate_hostel_ids(cls, v: Optional[List[UUID]]) -> Optional[List[UUID]]:
        """Validate hostel IDs list."""
        if v is not None and len(v) > 50:
            raise ValueError("Maximum 50 hostel IDs allowed")
        return v
    
    @field_validator("max_rating")
    @classmethod
    def validate_rating_range(cls, v: Optional[Decimal], info) -> Optional[Decimal]:
        """Validate that max_rating >= min_rating."""
        min_rating = info.data.get("min_rating")
        if v is not None and min_rating is not None and v < min_rating:
            raise ValueError("max_rating must be greater than or equal to min_rating")
        return v
    
    @field_validator("posted_date_to")
    @classmethod
    def validate_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate that posted_date_to >= posted_date_from."""
        posted_date_from = info.data.get("posted_date_from")
        if v is not None and posted_date_from is not None and v < posted_date_from:
            raise ValueError(
                "posted_date_to must be on or after posted_date_from"
            )
        return v


class ReviewSearchRequest(BaseFilterSchema):
    """
    Full-text search request for reviews.
    
    Supports searching in titles and content with advanced options.
    """
    
    query: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Search query",
        examples=["clean rooms", "friendly staff"],
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Limit search to specific hostel",
    )
    
    # Search scope
    search_in_title: bool = Field(
        True,
        description="Include review titles in search",
    )
    search_in_content: bool = Field(
        True,
        description="Include review text in search",
    )
    
    # Additional filters
    min_rating: Optional[Decimal] = Field(
        None,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        description="Filter by minimum rating",
    )
    verified_only: Optional[bool] = Field(
        None,
        description="Show only verified reviews",
    )
    
    # Pagination
    page: int = Field(
        1,
        ge=1,
        description="Page number",
    )
    page_size: int = Field(
        20,
        ge=1,
        le=100,
        description="Results per page",
    )
    
    @field_validator("query")
    @classmethod
    def validate_query(cls, v: str) -> str:
        """Validate and clean search query."""
        v = v.strip()
        if not v:
            raise ValueError("Search query cannot be empty")
        return v
    
    @model_validator(mode="after")
    def validate_search_scope(self) -> "ReviewSearchRequest":
        """Ensure at least one search scope is selected."""
        if not self.search_in_title and not self.search_in_content:
            raise ValueError(
                "At least one search scope must be enabled "
                "(title or content)"
            )
        return self


class ReviewSortOptions(BaseFilterSchema):
    """
    Review sorting options with multiple strategies.
    
    Supports various sorting methods including helpful votes and recency.
    """
    
    sort_by: str = Field(
        "helpful",
        pattern=r"^(helpful|recent|rating_high|rating_low|verified|oldest)$",
        description="Sort method",
    )
    
    # Priority options
    verified_first: bool = Field(
        True,
        description="Prioritize verified reviews in results",
    )
    with_photos_first: bool = Field(
        False,
        description="Prioritize reviews with photos",
    )
    with_response_first: bool = Field(
        False,
        description="Prioritize reviews with hostel responses",
    )
    
    @field_validator("sort_by")
    @classmethod
    def normalize_sort_by(cls, v: str) -> str:
        """Normalize sort_by value to lowercase."""
        return v.lower().strip()


class ReviewExportRequest(BaseFilterSchema):
    """
    Export reviews to various formats.
    
    Supports CSV, Excel, and PDF exports with customizable content.
    """
    
    hostel_id: UUID = Field(
        ...,
        description="Hostel to export reviews for",
    )
    filters: Optional[ReviewFilterParams] = Field(
        None,
        description="Additional filters to apply",
    )
    
    # Export format
    format: str = Field(
        "csv",
        pattern=r"^(csv|excel|pdf|json)$",
        description="Export format",
    )
    
    # Content options
    include_detailed_ratings: bool = Field(
        True,
        description="Include aspect-specific ratings",
    )
    include_hostel_responses: bool = Field(
        True,
        description="Include hostel responses to reviews",
    )
    include_voter_stats: bool = Field(
        False,
        description="Include helpful vote statistics",
    )
    include_reviewer_info: bool = Field(
        True,
        description="Include reviewer name and verification status",
    )
    
    # Date range for export
    date_from: Optional[date] = Field(
        None,
        description="Export reviews from this date onwards",
    )
    date_to: Optional[date] = Field(
        None,
        description="Export reviews up to this date",
    )
    
    @field_validator("format")
    @classmethod
    def normalize_format(cls, v: str) -> str:
        """Normalize format to lowercase."""
        return v.lower().strip()
    
    @field_validator("date_to")
    @classmethod
    def validate_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate export date range."""
        date_from = info.data.get("date_from")
        if v is not None and date_from is not None and v < date_from:
            raise ValueError("date_to must be on or after date_from")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_moderation.py ---
# --- File: app/schemas/review/review_moderation.py ---
"""
Review moderation and approval workflow schemas.

Handles review moderation queue, approval/rejection, and flagging.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema

__all__ = [
    "ModerationRequest",
    "ModerationResponse",
    "ModerationQueue",
    "PendingReview",
    "ApprovalWorkflow",
    "BulkModeration",
    "ModerationStats",
    "FlagReview",
]


class ModerationRequest(BaseCreateSchema):
    """
    Review moderation action request.
    
    Supports approval, rejection, and flagging of reviews.
    """
    
    review_id: UUID = Field(..., description="Review to moderate")
    
    action: str = Field(
        ...,
        pattern=r"^(approve|reject|flag|unflag|hold)$",
        description="Moderation action to take",
    )
    
    # Rejection details
    rejection_reason: Optional[str] = Field(
        None,
        min_length=20,
        max_length=500,
        description="Reason for rejection (required if action=reject)",
    )
    
    # Flagging details
    flag_reason: Optional[str] = Field(
        None,
        pattern=r"^(inappropriate|spam|fake|offensive|profanity|other)$",
        description="Reason for flagging (required if action=flag)",
    )
    flag_details: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional flagging details",
    )
    
    # Internal notes
    moderator_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Internal moderator notes (not visible to reviewer)",
    )
    
    # Notification control
    notify_reviewer: bool = Field(
        True,
        description="Send notification to reviewer about moderation action",
    )
    
    @field_validator("action")
    @classmethod
    def normalize_action(cls, v: str) -> str:
        """Normalize action to lowercase."""
        return v.lower().strip()
    
    @model_validator(mode="after")
    def validate_action_requirements(self) -> "ModerationRequest":
        """Validate that required fields are provided for specific actions."""
        if self.action == "reject" and not self.rejection_reason:
            raise ValueError(
                "rejection_reason is required when action is 'reject'"
            )
        
        if self.action == "flag" and not self.flag_reason:
            raise ValueError(
                "flag_reason is required when action is 'flag'"
            )
        
        return self


class FlagReview(BaseCreateSchema):
    """
    User-initiated review flagging.
    
    Allows users to report inappropriate or problematic reviews.
    """
    
    review_id: UUID = Field(..., description="Review to flag")
    reporter_id: UUID = Field(..., description="User reporting the review")
    
    flag_reason: str = Field(
        ...,
        pattern=r"^(inappropriate|spam|fake|offensive|profanity|not_relevant|other)$",
        description="Reason for flagging",
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Detailed description of the issue",
    )
    
    @field_validator("flag_reason")
    @classmethod
    def normalize_flag_reason(cls, v: str) -> str:
        """Normalize flag reason to lowercase."""
        return v.lower().strip()


class ModerationResponse(BaseSchema):
    """Response after moderation action."""
    
    review_id: UUID = Field(..., description="Moderated review ID")
    
    action_taken: str = Field(
        ...,
        description="Action that was performed",
    )
    moderated_by: UUID = Field(..., description="Moderator user ID")
    moderated_by_name: str = Field(..., description="Moderator name")
    moderated_at: datetime = Field(..., description="Moderation timestamp")
    
    # Notification status
    reviewer_notified: bool = Field(
        ...,
        description="Whether reviewer was notified",
    )
    
    message: str = Field(
        ...,
        description="Result message",
        examples=["Review approved successfully"],
    )


class PendingReview(BaseSchema):
    """
    Review pending moderation.
    
    Represents a review in the moderation queue.
    """
    
    review_id: UUID = Field(..., description="Review ID")
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Reviewer info
    reviewer_id: UUID = Field(..., description="Reviewer ID")
    reviewer_name: str = Field(..., description="Reviewer name")
    overall_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        description="Overall rating",
    )
    
    # Content preview
    title: str = Field(..., description="Review title")
    review_excerpt: str = Field(
        ...,
        max_length=200,
        description="Review text excerpt (first 200 chars)",
    )
    
    # Verification
    is_verified_stay: bool = Field(
        ...,
        description="Whether stay is verified",
    )
    
    # Flags and issues
    is_flagged: bool = Field(..., description="Whether review is flagged")
    flag_count: int = Field(
        ...,
        ge=0,
        description="Number of times review has been flagged",
    )
    flag_reasons: List[str] = Field(
        default_factory=list,
        description="Reasons for flagging",
    )
    
    # Timestamps
    submitted_at: datetime = Field(..., description="Review submission time")
    
    # AI moderation scores
    spam_score: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        le=Decimal("1"),
        description="AI spam detection score (0-1, higher = more likely spam)",
    )
    sentiment_score: Optional[Decimal] = Field(
        None,
        ge=Decimal("-1"),
        le=Decimal("1"),
        description="Sentiment analysis score (-1 to 1)",
    )
    toxicity_score: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        le=Decimal("1"),
        description="Content toxicity score (0-1, higher = more toxic)",
    )
    
    # Priority indicators
    requires_immediate_attention: bool = Field(
        default=False,
        description="Whether review needs urgent moderation",
    )


class ModerationQueue(BaseSchema):
    """
    Moderation queue overview.
    
    Summary of reviews pending moderation.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by specific hostel (None = all hostels)",
    )
    
    # Queue statistics
    total_pending: int = Field(..., ge=0, description="Total pending reviews")
    flagged_reviews: int = Field(..., ge=0, description="Flagged reviews count")
    auto_approved: int = Field(..., ge=0, description="Auto-approved count")
    high_priority: int = Field(
        ...,
        ge=0,
        description="High priority items needing attention",
    )
    
    # Reviews in queue
    pending_reviews: List[PendingReview] = Field(
        default_factory=list,
        description="List of pending reviews",
    )
    
    # Queue health
    average_wait_time_hours: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        description="Average time reviews spend in queue",
    )
    oldest_review_age_hours: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        description="Age of oldest pending review",
    )


class ApprovalWorkflow(BaseSchema):
    """
    Review approval workflow status.
    
    Tracks the complete moderation lifecycle of a review.
    """
    
    review_id: UUID = Field(..., description="Review ID")
    
    # Workflow status
    requires_moderation: bool = Field(
        ...,
        description="Whether review requires manual moderation",
    )
    moderation_status: str = Field(
        ...,
        pattern=r"^(pending|approved|rejected|flagged|on_hold)$",
        description="Current moderation status",
    )
    
    # Timeline
    submitted_at: datetime = Field(..., description="Submission timestamp")
    moderated_at: Optional[datetime] = Field(
        None,
        description="Moderation completion timestamp",
    )
    published_at: Optional[datetime] = Field(
        None,
        description="Publication timestamp (if approved)",
    )
    
    # Moderator info
    moderated_by: Optional[UUID] = Field(None, description="Moderator user ID")
    moderated_by_name: Optional[str] = Field(None, description="Moderator name")
    
    # Rejection/flagging details
    rejection_reason: Optional[str] = Field(
        None,
        description="Reason for rejection",
    )
    flag_reasons: List[str] = Field(
        default_factory=list,
        description="List of flag reasons",
    )
    
    # Auto-moderation
    auto_moderation_score: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        le=Decimal("1"),
        description="Automated moderation confidence score",
    )
    auto_approved: bool = Field(
        default=False,
        description="Whether review was auto-approved",
    )


class BulkModeration(BaseCreateSchema):
    """
    Bulk moderation of multiple reviews.
    
    Allows moderators to process multiple reviews at once.
    """
    
    review_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Reviews to moderate (max 50)",
    )
    
    action: str = Field(
        ...,
        pattern=r"^(approve|reject|flag)$",
        description="Action to apply to all reviews",
    )
    
    # Common reason/notes
    reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Common reason for all reviews",
    )
    
    notify_reviewers: bool = Field(
        True,
        description="Send notifications to all affected reviewers",
    )
    
    @field_validator("review_ids")
    @classmethod
    def validate_review_ids(cls, v: List[UUID]) -> List[UUID]:
        """Validate review IDs list."""
        if len(v) > 50:
            raise ValueError("Maximum 50 reviews can be moderated at once")
        
        # Remove duplicates
        unique_ids = list(set(v))
        if len(unique_ids) != len(v):
            raise ValueError("Duplicate review IDs found")
        
        return v
    
    @field_validator("action")
    @classmethod
    def normalize_action(cls, v: str) -> str:
        """Normalize action to lowercase."""
        return v.lower().strip()


class ModerationStats(BaseSchema):
    """
    Moderation statistics and metrics.
    
    Provides insights into moderation performance and volume.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel filter (None = all hostels)",
    )
    period_start: date = Field(..., description="Statistics period start")
    period_end: date = Field(..., description="Statistics period end")
    
    # Volume metrics
    total_reviews: int = Field(..., ge=0, description="Total reviews received")
    auto_approved: int = Field(..., ge=0, description="Auto-approved count")
    manually_approved: int = Field(
        ...,
        ge=0,
        description="Manually approved count",
    )
    rejected: int = Field(..., ge=0, description="Rejected count")
    flagged: int = Field(..., ge=0, description="Flagged count")
    
    # Performance metrics
    average_moderation_time_hours: Decimal = Field(
        ...,
        ge=Decimal("0"),
        description="Average time to moderate (in hours)",
    )
    median_moderation_time_hours: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        description="Median moderation time",
    )
    
    # By moderator
    moderations_by_user: Dict[str, int] = Field(
        default_factory=dict,
        description="Moderator ID/name to moderation count mapping",
    )
    
    # Quality metrics
    approval_rate: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        description="Percentage of reviews approved",
    )
    rejection_rate: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        description="Percentage of reviews rejected",
    )
    auto_approval_accuracy: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        le=Decimal("100"),
        description="Accuracy of auto-approval system",
    )
    
    @field_validator("period_end")
    @classmethod
    def validate_period(cls, v: date, info) -> date:
        """Validate period end is after start."""
        period_start = info.data.get("period_start")
        if period_start and v < period_start:
            raise ValueError("period_end must be on or after period_start")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_response.py ---
# --- File: app/schemas/review/review_response.py ---
"""
Review response schemas for API responses.

Provides comprehensive response formats for reviews.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema

__all__ = [
    "ReviewResponse",
    "ReviewDetail",
    "ReviewListItem",
    "ReviewSummary",
    "HostelResponseDetail",
]


class HostelResponseDetail(BaseSchema):
    """
    Hostel's response to a review.
    
    Represents management's reply to customer feedback.
    """
    
    response_id: UUID = Field(..., description="Response ID")
    response_text: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Response text from hostel management",
    )
    responded_by: UUID = Field(..., description="User who responded")
    responded_by_name: str = Field(..., description="Responder's name")
    responded_by_role: str = Field(
        ...,
        description="Responder's role (admin, owner, manager)",
    )
    responded_at: datetime = Field(..., description="Response timestamp")
    
    # Metadata
    is_edited: bool = Field(
        default=False,
        description="Whether response has been edited",
    )
    edited_at: Optional[datetime] = Field(
        None,
        description="Last edit timestamp",
    )


class ReviewResponse(BaseResponseSchema):
    """
    Basic review response.
    
    Minimal review information for list views.
    """
    
    # Hostel info
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Reviewer info
    reviewer_id: UUID = Field(..., description="Reviewer user ID")
    reviewer_name: str = Field(..., description="Reviewer display name")
    
    # Review content
    overall_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        description="Overall rating",
    )
    title: str = Field(..., description="Review title")
    review_text: str = Field(..., description="Review text")
    
    # Verification
    is_verified_stay: bool = Field(
        ...,
        description="Whether stay is verified",
    )
    verified_at: Optional[datetime] = Field(
        None,
        description="Verification timestamp",
    )
    
    # Status
    is_approved: bool = Field(..., description="Approval status")
    
    # Engagement
    helpful_count: int = Field(..., ge=0, description="Helpful votes count")
    not_helpful_count: int = Field(..., ge=0, description="Not helpful votes")
    
    # Timestamps
    created_at: datetime = Field(..., description="Creation timestamp")
    
    @computed_field
    @property
    def helpfulness_ratio(self) -> Decimal:
        """Calculate helpfulness ratio."""
        total_votes = self.helpful_count + self.not_helpful_count
        if total_votes == 0:
            return Decimal("0.5")  # Neutral
        return Decimal(str(round(self.helpful_count / total_votes, 3)))


class ReviewDetail(BaseResponseSchema):
    """
    Detailed review information.
    
    Complete review data including all ratings, media, and metadata.
    """
    
    # Hostel info
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Reviewer info
    reviewer_id: UUID = Field(..., description="Reviewer ID")
    reviewer_name: str = Field(..., description="Reviewer name")
    reviewer_profile_image: Optional[str] = Field(
        None,
        description="Reviewer profile image URL",
    )
    
    # References
    student_id: Optional[UUID] = Field(None, description="Student profile ID")
    booking_id: Optional[UUID] = Field(None, description="Related booking ID")
    
    # Ratings
    overall_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        description="Overall rating",
    )
    cleanliness_rating: Optional[int] = Field(None, ge=1, le=5)
    food_quality_rating: Optional[int] = Field(None, ge=1, le=5)
    staff_behavior_rating: Optional[int] = Field(None, ge=1, le=5)
    security_rating: Optional[int] = Field(None, ge=1, le=5)
    value_for_money_rating: Optional[int] = Field(None, ge=1, le=5)
    amenities_rating: Optional[int] = Field(None, ge=1, le=5)
    location_rating: Optional[int] = Field(None, ge=1, le=5)
    wifi_quality_rating: Optional[int] = Field(None, ge=1, le=5)
    
    # Content
    title: str = Field(..., description="Review title")
    review_text: str = Field(..., description="Full review text")
    
    # Media
    photos: List[str] = Field(
        default_factory=list,
        description="Review photo URLs",
    )
    
    # Verification
    is_verified_stay: bool = Field(..., description="Verification status")
    verified_at: Optional[datetime] = Field(None, description="Verification time")
    verification_method: Optional[str] = Field(
        None,
        description="How the stay was verified",
    )
    
    # Moderation
    is_approved: bool = Field(..., description="Approval status")
    approved_by: Optional[UUID] = Field(None, description="Approver ID")
    approved_at: Optional[datetime] = Field(None, description="Approval time")
    
    is_flagged: bool = Field(default=False, description="Flagged status")
    flag_reason: Optional[str] = Field(None, description="Flag reason")
    flagged_by: Optional[UUID] = Field(None, description="Flagger ID")
    flagged_at: Optional[datetime] = Field(None, description="Flag time")
    
    # Engagement
    helpful_count: int = Field(..., ge=0, description="Helpful votes")
    not_helpful_count: int = Field(..., ge=0, description="Not helpful votes")
    report_count: int = Field(..., ge=0, description="Report count")
    
    # Hostel response
    hostel_response: Optional[HostelResponseDetail] = Field(
        None,
        description="Hostel's response to this review",
    )
    
    # Timestamps
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    
    # Visibility
    is_published: bool = Field(..., description="Publication status")
    
    # Additional metadata
    would_recommend: Optional[bool] = Field(
        None,
        description="Whether reviewer recommends the hostel",
    )
    stay_duration_months: Optional[int] = Field(
        None,
        ge=1,
        le=24,
        description="Duration of stay",
    )
    
    @computed_field
    @property
    def total_votes(self) -> int:
        """Total votes on this review."""
        return self.helpful_count + self.not_helpful_count
    
    @computed_field
    @property
    def average_detailed_rating(self) -> Optional[Decimal]:
        """Calculate average of detailed ratings."""
        ratings = [
            r for r in [
                self.cleanliness_rating,
                self.food_quality_rating,
                self.staff_behavior_rating,
                self.security_rating,
                self.value_for_money_rating,
                self.amenities_rating,
                self.location_rating,
                self.wifi_quality_rating,
            ]
            if r is not None
        ]
        
        if not ratings:
            return None
        
        return Decimal(str(round(sum(ratings) / len(ratings), 2)))


class ReviewListItem(BaseSchema):
    """
    Review list item for paginated lists.
    
    Optimized for list views with essential information only.
    """
    
    id: UUID = Field(..., description="Review ID")
    reviewer_name: str = Field(..., description="Reviewer name")
    reviewer_image: Optional[str] = Field(None, description="Profile image URL")
    
    overall_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        description="Overall rating",
    )
    title: str = Field(..., description="Review title")
    review_excerpt: str = Field(
        ...,
        max_length=150,
        description="Review text excerpt (first 150 chars)",
    )
    
    is_verified_stay: bool = Field(..., description="Verification status")
    helpful_count: int = Field(..., ge=0, description="Helpful votes")
    
    has_photos: bool = Field(..., description="Has photos attached")
    photo_count: int = Field(..., ge=0, description="Number of photos")
    
    created_at: datetime = Field(..., description="Creation timestamp")
    
    has_hostel_response: bool = Field(
        ...,
        description="Whether hostel has responded",
    )
    
    @computed_field
    @property
    def days_ago(self) -> int:
        """Days since review was posted."""
        delta = datetime.utcnow() - self.created_at
        return delta.days


class ReviewSummary(BaseSchema):
    """
    Review summary for a hostel.
    
    Aggregated review statistics and recent reviews.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Aggregate metrics
    total_reviews: int = Field(..., ge=0, description="Total reviews count")
    average_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        description="Average overall rating",
    )
    
    # Rating distribution
    rating_5_count: int = Field(..., ge=0)
    rating_4_count: int = Field(..., ge=0)
    rating_3_count: int = Field(..., ge=0)
    rating_2_count: int = Field(..., ge=0)
    rating_1_count: int = Field(..., ge=0)
    
    # Verified reviews
    verified_reviews_count: int = Field(..., ge=0)
    verified_reviews_percentage: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        description="Percentage of verified reviews",
    )
    
    # Average detailed ratings
    average_cleanliness: Optional[Decimal] = Field(None, ge=Decimal("1"), le=Decimal("5"))
    average_food_quality: Optional[Decimal] = Field(None, ge=Decimal("1"), le=Decimal("5"))
    average_staff_behavior: Optional[Decimal] = Field(None, ge=Decimal("1"), le=Decimal("5"))
    average_security: Optional[Decimal] = Field(None, ge=Decimal("1"), le=Decimal("5"))
    average_value_for_money: Optional[Decimal] = Field(None, ge=Decimal("1"), le=Decimal("5"))
    average_amenities: Optional[Decimal] = Field(None, ge=Decimal("1"), le=Decimal("5"))
    
    # Recent reviews
    recent_reviews: List[ReviewListItem] = Field(
        default_factory=list,
        max_length=5,
        description="5 most recent reviews",
    )
    
    # Recommendation metric
    would_recommend_percentage: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        description="Percentage of reviewers who would recommend",
    )
    
    @computed_field
    @property
    def positive_review_percentage(self) -> Decimal:
        """Percentage of 4-5 star reviews."""
        if self.total_reviews == 0:
            return Decimal("0")
        
        positive = self.rating_5_count + self.rating_4_count
        return Decimal(str(round((positive / self.total_reviews) * 100, 2)))
    
    @computed_field
    @property
    def rating_quality_score(self) -> str:
        """
        Qualitative rating description.
        
        Returns: excellent, very_good, good, average, or poor
        """
        rating = float(self.average_rating)
        if rating >= 4.5:
            return "excellent"
        elif rating >= 4.0:
            return "very_good"
        elif rating >= 3.5:
            return "good"
        elif rating >= 3.0:
            return "average"
        else:
            return "poor"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_response_schema.py ---
# --- File: app/schemas/review/review_response_schema.py ---
"""
Hostel response to review schemas.

Handles hostel management responses to customer reviews.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, computed_field
from uuid import UUID

from app.schemas.common.base import (
    BaseSchema,
    BaseCreateSchema,
    BaseUpdateSchema,
    BaseResponseSchema,
)

__all__ = [
    "HostelResponseCreate",
    "HostelResponseUpdate",
    "OwnerResponse",
    "ResponseGuidelines",
    "ResponseStats",
    "ResponseTemplate",
]


class HostelResponseCreate(BaseCreateSchema):
    """
    Create hostel response to a review.
    
    Allows hostel management to respond to customer feedback.
    """
    
    review_id: UUID = Field(
        ...,
        description="Review being responded to",
    )
    
    response_text: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Response text from hostel management",
        examples=[
            "Thank you for your feedback. We appreciate your kind words "
            "about our staff and facilities. We are always striving to "
            "improve and provide the best experience for our residents."
        ],
    )
    
    responded_by: UUID = Field(
        ...,
        description="Admin/owner user ID who is responding",
    )
    
    # Optional template reference
    template_id: Optional[UUID] = Field(
        None,
        description="Response template used (if any)",
    )
    
    @field_validator("response_text")
    @classmethod
    def validate_response_text(cls, v: str) -> str:
        """Validate and clean response text."""
        v = v.strip()
        if not v:
            raise ValueError("Response text cannot be empty")
        
        # Minimum word count (approximately 5 words)
        word_count = len(v.split())
        if word_count < 5:
            raise ValueError(
                "Response should be more detailed (minimum 5 words)"
            )
        
        # Check for placeholder text
        placeholder_phrases = [
            "lorem ipsum",
            "test response",
            "[insert",
            "placeholder",
        ]
        lower_text = v.lower()
        for phrase in placeholder_phrases:
            if phrase in lower_text:
                raise ValueError(
                    f"Response appears to contain placeholder text: '{phrase}'"
                )
        
        return v


class HostelResponseUpdate(BaseUpdateSchema):
    """
    Update existing hostel response.
    
    Allows editing of response with edit history tracking.
    """
    
    response_id: UUID = Field(..., description="Response to update")
    
    response_text: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Updated response text",
    )
    
    edit_reason: Optional[str] = Field(
        None,
        max_length=255,
        description="Reason for editing the response",
    )
    
    @field_validator("response_text")
    @classmethod
    def validate_response_text(cls, v: str) -> str:
        """Validate and clean response text."""
        v = v.strip()
        if not v:
            raise ValueError("Response text cannot be empty")
        
        word_count = len(v.split())
        if word_count < 5:
            raise ValueError(
                "Response should be more detailed (minimum 5 words)"
            )
        
        return v


class OwnerResponse(BaseResponseSchema):
    """
    Owner/hostel response to review.
    
    Complete response information for display.
    """
    
    review_id: UUID = Field(..., description="Associated review ID")
    
    response_text: str = Field(..., description="Response text")
    
    # Responder info
    responded_by: UUID = Field(..., description="Responder user ID")
    responded_by_name: str = Field(..., description="Responder name")
    responded_by_role: str = Field(
        ...,
        description="Responder role in hostel",
        examples=["hostel_admin", "owner", "manager"],
    )
    responded_by_image: Optional[str] = Field(
        None,
        description="Responder profile image URL",
    )
    
    responded_at: datetime = Field(..., description="Response timestamp")
    
    # Edit tracking
    is_edited: bool = Field(default=False, description="Whether edited")
    edited_at: Optional[datetime] = Field(None, description="Last edit time")
    edit_count: int = Field(default=0, ge=0, description="Number of edits")
    
    @computed_field
    @property
    def response_age_days(self) -> int:
        """Days since response was posted."""
        delta = datetime.utcnow() - self.responded_at
        return delta.days


class ResponseGuidelines(BaseSchema):
    """
    Guidelines for hostel responses to reviews.
    
    Helps hostel staff craft professional and effective responses.
    """
    
    guidelines: List[str] = Field(
        default_factory=lambda: [
            "Thank the reviewer for their feedback",
            "Address specific concerns mentioned in the review",
            "Be professional and courteous at all times",
            "Explain any misunderstandings clearly and factually",
            "Mention improvements made based on feedback",
            "Invite them to connect directly for unresolved issues",
            "Keep the response focused and relevant",
            "Avoid making excuses or being defensive",
        ],
        description="Response guidelines for hostel staff",
    )
    
    best_practices: List[str] = Field(
        default_factory=lambda: [
            "Respond within 24-48 hours of review posting",
            "Personalize your response with reviewer's name if appropriate",
            "Acknowledge both positive and negative points raised",
            "Never be defensive or argumentative",
            "Keep responses concise (100-300 words ideal)",
            "Use professional and friendly tone",
            "Proofread before publishing",
            "Follow up on promised actions",
        ],
        description="Best practices for responding to reviews",
    )
    
    response_templates_available: bool = Field(
        default=True,
        description="Whether pre-approved templates are available",
    )
    
    # Character limits
    min_length: int = Field(default=20, description="Minimum response length")
    max_length: int = Field(default=2000, description="Maximum response length")
    recommended_length: int = Field(
        default=200,
        description="Recommended response length",
    )


class ResponseStats(BaseSchema):
    """
    Hostel response statistics.
    
    Tracks response rate and performance metrics.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Volume metrics
    total_reviews: int = Field(..., ge=0, description="Total reviews received")
    total_responses: int = Field(..., ge=0, description="Total responses given")
    
    # Rate metrics
    response_rate: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        description="Percentage of reviews with responses",
    )
    
    # Timing metrics
    average_response_time_hours: Decimal = Field(
        ...,
        ge=Decimal("0"),
        description="Average time to respond in hours",
    )
    median_response_time_hours: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        description="Median time to respond",
    )
    
    # Response by rating
    response_rate_5_star: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        description="Response rate for 5-star reviews",
    )
    response_rate_4_star: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        description="Response rate for 4-star reviews",
    )
    response_rate_3_star: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        description="Response rate for 3-star reviews",
    )
    response_rate_2_star: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        description="Response rate for 2-star reviews",
    )
    response_rate_1_star: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        description="Response rate for 1-star reviews",
    )
    
    # Response quality
    average_response_length: int = Field(
        ...,
        ge=0,
        description="Average response length in characters",
    )
    
    # Pending responses
    pending_responses: int = Field(
        ...,
        ge=0,
        description="Reviews awaiting response",
    )
    oldest_unanswered_days: Optional[int] = Field(
        None,
        ge=0,
        description="Age of oldest unanswered review in days",
    )
    
    @computed_field
    @property
    def negative_review_response_rate(self) -> Decimal:
        """Response rate for negative reviews (1-2 stars)."""
        # Calculate weighted average if counts are known
        # For now, return average of 1 and 2 star rates
        rate_1 = float(self.response_rate_1_star)
        rate_2 = float(self.response_rate_2_star)
        return Decimal(str(round((rate_1 + rate_2) / 2, 2)))
    
    @computed_field
    @property
    def response_health(self) -> str:
        """
        Evaluate response health.
        
        Returns: excellent, good, needs_improvement, or poor
        """
        rate = float(self.response_rate)
        time_hours = float(self.average_response_time_hours)
        
        if rate >= 90 and time_hours <= 24:
            return "excellent"
        elif rate >= 70 and time_hours <= 48:
            return "good"
        elif rate >= 50:
            return "needs_improvement"
        else:
            return "poor"


class ResponseTemplate(BaseSchema):
    """
    Pre-approved response template.
    
    Helps staff respond quickly while maintaining quality.
    """
    
    template_id: UUID = Field(..., description="Template ID")
    name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Template name",
        examples=["Positive Review Thank You", "Negative Review Apology"],
    )
    
    category: str = Field(
        ...,
        pattern=r"^(positive|negative|neutral|specific_issue)$",
        description="Template category based on review type",
    )
    
    template_text: str = Field(
        ...,
        min_length=50,
        max_length=2000,
        description="Template text with placeholders",
        examples=[
            "Dear {reviewer_name}, thank you for your {rating}-star review! "
            "We're delighted to hear about your positive experience at "
            "{hostel_name}. {custom_message} We look forward to hosting you "
            "again. Best regards, {responder_name}"
        ],
    )
    
    # Placeholders
    available_placeholders: List[str] = Field(
        default_factory=lambda: [
            "{reviewer_name}",
            "{hostel_name}",
            "{rating}",
            "{responder_name}",
            "{custom_message}",
        ],
        description="Available placeholders in template",
    )
    
    # Usage stats
    usage_count: int = Field(
        default=0,
        ge=0,
        description="Times this template has been used",
    )
    
    is_active: bool = Field(default=True, description="Whether template is active")
    
    @field_validator("category")
    @classmethod
    def normalize_category(cls, v: str) -> str:
        """Normalize category to lowercase."""
        return v.lower().strip()

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_submission.py ---
# --- File: app/schemas/review/review_submission.py ---
"""
Review submission and verification schemas.

Handles the complete review submission workflow including
verification and eligibility checks.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator, computed_field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "ReviewSubmissionRequest",
    "DetailedRatingsInput",
    "VerifiedReview",
    "ReviewGuidelines",
    "ReviewEligibility",
    "ReviewDraft",
]


class DetailedRatingsInput(BaseSchema):
    """
    Detailed aspect ratings for review submission.
    
    Allows reviewers to rate specific aspects of their experience.
    """
    
    cleanliness: int = Field(
        ...,
        ge=1,
        le=5,
        description="Cleanliness and hygiene rating",
    )
    food_quality: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Food quality rating (if mess facility used)",
    )
    staff_behavior: int = Field(
        ...,
        ge=1,
        le=5,
        description="Staff behavior and helpfulness rating",
    )
    security: int = Field(
        ...,
        ge=1,
        le=5,
        description="Safety and security measures rating",
    )
    value_for_money: int = Field(
        ...,
        ge=1,
        le=5,
        description="Value for money rating",
    )
    amenities: int = Field(
        ...,
        ge=1,
        le=5,
        description="Facilities and amenities quality rating",
    )
    location: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Location convenience rating",
    )
    wifi_quality: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Internet/WiFi quality rating",
    )
    maintenance: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Maintenance responsiveness rating",
    )
    
    @computed_field
    @property
    def average_rating(self) -> Decimal:
        """Calculate average of all provided ratings."""
        ratings = [
            self.cleanliness,
            self.staff_behavior,
            self.security,
            self.value_for_money,
            self.amenities,
        ]
        
        # Add optional ratings if provided
        optional = [
            self.food_quality,
            self.location,
            self.wifi_quality,
            self.maintenance,
        ]
        ratings.extend([r for r in optional if r is not None])
        
        return Decimal(str(round(sum(ratings) / len(ratings), 2)))


class ReviewSubmissionRequest(BaseCreateSchema):
    """
    Complete review submission request.
    
    Contains all data needed to submit a new review.
    """
    
    hostel_id: UUID = Field(..., description="Hostel to review")
    
    # Verification references (optional but help verify stay)
    booking_id: Optional[UUID] = Field(
        None,
        description="Related booking ID for stay verification",
    )
    student_id: Optional[UUID] = Field(
        None,
        description="Student profile ID for stay verification",
    )
    
    # Basic review content
    overall_rating: Decimal = Field(
        ...,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        description="Overall rating (1-5, in 0.5 increments)",
        examples=[Decimal("4.5")],
    )
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Review title",
        examples=["Excellent hostel with great facilities"],
    )
    review_text: str = Field(
        ...,
        min_length=50,
        max_length=5000,
        description="Detailed review text",
    )
    
    # Detailed ratings
    detailed_ratings: DetailedRatingsInput = Field(
        ...,
        description="Detailed aspect-specific ratings",
    )
    
    # Media
    photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="Review photos (max 10)",
    )
    
    # Recommendation
    would_recommend: bool = Field(
        ...,
        description="Would you recommend this hostel?",
    )
    
    # Stay details (helps with verification)
    stay_duration_months: Optional[int] = Field(
        None,
        ge=1,
        le=24,
        description="Duration of stay in months",
    )
    check_in_date: Optional[date] = Field(
        None,
        description="Approximate check-in date",
    )
    check_out_date: Optional[date] = Field(
        None,
        description="Approximate check-out date (if moved out)",
    )
    
    # Specific feedback (optional)
    pros: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Things you liked (max 5)",
    )
    cons: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Things that could be improved (max 5)",
    )
    
    # Terms acceptance
    agree_to_guidelines: bool = Field(
        ...,
        description="Confirms agreement to review guidelines",
    )
    
    @field_validator("overall_rating")
    @classmethod
    def round_to_half(cls, v: Decimal) -> Decimal:
        """Round overall rating to nearest 0.5."""
        return Decimal(str(round(float(v) * 2) / 2))
    
    @field_validator("title")
    @classmethod
    def validate_title(cls, v: str) -> str:
        """Validate and clean title."""
        v = v.strip()
        if not v:
            raise ValueError("Review title cannot be empty")
        
        if len(v) > 10 and v.isupper():
            raise ValueError("Please avoid using all caps in the title")
        
        return v
    
    @field_validator("review_text")
    @classmethod
    def validate_review_text(cls, v: str) -> str:
        """Validate and clean review text."""
        v = v.strip()
        if not v:
            raise ValueError("Review text cannot be empty")
        
        word_count = len(v.split())
        if word_count < 10:
            raise ValueError(
                "Please provide a more detailed review (minimum 10 words)"
            )
        
        return v
    
    @field_validator("agree_to_guidelines")
    @classmethod
    def must_agree(cls, v: bool) -> bool:
        """Ensure user agrees to guidelines."""
        if not v:
            raise ValueError(
                "You must agree to the review guidelines to submit a review"
            )
        return v
    
    @field_validator("pros", "cons")
    @classmethod
    def validate_feedback_items(cls, v: List[str]) -> List[str]:
        """Validate and clean feedback items."""
        cleaned = []
        for item in v:
            item = item.strip()
            if item:
                if len(item) > 200:
                    raise ValueError(
                        "Each feedback item must be 200 characters or less"
                    )
                cleaned.append(item)
        return cleaned
    
    @model_validator(mode="after")
    def validate_dates(self) -> "ReviewSubmissionRequest":
        """Validate check-in and check-out dates."""
        if self.check_in_date and self.check_out_date:
            if self.check_out_date <= self.check_in_date:
                raise ValueError(
                    "Check-out date must be after check-in date"
                )
        
        if self.check_in_date and self.check_in_date > date.today():
            raise ValueError("Check-in date cannot be in the future")
        
        return self
    
    @model_validator(mode="after")
    def validate_rating_consistency(self) -> "ReviewSubmissionRequest":
        """Validate overall rating aligns with detailed ratings."""
        overall = float(self.overall_rating)
        detailed_avg = float(self.detailed_ratings.average_rating)
        
        # Allow 1.5 variance
        if abs(overall - detailed_avg) > 1.5:
            raise ValueError(
                "Overall rating seems inconsistent with detailed ratings. "
                "Please review your ratings."
            )
        
        return self


class VerifiedReview(BaseSchema):
    """
    Verified review marker.
    
    Indicates that a review is from a verified stay.
    """
    
    review_id: UUID = Field(..., description="Review ID")
    
    is_verified: bool = Field(..., description="Verification status")
    verification_method: str = Field(
        ...,
        pattern=r"^(booking_verified|student_verified|admin_verified|auto_verified|manual_verified)$",
        description="Method used for verification",
    )
    
    verified_by: Optional[UUID] = Field(
        None,
        description="Admin who verified (for manual verification)",
    )
    verified_at: datetime = Field(..., description="Verification timestamp")
    
    # Verification details
    verification_details: Optional[Dict[str, str]] = Field(
        None,
        description="Additional verification information",
        examples=[
            {
                "booking_id": "123e4567-e89b-12d3-a456-426614174000",
                "stay_duration": "6 months",
                "verified_via": "booking_system",
            }
        ],
    )
    
    # Confidence score for auto-verification
    verification_confidence: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        le=Decimal("1"),
        description="Confidence score for auto-verification (0-1)",
    )
    
    @field_validator("verification_method")
    @classmethod
    def normalize_method(cls, v: str) -> str:
        """Normalize verification method."""
        return v.lower().strip()


class ReviewGuidelines(BaseSchema):
    """
    Review guidelines and prohibited content.
    
    Helps users understand what makes a good review.
    """
    
    guidelines: List[str] = Field(
        default_factory=lambda: [
            "Be honest and fair in your assessment",
            "Focus on your personal experience",
            "Avoid offensive or abusive language",
            "Don't include personal contact information",
            "Be specific and constructive with feedback",
            "Reviews are public and visible to all users",
            "Rate based on your actual experience, not expectations",
            "Consider both pros and cons objectively",
        ],
        description="Guidelines for writing reviews",
    )
    
    prohibited_content: List[str] = Field(
        default_factory=lambda: [
            "Offensive, abusive, or threatening language",
            "Personal attacks on staff or other residents",
            "Spam, advertising, or promotional content",
            "Fake, fraudulent, or misleading reviews",
            "Reviews for competing businesses",
            "Personal contact information (phone, email, address)",
            "Illegal content or content promoting illegal activities",
            "Discriminatory content based on race, religion, gender, etc.",
        ],
        description="Content that is not allowed in reviews",
    )
    
    tips_for_good_review: List[str] = Field(
        default_factory=lambda: [
            "Describe specific experiences (room quality, food, staff)",
            "Mention the duration of your stay",
            "Include photos if possible",
            "Be balanced - mention both positives and areas for improvement",
            "Update your review if significant changes occur",
        ],
        description="Tips for writing helpful reviews",
    )
    
    minimum_requirements: Dict[str, int] = Field(
        default_factory=lambda: {
            "title_min_length": 5,
            "title_max_length": 255,
            "review_min_length": 50,
            "review_max_length": 5000,
            "min_overall_rating": 1,
            "max_overall_rating": 5,
            "max_photos": 10,
        },
        description="Minimum requirements for review submission",
    )


class ReviewEligibility(BaseSchema):
    """
    Check if user is eligible to review a hostel.
    
    Validates eligibility based on stay history and existing reviews.
    """
    
    user_id: UUID = Field(..., description="User to check eligibility for")
    hostel_id: UUID = Field(..., description="Hostel to review")
    
    can_review: bool = Field(
        ...,
        description="Whether user can submit a review",
    )
    reason: str = Field(
        ...,
        description="Reason for eligibility decision",
        examples=[
            "Eligible to review",
            "Already reviewed this hostel",
            "No verified stay at this hostel",
        ],
    )
    
    # Stay verification
    has_stayed: bool = Field(
        ...,
        description="Whether user has stayed at this hostel",
    )
    has_booking: bool = Field(
        ...,
        description="Whether user has a booking at this hostel",
    )
    stay_verified: bool = Field(
        ...,
        description="Whether stay is verified",
    )
    
    # Existing review
    already_reviewed: bool = Field(
        ...,
        description="Whether user already has a review for this hostel",
    )
    existing_review_id: Optional[UUID] = Field(
        None,
        description="ID of existing review (if any)",
    )
    can_edit: bool = Field(
        default=False,
        description="Whether user can edit their existing review",
    )
    edit_deadline: Optional[datetime] = Field(
        None,
        description="Deadline for editing existing review",
    )
    
    # Additional info
    last_stay_date: Optional[date] = Field(
        None,
        description="Date of last stay (if applicable)",
    )
    stay_duration_days: Optional[int] = Field(
        None,
        ge=1,
        description="Duration of stay in days",
    )


class ReviewDraft(BaseSchema):
    """
    Saved review draft.
    
    Allows users to save incomplete reviews for later.
    """
    
    draft_id: UUID = Field(..., description="Draft ID")
    user_id: UUID = Field(..., description="User who created the draft")
    hostel_id: UUID = Field(..., description="Target hostel")
    
    # Partial content
    overall_rating: Optional[Decimal] = Field(
        None,
        ge=Decimal("1.0"),
        le=Decimal("5.0"),
        description="Overall rating (if set)",
    )
    title: Optional[str] = Field(
        None,
        max_length=255,
        description="Review title (if set)",
    )
    review_text: Optional[str] = Field(
        None,
        max_length=5000,
        description="Review text (if set)",
    )
    
    # Detailed ratings
    detailed_ratings: Optional[Dict[str, int]] = Field(
        None,
        description="Detailed ratings (if any set)",
    )
    
    # Photos
    photos: List[str] = Field(
        default_factory=list,
        description="Uploaded photo URLs",
    )
    
    # Timestamps
    created_at: datetime = Field(..., description="Draft creation time")
    updated_at: datetime = Field(..., description="Last update time")
    expires_at: datetime = Field(
        ...,
        description="When draft expires and will be deleted",
    )
    
    @computed_field
    @property
    def completion_percentage(self) -> int:
        """Estimate completion percentage."""
        total_fields = 5  # rating, title, text, detailed_ratings, photos
        completed = 0
        
        if self.overall_rating is not None:
            completed += 1
        if self.title:
            completed += 1
        if self.review_text and len(self.review_text) >= 50:
            completed += 1
        if self.detailed_ratings and len(self.detailed_ratings) >= 3:
            completed += 1
        if self.photos:
            completed += 1
        
        return int((completed / total_fields) * 100)
    
    @computed_field
    @property
    def is_expired(self) -> bool:
        """Check if draft is expired."""
        return datetime.utcnow() > self.expires_at

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\review_voting.py ---
# --- File: app/schemas/review/review_voting.py ---
"""
Review voting (helpful/not helpful) schemas.

Handles review helpfulness voting and engagement metrics.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from math import sqrt
from typing import List, Optional

from pydantic import Field, computed_field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema
from app.schemas.common.enums import VoteType

__all__ = [
    "VoteRequest",
    "VoteResponse",
    "HelpfulnessScore",
    "VoteHistory",
    "VoteHistoryItem",
    "RemoveVote",
    "VotingStats",
]


class VoteRequest(BaseCreateSchema):
    """
    Submit vote on review helpfulness.
    
    Allows users to indicate if a review was helpful.
    """
    
    review_id: UUID = Field(..., description="Review to vote on")
    voter_id: UUID = Field(..., description="User casting the vote")
    
    vote_type: VoteType = Field(
        ...,
        description="Vote type: helpful or not_helpful",
    )
    
    # Optional feedback
    feedback: Optional[str] = Field(
        None,
        max_length=500,
        description="Optional feedback about why vote was cast",
    )


class VoteResponse(BaseSchema):
    """
    Response after vote submission.
    
    Returns updated vote counts.
    """
    
    review_id: UUID = Field(..., description="Voted review ID")
    vote_type: VoteType = Field(..., description="Vote that was cast")
    
    # Updated counts
    helpful_count: int = Field(..., ge=0, description="Updated helpful count")
    not_helpful_count: int = Field(..., ge=0, description="Updated not helpful count")
    
    # User's current vote status
    user_vote: Optional[VoteType] = Field(
        None,
        description="User's current vote (may differ if changed)",
    )
    
    message: str = Field(
        ...,
        description="Result message",
        examples=["Vote recorded successfully", "Vote updated"],
    )
    
    @computed_field
    @property
    def total_votes(self) -> int:
        """Total votes on the review."""
        return self.helpful_count + self.not_helpful_count
    
    @computed_field
    @property
    def helpfulness_percentage(self) -> Decimal:
        """Percentage of helpful votes."""
        if self.total_votes == 0:
            return Decimal("0")
        return Decimal(str(round((self.helpful_count / self.total_votes) * 100, 2)))


class HelpfulnessScore(BaseSchema):
    """
    Helpfulness score for review ranking.
    
    Uses Wilson score for statistically sound ranking.
    """
    
    review_id: UUID = Field(..., description="Review ID")
    
    # Raw counts
    helpful_count: int = Field(..., ge=0, description="Helpful votes")
    not_helpful_count: int = Field(..., ge=0, description="Not helpful votes")
    total_votes: int = Field(..., ge=0, description="Total votes")
    
    # Percentage
    helpfulness_percentage: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        description="Percentage of helpful votes",
    )
    
    # Wilson score for ranking
    helpfulness_score: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("1"),
        description="Wilson score for ranking (0-1)",
    )
    
    # Rank among hostel's reviews
    rank: Optional[int] = Field(
        None,
        ge=1,
        description="Rank among reviews for this hostel",
    )
    
    @classmethod
    def calculate_wilson_score(
        cls,
        helpful: int,
        total: int,
        confidence: float = 0.95,
    ) -> Decimal:
        """
        Calculate Wilson score for review ranking.
        
        Wilson score provides a statistically robust way to rank items
        by positive/negative votes, handling the case where items with
        few votes aren't artificially ranked higher than those with many.
        
        Args:
            helpful: Number of helpful votes
            total: Total number of votes
            confidence: Confidence level (default 0.95 for 95%)
            
        Returns:
            Wilson score as Decimal (0-1)
        """
        if total == 0:
            return Decimal("0")
        
        # Z-score for confidence level (1.96 for 95%)
        z = 1.96 if confidence == 0.95 else 1.645  # 90% confidence
        
        phat = helpful / total
        
        denominator = 1 + (z * z / total)
        numerator = (
            phat
            + (z * z / (2 * total))
            - z * sqrt((phat * (1 - phat) + z * z / (4 * total)) / total)
        )
        
        score = numerator / denominator
        return Decimal(str(round(max(0, min(1, score)), 6)))


class VoteHistoryItem(BaseSchema):
    """
    Individual vote in user's history.
    """
    
    review_id: UUID = Field(..., description="Review that was voted on")
    hostel_id: UUID = Field(..., description="Hostel of the review")
    hostel_name: str = Field(..., description="Hostel name")
    
    review_title: str = Field(..., description="Review title")
    review_rating: Decimal = Field(
        ...,
        ge=Decimal("1"),
        le=Decimal("5"),
        description="Review's overall rating",
    )
    
    vote_type: VoteType = Field(..., description="How user voted")
    voted_at: datetime = Field(..., description="When vote was cast")
    
    @computed_field
    @property
    def days_ago(self) -> int:
        """Days since vote was cast."""
        delta = datetime.utcnow() - self.voted_at
        return delta.days


class VoteHistory(BaseSchema):
    """
    User's complete voting history.
    
    Tracks all votes cast by a user.
    """
    
    user_id: UUID = Field(..., description="User ID")
    
    # Aggregate stats
    total_votes: int = Field(..., ge=0, description="Total votes cast")
    helpful_votes: int = Field(..., ge=0, description="Helpful votes cast")
    not_helpful_votes: int = Field(..., ge=0, description="Not helpful votes cast")
    
    # Recent activity
    recent_votes: List[VoteHistoryItem] = Field(
        default_factory=list,
        max_length=20,
        description="Most recent votes (max 20)",
    )
    
    # Voting patterns
    most_voted_hostels: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Hostels where user votes most",
    )
    
    @computed_field
    @property
    def helpful_vote_percentage(self) -> Decimal:
        """Percentage of helpful votes vs total."""
        if self.total_votes == 0:
            return Decimal("0")
        return Decimal(
            str(round((self.helpful_votes / self.total_votes) * 100, 2))
        )
    
    @computed_field
    @property
    def voting_tendency(self) -> str:
        """
        User's voting tendency.
        
        Returns: positive, balanced, or critical
        """
        percentage = float(self.helpful_vote_percentage)
        if percentage >= 70:
            return "positive"
        elif percentage >= 40:
            return "balanced"
        else:
            return "critical"


class RemoveVote(BaseCreateSchema):
    """
    Remove previously cast vote.
    
    Allows users to change their mind about a vote.
    """
    
    review_id: UUID = Field(..., description="Review to remove vote from")
    voter_id: UUID = Field(..., description="User removing their vote")
    
    reason: Optional[str] = Field(
        None,
        max_length=255,
        description="Optional reason for removing vote",
    )


class VotingStats(BaseSchema):
    """
    Voting statistics for a hostel's reviews.
    
    Provides insights into review engagement.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    
    # Aggregate metrics
    total_votes: int = Field(..., ge=0, description="Total votes across all reviews")
    total_helpful: int = Field(..., ge=0, description="Total helpful votes")
    total_not_helpful: int = Field(..., ge=0, description="Total not helpful votes")
    
    # Per-review metrics
    total_reviews: int = Field(..., ge=0, description="Total reviews")
    reviews_with_votes: int = Field(..., ge=0, description="Reviews that have votes")
    
    average_votes_per_review: Decimal = Field(
        ...,
        ge=Decimal("0"),
        description="Average votes per review",
    )
    average_helpfulness: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        description="Average helpfulness percentage across reviews",
    )
    
    # Top reviews
    most_helpful_review_id: Optional[UUID] = Field(
        None,
        description="Review with highest helpfulness score",
    )
    most_voted_review_id: Optional[UUID] = Field(
        None,
        description="Review with most total votes",
    )
    
    @computed_field
    @property
    def engagement_rate(self) -> Decimal:
        """Percentage of reviews that have votes."""
        if self.total_reviews == 0:
            return Decimal("0")
        return Decimal(
            str(round((self.reviews_with_votes / self.total_reviews) * 100, 2))
        )
    
    @computed_field
    @property
    def overall_sentiment(self) -> str:
        """
        Overall voting sentiment.
        
        Returns: positive, neutral, or negative
        """
        if self.total_votes == 0:
            return "neutral"
        
        helpful_ratio = self.total_helpful / self.total_votes
        if helpful_ratio >= 0.7:
            return "positive"
        elif helpful_ratio >= 0.4:
            return "neutral"
        else:
            return "negative"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\review\__init__.py ---
# --- File: app/schemas/review/__init__.py ---
"""
Review schemas package.

Provides comprehensive schemas for:
- Review creation, update, and submission
- Review responses and details
- Moderation and approval workflows
- Voting and engagement
- Hostel responses to reviews
- Filtering, searching, and export
- Analytics and insights

Example:
    from app.schemas.review import (
        ReviewCreate,
        ReviewResponse,
        ReviewSubmissionRequest,
        ModerationRequest,
        VoteRequest,
    )
"""

from __future__ import annotations

# Base schemas
from app.schemas.review.review_base import (
    ReviewBase,
    ReviewCreate,
    ReviewUpdate,
    DetailedRatings,
)

# Response schemas
from app.schemas.review.review_response import (
    ReviewResponse,
    ReviewDetail,
    ReviewListItem,
    ReviewSummary,
    HostelResponseDetail,
)

# Submission schemas
from app.schemas.review.review_submission import (
    ReviewSubmissionRequest,
    DetailedRatingsInput,
    VerifiedReview,
    ReviewGuidelines,
    ReviewEligibility,
    ReviewDraft,
)

# Moderation schemas
from app.schemas.review.review_moderation import (
    ModerationRequest,
    ModerationResponse,
    ModerationQueue,
    PendingReview,
    ApprovalWorkflow,
    BulkModeration,
    ModerationStats,
    FlagReview,
)

# Voting schemas
from app.schemas.review.review_voting import (
    VoteRequest,
    VoteResponse,
    HelpfulnessScore,
    VoteHistory,
    VoteHistoryItem,
    RemoveVote,
    VotingStats,
)

# Hostel response schemas
from app.schemas.review.review_response_schema import (
    HostelResponseCreate,
    HostelResponseUpdate,
    OwnerResponse,
    ResponseGuidelines,
    ResponseStats,
    ResponseTemplate,
)

# Filter schemas
from app.schemas.review.review_filters import (
    ReviewFilterParams,
    ReviewSearchRequest,
    ReviewSortOptions,
    ReviewExportRequest,
)

# Analytics schemas
from app.schemas.review.review_analytics import (
    ReviewAnalytics,
    RatingDistribution,
    TrendAnalysis,
    MonthlyRating,
    SentimentAnalysis,
    AspectAnalysis,
    CompetitorComparison,
)

__all__ = [
    # Base
    "ReviewBase",
    "ReviewCreate",
    "ReviewUpdate",
    "DetailedRatings",
    
    # Response
    "ReviewResponse",
    "ReviewDetail",
    "ReviewListItem",
    "ReviewSummary",
    "HostelResponseDetail",
    
    # Submission
    "ReviewSubmissionRequest",
    "DetailedRatingsInput",
    "VerifiedReview",
    "ReviewGuidelines",
    "ReviewEligibility",
    "ReviewDraft",
    
    # Moderation
    "ModerationRequest",
    "ModerationResponse",
    "ModerationQueue",
    "PendingReview",
    "ApprovalWorkflow",
    "BulkModeration",
    "ModerationStats",
    "FlagReview",
    
    # Voting
    "VoteRequest",
    "VoteResponse",
    "HelpfulnessScore",
    "VoteHistory",
    "VoteHistoryItem",
    "RemoveVote",
    "VotingStats",
    
    # Hostel Response
    "HostelResponseCreate",
    "HostelResponseUpdate",
    "OwnerResponse",
    "ResponseGuidelines",
    "ResponseStats",
    "ResponseTemplate",
    
    # Filters
    "ReviewFilterParams",
    "ReviewSearchRequest",
    "ReviewSortOptions",
    "ReviewExportRequest",
    
    # Analytics
    "ReviewAnalytics",
    "RatingDistribution",
    "TrendAnalysis",
    "MonthlyRating",
    "SentimentAnalysis",
    "AspectAnalysis",
    "CompetitorComparison",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\room =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\room\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\room ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\room =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\room\bed_base.py ---
# --- File: app/schemas/room/bed_base.py ---
"""
Bed base schemas with enhanced validation and assignment management.

Provides schemas for individual bed management, bulk operations,
assignments, and releases.
"""

from __future__ import annotations

from datetime import date
from typing import List, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import BedStatus

__all__ = [
    "BedBase",
    "BedCreate",
    "BedUpdate",
    "BulkBedCreate",
    "BedAssignmentRequest",
    "BedReleaseRequest",
    "BedSwapRequest",
    "BulkBedStatusUpdate",
]


class BedBase(BaseSchema):
    """
    Base bed schema with core bed attributes.
    
    Represents an individual bed/berth within a room.
    """

    room_id: str = Field(
        ...,
        description="Room ID this bed belongs to",
    )
    bed_number: str = Field(
        ...,
        min_length=1,
        max_length=10,
        description="Bed identifier within room (A1, B2, Bed-1, etc.)",
        examples=["A1", "B2", "Bed-1", "Upper-1"],
    )
    status: BedStatus = Field(
        default=BedStatus.AVAILABLE,
        description="Current bed status",
    )

    @field_validator("bed_number")
    @classmethod
    def validate_bed_number(cls, v: str) -> str:
        """
        Validate and normalize bed number.
        
        Ensures consistent bed number format.
        """
        v = v.strip().upper()
        if not v:
            raise ValueError("Bed number cannot be empty")
        # Remove excessive whitespace
        v = " ".join(v.split())
        return v


class BedCreate(BedBase, BaseCreateSchema):
    """
    Schema for creating a single bed.
    
    Used when manually adding beds to a room.
    """

    # Override to ensure required fields
    room_id: str = Field(
        ...,
        description="Room ID (required)",
    )
    bed_number: str = Field(
        ...,
        min_length=1,
        max_length=10,
        description="Bed number (required)",
    )


class BedUpdate(BaseUpdateSchema):
    """
    Schema for updating bed information.
    
    Allows partial updates to bed attributes.
    """

    bed_number: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=10,
        description="Bed identifier",
    )
    status: Optional[BedStatus] = Field(
        default=None,
        description="Bed status",
    )
    is_occupied: Optional[bool] = Field(
        default=None,
        description="Occupancy status (legacy, prefer using status)",
    )
    notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Additional notes about the bed",
    )

    @field_validator("bed_number")
    @classmethod
    def validate_bed_number(cls, v: Optional[str]) -> Optional[str]:
        """Validate bed number format."""
        if v is not None:
            v = v.strip().upper()
            if not v:
                raise ValueError("Bed number cannot be empty")
            v = " ".join(v.split())
        return v

    @model_validator(mode="after")
    def sync_status_with_occupancy(self) -> "BedUpdate":
        """
        Sync legacy is_occupied with status field.
        
        Maintains backward compatibility.
        """
        if self.is_occupied is not None:
            if self.is_occupied:
                self.status = BedStatus.OCCUPIED
            else:
                # Only set to available if not in maintenance/reserved
                if self.status in [BedStatus.OCCUPIED, None]:
                    self.status = BedStatus.AVAILABLE
        return self


class BulkBedCreate(BaseCreateSchema):
    """
    Schema for bulk bed creation.
    
    Automatically creates multiple beds for a room with sequential numbering.
    Useful for initial room setup.
    """

    room_id: str = Field(
        ...,
        description="Room ID to create beds for",
    )
    bed_count: int = Field(
        ...,
        ge=1,
        le=20,
        description="Number of beds to create (1-20)",
    )
    bed_prefix: str = Field(
        default="B",
        min_length=1,
        max_length=5,
        description="Prefix for bed numbers (e.g., 'B', 'BED', 'A')",
        examples=["B", "BED", "A", "BERTH"],
    )
    start_number: int = Field(
        default=1,
        ge=1,
        le=100,
        description="Starting number for bed sequence",
    )
    number_format: str = Field(
        default="{prefix}{number}",
        description="Format string for bed numbers (use {prefix} and {number})",
        examples=["{prefix}{number}", "{prefix}-{number}", "Bed-{number}"],
    )

    @field_validator("bed_prefix")
    @classmethod
    def validate_bed_prefix(cls, v: str) -> str:
        """Validate and normalize bed prefix."""
        v = v.strip().upper()
        if not v:
            raise ValueError("Bed prefix cannot be empty")
        # Only alphanumeric characters
        if not v.replace("-", "").replace("_", "").isalnum():
            raise ValueError(
                "Bed prefix can only contain alphanumeric characters, hyphens, and underscores"
            )
        return v

    @field_validator("number_format")
    @classmethod
    def validate_number_format(cls, v: str) -> str:
        """Validate number format string."""
        if "{number}" not in v:
            raise ValueError("Number format must contain {number} placeholder")
        # Validate format string can be used
        try:
            test = v.format(prefix="TEST", number=1)
        except KeyError as e:
            raise ValueError(f"Invalid placeholder in format string: {e}")
        return v

    def generate_bed_numbers(self) -> List[str]:
        """
        Generate bed numbers based on configuration.
        
        Returns:
            List of bed numbers to create
        """
        bed_numbers = []
        for i in range(self.bed_count):
            bed_num = self.number_format.format(
                prefix=self.bed_prefix,
                number=self.start_number + i
            )
            bed_numbers.append(bed_num)
        return bed_numbers


class BedAssignmentRequest(BaseCreateSchema):
    """
    Schema for assigning a bed to a student.
    
    Creates a bed assignment with proper date tracking.
    """

    bed_id: str = Field(
        ...,
        description="Bed ID to assign",
    )
    student_id: str = Field(
        ...,
        description="Student ID to assign bed to",
    )
    occupied_from: date = Field(
        ...,
        description="Occupancy start date",
    )
    expected_vacate_date: Optional[date] = Field(
        default=None,
        description="Expected vacate/checkout date (optional)",
    )
    booking_id: Optional[str] = Field(
        default=None,
        description="Related booking ID (if applicable)",
    )
    notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Assignment notes",
    )

    @field_validator("occupied_from")
    @classmethod
    def validate_occupied_from(cls, v: date) -> date:
        """
        Validate occupancy start date.
        
        Allows past dates for historical assignments but warns for future dates.
        """
        from datetime import date as dt
        
        # Allow past dates for historical data entry
        # Could add warning logic here if needed
        
        return v

    @model_validator(mode="after")
    def validate_date_range(self) -> "BedAssignmentRequest":
        """Validate expected vacate date is after occupied_from."""
        if self.expected_vacate_date:
            if self.expected_vacate_date <= self.occupied_from:
                raise ValueError(
                    "Expected vacate date must be after occupancy start date"
                )
        return self


class BedReleaseRequest(BaseCreateSchema):
    """
    Schema for releasing a bed from a student.
    
    Handles bed checkout/vacating with proper documentation.
    """

    bed_id: str = Field(
        ...,
        description="Bed ID to release",
    )
    student_id: Optional[str] = Field(
        default=None,
        description="Student ID (optional, for validation)",
    )
    release_date: date = Field(
        ...,
        description="Actual release/checkout date",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for release",
        examples=[
            "Completed stay",
            "Early checkout",
            "Transferred to another room",
            "Hostel exit",
        ],
    )
    condition_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Bed/room condition notes at checkout",
    )
    damages_reported: bool = Field(
        default=False,
        description="Whether any damages were reported",
    )

    @field_validator("release_date")
    @classmethod
    def validate_release_date(cls, v: date) -> date:
        """
        Validate release date.
        
        Allows past dates for historical entries.
        """
        # Allow past dates for data entry
        # Future dates might be allowed for scheduled releases
        return v


class BedSwapRequest(BaseCreateSchema):
    """
    Schema for swapping beds between students.
    
    Handles bed exchanges with proper tracking.
    """

    student_1_id: str = Field(
        ...,
        description="First student ID",
    )
    bed_1_id: str = Field(
        ...,
        description="First student's current bed ID",
    )
    student_2_id: str = Field(
        ...,
        description="Second student ID",
    )
    bed_2_id: str = Field(
        ...,
        description="Second student's current bed ID",
    )
    swap_date: date = Field(
        ...,
        description="Date of bed swap",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for swap",
        examples=[
            "Student request",
            "Compatibility issues",
            "Room preference",
            "Administrative decision",
        ],
    )
    approved_by: Optional[str] = Field(
        default=None,
        description="Admin/supervisor who approved the swap",
    )

    @field_validator("swap_date")
    @classmethod
    def validate_swap_date(cls, v: date) -> date:
        """Validate swap date is not too far in the past."""
        from datetime import date as dt, timedelta
        
        # Warn if swap date is more than 30 days in the past
        if v < dt.today() - timedelta(days=30):
            # Could log a warning here
            pass
        
        return v

    @model_validator(mode="after")
    def validate_different_students_and_beds(self) -> "BedSwapRequest":
        """Ensure students and beds are different."""
        if self.student_1_id == self.student_2_id:
            raise ValueError("Cannot swap beds for the same student")
        
        if self.bed_1_id == self.bed_2_id:
            raise ValueError("Cannot swap the same bed")
        
        return self


class BulkBedStatusUpdate(BaseCreateSchema):
    """
    Schema for bulk bed status updates.
    
    Allows updating status of multiple beds simultaneously.
    Useful for maintenance or availability updates.
    """

    bed_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of bed IDs to update (max 50)",
    )
    status: BedStatus = Field(
        ...,
        description="New status for all beds",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for bulk status change",
    )
    effective_date: Optional[date] = Field(
        default=None,
        description="Effective date for status change",
    )

    @field_validator("bed_ids")
    @classmethod
    def validate_unique_bed_ids(cls, v: List[str]) -> List[str]:
        """Ensure bed IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Bed IDs must be unique")
        return v

    @model_validator(mode="after")
    def validate_status_change(self) -> "BulkBedStatusUpdate":
        """Validate status change requirements."""
        # If setting to maintenance, require reason
        if self.status == BedStatus.MAINTENANCE and not self.reason:
            raise ValueError(
                "Reason is required when setting beds to maintenance status"
            )
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\room\bed_response.py ---
# --- File: app/schemas/room/bed_response.py ---
"""
Bed response schemas for API responses.

Provides various response formats for bed data including
availability, assignments, and history.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import BedStatus

__all__ = [
    "BedResponse",
    "BedAvailability",
    "BedAssignment",
    "BedHistory",
    "BedAssignmentHistory",
    "BedDetailedStatus",
]


class BedResponse(BaseResponseSchema):
    """
    Standard bed response schema.
    
    Basic bed information for general API responses.
    """

    room_id: str = Field(..., description="Room ID")
    bed_number: str = Field(..., description="Bed identifier")
    is_occupied: bool = Field(..., description="Currently occupied")
    status: BedStatus = Field(..., description="Bed status")
    current_student_id: Optional[str] = Field(
        default=None,
        description="Current occupant ID",
    )
    occupied_from: Optional[date] = Field(
        default=None,
        description="Occupancy start date",
    )

    @computed_field
    @property
    def is_available(self) -> bool:
        """Check if bed is available for assignment."""
        return self.status == BedStatus.AVAILABLE and not self.is_occupied


class BedAvailability(BaseSchema):
    """
    Bed availability information.
    
    Detailed availability status for booking purposes.
    """

    bed_id: str = Field(..., description="Bed ID")
    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    bed_number: str = Field(..., description="Bed identifier")
    
    # Availability
    is_available: bool = Field(..., description="Available for assignment")
    status: BedStatus = Field(..., description="Current status")
    available_from: Optional[date] = Field(
        default=None,
        description="Date when bed becomes available",
    )
    
    # Current occupant (if any)
    current_student_name: Optional[str] = Field(
        default=None,
        description="Current occupant name",
    )
    current_student_id: Optional[str] = Field(
        default=None,
        description="Current occupant ID",
    )
    expected_vacate_date: Optional[date] = Field(
        default=None,
        description="Expected checkout date",
    )
    
    # Room info
    room_type: str = Field(..., description="Room type")
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent")
    is_ac: bool = Field(..., description="AC available in room")
    has_attached_bathroom: bool = Field(
        ...,
        description="Attached bathroom",
    )

    @computed_field
    @property
    def days_until_available(self) -> Optional[int]:
        """Calculate days until bed becomes available."""
        if not self.available_from:
            return None
        if self.is_available:
            return 0
        today = date.today()
        if self.available_from <= today:
            return 0
        return (self.available_from - today).days


class BedAssignment(BaseResponseSchema):
    """
    Bed assignment details.
    
    Complete information about a bed assignment.
    """

    bed_id: str = Field(..., description="Bed ID")
    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    bed_number: str = Field(..., description="Bed identifier")
    
    # Student info
    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")
    student_email: Optional[str] = Field(
        default=None,
        description="Student email",
    )
    student_phone: Optional[str] = Field(
        default=None,
        description="Student phone",
    )
    
    # Assignment dates
    occupied_from: date = Field(..., description="Occupancy start date")
    expected_vacate_date: Optional[date] = Field(
        default=None,
        description="Expected checkout date",
    )
    actual_vacate_date: Optional[date] = Field(
        default=None,
        description="Actual checkout date (if completed)",
    )
    
    # Pricing
    monthly_rent: Decimal = Field(..., ge=0, description="Monthly rent amount")
    
    # Related records
    booking_id: Optional[str] = Field(
        default=None,
        description="Related booking ID",
    )
    
    # Status
    is_active: bool = Field(
        default=True,
        description="Assignment is currently active",
    )
    
    # Metadata
    assigned_at: datetime = Field(..., description="Assignment timestamp")
    assigned_by: Optional[str] = Field(
        default=None,
        description="Admin who created assignment",
    )
    notes: Optional[str] = Field(
        default=None,
        description="Assignment notes",
    )

    @computed_field
    @property
    def days_occupied(self) -> int:
        """Calculate days occupied."""
        end_date = self.actual_vacate_date or date.today()
        return (end_date - self.occupied_from).days

    @computed_field
    @property
    def expected_duration_days(self) -> Optional[int]:
        """Calculate expected duration in days."""
        if not self.expected_vacate_date:
            return None
        return (self.expected_vacate_date - self.occupied_from).days


class BedAssignmentHistory(BaseSchema):
    """
    Individual bed assignment history entry.
    
    Historical record of a single bed assignment.
    """

    assignment_id: str = Field(..., description="Assignment ID")
    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")
    move_in_date: date = Field(..., description="Move-in date")
    move_out_date: Optional[date] = Field(
        default=None,
        description="Move-out date (null if current)",
    )
    duration_days: Optional[int] = Field(
        default=None,
        description="Total duration in days",
    )
    monthly_rent: Decimal = Field(..., ge=0, description="Monthly rent paid")
    total_rent_paid: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Total rent paid during stay",
    )
    is_current: bool = Field(
        default=False,
        description="Currently active assignment",
    )

    @computed_field
    @property
    def duration_months(self) -> Optional[Decimal]:
        """Calculate duration in months."""
        if self.duration_days is None:
            return None
        return Decimal(self.duration_days / 30).quantize(Decimal("0.1"))


class BedHistory(BaseSchema):
    """
    Complete bed occupancy history.
    
    Historical timeline of all assignments for a bed.
    """

    bed_id: str = Field(..., description="Bed ID")
    room_number: str = Field(..., description="Room number")
    bed_number: str = Field(..., description="Bed identifier")
    
    # Current status
    current_status: BedStatus = Field(..., description="Current bed status")
    is_currently_occupied: bool = Field(
        ...,
        description="Currently occupied",
    )
    
    # Assignment history
    assignments: List[BedAssignmentHistory] = Field(
        default_factory=list,
        description="Historical assignments (newest first)",
    )
    
    # Statistics
    total_assignments: int = Field(
        default=0,
        ge=0,
        description="Total number of assignments",
    )
    total_occupancy_days: int = Field(
        default=0,
        ge=0,
        description="Total days occupied",
    )
    average_stay_duration_days: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Average stay duration",
    )
    last_occupied_date: Optional[date] = Field(
        default=None,
        description="Last occupancy date",
    )

    @computed_field
    @property
    def utilization_rate(self) -> Optional[Decimal]:
        """
        Calculate utilization rate since first assignment.
        
        Returns percentage of time bed has been occupied.
        """
        if not self.assignments:
            return None
        
        # Get earliest assignment
        earliest = min(a.move_in_date for a in self.assignments)
        total_days = (date.today() - earliest).days
        
        if total_days == 0:
            return None
        
        return Decimal(
            (self.total_occupancy_days / total_days * 100)
        ).quantize(Decimal("0.01"))


class BedDetailedStatus(BaseResponseSchema):
    """
    Detailed bed status with comprehensive information.
    
    Extended bed information including maintenance and condition.
    """

    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    bed_number: str = Field(..., description="Bed identifier")
    
    # Status
    status: BedStatus = Field(..., description="Current status")
    is_occupied: bool = Field(..., description="Occupied flag")
    is_available: bool = Field(..., description="Available for assignment")
    
    # Current assignment
    current_student_id: Optional[str] = Field(
        default=None,
        description="Current student ID",
    )
    current_student_name: Optional[str] = Field(
        default=None,
        description="Current student name",
    )
    occupied_from: Optional[date] = Field(
        default=None,
        description="Current occupancy start date",
    )
    expected_vacate_date: Optional[date] = Field(
        default=None,
        description="Expected checkout date",
    )
    
    # Maintenance
    last_maintenance_date: Optional[date] = Field(
        default=None,
        description="Last maintenance date",
    )
    next_scheduled_maintenance: Optional[date] = Field(
        default=None,
        description="Next scheduled maintenance",
    )
    maintenance_notes: Optional[str] = Field(
        default=None,
        description="Maintenance notes",
    )
    
    # Condition
    condition_rating: Optional[int] = Field(
        default=None,
        ge=1,
        le=5,
        description="Condition rating (1-5, 5 being excellent)",
    )
    last_inspection_date: Optional[date] = Field(
        default=None,
        description="Last inspection date",
    )
    reported_issues: List[str] = Field(
        default_factory=list,
        description="Currently reported issues",
    )
    
    # History stats
    total_assignments: int = Field(
        default=0,
        ge=0,
        description="Total historical assignments",
    )
    average_stay_duration_days: Optional[int] = Field(
        default=None,
        ge=0,
        description="Average stay duration",
    )
    
    # Metadata
    notes: Optional[str] = Field(
        default=None,
        description="General notes",
    )
    last_status_change: Optional[datetime] = Field(
        default=None,
        description="Last status change timestamp",
    )

    @computed_field
    @property
    def needs_maintenance(self) -> bool:
        """Check if bed needs maintenance."""
        # Needs maintenance if:
        # 1. Status is maintenance
        # 2. Has reported issues
        # 3. Condition rating is low (1-2)
        if self.status == BedStatus.MAINTENANCE:
            return True
        if self.reported_issues:
            return True
        if self.condition_rating and self.condition_rating <= 2:
            return True
        return False

    @computed_field
    @property
    def current_occupancy_days(self) -> Optional[int]:
        """Calculate days of current occupancy."""
        if not self.occupied_from:
            return None
        return (date.today() - self.occupied_from).days

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\room\room_availability.py ---
# --- File: app/schemas/room/room_availability.py ---
"""
Room availability schemas with enhanced date validation.

Provides schemas for checking room availability, calendar views,
and booking-related information.
"""

from __future__ import annotations

from datetime import date, timedelta
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, model_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import RoomType

__all__ = [
    "RoomAvailabilityRequest",
    "AvailabilityResponse",
    "AvailableRoom",
    "AvailabilityCalendar",
    "DayAvailability",
    "BookingInfo",
    "BulkAvailabilityRequest",
]


class RoomAvailabilityRequest(BaseCreateSchema):
    """
    Request to check room availability.
    
    Validates dates and duration for availability checking.
    """

    hostel_id: str = Field(
        ...,
        description="Hostel ID to check availability for",
    )
    check_in_date: date = Field(
        ...,
        description="Desired check-in date",
    )
    duration_months: int = Field(
        ...,
        ge=1,
        le=24,
        description="Stay duration in months (1-24)",
    )
    room_type: Optional[RoomType] = Field(
        default=None,
        description="Preferred room type (optional filter)",
    )
    min_beds: int = Field(
        default=1,
        ge=1,
        le=20,
        description="Minimum beds required",
    )
    
    # Preferences (optional filters)
    is_ac_required: Optional[bool] = Field(
        default=None,
        description="AC required",
    )
    attached_bathroom_required: Optional[bool] = Field(
        default=None,
        description="Attached bathroom required",
    )
    max_price_monthly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Maximum acceptable monthly rent",
    )

    @field_validator("check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """
        Validate check-in date.
        
        Ensures date is not too far in the past.
        """
        today = date.today()
        # Allow up to 7 days in the past for flexibility
        min_date = today - timedelta(days=7)
        
        if v < min_date:
            raise ValueError(
                "Check-in date cannot be more than 7 days in the past"
            )
        
        # Warn if too far in future (1 year)
        max_date = today + timedelta(days=365)
        if v > max_date:
            raise ValueError(
                "Check-in date cannot be more than 1 year in the future"
            )
        
        return v

    @computed_field
    @property
    def check_out_date(self) -> date:
        """Calculate checkout date based on duration."""
        # Approximate: 1 month = 30 days
        return self.check_in_date + timedelta(days=self.duration_months * 30)


class AvailableRoom(BaseSchema):
    """
    Available room details for booking.
    
    Comprehensive room information for availability results.
    """

    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    room_type: RoomType = Field(..., description="Room type")
    floor_number: Optional[int] = Field(default=None, description="Floor")
    wing: Optional[str] = Field(default=None, description="Wing/Block")
    
    # Availability
    available_beds: int = Field(..., ge=0, description="Available beds")
    total_beds: int = Field(..., ge=1, description="Total beds")
    
    # Pricing
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent per bed")
    price_quarterly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Quarterly rate",
    )
    price_half_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Half-yearly rate",
    )
    price_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Yearly rate",
    )
    
    # Features
    is_ac: bool = Field(..., description="Air conditioned")
    has_attached_bathroom: bool = Field(..., description="Attached bathroom")
    has_balcony: bool = Field(default=False, description="Has balcony")
    has_wifi: bool = Field(default=True, description="WiFi available")
    room_size_sqft: Optional[int] = Field(
        default=None,
        description="Room size",
    )
    
    # Amenities
    amenities: List[str] = Field(
        default_factory=list,
        description="Room amenities",
    )
    furnishing: List[str] = Field(
        default_factory=list,
        description="Furniture items",
    )
    
    # Media
    room_images: List[str] = Field(
        default_factory=list,
        description="Room images",
    )
    primary_image: Optional[str] = Field(
        default=None,
        description="Primary image URL",
    )

    @computed_field
    @property
    def occupancy_rate(self) -> Decimal:
        """Calculate current occupancy rate."""
        if self.total_beds == 0:
            return Decimal("0.00")
        occupied = self.total_beds - self.available_beds
        return Decimal((occupied / self.total_beds * 100)).quantize(
            Decimal("0.01")
        )


class AvailabilityResponse(BaseSchema):
    """
    Room availability response.
    
    Complete availability results with metadata.
    """

    hostel_id: str = Field(..., description="Hostel ID")
    check_in_date: date = Field(..., description="Requested check-in date")
    check_out_date: date = Field(..., description="Calculated checkout date")
    duration_months: int = Field(..., ge=1, description="Stay duration")
    
    # Results
    available_rooms: List[AvailableRoom] = Field(
        default_factory=list,
        description="List of available rooms",
    )
    total_available_beds: int = Field(
        ...,
        ge=0,
        description="Total available beds across all rooms",
    )
    has_availability: bool = Field(
        ...,
        description="Whether any beds are available",
    )
    
    # Filters applied
    filters_applied: Dict[str, any] = Field(
        default_factory=dict,
        description="Summary of applied filters",
    )

    @computed_field
    @property
    def total_rooms_available(self) -> int:
        """Count of rooms with availability."""
        return len(self.available_rooms)

    @computed_field
    @property
    def price_range(self) -> Optional[Dict[str, Decimal]]:
        """Calculate price range across available rooms."""
        if not self.available_rooms:
            return None
        
        prices = [room.price_monthly for room in self.available_rooms]
        return {
            "min": min(prices),
            "max": max(prices),
            "average": Decimal(sum(prices) / len(prices)).quantize(
                Decimal("0.01")
            ),
        }


class BookingInfo(BaseSchema):
    """
    Booking information for calendar display.
    
    Brief booking details for availability calendar.
    """

    booking_id: str = Field(..., description="Booking ID")
    student_name: str = Field(..., description="Student name")
    student_id: str = Field(..., description="Student ID")
    check_in_date: date = Field(..., description="Check-in date")
    check_out_date: date = Field(..., description="Check-out date")
    bed_number: Optional[str] = Field(
        default=None,
        description="Assigned bed number",
    )
    status: str = Field(..., description="Booking status")


class DayAvailability(BaseSchema):
    """
    Availability information for a specific day.
    
    Day-level availability with booking details.
    """

    date: date = Field(..., description="Date")
    available_beds: int = Field(..., ge=0, description="Available beds")
    total_beds: int = Field(..., ge=1, description="Total beds")
    is_available: bool = Field(..., description="Has availability")
    bookings: List[BookingInfo] = Field(
        default_factory=list,
        description="Active bookings for this day",
    )
    notes: Optional[str] = Field(
        default=None,
        description="Special notes (holidays, maintenance, etc.)",
    )

    @computed_field
    @property
    def occupancy_percentage(self) -> Decimal:
        """Calculate occupancy percentage for the day."""
        if self.total_beds == 0:
            return Decimal("0.00")
        occupied = self.total_beds - self.available_beds
        return Decimal((occupied / self.total_beds * 100)).quantize(
            Decimal("0.01")
        )


class AvailabilityCalendar(BaseSchema):
    """
    Availability calendar for a room.
    
    Month-view calendar showing daily availability.
    """

    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    month: str = Field(
        ...,
        pattern=r"^\d{4}-\d{2}$",
        description="Month in YYYY-MM format",
    )
    total_beds: int = Field(..., ge=1, description="Total beds in room")
    
    # Day-by-day availability
    availability: Dict[str, DayAvailability] = Field(
        ...,
        description="Availability by date (ISO date string as key)",
    )

    @field_validator("month")
    @classmethod
    def validate_month_format(cls, v: str) -> str:
        """Validate month format and range."""
        try:
            year, month = map(int, v.split("-"))
            if not (1 <= month <= 12):
                raise ValueError("Month must be between 01 and 12")
            if not (2000 <= year <= 2100):
                raise ValueError("Year must be between 2000 and 2100")
        except (ValueError, AttributeError) as e:
            raise ValueError(f"Invalid month format: {e}")
        return v

    @computed_field
    @property
    def average_occupancy(self) -> Decimal:
        """Calculate average occupancy for the month."""
        if not self.availability:
            return Decimal("0.00")
        
        total_occupancy = sum(
            day.occupancy_percentage for day in self.availability.values()
        )
        return Decimal(total_occupancy / len(self.availability)).quantize(
            Decimal("0.01")
        )

    @computed_field
    @property
    def fully_booked_days(self) -> int:
        """Count days with no availability."""
        return sum(
            1 for day in self.availability.values()
            if day.available_beds == 0
        )


class BulkAvailabilityRequest(BaseCreateSchema):
    """
    Request to check availability for multiple rooms/hostels.
    
    Batch availability checking for comparison or bulk operations.
    """

    hostel_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=10,
        description="List of hostel IDs (max 10)",
    )
    check_in_date: date = Field(
        ...,
        description="Check-in date",
    )
    duration_months: int = Field(
        ...,
        ge=1,
        le=24,
        description="Stay duration",
    )
    room_type: Optional[RoomType] = Field(
        default=None,
        description="Room type filter",
    )
    min_beds_per_hostel: int = Field(
        default=1,
        ge=1,
        description="Minimum beds required per hostel",
    )

    @field_validator("hostel_ids")
    @classmethod
    def validate_unique_hostel_ids(cls, v: List[str]) -> List[str]:
        """Ensure hostel IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Hostel IDs must be unique")
        return v

    @field_validator("check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date is not in the past."""
        today = date.today()
        if v < today - timedelta(days=7):
            raise ValueError(
                "Check-in date cannot be more than 7 days in the past"
            )
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\room\room_base.py ---
# --- File: app/schemas/room/room_base.py ---
"""
Room base schemas with enhanced validation and type safety.

Provides core room management schemas including creation, updates,
bulk operations, and pricing/status management.
"""

from __future__ import annotations

from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import RoomStatus, RoomType

__all__ = [
    "RoomBase",
    "RoomCreate",
    "RoomUpdate",
    "BulkRoomCreate",
    "RoomPricingUpdate",
    "RoomStatusUpdate",
    "RoomMediaUpdate",
]


class RoomBase(BaseSchema):
    """
    Base room schema with comprehensive room attributes.
    
    Contains common fields shared across room operations including
    specifications, pricing, amenities, and availability.
    """

    hostel_id: str = Field(
        ...,
        description="Hostel ID this room belongs to",
    )
    room_number: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Room number/identifier (e.g., '101', 'A-201')",
        examples=["101", "A-201", "Block-B-301"],
    )
    floor_number: Optional[int] = Field(
        default=None,
        ge=0,
        le=50,
        description="Floor number (0 for ground floor)",
    )
    wing: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Wing/Block designation (A, B, North Wing, etc.)",
        examples=["A", "B", "North Wing", "Block-1"],
    )

    # Type and capacity
    room_type: RoomType = Field(
        ...,
        description="Room occupancy type",
    )
    total_beds: int = Field(
        ...,
        ge=1,
        le=20,
        description="Total bed capacity in the room",
    )

    # Pricing (all in same currency as hostel)
    price_monthly: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Monthly rent amount",
    )
    price_quarterly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Quarterly rent (3 months, often discounted)",
    )
    price_half_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Half-yearly rent (6 months, often discounted)",
    )
    price_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Yearly rent (12 months, often discounted)",
    )

    # Physical specifications
    room_size_sqft: Optional[int] = Field(
        default=None,
        ge=50,
        le=1000,
        description="Room size in square feet",
    )
    is_ac: bool = Field(
        default=False,
        description="Air conditioning available",
    )
    has_attached_bathroom: bool = Field(
        default=False,
        description="Attached/ensuite bathroom",
    )
    has_balcony: bool = Field(
        default=False,
        description="Private balcony available",
    )
    has_wifi: bool = Field(
        default=True,
        description="WiFi connectivity available",
    )

    # Amenities and furnishing
    amenities: List[str] = Field(
        default_factory=list,
        description="Room-specific amenities (separate from general hostel amenities)",
        examples=[["Study Table", "Wardrobe", "Fan", "Geyser"]],
    )
    furnishing: List[str] = Field(
        default_factory=list,
        description="Furniture and fixtures provided",
        examples=[["Bed", "Mattress", "Study Table", "Chair", "Wardrobe"]],
    )

    # Availability and status
    is_available_for_booking: bool = Field(
        default=True,
        description="Available for online booking requests",
    )
    is_under_maintenance: bool = Field(
        default=False,
        description="Currently under maintenance",
    )

    # Media
    room_images: List[str] = Field(
        default_factory=list,
        max_length=15,
        description="Room image URLs (max 15)",
    )

    @field_validator("room_number")
    @classmethod
    def validate_room_number(cls, v: str) -> str:
        """
        Validate and normalize room number.
        
        Ensures room number is properly formatted and trimmed.
        """
        v = v.strip().upper()
        if not v:
            raise ValueError("Room number cannot be empty")
        # Remove excessive whitespace
        v = " ".join(v.split())
        return v

    @field_validator("wing")
    @classmethod
    def validate_wing(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize wing/block designation."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Remove excessive whitespace
            v = " ".join(v.split())
        return v

    @field_validator("amenities", "furnishing")
    @classmethod
    def validate_and_clean_lists(cls, v: List[str]) -> List[str]:
        """
        Validate and clean list fields.
        
        Removes empty strings, duplicates, and normalizes values.
        """
        if not v:
            return []
        # Clean and normalize
        cleaned = [item.strip() for item in v if item and item.strip()]
        # Remove duplicates while preserving order (case-insensitive)
        seen = set()
        unique = []
        for item in cleaned:
            item_lower = item.lower()
            if item_lower not in seen:
                seen.add(item_lower)
                unique.append(item)
        return unique

    @field_validator("room_images")
    @classmethod
    def validate_room_images(cls, v: List[str]) -> List[str]:
        """
        Validate room image URLs.
        
        Removes empty strings, duplicates, and validates URL format.
        """
        if not v:
            return []
        # Clean URLs
        cleaned = []
        seen = set()
        for url in v:
            if not url or not url.strip():
                continue
            url = url.strip()
            # Basic URL validation
            if not (url.startswith("http://") or url.startswith("https://")):
                continue
            # Remove duplicates
            if url not in seen:
                seen.add(url)
                cleaned.append(url)
        return cleaned[:15]  # Limit to 15 images

    @model_validator(mode="after")
    def validate_pricing_consistency(self) -> "RoomBase":
        """
        Validate pricing consistency and logical discounts.
        
        Ensures longer-term prices are not higher than monthly equivalent.
        """
        monthly = self.price_monthly
        
        # Validate quarterly pricing
        if self.price_quarterly is not None:
            monthly_equivalent = monthly * 3
            if self.price_quarterly > monthly_equivalent:
                raise ValueError(
                    f"Quarterly price ({self.price_quarterly}) should not exceed "
                    f"3x monthly price ({monthly_equivalent})"
                )
        
        # Validate half-yearly pricing
        if self.price_half_yearly is not None:
            monthly_equivalent = monthly * 6
            if self.price_half_yearly > monthly_equivalent:
                raise ValueError(
                    f"Half-yearly price ({self.price_half_yearly}) should not exceed "
                    f"6x monthly price ({monthly_equivalent})"
                )
        
        # Validate yearly pricing
        if self.price_yearly is not None:
            monthly_equivalent = monthly * 12
            if self.price_yearly > monthly_equivalent:
                raise ValueError(
                    f"Yearly price ({self.price_yearly}) should not exceed "
                    f"12x monthly price ({monthly_equivalent})"
                )
        
        return self

    @model_validator(mode="after")
    def validate_room_type_beds(self) -> "RoomBase":
        """
        Validate bed count matches room type expectations.
        
        Provides warnings for unusual configurations.
        """
        expected_beds = {
            RoomType.SINGLE: (1, 1),
            RoomType.DOUBLE: (2, 2),
            RoomType.TRIPLE: (3, 3),
            RoomType.FOUR_SHARING: (4, 4),
            RoomType.DORMITORY: (5, 20),
        }
        
        if self.room_type in expected_beds:
            min_beds, max_beds = expected_beds[self.room_type]
            if not (min_beds <= self.total_beds <= max_beds):
                # Note: We don't raise an error to allow flexibility
                # but this could be logged as a warning
                pass
        
        return self


class RoomCreate(RoomBase, BaseCreateSchema):
    """
    Schema for creating a new room.
    
    Enforces all required fields for room creation.
    """

    # Override to ensure required fields
    hostel_id: str = Field(
        ...,
        description="Hostel ID (required)",
    )
    room_number: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Room number (required)",
    )
    room_type: RoomType = Field(
        ...,
        description="Room type (required)",
    )
    total_beds: int = Field(
        ...,
        ge=1,
        le=20,
        description="Total beds (required)",
    )
    price_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Monthly rent (required)",
    )


class RoomUpdate(BaseUpdateSchema):
    """
    Schema for updating room information.
    
    All fields are optional for partial updates.
    """

    room_number: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=50,
        description="Room number",
    )
    floor_number: Optional[int] = Field(
        default=None,
        ge=0,
        le=50,
        description="Floor number",
    )
    wing: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Wing/Block",
    )
    room_type: Optional[RoomType] = Field(
        default=None,
        description="Room type",
    )
    total_beds: Optional[int] = Field(
        default=None,
        ge=1,
        le=20,
        description="Total beds",
    )

    # Pricing updates
    price_monthly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Monthly rent",
    )
    price_quarterly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Quarterly rent",
    )
    price_half_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Half-yearly rent",
    )
    price_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Yearly rent",
    )

    # Physical specifications
    room_size_sqft: Optional[int] = Field(
        default=None,
        ge=50,
        le=1000,
        description="Room size in sq ft",
    )
    is_ac: Optional[bool] = Field(
        default=None,
        description="Air conditioning",
    )
    has_attached_bathroom: Optional[bool] = Field(
        default=None,
        description="Attached bathroom",
    )
    has_balcony: Optional[bool] = Field(
        default=None,
        description="Balcony",
    )
    has_wifi: Optional[bool] = Field(
        default=None,
        description="WiFi",
    )

    # Amenities
    amenities: Optional[List[str]] = Field(
        default=None,
        description="Room amenities",
    )
    furnishing: Optional[List[str]] = Field(
        default=None,
        description="Furniture items",
    )

    # Availability
    is_available_for_booking: Optional[bool] = Field(
        default=None,
        description="Booking availability",
    )
    is_under_maintenance: Optional[bool] = Field(
        default=None,
        description="Maintenance status",
    )

    # Status
    status: Optional[RoomStatus] = Field(
        default=None,
        description="Room operational status",
    )

    # Media
    room_images: Optional[List[str]] = Field(
        default=None,
        max_length=15,
        description="Room image URLs",
    )

    # Apply same validators as base
    _validate_room_number = field_validator("room_number")(
        RoomBase.validate_room_number.__func__
    )
    _validate_wing = field_validator("wing")(RoomBase.validate_wing.__func__)
    _validate_lists = field_validator("amenities", "furnishing")(
        RoomBase.validate_and_clean_lists.__func__
    )
    _validate_images = field_validator("room_images")(
        RoomBase.validate_room_images.__func__
    )


class BulkRoomCreate(BaseCreateSchema):
    """
    Schema for bulk room creation.
    
    Allows creating multiple rooms in a single operation.
    Useful for initial hostel setup or adding multiple similar rooms.
    """

    hostel_id: str = Field(
        ...,
        description="Hostel ID for all rooms",
    )
    rooms: List[RoomCreate] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of rooms to create (max 100 per batch)",
    )

    @field_validator("rooms")
    @classmethod
    def validate_unique_room_numbers(cls, v: List[RoomCreate]) -> List[RoomCreate]:
        """
        Validate room numbers are unique within the batch.
        
        Prevents duplicate room numbers in bulk creation.
        """
        room_numbers = [room.room_number.strip().upper() for room in v]
        if len(room_numbers) != len(set(room_numbers)):
            raise ValueError("Room numbers must be unique within the batch")
        return v

    @field_validator("rooms")
    @classmethod
    def validate_consistent_hostel(cls, v: List[RoomCreate], info) -> List[RoomCreate]:
        """
        Validate all rooms belong to the same hostel.
        
        Ensures consistency in bulk operations.
        """
        hostel_id = info.data.get("hostel_id")
        if hostel_id:
            for room in v:
                if room.hostel_id != hostel_id:
                    raise ValueError(
                        f"All rooms must belong to hostel {hostel_id}. "
                        f"Found room with hostel_id: {room.hostel_id}"
                    )
        return v


class RoomPricingUpdate(BaseUpdateSchema):
    """
    Schema for updating room pricing.
    
    Dedicated schema for price updates with validation.
    """

    price_monthly: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Monthly rent (required)",
    )
    price_quarterly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Quarterly rent (optional discount)",
    )
    price_half_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Half-yearly rent (optional discount)",
    )
    price_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Yearly rent (optional discount)",
    )
    effective_from: Optional[date] = Field(
        default=None,
        description="Effective date for new pricing (optional)",
    )

    @model_validator(mode="after")
    def validate_pricing_logic(self) -> "RoomPricingUpdate":
        """Validate pricing consistency."""
        monthly = self.price_monthly

        if self.price_quarterly is not None:
            if self.price_quarterly > (monthly * 3):
                raise ValueError(
                    "Quarterly price should not exceed 3x monthly price"
                )

        if self.price_half_yearly is not None:
            if self.price_half_yearly > (monthly * 6):
                raise ValueError(
                    "Half-yearly price should not exceed 6x monthly price"
                )

        if self.price_yearly is not None:
            if self.price_yearly > (monthly * 12):
                raise ValueError(
                    "Yearly price should not exceed 12x monthly price"
                )

        return self

    @field_validator("effective_from")
    @classmethod
    def validate_effective_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate effective date is not in the past."""
        if v is not None:
            from datetime import date as dt
            if v < dt.today():
                raise ValueError("Effective date cannot be in the past")
        return v


class RoomStatusUpdate(BaseUpdateSchema):
    """
    Schema for updating room operational status.
    
    Manages room availability and maintenance status with proper tracking.
    """

    status: RoomStatus = Field(
        ...,
        description="Room operational status",
    )
    is_available_for_booking: bool = Field(
        ...,
        description="Available for online bookings",
    )
    is_under_maintenance: bool = Field(
        default=False,
        description="Currently under maintenance",
    )
    maintenance_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Maintenance details and notes",
    )
    maintenance_start_date: Optional[date] = Field(
        default=None,
        description="Maintenance start date",
    )
    maintenance_end_date: Optional[date] = Field(
        default=None,
        description="Expected maintenance completion date",
    )

    @model_validator(mode="after")
    def validate_maintenance_requirements(self) -> "RoomStatusUpdate":
        """
        Validate maintenance-related fields.
        
        Ensures proper documentation when room is under maintenance.
        """
        if self.is_under_maintenance or self.status == RoomStatus.MAINTENANCE:
            # Require maintenance notes when under maintenance
            if not self.maintenance_notes:
                raise ValueError(
                    "Maintenance notes are required when room is under maintenance"
                )
            # Require maintenance start date
            if not self.maintenance_start_date:
                raise ValueError(
                    "Maintenance start date is required when room is under maintenance"
                )
            # Set room as unavailable for booking
            if self.is_available_for_booking:
                raise ValueError(
                    "Room cannot be available for booking while under maintenance"
                )
        
        return self

    @model_validator(mode="after")
    def validate_maintenance_dates(self) -> "RoomStatusUpdate":
        """Validate maintenance date range."""
        if self.maintenance_start_date and self.maintenance_end_date:
            if self.maintenance_end_date < self.maintenance_start_date:
                raise ValueError(
                    "Maintenance end date must be after or equal to start date"
                )
        return self


class RoomMediaUpdate(BaseUpdateSchema):
    """
    Schema for updating room media (images).
    
    Dedicated schema for managing room photographs and virtual tours.
    """

    room_images: List[str] = Field(
        default_factory=list,
        max_length=15,
        description="Room image URLs (max 15)",
    )
    primary_image: Optional[str] = Field(
        default=None,
        description="Primary/cover image URL (must be in room_images)",
    )
    virtual_tour_url: Optional[str] = Field(
        default=None,
        description="360 virtual tour URL",
    )

    @field_validator("room_images")
    @classmethod
    def validate_room_images(cls, v: List[str]) -> List[str]:
        """Validate room image URLs."""
        if not v:
            return []
        
        cleaned = []
        seen = set()
        for url in v:
            if not url or not url.strip():
                continue
            url = url.strip()
            # Validate URL format
            if not (url.startswith("http://") or url.startswith("https://")):
                raise ValueError(f"Invalid image URL format: {url}")
            # Remove duplicates
            if url not in seen:
                seen.add(url)
                cleaned.append(url)
        
        return cleaned[:15]

    @model_validator(mode="after")
    def validate_primary_image(self) -> "RoomMediaUpdate":
        """Validate primary image is in room_images list."""
        if self.primary_image:
            if self.primary_image not in self.room_images:
                raise ValueError(
                    "Primary image must be one of the room images"
                )
        return self

    @field_validator("virtual_tour_url")
    @classmethod
    def validate_virtual_tour_url(cls, v: Optional[str]) -> Optional[str]:
        """Validate virtual tour URL format."""
        if v is not None:
            v = v.strip()
            if v and not (v.startswith("http://") or v.startswith("https://")):
                raise ValueError("Invalid virtual tour URL format")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\room\room_response.py ---
# --- File: app/schemas/room/room_response.py ---
"""
Room response schemas for API responses.

Provides various response formats for room data including
detailed views, list items, and statistics.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import BedStatus, RoomStatus, RoomType

__all__ = [
    "RoomResponse",
    "RoomDetail",
    "RoomListItem",
    "RoomWithBeds",
    "RoomOccupancyStats",
    "RoomFinancialSummary",
]


class RoomResponse(BaseResponseSchema):
    """
    Standard room response schema.
    
    Basic room information for general API responses.
    """

    hostel_id: str = Field(..., description="Hostel ID")
    room_number: str = Field(..., description="Room number")
    floor_number: Optional[int] = Field(default=None, description="Floor number")
    wing: Optional[str] = Field(default=None, description="Wing/Block")
    
    # Type and capacity
    room_type: RoomType = Field(..., description="Room type")
    total_beds: int = Field(..., ge=0, description="Total bed capacity")
    occupied_beds: int = Field(..., ge=0, description="Currently occupied beds")
    available_beds: int = Field(..., ge=0, description="Available beds")
    
    # Pricing
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent")
    
    # Features
    is_ac: bool = Field(..., description="Air conditioned")
    has_attached_bathroom: bool = Field(..., description="Attached bathroom")
    
    # Status
    status: RoomStatus = Field(..., description="Room status")
    is_available_for_booking: bool = Field(
        ...,
        description="Available for booking",
    )
    
    @computed_field
    @property
    def occupancy_percentage(self) -> Decimal:
        """Calculate occupancy percentage."""
        if self.total_beds == 0:
            return Decimal("0.00")
        return Decimal(
            (self.occupied_beds / self.total_beds * 100)
        ).quantize(Decimal("0.01"))


class BedDetail(BaseSchema):
    """
    Detailed bed information within a room.
    
    Provides complete bed status and assignment details.
    """

    id: str = Field(..., description="Bed ID")
    bed_number: str = Field(..., description="Bed identifier")
    is_occupied: bool = Field(..., description="Currently occupied")
    status: BedStatus = Field(..., description="Bed status")
    
    # Current occupant
    current_student_id: Optional[str] = Field(
        default=None,
        description="Current student ID (if occupied)",
    )
    current_student_name: Optional[str] = Field(
        default=None,
        description="Current student name (if occupied)",
    )
    occupied_from: Optional[date] = Field(
        default=None,
        description="Occupancy start date",
    )
    expected_vacate_date: Optional[date] = Field(
        default=None,
        description="Expected checkout date",
    )
    
    # Additional info
    last_maintenance_date: Optional[date] = Field(
        default=None,
        description="Last maintenance date",
    )
    notes: Optional[str] = Field(
        default=None,
        description="Bed notes",
    )


class RoomDetail(BaseResponseSchema):
    """
    Detailed room information.
    
    Comprehensive room data including all specifications,
    amenities, and bed details.
    """

    # Basic info
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    room_number: str = Field(..., description="Room number")
    floor_number: Optional[int] = Field(default=None, description="Floor number")
    wing: Optional[str] = Field(default=None, description="Wing/Block")

    # Type and capacity
    room_type: RoomType = Field(..., description="Room type")
    total_beds: int = Field(..., ge=0, description="Total beds")
    occupied_beds: int = Field(..., ge=0, description="Occupied beds")
    available_beds: int = Field(..., ge=0, description="Available beds")

    # Pricing
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent")
    price_quarterly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Quarterly rent",
    )
    price_half_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Half-yearly rent",
    )
    price_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Yearly rent",
    )

    # Specifications
    room_size_sqft: Optional[int] = Field(
        default=None,
        description="Room size in sq ft",
    )
    is_ac: bool = Field(..., description="Air conditioned")
    has_attached_bathroom: bool = Field(..., description="Attached bathroom")
    has_balcony: bool = Field(..., description="Has balcony")
    has_wifi: bool = Field(..., description="WiFi available")

    # Amenities
    amenities: List[str] = Field(
        default_factory=list,
        description="Room amenities",
    )
    furnishing: List[str] = Field(
        default_factory=list,
        description="Furniture items",
    )

    # Status
    status: RoomStatus = Field(..., description="Room status")
    is_available_for_booking: bool = Field(
        ...,
        description="Available for booking",
    )
    is_under_maintenance: bool = Field(
        ...,
        description="Under maintenance",
    )
    maintenance_start_date: Optional[date] = Field(
        default=None,
        description="Maintenance start date",
    )
    maintenance_end_date: Optional[date] = Field(
        default=None,
        description="Expected maintenance end date",
    )
    maintenance_notes: Optional[str] = Field(
        default=None,
        description="Maintenance notes",
    )

    # Media
    room_images: List[str] = Field(
        default_factory=list,
        description="Room image URLs",
    )
    primary_image: Optional[str] = Field(
        default=None,
        description="Primary/cover image",
    )
    virtual_tour_url: Optional[str] = Field(
        default=None,
        description="Virtual tour URL",
    )

    # Beds detail
    beds: List[BedDetail] = Field(
        default_factory=list,
        description="Detailed bed information",
    )

    @computed_field
    @property
    def occupancy_percentage(self) -> Decimal:
        """Calculate current occupancy percentage."""
        if self.total_beds == 0:
            return Decimal("0.00")
        return Decimal(
            (self.occupied_beds / self.total_beds * 100)
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_fully_occupied(self) -> bool:
        """Check if room is fully occupied."""
        return self.occupied_beds >= self.total_beds

    @computed_field
    @property
    def discount_percentage_quarterly(self) -> Optional[Decimal]:
        """Calculate quarterly discount percentage."""
        if not self.price_quarterly:
            return None
        monthly_equivalent = self.price_monthly * 3
        if monthly_equivalent == 0:
            return None
        discount = (
            (monthly_equivalent - self.price_quarterly) / monthly_equivalent * 100
        )
        return Decimal(discount).quantize(Decimal("0.01"))

    @computed_field
    @property
    def discount_percentage_yearly(self) -> Optional[Decimal]:
        """Calculate yearly discount percentage."""
        if not self.price_yearly:
            return None
        monthly_equivalent = self.price_monthly * 12
        if monthly_equivalent == 0:
            return None
        discount = (
            (monthly_equivalent - self.price_yearly) / monthly_equivalent * 100
        )
        return Decimal(discount).quantize(Decimal("0.01"))


class RoomListItem(BaseSchema):
    """
    Room list item for list views.
    
    Minimal room information for efficient list rendering.
    """

    id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    floor_number: Optional[int] = Field(default=None, description="Floor")
    wing: Optional[str] = Field(default=None, description="Wing")
    room_type: RoomType = Field(..., description="Room type")
    total_beds: int = Field(..., ge=0, description="Total beds")
    available_beds: int = Field(..., ge=0, description="Available beds")
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent")
    is_ac: bool = Field(..., description="AC available")
    status: RoomStatus = Field(..., description="Status")
    is_available_for_booking: bool = Field(..., description="Bookable")
    primary_image: Optional[str] = Field(default=None, description="Cover image")

    @computed_field
    @property
    def occupancy_percentage(self) -> Decimal:
        """Calculate occupancy percentage."""
        if self.total_beds == 0:
            return Decimal("0.00")
        occupied = self.total_beds - self.available_beds
        return Decimal((occupied / self.total_beds * 100)).quantize(
            Decimal("0.01")
        )


class BedInfo(BaseSchema):
    """
    Brief bed information for room overview.
    
    Simplified bed data for quick views.
    """

    id: str = Field(..., description="Bed ID")
    bed_number: str = Field(..., description="Bed number")
    is_occupied: bool = Field(..., description="Occupied status")
    status: BedStatus = Field(..., description="Bed status")
    student_name: Optional[str] = Field(
        default=None,
        description="Occupant name (if applicable)",
    )
    occupied_from: Optional[date] = Field(
        default=None,
        description="Occupancy start date",
    )


class RoomWithBeds(BaseResponseSchema):
    """
    Room with bed information.
    
    Room overview with bed-level details.
    """

    hostel_id: str = Field(..., description="Hostel ID")
    room_number: str = Field(..., description="Room number")
    room_type: RoomType = Field(..., description="Room type")
    total_beds: int = Field(..., ge=0, description="Total beds")
    occupied_beds: int = Field(..., ge=0, description="Occupied beds")
    available_beds: int = Field(..., ge=0, description="Available beds")
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent")
    beds: List[BedInfo] = Field(
        default_factory=list,
        description="Bed details",
    )

    @computed_field
    @property
    def occupancy_rate(self) -> Decimal:
        """Calculate occupancy rate."""
        if self.total_beds == 0:
            return Decimal("0.00")
        return Decimal(
            (self.occupied_beds / self.total_beds * 100)
        ).quantize(Decimal("0.01"))


class RoomOccupancyStats(BaseSchema):
    """
    Room occupancy statistics.
    
    Provides occupancy metrics and revenue calculations.
    """

    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    room_type: RoomType = Field(..., description="Room type")
    
    # Capacity
    total_beds: int = Field(..., ge=0, description="Total beds")
    occupied_beds: int = Field(..., ge=0, description="Occupied beds")
    available_beds: int = Field(..., ge=0, description="Available beds")
    reserved_beds: int = Field(
        default=0,
        ge=0,
        description="Reserved beds",
    )
    
    # Revenue
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent per bed")
    current_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Current monthly revenue",
    )
    potential_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Potential revenue at full capacity",
    )
    
    # Status
    status: RoomStatus = Field(..., description="Room status")
    is_available_for_booking: bool = Field(..., description="Booking availability")
    
    # Timestamps
    last_occupancy_change: Optional[datetime] = Field(
        default=None,
        description="Last occupancy change timestamp",
    )

    @computed_field
    @property
    def occupancy_percentage(self) -> Decimal:
        """Calculate occupancy percentage."""
        if self.total_beds == 0:
            return Decimal("0.00")
        return Decimal(
            (self.occupied_beds / self.total_beds * 100)
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def revenue_percentage(self) -> Decimal:
        """Calculate revenue realization percentage."""
        if self.potential_revenue == 0:
            return Decimal("0.00")
        return Decimal(
            (self.current_revenue / self.potential_revenue * 100)
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def lost_revenue(self) -> Decimal:
        """Calculate lost revenue due to vacancy."""
        return self.potential_revenue - self.current_revenue


class RoomFinancialSummary(BaseSchema):
    """
    Room financial summary.
    
    Provides detailed financial metrics for a room.
    """

    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    
    # Pricing
    price_monthly_per_bed: Decimal = Field(
        ...,
        ge=0,
        description="Monthly rent per bed",
    )
    total_beds: int = Field(..., ge=0, description="Total beds")
    occupied_beds: int = Field(..., ge=0, description="Occupied beds")
    
    # Current month
    current_month_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Current month revenue",
    )
    current_month_collected: Decimal = Field(
        ...,
        ge=0,
        description="Amount collected this month",
    )
    current_month_pending: Decimal = Field(
        ...,
        ge=0,
        description="Amount pending this month",
    )
    
    # Historical
    total_revenue_ytd: Decimal = Field(
        ...,
        ge=0,
        description="Year-to-date total revenue",
    )
    total_collected_ytd: Decimal = Field(
        ...,
        ge=0,
        description="Year-to-date collected amount",
    )
    average_occupancy_ytd: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Year-to-date average occupancy %",
    )
    
    # Projections
    projected_monthly_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Projected revenue at current occupancy",
    )
    projected_yearly_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Projected yearly revenue",
    )

    @computed_field
    @property
    def collection_rate(self) -> Decimal:
        """Calculate collection rate for current month."""
        if self.current_month_revenue == 0:
            return Decimal("100.00")
        return Decimal(
            (self.current_month_collected / self.current_month_revenue * 100)
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def occupancy_rate(self) -> Decimal:
        """Calculate current occupancy rate."""
        if self.total_beds == 0:
            return Decimal("0.00")
        return Decimal(
            (self.occupied_beds / self.total_beds * 100)
        ).quantize(Decimal("0.01"))

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\room\__init__.py ---
# --- File: app/schemas/room/__init__.py ---
"""
Room schemas package.

Re-exports commonly used room and bed-related schemas for convenient imports.

Example:
    from app.schemas.room import RoomCreate, BedAssignment, AvailabilityResponse
"""

from __future__ import annotations

from app.schemas.room.bed_base import (
    BedAssignmentRequest,
    BedBase,
    BedCreate,
    BedReleaseRequest,
    BedSwapRequest,
    BedUpdate,
    BulkBedCreate,
    BulkBedStatusUpdate,
)
from app.schemas.room.bed_response import (
    BedAssignment,
    BedAssignmentHistory,
    BedAvailability,
    BedDetailedStatus,
    BedHistory,
    BedResponse,
)
from app.schemas.room.room_availability import (
    AvailabilityCalendar,
    AvailabilityResponse,
    AvailableRoom,
    BulkAvailabilityRequest,
    DayAvailability,
    RoomAvailabilityRequest,
)
from app.schemas.room.room_base import (
    BulkRoomCreate,
    RoomBase,
    RoomCreate,
    RoomMediaUpdate,
    RoomPricingUpdate,
    RoomStatusUpdate,
    RoomUpdate,
)
from app.schemas.room.room_response import (
    BedDetail,
    BedInfo,
    RoomDetail,
    RoomFinancialSummary,
    RoomListItem,
    RoomOccupancyStats,
    RoomResponse,
    RoomWithBeds,
)

__all__ = [
    # Room base
    "RoomBase",
    "RoomCreate",
    "RoomUpdate",
    "BulkRoomCreate",
    "RoomPricingUpdate",
    "RoomStatusUpdate",
    "RoomMediaUpdate",
    # Room response
    "RoomResponse",
    "RoomDetail",
    "RoomListItem",
    "RoomWithBeds",
    "RoomOccupancyStats",
    "RoomFinancialSummary",
    "BedDetail",
    "BedInfo",
    # Bed base
    "BedBase",
    "BedCreate",
    "BedUpdate",
    "BulkBedCreate",
    "BedAssignmentRequest",
    "BedReleaseRequest",
    "BedSwapRequest",
    "BulkBedStatusUpdate",
    # Bed response
    "BedResponse",
    "BedAvailability",
    "BedAssignment",
    "BedHistory",
    "BedAssignmentHistory",
    "BedDetailedStatus",
    # Availability
    "RoomAvailabilityRequest",
    "AvailabilityResponse",
    "AvailableRoom",
    "AvailabilityCalendar",
    "DayAvailability",
    "BulkAvailabilityRequest",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\room\bed_base.py ---
# --- File: app/schemas/room/bed_base.py ---
"""
Bed base schemas with enhanced validation and assignment management.

Provides schemas for individual bed management, bulk operations,
assignments, and releases.
"""

from __future__ import annotations

from datetime import date
from typing import List, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import BedStatus

__all__ = [
    "BedBase",
    "BedCreate",
    "BedUpdate",
    "BulkBedCreate",
    "BedAssignmentRequest",
    "BedReleaseRequest",
    "BedSwapRequest",
    "BulkBedStatusUpdate",
]


class BedBase(BaseSchema):
    """
    Base bed schema with core bed attributes.
    
    Represents an individual bed/berth within a room.
    """

    room_id: str = Field(
        ...,
        description="Room ID this bed belongs to",
    )
    bed_number: str = Field(
        ...,
        min_length=1,
        max_length=10,
        description="Bed identifier within room (A1, B2, Bed-1, etc.)",
        examples=["A1", "B2", "Bed-1", "Upper-1"],
    )
    status: BedStatus = Field(
        default=BedStatus.AVAILABLE,
        description="Current bed status",
    )

    @field_validator("bed_number")
    @classmethod
    def validate_bed_number(cls, v: str) -> str:
        """
        Validate and normalize bed number.
        
        Ensures consistent bed number format.
        """
        v = v.strip().upper()
        if not v:
            raise ValueError("Bed number cannot be empty")
        # Remove excessive whitespace
        v = " ".join(v.split())
        return v


class BedCreate(BedBase, BaseCreateSchema):
    """
    Schema for creating a single bed.
    
    Used when manually adding beds to a room.
    """

    # Override to ensure required fields
    room_id: str = Field(
        ...,
        description="Room ID (required)",
    )
    bed_number: str = Field(
        ...,
        min_length=1,
        max_length=10,
        description="Bed number (required)",
    )


class BedUpdate(BaseUpdateSchema):
    """
    Schema for updating bed information.
    
    Allows partial updates to bed attributes.
    """

    bed_number: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=10,
        description="Bed identifier",
    )
    status: Optional[BedStatus] = Field(
        default=None,
        description="Bed status",
    )
    is_occupied: Optional[bool] = Field(
        default=None,
        description="Occupancy status (legacy, prefer using status)",
    )
    notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Additional notes about the bed",
    )

    @field_validator("bed_number")
    @classmethod
    def validate_bed_number(cls, v: Optional[str]) -> Optional[str]:
        """Validate bed number format."""
        if v is not None:
            v = v.strip().upper()
            if not v:
                raise ValueError("Bed number cannot be empty")
            v = " ".join(v.split())
        return v

    @model_validator(mode="after")
    def sync_status_with_occupancy(self) -> "BedUpdate":
        """
        Sync legacy is_occupied with status field.
        
        Maintains backward compatibility.
        """
        if self.is_occupied is not None:
            if self.is_occupied:
                self.status = BedStatus.OCCUPIED
            else:
                # Only set to available if not in maintenance/reserved
                if self.status in [BedStatus.OCCUPIED, None]:
                    self.status = BedStatus.AVAILABLE
        return self


class BulkBedCreate(BaseCreateSchema):
    """
    Schema for bulk bed creation.
    
    Automatically creates multiple beds for a room with sequential numbering.
    Useful for initial room setup.
    """

    room_id: str = Field(
        ...,
        description="Room ID to create beds for",
    )
    bed_count: int = Field(
        ...,
        ge=1,
        le=20,
        description="Number of beds to create (1-20)",
    )
    bed_prefix: str = Field(
        default="B",
        min_length=1,
        max_length=5,
        description="Prefix for bed numbers (e.g., 'B', 'BED', 'A')",
        examples=["B", "BED", "A", "BERTH"],
    )
    start_number: int = Field(
        default=1,
        ge=1,
        le=100,
        description="Starting number for bed sequence",
    )
    number_format: str = Field(
        default="{prefix}{number}",
        description="Format string for bed numbers (use {prefix} and {number})",
        examples=["{prefix}{number}", "{prefix}-{number}", "Bed-{number}"],
    )

    @field_validator("bed_prefix")
    @classmethod
    def validate_bed_prefix(cls, v: str) -> str:
        """Validate and normalize bed prefix."""
        v = v.strip().upper()
        if not v:
            raise ValueError("Bed prefix cannot be empty")
        # Only alphanumeric characters
        if not v.replace("-", "").replace("_", "").isalnum():
            raise ValueError(
                "Bed prefix can only contain alphanumeric characters, hyphens, and underscores"
            )
        return v

    @field_validator("number_format")
    @classmethod
    def validate_number_format(cls, v: str) -> str:
        """Validate number format string."""
        if "{number}" not in v:
            raise ValueError("Number format must contain {number} placeholder")
        # Validate format string can be used
        try:
            test = v.format(prefix="TEST", number=1)
        except KeyError as e:
            raise ValueError(f"Invalid placeholder in format string: {e}")
        return v

    def generate_bed_numbers(self) -> List[str]:
        """
        Generate bed numbers based on configuration.
        
        Returns:
            List of bed numbers to create
        """
        bed_numbers = []
        for i in range(self.bed_count):
            bed_num = self.number_format.format(
                prefix=self.bed_prefix,
                number=self.start_number + i
            )
            bed_numbers.append(bed_num)
        return bed_numbers


class BedAssignmentRequest(BaseCreateSchema):
    """
    Schema for assigning a bed to a student.
    
    Creates a bed assignment with proper date tracking.
    """

    bed_id: str = Field(
        ...,
        description="Bed ID to assign",
    )
    student_id: str = Field(
        ...,
        description="Student ID to assign bed to",
    )
    occupied_from: date = Field(
        ...,
        description="Occupancy start date",
    )
    expected_vacate_date: Optional[date] = Field(
        default=None,
        description="Expected vacate/checkout date (optional)",
    )
    booking_id: Optional[str] = Field(
        default=None,
        description="Related booking ID (if applicable)",
    )
    notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Assignment notes",
    )

    @field_validator("occupied_from")
    @classmethod
    def validate_occupied_from(cls, v: date) -> date:
        """
        Validate occupancy start date.
        
        Allows past dates for historical assignments but warns for future dates.
        """
        from datetime import date as dt
        
        # Allow past dates for historical data entry
        # Could add warning logic here if needed
        
        return v

    @model_validator(mode="after")
    def validate_date_range(self) -> "BedAssignmentRequest":
        """Validate expected vacate date is after occupied_from."""
        if self.expected_vacate_date:
            if self.expected_vacate_date <= self.occupied_from:
                raise ValueError(
                    "Expected vacate date must be after occupancy start date"
                )
        return self


class BedReleaseRequest(BaseCreateSchema):
    """
    Schema for releasing a bed from a student.
    
    Handles bed checkout/vacating with proper documentation.
    """

    bed_id: str = Field(
        ...,
        description="Bed ID to release",
    )
    student_id: Optional[str] = Field(
        default=None,
        description="Student ID (optional, for validation)",
    )
    release_date: date = Field(
        ...,
        description="Actual release/checkout date",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for release",
        examples=[
            "Completed stay",
            "Early checkout",
            "Transferred to another room",
            "Hostel exit",
        ],
    )
    condition_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Bed/room condition notes at checkout",
    )
    damages_reported: bool = Field(
        default=False,
        description="Whether any damages were reported",
    )

    @field_validator("release_date")
    @classmethod
    def validate_release_date(cls, v: date) -> date:
        """
        Validate release date.
        
        Allows past dates for historical entries.
        """
        # Allow past dates for data entry
        # Future dates might be allowed for scheduled releases
        return v


class BedSwapRequest(BaseCreateSchema):
    """
    Schema for swapping beds between students.
    
    Handles bed exchanges with proper tracking.
    """

    student_1_id: str = Field(
        ...,
        description="First student ID",
    )
    bed_1_id: str = Field(
        ...,
        description="First student's current bed ID",
    )
    student_2_id: str = Field(
        ...,
        description="Second student ID",
    )
    bed_2_id: str = Field(
        ...,
        description="Second student's current bed ID",
    )
    swap_date: date = Field(
        ...,
        description="Date of bed swap",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for swap",
        examples=[
            "Student request",
            "Compatibility issues",
            "Room preference",
            "Administrative decision",
        ],
    )
    approved_by: Optional[str] = Field(
        default=None,
        description="Admin/supervisor who approved the swap",
    )

    @field_validator("swap_date")
    @classmethod
    def validate_swap_date(cls, v: date) -> date:
        """Validate swap date is not too far in the past."""
        from datetime import date as dt, timedelta
        
        # Warn if swap date is more than 30 days in the past
        if v < dt.today() - timedelta(days=30):
            # Could log a warning here
            pass
        
        return v

    @model_validator(mode="after")
    def validate_different_students_and_beds(self) -> "BedSwapRequest":
        """Ensure students and beds are different."""
        if self.student_1_id == self.student_2_id:
            raise ValueError("Cannot swap beds for the same student")
        
        if self.bed_1_id == self.bed_2_id:
            raise ValueError("Cannot swap the same bed")
        
        return self


class BulkBedStatusUpdate(BaseCreateSchema):
    """
    Schema for bulk bed status updates.
    
    Allows updating status of multiple beds simultaneously.
    Useful for maintenance or availability updates.
    """

    bed_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of bed IDs to update (max 50)",
    )
    status: BedStatus = Field(
        ...,
        description="New status for all beds",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for bulk status change",
    )
    effective_date: Optional[date] = Field(
        default=None,
        description="Effective date for status change",
    )

    @field_validator("bed_ids")
    @classmethod
    def validate_unique_bed_ids(cls, v: List[str]) -> List[str]:
        """Ensure bed IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Bed IDs must be unique")
        return v

    @model_validator(mode="after")
    def validate_status_change(self) -> "BulkBedStatusUpdate":
        """Validate status change requirements."""
        # If setting to maintenance, require reason
        if self.status == BedStatus.MAINTENANCE and not self.reason:
            raise ValueError(
                "Reason is required when setting beds to maintenance status"
            )
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\room\bed_response.py ---
# --- File: app/schemas/room/bed_response.py ---
"""
Bed response schemas for API responses.

Provides various response formats for bed data including
availability, assignments, and history.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import BedStatus

__all__ = [
    "BedResponse",
    "BedAvailability",
    "BedAssignment",
    "BedHistory",
    "BedAssignmentHistory",
    "BedDetailedStatus",
]


class BedResponse(BaseResponseSchema):
    """
    Standard bed response schema.
    
    Basic bed information for general API responses.
    """

    room_id: str = Field(..., description="Room ID")
    bed_number: str = Field(..., description="Bed identifier")
    is_occupied: bool = Field(..., description="Currently occupied")
    status: BedStatus = Field(..., description="Bed status")
    current_student_id: Optional[str] = Field(
        default=None,
        description="Current occupant ID",
    )
    occupied_from: Optional[date] = Field(
        default=None,
        description="Occupancy start date",
    )

    @computed_field
    @property
    def is_available(self) -> bool:
        """Check if bed is available for assignment."""
        return self.status == BedStatus.AVAILABLE and not self.is_occupied


class BedAvailability(BaseSchema):
    """
    Bed availability information.
    
    Detailed availability status for booking purposes.
    """

    bed_id: str = Field(..., description="Bed ID")
    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    bed_number: str = Field(..., description="Bed identifier")
    
    # Availability
    is_available: bool = Field(..., description="Available for assignment")
    status: BedStatus = Field(..., description="Current status")
    available_from: Optional[date] = Field(
        default=None,
        description="Date when bed becomes available",
    )
    
    # Current occupant (if any)
    current_student_name: Optional[str] = Field(
        default=None,
        description="Current occupant name",
    )
    current_student_id: Optional[str] = Field(
        default=None,
        description="Current occupant ID",
    )
    expected_vacate_date: Optional[date] = Field(
        default=None,
        description="Expected checkout date",
    )
    
    # Room info
    room_type: str = Field(..., description="Room type")
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent")
    is_ac: bool = Field(..., description="AC available in room")
    has_attached_bathroom: bool = Field(
        ...,
        description="Attached bathroom",
    )

    @computed_field
    @property
    def days_until_available(self) -> Optional[int]:
        """Calculate days until bed becomes available."""
        if not self.available_from:
            return None
        if self.is_available:
            return 0
        today = date.today()
        if self.available_from <= today:
            return 0
        return (self.available_from - today).days


class BedAssignment(BaseResponseSchema):
    """
    Bed assignment details.
    
    Complete information about a bed assignment.
    """

    bed_id: str = Field(..., description="Bed ID")
    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    bed_number: str = Field(..., description="Bed identifier")
    
    # Student info
    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")
    student_email: Optional[str] = Field(
        default=None,
        description="Student email",
    )
    student_phone: Optional[str] = Field(
        default=None,
        description="Student phone",
    )
    
    # Assignment dates
    occupied_from: date = Field(..., description="Occupancy start date")
    expected_vacate_date: Optional[date] = Field(
        default=None,
        description="Expected checkout date",
    )
    actual_vacate_date: Optional[date] = Field(
        default=None,
        description="Actual checkout date (if completed)",
    )
    
    # Pricing
    monthly_rent: Decimal = Field(..., ge=0, description="Monthly rent amount")
    
    # Related records
    booking_id: Optional[str] = Field(
        default=None,
        description="Related booking ID",
    )
    
    # Status
    is_active: bool = Field(
        default=True,
        description="Assignment is currently active",
    )
    
    # Metadata
    assigned_at: datetime = Field(..., description="Assignment timestamp")
    assigned_by: Optional[str] = Field(
        default=None,
        description="Admin who created assignment",
    )
    notes: Optional[str] = Field(
        default=None,
        description="Assignment notes",
    )

    @computed_field
    @property
    def days_occupied(self) -> int:
        """Calculate days occupied."""
        end_date = self.actual_vacate_date or date.today()
        return (end_date - self.occupied_from).days

    @computed_field
    @property
    def expected_duration_days(self) -> Optional[int]:
        """Calculate expected duration in days."""
        if not self.expected_vacate_date:
            return None
        return (self.expected_vacate_date - self.occupied_from).days


class BedAssignmentHistory(BaseSchema):
    """
    Individual bed assignment history entry.
    
    Historical record of a single bed assignment.
    """

    assignment_id: str = Field(..., description="Assignment ID")
    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")
    move_in_date: date = Field(..., description="Move-in date")
    move_out_date: Optional[date] = Field(
        default=None,
        description="Move-out date (null if current)",
    )
    duration_days: Optional[int] = Field(
        default=None,
        description="Total duration in days",
    )
    monthly_rent: Decimal = Field(..., ge=0, description="Monthly rent paid")
    total_rent_paid: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Total rent paid during stay",
    )
    is_current: bool = Field(
        default=False,
        description="Currently active assignment",
    )

    @computed_field
    @property
    def duration_months(self) -> Optional[Decimal]:
        """Calculate duration in months."""
        if self.duration_days is None:
            return None
        return Decimal(self.duration_days / 30).quantize(Decimal("0.1"))


class BedHistory(BaseSchema):
    """
    Complete bed occupancy history.
    
    Historical timeline of all assignments for a bed.
    """

    bed_id: str = Field(..., description="Bed ID")
    room_number: str = Field(..., description="Room number")
    bed_number: str = Field(..., description="Bed identifier")
    
    # Current status
    current_status: BedStatus = Field(..., description="Current bed status")
    is_currently_occupied: bool = Field(
        ...,
        description="Currently occupied",
    )
    
    # Assignment history
    assignments: List[BedAssignmentHistory] = Field(
        default_factory=list,
        description="Historical assignments (newest first)",
    )
    
    # Statistics
    total_assignments: int = Field(
        default=0,
        ge=0,
        description="Total number of assignments",
    )
    total_occupancy_days: int = Field(
        default=0,
        ge=0,
        description="Total days occupied",
    )
    average_stay_duration_days: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Average stay duration",
    )
    last_occupied_date: Optional[date] = Field(
        default=None,
        description="Last occupancy date",
    )

    @computed_field
    @property
    def utilization_rate(self) -> Optional[Decimal]:
        """
        Calculate utilization rate since first assignment.
        
        Returns percentage of time bed has been occupied.
        """
        if not self.assignments:
            return None
        
        # Get earliest assignment
        earliest = min(a.move_in_date for a in self.assignments)
        total_days = (date.today() - earliest).days
        
        if total_days == 0:
            return None
        
        return Decimal(
            (self.total_occupancy_days / total_days * 100)
        ).quantize(Decimal("0.01"))


class BedDetailedStatus(BaseResponseSchema):
    """
    Detailed bed status with comprehensive information.
    
    Extended bed information including maintenance and condition.
    """

    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    bed_number: str = Field(..., description="Bed identifier")
    
    # Status
    status: BedStatus = Field(..., description="Current status")
    is_occupied: bool = Field(..., description="Occupied flag")
    is_available: bool = Field(..., description="Available for assignment")
    
    # Current assignment
    current_student_id: Optional[str] = Field(
        default=None,
        description="Current student ID",
    )
    current_student_name: Optional[str] = Field(
        default=None,
        description="Current student name",
    )
    occupied_from: Optional[date] = Field(
        default=None,
        description="Current occupancy start date",
    )
    expected_vacate_date: Optional[date] = Field(
        default=None,
        description="Expected checkout date",
    )
    
    # Maintenance
    last_maintenance_date: Optional[date] = Field(
        default=None,
        description="Last maintenance date",
    )
    next_scheduled_maintenance: Optional[date] = Field(
        default=None,
        description="Next scheduled maintenance",
    )
    maintenance_notes: Optional[str] = Field(
        default=None,
        description="Maintenance notes",
    )
    
    # Condition
    condition_rating: Optional[int] = Field(
        default=None,
        ge=1,
        le=5,
        description="Condition rating (1-5, 5 being excellent)",
    )
    last_inspection_date: Optional[date] = Field(
        default=None,
        description="Last inspection date",
    )
    reported_issues: List[str] = Field(
        default_factory=list,
        description="Currently reported issues",
    )
    
    # History stats
    total_assignments: int = Field(
        default=0,
        ge=0,
        description="Total historical assignments",
    )
    average_stay_duration_days: Optional[int] = Field(
        default=None,
        ge=0,
        description="Average stay duration",
    )
    
    # Metadata
    notes: Optional[str] = Field(
        default=None,
        description="General notes",
    )
    last_status_change: Optional[datetime] = Field(
        default=None,
        description="Last status change timestamp",
    )

    @computed_field
    @property
    def needs_maintenance(self) -> bool:
        """Check if bed needs maintenance."""
        # Needs maintenance if:
        # 1. Status is maintenance
        # 2. Has reported issues
        # 3. Condition rating is low (1-2)
        if self.status == BedStatus.MAINTENANCE:
            return True
        if self.reported_issues:
            return True
        if self.condition_rating and self.condition_rating <= 2:
            return True
        return False

    @computed_field
    @property
    def current_occupancy_days(self) -> Optional[int]:
        """Calculate days of current occupancy."""
        if not self.occupied_from:
            return None
        return (date.today() - self.occupied_from).days

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\room\room_availability.py ---
# --- File: app/schemas/room/room_availability.py ---
"""
Room availability schemas with enhanced date validation.

Provides schemas for checking room availability, calendar views,
and booking-related information.
"""

from __future__ import annotations

from datetime import date, timedelta
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, model_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import RoomType

__all__ = [
    "RoomAvailabilityRequest",
    "AvailabilityResponse",
    "AvailableRoom",
    "AvailabilityCalendar",
    "DayAvailability",
    "BookingInfo",
    "BulkAvailabilityRequest",
]


class RoomAvailabilityRequest(BaseCreateSchema):
    """
    Request to check room availability.
    
    Validates dates and duration for availability checking.
    """

    hostel_id: str = Field(
        ...,
        description="Hostel ID to check availability for",
    )
    check_in_date: date = Field(
        ...,
        description="Desired check-in date",
    )
    duration_months: int = Field(
        ...,
        ge=1,
        le=24,
        description="Stay duration in months (1-24)",
    )
    room_type: Optional[RoomType] = Field(
        default=None,
        description="Preferred room type (optional filter)",
    )
    min_beds: int = Field(
        default=1,
        ge=1,
        le=20,
        description="Minimum beds required",
    )
    
    # Preferences (optional filters)
    is_ac_required: Optional[bool] = Field(
        default=None,
        description="AC required",
    )
    attached_bathroom_required: Optional[bool] = Field(
        default=None,
        description="Attached bathroom required",
    )
    max_price_monthly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Maximum acceptable monthly rent",
    )

    @field_validator("check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """
        Validate check-in date.
        
        Ensures date is not too far in the past.
        """
        today = date.today()
        # Allow up to 7 days in the past for flexibility
        min_date = today - timedelta(days=7)
        
        if v < min_date:
            raise ValueError(
                "Check-in date cannot be more than 7 days in the past"
            )
        
        # Warn if too far in future (1 year)
        max_date = today + timedelta(days=365)
        if v > max_date:
            raise ValueError(
                "Check-in date cannot be more than 1 year in the future"
            )
        
        return v

    @computed_field
    @property
    def check_out_date(self) -> date:
        """Calculate checkout date based on duration."""
        # Approximate: 1 month = 30 days
        return self.check_in_date + timedelta(days=self.duration_months * 30)


class AvailableRoom(BaseSchema):
    """
    Available room details for booking.
    
    Comprehensive room information for availability results.
    """

    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    room_type: RoomType = Field(..., description="Room type")
    floor_number: Optional[int] = Field(default=None, description="Floor")
    wing: Optional[str] = Field(default=None, description="Wing/Block")
    
    # Availability
    available_beds: int = Field(..., ge=0, description="Available beds")
    total_beds: int = Field(..., ge=1, description="Total beds")
    
    # Pricing
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent per bed")
    price_quarterly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Quarterly rate",
    )
    price_half_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Half-yearly rate",
    )
    price_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Yearly rate",
    )
    
    # Features
    is_ac: bool = Field(..., description="Air conditioned")
    has_attached_bathroom: bool = Field(..., description="Attached bathroom")
    has_balcony: bool = Field(default=False, description="Has balcony")
    has_wifi: bool = Field(default=True, description="WiFi available")
    room_size_sqft: Optional[int] = Field(
        default=None,
        description="Room size",
    )
    
    # Amenities
    amenities: List[str] = Field(
        default_factory=list,
        description="Room amenities",
    )
    furnishing: List[str] = Field(
        default_factory=list,
        description="Furniture items",
    )
    
    # Media
    room_images: List[str] = Field(
        default_factory=list,
        description="Room images",
    )
    primary_image: Optional[str] = Field(
        default=None,
        description="Primary image URL",
    )

    @computed_field
    @property
    def occupancy_rate(self) -> Decimal:
        """Calculate current occupancy rate."""
        if self.total_beds == 0:
            return Decimal("0.00")
        occupied = self.total_beds - self.available_beds
        return Decimal((occupied / self.total_beds * 100)).quantize(
            Decimal("0.01")
        )


class AvailabilityResponse(BaseSchema):
    """
    Room availability response.
    
    Complete availability results with metadata.
    """

    hostel_id: str = Field(..., description="Hostel ID")
    check_in_date: date = Field(..., description="Requested check-in date")
    check_out_date: date = Field(..., description="Calculated checkout date")
    duration_months: int = Field(..., ge=1, description="Stay duration")
    
    # Results
    available_rooms: List[AvailableRoom] = Field(
        default_factory=list,
        description="List of available rooms",
    )
    total_available_beds: int = Field(
        ...,
        ge=0,
        description="Total available beds across all rooms",
    )
    has_availability: bool = Field(
        ...,
        description="Whether any beds are available",
    )
    
    # Filters applied
    filters_applied: Dict[str, any] = Field(
        default_factory=dict,
        description="Summary of applied filters",
    )

    @computed_field
    @property
    def total_rooms_available(self) -> int:
        """Count of rooms with availability."""
        return len(self.available_rooms)

    @computed_field
    @property
    def price_range(self) -> Optional[Dict[str, Decimal]]:
        """Calculate price range across available rooms."""
        if not self.available_rooms:
            return None
        
        prices = [room.price_monthly for room in self.available_rooms]
        return {
            "min": min(prices),
            "max": max(prices),
            "average": Decimal(sum(prices) / len(prices)).quantize(
                Decimal("0.01")
            ),
        }


class BookingInfo(BaseSchema):
    """
    Booking information for calendar display.
    
    Brief booking details for availability calendar.
    """

    booking_id: str = Field(..., description="Booking ID")
    student_name: str = Field(..., description="Student name")
    student_id: str = Field(..., description="Student ID")
    check_in_date: date = Field(..., description="Check-in date")
    check_out_date: date = Field(..., description="Check-out date")
    bed_number: Optional[str] = Field(
        default=None,
        description="Assigned bed number",
    )
    status: str = Field(..., description="Booking status")


class DayAvailability(BaseSchema):
    """
    Availability information for a specific day.
    
    Day-level availability with booking details.
    """

    date: date = Field(..., description="Date")
    available_beds: int = Field(..., ge=0, description="Available beds")
    total_beds: int = Field(..., ge=1, description="Total beds")
    is_available: bool = Field(..., description="Has availability")
    bookings: List[BookingInfo] = Field(
        default_factory=list,
        description="Active bookings for this day",
    )
    notes: Optional[str] = Field(
        default=None,
        description="Special notes (holidays, maintenance, etc.)",
    )

    @computed_field
    @property
    def occupancy_percentage(self) -> Decimal:
        """Calculate occupancy percentage for the day."""
        if self.total_beds == 0:
            return Decimal("0.00")
        occupied = self.total_beds - self.available_beds
        return Decimal((occupied / self.total_beds * 100)).quantize(
            Decimal("0.01")
        )


class AvailabilityCalendar(BaseSchema):
    """
    Availability calendar for a room.
    
    Month-view calendar showing daily availability.
    """

    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    month: str = Field(
        ...,
        pattern=r"^\d{4}-\d{2}$",
        description="Month in YYYY-MM format",
    )
    total_beds: int = Field(..., ge=1, description="Total beds in room")
    
    # Day-by-day availability
    availability: Dict[str, DayAvailability] = Field(
        ...,
        description="Availability by date (ISO date string as key)",
    )

    @field_validator("month")
    @classmethod
    def validate_month_format(cls, v: str) -> str:
        """Validate month format and range."""
        try:
            year, month = map(int, v.split("-"))
            if not (1 <= month <= 12):
                raise ValueError("Month must be between 01 and 12")
            if not (2000 <= year <= 2100):
                raise ValueError("Year must be between 2000 and 2100")
        except (ValueError, AttributeError) as e:
            raise ValueError(f"Invalid month format: {e}")
        return v

    @computed_field
    @property
    def average_occupancy(self) -> Decimal:
        """Calculate average occupancy for the month."""
        if not self.availability:
            return Decimal("0.00")
        
        total_occupancy = sum(
            day.occupancy_percentage for day in self.availability.values()
        )
        return Decimal(total_occupancy / len(self.availability)).quantize(
            Decimal("0.01")
        )

    @computed_field
    @property
    def fully_booked_days(self) -> int:
        """Count days with no availability."""
        return sum(
            1 for day in self.availability.values()
            if day.available_beds == 0
        )


class BulkAvailabilityRequest(BaseCreateSchema):
    """
    Request to check availability for multiple rooms/hostels.
    
    Batch availability checking for comparison or bulk operations.
    """

    hostel_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=10,
        description="List of hostel IDs (max 10)",
    )
    check_in_date: date = Field(
        ...,
        description="Check-in date",
    )
    duration_months: int = Field(
        ...,
        ge=1,
        le=24,
        description="Stay duration",
    )
    room_type: Optional[RoomType] = Field(
        default=None,
        description="Room type filter",
    )
    min_beds_per_hostel: int = Field(
        default=1,
        ge=1,
        description="Minimum beds required per hostel",
    )

    @field_validator("hostel_ids")
    @classmethod
    def validate_unique_hostel_ids(cls, v: List[str]) -> List[str]:
        """Ensure hostel IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Hostel IDs must be unique")
        return v

    @field_validator("check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date is not in the past."""
        today = date.today()
        if v < today - timedelta(days=7):
            raise ValueError(
                "Check-in date cannot be more than 7 days in the past"
            )
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\room\room_base.py ---
# --- File: app/schemas/room/room_base.py ---
"""
Room base schemas with enhanced validation and type safety.

Provides core room management schemas including creation, updates,
bulk operations, and pricing/status management.
"""

from __future__ import annotations

from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import RoomStatus, RoomType

__all__ = [
    "RoomBase",
    "RoomCreate",
    "RoomUpdate",
    "BulkRoomCreate",
    "RoomPricingUpdate",
    "RoomStatusUpdate",
    "RoomMediaUpdate",
]


class RoomBase(BaseSchema):
    """
    Base room schema with comprehensive room attributes.
    
    Contains common fields shared across room operations including
    specifications, pricing, amenities, and availability.
    """

    hostel_id: str = Field(
        ...,
        description="Hostel ID this room belongs to",
    )
    room_number: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Room number/identifier (e.g., '101', 'A-201')",
        examples=["101", "A-201", "Block-B-301"],
    )
    floor_number: Optional[int] = Field(
        default=None,
        ge=0,
        le=50,
        description="Floor number (0 for ground floor)",
    )
    wing: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Wing/Block designation (A, B, North Wing, etc.)",
        examples=["A", "B", "North Wing", "Block-1"],
    )

    # Type and capacity
    room_type: RoomType = Field(
        ...,
        description="Room occupancy type",
    )
    total_beds: int = Field(
        ...,
        ge=1,
        le=20,
        description="Total bed capacity in the room",
    )

    # Pricing (all in same currency as hostel)
    price_monthly: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Monthly rent amount",
    )
    price_quarterly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Quarterly rent (3 months, often discounted)",
    )
    price_half_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Half-yearly rent (6 months, often discounted)",
    )
    price_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Yearly rent (12 months, often discounted)",
    )

    # Physical specifications
    room_size_sqft: Optional[int] = Field(
        default=None,
        ge=50,
        le=1000,
        description="Room size in square feet",
    )
    is_ac: bool = Field(
        default=False,
        description="Air conditioning available",
    )
    has_attached_bathroom: bool = Field(
        default=False,
        description="Attached/ensuite bathroom",
    )
    has_balcony: bool = Field(
        default=False,
        description="Private balcony available",
    )
    has_wifi: bool = Field(
        default=True,
        description="WiFi connectivity available",
    )

    # Amenities and furnishing
    amenities: List[str] = Field(
        default_factory=list,
        description="Room-specific amenities (separate from general hostel amenities)",
        examples=[["Study Table", "Wardrobe", "Fan", "Geyser"]],
    )
    furnishing: List[str] = Field(
        default_factory=list,
        description="Furniture and fixtures provided",
        examples=[["Bed", "Mattress", "Study Table", "Chair", "Wardrobe"]],
    )

    # Availability and status
    is_available_for_booking: bool = Field(
        default=True,
        description="Available for online booking requests",
    )
    is_under_maintenance: bool = Field(
        default=False,
        description="Currently under maintenance",
    )

    # Media
    room_images: List[str] = Field(
        default_factory=list,
        max_length=15,
        description="Room image URLs (max 15)",
    )

    @field_validator("room_number")
    @classmethod
    def validate_room_number(cls, v: str) -> str:
        """
        Validate and normalize room number.
        
        Ensures room number is properly formatted and trimmed.
        """
        v = v.strip().upper()
        if not v:
            raise ValueError("Room number cannot be empty")
        # Remove excessive whitespace
        v = " ".join(v.split())
        return v

    @field_validator("wing")
    @classmethod
    def validate_wing(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize wing/block designation."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Remove excessive whitespace
            v = " ".join(v.split())
        return v

    @field_validator("amenities", "furnishing")
    @classmethod
    def validate_and_clean_lists(cls, v: List[str]) -> List[str]:
        """
        Validate and clean list fields.
        
        Removes empty strings, duplicates, and normalizes values.
        """
        if not v:
            return []
        # Clean and normalize
        cleaned = [item.strip() for item in v if item and item.strip()]
        # Remove duplicates while preserving order (case-insensitive)
        seen = set()
        unique = []
        for item in cleaned:
            item_lower = item.lower()
            if item_lower not in seen:
                seen.add(item_lower)
                unique.append(item)
        return unique

    @field_validator("room_images")
    @classmethod
    def validate_room_images(cls, v: List[str]) -> List[str]:
        """
        Validate room image URLs.
        
        Removes empty strings, duplicates, and validates URL format.
        """
        if not v:
            return []
        # Clean URLs
        cleaned = []
        seen = set()
        for url in v:
            if not url or not url.strip():
                continue
            url = url.strip()
            # Basic URL validation
            if not (url.startswith("http://") or url.startswith("https://")):
                continue
            # Remove duplicates
            if url not in seen:
                seen.add(url)
                cleaned.append(url)
        return cleaned[:15]  # Limit to 15 images

    @model_validator(mode="after")
    def validate_pricing_consistency(self) -> "RoomBase":
        """
        Validate pricing consistency and logical discounts.
        
        Ensures longer-term prices are not higher than monthly equivalent.
        """
        monthly = self.price_monthly
        
        # Validate quarterly pricing
        if self.price_quarterly is not None:
            monthly_equivalent = monthly * 3
            if self.price_quarterly > monthly_equivalent:
                raise ValueError(
                    f"Quarterly price ({self.price_quarterly}) should not exceed "
                    f"3x monthly price ({monthly_equivalent})"
                )
        
        # Validate half-yearly pricing
        if self.price_half_yearly is not None:
            monthly_equivalent = monthly * 6
            if self.price_half_yearly > monthly_equivalent:
                raise ValueError(
                    f"Half-yearly price ({self.price_half_yearly}) should not exceed "
                    f"6x monthly price ({monthly_equivalent})"
                )
        
        # Validate yearly pricing
        if self.price_yearly is not None:
            monthly_equivalent = monthly * 12
            if self.price_yearly > monthly_equivalent:
                raise ValueError(
                    f"Yearly price ({self.price_yearly}) should not exceed "
                    f"12x monthly price ({monthly_equivalent})"
                )
        
        return self

    @model_validator(mode="after")
    def validate_room_type_beds(self) -> "RoomBase":
        """
        Validate bed count matches room type expectations.
        
        Provides warnings for unusual configurations.
        """
        expected_beds = {
            RoomType.SINGLE: (1, 1),
            RoomType.DOUBLE: (2, 2),
            RoomType.TRIPLE: (3, 3),
            RoomType.FOUR_SHARING: (4, 4),
            RoomType.DORMITORY: (5, 20),
        }
        
        if self.room_type in expected_beds:
            min_beds, max_beds = expected_beds[self.room_type]
            if not (min_beds <= self.total_beds <= max_beds):
                # Note: We don't raise an error to allow flexibility
                # but this could be logged as a warning
                pass
        
        return self


class RoomCreate(RoomBase, BaseCreateSchema):
    """
    Schema for creating a new room.
    
    Enforces all required fields for room creation.
    """

    # Override to ensure required fields
    hostel_id: str = Field(
        ...,
        description="Hostel ID (required)",
    )
    room_number: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Room number (required)",
    )
    room_type: RoomType = Field(
        ...,
        description="Room type (required)",
    )
    total_beds: int = Field(
        ...,
        ge=1,
        le=20,
        description="Total beds (required)",
    )
    price_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Monthly rent (required)",
    )


class RoomUpdate(BaseUpdateSchema):
    """
    Schema for updating room information.
    
    All fields are optional for partial updates.
    """

    room_number: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=50,
        description="Room number",
    )
    floor_number: Optional[int] = Field(
        default=None,
        ge=0,
        le=50,
        description="Floor number",
    )
    wing: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Wing/Block",
    )
    room_type: Optional[RoomType] = Field(
        default=None,
        description="Room type",
    )
    total_beds: Optional[int] = Field(
        default=None,
        ge=1,
        le=20,
        description="Total beds",
    )

    # Pricing updates
    price_monthly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Monthly rent",
    )
    price_quarterly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Quarterly rent",
    )
    price_half_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Half-yearly rent",
    )
    price_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Yearly rent",
    )

    # Physical specifications
    room_size_sqft: Optional[int] = Field(
        default=None,
        ge=50,
        le=1000,
        description="Room size in sq ft",
    )
    is_ac: Optional[bool] = Field(
        default=None,
        description="Air conditioning",
    )
    has_attached_bathroom: Optional[bool] = Field(
        default=None,
        description="Attached bathroom",
    )
    has_balcony: Optional[bool] = Field(
        default=None,
        description="Balcony",
    )
    has_wifi: Optional[bool] = Field(
        default=None,
        description="WiFi",
    )

    # Amenities
    amenities: Optional[List[str]] = Field(
        default=None,
        description="Room amenities",
    )
    furnishing: Optional[List[str]] = Field(
        default=None,
        description="Furniture items",
    )

    # Availability
    is_available_for_booking: Optional[bool] = Field(
        default=None,
        description="Booking availability",
    )
    is_under_maintenance: Optional[bool] = Field(
        default=None,
        description="Maintenance status",
    )

    # Status
    status: Optional[RoomStatus] = Field(
        default=None,
        description="Room operational status",
    )

    # Media
    room_images: Optional[List[str]] = Field(
        default=None,
        max_length=15,
        description="Room image URLs",
    )

    # Apply same validators as base
    _validate_room_number = field_validator("room_number")(
        RoomBase.validate_room_number.__func__
    )
    _validate_wing = field_validator("wing")(RoomBase.validate_wing.__func__)
    _validate_lists = field_validator("amenities", "furnishing")(
        RoomBase.validate_and_clean_lists.__func__
    )
    _validate_images = field_validator("room_images")(
        RoomBase.validate_room_images.__func__
    )


class BulkRoomCreate(BaseCreateSchema):
    """
    Schema for bulk room creation.
    
    Allows creating multiple rooms in a single operation.
    Useful for initial hostel setup or adding multiple similar rooms.
    """

    hostel_id: str = Field(
        ...,
        description="Hostel ID for all rooms",
    )
    rooms: List[RoomCreate] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of rooms to create (max 100 per batch)",
    )

    @field_validator("rooms")
    @classmethod
    def validate_unique_room_numbers(cls, v: List[RoomCreate]) -> List[RoomCreate]:
        """
        Validate room numbers are unique within the batch.
        
        Prevents duplicate room numbers in bulk creation.
        """
        room_numbers = [room.room_number.strip().upper() for room in v]
        if len(room_numbers) != len(set(room_numbers)):
            raise ValueError("Room numbers must be unique within the batch")
        return v

    @field_validator("rooms")
    @classmethod
    def validate_consistent_hostel(cls, v: List[RoomCreate], info) -> List[RoomCreate]:
        """
        Validate all rooms belong to the same hostel.
        
        Ensures consistency in bulk operations.
        """
        hostel_id = info.data.get("hostel_id")
        if hostel_id:
            for room in v:
                if room.hostel_id != hostel_id:
                    raise ValueError(
                        f"All rooms must belong to hostel {hostel_id}. "
                        f"Found room with hostel_id: {room.hostel_id}"
                    )
        return v


class RoomPricingUpdate(BaseUpdateSchema):
    """
    Schema for updating room pricing.
    
    Dedicated schema for price updates with validation.
    """

    price_monthly: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Monthly rent (required)",
    )
    price_quarterly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Quarterly rent (optional discount)",
    )
    price_half_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Half-yearly rent (optional discount)",
    )
    price_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Yearly rent (optional discount)",
    )
    effective_from: Optional[date] = Field(
        default=None,
        description="Effective date for new pricing (optional)",
    )

    @model_validator(mode="after")
    def validate_pricing_logic(self) -> "RoomPricingUpdate":
        """Validate pricing consistency."""
        monthly = self.price_monthly

        if self.price_quarterly is not None:
            if self.price_quarterly > (monthly * 3):
                raise ValueError(
                    "Quarterly price should not exceed 3x monthly price"
                )

        if self.price_half_yearly is not None:
            if self.price_half_yearly > (monthly * 6):
                raise ValueError(
                    "Half-yearly price should not exceed 6x monthly price"
                )

        if self.price_yearly is not None:
            if self.price_yearly > (monthly * 12):
                raise ValueError(
                    "Yearly price should not exceed 12x monthly price"
                )

        return self

    @field_validator("effective_from")
    @classmethod
    def validate_effective_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate effective date is not in the past."""
        if v is not None:
            from datetime import date as dt
            if v < dt.today():
                raise ValueError("Effective date cannot be in the past")
        return v


class RoomStatusUpdate(BaseUpdateSchema):
    """
    Schema for updating room operational status.
    
    Manages room availability and maintenance status with proper tracking.
    """

    status: RoomStatus = Field(
        ...,
        description="Room operational status",
    )
    is_available_for_booking: bool = Field(
        ...,
        description="Available for online bookings",
    )
    is_under_maintenance: bool = Field(
        default=False,
        description="Currently under maintenance",
    )
    maintenance_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Maintenance details and notes",
    )
    maintenance_start_date: Optional[date] = Field(
        default=None,
        description="Maintenance start date",
    )
    maintenance_end_date: Optional[date] = Field(
        default=None,
        description="Expected maintenance completion date",
    )

    @model_validator(mode="after")
    def validate_maintenance_requirements(self) -> "RoomStatusUpdate":
        """
        Validate maintenance-related fields.
        
        Ensures proper documentation when room is under maintenance.
        """
        if self.is_under_maintenance or self.status == RoomStatus.MAINTENANCE:
            # Require maintenance notes when under maintenance
            if not self.maintenance_notes:
                raise ValueError(
                    "Maintenance notes are required when room is under maintenance"
                )
            # Require maintenance start date
            if not self.maintenance_start_date:
                raise ValueError(
                    "Maintenance start date is required when room is under maintenance"
                )
            # Set room as unavailable for booking
            if self.is_available_for_booking:
                raise ValueError(
                    "Room cannot be available for booking while under maintenance"
                )
        
        return self

    @model_validator(mode="after")
    def validate_maintenance_dates(self) -> "RoomStatusUpdate":
        """Validate maintenance date range."""
        if self.maintenance_start_date and self.maintenance_end_date:
            if self.maintenance_end_date < self.maintenance_start_date:
                raise ValueError(
                    "Maintenance end date must be after or equal to start date"
                )
        return self


class RoomMediaUpdate(BaseUpdateSchema):
    """
    Schema for updating room media (images).
    
    Dedicated schema for managing room photographs and virtual tours.
    """

    room_images: List[str] = Field(
        default_factory=list,
        max_length=15,
        description="Room image URLs (max 15)",
    )
    primary_image: Optional[str] = Field(
        default=None,
        description="Primary/cover image URL (must be in room_images)",
    )
    virtual_tour_url: Optional[str] = Field(
        default=None,
        description="360 virtual tour URL",
    )

    @field_validator("room_images")
    @classmethod
    def validate_room_images(cls, v: List[str]) -> List[str]:
        """Validate room image URLs."""
        if not v:
            return []
        
        cleaned = []
        seen = set()
        for url in v:
            if not url or not url.strip():
                continue
            url = url.strip()
            # Validate URL format
            if not (url.startswith("http://") or url.startswith("https://")):
                raise ValueError(f"Invalid image URL format: {url}")
            # Remove duplicates
            if url not in seen:
                seen.add(url)
                cleaned.append(url)
        
        return cleaned[:15]

    @model_validator(mode="after")
    def validate_primary_image(self) -> "RoomMediaUpdate":
        """Validate primary image is in room_images list."""
        if self.primary_image:
            if self.primary_image not in self.room_images:
                raise ValueError(
                    "Primary image must be one of the room images"
                )
        return self

    @field_validator("virtual_tour_url")
    @classmethod
    def validate_virtual_tour_url(cls, v: Optional[str]) -> Optional[str]:
        """Validate virtual tour URL format."""
        if v is not None:
            v = v.strip()
            if v and not (v.startswith("http://") or v.startswith("https://")):
                raise ValueError("Invalid virtual tour URL format")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\room\room_response.py ---
# --- File: app/schemas/room/room_response.py ---
"""
Room response schemas for API responses.

Provides various response formats for room data including
detailed views, list items, and statistics.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import BedStatus, RoomStatus, RoomType

__all__ = [
    "RoomResponse",
    "RoomDetail",
    "RoomListItem",
    "RoomWithBeds",
    "RoomOccupancyStats",
    "RoomFinancialSummary",
]


class RoomResponse(BaseResponseSchema):
    """
    Standard room response schema.
    
    Basic room information for general API responses.
    """

    hostel_id: str = Field(..., description="Hostel ID")
    room_number: str = Field(..., description="Room number")
    floor_number: Optional[int] = Field(default=None, description="Floor number")
    wing: Optional[str] = Field(default=None, description="Wing/Block")
    
    # Type and capacity
    room_type: RoomType = Field(..., description="Room type")
    total_beds: int = Field(..., ge=0, description="Total bed capacity")
    occupied_beds: int = Field(..., ge=0, description="Currently occupied beds")
    available_beds: int = Field(..., ge=0, description="Available beds")
    
    # Pricing
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent")
    
    # Features
    is_ac: bool = Field(..., description="Air conditioned")
    has_attached_bathroom: bool = Field(..., description="Attached bathroom")
    
    # Status
    status: RoomStatus = Field(..., description="Room status")
    is_available_for_booking: bool = Field(
        ...,
        description="Available for booking",
    )
    
    @computed_field
    @property
    def occupancy_percentage(self) -> Decimal:
        """Calculate occupancy percentage."""
        if self.total_beds == 0:
            return Decimal("0.00")
        return Decimal(
            (self.occupied_beds / self.total_beds * 100)
        ).quantize(Decimal("0.01"))


class BedDetail(BaseSchema):
    """
    Detailed bed information within a room.
    
    Provides complete bed status and assignment details.
    """

    id: str = Field(..., description="Bed ID")
    bed_number: str = Field(..., description="Bed identifier")
    is_occupied: bool = Field(..., description="Currently occupied")
    status: BedStatus = Field(..., description="Bed status")
    
    # Current occupant
    current_student_id: Optional[str] = Field(
        default=None,
        description="Current student ID (if occupied)",
    )
    current_student_name: Optional[str] = Field(
        default=None,
        description="Current student name (if occupied)",
    )
    occupied_from: Optional[date] = Field(
        default=None,
        description="Occupancy start date",
    )
    expected_vacate_date: Optional[date] = Field(
        default=None,
        description="Expected checkout date",
    )
    
    # Additional info
    last_maintenance_date: Optional[date] = Field(
        default=None,
        description="Last maintenance date",
    )
    notes: Optional[str] = Field(
        default=None,
        description="Bed notes",
    )


class RoomDetail(BaseResponseSchema):
    """
    Detailed room information.
    
    Comprehensive room data including all specifications,
    amenities, and bed details.
    """

    # Basic info
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    room_number: str = Field(..., description="Room number")
    floor_number: Optional[int] = Field(default=None, description="Floor number")
    wing: Optional[str] = Field(default=None, description="Wing/Block")

    # Type and capacity
    room_type: RoomType = Field(..., description="Room type")
    total_beds: int = Field(..., ge=0, description="Total beds")
    occupied_beds: int = Field(..., ge=0, description="Occupied beds")
    available_beds: int = Field(..., ge=0, description="Available beds")

    # Pricing
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent")
    price_quarterly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Quarterly rent",
    )
    price_half_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Half-yearly rent",
    )
    price_yearly: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Yearly rent",
    )

    # Specifications
    room_size_sqft: Optional[int] = Field(
        default=None,
        description="Room size in sq ft",
    )
    is_ac: bool = Field(..., description="Air conditioned")
    has_attached_bathroom: bool = Field(..., description="Attached bathroom")
    has_balcony: bool = Field(..., description="Has balcony")
    has_wifi: bool = Field(..., description="WiFi available")

    # Amenities
    amenities: List[str] = Field(
        default_factory=list,
        description="Room amenities",
    )
    furnishing: List[str] = Field(
        default_factory=list,
        description="Furniture items",
    )

    # Status
    status: RoomStatus = Field(..., description="Room status")
    is_available_for_booking: bool = Field(
        ...,
        description="Available for booking",
    )
    is_under_maintenance: bool = Field(
        ...,
        description="Under maintenance",
    )
    maintenance_start_date: Optional[date] = Field(
        default=None,
        description="Maintenance start date",
    )
    maintenance_end_date: Optional[date] = Field(
        default=None,
        description="Expected maintenance end date",
    )
    maintenance_notes: Optional[str] = Field(
        default=None,
        description="Maintenance notes",
    )

    # Media
    room_images: List[str] = Field(
        default_factory=list,
        description="Room image URLs",
    )
    primary_image: Optional[str] = Field(
        default=None,
        description="Primary/cover image",
    )
    virtual_tour_url: Optional[str] = Field(
        default=None,
        description="Virtual tour URL",
    )

    # Beds detail
    beds: List[BedDetail] = Field(
        default_factory=list,
        description="Detailed bed information",
    )

    @computed_field
    @property
    def occupancy_percentage(self) -> Decimal:
        """Calculate current occupancy percentage."""
        if self.total_beds == 0:
            return Decimal("0.00")
        return Decimal(
            (self.occupied_beds / self.total_beds * 100)
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_fully_occupied(self) -> bool:
        """Check if room is fully occupied."""
        return self.occupied_beds >= self.total_beds

    @computed_field
    @property
    def discount_percentage_quarterly(self) -> Optional[Decimal]:
        """Calculate quarterly discount percentage."""
        if not self.price_quarterly:
            return None
        monthly_equivalent = self.price_monthly * 3
        if monthly_equivalent == 0:
            return None
        discount = (
            (monthly_equivalent - self.price_quarterly) / monthly_equivalent * 100
        )
        return Decimal(discount).quantize(Decimal("0.01"))

    @computed_field
    @property
    def discount_percentage_yearly(self) -> Optional[Decimal]:
        """Calculate yearly discount percentage."""
        if not self.price_yearly:
            return None
        monthly_equivalent = self.price_monthly * 12
        if monthly_equivalent == 0:
            return None
        discount = (
            (monthly_equivalent - self.price_yearly) / monthly_equivalent * 100
        )
        return Decimal(discount).quantize(Decimal("0.01"))


class RoomListItem(BaseSchema):
    """
    Room list item for list views.
    
    Minimal room information for efficient list rendering.
    """

    id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    floor_number: Optional[int] = Field(default=None, description="Floor")
    wing: Optional[str] = Field(default=None, description="Wing")
    room_type: RoomType = Field(..., description="Room type")
    total_beds: int = Field(..., ge=0, description="Total beds")
    available_beds: int = Field(..., ge=0, description="Available beds")
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent")
    is_ac: bool = Field(..., description="AC available")
    status: RoomStatus = Field(..., description="Status")
    is_available_for_booking: bool = Field(..., description="Bookable")
    primary_image: Optional[str] = Field(default=None, description="Cover image")

    @computed_field
    @property
    def occupancy_percentage(self) -> Decimal:
        """Calculate occupancy percentage."""
        if self.total_beds == 0:
            return Decimal("0.00")
        occupied = self.total_beds - self.available_beds
        return Decimal((occupied / self.total_beds * 100)).quantize(
            Decimal("0.01")
        )


class BedInfo(BaseSchema):
    """
    Brief bed information for room overview.
    
    Simplified bed data for quick views.
    """

    id: str = Field(..., description="Bed ID")
    bed_number: str = Field(..., description="Bed number")
    is_occupied: bool = Field(..., description="Occupied status")
    status: BedStatus = Field(..., description="Bed status")
    student_name: Optional[str] = Field(
        default=None,
        description="Occupant name (if applicable)",
    )
    occupied_from: Optional[date] = Field(
        default=None,
        description="Occupancy start date",
    )


class RoomWithBeds(BaseResponseSchema):
    """
    Room with bed information.
    
    Room overview with bed-level details.
    """

    hostel_id: str = Field(..., description="Hostel ID")
    room_number: str = Field(..., description="Room number")
    room_type: RoomType = Field(..., description="Room type")
    total_beds: int = Field(..., ge=0, description="Total beds")
    occupied_beds: int = Field(..., ge=0, description="Occupied beds")
    available_beds: int = Field(..., ge=0, description="Available beds")
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent")
    beds: List[BedInfo] = Field(
        default_factory=list,
        description="Bed details",
    )

    @computed_field
    @property
    def occupancy_rate(self) -> Decimal:
        """Calculate occupancy rate."""
        if self.total_beds == 0:
            return Decimal("0.00")
        return Decimal(
            (self.occupied_beds / self.total_beds * 100)
        ).quantize(Decimal("0.01"))


class RoomOccupancyStats(BaseSchema):
    """
    Room occupancy statistics.
    
    Provides occupancy metrics and revenue calculations.
    """

    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    room_type: RoomType = Field(..., description="Room type")
    
    # Capacity
    total_beds: int = Field(..., ge=0, description="Total beds")
    occupied_beds: int = Field(..., ge=0, description="Occupied beds")
    available_beds: int = Field(..., ge=0, description="Available beds")
    reserved_beds: int = Field(
        default=0,
        ge=0,
        description="Reserved beds",
    )
    
    # Revenue
    price_monthly: Decimal = Field(..., ge=0, description="Monthly rent per bed")
    current_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Current monthly revenue",
    )
    potential_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Potential revenue at full capacity",
    )
    
    # Status
    status: RoomStatus = Field(..., description="Room status")
    is_available_for_booking: bool = Field(..., description="Booking availability")
    
    # Timestamps
    last_occupancy_change: Optional[datetime] = Field(
        default=None,
        description="Last occupancy change timestamp",
    )

    @computed_field
    @property
    def occupancy_percentage(self) -> Decimal:
        """Calculate occupancy percentage."""
        if self.total_beds == 0:
            return Decimal("0.00")
        return Decimal(
            (self.occupied_beds / self.total_beds * 100)
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def revenue_percentage(self) -> Decimal:
        """Calculate revenue realization percentage."""
        if self.potential_revenue == 0:
            return Decimal("0.00")
        return Decimal(
            (self.current_revenue / self.potential_revenue * 100)
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def lost_revenue(self) -> Decimal:
        """Calculate lost revenue due to vacancy."""
        return self.potential_revenue - self.current_revenue


class RoomFinancialSummary(BaseSchema):
    """
    Room financial summary.
    
    Provides detailed financial metrics for a room.
    """

    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    
    # Pricing
    price_monthly_per_bed: Decimal = Field(
        ...,
        ge=0,
        description="Monthly rent per bed",
    )
    total_beds: int = Field(..., ge=0, description="Total beds")
    occupied_beds: int = Field(..., ge=0, description="Occupied beds")
    
    # Current month
    current_month_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Current month revenue",
    )
    current_month_collected: Decimal = Field(
        ...,
        ge=0,
        description="Amount collected this month",
    )
    current_month_pending: Decimal = Field(
        ...,
        ge=0,
        description="Amount pending this month",
    )
    
    # Historical
    total_revenue_ytd: Decimal = Field(
        ...,
        ge=0,
        description="Year-to-date total revenue",
    )
    total_collected_ytd: Decimal = Field(
        ...,
        ge=0,
        description="Year-to-date collected amount",
    )
    average_occupancy_ytd: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Year-to-date average occupancy %",
    )
    
    # Projections
    projected_monthly_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Projected revenue at current occupancy",
    )
    projected_yearly_revenue: Decimal = Field(
        ...,
        ge=0,
        description="Projected yearly revenue",
    )

    @computed_field
    @property
    def collection_rate(self) -> Decimal:
        """Calculate collection rate for current month."""
        if self.current_month_revenue == 0:
            return Decimal("100.00")
        return Decimal(
            (self.current_month_collected / self.current_month_revenue * 100)
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def occupancy_rate(self) -> Decimal:
        """Calculate current occupancy rate."""
        if self.total_beds == 0:
            return Decimal("0.00")
        return Decimal(
            (self.occupied_beds / self.total_beds * 100)
        ).quantize(Decimal("0.01"))

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\room\__init__.py ---
# --- File: app/schemas/room/__init__.py ---
"""
Room schemas package.

Re-exports commonly used room and bed-related schemas for convenient imports.

Example:
    from app.schemas.room import RoomCreate, BedAssignment, AvailabilityResponse
"""

from __future__ import annotations

from app.schemas.room.bed_base import (
    BedAssignmentRequest,
    BedBase,
    BedCreate,
    BedReleaseRequest,
    BedSwapRequest,
    BedUpdate,
    BulkBedCreate,
    BulkBedStatusUpdate,
)
from app.schemas.room.bed_response import (
    BedAssignment,
    BedAssignmentHistory,
    BedAvailability,
    BedDetailedStatus,
    BedHistory,
    BedResponse,
)
from app.schemas.room.room_availability import (
    AvailabilityCalendar,
    AvailabilityResponse,
    AvailableRoom,
    BulkAvailabilityRequest,
    DayAvailability,
    RoomAvailabilityRequest,
)
from app.schemas.room.room_base import (
    BulkRoomCreate,
    RoomBase,
    RoomCreate,
    RoomMediaUpdate,
    RoomPricingUpdate,
    RoomStatusUpdate,
    RoomUpdate,
)
from app.schemas.room.room_response import (
    BedDetail,
    BedInfo,
    RoomDetail,
    RoomFinancialSummary,
    RoomListItem,
    RoomOccupancyStats,
    RoomResponse,
    RoomWithBeds,
)

__all__ = [
    # Room base
    "RoomBase",
    "RoomCreate",
    "RoomUpdate",
    "BulkRoomCreate",
    "RoomPricingUpdate",
    "RoomStatusUpdate",
    "RoomMediaUpdate",
    # Room response
    "RoomResponse",
    "RoomDetail",
    "RoomListItem",
    "RoomWithBeds",
    "RoomOccupancyStats",
    "RoomFinancialSummary",
    "BedDetail",
    "BedInfo",
    # Bed base
    "BedBase",
    "BedCreate",
    "BedUpdate",
    "BulkBedCreate",
    "BedAssignmentRequest",
    "BedReleaseRequest",
    "BedSwapRequest",
    "BulkBedStatusUpdate",
    # Bed response
    "BedResponse",
    "BedAvailability",
    "BedAssignment",
    "BedHistory",
    "BedAssignmentHistory",
    "BedDetailedStatus",
    # Availability
    "RoomAvailabilityRequest",
    "AvailabilityResponse",
    "AvailableRoom",
    "AvailabilityCalendar",
    "DayAvailability",
    "BulkAvailabilityRequest",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\search =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\search\all_folders_files_content.txt ---
### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\search ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\search =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\search\search_analytics.py ---
"""
Search analytics & popular queries schemas
"""
from datetime import date, datetime
from typing import List, Dict
from pydantic import Field

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter


class SearchTermStats(BaseSchema):
    """Statistics for a single search term"""
    term: str
    search_count: int
    avg_results: float
    zero_result_count: int
    last_searched_at: datetime


class SearchAnalytics(BaseSchema):
    """Search analytics summary"""
    period: DateRangeFilter

    total_searches: int
    unique_terms: int
    zero_result_searches: int

    top_terms: List[SearchTermStats] = Field(default_factory=list)
    zero_result_terms: List[SearchTermStats] = Field(default_factory=list)

    # Aggregated metrics
    avg_results_per_search: float

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\search\search_autocomplete.py ---
"""
Autocomplete / suggestion schemas
"""
from typing import List
from pydantic import Field

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class AutocompleteRequest(BaseCreateSchema):
    """Request for autocomplete suggestions"""
    prefix: str = Field(..., min_length=1, max_length=100)
    type: str = Field(
        "hostel",
        pattern="^(hostel|city|area)$",
        description="What to autocomplete",
    )
    limit: int = Field(10, ge=1, le=20)


class Suggestion(BaseSchema):
    """Single suggestion"""
    value: str
    label: str
    type: str
    extra: dict = Field(default_factory=dict)


class AutocompleteResponse(BaseSchema):
    """Autocomplete result set"""
    suggestions: List[Suggestion]

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\search\search_filters.py ---
"""
Reusable search filter schemas (common for advanced search)
"""
from typing import List, Optional
from pydantic import Field
from decimal import Decimal

from app.schemas.common.base import BaseFilterSchema


class PriceFilter(BaseFilterSchema):
    min_price: Optional[Decimal] = Field(None, ge=0)
    max_price: Optional[Decimal] = Field(None, ge=0)


class RatingFilter(BaseFilterSchema):
    min_rating: Optional[Decimal] = Field(None, ge=0, le=5)
    max_rating: Optional[Decimal] = Field(None, ge=0, le=5)


class AmenityFilter(BaseFilterSchema):
    amenities: Optional[List[str]] = Field(None)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\search\search_request.py ---
"""
Search request schemas (hostels, rooms, etc.)
"""
from typing import List, Optional
from pydantic import Field
from uuid import UUID
from decimal import Decimal

from app.schemas.common.base import BaseSchema, BaseFilterSchema
from app.schemas.common.enums import HostelType, RoomType


class BasicSearchRequest(BaseFilterSchema):
    """Simple keyword search"""
    query: str = Field(..., min_length=1, max_length=255)


class AdvancedSearchRequest(BaseFilterSchema):
    """Advanced hostel search request (public)"""
    query: Optional[str] = Field(None, max_length=255)

    # Location
    city: Optional[str] = None
    state: Optional[str] = None
    pincode: Optional[str] = Field(None, pattern=r"^\d{6}$")

    latitude: Optional[Decimal] = Field(None, ge=-90, le=90)
    longitude: Optional[Decimal] = Field(None, ge=-180, le=180)
    radius_km: Optional[Decimal] = Field(None, ge=0, le=100)

    # Filters
    hostel_type: Optional[HostelType] = None
    room_type: Optional[RoomType] = None

    min_price: Optional[Decimal] = Field(None, ge=0)
    max_price: Optional[Decimal] = Field(None, ge=0)

    amenities: Optional[List[str]] = None
    min_rating: Optional[Decimal] = Field(None, ge=0, le=5)

    verified_only: bool = Field(False)
    available_only: bool = Field(False)

    # Sorting
    sort_by: str = Field(
        "relevance",
        pattern="^(relevance|price_asc|price_desc|rating_desc|distance_asc|newest)$",
    )
    page: int = Field(1, ge=1)
    page_size: int = Field(20, ge=1, le=100)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\search\search_response.py ---
"""
Search response schemas
"""
from typing import List, Dict, Any
from pydantic import Field
from decimal import Decimal
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.hostel.hostel_public import PublicHostelCard


class SearchResultItem(BaseSchema):
    """Generic search result wrapper (for hostels now, extensible later)"""
    hostel: PublicHostelCard
    score: Decimal = Field(..., description="Relevance score from search engine")


class FacetBucket(BaseSchema):
    """Facet value & count"""
    value: str
    count: int
    label: str


class FacetedSearchResponse(BaseSchema):
    """Response for advanced faceted search"""
    results: List[SearchResultItem]
    total_results: int
    page: int
    page_size: int
    total_pages: int

    # Facets
    facets: Dict[str, List[FacetBucket]] = Field(
        default_factory=dict, description="FacetName -> bucket list"
    )

    # Debug / meta
    query_time_ms: int = Field(..., description="Search execution time (ms)")
    raw_query: Dict[str, Any] = Field(
        default_factory=dict,
        description="Raw search engine query (optional, for debugging)",
    )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\search\search_sort.py ---
"""
Search sort option schemas
"""
from pydantic import Field

from app.schemas.common.base import BaseSchema


class SortCriteria(BaseSchema):
    """Sort criteria used by search"""
    sort_by: str = Field(
        ...,
        pattern="^(relevance|price|rating|distance|created_at)$",
        description="Field to sort by",
    )
    sort_order: str = Field(
        "asc",
        pattern="^(asc|desc)$",
        description="Sort direction",
    )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\search\__init__.py ---



# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\search\search_analytics.py ---
# --- File: app/schemas/search/search_analytics.py ---
"""
Search analytics and insights schemas.

Provides comprehensive analytics on search behavior, popular queries,
and zero-result searches for optimization.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Dict, List, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "SearchTermStats",
    "SearchMetrics",
    "PopularSearchTerm",
    "TrendingSearch",
    "ZeroResultTerm",
    "SearchAnalyticsRequest",
    "SearchAnalytics",
]


class SearchTermStats(BaseSchema):
    """
    Detailed statistics for a single search term.

    Tracks usage patterns and result quality for search optimization.
    """

    term: str = Field(
        ...,
        description="Search term or query",
    )
    search_count: int = Field(
        ...,
        ge=0,
        description="Number of times this term was searched",
    )
    unique_users: int = Field(
        0,
        ge=0,
        description="Number of unique users who searched this term",
    )

    # Result quality metrics
    avg_results: float = Field(
        ...,
        ge=0,
        description="Average number of results returned",
    )
    zero_result_count: int = Field(
        ...,
        ge=0,
        description="Number of searches with zero results",
    )
    zero_result_rate: float = Field(
        0.0,
        ge=0,
        le=100,
        description="Percentage of searches with zero results",
    )

    # Engagement metrics
    avg_click_position: Optional[float] = Field(
        None,
        ge=0,
        description="Average position of clicked results (1-based)",
    )
    click_through_rate: float = Field(
        0.0,
        ge=0,
        le=100,
        description="Percentage of searches that resulted in clicks",
    )

    # Temporal data
    first_searched_at: datetime = Field(
        ...,
        description="When this term was first searched",
    )
    last_searched_at: datetime = Field(
        ...,
        description="Most recent search timestamp",
    )

    # Trend indicators
    trend_direction: Optional[str] = Field(
        None,
        pattern=r"^(rising|falling|stable)$",
        description="Search trend direction",
    )
    growth_rate: Optional[float] = Field(
        None,
        description="Percentage change in search volume (vs previous period)",
    )


class SearchMetrics(BaseSchema):
    """
    Aggregated search performance metrics.

    Provides overview of search system health and performance.
    """

    # Volume metrics
    total_searches: int = Field(
        ...,
        ge=0,
        description="Total number of searches in period",
    )
    unique_searches: int = Field(
        ...,
        ge=0,
        description="Number of unique search queries",
    )
    unique_users: int = Field(
        0,
        ge=0,
        description="Number of unique users who performed searches",
    )

    # Quality metrics
    avg_results_per_search: float = Field(
        ...,
        ge=0,
        description="Average number of results per search",
    )
    zero_result_searches: int = Field(
        ...,
        ge=0,
        description="Number of searches with zero results",
    )
    zero_result_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of searches with zero results",
    )

    # Performance metrics
    avg_response_time_ms: float = Field(
        ...,
        ge=0,
        description="Average search response time in milliseconds",
    )
    p95_response_time_ms: float = Field(
        ...,
        ge=0,
        description="95th percentile response time",
    )
    p99_response_time_ms: float = Field(
        ...,
        ge=0,
        description="99th percentile response time",
    )

    # Engagement metrics
    avg_click_through_rate: float = Field(
        0.0,
        ge=0,
        le=100,
        description="Average click-through rate across all searches",
    )
    searches_with_clicks: int = Field(
        0,
        ge=0,
        description="Number of searches that resulted in at least one click",
    )


class PopularSearchTerm(BaseSchema):
    """
    Popular search term with ranking.

    Used for displaying trending/popular searches to users.
    """

    rank: int = Field(
        ...,
        ge=1,
        description="Popularity ranking (1 = most popular)",
    )
    term: str = Field(
        ...,
        description="Search term",
    )
    search_count: int = Field(
        ...,
        ge=0,
        description="Number of searches",
    )
    result_count: int = Field(
        ...,
        ge=0,
        description="Average number of results",
    )
    change_from_previous: Optional[int] = Field(
        None,
        description="Change in rank from previous period (+/- positions)",
    )


class TrendingSearch(BaseSchema):
    """
    Trending search term (rapidly growing in popularity).

    Identifies emerging search patterns.
    """

    term: str = Field(
        ...,
        description="Trending search term",
    )
    current_count: int = Field(
        ...,
        ge=0,
        description="Number of searches in current period",
    )
    previous_count: int = Field(
        ...,
        ge=0,
        description="Number of searches in previous period",
    )
    growth_rate: float = Field(
        ...,
        description="Percentage growth rate",
    )
    velocity: float = Field(
        ...,
        ge=0,
        description="Trending velocity score (higher = faster growth)",
    )


class ZeroResultTerm(BaseSchema):
    """
    Search term that consistently returns zero results.

    Critical for search optimization and content gap analysis.
    """

    term: str = Field(
        ...,
        description="Search term with zero results",
    )
    search_count: int = Field(
        ...,
        ge=1,
        description="Number of times searched (with zero results)",
    )
    unique_users: int = Field(
        ...,
        ge=0,
        description="Number of unique users affected",
    )
    first_seen: datetime = Field(
        ...,
        description="First occurrence of this zero-result search",
    )
    last_seen: datetime = Field(
        ...,
        description="Most recent occurrence",
    )
    suggested_alternatives: Optional[List[str]] = Field(
        None,
        description="Suggested alternative search terms",
    )


class SearchAnalyticsRequest(BaseSchema):
    """
    Request parameters for search analytics.

    Allows filtering analytics by date range and other criteria.
    """

    # Date range
    date_range: DateRangeFilter = Field(
        ...,
        description="Date range for analytics",
    )

    # Filters
    min_search_count: int = Field(
        1,
        ge=1,
        description="Minimum number of searches to include term",
    )
    include_zero_results: bool = Field(
        True,
        description="Include zero-result searches in analysis",
    )

    # Limits
    top_terms_limit: int = Field(
        20,
        ge=1,
        le=100,
        description="Number of top terms to return",
    )
    trending_limit: int = Field(
        10,
        ge=1,
        le=50,
        description="Number of trending terms to return",
    )
    zero_result_limit: int = Field(
        20,
        ge=1,
        le=100,
        description="Number of zero-result terms to return",
    )

    @model_validator(mode="after")
    def validate_date_range(self) -> "SearchAnalyticsRequest":
        """Validate date range is reasonable."""
        if self.date_range.start_date and self.date_range.end_date:
            delta = self.date_range.end_date - self.date_range.start_date
            if delta.days > 365:
                raise ValueError("Date range cannot exceed 365 days")
        return self


class SearchAnalytics(BaseSchema):
    """
    Comprehensive search analytics response.

    Provides detailed insights into search behavior and performance.
    """

    # Period information
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period",
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When this analytics report was generated",
    )

    # Overall metrics
    metrics: SearchMetrics = Field(
        ...,
        description="Aggregated search metrics",
    )

    # Top searches
    top_searches: List[PopularSearchTerm] = Field(
        default_factory=list,
        description="Most popular search terms",
    )

    # Trending searches
    trending_searches: List[TrendingSearch] = Field(
        default_factory=list,
        description="Rapidly growing search terms",
    )

    # Zero-result searches
    zero_result_searches: List[ZeroResultTerm] = Field(
        default_factory=list,
        description="Searches that returned no results",
    )

    # Detailed term statistics (optional, for deep dive)
    term_statistics: Optional[List[SearchTermStats]] = Field(
        None,
        description="Detailed statistics for individual search terms",
    )

    # Breakdown by category
    category_breakdown: Optional[Dict[str, int]] = Field(
        None,
        description="Search volume by category (hostel_type, location, etc.)",
    )

    # Geographic breakdown
    geographic_breakdown: Optional[Dict[str, int]] = Field(
        None,
        description="Search volume by location (city/state)",
    )

    @property
    def has_quality_issues(self) -> bool:
        """
        Check if there are search quality issues.

        Returns True if zero-result rate is high or response times are slow.
        """
        return (
            self.metrics.zero_result_rate > 20
            or self.metrics.p95_response_time_ms > 1000
        )

    @property
    def engagement_score(self) -> float:
        """
        Calculate overall engagement score (0-100).

        Based on click-through rate and result quality.
        """
        # Weight CTR (70%) and inverse zero-result rate (30%)
        ctr_score = self.metrics.avg_click_through_rate * 0.7
        quality_score = (100 - self.metrics.zero_result_rate) * 0.3
        return min(ctr_score + quality_score, 100)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\search\search_autocomplete.py ---
# --- File: app/schemas/search/search_autocomplete.py ---
"""
Autocomplete and suggestion schemas for search.

Provides real-time search suggestions as users type.
"""

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "SuggestionType",
    "AutocompleteRequest",
    "Suggestion",
    "AutocompleteResponse",
]


class SuggestionType(str, Enum):
    """
    Type of autocomplete suggestion.

    Helps categorize and display suggestions appropriately.
    """

    HOSTEL = "hostel"
    CITY = "city"
    AREA = "area"
    LANDMARK = "landmark"
    AMENITY = "amenity"
    POPULAR_SEARCH = "popular_search"


class AutocompleteRequest(BaseCreateSchema):
    """
    Autocomplete request for search suggestions.

    Optimized for real-time typeahead functionality.
    """

    prefix: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Search prefix (user's partial input)",
        examples=["mumb", "boys host", "pg near"],
    )
    suggestion_type: Optional[SuggestionType] = Field(
        None,
        description="Filter suggestions by type (optional)",
    )
    limit: int = Field(
        10,
        ge=1,
        le=20,
        description="Maximum number of suggestions to return",
    )

    # Context for personalization
    user_latitude: Optional[float] = Field(
        None,
        ge=-90,
        le=90,
        description="User latitude for location-based suggestions",
    )
    user_longitude: Optional[float] = Field(
        None,
        ge=-180,
        le=180,
        description="User longitude for location-based suggestions",
    )

    # Filtering
    include_types: Optional[List[SuggestionType]] = Field(
        None,
        description="Include only these suggestion types",
        examples=[["hostel", "city"]],
    )
    exclude_types: Optional[List[SuggestionType]] = Field(
        None,
        description="Exclude these suggestion types",
    )

    @field_validator("prefix")
    @classmethod
    def normalize_prefix(cls, v: str) -> str:
        """
        Normalize search prefix.

        - Trim whitespace
        - Convert to lowercase for matching
        """
        normalized = v.strip().lower()
        if not normalized:
            raise ValueError("Search prefix cannot be empty or only whitespace")
        return normalized

    @field_validator("include_types", "exclude_types")
    @classmethod
    def validate_type_lists(
        cls,
        v: Optional[List[SuggestionType]],
    ) -> Optional[List[SuggestionType]]:
        """Remove duplicates from type lists."""
        if v is not None:
            return list(dict.fromkeys(v))  # Preserve order while removing dupes
        return v


class Suggestion(BaseSchema):
    """
    Single autocomplete suggestion.

    Provides rich metadata for displaying suggestions.
    """

    # Core fields
    value: str = Field(
        ...,
        description="Suggestion value (what to insert into search)",
        examples=["Mumbai", "Boys Hostel in Andheri"],
    )
    label: str = Field(
        ...,
        description="Display label (formatted for UI)",
        examples=["Mumbai, Maharashtra", "Boys Hostel in Andheri (15 results)"],
    )
    type: SuggestionType = Field(
        ...,
        description="Suggestion type",
    )

    # Metadata
    score: float = Field(
        0.0,
        ge=0,
        description="Relevance/popularity score",
    )
    result_count: Optional[int] = Field(
        None,
        ge=0,
        description="Estimated number of results for this suggestion",
    )

    # Rich data (optional)
    icon: Optional[str] = Field(
        None,
        description="Icon identifier for UI display",
        examples=["location", "building", "search"],
    )
    thumbnail_url: Optional[str] = Field(
        None,
        description="Thumbnail image URL (for hostel suggestions)",
    )

    # Additional context
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional type-specific metadata",
        examples=[
            {"city": "Mumbai", "state": "Maharashtra"},
            {"hostel_id": "uuid", "min_price": 10000},
        ],
    )

    # Highlighting
    highlighted_label: Optional[str] = Field(
        None,
        description="Label with matched portions highlighted (HTML)",
        examples=["<strong>Mumb</strong>ai, Maharashtra"],
    )


class AutocompleteResponse(BaseSchema):
    """
    Autocomplete response with suggestions.

    Groups suggestions by type for better UX.
    """

    suggestions: List[Suggestion] = Field(
        default_factory=list,
        description="Ordered list of suggestions",
    )

    # Grouped suggestions (optional, for categorized display)
    grouped_suggestions: Optional[Dict[str, List[Suggestion]]] = Field(
        None,
        description="Suggestions grouped by type",
        examples=[
            {
                "hostel": [{"value": "XYZ Hostel", "label": "XYZ Hostel"}],
                "city": [{"value": "Mumbai", "label": "Mumbai, Maharashtra"}],
            }
        ],
    )

    # Metadata
    prefix: str = Field(
        ...,
        description="Original search prefix",
    )
    total_suggestions: int = Field(
        ...,
        ge=0,
        description="Total number of suggestions returned",
    )
    execution_time_ms: int = Field(
        ...,
        ge=0,
        description="Suggestion generation time in milliseconds",
    )

    # Popular searches (shown when no prefix match)
    popular_searches: Optional[List[str]] = Field(
        None,
        description="Popular search terms (shown for empty/short prefix)",
        examples=[["Boys Hostel Mumbai", "PG in Bangalore", "Hostel near me"]],
    )

    @classmethod
    def create_grouped(
        cls,
        suggestions: List[Suggestion],
        prefix: str,
        execution_time_ms: int = 0,
    ) -> "AutocompleteResponse":
        """
        Create response with automatic grouping by type.

        Args:
            suggestions: List of suggestions
            prefix: Original search prefix
            execution_time_ms: Execution time

        Returns:
            AutocompleteResponse with grouped suggestions
        """
        # Group suggestions by type
        grouped: Dict[str, List[Suggestion]] = {}
        for suggestion in suggestions:
            type_key = suggestion.type.value
            if type_key not in grouped:
                grouped[type_key] = []
            grouped[type_key].append(suggestion)

        return cls(
            suggestions=suggestions,
            grouped_suggestions=grouped if grouped else None,
            prefix=prefix,
            total_suggestions=len(suggestions),
            execution_time_ms=execution_time_ms,
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\search\search_filters.py ---
# --- File: app/schemas/search/search_filters.py ---
"""
Reusable search filter schemas.

Provides modular, composable filter schemas for advanced search functionality.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import HostelType, RoomType

__all__ = [
    "PriceFilter",
    "RatingFilter",
    "AmenityFilter",
    "LocationFilter",
    "AvailabilityFilter",
    "SearchFilterSet",
]


class PriceFilter(BaseFilterSchema):
    """
    Price range filter with validation.

    Ensures min_price <= max_price and both are non-negative.
    """

    min_price: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Minimum price in INR",
        examples=[5000, 10000],
    )
    max_price: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Maximum price in INR",
        examples=[20000, 30000],
    )

    @model_validator(mode="after")
    def validate_price_range(self) -> "PriceFilter":
        """Ensure min_price is not greater than max_price."""
        if (
            self.min_price is not None
            and self.max_price is not None
            and self.min_price > self.max_price
        ):
            raise ValueError(
                f"min_price ({self.min_price}) cannot be greater than "
                f"max_price ({self.max_price})"
            )
        return self

    @property
    def is_active(self) -> bool:
        """Check if price filter is active."""
        return self.min_price is not None or self.max_price is not None


class RatingFilter(BaseFilterSchema):
    """
    Rating range filter with validation.

    Ensures ratings are within valid range (0-5).
    """

    min_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Minimum average rating (0-5 scale)",
        examples=[3.5, 4.0, 4.5],
    )
    max_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Maximum average rating (0-5 scale)",
        examples=[5.0],
    )

    @model_validator(mode="after")
    def validate_rating_range(self) -> "RatingFilter":
        """Ensure min_rating is not greater than max_rating."""
        if (
            self.min_rating is not None
            and self.max_rating is not None
            and self.min_rating > self.max_rating
        ):
            raise ValueError(
                f"min_rating ({self.min_rating}) cannot be greater than "
                f"max_rating ({self.max_rating})"
            )
        return self

    @property
    def is_active(self) -> bool:
        """Check if rating filter is active."""
        return self.min_rating is not None or self.max_rating is not None


class AmenityFilter(BaseFilterSchema):
    """
    Amenity filter with AND/OR logic support.

    - `required_amenities`: ALL must be present (AND logic)
    - `optional_amenities`: ANY can be present (OR logic)
    """

    required_amenities: Optional[List[str]] = Field(
        None,
        description="All of these amenities must be present (AND logic)",
        examples=[["wifi", "ac", "parking"]],
    )
    optional_amenities: Optional[List[str]] = Field(
        None,
        description="Any of these amenities can be present (OR logic)",
        examples=[["gym", "swimming_pool", "laundry"]],
    )
    excluded_amenities: Optional[List[str]] = Field(
        None,
        description="None of these amenities should be present",
        examples=[["smoking_allowed"]],
    )

    @field_validator("required_amenities", "optional_amenities", "excluded_amenities")
    @classmethod
    def normalize_amenities(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """
        Normalize amenity list.

        - Convert to lowercase
        - Remove duplicates
        - Strip whitespace
        - Preserve order
        """
        if v is not None:
            seen = set()
            normalized = []
            for amenity in v:
                amenity_clean = amenity.lower().strip()
                if amenity_clean and amenity_clean not in seen:
                    seen.add(amenity_clean)
                    normalized.append(amenity_clean)
            return normalized if normalized else None
        return v

    @property
    def is_active(self) -> bool:
        """Check if amenity filter is active."""
        return (
            self.required_amenities is not None
            or self.optional_amenities is not None
            or self.excluded_amenities is not None
        )


class LocationFilter(BaseFilterSchema):
    """
    Location-based filter with multiple filter types.

    Supports:
    - Text-based location (city, state, pincode)
    - Proximity-based (lat/lon + radius)
    """

    # Text-based location
    city: Optional[str] = Field(
        None,
        min_length=2,
        max_length=100,
        description="City name",
        examples=["Mumbai", "Bangalore"],
    )
    state: Optional[str] = Field(
        None,
        min_length=2,
        max_length=100,
        description="State name",
        examples=["Maharashtra", "Karnataka"],
    )
    pincode: Optional[str] = Field(
        None,
        pattern=r"^\d{6}$",
        description="6-digit pincode",
        examples=["400001", "560001"],
    )

    # Proximity-based location
    latitude: Optional[Decimal] = Field(
        None,
        ge=-90,
        le=90,
        description="Latitude for proximity search",
    )
    longitude: Optional[Decimal] = Field(
        None,
        ge=-180,
        le=180,
        description="Longitude for proximity search",
    )
    radius_km: Optional[Decimal] = Field(
        None,
        ge=0.1,
        le=100,
        description="Search radius in kilometers",
        examples=[5, 10, 25],
    )

    @field_validator("city", "state")
    @classmethod
    def normalize_location(cls, v: Optional[str]) -> Optional[str]:
        """Normalize location strings to title case."""
        if v is not None:
            return v.strip().title()
        return v

    @model_validator(mode="after")
    def validate_proximity_requirements(self) -> "LocationFilter":
        """Ensure radius requires both latitude and longitude."""
        if self.radius_km is not None:
            if self.latitude is None or self.longitude is None:
                raise ValueError(
                    "Both latitude and longitude are required when using radius_km"
                )
        return self

    @property
    def is_text_location(self) -> bool:
        """Check if text-based location filter is active."""
        return any([self.city, self.state, self.pincode])

    @property
    def is_proximity_location(self) -> bool:
        """Check if proximity-based location filter is active."""
        return self.latitude is not None and self.longitude is not None

    @property
    def is_active(self) -> bool:
        """Check if any location filter is active."""
        return self.is_text_location or self.is_proximity_location


class AvailabilityFilter(BaseFilterSchema):
    """
    Availability and booking filters.

    Filters based on bed availability and booking requirements.
    """

    available_only: bool = Field(
        False,
        description="Show only hostels with available beds",
    )
    min_available_beds: Optional[int] = Field(
        None,
        ge=1,
        description="Minimum number of available beds required",
        examples=[1, 2, 5],
    )

    # Date-based availability
    check_in_date: Optional[date] = Field(
        None,
        description="Desired check-in date",
    )
    check_out_date: Optional[date] = Field(
        None,
        description="Desired check-out date",
    )

    # Booking preferences
    instant_booking_only: bool = Field(
        False,
        description="Show only hostels with instant booking enabled",
    )
    verified_only: bool = Field(
        False,
        description="Show only verified hostels",
    )

    @model_validator(mode="after")
    def validate_date_range(self) -> "AvailabilityFilter":
        """Validate check-in and check-out date logic."""
        if self.check_in_date and self.check_out_date:
            if self.check_in_date >= self.check_out_date:
                raise ValueError(
                    "check_in_date must be before check_out_date"
                )

            # Validate dates are not in the past
            today = date.today()
            if self.check_in_date < today:
                raise ValueError("check_in_date cannot be in the past")

        return self

    @property
    def is_active(self) -> bool:
        """Check if any availability filter is active."""
        return (
            self.available_only
            or self.min_available_beds is not None
            or self.check_in_date is not None
            or self.instant_booking_only
            or self.verified_only
        )


class SearchFilterSet(BaseFilterSchema):
    """
    Composite filter set combining all filter types.

    Provides a convenient way to apply multiple filters together.
    """

    # Core filters
    price: Optional[PriceFilter] = Field(
        None,
        description="Price range filter",
    )
    rating: Optional[RatingFilter] = Field(
        None,
        description="Rating range filter",
    )
    amenities: Optional[AmenityFilter] = Field(
        None,
        description="Amenity filters",
    )
    location: Optional[LocationFilter] = Field(
        None,
        description="Location filters",
    )
    availability: Optional[AvailabilityFilter] = Field(
        None,
        description="Availability filters",
    )

    # Type filters
    hostel_types: Optional[List[HostelType]] = Field(
        None,
        description="Filter by hostel types",
        examples=[["boys", "girls"]],
    )
    room_types: Optional[List[RoomType]] = Field(
        None,
        description="Filter by room types",
        examples=[["single", "double"]],
    )

    @property
    def active_filters(self) -> List[str]:
        """Get list of active filter names."""
        active = []
        if self.price and self.price.is_active:
            active.append("price")
        if self.rating and self.rating.is_active:
            active.append("rating")
        if self.amenities and self.amenities.is_active:
            active.append("amenities")
        if self.location and self.location.is_active:
            active.append("location")
        if self.availability and self.availability.is_active:
            active.append("availability")
        if self.hostel_types:
            active.append("hostel_types")
        if self.room_types:
            active.append("room_types")
        return active

    @property
    def filter_count(self) -> int:
        """Get count of active filters."""
        return len(self.active_filters)

    @property
    def has_filters(self) -> bool:
        """Check if any filter is active."""
        return self.filter_count > 0

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\search\search_request.py ---
# --- File: app/schemas/search/search_request.py ---
"""
Search request schemas with comprehensive validation and type safety.

Provides schemas for:
- Basic keyword search
- Advanced search with multiple filters
- Nearby/proximity search
- Saved searches
- Search history
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseFilterSchema,
    BaseResponseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import Gender, HostelType, RoomType

__all__ = [
    "BasicSearchRequest",
    "AdvancedSearchRequest",
    "NearbySearchRequest",
    "SavedSearchCreate",
    "SavedSearchUpdate",
    "SavedSearchResponse",
    "SearchHistoryResponse",
]


class BasicSearchRequest(BaseFilterSchema):
    """
    Simple keyword-based search request.

    Optimized for quick searches with minimal parameters.
    """

    query: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Search query string",
        examples=["hostels in Mumbai", "PG near me"],
    )
    limit: int = Field(
        20,
        ge=1,
        le=100,
        description="Maximum number of results to return",
    )

    @field_validator("query")
    @classmethod
    def validate_and_normalize_query(cls, v: str) -> str:
        """
        Normalize search query.

        - Strips whitespace
        - Removes excessive spaces
        - Validates non-empty after normalization
        """
        # Strip and normalize whitespace
        normalized = " ".join(v.split())

        if not normalized:
            raise ValueError("Search query cannot be empty or only whitespace")

        return normalized


class AdvancedSearchRequest(BaseFilterSchema):
    """
    Advanced search request with comprehensive filtering options.

    Supports:
    - Text search
    - Geographic filtering
    - Price range
    - Amenity filtering
    - Rating filters
    - Availability filters
    - Sorting and pagination
    """

    # Search query
    query: Optional[str] = Field(
        None,
        max_length=255,
        description="Optional search keywords",
        examples=["boys hostel", "PG with meals"],
    )

    # Location filters
    city: Optional[str] = Field(
        None,
        min_length=2,
        max_length=100,
        description="City name",
        examples=["Mumbai", "Bangalore"],
    )
    state: Optional[str] = Field(
        None,
        min_length=2,
        max_length=100,
        description="State name",
        examples=["Maharashtra", "Karnataka"],
    )
    pincode: Optional[str] = Field(
        None,
        pattern=r"^\d{6}$",
        description="6-digit Indian pincode",
        examples=["400001", "560001"],
    )

    # Geographic coordinates for proximity search
    latitude: Optional[Decimal] = Field(
        None,
        ge=-90,
        le=90,
        description="Latitude for proximity search",
        examples=[19.0760],
    )
    longitude: Optional[Decimal] = Field(
        None,
        ge=-180,
        le=180,
        description="Longitude for proximity search",
        examples=[72.8777],
    )
    radius_km: Optional[Decimal] = Field(
        None,
        ge=0.1,
        le=100,
        description="Search radius in kilometers",
        examples=[5, 10, 25],
    )

    # Hostel and room type filters
    hostel_type: Optional[HostelType] = Field(
        None,
        description="Filter by hostel type (boys/girls/co-ed)",
    )
    room_types: Optional[List[RoomType]] = Field(
        None,
        description="Filter by room types (can select multiple)",
        examples=[["single", "double"]],
    )

    # Gender preference (for co-ed hostels)
    gender_preference: Optional[Gender] = Field(
        None,
        description="Gender preference for room allocation",
    )

    # Price range filter
    min_price: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Minimum monthly price in INR",
        examples=[5000, 10000],
    )
    max_price: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Maximum monthly price in INR",
        examples=[20000, 30000],
    )

    # Amenities filter
    amenities: Optional[List[str]] = Field(
        None,
        description="Required amenities (AND logic - hostel must have all)",
        examples=[["wifi", "ac", "parking"]],
    )
    any_amenities: Optional[List[str]] = Field(
        None,
        description="Optional amenities (OR logic - hostel can have any)",
        examples=[["gym", "laundry", "swimming_pool"]],
    )

    # Rating filter
    min_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Minimum average rating (0-5)",
        examples=[3.5, 4.0],
    )

    # Availability filters
    verified_only: bool = Field(
        False,
        description="Show only verified hostels",
    )
    available_only: bool = Field(
        False,
        description="Show only hostels with available beds",
    )
    instant_booking: bool = Field(
        False,
        description="Show only hostels with instant booking enabled",
    )

    # Date-based availability
    check_in_date: Optional[date] = Field(
        None,
        description="Desired check-in date for availability check",
    )
    check_out_date: Optional[date] = Field(
        None,
        description="Desired check-out date for availability check",
    )

    # Sorting options
    sort_by: str = Field(
        "relevance",
        pattern=r"^(relevance|price_asc|price_desc|rating_desc|distance_asc|newest|popular)$",
        description="Sort criterion",
    )

    # Pagination
    page: int = Field(
        1,
        ge=1,
        description="Page number (1-indexed)",
    )
    page_size: int = Field(
        20,
        ge=1,
        le=100,
        description="Results per page",
    )

    # Advanced options
    include_nearby_cities: bool = Field(
        False,
        description="Include results from nearby cities",
    )
    boost_featured: bool = Field(
        True,
        description="Boost featured/promoted hostels in results",
    )

    @field_validator("query")
    @classmethod
    def normalize_query(cls, v: Optional[str]) -> Optional[str]:
        """Normalize search query."""
        if v is not None:
            normalized = " ".join(v.split())
            return normalized if normalized else None
        return v

    @field_validator("city", "state")
    @classmethod
    def normalize_location(cls, v: Optional[str]) -> Optional[str]:
        """Normalize location strings."""
        if v is not None:
            return v.strip().title()
        return v

    @field_validator("amenities", "any_amenities")
    @classmethod
    def normalize_amenities(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """Normalize amenity list (lowercase, deduplicate)."""
        if v is not None:
            # Convert to lowercase and remove duplicates while preserving order
            seen = set()
            normalized = []
            for amenity in v:
                amenity_lower = amenity.lower().strip()
                if amenity_lower and amenity_lower not in seen:
                    seen.add(amenity_lower)
                    normalized.append(amenity_lower)
            return normalized if normalized else None
        return v

    @model_validator(mode="after")
    def validate_location_consistency(self) -> "AdvancedSearchRequest":
        """
        Validate location-related fields consistency.

        - Ensure radius is provided only with coordinates
        - Validate price range
        - Validate date range
        """
        # Validate radius requires coordinates
        if self.radius_km is not None:
            if self.latitude is None or self.longitude is None:
                raise ValueError(
                    "Both latitude and longitude are required when using radius_km"
                )

        # Validate price range
        if (
            self.min_price is not None
            and self.max_price is not None
            and self.min_price > self.max_price
        ):
            raise ValueError("min_price cannot be greater than max_price")

        # Validate date range
        if self.check_in_date and self.check_out_date:
            if self.check_in_date >= self.check_out_date:
                raise ValueError("check_in_date must be before check_out_date")

            # Validate dates are not in the past
            today = date.today()
            if self.check_in_date < today:
                raise ValueError("check_in_date cannot be in the past")

        return self

    @property
    def has_location_filter(self) -> bool:
        """Check if any location filter is applied."""
        return any(
            [
                self.city,
                self.state,
                self.pincode,
                self.latitude and self.longitude,
            ]
        )

    @property
    def has_price_filter(self) -> bool:
        """Check if price filter is applied."""
        return self.min_price is not None or self.max_price is not None

    @property
    def offset(self) -> int:
        """Calculate offset for database queries."""
        return (self.page - 1) * self.page_size


class NearbySearchRequest(BaseFilterSchema):
    """
    Proximity-based search request.

    Optimized for "near me" searches and location-based discovery.
    """

    latitude: Decimal = Field(
        ...,
        ge=-90,
        le=90,
        description="Current latitude",
    )
    longitude: Decimal = Field(
        ...,
        ge=-180,
        le=180,
        description="Current longitude",
    )
    radius_km: Decimal = Field(
        5.0,
        ge=0.1,
        le=50,
        description="Search radius in kilometers",
    )

    # Optional filters
    hostel_type: Optional[HostelType] = Field(
        None,
        description="Filter by hostel type",
    )
    min_price: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Minimum price filter",
    )
    max_price: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Maximum price filter",
    )
    available_only: bool = Field(
        True,
        description="Show only hostels with available beds",
    )

    limit: int = Field(
        20,
        ge=1,
        le=100,
        description="Maximum number of results",
    )

    @model_validator(mode="after")
    def validate_price_range(self) -> "NearbySearchRequest":
        """Validate price range."""
        if (
            self.min_price is not None
            and self.max_price is not None
            and self.min_price > self.max_price
        ):
            raise ValueError("min_price cannot be greater than max_price")
        return self


class SavedSearchCreate(BaseCreateSchema):
    """
    Create saved search for user.

    Allows users to save frequently used search criteria.
    """

    name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="User-friendly name for the saved search",
        examples=["My Daily Commute Search", "Budget Hostels in Mumbai"],
    )
    search_criteria: Dict[str, Any] = Field(
        ...,
        description="Serialized search parameters (AdvancedSearchRequest as dict)",
    )
    is_alert_enabled: bool = Field(
        False,
        description="Enable notifications when new matching hostels are added",
    )
    alert_frequency: Optional[str] = Field(
        None,
        pattern=r"^(daily|weekly|instant)$",
        description="Alert notification frequency",
    )

    @field_validator("name")
    @classmethod
    def normalize_name(cls, v: str) -> str:
        """Normalize search name."""
        normalized = " ".join(v.split())
        if not normalized:
            raise ValueError("Search name cannot be empty")
        return normalized

    @model_validator(mode="after")
    def validate_alert_settings(self) -> "SavedSearchCreate":
        """Validate alert configuration."""
        if self.is_alert_enabled and not self.alert_frequency:
            raise ValueError(
                "alert_frequency is required when is_alert_enabled is True"
            )
        if not self.is_alert_enabled and self.alert_frequency:
            self.alert_frequency = None  # Clear frequency if alerts disabled
        return self


class SavedSearchUpdate(BaseUpdateSchema):
    """Update saved search configuration."""

    name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=100,
        description="Updated name",
    )
    search_criteria: Optional[Dict[str, Any]] = Field(
        None,
        description="Updated search parameters",
    )
    is_alert_enabled: Optional[bool] = Field(
        None,
        description="Enable/disable alerts",
    )
    alert_frequency: Optional[str] = Field(
        None,
        pattern=r"^(daily|weekly|instant)$",
        description="Alert frequency",
    )

    @field_validator("name")
    @classmethod
    def normalize_name(cls, v: Optional[str]) -> Optional[str]:
        """Normalize search name."""
        if v is not None:
            normalized = " ".join(v.split())
            return normalized if normalized else None
        return v


class SavedSearchResponse(BaseResponseSchema):
    """Saved search response schema."""

    user_id: UUID = Field(..., description="User ID who owns this search")
    name: str = Field(..., description="Search name")
    search_criteria: Dict[str, Any] = Field(..., description="Search parameters")
    is_alert_enabled: bool = Field(..., description="Alert status")
    alert_frequency: Optional[str] = Field(None, description="Alert frequency")
    last_executed_at: Optional[datetime] = Field(
        None,
        description="Last time this search was executed",
    )
    result_count: int = Field(
        0,
        ge=0,
        description="Number of results from last execution",
    )


class SearchHistoryResponse(BaseResponseSchema):
    """Search history entry response."""

    user_id: Optional[UUID] = Field(
        None,
        description="User ID (null for anonymous searches)",
    )
    query: str = Field(..., description="Search query")
    search_criteria: Dict[str, Any] = Field(
        ...,
        description="Complete search parameters",
    )
    result_count: int = Field(
        ...,
        ge=0,
        description="Number of results returned",
    )
    execution_time_ms: int = Field(
        ...,
        ge=0,
        description="Query execution time in milliseconds",
    )
    clicked_result_ids: List[UUID] = Field(
        default_factory=list,
        description="IDs of hostels clicked from this search",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\search\search_response.py ---
# --- File: app/schemas/search/search_response.py ---
"""
Search response schemas with comprehensive result metadata.

Provides schemas for:
- Search result items
- Faceted search responses
- Search metadata and diagnostics
- Search suggestions
"""

from __future__ import annotations

from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseSchema

__all__ = [
    "SearchResultItem",
    "SearchMetadata",
    "FacetBucket",
    "FacetedSearchResponse",
    "SearchSuggestion",
]


class SearchResultItem(BaseSchema):
    """
    Individual search result item.

    Wraps hostel data with search-specific metadata like relevance score.
    """

    # Hostel identifier
    hostel_id: UUID = Field(
        ...,
        description="Unique hostel identifier",
    )

    # Basic hostel information (denormalized for performance)
    name: str = Field(..., description="Hostel name")
    slug: str = Field(..., description="URL-friendly slug")
    hostel_type: str = Field(..., description="Hostel type")

    # Location
    city: str = Field(..., description="City")
    state: str = Field(..., description="State")
    address_line1: str = Field(..., description="Primary address")

    # Pricing
    min_price: Decimal = Field(
        ...,
        ge=0,
        description="Minimum monthly price across all rooms",
    )
    max_price: Decimal = Field(
        ...,
        ge=0,
        description="Maximum monthly price across all rooms",
    )

    # Ratings and reviews
    average_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average rating (0-5)",
    )
    total_reviews: int = Field(
        0,
        ge=0,
        description="Total number of reviews",
    )

    # Availability
    available_beds: int = Field(
        0,
        ge=0,
        description="Number of currently available beds",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total bed capacity",
    )

    # Media
    thumbnail_url: Optional[str] = Field(
        None,
        description="Primary image URL",
    )
    image_urls: List[str] = Field(
        default_factory=list,
        description="Additional image URLs",
    )

    # Amenities (top/featured only for performance)
    featured_amenities: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Top featured amenities",
    )

    # Verification and quality indicators
    is_verified: bool = Field(
        False,
        description="Hostel verification status",
    )
    is_featured: bool = Field(
        False,
        description="Featured/promoted status",
    )

    # Search-specific metadata
    relevance_score: Decimal = Field(
        ...,
        ge=0,
        description="Relevance score from search engine (higher = more relevant)",
    )
    distance_km: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Distance from search location (if proximity search)",
    )

    # Highlighting (search term matches)
    highlights: Dict[str, List[str]] = Field(
        default_factory=dict,
        description="Highlighted snippets showing search term matches",
        examples=[{"name": ["Best <em>Hostel</em> in Mumbai"]}],
    )

    @computed_field
    @property
    def occupancy_rate(self) -> Decimal:
        """Calculate current occupancy rate as percentage."""
        if self.total_beds == 0:
            return Decimal("0")
        occupied = self.total_beds - self.available_beds
        return Decimal(occupied / self.total_beds * 100).quantize(Decimal("0.01"))

    @computed_field
    @property
    def has_availability(self) -> bool:
        """Check if hostel has any available beds."""
        return self.available_beds > 0


class SearchMetadata(BaseSchema):
    """
    Search execution metadata and diagnostics.

    Provides insights into search performance and result quality.
    """

    # Result counts
    total_results: int = Field(
        ...,
        ge=0,
        description="Total number of matching results",
    )
    returned_results: int = Field(
        ...,
        ge=0,
        description="Number of results in current page",
    )

    # Pagination
    page: int = Field(
        ...,
        ge=1,
        description="Current page number",
    )
    page_size: int = Field(
        ...,
        ge=1,
        description="Results per page",
    )
    total_pages: int = Field(
        ...,
        ge=0,
        description="Total number of pages",
    )

    # Performance metrics
    query_time_ms: int = Field(
        ...,
        ge=0,
        description="Search execution time in milliseconds",
    )
    fetch_time_ms: Optional[int] = Field(
        None,
        ge=0,
        description="Data fetch time in milliseconds",
    )

    # Query information
    applied_filters: Dict[str, Any] = Field(
        default_factory=dict,
        description="Filters that were applied to this search",
    )
    sort_criteria: str = Field(
        ...,
        description="Sort order applied",
    )

    # Result quality indicators
    max_score: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Highest relevance score in results",
    )
    min_score: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Lowest relevance score in results",
    )

    # Debug information (optional, for development)
    debug_info: Optional[Dict[str, Any]] = Field(
        None,
        description="Debug information (available in development mode)",
    )

    @computed_field
    @property
    def has_next_page(self) -> bool:
        """Check if there are more pages available."""
        return self.page < self.total_pages

    @computed_field
    @property
    def has_previous_page(self) -> bool:
        """Check if there are previous pages."""
        return self.page > 1


class FacetBucket(BaseSchema):
    """
    Single facet value with count.

    Used in faceted search to show available filter options.
    """

    value: str = Field(
        ...,
        description="Facet value (e.g., 'Mumbai' for city facet)",
    )
    label: str = Field(
        ...,
        description="Human-readable label",
    )
    count: int = Field(
        ...,
        ge=0,
        description="Number of results with this facet value",
    )
    is_selected: bool = Field(
        False,
        description="Whether this facet is currently selected/active",
    )

    # Additional metadata
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description="Additional facet-specific metadata",
    )


class FacetedSearchResponse(BaseSchema):
    """
    Complete faceted search response.

    Includes results, facets, and comprehensive metadata.
    """

    # Search results
    results: List[SearchResultItem] = Field(
        default_factory=list,
        description="Search result items",
    )

    # Metadata
    metadata: SearchMetadata = Field(
        ...,
        description="Search execution metadata",
    )

    # Facets for filtering
    facets: Dict[str, List[FacetBucket]] = Field(
        default_factory=dict,
        description="Available facets organized by facet name",
        examples=[
            {
                "city": [
                    {"value": "mumbai", "label": "Mumbai", "count": 45},
                    {"value": "bangalore", "label": "Bangalore", "count": 32},
                ],
                "hostel_type": [
                    {"value": "boys", "label": "Boys", "count": 50},
                    {"value": "girls", "label": "Girls", "count": 27},
                ],
            }
        ],
    )

    # Search suggestions (for query refinement)
    suggestions: List["SearchSuggestion"] = Field(
        default_factory=list,
        description="Suggested query refinements",
    )

    @computed_field
    @property
    def is_empty(self) -> bool:
        """Check if search returned no results."""
        return len(self.results) == 0

    @computed_field
    @property
    def facet_names(self) -> List[str]:
        """Get list of available facet names."""
        return list(self.facets.keys())


class SearchSuggestion(BaseSchema):
    """
    Search query suggestion for refinement.

    Helps users refine their search when results are poor.
    """

    suggestion_type: str = Field(
        ...,
        pattern=r"^(spell_correction|alternative_query|related_search|popular_search)$",
        description="Type of suggestion",
    )
    text: str = Field(
        ...,
        description="Suggested search text",
    )
    reason: Optional[str] = Field(
        None,
        description="Why this suggestion is offered",
        examples=[
            "Did you mean...",
            "Popular search",
            "Related to your search",
        ],
    )
    expected_results: Optional[int] = Field(
        None,
        ge=0,
        description="Estimated number of results for this suggestion",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\search\search_sort.py ---
# --- File: app/schemas/search/search_sort.py ---
"""
Search sorting schemas with type-safe sort options.

Provides strongly-typed sorting criteria for search results.
"""

from __future__ import annotations

from enum import Enum

from pydantic import Field, field_validator

from app.schemas.common.base import BaseSchema

__all__ = [
    "SearchSortField",
    "SearchSortOrder",
    "SortCriteria",
]


class SearchSortField(str, Enum):
    """
    Available sort fields for search results.

    Provides type-safe sort field options.
    """

    RELEVANCE = "relevance"
    PRICE_LOW_TO_HIGH = "price_asc"
    PRICE_HIGH_TO_LOW = "price_desc"
    RATING_HIGH_TO_LOW = "rating_desc"
    DISTANCE_NEAR_TO_FAR = "distance_asc"
    NEWEST_FIRST = "newest"
    POPULAR = "popular"
    AVAILABILITY = "availability"


class SearchSortOrder(str, Enum):
    """Sort order direction."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class SortCriteria(BaseSchema):
    """
    Sort criteria for search results.

    Provides flexible sorting with primary and optional secondary sort.
    """

    sort_by: SearchSortField = Field(
        SearchSortField.RELEVANCE,
        description="Primary sort field",
    )
    sort_order: SearchSortOrder = Field(
        SearchSortOrder.DESCENDING,
        description="Sort direction (for applicable fields)",
    )

    # Secondary sort (for tie-breaking)
    secondary_sort_by: Optional[SearchSortField] = Field(
        None,
        description="Secondary sort field for tie-breaking",
    )
    secondary_sort_order: Optional[SearchSortOrder] = Field(
        None,
        description="Secondary sort direction",
    )

    @field_validator("sort_by")
    @classmethod
    def validate_sort_field(cls, v: SearchSortField) -> SearchSortField:
        """Validate sort field is appropriate."""
        # Some sort fields have implicit direction
        implicit_direction_fields = {
            SearchSortField.PRICE_LOW_TO_HIGH,
            SearchSortField.PRICE_HIGH_TO_LOW,
            SearchSortField.RATING_HIGH_TO_LOW,
            SearchSortField.DISTANCE_NEAR_TO_FAR,
        }

        # These fields encode direction in the field name
        # The sort_order parameter will be ignored for them
        return v

    @property
    def effective_sort_order(self) -> SearchSortOrder:
        """
        Get effective sort order based on sort field.

        Some fields have implicit direction (e.g., price_asc always means ascending).
        """
        # Fields with implicit direction
        if self.sort_by == SearchSortField.PRICE_LOW_TO_HIGH:
            return SearchSortOrder.ASCENDING
        elif self.sort_by == SearchSortField.PRICE_HIGH_TO_LOW:
            return SearchSortOrder.DESCENDING
        elif self.sort_by == SearchSortField.RATING_HIGH_TO_LOW:
            return SearchSortOrder.DESCENDING
        elif self.sort_by == SearchSortField.DISTANCE_NEAR_TO_FAR:
            return SearchSortOrder.ASCENDING

        # For other fields, use specified sort_order
        return self.sort_order

    def to_db_sort(self) -> tuple[str, str]:
        """
        Convert to database sort parameters.

        Returns:
            Tuple of (field_name, direction) for database queries
        """
        field_mapping = {
            SearchSortField.RELEVANCE: "relevance_score",
            SearchSortField.PRICE_LOW_TO_HIGH: "min_price",
            SearchSortField.PRICE_HIGH_TO_LOW: "max_price",
            SearchSortField.RATING_HIGH_TO_LOW: "average_rating",
            SearchSortField.DISTANCE_NEAR_TO_FAR: "distance",
            SearchSortField.NEWEST_FIRST: "created_at",
            SearchSortField.POPULAR: "popularity_score",
            SearchSortField.AVAILABILITY: "available_beds",
        }

        field = field_mapping.get(self.sort_by, "relevance_score")
        direction = self.effective_sort_order.value

        return field, direction

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\search\__init__.py ---
# --- File: app/schemas/search/__init__.py ---
"""
Search schemas package.

Provides comprehensive search functionality including:
- Basic and advanced hostel search
- Autocomplete and suggestions
- Search analytics and insights
- Faceted search with filtering
- Search history tracking

Example:
    from app.schemas.search import (
        AdvancedSearchRequest,
        FacetedSearchResponse,
        SearchAnalytics,
    )
"""

from __future__ import annotations

from app.schemas.search.search_analytics import (
    PopularSearchTerm,
    SearchAnalytics,
    SearchAnalyticsRequest,
    SearchMetrics,
    SearchTermStats,
    TrendingSearch,
    ZeroResultTerm,
)
from app.schemas.search.search_autocomplete import (
    AutocompleteRequest,
    AutocompleteResponse,
    Suggestion,
    SuggestionType,
)
from app.schemas.search.search_filters import (
    AmenityFilter,
    AvailabilityFilter,
    LocationFilter,
    PriceFilter,
    RatingFilter,
    SearchFilterSet,
)
from app.schemas.search.search_request import (
    AdvancedSearchRequest,
    BasicSearchRequest,
    NearbySearchRequest,
    SavedSearchCreate,
    SavedSearchResponse,
    SavedSearchUpdate,
    SearchHistoryResponse,
)
from app.schemas.search.search_response import (
    FacetBucket,
    FacetedSearchResponse,
    SearchMetadata,
    SearchResultItem,
    SearchSuggestion,
)
from app.schemas.search.search_sort import (
    SearchSortField,
    SearchSortOrder,
    SortCriteria,
)

__all__ = [
    # Request schemas
    "BasicSearchRequest",
    "AdvancedSearchRequest",
    "NearbySearchRequest",
    "SavedSearchCreate",
    "SavedSearchUpdate",
    # Response schemas
    "SearchResultItem",
    "FacetedSearchResponse",
    "SearchMetadata",
    "SearchSuggestion",
    "FacetBucket",
    "SavedSearchResponse",
    "SearchHistoryResponse",
    # Autocomplete
    "AutocompleteRequest",
    "AutocompleteResponse",
    "Suggestion",
    "SuggestionType",
    # Filters
    "PriceFilter",
    "RatingFilter",
    "AmenityFilter",
    "LocationFilter",
    "AvailabilityFilter",
    "SearchFilterSet",
    # Sort
    "SortCriteria",
    "SearchSortField",
    "SearchSortOrder",
    # Analytics
    "SearchAnalytics",
    "SearchAnalyticsRequest",
    "SearchTermStats",
    "SearchMetrics",
    "PopularSearchTerm",
    "TrendingSearch",
    "ZeroResultTerm",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\student =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\student ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\student =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\student_base.py ---
# --- File: app/schemas/student/student_base.py ---
"""
Student base schemas with enhanced validation and type safety.

Provides core student management schemas including creation, updates,
check-in/check-out operations, and student-specific attributes.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import (
    DietaryPreference,
    IDProofType,
    StudentStatus,
)

__all__ = [
    "StudentBase",
    "StudentCreate",
    "StudentUpdate",
    "StudentCheckInRequest",
    "StudentCheckOutRequest",
    "StudentRoomAssignment",
    "StudentStatusUpdate",
]


class StudentBase(BaseSchema):
    """
    Base student schema with comprehensive student attributes.
    
    Contains common fields shared across student operations including
    identification, guardian info, institutional/employment details,
    and preferences.
    """

    user_id: str = Field(
        ...,
        description="Associated user ID",
    )
    hostel_id: str = Field(
        ...,
        description="Current hostel ID",
    )
    room_id: Optional[str] = Field(
        default=None,
        description="Assigned room ID (null if not assigned)",
    )
    bed_id: Optional[str] = Field(
        default=None,
        description="Assigned bed ID (null if not assigned)",
    )

    # Identification documents
    id_proof_type: Optional[IDProofType] = Field(
        default=None,
        description="Type of ID proof submitted",
    )
    id_proof_number: Optional[str] = Field(
        default=None,
        max_length=50,
        description="ID proof number/reference",
    )
    id_proof_document_url: Optional[str] = Field(
        default=None,
        description="Uploaded ID proof document URL",
    )

    # Guardian information (mandatory for students)
    guardian_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Guardian/parent full name",
        examples=["John Smith", "Mrs. Jane Doe"],
    )
    guardian_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Guardian contact phone (E.164 format)",
        examples=["+919876543210", "9876543210"],
    )
    guardian_email: Optional[str] = Field(
        default=None,
        description="Guardian email address",
    )
    guardian_relation: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Relation to student",
        examples=["Father", "Mother", "Uncle", "Guardian"],
    )
    guardian_address: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Guardian residential address",
    )

    # Institutional information (for students)
    institution_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="College/University/School name",
        examples=["IIT Delhi", "Delhi University", "XYZ College"],
    )
    course: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Course/Program name",
        examples=["B.Tech Computer Science", "MBA", "BA Economics"],
    )
    year_of_study: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Current year/semester",
        examples=["1st Year", "3rd Semester", "Final Year"],
    )
    student_id_number: Optional[str] = Field(
        default=None,
        max_length=100,
        description="College/University ID number",
    )
    institutional_id_url: Optional[str] = Field(
        default=None,
        description="Uploaded institutional ID card URL",
    )

    # Employment information (for working professionals)
    company_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Employer/Company name",
        examples=["Google India", "Infosys", "Startup XYZ"],
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Job title/designation",
        examples=["Software Engineer", "Marketing Manager", "Analyst"],
    )
    company_id_url: Optional[str] = Field(
        default=None,
        description="Company ID card URL",
    )

    # Check-in/Check-out dates
    check_in_date: Optional[date] = Field(
        default=None,
        description="Actual check-in date",
    )
    expected_checkout_date: Optional[date] = Field(
        default=None,
        description="Expected/planned checkout date",
    )
    actual_checkout_date: Optional[date] = Field(
        default=None,
        description="Actual checkout date (when checked out)",
    )

    # Financial information
    security_deposit_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Security deposit amount",
    )
    security_deposit_paid: bool = Field(
        default=False,
        description="Security deposit payment status",
    )
    security_deposit_paid_date: Optional[date] = Field(
        default=None,
        description="Date security deposit was paid",
    )
    monthly_rent_amount: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Monthly rent amount for the student",
    )

    # Meal preferences
    mess_subscribed: bool = Field(
        default=False,
        description="Subscribed to mess/canteen facility",
    )
    dietary_preference: Optional[DietaryPreference] = Field(
        default=None,
        description="Dietary preference (veg/non-veg/vegan/jain)",
    )
    food_allergies: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Food allergies and restrictions",
        examples=["Peanuts, Shellfish", "Lactose intolerant", "Gluten allergy"],
    )

    # Status tracking
    student_status: StudentStatus = Field(
        default=StudentStatus.ACTIVE,
        description="Current student status",
    )
    notice_period_start: Optional[date] = Field(
        default=None,
        description="Notice period start date (if leaving)",
    )
    notice_period_end: Optional[date] = Field(
        default=None,
        description="Notice period end date",
    )

    @field_validator("guardian_name")
    @classmethod
    def validate_guardian_name(cls, v: str) -> str:
        """
        Validate and normalize guardian name.
        
        Ensures name is properly formatted and trimmed.
        """
        v = v.strip()
        if len(v) < 2:
            raise ValueError("Guardian name must be at least 2 characters")
        if v.isdigit():
            raise ValueError("Guardian name cannot be only numbers")
        # Remove excessive whitespace
        v = " ".join(v.split())
        return v

    @field_validator("guardian_phone")
    @classmethod
    def normalize_guardian_phone(cls, v: str) -> str:
        """Normalize guardian phone number."""
        return v.replace(" ", "").replace("-", "").strip()

    @field_validator("guardian_email")
    @classmethod
    def normalize_guardian_email(cls, v: Optional[str]) -> Optional[str]:
        """Normalize guardian email."""
        if v is not None:
            return v.lower().strip()
        return v

    @field_validator("id_proof_number")
    @classmethod
    def validate_id_proof_number(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize ID proof number."""
        if v is not None:
            v = v.strip().upper()
            if not v:
                return None
            # Remove excessive whitespace
            v = " ".join(v.split())
        return v

    @field_validator(
        "institution_name",
        "course",
        "company_name",
        "designation",
    )
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Remove excessive whitespace
            v = " ".join(v.split())
        return v

    @model_validator(mode="after")
    def validate_checkout_dates(self) -> "StudentBase":
        """
        Validate checkout date relationships.
        
        Ensures expected checkout is after check-in and actual is after expected.
        """
        if self.check_in_date and self.expected_checkout_date:
            if self.expected_checkout_date <= self.check_in_date:
                raise ValueError(
                    "Expected checkout date must be after check-in date"
                )

        if self.check_in_date and self.actual_checkout_date:
            if self.actual_checkout_date < self.check_in_date:
                raise ValueError(
                    "Actual checkout date cannot be before check-in date"
                )

        return self

    @model_validator(mode="after")
    def validate_notice_period(self) -> "StudentBase":
        """Validate notice period dates."""
        if self.notice_period_start and self.notice_period_end:
            if self.notice_period_end <= self.notice_period_start:
                raise ValueError(
                    "Notice period end must be after start date"
                )
        return self

    @model_validator(mode="after")
    def validate_institutional_or_employment(self) -> "StudentBase":
        """
        Validate that either institutional or employment info is provided.
        
        Students should be either studying or working.
        Note: This is a soft validation - we don't raise error to allow flexibility.
        """
        has_institution = any(
            [
                self.institution_name,
                self.course,
                self.student_id_number,
            ]
        )
        has_employment = any([self.company_name, self.designation])

        # Just log or track - don't enforce strictly
        # This allows for gap year students, etc.

        return self

    @model_validator(mode="after")
    def validate_room_bed_consistency(self) -> "StudentBase":
        """Validate room and bed assignment consistency."""
        # If bed is assigned, room must be assigned
        if self.bed_id and not self.room_id:
            raise ValueError(
                "Cannot assign bed without assigning room"
            )
        return self


class StudentCreate(StudentBase, BaseCreateSchema):
    """
    Schema for creating a new student record.
    
    Used when converting a booking to student or direct student registration.
    """

    # Override to ensure required fields
    user_id: str = Field(
        ...,
        description="User ID (required)",
    )
    hostel_id: str = Field(
        ...,
        description="Hostel ID (required)",
    )
    guardian_name: str = Field(
        ...,
        min_length=2,
        description="Guardian name (required)",
    )
    guardian_phone: str = Field(
        ...,
        description="Guardian phone (required)",
    )

    # Optional link to source booking
    booking_id: Optional[str] = Field(
        default=None,
        description="Source booking ID (if converted from booking)",
    )

    # Initial payment status
    initial_rent_paid: bool = Field(
        default=False,
        description="Whether initial/first month rent is paid",
    )


class StudentUpdate(BaseUpdateSchema):
    """
    Schema for updating student information.
    
    All fields are optional for partial updates.
    """

    # Room assignment updates
    room_id: Optional[str] = Field(
        default=None,
        description="Updated room ID",
    )
    bed_id: Optional[str] = Field(
        default=None,
        description="Updated bed ID",
    )

    # Identification updates
    id_proof_type: Optional[IDProofType] = Field(
        default=None,
        description="ID proof type",
    )
    id_proof_number: Optional[str] = Field(
        default=None,
        max_length=50,
        description="ID proof number",
    )
    id_proof_document_url: Optional[str] = Field(
        default=None,
        description="ID proof document URL",
    )

    # Guardian updates
    guardian_name: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=255,
        description="Guardian name",
    )
    guardian_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Guardian phone",
    )
    guardian_email: Optional[str] = Field(
        default=None,
        description="Guardian email",
    )
    guardian_relation: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Guardian relation",
    )
    guardian_address: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Guardian address",
    )

    # Institutional updates
    institution_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Institution name",
    )
    course: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Course",
    )
    year_of_study: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Year of study",
    )
    student_id_number: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Student ID number",
    )
    institutional_id_url: Optional[str] = Field(
        default=None,
        description="Institutional ID URL",
    )

    # Employment updates
    company_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Company name",
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Designation",
    )
    company_id_url: Optional[str] = Field(
        default=None,
        description="Company ID URL",
    )

    # Date updates
    check_in_date: Optional[date] = Field(
        default=None,
        description="Check-in date",
    )
    expected_checkout_date: Optional[date] = Field(
        default=None,
        description="Expected checkout date",
    )
    actual_checkout_date: Optional[date] = Field(
        default=None,
        description="Actual checkout date",
    )

    # Financial updates
    security_deposit_amount: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Security deposit amount",
    )
    security_deposit_paid: Optional[bool] = Field(
        default=None,
        description="Security deposit paid status",
    )
    security_deposit_paid_date: Optional[date] = Field(
        default=None,
        description="Security deposit paid date",
    )
    monthly_rent_amount: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Monthly rent amount",
    )

    # Meal updates
    mess_subscribed: Optional[bool] = Field(
        default=None,
        description="Mess subscription status",
    )
    dietary_preference: Optional[DietaryPreference] = Field(
        default=None,
        description="Dietary preference",
    )
    food_allergies: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Food allergies",
    )

    # Status updates
    student_status: Optional[StudentStatus] = Field(
        default=None,
        description="Student status",
    )
    notice_period_start: Optional[date] = Field(
        default=None,
        description="Notice period start",
    )
    notice_period_end: Optional[date] = Field(
        default=None,
        description="Notice period end",
    )

    # Apply same validators as base
    _validate_guardian_name = field_validator("guardian_name")(
        StudentBase.validate_guardian_name.__func__
    )
    _normalize_guardian_phone = field_validator("guardian_phone")(
        StudentBase.normalize_guardian_phone.__func__
    )
    _normalize_guardian_email = field_validator("guardian_email")(
        StudentBase.normalize_guardian_email.__func__
    )
    _validate_id_proof = field_validator("id_proof_number")(
        StudentBase.validate_id_proof_number.__func__
    )
    _normalize_text = field_validator(
        "institution_name",
        "course",
        "company_name",
        "designation",
    )(StudentBase.normalize_text_fields.__func__)


class StudentCheckInRequest(BaseCreateSchema):
    """
    Schema for student check-in operation.
    
    Handles the complete check-in process with room/bed assignment
    and payment verification.
    """

    student_id: str = Field(
        ...,
        description="Student ID to check in",
    )
    check_in_date: date = Field(
        ...,
        description="Check-in date",
    )
    room_id: str = Field(
        ...,
        description="Assigned room ID",
    )
    bed_id: str = Field(
        ...,
        description="Assigned bed ID",
    )

    # Payment verification
    security_deposit_paid: bool = Field(
        default=False,
        description="Security deposit payment confirmation",
    )
    security_deposit_payment_id: Optional[str] = Field(
        default=None,
        description="Security deposit payment reference ID",
    )
    initial_rent_paid: bool = Field(
        default=False,
        description="First month rent payment confirmation",
    )
    initial_rent_payment_id: Optional[str] = Field(
        default=None,
        description="Initial rent payment reference ID",
    )

    # Additional charges
    mess_advance_paid: bool = Field(
        default=False,
        description="Mess advance payment (if applicable)",
    )
    other_charges_paid: bool = Field(
        default=False,
        description="Other charges payment confirmation",
    )

    # Documentation
    id_proof_verified: bool = Field(
        default=False,
        description="ID proof verification status",
    )
    documents_collected: bool = Field(
        default=False,
        description="All required documents collected",
    )

    # Notes
    check_in_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Check-in notes and observations",
    )

    @field_validator("check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date is reasonable."""
        from datetime import timedelta

        today = date.today()

        # Allow up to 30 days in the past for data entry
        if v < today - timedelta(days=30):
            raise ValueError(
                "Check-in date cannot be more than 30 days in the past"
            )

        # Warn if more than 7 days in future
        if v > today + timedelta(days=7):
            raise ValueError(
                "Check-in date cannot be more than 7 days in the future"
            )

        return v

    @model_validator(mode="after")
    def validate_payment_references(self) -> "StudentCheckInRequest":
        """Validate payment reference IDs are provided when payments are confirmed."""
        if self.security_deposit_paid and not self.security_deposit_payment_id:
            raise ValueError(
                "Security deposit payment ID is required when payment is confirmed"
            )

        if self.initial_rent_paid and not self.initial_rent_payment_id:
            raise ValueError(
                "Initial rent payment ID is required when payment is confirmed"
            )

        return self


class StudentCheckOutRequest(BaseCreateSchema):
    """
    Schema for student check-out operation.
    
    Handles the complete checkout process with clearance verification
    and refund processing.
    """

    student_id: str = Field(
        ...,
        description="Student ID to check out",
    )
    checkout_date: date = Field(
        ...,
        description="Actual checkout date",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for checkout",
        examples=[
            "Course completion",
            "Job relocation",
            "Personal reasons",
            "Transferred to another hostel",
        ],
    )

    # Financial clearance
    final_dues_cleared: bool = Field(
        default=False,
        description="All outstanding dues cleared",
    )
    outstanding_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Outstanding amount (if any)",
    )
    refund_security_deposit: bool = Field(
        default=True,
        description="Refund security deposit",
    )
    security_deposit_refund_amount: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Security deposit refund amount (after deductions)",
    )
    deduction_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Deductions from security deposit",
    )
    deduction_reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for deductions",
    )

    # Room clearance
    room_condition_acceptable: bool = Field(
        default=True,
        description="Room condition is acceptable",
    )
    damages_reported: bool = Field(
        default=False,
        description="Any damages reported",
    )
    damage_charges: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Charges for damages",
    )

    # Property return
    key_returned: bool = Field(
        default=False,
        description="Room key returned",
    )
    id_card_returned: bool = Field(
        default=False,
        description="Hostel ID card returned",
    )
    other_items_returned: bool = Field(
        default=False,
        description="Other borrowed items returned",
    )

    # Clearance from departments
    mess_clearance: bool = Field(
        default=True,
        description="Mess dues cleared",
    )
    library_clearance: bool = Field(
        default=True,
        description="Library clearance obtained",
    )
    maintenance_clearance: bool = Field(
        default=True,
        description="No pending maintenance complaints",
    )

    # Notes
    checkout_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Checkout notes and observations",
    )
    forwarding_address: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Forwarding address for correspondence",
    )

    @field_validator("checkout_date")
    @classmethod
    def validate_checkout_date(cls, v: date) -> date:
        """Validate checkout date."""
        from datetime import timedelta

        today = date.today()

        # Allow past dates for data entry
        # Future dates for scheduled checkout
        if v > today + timedelta(days=90):
            raise ValueError(
                "Checkout date cannot be more than 90 days in the future"
            )

        return v

    @model_validator(mode="after")
    def validate_financial_consistency(self) -> "StudentCheckOutRequest":
        """Validate financial data consistency."""
        if not self.final_dues_cleared and self.outstanding_amount == 0:
            raise ValueError(
                "If dues are not cleared, outstanding amount must be greater than 0"
            )

        if self.refund_security_deposit and self.security_deposit_refund_amount is None:
            raise ValueError(
                "Security deposit refund amount is required when refunding deposit"
            )

        return self

    @model_validator(mode="after")
    def validate_clearance_requirements(self) -> "StudentCheckOutRequest":
        """Validate clearance requirements."""
        # If damages reported or poor room condition, require damage charges or reason
        if self.damages_reported or not self.room_condition_acceptable:
            if self.damage_charges == 0 and not self.deduction_reason:
                raise ValueError(
                    "Damage charges or deduction reason required for reported damages"
                )

        return self


class StudentRoomAssignment(BaseCreateSchema):
    """
    Schema for assigning/reassigning room and bed to student.
    
    Dedicated schema for room/bed assignment operations.
    """

    student_id: str = Field(
        ...,
        description="Student ID",
    )
    room_id: str = Field(
        ...,
        description="Room ID to assign",
    )
    bed_id: str = Field(
        ...,
        description="Bed ID to assign",
    )
    assignment_date: date = Field(
        ...,
        description="Assignment effective date",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for assignment/reassignment",
    )

    # Financial impact
    rent_adjustment: Optional[Decimal] = Field(
        default=None,
        description="Rent adjustment due to room change",
    )
    prorated_rent: bool = Field(
        default=True,
        description="Calculate prorated rent for partial month",
    )

    @field_validator("assignment_date")
    @classmethod
    def validate_assignment_date(cls, v: date) -> date:
        """Validate assignment date."""
        from datetime import timedelta

        today = date.today()

        if v < today - timedelta(days=7):
            raise ValueError(
                "Assignment date cannot be more than 7 days in the past"
            )

        return v


class StudentStatusUpdate(BaseCreateSchema):
    """
    Schema for updating student status.
    
    Handles status transitions with proper tracking and documentation.
    """

    student_id: str = Field(
        ...,
        description="Student ID",
    )
    new_status: StudentStatus = Field(
        ...,
        description="New student status",
    )
    effective_date: date = Field(
        ...,
        description="Status change effective date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for status change",
    )

    # For notice period status
    notice_period_days: Optional[int] = Field(
        default=None,
        ge=0,
        le=90,
        description="Notice period duration in days",
    )

    # For suspension
    suspension_end_date: Optional[date] = Field(
        default=None,
        description="Suspension end date (for SUSPENDED status)",
    )

    # Additional notes
    admin_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Administrative notes",
    )

    @model_validator(mode="after")
    def validate_status_specific_fields(self) -> "StudentStatusUpdate":
        """Validate status-specific required fields."""
        if self.new_status == StudentStatus.SUSPENDED:
            if not self.suspension_end_date:
                raise ValueError(
                    "Suspension end date is required for SUSPENDED status"
                )

        if self.new_status == StudentStatus.NOTICE_PERIOD:
            if not self.notice_period_days:
                raise ValueError(
                    "Notice period duration is required for NOTICE_PERIOD status"
                )

        return self

    @model_validator(mode="after")
    def validate_suspension_date(self) -> "StudentStatusUpdate":
        """Validate suspension end date."""
        if self.suspension_end_date:
            if self.suspension_end_date <= self.effective_date:
                raise ValueError(
                    "Suspension end date must be after effective date"
                )

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\student_dashboard.py ---
# --- File: app/schemas/student/student_dashboard.py ---
"""
Student dashboard schemas with comprehensive overview data.

Provides schemas for student dashboard, statistics, summaries,
and quick-view information.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseSchema

__all__ = [
    "StudentDashboard",
    "StudentFinancialSummary",
    "AttendanceSummary",
    "StudentStats",
    "RecentPayment",
    "RecentComplaint",
    "PendingLeave",
    "RecentAnnouncement",
    "TodayMessMenu",
    "UpcomingEvent",
]


class StudentFinancialSummary(BaseSchema):
    """
    Financial summary for student dashboard.
    
    Provides quick overview of payment status and dues.
    """

    monthly_rent: Decimal = Field(..., description="Monthly rent amount")
    next_due_date: date = Field(..., description="Next payment due date")
    amount_due: Decimal = Field(..., description="Current amount due")
    amount_overdue: Decimal = Field(..., description="Overdue amount")
    advance_balance: Decimal = Field(..., description="Advance payment balance")
    security_deposit: Decimal = Field(..., description="Security deposit amount")

    # Mess charges
    mess_charges: Decimal = Field(
        default=Decimal("0.00"),
        description="Monthly mess charges",
    )
    mess_balance: Decimal = Field(
        default=Decimal("0.00"),
        description="Mess account balance",
    )

    # Payment status
    payment_status: str = Field(
        ...,
        pattern=r"^(current|due_soon|overdue)$",
        description="Overall payment status",
    )
    days_until_due: Optional[int] = Field(
        default=None,
        description="Days until next payment due",
    )
    days_overdue: Optional[int] = Field(
        default=None,
        ge=0,
        description="Days payment is overdue",
    )

    @computed_field
    @property
    def total_outstanding(self) -> Decimal:
        """Calculate total outstanding amount."""
        return self.amount_due + self.amount_overdue

    @computed_field
    @property
    def net_balance(self) -> Decimal:
        """Calculate net balance (advance - dues)."""
        return self.advance_balance - self.total_outstanding

    @computed_field
    @property
    def is_payment_urgent(self) -> bool:
        """Check if payment is urgent (due in 3 days or overdue)."""
        if self.amount_overdue > 0:
            return True
        if self.days_until_due is not None and self.days_until_due <= 3:
            return True
        return False


class AttendanceSummary(BaseSchema):
    """
    Attendance summary for student dashboard.
    
    Provides attendance statistics and status.
    """

    # Current month
    current_month_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Current month attendance percentage",
    )
    current_month_present: int = Field(
        ...,
        ge=0,
        description="Days present this month",
    )
    current_month_absent: int = Field(
        ...,
        ge=0,
        description="Days absent this month",
    )
    current_month_leaves: int = Field(
        ...,
        ge=0,
        description="Days on leave this month",
    )
    current_month_total_days: int = Field(
        ...,
        ge=0,
        description="Total trackable days this month",
    )

    # Last 30 days
    last_30_days_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Last 30 days attendance percentage",
    )

    # Overall
    overall_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall attendance percentage",
    )
    minimum_required_percentage: Decimal = Field(
        default=Decimal("75.00"),
        description="Minimum required attendance",
    )

    # Status
    attendance_status: str = Field(
        ...,
        pattern=r"^(good|warning|critical)$",
        description="Attendance status indicator",
    )

    # Leaves
    leave_balance: int = Field(
        default=0,
        ge=0,
        description="Remaining leave balance",
    )
    pending_leave_requests: int = Field(
        default=0,
        ge=0,
        description="Pending leave applications",
    )

    @computed_field
    @property
    def is_below_minimum(self) -> bool:
        """Check if attendance is below minimum requirement."""
        return self.overall_percentage < self.minimum_required_percentage

    @computed_field
    @property
    def percentage_gap(self) -> Decimal:
        """Calculate gap from minimum requirement."""
        return self.minimum_required_percentage - self.overall_percentage


class StudentStats(BaseSchema):
    """
    Quick statistics for student dashboard.
    
    Provides key metrics and counts.
    """

    days_in_hostel: int = Field(
        ...,
        ge=0,
        description="Total days as hostel resident",
    )
    months_in_hostel: int = Field(
        ...,
        ge=0,
        description="Total months in hostel",
    )

    # Payments
    total_payments_made: int = Field(
        ...,
        ge=0,
        description="Total number of payments",
    )
    total_amount_paid: Decimal = Field(
        ...,
        ge=0,
        description="Total amount paid",
    )
    last_payment_date: Optional[date] = Field(
        default=None,
        description="Last payment date",
    )

    # Complaints
    complaints_raised: int = Field(
        ...,
        ge=0,
        description="Total complaints raised",
    )
    complaints_resolved: int = Field(
        ...,
        ge=0,
        description="Resolved complaints",
    )
    complaints_pending: int = Field(
        ...,
        ge=0,
        description="Pending complaints",
    )

    # Attendance
    current_attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Current attendance percentage",
    )

    # Mess
    mess_meals_consumed: int = Field(
        default=0,
        ge=0,
        description="Total mess meals consumed",
    )

    @computed_field
    @property
    def complaint_resolution_rate(self) -> Decimal:
        """Calculate complaint resolution rate."""
        if self.complaints_raised == 0:
            return Decimal("100.00")
        return Decimal(
            (self.complaints_resolved / self.complaints_raised * 100)
        ).quantize(Decimal("0.01"))


class RecentPayment(BaseSchema):
    """
    Recent payment item for dashboard.
    
    Displays recent payment transaction.
    """

    payment_id: str = Field(..., description="Payment ID")
    amount: Decimal = Field(..., ge=0, description="Payment amount")
    payment_type: str = Field(..., description="Payment type")
    payment_date: date = Field(..., description="Payment date")
    status: str = Field(..., description="Payment status")
    receipt_url: Optional[str] = Field(
        default=None,
        description="Receipt download URL",
    )
    payment_method: Optional[str] = Field(
        default=None,
        description="Payment method used",
    )


class RecentComplaint(BaseSchema):
    """
    Recent complaint item for dashboard.
    
    Displays recent complaint with status.
    """

    complaint_id: str = Field(..., description="Complaint ID")
    title: str = Field(..., description="Complaint title")
    category: str = Field(..., description="Complaint category")
    status: str = Field(..., description="Current status")
    priority: str = Field(..., description="Priority level")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    assigned_to: Optional[str] = Field(
        default=None,
        description="Assigned staff name",
    )

    @computed_field
    @property
    def days_open(self) -> int:
        """Calculate days since complaint was raised."""
        return (datetime.now() - self.created_at).days


class PendingLeave(BaseSchema):
    """
    Pending leave application for dashboard.
    
    Displays leave request awaiting approval.
    """

    leave_id: str = Field(..., description="Leave application ID")
    leave_type: str = Field(..., description="Leave type")
    from_date: date = Field(..., description="Leave start date")
    to_date: date = Field(..., description="Leave end date")
    total_days: int = Field(..., ge=1, description="Total leave days")
    reason: Optional[str] = Field(default=None, description="Leave reason")
    status: str = Field(..., description="Application status")
    applied_at: datetime = Field(..., description="Application timestamp")

    @computed_field
    @property
    def is_upcoming(self) -> bool:
        """Check if leave is upcoming."""
        return self.from_date > date.today()


class RecentAnnouncement(BaseSchema):
    """
    Recent announcement for dashboard.
    
    Displays hostel announcement.
    """

    announcement_id: str = Field(..., description="Announcement ID")
    title: str = Field(..., description="Announcement title")
    content: Optional[str] = Field(default=None, description="Announcement content")
    category: str = Field(..., description="Category")
    priority: str = Field(..., description="Priority level")
    published_at: datetime = Field(..., description="Published timestamp")
    is_read: bool = Field(default=False, description="Read status")
    is_important: bool = Field(default=False, description="Important flag")

    @computed_field
    @property
    def is_new(self) -> bool:
        """Check if announcement is new (within 24 hours)."""
        from datetime import timedelta

        return datetime.now() - self.published_at < timedelta(hours=24)


class TodayMessMenu(BaseSchema):
    """
    Today's mess menu for dashboard.
    
    Displays daily meal menu.
    """

    date: date = Field(..., description="Menu date")
    breakfast: List[str] = Field(
        default_factory=list,
        description="Breakfast items",
    )
    lunch: List[str] = Field(
        default_factory=list,
        description="Lunch items",
    )
    snacks: List[str] = Field(
        default_factory=list,
        description="Snacks/tea items",
    )
    dinner: List[str] = Field(
        default_factory=list,
        description="Dinner items",
    )
    is_special: bool = Field(
        default=False,
        description="Special menu (festival, etc.)",
    )
    special_occasion: Optional[str] = Field(
        default=None,
        description="Special occasion name",
    )


class UpcomingEvent(BaseSchema):
    """
    Upcoming event for dashboard.
    
    Displays hostel event or activity.
    """

    event_id: str = Field(..., description="Event ID")
    title: str = Field(..., description="Event title")
    description: Optional[str] = Field(default=None, description="Event description")
    event_date: date = Field(..., description="Event date")
    event_time: Optional[str] = Field(default=None, description="Event time")
    location: Optional[str] = Field(default=None, description="Event location")
    category: str = Field(..., description="Event category")
    is_registered: bool = Field(
        default=False,
        description="Student registration status",
    )
    registration_required: bool = Field(
        default=False,
        description="Whether registration is required",
    )

    @computed_field
    @property
    def days_until_event(self) -> int:
        """Calculate days until event."""
        return (self.event_date - date.today()).days


class StudentDashboard(BaseSchema):
    """
    Complete student dashboard.
    
    Aggregates all dashboard components for student overview.
    """

    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )

    # Hostel info
    hostel_name: str = Field(..., description="Current hostel")
    room_number: str = Field(..., description="Room number")
    bed_number: str = Field(..., description="Bed number")
    floor_number: Optional[int] = Field(default=None, description="Floor number")

    # Summaries
    financial_summary: StudentFinancialSummary = Field(
        ...,
        description="Financial overview",
    )
    attendance_summary: AttendanceSummary = Field(
        ...,
        description="Attendance overview",
    )
    stats: StudentStats = Field(
        ...,
        description="Quick statistics",
    )

    # Recent activity
    recent_payments: List[RecentPayment] = Field(
        default_factory=list,
        max_length=5,
        description="Last 5 payments",
    )
    recent_complaints: List[RecentComplaint] = Field(
        default_factory=list,
        max_length=5,
        description="Recent complaints",
    )
    pending_leave_applications: List[PendingLeave] = Field(
        default_factory=list,
        description="Pending leave requests",
    )

    # Announcements and events
    recent_announcements: List[RecentAnnouncement] = Field(
        default_factory=list,
        max_length=5,
        description="Recent announcements",
    )
    upcoming_events: List[UpcomingEvent] = Field(
        default_factory=list,
        max_length=5,
        description="Upcoming events",
    )
    unread_announcements_count: int = Field(
        default=0,
        ge=0,
        description="Unread announcements count",
    )

    # Mess menu
    today_mess_menu: Optional[TodayMessMenu] = Field(
        default=None,
        description="Today's mess menu",
    )

    # Notifications
    unread_notifications_count: int = Field(
        default=0,
        ge=0,
        description="Unread notifications count",
    )

    # Last updated
    dashboard_updated_at: datetime = Field(
        ...,
        description="Dashboard data timestamp",
    )

    @computed_field
    @property
    def has_urgent_items(self) -> bool:
        """Check if there are urgent items requiring attention."""
        # Check for urgent payments
        if self.financial_summary.is_payment_urgent:
            return True

        # Check for critical attendance
        if self.attendance_summary.attendance_status == "critical":
            return True

        # Check for high-priority complaints
        if any(c.priority in ["high", "urgent"] for c in self.recent_complaints):
            return True

        return False

    @computed_field
    @property
    def action_items_count(self) -> int:
        """Count items requiring action."""
        count = 0

        # Pending payments
        if self.financial_summary.amount_due > 0:
            count += 1

        # Pending leave approvals
        count += len(self.pending_leave_applications)

        # Open complaints
        count += sum(
            1 for c in self.recent_complaints if c.status != "resolved"
        )

        return count

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\student_filters.py ---
# --- File: app/schemas/student/student_filters.py ---
"""
Student filter and search schemas with advanced filtering options.

Provides comprehensive filtering, searching, sorting, and bulk operation
schemas for student management.
"""

from __future__ import annotations

from datetime import date
from typing import List, Optional

from pydantic import Field, field_validator

from app.schemas.common.base import BaseFilterSchema, BaseCreateSchema
from app.schemas.common.enums import StudentStatus

__all__ = [
    "StudentFilterParams",
    "StudentSearchRequest",
    "StudentSortOptions",
    "StudentExportRequest",
    "StudentBulkActionRequest",
    "AdvancedStudentFilters",
]


class StudentFilterParams(BaseFilterSchema):
    """
    Student filter parameters.
    
    Comprehensive filtering options for student queries.
    """

    # Text search
    search: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=255,
        description="Search in name, email, phone, room number",
    )

    # Hostel filter
    hostel_id: Optional[str] = Field(
        default=None,
        description="Filter by single hostel ID",
    )
    hostel_ids: Optional[List[str]] = Field(
        default=None,
        min_length=1,
        max_length=10,
        description="Filter by multiple hostel IDs",
    )

    # Room filter
    room_id: Optional[str] = Field(
        default=None,
        description="Filter by specific room",
    )
    room_number: Optional[str] = Field(
        default=None,
        description="Filter by room number",
    )
    room_type: Optional[str] = Field(
        default=None,
        description="Filter by room type",
    )
    floor_number: Optional[int] = Field(
        default=None,
        ge=0,
        le=50,
        description="Filter by floor number",
    )
    wing: Optional[str] = Field(
        default=None,
        description="Filter by wing/block",
    )

    # Status filter
    status: Optional[StudentStatus] = Field(
        default=None,
        description="Filter by single status",
    )
    statuses: Optional[List[StudentStatus]] = Field(
        default=None,
        min_length=1,
        description="Filter by multiple statuses",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Filter by active status",
    )
    is_checked_in: Optional[bool] = Field(
        default=None,
        description="Filter by check-in status",
    )

    # Date filters
    checked_in_after: Optional[date] = Field(
        default=None,
        description="Checked in after this date",
    )
    checked_in_before: Optional[date] = Field(
        default=None,
        description="Checked in before this date",
    )
    expected_checkout_after: Optional[date] = Field(
        default=None,
        description="Expected checkout after this date",
    )
    expected_checkout_before: Optional[date] = Field(
        default=None,
        description="Expected checkout before this date",
    )

    # Financial filters
    has_overdue_payments: Optional[bool] = Field(
        default=None,
        description="Has overdue payments",
    )
    has_advance_balance: Optional[bool] = Field(
        default=None,
        description="Has advance payment balance",
    )
    security_deposit_paid: Optional[bool] = Field(
        default=None,
        description="Security deposit paid status",
    )

    # Meal filter
    mess_subscribed: Optional[bool] = Field(
        default=None,
        description="Subscribed to mess facility",
    )

    # Institutional filters
    institution_name: Optional[str] = Field(
        default=None,
        description="Filter by institution name (partial match)",
    )
    course: Optional[str] = Field(
        default=None,
        description="Filter by course (partial match)",
    )

    # Company filter
    company_name: Optional[str] = Field(
        default=None,
        description="Filter by company name (partial match)",
    )

    # Gender filter
    gender: Optional[str] = Field(
        default=None,
        pattern=r"^(male|female|other)$",
        description="Filter by gender",
    )

    @field_validator("hostel_ids")
    @classmethod
    def validate_unique_hostel_ids(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """Ensure hostel IDs are unique."""
        if v is not None and len(v) != len(set(v)):
            raise ValueError("Hostel IDs must be unique")
        return v

    @field_validator("statuses")
    @classmethod
    def validate_unique_statuses(
        cls, v: Optional[List[StudentStatus]]
    ) -> Optional[List[StudentStatus]]:
        """Ensure statuses are unique."""
        if v is not None and len(v) != len(set(v)):
            raise ValueError("Statuses must be unique")
        return v


class StudentSearchRequest(BaseFilterSchema):
    """
    Student search request.
    
    Full-text search with field selection and filters.
    """

    query: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Search query",
    )
    hostel_id: Optional[str] = Field(
        default=None,
        description="Limit search to specific hostel",
    )

    # Search field selection
    search_in_name: bool = Field(
        default=True,
        description="Search in student name",
    )
    search_in_email: bool = Field(
        default=True,
        description="Search in email address",
    )
    search_in_phone: bool = Field(
        default=True,
        description="Search in phone number",
    )
    search_in_room: bool = Field(
        default=True,
        description="Search in room number",
    )
    search_in_institution: bool = Field(
        default=True,
        description="Search in institution name",
    )
    search_in_company: bool = Field(
        default=False,
        description="Search in company name",
    )
    search_in_guardian: bool = Field(
        default=False,
        description="Search in guardian name",
    )

    # Additional filters
    status: Optional[StudentStatus] = Field(
        default=None,
        description="Filter by status",
    )
    only_active: bool = Field(
        default=True,
        description="Only include active students",
    )

    # Pagination
    page: int = Field(
        default=1,
        ge=1,
        description="Page number",
    )
    page_size: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Results per page",
    )


class StudentSortOptions(BaseFilterSchema):
    """
    Student sorting options.
    
    Defines available sort criteria and order.
    """

    sort_by: str = Field(
        default="created_at",
        pattern=r"^(name|email|room_number|check_in_date|created_at|monthly_rent|status)$",
        description="Field to sort by",
    )
    sort_order: str = Field(
        default="desc",
        pattern=r"^(asc|desc)$",
        description="Sort order (ascending/descending)",
    )

    @field_validator("sort_order")
    @classmethod
    def normalize_sort_order(cls, v: str) -> str:
        """Normalize sort order to lowercase."""
        return v.lower()


class AdvancedStudentFilters(BaseFilterSchema):
    """
    Advanced filtering options.
    
    Additional complex filters for detailed queries.
    """

    # Attendance filters
    min_attendance_percentage: Optional[float] = Field(
        default=None,
        ge=0,
        le=100,
        description="Minimum attendance percentage",
    )
    max_attendance_percentage: Optional[float] = Field(
        default=None,
        ge=0,
        le=100,
        description="Maximum attendance percentage",
    )
    attendance_below_required: Optional[bool] = Field(
        default=None,
        description="Attendance below minimum requirement",
    )

    # Payment behavior
    payment_history: Optional[str] = Field(
        default=None,
        pattern=r"^(good|irregular|poor)$",
        description="Payment history pattern",
    )
    has_pending_complaints: Optional[bool] = Field(
        default=None,
        description="Has open complaints",
    )

    # Duration filters
    min_stay_days: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum stay duration in days",
    )
    max_stay_days: Optional[int] = Field(
        default=None,
        ge=0,
        description="Maximum stay duration in days",
    )

    # Age filters
    min_age: Optional[int] = Field(
        default=None,
        ge=16,
        le=100,
        description="Minimum age",
    )
    max_age: Optional[int] = Field(
        default=None,
        ge=16,
        le=100,
        description="Maximum age",
    )

    # Document verification
    documents_verified: Optional[bool] = Field(
        default=None,
        description="All documents verified",
    )

    @field_validator("max_attendance_percentage")
    @classmethod
    def validate_attendance_range(cls, v: Optional[float], info) -> Optional[float]:
        """Validate attendance percentage range."""
        if v is not None:
            min_att = info.data.get("min_attendance_percentage")
            if min_att is not None and v < min_att:
                raise ValueError(
                    "max_attendance_percentage must be >= min_attendance_percentage"
                )
        return v


class StudentExportRequest(BaseFilterSchema):
    """
    Export students request.
    
    Configures student data export with format and field selection.
    """

    hostel_id: Optional[str] = Field(
        default=None,
        description="Export students from specific hostel",
    )
    filters: Optional[StudentFilterParams] = Field(
        default=None,
        description="Apply filters to export",
    )

    # Export format
    format: str = Field(
        default="csv",
        pattern=r"^(csv|excel|pdf)$",
        description="Export file format",
    )

    # Field selection
    include_financial_data: bool = Field(
        default=False,
        description="Include payment and financial information",
    )
    include_attendance_data: bool = Field(
        default=False,
        description="Include attendance statistics",
    )
    include_guardian_info: bool = Field(
        default=True,
        description="Include guardian information",
    )
    include_institutional_info: bool = Field(
        default=True,
        description="Include college/company information",
    )
    include_contact_details: bool = Field(
        default=True,
        description="Include phone and email",
    )
    include_room_assignment: bool = Field(
        default=True,
        description="Include room and bed details",
    )

    # Additional options
    include_inactive: bool = Field(
        default=False,
        description="Include inactive students",
    )
    include_checkout_students: bool = Field(
        default=False,
        description="Include checked-out students",
    )

    @field_validator("format")
    @classmethod
    def normalize_format(cls, v: str) -> str:
        """Normalize format to lowercase."""
        return v.lower()


class StudentBulkActionRequest(BaseCreateSchema):
    """
    Bulk action on students.
    
    Performs bulk operations on multiple students.
    """

    student_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Student IDs (max 100)",
    )
    action: str = Field(
        ...,
        pattern=r"^(activate|deactivate|send_notification|export|change_status|assign_room|update_rent)$",
        description="Action to perform",
    )

    # Action-specific parameters
    new_status: Optional[StudentStatus] = Field(
        default=None,
        description="New status (for change_status action)",
    )
    notification_message: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Notification message (for send_notification)",
    )
    notification_title: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Notification title",
    )
    new_rent_amount: Optional[float] = Field(
        default=None,
        ge=0,
        description="New rent amount (for update_rent)",
    )
    effective_date: Optional[date] = Field(
        default=None,
        description="Effective date for changes",
    )

    # Confirmation
    confirm_action: bool = Field(
        default=False,
        description="Explicit confirmation for bulk action",
    )

    @field_validator("student_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[str]) -> List[str]:
        """Ensure student IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Student IDs must be unique")
        return v

    @field_validator("action")
    @classmethod
    def normalize_action(cls, v: str) -> str:
        """Normalize action to lowercase."""
        return v.lower()

    @model_validator(mode="after")
    def validate_action_parameters(self) -> "StudentBulkActionRequest":
        """Validate action-specific required parameters."""
        if self.action == "change_status" and not self.new_status:
            raise ValueError("new_status is required for change_status action")

        if self.action == "send_notification":
            if not self.notification_message:
                raise ValueError(
                    "notification_message is required for send_notification action"
                )
            if not self.notification_title:
                raise ValueError(
                    "notification_title is required for send_notification action"
                )

        if self.action == "update_rent" and self.new_rent_amount is None:
            raise ValueError("new_rent_amount is required for update_rent action")

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\student_profile.py ---
# --- File: app/schemas/student/student_profile.py ---
"""
Student profile management schemas with enhanced validation.

Provides schemas for student profile creation, updates, document management,
and preference settings.
"""

from __future__ import annotations

from datetime import datetime
from typing import List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import DietaryPreference, IDProofType

__all__ = [
    "StudentProfileCreate",
    "StudentProfileUpdate",
    "StudentDocuments",
    "DocumentInfo",
    "DocumentUploadRequest",
    "DocumentVerificationRequest",
    "StudentPreferences",
    "StudentPrivacySettings",
]


class StudentProfileCreate(BaseCreateSchema):
    """
    Create student profile (extends user registration).
    
    Used during student onboarding to collect student-specific information.
    """

    # Guardian information (required for students)
    guardian_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Guardian/parent full name",
    )
    guardian_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Guardian contact phone",
    )
    guardian_email: Optional[str] = Field(
        default=None,
        description="Guardian email address",
    )
    guardian_relation: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Relation to student",
        examples=["Father", "Mother", "Uncle", "Guardian"],
    )
    guardian_address: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Guardian residential address",
    )

    # Institutional information (for students)
    institution_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Educational institution name",
    )
    course: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Course/program name",
    )
    year_of_study: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Current year/semester",
    )
    student_id_number: Optional[str] = Field(
        default=None,
        max_length=100,
        description="College/University ID",
    )

    # Employment information (for working professionals)
    company_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Employer name",
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Job designation",
    )

    # ID proof
    id_proof_type: Optional[IDProofType] = Field(
        default=None,
        description="Type of ID proof",
    )
    id_proof_number: Optional[str] = Field(
        default=None,
        max_length=50,
        description="ID proof number",
    )

    # Preferences
    dietary_preference: Optional[DietaryPreference] = Field(
        default=None,
        description="Dietary preference",
    )
    food_allergies: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Food allergies and restrictions",
    )

    @field_validator("guardian_name")
    @classmethod
    def validate_guardian_name(cls, v: str) -> str:
        """Validate and normalize guardian name."""
        v = v.strip()
        if len(v) < 2:
            raise ValueError("Guardian name must be at least 2 characters")
        if v.isdigit():
            raise ValueError("Guardian name cannot be only numbers")
        return " ".join(v.split())

    @field_validator("guardian_phone")
    @classmethod
    def normalize_guardian_phone(cls, v: str) -> str:
        """Normalize guardian phone number."""
        return v.replace(" ", "").replace("-", "").strip()

    @field_validator("guardian_email")
    @classmethod
    def normalize_guardian_email(cls, v: Optional[str]) -> Optional[str]:
        """Normalize guardian email."""
        if v is not None:
            return v.lower().strip()
        return v

    @field_validator(
        "institution_name",
        "course",
        "company_name",
        "designation",
    )
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            return " ".join(v.split())
        return v

    @field_validator("id_proof_number")
    @classmethod
    def normalize_id_proof(cls, v: Optional[str]) -> Optional[str]:
        """Normalize ID proof number."""
        if v is not None:
            v = v.strip().upper()
            if not v:
                return None
            return " ".join(v.split())
        return v

    @model_validator(mode="after")
    def validate_student_or_professional(self) -> "StudentProfileCreate":
        """
        Validate that either institutional or employment info is provided.
        
        Students should be either studying or working.
        """
        has_institution = any(
            [
                self.institution_name,
                self.course,
                self.student_id_number,
            ]
        )
        has_employment = any([self.company_name, self.designation])

        if not has_institution and not has_employment:
            raise ValueError(
                "Either institutional information (for students) or "
                "employment information (for working professionals) must be provided"
            )

        return self


class StudentProfileUpdate(BaseUpdateSchema):
    """
    Update student profile.
    
    All fields optional for partial updates.
    """

    # Guardian updates
    guardian_name: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=255,
        description="Guardian name",
    )
    guardian_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Guardian phone",
    )
    guardian_email: Optional[str] = Field(
        default=None,
        description="Guardian email",
    )
    guardian_relation: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Guardian relation",
    )
    guardian_address: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Guardian address",
    )

    # Institutional updates
    institution_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Institution name",
    )
    course: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Course",
    )
    year_of_study: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Year of study",
    )
    student_id_number: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Student ID",
    )

    # Employment updates
    company_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Company name",
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Designation",
    )

    # ID proof updates
    id_proof_type: Optional[IDProofType] = Field(
        default=None,
        description="ID proof type",
    )
    id_proof_number: Optional[str] = Field(
        default=None,
        max_length=50,
        description="ID proof number",
    )

    # Preferences
    dietary_preference: Optional[DietaryPreference] = Field(
        default=None,
        description="Dietary preference",
    )
    food_allergies: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Food allergies",
    )

    # Apply validators
    _validate_guardian_name = field_validator("guardian_name")(
        StudentProfileCreate.validate_guardian_name.__func__
    )
    _normalize_phone = field_validator("guardian_phone")(
        StudentProfileCreate.normalize_guardian_phone.__func__
    )
    _normalize_email = field_validator("guardian_email")(
        StudentProfileCreate.normalize_guardian_email.__func__
    )
    _normalize_text = field_validator(
        "institution_name",
        "course",
        "company_name",
        "designation",
    )(StudentProfileCreate.normalize_text_fields.__func__)
    _normalize_id = field_validator("id_proof_number")(
        StudentProfileCreate.normalize_id_proof.__func__
    )


class DocumentInfo(BaseSchema):
    """
    Individual document information.
    
    Represents a single uploaded document with metadata.
    """

    id: str = Field(..., description="Document ID")
    document_type: str = Field(
        ...,
        description="Document category/type",
        examples=[
            "id_proof",
            "address_proof",
            "photo",
            "institutional_id",
            "company_id",
            "other",
        ],
    )
    document_name: str = Field(
        ...,
        description="Document display name",
    )
    document_url: HttpUrl = Field(
        ...,
        description="Document storage URL",
    )
    file_size_bytes: Optional[int] = Field(
        default=None,
        ge=0,
        description="File size in bytes",
    )
    mime_type: Optional[str] = Field(
        default=None,
        description="MIME type",
        examples=["application/pdf", "image/jpeg", "image/png"],
    )
    uploaded_at: datetime = Field(
        ...,
        description="Upload timestamp",
    )
    uploaded_by: str = Field(
        ...,
        description="User ID who uploaded",
    )

    # Verification
    verified: bool = Field(
        default=False,
        description="Verification status",
    )
    verified_by: Optional[str] = Field(
        default=None,
        description="Admin who verified",
    )
    verified_at: Optional[datetime] = Field(
        default=None,
        description="Verification timestamp",
    )
    verification_notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Verification notes",
    )

    # Expiry (for documents like ID proofs)
    expiry_date: Optional[datetime] = Field(
        default=None,
        description="Document expiry date",
    )
    is_expired: bool = Field(
        default=False,
        description="Whether document is expired",
    )


class StudentDocuments(BaseSchema):
    """
    Student document collection.
    
    All documents associated with a student.
    """

    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")
    documents: List[DocumentInfo] = Field(
        default_factory=list,
        description="List of uploaded documents",
    )
    total_documents: int = Field(
        default=0,
        ge=0,
        description="Total document count",
    )
    verified_documents: int = Field(
        default=0,
        ge=0,
        description="Verified document count",
    )
    pending_verification: int = Field(
        default=0,
        ge=0,
        description="Pending verification count",
    )


class DocumentUploadRequest(BaseCreateSchema):
    """
    Upload document request.
    
    Used after file upload to register document in system.
    """

    student_id: str = Field(
        ...,
        description="Student ID",
    )
    document_type: str = Field(
        ...,
        pattern=r"^(id_proof|address_proof|photo|institutional_id|company_id|other)$",
        description="Document type/category",
    )
    document_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Document name",
    )
    document_url: HttpUrl = Field(
        ...,
        description="Document URL (after upload to storage)",
    )
    file_size_bytes: Optional[int] = Field(
        default=None,
        ge=0,
        le=10485760,  # 10MB
        description="File size in bytes (max 10MB)",
    )
    mime_type: Optional[str] = Field(
        default=None,
        description="MIME type",
    )
    expiry_date: Optional[datetime] = Field(
        default=None,
        description="Document expiry date (for ID proofs)",
    )
    notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Additional notes",
    )

    @field_validator("document_type")
    @classmethod
    def normalize_document_type(cls, v: str) -> str:
        """Normalize document type to lowercase."""
        return v.lower().strip()

    @field_validator("document_name")
    @classmethod
    def validate_document_name(cls, v: str) -> str:
        """Validate and normalize document name."""
        v = v.strip()
        if not v:
            raise ValueError("Document name cannot be empty")
        return " ".join(v.split())

    @field_validator("mime_type")
    @classmethod
    def validate_mime_type(cls, v: Optional[str]) -> Optional[str]:
        """Validate MIME type is allowed."""
        if v is not None:
            allowed_types = [
                "application/pdf",
                "image/jpeg",
                "image/jpg",
                "image/png",
                "image/webp",
            ]
            if v.lower() not in allowed_types:
                raise ValueError(
                    f"MIME type must be one of: {', '.join(allowed_types)}"
                )
        return v

    @field_validator("expiry_date")
    @classmethod
    def validate_expiry_date(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate expiry date is in the future."""
        if v is not None:
            if v < datetime.now():
                raise ValueError("Document expiry date cannot be in the past")
        return v


class DocumentVerificationRequest(BaseCreateSchema):
    """
    Verify document request.
    
    Used by admins to verify or reject uploaded documents.
    """

    document_id: str = Field(
        ...,
        description="Document ID to verify",
    )
    verified: bool = Field(
        ...,
        description="Verification status (true=verified, false=rejected)",
    )
    verification_notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Verification notes/comments",
    )
    reject_reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Rejection reason (if not verified)",
    )

    @model_validator(mode="after")
    def validate_rejection_reason(self) -> "DocumentVerificationRequest":
        """Require rejection reason if document is rejected."""
        if not self.verified and not self.reject_reason:
            raise ValueError(
                "Rejection reason is required when rejecting a document"
            )
        return self


class StudentPreferences(BaseUpdateSchema):
    """
    Student preferences and settings.
    
    Manages student-specific preferences for meal, notifications, etc.
    """

    # Meal preferences
    mess_subscribed: Optional[bool] = Field(
        default=None,
        description="Mess subscription status",
    )
    dietary_preference: Optional[DietaryPreference] = Field(
        default=None,
        description="Dietary preference",
    )
    food_allergies: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Food allergies and restrictions",
    )

    # Meal plan preferences
    meal_plan_type: Optional[str] = Field(
        default=None,
        pattern=r"^(full|breakfast_only|lunch_dinner|custom)$",
        description="Meal plan type",
    )
    skip_breakfast: bool = Field(
        default=False,
        description="Skip breakfast in meal plan",
    )
    skip_lunch: bool = Field(
        default=False,
        description="Skip lunch in meal plan",
    )
    skip_dinner: bool = Field(
        default=False,
        description="Skip dinner in meal plan",
    )

    # Notification preferences
    email_notifications: bool = Field(
        default=True,
        description="Enable email notifications",
    )
    sms_notifications: bool = Field(
        default=True,
        description="Enable SMS notifications",
    )
    push_notifications: bool = Field(
        default=True,
        description="Enable push notifications",
    )

    # Notification types
    payment_reminders: bool = Field(
        default=True,
        description="Receive payment reminders",
    )
    attendance_alerts: bool = Field(
        default=True,
        description="Receive attendance alerts",
    )
    announcement_notifications: bool = Field(
        default=True,
        description="Receive announcements",
    )
    complaint_updates: bool = Field(
        default=True,
        description="Receive complaint status updates",
    )
    event_notifications: bool = Field(
        default=True,
        description="Receive event notifications",
    )

    # Communication preferences
    preferred_language: str = Field(
        default="en",
        pattern=r"^(en|hi|ta|te|bn|mr|gu)$",
        description="Preferred language for communications",
    )
    preferred_contact_method: str = Field(
        default="email",
        pattern=r"^(email|sms|phone|whatsapp)$",
        description="Preferred contact method",
    )

    @field_validator("preferred_language", "preferred_contact_method")
    @classmethod
    def normalize_preferences(cls, v: str) -> str:
        """Normalize preference values."""
        return v.lower().strip()


class StudentPrivacySettings(BaseUpdateSchema):
    """
    Student privacy settings.
    
    Controls visibility of student information to others.
    """

    # Profile visibility
    show_profile_to_others: bool = Field(
        default=True,
        description="Show profile to other students",
    )
    show_room_number: bool = Field(
        default=True,
        description="Show room number in profile",
    )
    show_phone_number: bool = Field(
        default=False,
        description="Show phone number to other students",
    )
    show_email: bool = Field(
        default=False,
        description="Show email to other students",
    )
    show_institutional_info: bool = Field(
        default=True,
        description="Show college/company information",
    )

    # Contact permissions
    allow_roommate_contact: bool = Field(
        default=True,
        description="Allow roommates to view contact info",
    )
    allow_floormate_contact: bool = Field(
        default=True,
        description="Allow floormates to view contact info",
    )
    allow_hostelmate_contact: bool = Field(
        default=False,
        description="Allow all hostel residents to view contact info",
    )

    # Search visibility
    searchable_by_name: bool = Field(
        default=True,
        description="Allow search by name",
    )
    searchable_by_institution: bool = Field(
        default=True,
        description="Allow search by institution",
    )

    # Activity visibility
    show_last_seen: bool = Field(
        default=True,
        description="Show last seen/activity status",
    )
    show_attendance_to_others: bool = Field(
        default=False,
        description="Show attendance status to other students",
    )


class StudentBulkImport(BaseCreateSchema):
    """
    Bulk import students from file.
    
    Used for initial data migration or batch student registration.
    """

    hostel_id: str = Field(
        ...,
        description="Hostel ID for all students",
    )
    import_file_url: HttpUrl = Field(
        ...,
        description="URL of uploaded CSV/Excel file",
    )
    file_type: str = Field(
        ...,
        pattern=r"^(csv|excel)$",
        description="File format",
    )
    skip_duplicates: bool = Field(
        default=True,
        description="Skip duplicate email/phone entries",
    )
    send_welcome_email: bool = Field(
        default=True,
        description="Send welcome email to imported students",
    )
    auto_generate_passwords: bool = Field(
        default=True,
        description="Auto-generate passwords for new users",
    )

    # Field mapping (if custom columns)
    field_mapping: Optional[dict] = Field(
        default=None,
        description="Custom field mapping for CSV columns",
        examples=[
            {
                "Name": "full_name",
                "Email": "email",
                "Phone": "phone",
                "Guardian Name": "guardian_name",
            }
        ],
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\student_response.py ---
# --- File: app/schemas/student/student_response.py ---
"""
Student response schemas for API responses.

Provides various response formats for student data including
detailed views, list items, profiles, and specialized information.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import (
    DietaryPreference,
    IDProofType,
    StudentStatus,
)

__all__ = [
    "StudentResponse",
    "StudentDetail",
    "StudentProfile",
    "StudentListItem",
    "StudentFinancialInfo",
    "StudentContactInfo",
    "StudentDocumentInfo",
]


class StudentResponse(BaseResponseSchema):
    """
    Standard student response schema.
    
    Basic student information for general API responses.
    """

    user_id: str = Field(..., description="User ID")
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    room_id: Optional[str] = Field(default=None, description="Room ID")
    room_number: Optional[str] = Field(default=None, description="Room number")
    bed_id: Optional[str] = Field(default=None, description="Bed ID")
    bed_number: Optional[str] = Field(default=None, description="Bed number")

    # Personal info (from user)
    full_name: str = Field(..., description="Student full name")
    email: str = Field(..., description="Email address")
    phone: str = Field(..., description="Phone number")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )

    # Guardian
    guardian_name: str = Field(..., description="Guardian name")
    guardian_phone: str = Field(..., description="Guardian phone")

    # Status
    student_status: StudentStatus = Field(..., description="Student status")
    check_in_date: Optional[date] = Field(
        default=None,
        description="Check-in date",
    )
    expected_checkout_date: Optional[date] = Field(
        default=None,
        description="Expected checkout date",
    )

    # Financial
    monthly_rent_amount: Optional[Decimal] = Field(
        default=None,
        description="Monthly rent",
    )
    security_deposit_amount: Decimal = Field(
        ...,
        description="Security deposit amount",
    )
    security_deposit_paid: bool = Field(
        ...,
        description="Security deposit paid status",
    )

    # Meal
    mess_subscribed: bool = Field(..., description="Mess subscription status")

    @computed_field
    @property
    def days_in_hostel(self) -> Optional[int]:
        """Calculate days stayed in hostel."""
        if not self.check_in_date:
            return None
        end_date = self.actual_checkout_date or date.today()
        return (end_date - self.check_in_date).days

    @computed_field
    @property
    def is_checked_in(self) -> bool:
        """Check if student is currently checked in."""
        return (
            self.check_in_date is not None
            and self.actual_checkout_date is None
        )


class StudentDetail(BaseResponseSchema):
    """
    Detailed student information.
    
    Comprehensive student profile with all attributes.
    """

    # User information
    user_id: str = Field(..., description="User ID")
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    gender: Optional[str] = Field(default=None, description="Gender")
    date_of_birth: Optional[date] = Field(default=None, description="Date of birth")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )

    # Hostel assignment
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    room_id: Optional[str] = Field(default=None, description="Room ID")
    room_number: Optional[str] = Field(default=None, description="Room number")
    room_type: Optional[str] = Field(default=None, description="Room type")
    floor_number: Optional[int] = Field(default=None, description="Floor number")
    bed_id: Optional[str] = Field(default=None, description="Bed ID")
    bed_number: Optional[str] = Field(default=None, description="Bed number")

    # Identification
    id_proof_type: Optional[IDProofType] = Field(
        default=None,
        description="ID proof type",
    )
    id_proof_number: Optional[str] = Field(
        default=None,
        description="ID proof number",
    )
    id_proof_document_url: Optional[str] = Field(
        default=None,
        description="ID proof document URL",
    )
    id_proof_verified: bool = Field(
        default=False,
        description="ID proof verification status",
    )

    # Guardian information
    guardian_name: str = Field(..., description="Guardian name")
    guardian_phone: str = Field(..., description="Guardian phone")
    guardian_email: Optional[str] = Field(default=None, description="Guardian email")
    guardian_relation: Optional[str] = Field(
        default=None,
        description="Guardian relation",
    )
    guardian_address: Optional[str] = Field(
        default=None,
        description="Guardian address",
    )

    # Institutional information
    institution_name: Optional[str] = Field(
        default=None,
        description="Institution name",
    )
    course: Optional[str] = Field(default=None, description="Course")
    year_of_study: Optional[str] = Field(default=None, description="Year of study")
    student_id_number: Optional[str] = Field(
        default=None,
        description="Student ID number",
    )
    institutional_id_url: Optional[str] = Field(
        default=None,
        description="Institutional ID URL",
    )

    # Employment information
    company_name: Optional[str] = Field(default=None, description="Company name")
    designation: Optional[str] = Field(default=None, description="Designation")
    company_id_url: Optional[str] = Field(
        default=None,
        description="Company ID URL",
    )

    # Dates
    check_in_date: Optional[date] = Field(default=None, description="Check-in date")
    expected_checkout_date: Optional[date] = Field(
        default=None,
        description="Expected checkout",
    )
    actual_checkout_date: Optional[date] = Field(
        default=None,
        description="Actual checkout",
    )

    # Financial
    security_deposit_amount: Decimal = Field(
        ...,
        description="Security deposit amount",
    )
    security_deposit_paid: bool = Field(
        ...,
        description="Security deposit paid",
    )
    security_deposit_paid_date: Optional[date] = Field(
        default=None,
        description="Deposit paid date",
    )
    monthly_rent_amount: Optional[Decimal] = Field(
        default=None,
        description="Monthly rent",
    )

    # Meal preferences
    mess_subscribed: bool = Field(..., description="Mess subscription")
    dietary_preference: Optional[DietaryPreference] = Field(
        default=None,
        description="Dietary preference",
    )
    food_allergies: Optional[str] = Field(
        default=None,
        description="Food allergies",
    )

    # Status
    student_status: StudentStatus = Field(..., description="Student status")
    notice_period_start: Optional[date] = Field(
        default=None,
        description="Notice period start",
    )
    notice_period_end: Optional[date] = Field(
        default=None,
        description="Notice period end",
    )

    # Source
    booking_id: Optional[str] = Field(
        default=None,
        description="Source booking ID",
    )

    # Additional documents
    additional_documents: List[dict] = Field(
        default_factory=list,
        description="Additional uploaded documents",
    )

    @computed_field
    @property
    def age(self) -> Optional[int]:
        """Calculate age from date of birth."""
        if not self.date_of_birth:
            return None
        today = date.today()
        return (
            today.year
            - self.date_of_birth.year
            - (
                (today.month, today.day)
                < (self.date_of_birth.month, self.date_of_birth.day)
            )
        )

    @computed_field
    @property
    def days_in_hostel(self) -> Optional[int]:
        """Calculate total days in hostel."""
        if not self.check_in_date:
            return None
        end_date = self.actual_checkout_date or date.today()
        return (end_date - self.check_in_date).days

    @computed_field
    @property
    def is_currently_resident(self) -> bool:
        """Check if currently a resident."""
        return (
            self.check_in_date is not None
            and self.actual_checkout_date is None
            and self.student_status == StudentStatus.ACTIVE
        )

    @computed_field
    @property
    def is_student(self) -> bool:
        """Check if institutional student."""
        return bool(self.institution_name or self.course)

    @computed_field
    @property
    def is_working_professional(self) -> bool:
        """Check if working professional."""
        return bool(self.company_name or self.designation)


class StudentProfile(BaseSchema):
    """
    Public student profile.
    
    Limited information suitable for public/peer viewing.
    """

    id: str = Field(..., description="Student ID")
    full_name: str = Field(..., description="Full name")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )
    hostel_name: str = Field(..., description="Hostel name")
    room_number: Optional[str] = Field(default=None, description="Room number")
    check_in_date: Optional[date] = Field(default=None, description="Check-in date")

    # Optional info (based on privacy settings)
    institution_name: Optional[str] = Field(
        default=None,
        description="Institution name",
    )
    course: Optional[str] = Field(default=None, description="Course")
    year_of_study: Optional[str] = Field(default=None, description="Year")
    company_name: Optional[str] = Field(default=None, description="Company")

    @computed_field
    @property
    def duration_in_hostel(self) -> Optional[str]:
        """Human-readable duration in hostel."""
        if not self.check_in_date:
            return None

        days = (date.today() - self.check_in_date).days
        if days < 30:
            return f"{days} days"
        elif days < 365:
            months = days // 30
            return f"{months} month{'s' if months > 1 else ''}"
        else:
            years = days // 365
            return f"{years} year{'s' if years > 1 else ''}"


class StudentListItem(BaseSchema):
    """
    Student list item for admin views.
    
    Optimized for list rendering with essential information.
    """

    id: str = Field(..., description="Student ID")
    user_id: str = Field(..., description="User ID")
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )

    # Room assignment
    room_number: Optional[str] = Field(default=None, description="Room number")
    bed_number: Optional[str] = Field(default=None, description="Bed number")

    # Status
    student_status: StudentStatus = Field(..., description="Status")
    check_in_date: Optional[date] = Field(default=None, description="Check-in date")

    # Financial
    monthly_rent: Optional[Decimal] = Field(default=None, description="Monthly rent")
    payment_status: str = Field(
        ...,
        description="Payment status (current/overdue/advance)",
    )
    overdue_amount: Decimal = Field(
        default=Decimal("0.00"),
        description="Overdue amount",
    )

    # Timestamps
    created_at: datetime = Field(..., description="Registration timestamp")

    @computed_field
    @property
    def days_in_hostel(self) -> Optional[int]:
        """Calculate days in hostel."""
        if not self.check_in_date:
            return None
        return (date.today() - self.check_in_date).days


class StudentFinancialInfo(BaseSchema):
    """
    Student financial information.
    
    Comprehensive financial details for a student.
    """

    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")

    # Rent
    monthly_rent_amount: Decimal = Field(..., description="Monthly rent")
    rent_due_day: int = Field(..., description="Monthly due day")

    # Security deposit
    security_deposit_amount: Decimal = Field(..., description="Security deposit")
    security_deposit_paid: bool = Field(..., description="Deposit paid status")
    security_deposit_paid_date: Optional[date] = Field(
        default=None,
        description="Deposit paid date",
    )
    security_deposit_refundable: Decimal = Field(
        ...,
        description="Refundable amount",
    )

    # Payments
    total_paid: Decimal = Field(..., description="Total amount paid")
    total_due: Decimal = Field(..., description="Total amount due")
    last_payment_date: Optional[date] = Field(
        default=None,
        description="Last payment date",
    )
    next_due_date: Optional[date] = Field(default=None, description="Next due date")

    # Outstanding
    overdue_amount: Decimal = Field(..., description="Overdue amount")
    advance_amount: Decimal = Field(..., description="Advance balance")

    # Mess
    mess_charges_monthly: Decimal = Field(
        default=Decimal("0.00"),
        description="Monthly mess charges",
    )
    mess_balance: Decimal = Field(
        default=Decimal("0.00"),
        description="Mess account balance",
    )

    # Other charges
    other_charges: Decimal = Field(
        default=Decimal("0.00"),
        description="Other charges",
    )

    @computed_field
    @property
    def payment_status(self) -> str:
        """Determine payment status."""
        if self.overdue_amount > 0:
            return "overdue"
        elif self.advance_amount > 0:
            return "advance"
        else:
            return "current"

    @computed_field
    @property
    def total_outstanding(self) -> Decimal:
        """Calculate total outstanding amount."""
        return self.total_due - self.advance_amount

    @computed_field
    @property
    def net_balance(self) -> Decimal:
        """Calculate net balance (advance - dues)."""
        return self.advance_amount - self.total_due


class StudentContactInfo(BaseSchema):
    """
    Student contact information.
    
    Comprehensive contact details for emergency and communication.
    """

    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")

    # Student contact
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    alternate_phone: Optional[str] = Field(default=None, description="Alternate phone")

    # Guardian contact
    guardian_name: str = Field(..., description="Guardian name")
    guardian_phone: str = Field(..., description="Guardian phone")
    guardian_email: Optional[str] = Field(default=None, description="Guardian email")
    guardian_relation: Optional[str] = Field(
        default=None,
        description="Guardian relation",
    )
    guardian_address: Optional[str] = Field(
        default=None,
        description="Guardian address",
    )

    # Emergency contact (from user profile)
    emergency_contact_name: Optional[str] = Field(
        default=None,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        default=None,
        description="Emergency contact phone",
    )
    emergency_contact_relation: Optional[str] = Field(
        default=None,
        description="Emergency relation",
    )

    # Current address (hostel)
    current_hostel: str = Field(..., description="Current hostel")
    current_room: Optional[str] = Field(default=None, description="Current room")

    # Forwarding address (if checked out)
    forwarding_address: Optional[str] = Field(
        default=None,
        description="Forwarding address",
    )


class StudentDocumentInfo(BaseSchema):
    """
    Student document information.
    
    Details about uploaded documents and verification status.
    """

    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")

    # ID documents
    id_proof_type: Optional[IDProofType] = Field(
        default=None,
        description="ID proof type",
    )
    id_proof_number: Optional[str] = Field(
        default=None,
        description="ID proof number",
    )
    id_proof_url: Optional[str] = Field(
        default=None,
        description="ID proof document URL",
    )
    id_proof_verified: bool = Field(
        default=False,
        description="ID verification status",
    )
    id_proof_verified_at: Optional[datetime] = Field(
        default=None,
        description="Verification timestamp",
    )

    # Institutional documents
    institutional_id_url: Optional[str] = Field(
        default=None,
        description="College/University ID",
    )
    institutional_id_verified: bool = Field(
        default=False,
        description="Institutional ID verified",
    )

    # Employment documents
    company_id_url: Optional[str] = Field(
        default=None,
        description="Company ID card",
    )
    company_id_verified: bool = Field(
        default=False,
        description="Company ID verified",
    )

    # Additional documents
    additional_documents: List[dict] = Field(
        default_factory=list,
        description="Other uploaded documents",
    )

    @computed_field
    @property
    def verification_status(self) -> str:
        """Overall verification status."""
        if self.id_proof_verified:
            return "verified"
        elif self.id_proof_url:
            return "pending_verification"
        else:
            return "not_uploaded"

    @computed_field
    @property
    def documents_complete(self) -> bool:
        """Check if all required documents are uploaded."""
        return bool(self.id_proof_url)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\student_room_history.py ---
# --- File: app/schemas/student/student_room_history.py ---
"""
Student room history and transfer schemas with enhanced validation.

Provides schemas for tracking room assignments, transfers, and
movement history for students.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator, computed_field

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
)

__all__ = [
    "RoomHistoryResponse",
    "RoomHistoryItem",
    "RoomTransferRequest",
    "RoomTransferApproval",
    "RoomTransferStatus",
    "BulkRoomTransfer",
    "SingleTransfer",
    "RoomSwapRequest",
]


class RoomHistoryItem(BaseResponseSchema):
    """
    Individual room history entry.
    
    Represents a single room assignment period in student's history.
    """

    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    room_type: str = Field(..., description="Room type")
    floor_number: Optional[int] = Field(default=None, description="Floor number")
    wing: Optional[str] = Field(default=None, description="Wing/Block")
    bed_id: Optional[str] = Field(default=None, description="Bed ID")
    bed_number: Optional[str] = Field(default=None, description="Bed number")

    # Duration
    move_in_date: date = Field(..., description="Move-in date")
    move_out_date: Optional[date] = Field(
        default=None,
        description="Move-out date (null if current)",
    )
    duration_days: Optional[int] = Field(
        default=None,
        ge=0,
        description="Total duration in days",
    )

    # Financial
    rent_amount: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Monthly rent for this assignment",
    )
    total_rent_paid: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Total rent paid during this period",
    )

    # Transfer details
    reason: Optional[str] = Field(
        default=None,
        description="Reason for assignment/transfer",
    )
    transfer_type: Optional[str] = Field(
        default=None,
        description="Transfer type (initial, request, admin)",
    )

    # Audit
    requested_by: Optional[str] = Field(
        default=None,
        description="User who requested transfer",
    )
    approved_by: Optional[str] = Field(
        default=None,
        description="Admin who approved assignment",
    )
    assigned_at: datetime = Field(
        ...,
        description="Assignment timestamp",
    )

    @computed_field
    @property
    def is_current(self) -> bool:
        """Check if this is the current assignment."""
        return self.move_out_date is None

    @computed_field
    @property
    def duration_months(self) -> Optional[Decimal]:
        """Calculate duration in months."""
        if self.duration_days is None:
            return None
        return Decimal(self.duration_days / 30).quantize(Decimal("0.1"))


class RoomHistoryResponse(BaseSchema):
    """
    Complete student room history.
    
    Chronological list of all room assignments for a student.
    """

    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")
    hostel_id: str = Field(..., description="Current hostel ID")
    hostel_name: str = Field(..., description="Current hostel name")

    # Current assignment
    current_room: Optional[str] = Field(
        default=None,
        description="Current room number",
    )
    current_bed: Optional[str] = Field(
        default=None,
        description="Current bed number",
    )

    # History
    room_history: List[RoomHistoryItem] = Field(
        ...,
        description="Room assignment history (newest first)",
    )

    # Statistics
    total_assignments: int = Field(
        default=0,
        ge=0,
        description="Total number of room assignments",
    )
    total_transfers: int = Field(
        default=0,
        ge=0,
        description="Total number of room transfers",
    )

    @computed_field
    @property
    def has_changed_rooms(self) -> bool:
        """Check if student has changed rooms."""
        return self.total_assignments > 1


class RoomTransferRequest(BaseCreateSchema):
    """
    Request room transfer.
    
    Student-initiated or admin-initiated room transfer request.
    """

    student_id: str = Field(
        ...,
        description="Student ID requesting transfer",
    )
    current_room_id: str = Field(
        ...,
        description="Current room ID",
    )
    requested_room_id: str = Field(
        ...,
        description="Desired room ID",
    )
    requested_bed_id: Optional[str] = Field(
        default=None,
        description="Desired bed ID (if specific bed requested)",
    )

    transfer_date: date = Field(
        ...,
        description="Desired transfer date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for transfer",
        examples=[
            "Room too small for my belongings",
            "Prefer ground floor room",
            "Request to be closer to friends",
            "Medical reasons - need AC room",
        ],
    )

    # Preferences
    accept_price_difference: bool = Field(
        default=False,
        description="Accept if new room has different rent",
    )
    flexible_on_bed: bool = Field(
        default=True,
        description="Flexible on specific bed (any bed in room)",
    )

    # Priority
    priority: str = Field(
        default="normal",
        pattern=r"^(low|normal|high|urgent)$",
        description="Transfer priority/urgency",
    )

    # Supporting documents
    supporting_documents: List[str] = Field(
        default_factory=list,
        description="URLs of supporting documents (medical certificates, etc.)",
    )

    @field_validator("transfer_date")
    @classmethod
    def validate_transfer_date(cls, v: date) -> date:
        """Validate transfer date is reasonable."""
        from datetime import timedelta

        today = date.today()

        # Must be at least today or future
        if v < today:
            raise ValueError("Transfer date cannot be in the past")

        # Warn if too far in future (more than 90 days)
        if v > today + timedelta(days=90):
            raise ValueError(
                "Transfer date cannot be more than 90 days in the future"
            )

        return v

    @model_validator(mode="after")
    def validate_different_room(self) -> "RoomTransferRequest":
        """Ensure requested room is different from current room."""
        if self.current_room_id == self.requested_room_id:
            raise ValueError(
                "Requested room must be different from current room"
            )
        return self


class RoomTransferApproval(BaseCreateSchema):
    """
    Approve or reject room transfer request.
    
    Admin action to process transfer requests.
    """

    transfer_request_id: str = Field(
        ...,
        description="Transfer request ID to process",
    )
    approved: bool = Field(
        ...,
        description="Approval decision (true=approved, false=rejected)",
    )

    # If approved
    new_room_id: Optional[str] = Field(
        default=None,
        description="Approved room (may differ from requested)",
    )
    new_bed_id: Optional[str] = Field(
        default=None,
        description="Assigned bed in new room",
    )
    transfer_date: Optional[date] = Field(
        default=None,
        description="Approved transfer date (may differ from requested)",
    )

    # If rejected
    rejection_reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Detailed rejection reason",
        examples=[
            "Requested room not available",
            "Transfer not justified",
            "Pending payment dues must be cleared first",
        ],
    )

    # Financial implications
    rent_adjustment: Optional[Decimal] = Field(
        default=None,
        description="Monthly rent adjustment (positive=increase, negative=decrease)",
    )
    additional_charges: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="One-time transfer charges",
    )
    prorated_rent_calculation: bool = Field(
        default=True,
        description="Calculate prorated rent for partial month",
    )

    # Notes
    admin_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Administrative notes",
    )

    @model_validator(mode="after")
    def validate_approval_requirements(self) -> "RoomTransferApproval":
        """Validate approval-specific required fields."""
        if self.approved:
            # Approved transfers require room and bed assignment
            if not self.new_room_id:
                raise ValueError(
                    "new_room_id is required when approving transfer"
                )
            if not self.new_bed_id:
                raise ValueError(
                    "new_bed_id is required when approving transfer"
                )
            if not self.transfer_date:
                raise ValueError(
                    "transfer_date is required when approving transfer"
                )
        else:
            # Rejected transfers require rejection reason
            if not self.rejection_reason:
                raise ValueError(
                    "rejection_reason is required when rejecting transfer"
                )

        return self

    @field_validator("transfer_date")
    @classmethod
    def validate_transfer_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate transfer date."""
        if v is not None:
            from datetime import timedelta

            today = date.today()
            if v < today:
                raise ValueError("Transfer date cannot be in the past")
            if v > today + timedelta(days=90):
                raise ValueError(
                    "Transfer date cannot be more than 90 days in the future"
                )
        return v


class RoomTransferStatus(BaseSchema):
    """
    Room transfer request status.
    
    Current status and details of a transfer request.
    """

    request_id: str = Field(..., description="Transfer request ID")
    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")

    # Room details
    current_room: str = Field(..., description="Current room number")
    current_bed: Optional[str] = Field(default=None, description="Current bed")
    requested_room: str = Field(..., description="Requested room number")
    requested_bed: Optional[str] = Field(default=None, description="Requested bed")
    approved_room: Optional[str] = Field(
        default=None,
        description="Approved room (if different)",
    )
    approved_bed: Optional[str] = Field(
        default=None,
        description="Approved bed",
    )

    # Dates
    transfer_date: date = Field(..., description="Transfer date")
    requested_at: datetime = Field(..., description="Request timestamp")
    processed_at: Optional[datetime] = Field(
        default=None,
        description="Processing timestamp",
    )

    # Status
    status: str = Field(
        ...,
        pattern=r"^(pending|approved|rejected|completed|cancelled)$",
        description="Request status",
    )
    priority: str = Field(..., description="Request priority")

    # Details
    reason: str = Field(..., description="Transfer reason")
    approval_notes: Optional[str] = Field(
        default=None,
        description="Approval/rejection notes",
    )
    processed_by: Optional[str] = Field(
        default=None,
        description="Admin who processed",
    )
    processed_by_name: Optional[str] = Field(
        default=None,
        description="Admin name",
    )

    # Financial
    rent_adjustment: Optional[Decimal] = Field(
        default=None,
        description="Rent adjustment",
    )
    additional_charges: Optional[Decimal] = Field(
        default=None,
        description="Transfer charges",
    )

    @computed_field
    @property
    def is_pending(self) -> bool:
        """Check if request is still pending."""
        return self.status == "pending"

    @computed_field
    @property
    def days_pending(self) -> Optional[int]:
        """Calculate days request has been pending."""
        if self.status != "pending":
            return None
        return (datetime.now() - self.requested_at).days


class SingleTransfer(BaseSchema):
    """
    Single transfer in bulk operation.
    
    Represents one student transfer in a bulk transfer operation.
    """

    student_id: str = Field(..., description="Student ID to transfer")
    new_room_id: str = Field(..., description="New room ID")
    new_bed_id: Optional[str] = Field(
        default=None,
        description="New bed ID (optional, auto-assign if not specified)",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=200,
        description="Transfer reason (optional, uses bulk reason if not specified)",
    )


class BulkRoomTransfer(BaseCreateSchema):
    """
    Bulk room transfer (admin only).
    
    Transfer multiple students simultaneously (e.g., floor reorganization).
    """

    transfers: List[SingleTransfer] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of transfers to perform (max 50)",
    )
    transfer_date: date = Field(
        ...,
        description="Transfer date for all students",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Common reason for bulk transfer",
        examples=[
            "Floor renovation - temporary relocation",
            "Wing reorganization",
            "Room type consolidation",
        ],
    )

    # Options
    skip_on_error: bool = Field(
        default=True,
        description="Skip individual transfers that fail, continue with rest",
    )
    send_notifications: bool = Field(
        default=True,
        description="Send notifications to affected students",
    )
    prorated_rent: bool = Field(
        default=True,
        description="Calculate prorated rent for all transfers",
    )

    # Confirmation
    confirm_bulk_transfer: bool = Field(
        default=False,
        description="Explicit confirmation for bulk operation",
    )

    @field_validator("transfers")
    @classmethod
    def validate_unique_students(cls, v: List[SingleTransfer]) -> List[SingleTransfer]:
        """Ensure each student appears only once."""
        student_ids = [t.student_id for t in v]
        if len(student_ids) != len(set(student_ids)):
            raise ValueError(
                "Each student can only be transferred once in bulk operation"
            )
        return v

    @field_validator("transfer_date")
    @classmethod
    def validate_transfer_date(cls, v: date) -> date:
        """Validate transfer date."""
        from datetime import timedelta

        today = date.today()
        if v < today:
            raise ValueError("Transfer date cannot be in the past")
        if v > today + timedelta(days=30):
            raise ValueError(
                "Bulk transfer date cannot be more than 30 days in the future"
            )
        return v

    @model_validator(mode="after")
    def validate_confirmation(self) -> "BulkRoomTransfer":
        """Require explicit confirmation for bulk operations."""
        if not self.confirm_bulk_transfer:
            raise ValueError(
                "Bulk transfer requires explicit confirmation (confirm_bulk_transfer=true)"
            )
        return self


class RoomSwapRequest(BaseCreateSchema):
    """
    Request room swap between two students.
    
    Mutual room exchange between two students.
    """

    student_1_id: str = Field(
        ...,
        description="First student ID",
    )
    student_2_id: str = Field(
        ...,
        description="Second student ID",
    )
    swap_date: date = Field(
        ...,
        description="Swap date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for swap",
        examples=[
            "Mutual preference exchange",
            "Closer to respective friends",
            "Room size preference swap",
        ],
    )

    # Consent
    student_1_consent: bool = Field(
        default=False,
        description="First student consent",
    )
    student_2_consent: bool = Field(
        default=False,
        description="Second student consent",
    )

    # Financial
    handle_rent_difference: bool = Field(
        default=True,
        description="Automatically handle rent difference between rooms",
    )

    @field_validator("swap_date")
    @classmethod
    def validate_swap_date(cls, v: date) -> date:
        """Validate swap date."""
        from datetime import timedelta

        today = date.today()
        if v < today:
            raise ValueError("Swap date cannot be in the past")
        if v > today + timedelta(days=30):
            raise ValueError(
                "Swap date cannot be more than 30 days in the future"
            )
        return v

    @model_validator(mode="after")
    def validate_different_students(self) -> "RoomSwapRequest":
        """Ensure students are different."""
        if self.student_1_id == self.student_2_id:
            raise ValueError(
                "Cannot swap room for the same student"
            )
        return self

    @model_validator(mode="after")
    def validate_consent(self) -> "RoomSwapRequest":
        """Validate both students have consented."""
        if not self.student_1_consent or not self.student_2_consent:
            raise ValueError(
                "Both students must consent to room swap"
            )
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\__init__.py ---
# --- File: app/schemas/student/__init__.py ---
"""
Student schemas package.

Re-exports commonly used student-related schemas for convenient imports.

Example:
    from app.schemas.student import (
        StudentCreate,
        StudentDetail,
        StudentDashboard,
        RoomTransferRequest,
    )
"""

from __future__ import annotations

from app.schemas.student.student_base import (
    StudentBase,
    StudentCheckInRequest,
    StudentCheckOutRequest,
    StudentCreate,
    StudentRoomAssignment,
    StudentStatusUpdate,
    StudentUpdate,
)
from app.schemas.student.student_dashboard import (
    AttendanceSummary,
    PendingLeave,
    RecentAnnouncement,
    RecentComplaint,
    RecentPayment,
    StudentDashboard,
    StudentFinancialSummary,
    StudentStats,
    TodayMessMenu,
    UpcomingEvent,
)
from app.schemas.student.student_filters import (
    AdvancedStudentFilters,
    StudentBulkActionRequest,
    StudentExportRequest,
    StudentFilterParams,
    StudentSearchRequest,
    StudentSortOptions,
)
from app.schemas.student.student_profile import (
    DocumentInfo,
    DocumentUploadRequest,
    DocumentVerificationRequest,
    StudentBulkImport,
    StudentDocuments,
    StudentPreferences,
    StudentPrivacySettings,
    StudentProfileCreate,
    StudentProfileUpdate,
)
from app.schemas.student.student_response import (
    StudentContactInfo,
    StudentDetail,
    StudentDocumentInfo,
    StudentFinancialInfo,
    StudentListItem,
    StudentProfile,
    StudentResponse,
)
from app.schemas.student.student_room_history import (
    BulkRoomTransfer,
    RoomHistoryItem,
    RoomHistoryResponse,
    RoomSwapRequest,
    RoomTransferApproval,
    RoomTransferRequest,
    RoomTransferStatus,
    SingleTransfer,
)

__all__ = [
    # Base
    "StudentBase",
    "StudentCreate",
    "StudentUpdate",
    "StudentCheckInRequest",
    "StudentCheckOutRequest",
    "StudentRoomAssignment",
    "StudentStatusUpdate",
    # Response
    "StudentResponse",
    "StudentDetail",
    "StudentProfile",
    "StudentListItem",
    "StudentFinancialInfo",
    "StudentContactInfo",
    "StudentDocumentInfo",
    # Profile
    "StudentProfileCreate",
    "StudentProfileUpdate",
    "StudentDocuments",
    "DocumentInfo",
    "DocumentUploadRequest",
    "DocumentVerificationRequest",
    "StudentPreferences",
    "StudentPrivacySettings",
    "StudentBulkImport",
    # Room history
    "RoomHistoryResponse",
    "RoomHistoryItem",
    "RoomTransferRequest",
    "RoomTransferApproval",
    "RoomTransferStatus",
    "BulkRoomTransfer",
    "SingleTransfer",
    "RoomSwapRequest",
    # Dashboard
    "StudentDashboard",
    "StudentStats",
    "StudentFinancialSummary",
    "AttendanceSummary",
    "RecentPayment",
    "RecentComplaint",
    "PendingLeave",
    "RecentAnnouncement",
    "TodayMessMenu",
    "UpcomingEvent",
    # Filters
    "StudentFilterParams",
    "StudentSearchRequest",
    "StudentSortOptions",
    "StudentExportRequest",
    "StudentBulkActionRequest",
    "AdvancedStudentFilters",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\student_base.py ---
# --- File: app/schemas/student/student_base.py ---
"""
Student base schemas with enhanced validation and type safety.

Provides core student management schemas including creation, updates,
check-in/check-out operations, and student-specific attributes.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import (
    DietaryPreference,
    IDProofType,
    StudentStatus,
)

__all__ = [
    "StudentBase",
    "StudentCreate",
    "StudentUpdate",
    "StudentCheckInRequest",
    "StudentCheckOutRequest",
    "StudentRoomAssignment",
    "StudentStatusUpdate",
]


class StudentBase(BaseSchema):
    """
    Base student schema with comprehensive student attributes.
    
    Contains common fields shared across student operations including
    identification, guardian info, institutional/employment details,
    and preferences.
    """

    user_id: str = Field(
        ...,
        description="Associated user ID",
    )
    hostel_id: str = Field(
        ...,
        description="Current hostel ID",
    )
    room_id: Optional[str] = Field(
        default=None,
        description="Assigned room ID (null if not assigned)",
    )
    bed_id: Optional[str] = Field(
        default=None,
        description="Assigned bed ID (null if not assigned)",
    )

    # Identification documents
    id_proof_type: Optional[IDProofType] = Field(
        default=None,
        description="Type of ID proof submitted",
    )
    id_proof_number: Optional[str] = Field(
        default=None,
        max_length=50,
        description="ID proof number/reference",
    )
    id_proof_document_url: Optional[str] = Field(
        default=None,
        description="Uploaded ID proof document URL",
    )

    # Guardian information (mandatory for students)
    guardian_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Guardian/parent full name",
        examples=["John Smith", "Mrs. Jane Doe"],
    )
    guardian_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Guardian contact phone (E.164 format)",
        examples=["+919876543210", "9876543210"],
    )
    guardian_email: Optional[str] = Field(
        default=None,
        description="Guardian email address",
    )
    guardian_relation: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Relation to student",
        examples=["Father", "Mother", "Uncle", "Guardian"],
    )
    guardian_address: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Guardian residential address",
    )

    # Institutional information (for students)
    institution_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="College/University/School name",
        examples=["IIT Delhi", "Delhi University", "XYZ College"],
    )
    course: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Course/Program name",
        examples=["B.Tech Computer Science", "MBA", "BA Economics"],
    )
    year_of_study: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Current year/semester",
        examples=["1st Year", "3rd Semester", "Final Year"],
    )
    student_id_number: Optional[str] = Field(
        default=None,
        max_length=100,
        description="College/University ID number",
    )
    institutional_id_url: Optional[str] = Field(
        default=None,
        description="Uploaded institutional ID card URL",
    )

    # Employment information (for working professionals)
    company_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Employer/Company name",
        examples=["Google India", "Infosys", "Startup XYZ"],
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Job title/designation",
        examples=["Software Engineer", "Marketing Manager", "Analyst"],
    )
    company_id_url: Optional[str] = Field(
        default=None,
        description="Company ID card URL",
    )

    # Check-in/Check-out dates
    check_in_date: Optional[date] = Field(
        default=None,
        description="Actual check-in date",
    )
    expected_checkout_date: Optional[date] = Field(
        default=None,
        description="Expected/planned checkout date",
    )
    actual_checkout_date: Optional[date] = Field(
        default=None,
        description="Actual checkout date (when checked out)",
    )

    # Financial information
    security_deposit_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Security deposit amount",
    )
    security_deposit_paid: bool = Field(
        default=False,
        description="Security deposit payment status",
    )
    security_deposit_paid_date: Optional[date] = Field(
        default=None,
        description="Date security deposit was paid",
    )
    monthly_rent_amount: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Monthly rent amount for the student",
    )

    # Meal preferences
    mess_subscribed: bool = Field(
        default=False,
        description="Subscribed to mess/canteen facility",
    )
    dietary_preference: Optional[DietaryPreference] = Field(
        default=None,
        description="Dietary preference (veg/non-veg/vegan/jain)",
    )
    food_allergies: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Food allergies and restrictions",
        examples=["Peanuts, Shellfish", "Lactose intolerant", "Gluten allergy"],
    )

    # Status tracking
    student_status: StudentStatus = Field(
        default=StudentStatus.ACTIVE,
        description="Current student status",
    )
    notice_period_start: Optional[date] = Field(
        default=None,
        description="Notice period start date (if leaving)",
    )
    notice_period_end: Optional[date] = Field(
        default=None,
        description="Notice period end date",
    )

    @field_validator("guardian_name")
    @classmethod
    def validate_guardian_name(cls, v: str) -> str:
        """
        Validate and normalize guardian name.
        
        Ensures name is properly formatted and trimmed.
        """
        v = v.strip()
        if len(v) < 2:
            raise ValueError("Guardian name must be at least 2 characters")
        if v.isdigit():
            raise ValueError("Guardian name cannot be only numbers")
        # Remove excessive whitespace
        v = " ".join(v.split())
        return v

    @field_validator("guardian_phone")
    @classmethod
    def normalize_guardian_phone(cls, v: str) -> str:
        """Normalize guardian phone number."""
        return v.replace(" ", "").replace("-", "").strip()

    @field_validator("guardian_email")
    @classmethod
    def normalize_guardian_email(cls, v: Optional[str]) -> Optional[str]:
        """Normalize guardian email."""
        if v is not None:
            return v.lower().strip()
        return v

    @field_validator("id_proof_number")
    @classmethod
    def validate_id_proof_number(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize ID proof number."""
        if v is not None:
            v = v.strip().upper()
            if not v:
                return None
            # Remove excessive whitespace
            v = " ".join(v.split())
        return v

    @field_validator(
        "institution_name",
        "course",
        "company_name",
        "designation",
    )
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Remove excessive whitespace
            v = " ".join(v.split())
        return v

    @model_validator(mode="after")
    def validate_checkout_dates(self) -> "StudentBase":
        """
        Validate checkout date relationships.
        
        Ensures expected checkout is after check-in and actual is after expected.
        """
        if self.check_in_date and self.expected_checkout_date:
            if self.expected_checkout_date <= self.check_in_date:
                raise ValueError(
                    "Expected checkout date must be after check-in date"
                )

        if self.check_in_date and self.actual_checkout_date:
            if self.actual_checkout_date < self.check_in_date:
                raise ValueError(
                    "Actual checkout date cannot be before check-in date"
                )

        return self

    @model_validator(mode="after")
    def validate_notice_period(self) -> "StudentBase":
        """Validate notice period dates."""
        if self.notice_period_start and self.notice_period_end:
            if self.notice_period_end <= self.notice_period_start:
                raise ValueError(
                    "Notice period end must be after start date"
                )
        return self

    @model_validator(mode="after")
    def validate_institutional_or_employment(self) -> "StudentBase":
        """
        Validate that either institutional or employment info is provided.
        
        Students should be either studying or working.
        Note: This is a soft validation - we don't raise error to allow flexibility.
        """
        has_institution = any(
            [
                self.institution_name,
                self.course,
                self.student_id_number,
            ]
        )
        has_employment = any([self.company_name, self.designation])

        # Just log or track - don't enforce strictly
        # This allows for gap year students, etc.

        return self

    @model_validator(mode="after")
    def validate_room_bed_consistency(self) -> "StudentBase":
        """Validate room and bed assignment consistency."""
        # If bed is assigned, room must be assigned
        if self.bed_id and not self.room_id:
            raise ValueError(
                "Cannot assign bed without assigning room"
            )
        return self


class StudentCreate(StudentBase, BaseCreateSchema):
    """
    Schema for creating a new student record.
    
    Used when converting a booking to student or direct student registration.
    """

    # Override to ensure required fields
    user_id: str = Field(
        ...,
        description="User ID (required)",
    )
    hostel_id: str = Field(
        ...,
        description="Hostel ID (required)",
    )
    guardian_name: str = Field(
        ...,
        min_length=2,
        description="Guardian name (required)",
    )
    guardian_phone: str = Field(
        ...,
        description="Guardian phone (required)",
    )

    # Optional link to source booking
    booking_id: Optional[str] = Field(
        default=None,
        description="Source booking ID (if converted from booking)",
    )

    # Initial payment status
    initial_rent_paid: bool = Field(
        default=False,
        description="Whether initial/first month rent is paid",
    )


class StudentUpdate(BaseUpdateSchema):
    """
    Schema for updating student information.
    
    All fields are optional for partial updates.
    """

    # Room assignment updates
    room_id: Optional[str] = Field(
        default=None,
        description="Updated room ID",
    )
    bed_id: Optional[str] = Field(
        default=None,
        description="Updated bed ID",
    )

    # Identification updates
    id_proof_type: Optional[IDProofType] = Field(
        default=None,
        description="ID proof type",
    )
    id_proof_number: Optional[str] = Field(
        default=None,
        max_length=50,
        description="ID proof number",
    )
    id_proof_document_url: Optional[str] = Field(
        default=None,
        description="ID proof document URL",
    )

    # Guardian updates
    guardian_name: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=255,
        description="Guardian name",
    )
    guardian_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Guardian phone",
    )
    guardian_email: Optional[str] = Field(
        default=None,
        description="Guardian email",
    )
    guardian_relation: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Guardian relation",
    )
    guardian_address: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Guardian address",
    )

    # Institutional updates
    institution_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Institution name",
    )
    course: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Course",
    )
    year_of_study: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Year of study",
    )
    student_id_number: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Student ID number",
    )
    institutional_id_url: Optional[str] = Field(
        default=None,
        description="Institutional ID URL",
    )

    # Employment updates
    company_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Company name",
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Designation",
    )
    company_id_url: Optional[str] = Field(
        default=None,
        description="Company ID URL",
    )

    # Date updates
    check_in_date: Optional[date] = Field(
        default=None,
        description="Check-in date",
    )
    expected_checkout_date: Optional[date] = Field(
        default=None,
        description="Expected checkout date",
    )
    actual_checkout_date: Optional[date] = Field(
        default=None,
        description="Actual checkout date",
    )

    # Financial updates
    security_deposit_amount: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Security deposit amount",
    )
    security_deposit_paid: Optional[bool] = Field(
        default=None,
        description="Security deposit paid status",
    )
    security_deposit_paid_date: Optional[date] = Field(
        default=None,
        description="Security deposit paid date",
    )
    monthly_rent_amount: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Monthly rent amount",
    )

    # Meal updates
    mess_subscribed: Optional[bool] = Field(
        default=None,
        description="Mess subscription status",
    )
    dietary_preference: Optional[DietaryPreference] = Field(
        default=None,
        description="Dietary preference",
    )
    food_allergies: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Food allergies",
    )

    # Status updates
    student_status: Optional[StudentStatus] = Field(
        default=None,
        description="Student status",
    )
    notice_period_start: Optional[date] = Field(
        default=None,
        description="Notice period start",
    )
    notice_period_end: Optional[date] = Field(
        default=None,
        description="Notice period end",
    )

    # Apply same validators as base
    _validate_guardian_name = field_validator("guardian_name")(
        StudentBase.validate_guardian_name.__func__
    )
    _normalize_guardian_phone = field_validator("guardian_phone")(
        StudentBase.normalize_guardian_phone.__func__
    )
    _normalize_guardian_email = field_validator("guardian_email")(
        StudentBase.normalize_guardian_email.__func__
    )
    _validate_id_proof = field_validator("id_proof_number")(
        StudentBase.validate_id_proof_number.__func__
    )
    _normalize_text = field_validator(
        "institution_name",
        "course",
        "company_name",
        "designation",
    )(StudentBase.normalize_text_fields.__func__)


class StudentCheckInRequest(BaseCreateSchema):
    """
    Schema for student check-in operation.
    
    Handles the complete check-in process with room/bed assignment
    and payment verification.
    """

    student_id: str = Field(
        ...,
        description="Student ID to check in",
    )
    check_in_date: date = Field(
        ...,
        description="Check-in date",
    )
    room_id: str = Field(
        ...,
        description="Assigned room ID",
    )
    bed_id: str = Field(
        ...,
        description="Assigned bed ID",
    )

    # Payment verification
    security_deposit_paid: bool = Field(
        default=False,
        description="Security deposit payment confirmation",
    )
    security_deposit_payment_id: Optional[str] = Field(
        default=None,
        description="Security deposit payment reference ID",
    )
    initial_rent_paid: bool = Field(
        default=False,
        description="First month rent payment confirmation",
    )
    initial_rent_payment_id: Optional[str] = Field(
        default=None,
        description="Initial rent payment reference ID",
    )

    # Additional charges
    mess_advance_paid: bool = Field(
        default=False,
        description="Mess advance payment (if applicable)",
    )
    other_charges_paid: bool = Field(
        default=False,
        description="Other charges payment confirmation",
    )

    # Documentation
    id_proof_verified: bool = Field(
        default=False,
        description="ID proof verification status",
    )
    documents_collected: bool = Field(
        default=False,
        description="All required documents collected",
    )

    # Notes
    check_in_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Check-in notes and observations",
    )

    @field_validator("check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date is reasonable."""
        from datetime import timedelta

        today = date.today()

        # Allow up to 30 days in the past for data entry
        if v < today - timedelta(days=30):
            raise ValueError(
                "Check-in date cannot be more than 30 days in the past"
            )

        # Warn if more than 7 days in future
        if v > today + timedelta(days=7):
            raise ValueError(
                "Check-in date cannot be more than 7 days in the future"
            )

        return v

    @model_validator(mode="after")
    def validate_payment_references(self) -> "StudentCheckInRequest":
        """Validate payment reference IDs are provided when payments are confirmed."""
        if self.security_deposit_paid and not self.security_deposit_payment_id:
            raise ValueError(
                "Security deposit payment ID is required when payment is confirmed"
            )

        if self.initial_rent_paid and not self.initial_rent_payment_id:
            raise ValueError(
                "Initial rent payment ID is required when payment is confirmed"
            )

        return self


class StudentCheckOutRequest(BaseCreateSchema):
    """
    Schema for student check-out operation.
    
    Handles the complete checkout process with clearance verification
    and refund processing.
    """

    student_id: str = Field(
        ...,
        description="Student ID to check out",
    )
    checkout_date: date = Field(
        ...,
        description="Actual checkout date",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for checkout",
        examples=[
            "Course completion",
            "Job relocation",
            "Personal reasons",
            "Transferred to another hostel",
        ],
    )

    # Financial clearance
    final_dues_cleared: bool = Field(
        default=False,
        description="All outstanding dues cleared",
    )
    outstanding_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Outstanding amount (if any)",
    )
    refund_security_deposit: bool = Field(
        default=True,
        description="Refund security deposit",
    )
    security_deposit_refund_amount: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Security deposit refund amount (after deductions)",
    )
    deduction_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Deductions from security deposit",
    )
    deduction_reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for deductions",
    )

    # Room clearance
    room_condition_acceptable: bool = Field(
        default=True,
        description="Room condition is acceptable",
    )
    damages_reported: bool = Field(
        default=False,
        description="Any damages reported",
    )
    damage_charges: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Charges for damages",
    )

    # Property return
    key_returned: bool = Field(
        default=False,
        description="Room key returned",
    )
    id_card_returned: bool = Field(
        default=False,
        description="Hostel ID card returned",
    )
    other_items_returned: bool = Field(
        default=False,
        description="Other borrowed items returned",
    )

    # Clearance from departments
    mess_clearance: bool = Field(
        default=True,
        description="Mess dues cleared",
    )
    library_clearance: bool = Field(
        default=True,
        description="Library clearance obtained",
    )
    maintenance_clearance: bool = Field(
        default=True,
        description="No pending maintenance complaints",
    )

    # Notes
    checkout_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Checkout notes and observations",
    )
    forwarding_address: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Forwarding address for correspondence",
    )

    @field_validator("checkout_date")
    @classmethod
    def validate_checkout_date(cls, v: date) -> date:
        """Validate checkout date."""
        from datetime import timedelta

        today = date.today()

        # Allow past dates for data entry
        # Future dates for scheduled checkout
        if v > today + timedelta(days=90):
            raise ValueError(
                "Checkout date cannot be more than 90 days in the future"
            )

        return v

    @model_validator(mode="after")
    def validate_financial_consistency(self) -> "StudentCheckOutRequest":
        """Validate financial data consistency."""
        if not self.final_dues_cleared and self.outstanding_amount == 0:
            raise ValueError(
                "If dues are not cleared, outstanding amount must be greater than 0"
            )

        if self.refund_security_deposit and self.security_deposit_refund_amount is None:
            raise ValueError(
                "Security deposit refund amount is required when refunding deposit"
            )

        return self

    @model_validator(mode="after")
    def validate_clearance_requirements(self) -> "StudentCheckOutRequest":
        """Validate clearance requirements."""
        # If damages reported or poor room condition, require damage charges or reason
        if self.damages_reported or not self.room_condition_acceptable:
            if self.damage_charges == 0 and not self.deduction_reason:
                raise ValueError(
                    "Damage charges or deduction reason required for reported damages"
                )

        return self


class StudentRoomAssignment(BaseCreateSchema):
    """
    Schema for assigning/reassigning room and bed to student.
    
    Dedicated schema for room/bed assignment operations.
    """

    student_id: str = Field(
        ...,
        description="Student ID",
    )
    room_id: str = Field(
        ...,
        description="Room ID to assign",
    )
    bed_id: str = Field(
        ...,
        description="Bed ID to assign",
    )
    assignment_date: date = Field(
        ...,
        description="Assignment effective date",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for assignment/reassignment",
    )

    # Financial impact
    rent_adjustment: Optional[Decimal] = Field(
        default=None,
        description="Rent adjustment due to room change",
    )
    prorated_rent: bool = Field(
        default=True,
        description="Calculate prorated rent for partial month",
    )

    @field_validator("assignment_date")
    @classmethod
    def validate_assignment_date(cls, v: date) -> date:
        """Validate assignment date."""
        from datetime import timedelta

        today = date.today()

        if v < today - timedelta(days=7):
            raise ValueError(
                "Assignment date cannot be more than 7 days in the past"
            )

        return v


class StudentStatusUpdate(BaseCreateSchema):
    """
    Schema for updating student status.
    
    Handles status transitions with proper tracking and documentation.
    """

    student_id: str = Field(
        ...,
        description="Student ID",
    )
    new_status: StudentStatus = Field(
        ...,
        description="New student status",
    )
    effective_date: date = Field(
        ...,
        description="Status change effective date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for status change",
    )

    # For notice period status
    notice_period_days: Optional[int] = Field(
        default=None,
        ge=0,
        le=90,
        description="Notice period duration in days",
    )

    # For suspension
    suspension_end_date: Optional[date] = Field(
        default=None,
        description="Suspension end date (for SUSPENDED status)",
    )

    # Additional notes
    admin_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Administrative notes",
    )

    @model_validator(mode="after")
    def validate_status_specific_fields(self) -> "StudentStatusUpdate":
        """Validate status-specific required fields."""
        if self.new_status == StudentStatus.SUSPENDED:
            if not self.suspension_end_date:
                raise ValueError(
                    "Suspension end date is required for SUSPENDED status"
                )

        if self.new_status == StudentStatus.NOTICE_PERIOD:
            if not self.notice_period_days:
                raise ValueError(
                    "Notice period duration is required for NOTICE_PERIOD status"
                )

        return self

    @model_validator(mode="after")
    def validate_suspension_date(self) -> "StudentStatusUpdate":
        """Validate suspension end date."""
        if self.suspension_end_date:
            if self.suspension_end_date <= self.effective_date:
                raise ValueError(
                    "Suspension end date must be after effective date"
                )

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\student_dashboard.py ---
# --- File: app/schemas/student/student_dashboard.py ---
"""
Student dashboard schemas with comprehensive overview data.

Provides schemas for student dashboard, statistics, summaries,
and quick-view information.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseSchema

__all__ = [
    "StudentDashboard",
    "StudentFinancialSummary",
    "AttendanceSummary",
    "StudentStats",
    "RecentPayment",
    "RecentComplaint",
    "PendingLeave",
    "RecentAnnouncement",
    "TodayMessMenu",
    "UpcomingEvent",
]


class StudentFinancialSummary(BaseSchema):
    """
    Financial summary for student dashboard.
    
    Provides quick overview of payment status and dues.
    """

    monthly_rent: Decimal = Field(..., description="Monthly rent amount")
    next_due_date: date = Field(..., description="Next payment due date")
    amount_due: Decimal = Field(..., description="Current amount due")
    amount_overdue: Decimal = Field(..., description="Overdue amount")
    advance_balance: Decimal = Field(..., description="Advance payment balance")
    security_deposit: Decimal = Field(..., description="Security deposit amount")

    # Mess charges
    mess_charges: Decimal = Field(
        default=Decimal("0.00"),
        description="Monthly mess charges",
    )
    mess_balance: Decimal = Field(
        default=Decimal("0.00"),
        description="Mess account balance",
    )

    # Payment status
    payment_status: str = Field(
        ...,
        pattern=r"^(current|due_soon|overdue)$",
        description="Overall payment status",
    )
    days_until_due: Optional[int] = Field(
        default=None,
        description="Days until next payment due",
    )
    days_overdue: Optional[int] = Field(
        default=None,
        ge=0,
        description="Days payment is overdue",
    )

    @computed_field
    @property
    def total_outstanding(self) -> Decimal:
        """Calculate total outstanding amount."""
        return self.amount_due + self.amount_overdue

    @computed_field
    @property
    def net_balance(self) -> Decimal:
        """Calculate net balance (advance - dues)."""
        return self.advance_balance - self.total_outstanding

    @computed_field
    @property
    def is_payment_urgent(self) -> bool:
        """Check if payment is urgent (due in 3 days or overdue)."""
        if self.amount_overdue > 0:
            return True
        if self.days_until_due is not None and self.days_until_due <= 3:
            return True
        return False


class AttendanceSummary(BaseSchema):
    """
    Attendance summary for student dashboard.
    
    Provides attendance statistics and status.
    """

    # Current month
    current_month_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Current month attendance percentage",
    )
    current_month_present: int = Field(
        ...,
        ge=0,
        description="Days present this month",
    )
    current_month_absent: int = Field(
        ...,
        ge=0,
        description="Days absent this month",
    )
    current_month_leaves: int = Field(
        ...,
        ge=0,
        description="Days on leave this month",
    )
    current_month_total_days: int = Field(
        ...,
        ge=0,
        description="Total trackable days this month",
    )

    # Last 30 days
    last_30_days_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Last 30 days attendance percentage",
    )

    # Overall
    overall_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall attendance percentage",
    )
    minimum_required_percentage: Decimal = Field(
        default=Decimal("75.00"),
        description="Minimum required attendance",
    )

    # Status
    attendance_status: str = Field(
        ...,
        pattern=r"^(good|warning|critical)$",
        description="Attendance status indicator",
    )

    # Leaves
    leave_balance: int = Field(
        default=0,
        ge=0,
        description="Remaining leave balance",
    )
    pending_leave_requests: int = Field(
        default=0,
        ge=0,
        description="Pending leave applications",
    )

    @computed_field
    @property
    def is_below_minimum(self) -> bool:
        """Check if attendance is below minimum requirement."""
        return self.overall_percentage < self.minimum_required_percentage

    @computed_field
    @property
    def percentage_gap(self) -> Decimal:
        """Calculate gap from minimum requirement."""
        return self.minimum_required_percentage - self.overall_percentage


class StudentStats(BaseSchema):
    """
    Quick statistics for student dashboard.
    
    Provides key metrics and counts.
    """

    days_in_hostel: int = Field(
        ...,
        ge=0,
        description="Total days as hostel resident",
    )
    months_in_hostel: int = Field(
        ...,
        ge=0,
        description="Total months in hostel",
    )

    # Payments
    total_payments_made: int = Field(
        ...,
        ge=0,
        description="Total number of payments",
    )
    total_amount_paid: Decimal = Field(
        ...,
        ge=0,
        description="Total amount paid",
    )
    last_payment_date: Optional[date] = Field(
        default=None,
        description="Last payment date",
    )

    # Complaints
    complaints_raised: int = Field(
        ...,
        ge=0,
        description="Total complaints raised",
    )
    complaints_resolved: int = Field(
        ...,
        ge=0,
        description="Resolved complaints",
    )
    complaints_pending: int = Field(
        ...,
        ge=0,
        description="Pending complaints",
    )

    # Attendance
    current_attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Current attendance percentage",
    )

    # Mess
    mess_meals_consumed: int = Field(
        default=0,
        ge=0,
        description="Total mess meals consumed",
    )

    @computed_field
    @property
    def complaint_resolution_rate(self) -> Decimal:
        """Calculate complaint resolution rate."""
        if self.complaints_raised == 0:
            return Decimal("100.00")
        return Decimal(
            (self.complaints_resolved / self.complaints_raised * 100)
        ).quantize(Decimal("0.01"))


class RecentPayment(BaseSchema):
    """
    Recent payment item for dashboard.
    
    Displays recent payment transaction.
    """

    payment_id: str = Field(..., description="Payment ID")
    amount: Decimal = Field(..., ge=0, description="Payment amount")
    payment_type: str = Field(..., description="Payment type")
    payment_date: date = Field(..., description="Payment date")
    status: str = Field(..., description="Payment status")
    receipt_url: Optional[str] = Field(
        default=None,
        description="Receipt download URL",
    )
    payment_method: Optional[str] = Field(
        default=None,
        description="Payment method used",
    )


class RecentComplaint(BaseSchema):
    """
    Recent complaint item for dashboard.
    
    Displays recent complaint with status.
    """

    complaint_id: str = Field(..., description="Complaint ID")
    title: str = Field(..., description="Complaint title")
    category: str = Field(..., description="Complaint category")
    status: str = Field(..., description="Current status")
    priority: str = Field(..., description="Priority level")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    assigned_to: Optional[str] = Field(
        default=None,
        description="Assigned staff name",
    )

    @computed_field
    @property
    def days_open(self) -> int:
        """Calculate days since complaint was raised."""
        return (datetime.now() - self.created_at).days


class PendingLeave(BaseSchema):
    """
    Pending leave application for dashboard.
    
    Displays leave request awaiting approval.
    """

    leave_id: str = Field(..., description="Leave application ID")
    leave_type: str = Field(..., description="Leave type")
    from_date: date = Field(..., description="Leave start date")
    to_date: date = Field(..., description="Leave end date")
    total_days: int = Field(..., ge=1, description="Total leave days")
    reason: Optional[str] = Field(default=None, description="Leave reason")
    status: str = Field(..., description="Application status")
    applied_at: datetime = Field(..., description="Application timestamp")

    @computed_field
    @property
    def is_upcoming(self) -> bool:
        """Check if leave is upcoming."""
        return self.from_date > date.today()


class RecentAnnouncement(BaseSchema):
    """
    Recent announcement for dashboard.
    
    Displays hostel announcement.
    """

    announcement_id: str = Field(..., description="Announcement ID")
    title: str = Field(..., description="Announcement title")
    content: Optional[str] = Field(default=None, description="Announcement content")
    category: str = Field(..., description="Category")
    priority: str = Field(..., description="Priority level")
    published_at: datetime = Field(..., description="Published timestamp")
    is_read: bool = Field(default=False, description="Read status")
    is_important: bool = Field(default=False, description="Important flag")

    @computed_field
    @property
    def is_new(self) -> bool:
        """Check if announcement is new (within 24 hours)."""
        from datetime import timedelta

        return datetime.now() - self.published_at < timedelta(hours=24)


class TodayMessMenu(BaseSchema):
    """
    Today's mess menu for dashboard.
    
    Displays daily meal menu.
    """

    date: date = Field(..., description="Menu date")
    breakfast: List[str] = Field(
        default_factory=list,
        description="Breakfast items",
    )
    lunch: List[str] = Field(
        default_factory=list,
        description="Lunch items",
    )
    snacks: List[str] = Field(
        default_factory=list,
        description="Snacks/tea items",
    )
    dinner: List[str] = Field(
        default_factory=list,
        description="Dinner items",
    )
    is_special: bool = Field(
        default=False,
        description="Special menu (festival, etc.)",
    )
    special_occasion: Optional[str] = Field(
        default=None,
        description="Special occasion name",
    )


class UpcomingEvent(BaseSchema):
    """
    Upcoming event for dashboard.
    
    Displays hostel event or activity.
    """

    event_id: str = Field(..., description="Event ID")
    title: str = Field(..., description="Event title")
    description: Optional[str] = Field(default=None, description="Event description")
    event_date: date = Field(..., description="Event date")
    event_time: Optional[str] = Field(default=None, description="Event time")
    location: Optional[str] = Field(default=None, description="Event location")
    category: str = Field(..., description="Event category")
    is_registered: bool = Field(
        default=False,
        description="Student registration status",
    )
    registration_required: bool = Field(
        default=False,
        description="Whether registration is required",
    )

    @computed_field
    @property
    def days_until_event(self) -> int:
        """Calculate days until event."""
        return (self.event_date - date.today()).days


class StudentDashboard(BaseSchema):
    """
    Complete student dashboard.
    
    Aggregates all dashboard components for student overview.
    """

    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )

    # Hostel info
    hostel_name: str = Field(..., description="Current hostel")
    room_number: str = Field(..., description="Room number")
    bed_number: str = Field(..., description="Bed number")
    floor_number: Optional[int] = Field(default=None, description="Floor number")

    # Summaries
    financial_summary: StudentFinancialSummary = Field(
        ...,
        description="Financial overview",
    )
    attendance_summary: AttendanceSummary = Field(
        ...,
        description="Attendance overview",
    )
    stats: StudentStats = Field(
        ...,
        description="Quick statistics",
    )

    # Recent activity
    recent_payments: List[RecentPayment] = Field(
        default_factory=list,
        max_length=5,
        description="Last 5 payments",
    )
    recent_complaints: List[RecentComplaint] = Field(
        default_factory=list,
        max_length=5,
        description="Recent complaints",
    )
    pending_leave_applications: List[PendingLeave] = Field(
        default_factory=list,
        description="Pending leave requests",
    )

    # Announcements and events
    recent_announcements: List[RecentAnnouncement] = Field(
        default_factory=list,
        max_length=5,
        description="Recent announcements",
    )
    upcoming_events: List[UpcomingEvent] = Field(
        default_factory=list,
        max_length=5,
        description="Upcoming events",
    )
    unread_announcements_count: int = Field(
        default=0,
        ge=0,
        description="Unread announcements count",
    )

    # Mess menu
    today_mess_menu: Optional[TodayMessMenu] = Field(
        default=None,
        description="Today's mess menu",
    )

    # Notifications
    unread_notifications_count: int = Field(
        default=0,
        ge=0,
        description="Unread notifications count",
    )

    # Last updated
    dashboard_updated_at: datetime = Field(
        ...,
        description="Dashboard data timestamp",
    )

    @computed_field
    @property
    def has_urgent_items(self) -> bool:
        """Check if there are urgent items requiring attention."""
        # Check for urgent payments
        if self.financial_summary.is_payment_urgent:
            return True

        # Check for critical attendance
        if self.attendance_summary.attendance_status == "critical":
            return True

        # Check for high-priority complaints
        if any(c.priority in ["high", "urgent"] for c in self.recent_complaints):
            return True

        return False

    @computed_field
    @property
    def action_items_count(self) -> int:
        """Count items requiring action."""
        count = 0

        # Pending payments
        if self.financial_summary.amount_due > 0:
            count += 1

        # Pending leave approvals
        count += len(self.pending_leave_applications)

        # Open complaints
        count += sum(
            1 for c in self.recent_complaints if c.status != "resolved"
        )

        return count

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\student_filters.py ---
# --- File: app/schemas/student/student_filters.py ---
"""
Student filter and search schemas with advanced filtering options.

Provides comprehensive filtering, searching, sorting, and bulk operation
schemas for student management.
"""

from __future__ import annotations

from datetime import date
from typing import List, Optional

from pydantic import Field, field_validator

from app.schemas.common.base import BaseFilterSchema, BaseCreateSchema
from app.schemas.common.enums import StudentStatus

__all__ = [
    "StudentFilterParams",
    "StudentSearchRequest",
    "StudentSortOptions",
    "StudentExportRequest",
    "StudentBulkActionRequest",
    "AdvancedStudentFilters",
]


class StudentFilterParams(BaseFilterSchema):
    """
    Student filter parameters.
    
    Comprehensive filtering options for student queries.
    """

    # Text search
    search: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=255,
        description="Search in name, email, phone, room number",
    )

    # Hostel filter
    hostel_id: Optional[str] = Field(
        default=None,
        description="Filter by single hostel ID",
    )
    hostel_ids: Optional[List[str]] = Field(
        default=None,
        min_length=1,
        max_length=10,
        description="Filter by multiple hostel IDs",
    )

    # Room filter
    room_id: Optional[str] = Field(
        default=None,
        description="Filter by specific room",
    )
    room_number: Optional[str] = Field(
        default=None,
        description="Filter by room number",
    )
    room_type: Optional[str] = Field(
        default=None,
        description="Filter by room type",
    )
    floor_number: Optional[int] = Field(
        default=None,
        ge=0,
        le=50,
        description="Filter by floor number",
    )
    wing: Optional[str] = Field(
        default=None,
        description="Filter by wing/block",
    )

    # Status filter
    status: Optional[StudentStatus] = Field(
        default=None,
        description="Filter by single status",
    )
    statuses: Optional[List[StudentStatus]] = Field(
        default=None,
        min_length=1,
        description="Filter by multiple statuses",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Filter by active status",
    )
    is_checked_in: Optional[bool] = Field(
        default=None,
        description="Filter by check-in status",
    )

    # Date filters
    checked_in_after: Optional[date] = Field(
        default=None,
        description="Checked in after this date",
    )
    checked_in_before: Optional[date] = Field(
        default=None,
        description="Checked in before this date",
    )
    expected_checkout_after: Optional[date] = Field(
        default=None,
        description="Expected checkout after this date",
    )
    expected_checkout_before: Optional[date] = Field(
        default=None,
        description="Expected checkout before this date",
    )

    # Financial filters
    has_overdue_payments: Optional[bool] = Field(
        default=None,
        description="Has overdue payments",
    )
    has_advance_balance: Optional[bool] = Field(
        default=None,
        description="Has advance payment balance",
    )
    security_deposit_paid: Optional[bool] = Field(
        default=None,
        description="Security deposit paid status",
    )

    # Meal filter
    mess_subscribed: Optional[bool] = Field(
        default=None,
        description="Subscribed to mess facility",
    )

    # Institutional filters
    institution_name: Optional[str] = Field(
        default=None,
        description="Filter by institution name (partial match)",
    )
    course: Optional[str] = Field(
        default=None,
        description="Filter by course (partial match)",
    )

    # Company filter
    company_name: Optional[str] = Field(
        default=None,
        description="Filter by company name (partial match)",
    )

    # Gender filter
    gender: Optional[str] = Field(
        default=None,
        pattern=r"^(male|female|other)$",
        description="Filter by gender",
    )

    @field_validator("hostel_ids")
    @classmethod
    def validate_unique_hostel_ids(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """Ensure hostel IDs are unique."""
        if v is not None and len(v) != len(set(v)):
            raise ValueError("Hostel IDs must be unique")
        return v

    @field_validator("statuses")
    @classmethod
    def validate_unique_statuses(
        cls, v: Optional[List[StudentStatus]]
    ) -> Optional[List[StudentStatus]]:
        """Ensure statuses are unique."""
        if v is not None and len(v) != len(set(v)):
            raise ValueError("Statuses must be unique")
        return v


class StudentSearchRequest(BaseFilterSchema):
    """
    Student search request.
    
    Full-text search with field selection and filters.
    """

    query: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Search query",
    )
    hostel_id: Optional[str] = Field(
        default=None,
        description="Limit search to specific hostel",
    )

    # Search field selection
    search_in_name: bool = Field(
        default=True,
        description="Search in student name",
    )
    search_in_email: bool = Field(
        default=True,
        description="Search in email address",
    )
    search_in_phone: bool = Field(
        default=True,
        description="Search in phone number",
    )
    search_in_room: bool = Field(
        default=True,
        description="Search in room number",
    )
    search_in_institution: bool = Field(
        default=True,
        description="Search in institution name",
    )
    search_in_company: bool = Field(
        default=False,
        description="Search in company name",
    )
    search_in_guardian: bool = Field(
        default=False,
        description="Search in guardian name",
    )

    # Additional filters
    status: Optional[StudentStatus] = Field(
        default=None,
        description="Filter by status",
    )
    only_active: bool = Field(
        default=True,
        description="Only include active students",
    )

    # Pagination
    page: int = Field(
        default=1,
        ge=1,
        description="Page number",
    )
    page_size: int = Field(
        default=20,
        ge=1,
        le=100,
        description="Results per page",
    )


class StudentSortOptions(BaseFilterSchema):
    """
    Student sorting options.
    
    Defines available sort criteria and order.
    """

    sort_by: str = Field(
        default="created_at",
        pattern=r"^(name|email|room_number|check_in_date|created_at|monthly_rent|status)$",
        description="Field to sort by",
    )
    sort_order: str = Field(
        default="desc",
        pattern=r"^(asc|desc)$",
        description="Sort order (ascending/descending)",
    )

    @field_validator("sort_order")
    @classmethod
    def normalize_sort_order(cls, v: str) -> str:
        """Normalize sort order to lowercase."""
        return v.lower()


class AdvancedStudentFilters(BaseFilterSchema):
    """
    Advanced filtering options.
    
    Additional complex filters for detailed queries.
    """

    # Attendance filters
    min_attendance_percentage: Optional[float] = Field(
        default=None,
        ge=0,
        le=100,
        description="Minimum attendance percentage",
    )
    max_attendance_percentage: Optional[float] = Field(
        default=None,
        ge=0,
        le=100,
        description="Maximum attendance percentage",
    )
    attendance_below_required: Optional[bool] = Field(
        default=None,
        description="Attendance below minimum requirement",
    )

    # Payment behavior
    payment_history: Optional[str] = Field(
        default=None,
        pattern=r"^(good|irregular|poor)$",
        description="Payment history pattern",
    )
    has_pending_complaints: Optional[bool] = Field(
        default=None,
        description="Has open complaints",
    )

    # Duration filters
    min_stay_days: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum stay duration in days",
    )
    max_stay_days: Optional[int] = Field(
        default=None,
        ge=0,
        description="Maximum stay duration in days",
    )

    # Age filters
    min_age: Optional[int] = Field(
        default=None,
        ge=16,
        le=100,
        description="Minimum age",
    )
    max_age: Optional[int] = Field(
        default=None,
        ge=16,
        le=100,
        description="Maximum age",
    )

    # Document verification
    documents_verified: Optional[bool] = Field(
        default=None,
        description="All documents verified",
    )

    @field_validator("max_attendance_percentage")
    @classmethod
    def validate_attendance_range(cls, v: Optional[float], info) -> Optional[float]:
        """Validate attendance percentage range."""
        if v is not None:
            min_att = info.data.get("min_attendance_percentage")
            if min_att is not None and v < min_att:
                raise ValueError(
                    "max_attendance_percentage must be >= min_attendance_percentage"
                )
        return v


class StudentExportRequest(BaseFilterSchema):
    """
    Export students request.
    
    Configures student data export with format and field selection.
    """

    hostel_id: Optional[str] = Field(
        default=None,
        description="Export students from specific hostel",
    )
    filters: Optional[StudentFilterParams] = Field(
        default=None,
        description="Apply filters to export",
    )

    # Export format
    format: str = Field(
        default="csv",
        pattern=r"^(csv|excel|pdf)$",
        description="Export file format",
    )

    # Field selection
    include_financial_data: bool = Field(
        default=False,
        description="Include payment and financial information",
    )
    include_attendance_data: bool = Field(
        default=False,
        description="Include attendance statistics",
    )
    include_guardian_info: bool = Field(
        default=True,
        description="Include guardian information",
    )
    include_institutional_info: bool = Field(
        default=True,
        description="Include college/company information",
    )
    include_contact_details: bool = Field(
        default=True,
        description="Include phone and email",
    )
    include_room_assignment: bool = Field(
        default=True,
        description="Include room and bed details",
    )

    # Additional options
    include_inactive: bool = Field(
        default=False,
        description="Include inactive students",
    )
    include_checkout_students: bool = Field(
        default=False,
        description="Include checked-out students",
    )

    @field_validator("format")
    @classmethod
    def normalize_format(cls, v: str) -> str:
        """Normalize format to lowercase."""
        return v.lower()


class StudentBulkActionRequest(BaseCreateSchema):
    """
    Bulk action on students.
    
    Performs bulk operations on multiple students.
    """

    student_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Student IDs (max 100)",
    )
    action: str = Field(
        ...,
        pattern=r"^(activate|deactivate|send_notification|export|change_status|assign_room|update_rent)$",
        description="Action to perform",
    )

    # Action-specific parameters
    new_status: Optional[StudentStatus] = Field(
        default=None,
        description="New status (for change_status action)",
    )
    notification_message: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Notification message (for send_notification)",
    )
    notification_title: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Notification title",
    )
    new_rent_amount: Optional[float] = Field(
        default=None,
        ge=0,
        description="New rent amount (for update_rent)",
    )
    effective_date: Optional[date] = Field(
        default=None,
        description="Effective date for changes",
    )

    # Confirmation
    confirm_action: bool = Field(
        default=False,
        description="Explicit confirmation for bulk action",
    )

    @field_validator("student_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[str]) -> List[str]:
        """Ensure student IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Student IDs must be unique")
        return v

    @field_validator("action")
    @classmethod
    def normalize_action(cls, v: str) -> str:
        """Normalize action to lowercase."""
        return v.lower()

    @model_validator(mode="after")
    def validate_action_parameters(self) -> "StudentBulkActionRequest":
        """Validate action-specific required parameters."""
        if self.action == "change_status" and not self.new_status:
            raise ValueError("new_status is required for change_status action")

        if self.action == "send_notification":
            if not self.notification_message:
                raise ValueError(
                    "notification_message is required for send_notification action"
                )
            if not self.notification_title:
                raise ValueError(
                    "notification_title is required for send_notification action"
                )

        if self.action == "update_rent" and self.new_rent_amount is None:
            raise ValueError("new_rent_amount is required for update_rent action")

        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\student_profile.py ---
# --- File: app/schemas/student/student_profile.py ---
"""
Student profile management schemas with enhanced validation.

Provides schemas for student profile creation, updates, document management,
and preference settings.
"""

from __future__ import annotations

from datetime import datetime
from typing import List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import DietaryPreference, IDProofType

__all__ = [
    "StudentProfileCreate",
    "StudentProfileUpdate",
    "StudentDocuments",
    "DocumentInfo",
    "DocumentUploadRequest",
    "DocumentVerificationRequest",
    "StudentPreferences",
    "StudentPrivacySettings",
]


class StudentProfileCreate(BaseCreateSchema):
    """
    Create student profile (extends user registration).
    
    Used during student onboarding to collect student-specific information.
    """

    # Guardian information (required for students)
    guardian_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Guardian/parent full name",
    )
    guardian_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Guardian contact phone",
    )
    guardian_email: Optional[str] = Field(
        default=None,
        description="Guardian email address",
    )
    guardian_relation: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Relation to student",
        examples=["Father", "Mother", "Uncle", "Guardian"],
    )
    guardian_address: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Guardian residential address",
    )

    # Institutional information (for students)
    institution_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Educational institution name",
    )
    course: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Course/program name",
    )
    year_of_study: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Current year/semester",
    )
    student_id_number: Optional[str] = Field(
        default=None,
        max_length=100,
        description="College/University ID",
    )

    # Employment information (for working professionals)
    company_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Employer name",
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Job designation",
    )

    # ID proof
    id_proof_type: Optional[IDProofType] = Field(
        default=None,
        description="Type of ID proof",
    )
    id_proof_number: Optional[str] = Field(
        default=None,
        max_length=50,
        description="ID proof number",
    )

    # Preferences
    dietary_preference: Optional[DietaryPreference] = Field(
        default=None,
        description="Dietary preference",
    )
    food_allergies: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Food allergies and restrictions",
    )

    @field_validator("guardian_name")
    @classmethod
    def validate_guardian_name(cls, v: str) -> str:
        """Validate and normalize guardian name."""
        v = v.strip()
        if len(v) < 2:
            raise ValueError("Guardian name must be at least 2 characters")
        if v.isdigit():
            raise ValueError("Guardian name cannot be only numbers")
        return " ".join(v.split())

    @field_validator("guardian_phone")
    @classmethod
    def normalize_guardian_phone(cls, v: str) -> str:
        """Normalize guardian phone number."""
        return v.replace(" ", "").replace("-", "").strip()

    @field_validator("guardian_email")
    @classmethod
    def normalize_guardian_email(cls, v: Optional[str]) -> Optional[str]:
        """Normalize guardian email."""
        if v is not None:
            return v.lower().strip()
        return v

    @field_validator(
        "institution_name",
        "course",
        "company_name",
        "designation",
    )
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            return " ".join(v.split())
        return v

    @field_validator("id_proof_number")
    @classmethod
    def normalize_id_proof(cls, v: Optional[str]) -> Optional[str]:
        """Normalize ID proof number."""
        if v is not None:
            v = v.strip().upper()
            if not v:
                return None
            return " ".join(v.split())
        return v

    @model_validator(mode="after")
    def validate_student_or_professional(self) -> "StudentProfileCreate":
        """
        Validate that either institutional or employment info is provided.
        
        Students should be either studying or working.
        """
        has_institution = any(
            [
                self.institution_name,
                self.course,
                self.student_id_number,
            ]
        )
        has_employment = any([self.company_name, self.designation])

        if not has_institution and not has_employment:
            raise ValueError(
                "Either institutional information (for students) or "
                "employment information (for working professionals) must be provided"
            )

        return self


class StudentProfileUpdate(BaseUpdateSchema):
    """
    Update student profile.
    
    All fields optional for partial updates.
    """

    # Guardian updates
    guardian_name: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=255,
        description="Guardian name",
    )
    guardian_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Guardian phone",
    )
    guardian_email: Optional[str] = Field(
        default=None,
        description="Guardian email",
    )
    guardian_relation: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Guardian relation",
    )
    guardian_address: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Guardian address",
    )

    # Institutional updates
    institution_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Institution name",
    )
    course: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Course",
    )
    year_of_study: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Year of study",
    )
    student_id_number: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Student ID",
    )

    # Employment updates
    company_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Company name",
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Designation",
    )

    # ID proof updates
    id_proof_type: Optional[IDProofType] = Field(
        default=None,
        description="ID proof type",
    )
    id_proof_number: Optional[str] = Field(
        default=None,
        max_length=50,
        description="ID proof number",
    )

    # Preferences
    dietary_preference: Optional[DietaryPreference] = Field(
        default=None,
        description="Dietary preference",
    )
    food_allergies: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Food allergies",
    )

    # Apply validators
    _validate_guardian_name = field_validator("guardian_name")(
        StudentProfileCreate.validate_guardian_name.__func__
    )
    _normalize_phone = field_validator("guardian_phone")(
        StudentProfileCreate.normalize_guardian_phone.__func__
    )
    _normalize_email = field_validator("guardian_email")(
        StudentProfileCreate.normalize_guardian_email.__func__
    )
    _normalize_text = field_validator(
        "institution_name",
        "course",
        "company_name",
        "designation",
    )(StudentProfileCreate.normalize_text_fields.__func__)
    _normalize_id = field_validator("id_proof_number")(
        StudentProfileCreate.normalize_id_proof.__func__
    )


class DocumentInfo(BaseSchema):
    """
    Individual document information.
    
    Represents a single uploaded document with metadata.
    """

    id: str = Field(..., description="Document ID")
    document_type: str = Field(
        ...,
        description="Document category/type",
        examples=[
            "id_proof",
            "address_proof",
            "photo",
            "institutional_id",
            "company_id",
            "other",
        ],
    )
    document_name: str = Field(
        ...,
        description="Document display name",
    )
    document_url: HttpUrl = Field(
        ...,
        description="Document storage URL",
    )
    file_size_bytes: Optional[int] = Field(
        default=None,
        ge=0,
        description="File size in bytes",
    )
    mime_type: Optional[str] = Field(
        default=None,
        description="MIME type",
        examples=["application/pdf", "image/jpeg", "image/png"],
    )
    uploaded_at: datetime = Field(
        ...,
        description="Upload timestamp",
    )
    uploaded_by: str = Field(
        ...,
        description="User ID who uploaded",
    )

    # Verification
    verified: bool = Field(
        default=False,
        description="Verification status",
    )
    verified_by: Optional[str] = Field(
        default=None,
        description="Admin who verified",
    )
    verified_at: Optional[datetime] = Field(
        default=None,
        description="Verification timestamp",
    )
    verification_notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Verification notes",
    )

    # Expiry (for documents like ID proofs)
    expiry_date: Optional[datetime] = Field(
        default=None,
        description="Document expiry date",
    )
    is_expired: bool = Field(
        default=False,
        description="Whether document is expired",
    )


class StudentDocuments(BaseSchema):
    """
    Student document collection.
    
    All documents associated with a student.
    """

    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")
    documents: List[DocumentInfo] = Field(
        default_factory=list,
        description="List of uploaded documents",
    )
    total_documents: int = Field(
        default=0,
        ge=0,
        description="Total document count",
    )
    verified_documents: int = Field(
        default=0,
        ge=0,
        description="Verified document count",
    )
    pending_verification: int = Field(
        default=0,
        ge=0,
        description="Pending verification count",
    )


class DocumentUploadRequest(BaseCreateSchema):
    """
    Upload document request.
    
    Used after file upload to register document in system.
    """

    student_id: str = Field(
        ...,
        description="Student ID",
    )
    document_type: str = Field(
        ...,
        pattern=r"^(id_proof|address_proof|photo|institutional_id|company_id|other)$",
        description="Document type/category",
    )
    document_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Document name",
    )
    document_url: HttpUrl = Field(
        ...,
        description="Document URL (after upload to storage)",
    )
    file_size_bytes: Optional[int] = Field(
        default=None,
        ge=0,
        le=10485760,  # 10MB
        description="File size in bytes (max 10MB)",
    )
    mime_type: Optional[str] = Field(
        default=None,
        description="MIME type",
    )
    expiry_date: Optional[datetime] = Field(
        default=None,
        description="Document expiry date (for ID proofs)",
    )
    notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Additional notes",
    )

    @field_validator("document_type")
    @classmethod
    def normalize_document_type(cls, v: str) -> str:
        """Normalize document type to lowercase."""
        return v.lower().strip()

    @field_validator("document_name")
    @classmethod
    def validate_document_name(cls, v: str) -> str:
        """Validate and normalize document name."""
        v = v.strip()
        if not v:
            raise ValueError("Document name cannot be empty")
        return " ".join(v.split())

    @field_validator("mime_type")
    @classmethod
    def validate_mime_type(cls, v: Optional[str]) -> Optional[str]:
        """Validate MIME type is allowed."""
        if v is not None:
            allowed_types = [
                "application/pdf",
                "image/jpeg",
                "image/jpg",
                "image/png",
                "image/webp",
            ]
            if v.lower() not in allowed_types:
                raise ValueError(
                    f"MIME type must be one of: {', '.join(allowed_types)}"
                )
        return v

    @field_validator("expiry_date")
    @classmethod
    def validate_expiry_date(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate expiry date is in the future."""
        if v is not None:
            if v < datetime.now():
                raise ValueError("Document expiry date cannot be in the past")
        return v


class DocumentVerificationRequest(BaseCreateSchema):
    """
    Verify document request.
    
    Used by admins to verify or reject uploaded documents.
    """

    document_id: str = Field(
        ...,
        description="Document ID to verify",
    )
    verified: bool = Field(
        ...,
        description="Verification status (true=verified, false=rejected)",
    )
    verification_notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Verification notes/comments",
    )
    reject_reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Rejection reason (if not verified)",
    )

    @model_validator(mode="after")
    def validate_rejection_reason(self) -> "DocumentVerificationRequest":
        """Require rejection reason if document is rejected."""
        if not self.verified and not self.reject_reason:
            raise ValueError(
                "Rejection reason is required when rejecting a document"
            )
        return self


class StudentPreferences(BaseUpdateSchema):
    """
    Student preferences and settings.
    
    Manages student-specific preferences for meal, notifications, etc.
    """

    # Meal preferences
    mess_subscribed: Optional[bool] = Field(
        default=None,
        description="Mess subscription status",
    )
    dietary_preference: Optional[DietaryPreference] = Field(
        default=None,
        description="Dietary preference",
    )
    food_allergies: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Food allergies and restrictions",
    )

    # Meal plan preferences
    meal_plan_type: Optional[str] = Field(
        default=None,
        pattern=r"^(full|breakfast_only|lunch_dinner|custom)$",
        description="Meal plan type",
    )
    skip_breakfast: bool = Field(
        default=False,
        description="Skip breakfast in meal plan",
    )
    skip_lunch: bool = Field(
        default=False,
        description="Skip lunch in meal plan",
    )
    skip_dinner: bool = Field(
        default=False,
        description="Skip dinner in meal plan",
    )

    # Notification preferences
    email_notifications: bool = Field(
        default=True,
        description="Enable email notifications",
    )
    sms_notifications: bool = Field(
        default=True,
        description="Enable SMS notifications",
    )
    push_notifications: bool = Field(
        default=True,
        description="Enable push notifications",
    )

    # Notification types
    payment_reminders: bool = Field(
        default=True,
        description="Receive payment reminders",
    )
    attendance_alerts: bool = Field(
        default=True,
        description="Receive attendance alerts",
    )
    announcement_notifications: bool = Field(
        default=True,
        description="Receive announcements",
    )
    complaint_updates: bool = Field(
        default=True,
        description="Receive complaint status updates",
    )
    event_notifications: bool = Field(
        default=True,
        description="Receive event notifications",
    )

    # Communication preferences
    preferred_language: str = Field(
        default="en",
        pattern=r"^(en|hi|ta|te|bn|mr|gu)$",
        description="Preferred language for communications",
    )
    preferred_contact_method: str = Field(
        default="email",
        pattern=r"^(email|sms|phone|whatsapp)$",
        description="Preferred contact method",
    )

    @field_validator("preferred_language", "preferred_contact_method")
    @classmethod
    def normalize_preferences(cls, v: str) -> str:
        """Normalize preference values."""
        return v.lower().strip()


class StudentPrivacySettings(BaseUpdateSchema):
    """
    Student privacy settings.
    
    Controls visibility of student information to others.
    """

    # Profile visibility
    show_profile_to_others: bool = Field(
        default=True,
        description="Show profile to other students",
    )
    show_room_number: bool = Field(
        default=True,
        description="Show room number in profile",
    )
    show_phone_number: bool = Field(
        default=False,
        description="Show phone number to other students",
    )
    show_email: bool = Field(
        default=False,
        description="Show email to other students",
    )
    show_institutional_info: bool = Field(
        default=True,
        description="Show college/company information",
    )

    # Contact permissions
    allow_roommate_contact: bool = Field(
        default=True,
        description="Allow roommates to view contact info",
    )
    allow_floormate_contact: bool = Field(
        default=True,
        description="Allow floormates to view contact info",
    )
    allow_hostelmate_contact: bool = Field(
        default=False,
        description="Allow all hostel residents to view contact info",
    )

    # Search visibility
    searchable_by_name: bool = Field(
        default=True,
        description="Allow search by name",
    )
    searchable_by_institution: bool = Field(
        default=True,
        description="Allow search by institution",
    )

    # Activity visibility
    show_last_seen: bool = Field(
        default=True,
        description="Show last seen/activity status",
    )
    show_attendance_to_others: bool = Field(
        default=False,
        description="Show attendance status to other students",
    )


class StudentBulkImport(BaseCreateSchema):
    """
    Bulk import students from file.
    
    Used for initial data migration or batch student registration.
    """

    hostel_id: str = Field(
        ...,
        description="Hostel ID for all students",
    )
    import_file_url: HttpUrl = Field(
        ...,
        description="URL of uploaded CSV/Excel file",
    )
    file_type: str = Field(
        ...,
        pattern=r"^(csv|excel)$",
        description="File format",
    )
    skip_duplicates: bool = Field(
        default=True,
        description="Skip duplicate email/phone entries",
    )
    send_welcome_email: bool = Field(
        default=True,
        description="Send welcome email to imported students",
    )
    auto_generate_passwords: bool = Field(
        default=True,
        description="Auto-generate passwords for new users",
    )

    # Field mapping (if custom columns)
    field_mapping: Optional[dict] = Field(
        default=None,
        description="Custom field mapping for CSV columns",
        examples=[
            {
                "Name": "full_name",
                "Email": "email",
                "Phone": "phone",
                "Guardian Name": "guardian_name",
            }
        ],
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\student_response.py ---
# --- File: app/schemas/student/student_response.py ---
"""
Student response schemas for API responses.

Provides various response formats for student data including
detailed views, list items, profiles, and specialized information.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import (
    DietaryPreference,
    IDProofType,
    StudentStatus,
)

__all__ = [
    "StudentResponse",
    "StudentDetail",
    "StudentProfile",
    "StudentListItem",
    "StudentFinancialInfo",
    "StudentContactInfo",
    "StudentDocumentInfo",
]


class StudentResponse(BaseResponseSchema):
    """
    Standard student response schema.
    
    Basic student information for general API responses.
    """

    user_id: str = Field(..., description="User ID")
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    room_id: Optional[str] = Field(default=None, description="Room ID")
    room_number: Optional[str] = Field(default=None, description="Room number")
    bed_id: Optional[str] = Field(default=None, description="Bed ID")
    bed_number: Optional[str] = Field(default=None, description="Bed number")

    # Personal info (from user)
    full_name: str = Field(..., description="Student full name")
    email: str = Field(..., description="Email address")
    phone: str = Field(..., description="Phone number")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )

    # Guardian
    guardian_name: str = Field(..., description="Guardian name")
    guardian_phone: str = Field(..., description="Guardian phone")

    # Status
    student_status: StudentStatus = Field(..., description="Student status")
    check_in_date: Optional[date] = Field(
        default=None,
        description="Check-in date",
    )
    expected_checkout_date: Optional[date] = Field(
        default=None,
        description="Expected checkout date",
    )

    # Financial
    monthly_rent_amount: Optional[Decimal] = Field(
        default=None,
        description="Monthly rent",
    )
    security_deposit_amount: Decimal = Field(
        ...,
        description="Security deposit amount",
    )
    security_deposit_paid: bool = Field(
        ...,
        description="Security deposit paid status",
    )

    # Meal
    mess_subscribed: bool = Field(..., description="Mess subscription status")

    @computed_field
    @property
    def days_in_hostel(self) -> Optional[int]:
        """Calculate days stayed in hostel."""
        if not self.check_in_date:
            return None
        end_date = self.actual_checkout_date or date.today()
        return (end_date - self.check_in_date).days

    @computed_field
    @property
    def is_checked_in(self) -> bool:
        """Check if student is currently checked in."""
        return (
            self.check_in_date is not None
            and self.actual_checkout_date is None
        )


class StudentDetail(BaseResponseSchema):
    """
    Detailed student information.
    
    Comprehensive student profile with all attributes.
    """

    # User information
    user_id: str = Field(..., description="User ID")
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    gender: Optional[str] = Field(default=None, description="Gender")
    date_of_birth: Optional[date] = Field(default=None, description="Date of birth")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )

    # Hostel assignment
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    room_id: Optional[str] = Field(default=None, description="Room ID")
    room_number: Optional[str] = Field(default=None, description="Room number")
    room_type: Optional[str] = Field(default=None, description="Room type")
    floor_number: Optional[int] = Field(default=None, description="Floor number")
    bed_id: Optional[str] = Field(default=None, description="Bed ID")
    bed_number: Optional[str] = Field(default=None, description="Bed number")

    # Identification
    id_proof_type: Optional[IDProofType] = Field(
        default=None,
        description="ID proof type",
    )
    id_proof_number: Optional[str] = Field(
        default=None,
        description="ID proof number",
    )
    id_proof_document_url: Optional[str] = Field(
        default=None,
        description="ID proof document URL",
    )
    id_proof_verified: bool = Field(
        default=False,
        description="ID proof verification status",
    )

    # Guardian information
    guardian_name: str = Field(..., description="Guardian name")
    guardian_phone: str = Field(..., description="Guardian phone")
    guardian_email: Optional[str] = Field(default=None, description="Guardian email")
    guardian_relation: Optional[str] = Field(
        default=None,
        description="Guardian relation",
    )
    guardian_address: Optional[str] = Field(
        default=None,
        description="Guardian address",
    )

    # Institutional information
    institution_name: Optional[str] = Field(
        default=None,
        description="Institution name",
    )
    course: Optional[str] = Field(default=None, description="Course")
    year_of_study: Optional[str] = Field(default=None, description="Year of study")
    student_id_number: Optional[str] = Field(
        default=None,
        description="Student ID number",
    )
    institutional_id_url: Optional[str] = Field(
        default=None,
        description="Institutional ID URL",
    )

    # Employment information
    company_name: Optional[str] = Field(default=None, description="Company name")
    designation: Optional[str] = Field(default=None, description="Designation")
    company_id_url: Optional[str] = Field(
        default=None,
        description="Company ID URL",
    )

    # Dates
    check_in_date: Optional[date] = Field(default=None, description="Check-in date")
    expected_checkout_date: Optional[date] = Field(
        default=None,
        description="Expected checkout",
    )
    actual_checkout_date: Optional[date] = Field(
        default=None,
        description="Actual checkout",
    )

    # Financial
    security_deposit_amount: Decimal = Field(
        ...,
        description="Security deposit amount",
    )
    security_deposit_paid: bool = Field(
        ...,
        description="Security deposit paid",
    )
    security_deposit_paid_date: Optional[date] = Field(
        default=None,
        description="Deposit paid date",
    )
    monthly_rent_amount: Optional[Decimal] = Field(
        default=None,
        description="Monthly rent",
    )

    # Meal preferences
    mess_subscribed: bool = Field(..., description="Mess subscription")
    dietary_preference: Optional[DietaryPreference] = Field(
        default=None,
        description="Dietary preference",
    )
    food_allergies: Optional[str] = Field(
        default=None,
        description="Food allergies",
    )

    # Status
    student_status: StudentStatus = Field(..., description="Student status")
    notice_period_start: Optional[date] = Field(
        default=None,
        description="Notice period start",
    )
    notice_period_end: Optional[date] = Field(
        default=None,
        description="Notice period end",
    )

    # Source
    booking_id: Optional[str] = Field(
        default=None,
        description="Source booking ID",
    )

    # Additional documents
    additional_documents: List[dict] = Field(
        default_factory=list,
        description="Additional uploaded documents",
    )

    @computed_field
    @property
    def age(self) -> Optional[int]:
        """Calculate age from date of birth."""
        if not self.date_of_birth:
            return None
        today = date.today()
        return (
            today.year
            - self.date_of_birth.year
            - (
                (today.month, today.day)
                < (self.date_of_birth.month, self.date_of_birth.day)
            )
        )

    @computed_field
    @property
    def days_in_hostel(self) -> Optional[int]:
        """Calculate total days in hostel."""
        if not self.check_in_date:
            return None
        end_date = self.actual_checkout_date or date.today()
        return (end_date - self.check_in_date).days

    @computed_field
    @property
    def is_currently_resident(self) -> bool:
        """Check if currently a resident."""
        return (
            self.check_in_date is not None
            and self.actual_checkout_date is None
            and self.student_status == StudentStatus.ACTIVE
        )

    @computed_field
    @property
    def is_student(self) -> bool:
        """Check if institutional student."""
        return bool(self.institution_name or self.course)

    @computed_field
    @property
    def is_working_professional(self) -> bool:
        """Check if working professional."""
        return bool(self.company_name or self.designation)


class StudentProfile(BaseSchema):
    """
    Public student profile.
    
    Limited information suitable for public/peer viewing.
    """

    id: str = Field(..., description="Student ID")
    full_name: str = Field(..., description="Full name")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )
    hostel_name: str = Field(..., description="Hostel name")
    room_number: Optional[str] = Field(default=None, description="Room number")
    check_in_date: Optional[date] = Field(default=None, description="Check-in date")

    # Optional info (based on privacy settings)
    institution_name: Optional[str] = Field(
        default=None,
        description="Institution name",
    )
    course: Optional[str] = Field(default=None, description="Course")
    year_of_study: Optional[str] = Field(default=None, description="Year")
    company_name: Optional[str] = Field(default=None, description="Company")

    @computed_field
    @property
    def duration_in_hostel(self) -> Optional[str]:
        """Human-readable duration in hostel."""
        if not self.check_in_date:
            return None

        days = (date.today() - self.check_in_date).days
        if days < 30:
            return f"{days} days"
        elif days < 365:
            months = days // 30
            return f"{months} month{'s' if months > 1 else ''}"
        else:
            years = days // 365
            return f"{years} year{'s' if years > 1 else ''}"


class StudentListItem(BaseSchema):
    """
    Student list item for admin views.
    
    Optimized for list rendering with essential information.
    """

    id: str = Field(..., description="Student ID")
    user_id: str = Field(..., description="User ID")
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )

    # Room assignment
    room_number: Optional[str] = Field(default=None, description="Room number")
    bed_number: Optional[str] = Field(default=None, description="Bed number")

    # Status
    student_status: StudentStatus = Field(..., description="Status")
    check_in_date: Optional[date] = Field(default=None, description="Check-in date")

    # Financial
    monthly_rent: Optional[Decimal] = Field(default=None, description="Monthly rent")
    payment_status: str = Field(
        ...,
        description="Payment status (current/overdue/advance)",
    )
    overdue_amount: Decimal = Field(
        default=Decimal("0.00"),
        description="Overdue amount",
    )

    # Timestamps
    created_at: datetime = Field(..., description="Registration timestamp")

    @computed_field
    @property
    def days_in_hostel(self) -> Optional[int]:
        """Calculate days in hostel."""
        if not self.check_in_date:
            return None
        return (date.today() - self.check_in_date).days


class StudentFinancialInfo(BaseSchema):
    """
    Student financial information.
    
    Comprehensive financial details for a student.
    """

    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")

    # Rent
    monthly_rent_amount: Decimal = Field(..., description="Monthly rent")
    rent_due_day: int = Field(..., description="Monthly due day")

    # Security deposit
    security_deposit_amount: Decimal = Field(..., description="Security deposit")
    security_deposit_paid: bool = Field(..., description="Deposit paid status")
    security_deposit_paid_date: Optional[date] = Field(
        default=None,
        description="Deposit paid date",
    )
    security_deposit_refundable: Decimal = Field(
        ...,
        description="Refundable amount",
    )

    # Payments
    total_paid: Decimal = Field(..., description="Total amount paid")
    total_due: Decimal = Field(..., description="Total amount due")
    last_payment_date: Optional[date] = Field(
        default=None,
        description="Last payment date",
    )
    next_due_date: Optional[date] = Field(default=None, description="Next due date")

    # Outstanding
    overdue_amount: Decimal = Field(..., description="Overdue amount")
    advance_amount: Decimal = Field(..., description="Advance balance")

    # Mess
    mess_charges_monthly: Decimal = Field(
        default=Decimal("0.00"),
        description="Monthly mess charges",
    )
    mess_balance: Decimal = Field(
        default=Decimal("0.00"),
        description="Mess account balance",
    )

    # Other charges
    other_charges: Decimal = Field(
        default=Decimal("0.00"),
        description="Other charges",
    )

    @computed_field
    @property
    def payment_status(self) -> str:
        """Determine payment status."""
        if self.overdue_amount > 0:
            return "overdue"
        elif self.advance_amount > 0:
            return "advance"
        else:
            return "current"

    @computed_field
    @property
    def total_outstanding(self) -> Decimal:
        """Calculate total outstanding amount."""
        return self.total_due - self.advance_amount

    @computed_field
    @property
    def net_balance(self) -> Decimal:
        """Calculate net balance (advance - dues)."""
        return self.advance_amount - self.total_due


class StudentContactInfo(BaseSchema):
    """
    Student contact information.
    
    Comprehensive contact details for emergency and communication.
    """

    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")

    # Student contact
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    alternate_phone: Optional[str] = Field(default=None, description="Alternate phone")

    # Guardian contact
    guardian_name: str = Field(..., description="Guardian name")
    guardian_phone: str = Field(..., description="Guardian phone")
    guardian_email: Optional[str] = Field(default=None, description="Guardian email")
    guardian_relation: Optional[str] = Field(
        default=None,
        description="Guardian relation",
    )
    guardian_address: Optional[str] = Field(
        default=None,
        description="Guardian address",
    )

    # Emergency contact (from user profile)
    emergency_contact_name: Optional[str] = Field(
        default=None,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        default=None,
        description="Emergency contact phone",
    )
    emergency_contact_relation: Optional[str] = Field(
        default=None,
        description="Emergency relation",
    )

    # Current address (hostel)
    current_hostel: str = Field(..., description="Current hostel")
    current_room: Optional[str] = Field(default=None, description="Current room")

    # Forwarding address (if checked out)
    forwarding_address: Optional[str] = Field(
        default=None,
        description="Forwarding address",
    )


class StudentDocumentInfo(BaseSchema):
    """
    Student document information.
    
    Details about uploaded documents and verification status.
    """

    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")

    # ID documents
    id_proof_type: Optional[IDProofType] = Field(
        default=None,
        description="ID proof type",
    )
    id_proof_number: Optional[str] = Field(
        default=None,
        description="ID proof number",
    )
    id_proof_url: Optional[str] = Field(
        default=None,
        description="ID proof document URL",
    )
    id_proof_verified: bool = Field(
        default=False,
        description="ID verification status",
    )
    id_proof_verified_at: Optional[datetime] = Field(
        default=None,
        description="Verification timestamp",
    )

    # Institutional documents
    institutional_id_url: Optional[str] = Field(
        default=None,
        description="College/University ID",
    )
    institutional_id_verified: bool = Field(
        default=False,
        description="Institutional ID verified",
    )

    # Employment documents
    company_id_url: Optional[str] = Field(
        default=None,
        description="Company ID card",
    )
    company_id_verified: bool = Field(
        default=False,
        description="Company ID verified",
    )

    # Additional documents
    additional_documents: List[dict] = Field(
        default_factory=list,
        description="Other uploaded documents",
    )

    @computed_field
    @property
    def verification_status(self) -> str:
        """Overall verification status."""
        if self.id_proof_verified:
            return "verified"
        elif self.id_proof_url:
            return "pending_verification"
        else:
            return "not_uploaded"

    @computed_field
    @property
    def documents_complete(self) -> bool:
        """Check if all required documents are uploaded."""
        return bool(self.id_proof_url)

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\student_room_history.py ---
# --- File: app/schemas/student/student_room_history.py ---
"""
Student room history and transfer schemas with enhanced validation.

Provides schemas for tracking room assignments, transfers, and
movement history for students.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator, computed_field

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
)

__all__ = [
    "RoomHistoryResponse",
    "RoomHistoryItem",
    "RoomTransferRequest",
    "RoomTransferApproval",
    "RoomTransferStatus",
    "BulkRoomTransfer",
    "SingleTransfer",
    "RoomSwapRequest",
]


class RoomHistoryItem(BaseResponseSchema):
    """
    Individual room history entry.
    
    Represents a single room assignment period in student's history.
    """

    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    room_id: str = Field(..., description="Room ID")
    room_number: str = Field(..., description="Room number")
    room_type: str = Field(..., description="Room type")
    floor_number: Optional[int] = Field(default=None, description="Floor number")
    wing: Optional[str] = Field(default=None, description="Wing/Block")
    bed_id: Optional[str] = Field(default=None, description="Bed ID")
    bed_number: Optional[str] = Field(default=None, description="Bed number")

    # Duration
    move_in_date: date = Field(..., description="Move-in date")
    move_out_date: Optional[date] = Field(
        default=None,
        description="Move-out date (null if current)",
    )
    duration_days: Optional[int] = Field(
        default=None,
        ge=0,
        description="Total duration in days",
    )

    # Financial
    rent_amount: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Monthly rent for this assignment",
    )
    total_rent_paid: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Total rent paid during this period",
    )

    # Transfer details
    reason: Optional[str] = Field(
        default=None,
        description="Reason for assignment/transfer",
    )
    transfer_type: Optional[str] = Field(
        default=None,
        description="Transfer type (initial, request, admin)",
    )

    # Audit
    requested_by: Optional[str] = Field(
        default=None,
        description="User who requested transfer",
    )
    approved_by: Optional[str] = Field(
        default=None,
        description="Admin who approved assignment",
    )
    assigned_at: datetime = Field(
        ...,
        description="Assignment timestamp",
    )

    @computed_field
    @property
    def is_current(self) -> bool:
        """Check if this is the current assignment."""
        return self.move_out_date is None

    @computed_field
    @property
    def duration_months(self) -> Optional[Decimal]:
        """Calculate duration in months."""
        if self.duration_days is None:
            return None
        return Decimal(self.duration_days / 30).quantize(Decimal("0.1"))


class RoomHistoryResponse(BaseSchema):
    """
    Complete student room history.
    
    Chronological list of all room assignments for a student.
    """

    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")
    hostel_id: str = Field(..., description="Current hostel ID")
    hostel_name: str = Field(..., description="Current hostel name")

    # Current assignment
    current_room: Optional[str] = Field(
        default=None,
        description="Current room number",
    )
    current_bed: Optional[str] = Field(
        default=None,
        description="Current bed number",
    )

    # History
    room_history: List[RoomHistoryItem] = Field(
        ...,
        description="Room assignment history (newest first)",
    )

    # Statistics
    total_assignments: int = Field(
        default=0,
        ge=0,
        description="Total number of room assignments",
    )
    total_transfers: int = Field(
        default=0,
        ge=0,
        description="Total number of room transfers",
    )

    @computed_field
    @property
    def has_changed_rooms(self) -> bool:
        """Check if student has changed rooms."""
        return self.total_assignments > 1


class RoomTransferRequest(BaseCreateSchema):
    """
    Request room transfer.
    
    Student-initiated or admin-initiated room transfer request.
    """

    student_id: str = Field(
        ...,
        description="Student ID requesting transfer",
    )
    current_room_id: str = Field(
        ...,
        description="Current room ID",
    )
    requested_room_id: str = Field(
        ...,
        description="Desired room ID",
    )
    requested_bed_id: Optional[str] = Field(
        default=None,
        description="Desired bed ID (if specific bed requested)",
    )

    transfer_date: date = Field(
        ...,
        description="Desired transfer date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for transfer",
        examples=[
            "Room too small for my belongings",
            "Prefer ground floor room",
            "Request to be closer to friends",
            "Medical reasons - need AC room",
        ],
    )

    # Preferences
    accept_price_difference: bool = Field(
        default=False,
        description="Accept if new room has different rent",
    )
    flexible_on_bed: bool = Field(
        default=True,
        description="Flexible on specific bed (any bed in room)",
    )

    # Priority
    priority: str = Field(
        default="normal",
        pattern=r"^(low|normal|high|urgent)$",
        description="Transfer priority/urgency",
    )

    # Supporting documents
    supporting_documents: List[str] = Field(
        default_factory=list,
        description="URLs of supporting documents (medical certificates, etc.)",
    )

    @field_validator("transfer_date")
    @classmethod
    def validate_transfer_date(cls, v: date) -> date:
        """Validate transfer date is reasonable."""
        from datetime import timedelta

        today = date.today()

        # Must be at least today or future
        if v < today:
            raise ValueError("Transfer date cannot be in the past")

        # Warn if too far in future (more than 90 days)
        if v > today + timedelta(days=90):
            raise ValueError(
                "Transfer date cannot be more than 90 days in the future"
            )

        return v

    @model_validator(mode="after")
    def validate_different_room(self) -> "RoomTransferRequest":
        """Ensure requested room is different from current room."""
        if self.current_room_id == self.requested_room_id:
            raise ValueError(
                "Requested room must be different from current room"
            )
        return self


class RoomTransferApproval(BaseCreateSchema):
    """
    Approve or reject room transfer request.
    
    Admin action to process transfer requests.
    """

    transfer_request_id: str = Field(
        ...,
        description="Transfer request ID to process",
    )
    approved: bool = Field(
        ...,
        description="Approval decision (true=approved, false=rejected)",
    )

    # If approved
    new_room_id: Optional[str] = Field(
        default=None,
        description="Approved room (may differ from requested)",
    )
    new_bed_id: Optional[str] = Field(
        default=None,
        description="Assigned bed in new room",
    )
    transfer_date: Optional[date] = Field(
        default=None,
        description="Approved transfer date (may differ from requested)",
    )

    # If rejected
    rejection_reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Detailed rejection reason",
        examples=[
            "Requested room not available",
            "Transfer not justified",
            "Pending payment dues must be cleared first",
        ],
    )

    # Financial implications
    rent_adjustment: Optional[Decimal] = Field(
        default=None,
        description="Monthly rent adjustment (positive=increase, negative=decrease)",
    )
    additional_charges: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="One-time transfer charges",
    )
    prorated_rent_calculation: bool = Field(
        default=True,
        description="Calculate prorated rent for partial month",
    )

    # Notes
    admin_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Administrative notes",
    )

    @model_validator(mode="after")
    def validate_approval_requirements(self) -> "RoomTransferApproval":
        """Validate approval-specific required fields."""
        if self.approved:
            # Approved transfers require room and bed assignment
            if not self.new_room_id:
                raise ValueError(
                    "new_room_id is required when approving transfer"
                )
            if not self.new_bed_id:
                raise ValueError(
                    "new_bed_id is required when approving transfer"
                )
            if not self.transfer_date:
                raise ValueError(
                    "transfer_date is required when approving transfer"
                )
        else:
            # Rejected transfers require rejection reason
            if not self.rejection_reason:
                raise ValueError(
                    "rejection_reason is required when rejecting transfer"
                )

        return self

    @field_validator("transfer_date")
    @classmethod
    def validate_transfer_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate transfer date."""
        if v is not None:
            from datetime import timedelta

            today = date.today()
            if v < today:
                raise ValueError("Transfer date cannot be in the past")
            if v > today + timedelta(days=90):
                raise ValueError(
                    "Transfer date cannot be more than 90 days in the future"
                )
        return v


class RoomTransferStatus(BaseSchema):
    """
    Room transfer request status.
    
    Current status and details of a transfer request.
    """

    request_id: str = Field(..., description="Transfer request ID")
    student_id: str = Field(..., description="Student ID")
    student_name: str = Field(..., description="Student name")

    # Room details
    current_room: str = Field(..., description="Current room number")
    current_bed: Optional[str] = Field(default=None, description="Current bed")
    requested_room: str = Field(..., description="Requested room number")
    requested_bed: Optional[str] = Field(default=None, description="Requested bed")
    approved_room: Optional[str] = Field(
        default=None,
        description="Approved room (if different)",
    )
    approved_bed: Optional[str] = Field(
        default=None,
        description="Approved bed",
    )

    # Dates
    transfer_date: date = Field(..., description="Transfer date")
    requested_at: datetime = Field(..., description="Request timestamp")
    processed_at: Optional[datetime] = Field(
        default=None,
        description="Processing timestamp",
    )

    # Status
    status: str = Field(
        ...,
        pattern=r"^(pending|approved|rejected|completed|cancelled)$",
        description="Request status",
    )
    priority: str = Field(..., description="Request priority")

    # Details
    reason: str = Field(..., description="Transfer reason")
    approval_notes: Optional[str] = Field(
        default=None,
        description="Approval/rejection notes",
    )
    processed_by: Optional[str] = Field(
        default=None,
        description="Admin who processed",
    )
    processed_by_name: Optional[str] = Field(
        default=None,
        description="Admin name",
    )

    # Financial
    rent_adjustment: Optional[Decimal] = Field(
        default=None,
        description="Rent adjustment",
    )
    additional_charges: Optional[Decimal] = Field(
        default=None,
        description="Transfer charges",
    )

    @computed_field
    @property
    def is_pending(self) -> bool:
        """Check if request is still pending."""
        return self.status == "pending"

    @computed_field
    @property
    def days_pending(self) -> Optional[int]:
        """Calculate days request has been pending."""
        if self.status != "pending":
            return None
        return (datetime.now() - self.requested_at).days


class SingleTransfer(BaseSchema):
    """
    Single transfer in bulk operation.
    
    Represents one student transfer in a bulk transfer operation.
    """

    student_id: str = Field(..., description="Student ID to transfer")
    new_room_id: str = Field(..., description="New room ID")
    new_bed_id: Optional[str] = Field(
        default=None,
        description="New bed ID (optional, auto-assign if not specified)",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=200,
        description="Transfer reason (optional, uses bulk reason if not specified)",
    )


class BulkRoomTransfer(BaseCreateSchema):
    """
    Bulk room transfer (admin only).
    
    Transfer multiple students simultaneously (e.g., floor reorganization).
    """

    transfers: List[SingleTransfer] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of transfers to perform (max 50)",
    )
    transfer_date: date = Field(
        ...,
        description="Transfer date for all students",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Common reason for bulk transfer",
        examples=[
            "Floor renovation - temporary relocation",
            "Wing reorganization",
            "Room type consolidation",
        ],
    )

    # Options
    skip_on_error: bool = Field(
        default=True,
        description="Skip individual transfers that fail, continue with rest",
    )
    send_notifications: bool = Field(
        default=True,
        description="Send notifications to affected students",
    )
    prorated_rent: bool = Field(
        default=True,
        description="Calculate prorated rent for all transfers",
    )

    # Confirmation
    confirm_bulk_transfer: bool = Field(
        default=False,
        description="Explicit confirmation for bulk operation",
    )

    @field_validator("transfers")
    @classmethod
    def validate_unique_students(cls, v: List[SingleTransfer]) -> List[SingleTransfer]:
        """Ensure each student appears only once."""
        student_ids = [t.student_id for t in v]
        if len(student_ids) != len(set(student_ids)):
            raise ValueError(
                "Each student can only be transferred once in bulk operation"
            )
        return v

    @field_validator("transfer_date")
    @classmethod
    def validate_transfer_date(cls, v: date) -> date:
        """Validate transfer date."""
        from datetime import timedelta

        today = date.today()
        if v < today:
            raise ValueError("Transfer date cannot be in the past")
        if v > today + timedelta(days=30):
            raise ValueError(
                "Bulk transfer date cannot be more than 30 days in the future"
            )
        return v

    @model_validator(mode="after")
    def validate_confirmation(self) -> "BulkRoomTransfer":
        """Require explicit confirmation for bulk operations."""
        if not self.confirm_bulk_transfer:
            raise ValueError(
                "Bulk transfer requires explicit confirmation (confirm_bulk_transfer=true)"
            )
        return self


class RoomSwapRequest(BaseCreateSchema):
    """
    Request room swap between two students.
    
    Mutual room exchange between two students.
    """

    student_1_id: str = Field(
        ...,
        description="First student ID",
    )
    student_2_id: str = Field(
        ...,
        description="Second student ID",
    )
    swap_date: date = Field(
        ...,
        description="Swap date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for swap",
        examples=[
            "Mutual preference exchange",
            "Closer to respective friends",
            "Room size preference swap",
        ],
    )

    # Consent
    student_1_consent: bool = Field(
        default=False,
        description="First student consent",
    )
    student_2_consent: bool = Field(
        default=False,
        description="Second student consent",
    )

    # Financial
    handle_rent_difference: bool = Field(
        default=True,
        description="Automatically handle rent difference between rooms",
    )

    @field_validator("swap_date")
    @classmethod
    def validate_swap_date(cls, v: date) -> date:
        """Validate swap date."""
        from datetime import timedelta

        today = date.today()
        if v < today:
            raise ValueError("Swap date cannot be in the past")
        if v > today + timedelta(days=30):
            raise ValueError(
                "Swap date cannot be more than 30 days in the future"
            )
        return v

    @model_validator(mode="after")
    def validate_different_students(self) -> "RoomSwapRequest":
        """Ensure students are different."""
        if self.student_1_id == self.student_2_id:
            raise ValueError(
                "Cannot swap room for the same student"
            )
        return self

    @model_validator(mode="after")
    def validate_consent(self) -> "RoomSwapRequest":
        """Validate both students have consented."""
        if not self.student_1_consent or not self.student_2_consent:
            raise ValueError(
                "Both students must consent to room swap"
            )
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\student\__init__.py ---
# --- File: app/schemas/student/__init__.py ---
"""
Student schemas package.

Re-exports commonly used student-related schemas for convenient imports.

Example:
    from app.schemas.student import (
        StudentCreate,
        StudentDetail,
        StudentDashboard,
        RoomTransferRequest,
    )
"""

from __future__ import annotations

from app.schemas.student.student_base import (
    StudentBase,
    StudentCheckInRequest,
    StudentCheckOutRequest,
    StudentCreate,
    StudentRoomAssignment,
    StudentStatusUpdate,
    StudentUpdate,
)
from app.schemas.student.student_dashboard import (
    AttendanceSummary,
    PendingLeave,
    RecentAnnouncement,
    RecentComplaint,
    RecentPayment,
    StudentDashboard,
    StudentFinancialSummary,
    StudentStats,
    TodayMessMenu,
    UpcomingEvent,
)
from app.schemas.student.student_filters import (
    AdvancedStudentFilters,
    StudentBulkActionRequest,
    StudentExportRequest,
    StudentFilterParams,
    StudentSearchRequest,
    StudentSortOptions,
)
from app.schemas.student.student_profile import (
    DocumentInfo,
    DocumentUploadRequest,
    DocumentVerificationRequest,
    StudentBulkImport,
    StudentDocuments,
    StudentPreferences,
    StudentPrivacySettings,
    StudentProfileCreate,
    StudentProfileUpdate,
)
from app.schemas.student.student_response import (
    StudentContactInfo,
    StudentDetail,
    StudentDocumentInfo,
    StudentFinancialInfo,
    StudentListItem,
    StudentProfile,
    StudentResponse,
)
from app.schemas.student.student_room_history import (
    BulkRoomTransfer,
    RoomHistoryItem,
    RoomHistoryResponse,
    RoomSwapRequest,
    RoomTransferApproval,
    RoomTransferRequest,
    RoomTransferStatus,
    SingleTransfer,
)

__all__ = [
    # Base
    "StudentBase",
    "StudentCreate",
    "StudentUpdate",
    "StudentCheckInRequest",
    "StudentCheckOutRequest",
    "StudentRoomAssignment",
    "StudentStatusUpdate",
    # Response
    "StudentResponse",
    "StudentDetail",
    "StudentProfile",
    "StudentListItem",
    "StudentFinancialInfo",
    "StudentContactInfo",
    "StudentDocumentInfo",
    # Profile
    "StudentProfileCreate",
    "StudentProfileUpdate",
    "StudentDocuments",
    "DocumentInfo",
    "DocumentUploadRequest",
    "DocumentVerificationRequest",
    "StudentPreferences",
    "StudentPrivacySettings",
    "StudentBulkImport",
    # Room history
    "RoomHistoryResponse",
    "RoomHistoryItem",
    "RoomTransferRequest",
    "RoomTransferApproval",
    "RoomTransferStatus",
    "BulkRoomTransfer",
    "SingleTransfer",
    "RoomSwapRequest",
    # Dashboard
    "StudentDashboard",
    "StudentStats",
    "StudentFinancialSummary",
    "AttendanceSummary",
    "RecentPayment",
    "RecentComplaint",
    "PendingLeave",
    "RecentAnnouncement",
    "TodayMessMenu",
    "UpcomingEvent",
    # Filters
    "StudentFilterParams",
    "StudentSearchRequest",
    "StudentSortOptions",
    "StudentExportRequest",
    "StudentBulkActionRequest",
    "AdvancedStudentFilters",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\subscription =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\subscription\all_folders_files_content.txt ---
### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\subscription ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\subscription =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\subscription\commission.py ---
"""
Booking commission tracking schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import Optional, List
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema


class CommissionConfig(BaseSchema):
    """Global/platform commission configuration"""
    default_commission_percentage: Decimal = Field(
        Decimal("5.00"), ge=0, le=100, description="Default commission%"
    )
    min_commission_percentage: Decimal = Field(Decimal("0.00"), ge=0, le=100)
    max_commission_percentage: Decimal = Field(Decimal("30.00"), ge=0, le=100)

    # Per-plan overrides
    commission_by_plan: dict[str, Decimal] = Field(
        default_factory=dict,
        description="plan_type (Standard/Premium) -> commission %",
    )


class BookingCommissionResponse(BaseResponseSchema):
    """Commission record for a booking"""
    booking_id: UUID
    hostel_id: UUID
    subscription_id: UUID

    booking_amount: Decimal
    commission_percentage: Decimal
    commission_amount: Decimal
    currency: str

    status: str  # pending, calculated, paid, waived
    due_date: Optional[date]
    paid_date: Optional[date]
    payment_reference: Optional[str]


class CommissionSummary(BaseSchema):
    """Commission summary for platform/hostel"""
    scope_type: str = Field(..., pattern="^(platform|hostel)$")
    hostel_id: Optional[UUID] = None

    period_start: date
    period_end: date

    total_commission_due: Decimal
    total_commission_paid: Decimal
    total_bookings_count: int
    bookings_with_commission_count: int

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\subscription\subscription_base.py ---
"""
Hostel subscription schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseUpdateSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import SubscriptionStatus, BillingCycle


class SubscriptionBase(BaseSchema):
    """Base subscription for a hostel"""
    hostel_id: UUID = Field(..., description="Hostel ID")
    plan_id: UUID = Field(..., description="Subscription plan ID")

    subscription_reference: str = Field(..., max_length=100)

    billing_cycle: BillingCycle = Field(..., description="Billing cycle (monthly/yearly)")
    amount: Decimal = Field(..., ge=0, description="Amount per billing period")
    currency: str = Field("INR", min_length=3, max_length=3)

    # Period
    start_date: date = Field(..., description="Subscription start date")
    end_date: date = Field(..., description="Subscription end date")

    auto_renew: bool = Field(True)
    next_billing_date: Optional[date] = None

    status: SubscriptionStatus = Field(SubscriptionStatus.ACTIVE)


class SubscriptionCreate(SubscriptionBase, BaseCreateSchema):
    """Create new hostel subscription"""
    trial_end_date: Optional[date] = None


class SubscriptionUpdate(BaseUpdateSchema):
    """Update subscription (e.g. status, next billing)"""
    status: Optional[SubscriptionStatus] = None
    end_date: Optional[date] = None
    auto_renew: Optional[bool] = None
    next_billing_date: Optional[date] = None

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\subscription\subscription_billing.py ---
"""
Subscription billing schemas
"""
from datetime import date
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema


class BillingCycleInfo(BaseSchema):
    """Info about current billing cycle for subscription"""
    subscription_id: UUID
    hostel_id: UUID
    plan_name: str

    cycle_start: date
    cycle_end: date
    billing_cycle: str  # monthly/yearly

    amount: Decimal
    currency: str

    next_billing_date: date
    auto_renew: bool


class GenerateInvoiceRequest(BaseCreateSchema):
    """Generate invoice for subscription cycle"""
    subscription_id: UUID
    billing_date: date

    # Overridable
    amount_override: Optional[Decimal] = None


class InvoiceInfo(BaseSchema):
    """Generated invoice info"""
    invoice_id: UUID
    subscription_id: UUID
    hostel_id: UUID

    invoice_number: str
    invoice_date: date
    due_date: date

    amount: Decimal
    currency: str

    status: str  # draft, issued, paid, overdue, cancelled
    invoice_url: Optional[str]

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\subscription\subscription_cancellation.py ---
"""
Subscription cancellation schemas
"""
from datetime import date, datetime
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema


class CancellationRequest(BaseCreateSchema):
    """Cancel subscription"""
    subscription_id: UUID
    hostel_id: UUID

    cancellation_reason: str = Field(..., min_length=10, max_length=500)
    cancel_immediately: bool = Field(False, description="Cancel now vs at end of term")


class CancellationResponse(BaseSchema):
    """Cancellation response"""
    subscription_id: UUID
    hostel_id: UUID

    cancelled: bool
    cancellation_effective_date: date
    cancelled_at: datetime
    cancelled_by: UUID

    message: str

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\subscription\subscription_plan_base.py ---
"""
Subscription plan definition schemas
"""
from decimal import Decimal
from typing import Dict, Optional, List
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseUpdateSchema, BaseResponseSchema
from app.schemas.common.enums import SubscriptionPlan


class SubscriptionPlanBase(BaseSchema):
    """Base subscription plan schema"""
    plan_name: str = Field(..., min_length=3, max_length=100, description="Plan internal name")
    display_name: str = Field(..., min_length=3, max_length=100, description="Plan display name")
    plan_type: SubscriptionPlan = Field(..., description="Plan tier/type")

    description: Optional[str] = Field(None, max_length=1000)

    price_monthly: Decimal = Field(..., ge=0, description="Monthly price")
    price_yearly: Decimal = Field(..., ge=0, description="Yearly price")
    currency: str = Field("INR", min_length=3, max_length=3)

    # Feature flags & limits as JSON
    features: Dict[str, object] = Field(
        default_factory=dict,
        description="Feature flags (e.g. max_hostels, advanced_analytics)",
    )

    max_hostels: Optional[int] = Field(None, ge=1)
    max_rooms_per_hostel: Optional[int] = Field(None, ge=1)
    max_students: Optional[int] = Field(None, ge=1)

    is_active: bool = Field(True)
    is_public: bool = Field(True, description="Show on pricing page")
    sort_order: int = Field(0, description="Ordering for display")


class PlanCreate(SubscriptionPlanBase, BaseCreateSchema):
    """Create new subscription plan"""
    pass


class PlanUpdate(BaseUpdateSchema):
    """Update subscription plan"""
    display_name: Optional[str] = None
    description: Optional[str] = None
    price_monthly: Optional[Decimal] = Field(None, ge=0)
    price_yearly: Optional[Decimal] = Field(None, ge=0)
    currency: Optional[str] = None
    features: Optional[Dict[str, object]] = None
    max_hostels: Optional[int] = Field(None, ge=1)
    max_rooms_per_hostel: Optional[int] = Field(None, ge=1)
    max_students: Optional[int] = Field(None, ge=1)
    is_active: Optional[bool] = None
    is_public: Optional[bool] = None
    sort_order: Optional[int] = None

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\subscription\subscription_plan_response.py ---
"""
Subscription plan response & comparison schemas
"""
from decimal import Decimal
from typing import Dict, List, Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import SubscriptionPlan


class PlanResponse(BaseResponseSchema):
    """Subscription plan response"""
    plan_name: str
    display_name: str
    plan_type: SubscriptionPlan

    description: Optional[str]
    price_monthly: Decimal
    price_yearly: Decimal
    currency: str

    features: Dict[str, object]
    max_hostels: Optional[int]
    max_rooms_per_hostel: Optional[int]
    max_students: Optional[int]

    is_active: bool
    is_public: bool
    sort_order: int


class PlanFeatures(BaseSchema):
    """Human-friendly plan feature matrix"""
    plan_name: str
    display_name: str
    features: Dict[str, str] = Field(..., description="Feature -> label/value")


class PlanComparison(BaseSchema):
    """Compare multiple plans side by side"""
    plans: List[PlanResponse]
    feature_matrix: Dict[str, Dict[str, object]] = Field(
        ...,
        description="Feature key -> plan_name -> value",
    )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\subscription\subscription_response.py ---
"""
Subscription response schemas
"""
from datetime import date, datetime
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import SubscriptionStatus, BillingCycle, SubscriptionPlan


class SubscriptionResponse(BaseResponseSchema):
    """Hostel subscription response"""
    hostel_id: UUID
    hostel_name: str

    plan_id: UUID
    plan_name: str
    display_name: str
    plan_type: SubscriptionPlan

    subscription_reference: str
    billing_cycle: BillingCycle
    amount: Decimal
    currency: str

    start_date: date
    end_date: date
    auto_renew: bool
    next_billing_date: Optional[date]
    status: SubscriptionStatus

    trial_end_date: Optional[date]
    last_payment_date: Optional[date]
    last_payment_amount: Optional[Decimal]


class BillingHistoryItem(BaseSchema):
    """Single billing event"""
    billing_date: date
    amount: Decimal
    currency: str
    status: str
    payment_reference: Optional[str]
    invoice_url: Optional[str]


class BillingHistory(BaseSchema):
    """Subscription billing history"""
    subscription_id: UUID
    hostel_id: UUID

    items: list[BillingHistoryItem]
    total_billed: Decimal
    total_paid: Decimal
    total_outstanding: Decimal

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\subscription\subscription_upgrade.py ---
"""
Subscription upgrade/downgrade schemas
"""
from datetime import date
from decimal import Decimal
from typing import Optional
from pydantic import Field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import BillingCycle


class UpgradeRequest(BaseCreateSchema):
    """Request to change subscription plan"""
    hostel_id: UUID
    current_plan_id: UUID
    new_plan_id: UUID
    billing_cycle: BillingCycle = Field(...)
 
    # Timing
    effective_from: date = Field(..., description="When new plan takes effect")
    prorate: bool = Field(True, description="Prorate charges/refunds")


class UpgradePreview(BaseSchema):
    """Preview cost impact of upgrade/downgrade"""
    current_plan_name: str
    new_plan_name: str

    current_amount: Decimal
    new_amount: Decimal

    # For current period
    prorated_charge: Decimal = Field(..., description="Additional amount to charge")
    prorated_refund: Decimal = Field(..., description="If downgrade, refund amount")

    effective_from: date
    message: str


class DowngradeRequest(UpgradeRequest):
    """Same payload, semantics are downgrade if new plan is smaller"""
    pass

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\hostel-back\app\schemas\subscription\__init__.py ---



# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\subscription\commission.py ---
# --- File: app/schemas/subscription/commission.py ---
"""
Booking commission tracking schemas.

Handles commission configuration, calculation, and tracking for
platform revenue from hostel bookings.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from enum import Enum
from typing import Dict, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseResponseSchema, BaseSchema

__all__ = [
    "CommissionStatus",
    "CommissionConfig",
    "BookingCommissionResponse",
    "CommissionSummary",
]


class CommissionStatus(str, Enum):
    """Commission payment status."""

    PENDING = "pending"
    CALCULATED = "calculated"
    INVOICED = "invoiced"
    PAID = "paid"
    WAIVED = "waived"
    DISPUTED = "disputed"


class CommissionConfig(BaseSchema):
    """
    Global/platform commission configuration.

    Defines default commission rates and per-plan overrides for
    calculating platform fees on bookings.
    """

    default_commission_percentage: Decimal = Field(
        default=Decimal("5.00"),
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Default commission percentage for all plans",
    )
    min_commission_percentage: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Minimum allowed commission percentage",
    )
    max_commission_percentage: Decimal = Field(
        default=Decimal("30.00"),
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Maximum allowed commission percentage",
    )
    commission_by_plan: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Plan type to commission percentage mapping (e.g., {'premium': 3.00})",
    )

    @field_validator("commission_by_plan")
    @classmethod
    def validate_plan_commissions(
        cls, v: Dict[str, Decimal]
    ) -> Dict[str, Decimal]:
        """Validate all plan commission percentages are within valid range."""
        for plan_name, percentage in v.items():
            if not (Decimal("0") <= percentage <= Decimal("100")):
                raise ValueError(
                    f"Commission for plan '{plan_name}' must be between 0 and 100"
                )
        return v

    @model_validator(mode="after")
    def validate_min_max_range(self) -> "CommissionConfig":
        """Ensure min <= default <= max commission percentages."""
        if self.min_commission_percentage > self.max_commission_percentage:
            raise ValueError(
                "min_commission_percentage cannot exceed max_commission_percentage"
            )
        if not (
            self.min_commission_percentage
            <= self.default_commission_percentage
            <= self.max_commission_percentage
        ):
            raise ValueError(
                "default_commission_percentage must be between min and max"
            )
        return self

    def get_commission_for_plan(self, plan_type: str) -> Decimal:
        """
        Get commission percentage for a specific plan.

        Args:
            plan_type: The subscription plan type.

        Returns:
            Commission percentage for the plan, or default if not specified.
        """
        return self.commission_by_plan.get(
            plan_type, self.default_commission_percentage
        )


class BookingCommissionResponse(BaseResponseSchema):
    """
    Commission record for a booking.

    Tracks the commission owed to the platform for a specific booking,
    including calculation details and payment status.
    """

    booking_id: UUID = Field(..., description="Associated booking ID")
    hostel_id: UUID = Field(..., description="Hostel ID")
    subscription_id: UUID = Field(..., description="Active subscription ID")

    booking_amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Total booking amount",
    )
    commission_percentage: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Applied commission percentage",
    )
    commission_amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Calculated commission amount",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="ISO 4217 currency code",
    )

    status: CommissionStatus = Field(
        default=CommissionStatus.PENDING,
        description="Commission payment status",
    )
    due_date: Optional[date] = Field(
        None, description="Commission payment due date"
    )
    paid_date: Optional[date] = Field(
        None, description="Actual payment date"
    )
    payment_reference: Optional[str] = Field(
        None,
        max_length=100,
        description="Payment transaction reference",
    )

    @model_validator(mode="after")
    def validate_payment_dates(self) -> "BookingCommissionResponse":
        """Validate paid_date is set only when status is PAID."""
        if self.status == CommissionStatus.PAID and self.paid_date is None:
            raise ValueError("paid_date is required when status is PAID")
        if self.status != CommissionStatus.PAID and self.paid_date is not None:
            raise ValueError("paid_date should only be set when status is PAID")
        return self


class CommissionSummary(BaseSchema):
    """
    Commission summary for platform or hostel.

    Aggregates commission data over a specified period for
    reporting and reconciliation purposes.
    """

    scope_type: str = Field(
        ...,
        pattern=r"^(platform|hostel)$",
        description="Summary scope: 'platform' or 'hostel'",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID (required when scope_type is 'hostel')",
    )

    period_start: date = Field(..., description="Summary period start date")
    period_end: date = Field(..., description="Summary period end date")

    total_bookings_count: int = Field(
        ...,
        ge=0,
        description="Total number of bookings in period",
    )
    bookings_with_commission_count: int = Field(
        ...,
        ge=0,
        description="Bookings with commission calculated",
    )

    total_booking_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Total booking value in period",
    )
    total_commission_due: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Total commission amount due",
    )
    total_commission_paid: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Total commission amount paid",
    )
    total_commission_pending: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Outstanding commission amount",
    )

    average_commission_rate: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Average commission rate applied",
    )

    @model_validator(mode="after")
    def validate_scope_and_dates(self) -> "CommissionSummary":
        """Validate hostel scope and date range."""
        if self.scope_type == "hostel" and self.hostel_id is None:
            raise ValueError("hostel_id is required when scope_type is 'hostel'")
        if self.period_end < self.period_start:
            raise ValueError("period_end must be after or equal to period_start")
        if self.bookings_with_commission_count > self.total_bookings_count:
            raise ValueError(
                "bookings_with_commission_count cannot exceed total_bookings_count"
            )
        return self

    @property
    def commission_collection_rate(self) -> Decimal:
        """Calculate commission collection rate as percentage."""
        if self.total_commission_due == Decimal("0"):
            return Decimal("100.00")
        return (
            self.total_commission_paid / self.total_commission_due * Decimal("100")
        ).quantize(Decimal("0.01"))

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\subscription\subscription_base.py ---
# --- File: app/schemas/subscription/subscription_base.py ---
"""
Hostel subscription base schemas.

Defines the core subscription data structures for creating,
updating, and managing hostel subscriptions.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import BillingCycle, SubscriptionStatus

__all__ = [
    "SubscriptionBase",
    "SubscriptionCreate",
    "SubscriptionUpdate",
]


class SubscriptionBase(BaseSchema):
    """
    Base subscription schema for a hostel.

    Contains all core fields that define a subscription relationship
    between a hostel and a subscription plan.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    plan_id: UUID = Field(..., description="Subscription plan ID")

    subscription_reference: str = Field(
        ...,
        min_length=1,
        max_length=100,
        pattern=r"^[A-Z0-9\-]+$",
        description="Unique subscription reference (e.g., SUB-2024-001)",
    )

    billing_cycle: BillingCycle = Field(
        ..., description="Billing cycle (monthly/yearly)"
    )
    amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Amount per billing period",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="ISO 4217 currency code",
    )

    start_date: date = Field(..., description="Subscription start date")
    end_date: date = Field(..., description="Subscription end date")

    auto_renew: bool = Field(
        default=True, description="Auto-renew subscription on expiry"
    )
    next_billing_date: Optional[date] = Field(
        None, description="Next scheduled billing date"
    )

    status: SubscriptionStatus = Field(
        default=SubscriptionStatus.ACTIVE,
        description="Current subscription status",
    )

    @model_validator(mode="after")
    def validate_dates(self) -> "SubscriptionBase":
        """Validate subscription date relationships."""
        if self.end_date < self.start_date:
            raise ValueError("end_date must be after or equal to start_date")

        if self.next_billing_date is not None:
            if self.next_billing_date < self.start_date:
                raise ValueError(
                    "next_billing_date cannot be before start_date"
                )
            if self.next_billing_date > self.end_date and self.auto_renew:
                # Allow next billing after end_date only if auto_renew is True
                pass
            elif self.next_billing_date > self.end_date:
                raise ValueError(
                    "next_billing_date cannot be after end_date when auto_renew is False"
                )

        return self

    @field_validator("subscription_reference")
    @classmethod
    def normalize_reference(cls, v: str) -> str:
        """Normalize subscription reference to uppercase."""
        return v.upper().strip()


class SubscriptionCreate(BaseCreateSchema):
    """
    Create new hostel subscription.

    Extends base subscription with trial period support.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    plan_id: UUID = Field(..., description="Subscription plan ID")

    subscription_reference: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Unique subscription reference",
    )

    billing_cycle: BillingCycle = Field(
        ..., description="Billing cycle (monthly/yearly)"
    )
    amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Amount per billing period",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="ISO 4217 currency code",
    )

    start_date: date = Field(..., description="Subscription start date")
    end_date: date = Field(..., description="Subscription end date")

    auto_renew: bool = Field(default=True)
    next_billing_date: Optional[date] = Field(None)

    status: SubscriptionStatus = Field(default=SubscriptionStatus.ACTIVE)

    trial_end_date: Optional[date] = Field(
        None,
        description="Trial period end date (if applicable)",
    )

    @model_validator(mode="after")
    def validate_create_dates(self) -> "SubscriptionCreate":
        """Validate all date relationships for creation."""
        if self.end_date < self.start_date:
            raise ValueError("end_date must be after or equal to start_date")

        if self.trial_end_date is not None:
            if self.trial_end_date < self.start_date:
                raise ValueError("trial_end_date cannot be before start_date")
            if self.trial_end_date > self.end_date:
                raise ValueError("trial_end_date cannot be after end_date")

        if self.next_billing_date is not None:
            if self.next_billing_date < self.start_date:
                raise ValueError("next_billing_date cannot be before start_date")

        return self

    @field_validator("subscription_reference")
    @classmethod
    def normalize_reference(cls, v: str) -> str:
        """Normalize subscription reference to uppercase."""
        return v.upper().strip()


class SubscriptionUpdate(BaseUpdateSchema):
    """
    Update subscription.

    Allows partial updates to subscription status, dates, and renewal settings.
    """

    status: Optional[SubscriptionStatus] = Field(
        None, description="New subscription status"
    )
    end_date: Optional[date] = Field(
        None, description="New subscription end date"
    )
    auto_renew: Optional[bool] = Field(
        None, description="Update auto-renewal setting"
    )
    next_billing_date: Optional[date] = Field(
        None, description="Update next billing date"
    )

    # Additional updatable fields
    amount: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Updated billing amount",
    )
    billing_cycle: Optional[BillingCycle] = Field(
        None, description="Updated billing cycle"
    )

    @model_validator(mode="after")
    def validate_update_consistency(self) -> "SubscriptionUpdate":
        """Validate update field consistency."""
        # If setting to cancelled/expired, auto_renew should be False
        if self.status in (
            SubscriptionStatus.CANCELLED,
            SubscriptionStatus.EXPIRED,
        ):
            if self.auto_renew is True:
                raise ValueError(
                    f"auto_renew cannot be True when status is {self.status.value}"
                )
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\subscription\subscription_billing.py ---
# --- File: app/schemas/subscription/subscription_billing.py ---
"""
Subscription billing schemas.

Handles billing cycle information, invoice generation,
and invoice tracking for subscriptions.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from enum import Enum
from typing import Optional
from uuid import UUID

from pydantic import Field, HttpUrl, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "InvoiceStatus",
    "BillingCycleInfo",
    "GenerateInvoiceRequest",
    "InvoiceInfo",
]


class InvoiceStatus(str, Enum):
    """Invoice status enumeration."""

    DRAFT = "draft"
    ISSUED = "issued"
    SENT = "sent"
    PAID = "paid"
    PARTIALLY_PAID = "partially_paid"
    OVERDUE = "overdue"
    CANCELLED = "cancelled"
    REFUNDED = "refunded"


class BillingCycleInfo(BaseSchema):
    """
    Information about current billing cycle for subscription.

    Provides a comprehensive view of the current billing period,
    including dates, amounts, and renewal information.
    """

    subscription_id: UUID = Field(..., description="Subscription ID")
    hostel_id: UUID = Field(..., description="Hostel ID")
    plan_name: str = Field(..., description="Subscription plan name")
    plan_display_name: str = Field(
        ..., description="Plan display name for UI"
    )

    cycle_start: date = Field(..., description="Current cycle start date")
    cycle_end: date = Field(..., description="Current cycle end date")
    billing_cycle: str = Field(
        ...,
        pattern=r"^(monthly|yearly)$",
        description="Billing cycle type",
    )

    amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Billing amount for this cycle",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="ISO 4217 currency code",
    )

    next_billing_date: date = Field(..., description="Next billing date")
    days_until_billing: int = Field(
        ...,
        description="Days until next billing",
    )
    auto_renew: bool = Field(..., description="Auto-renewal status")

    # Calculated fields
    is_in_trial: bool = Field(
        default=False, description="Whether currently in trial period"
    )
    trial_days_remaining: Optional[int] = Field(
        None, description="Days remaining in trial"
    )

    @model_validator(mode="after")
    def validate_cycle_dates(self) -> "BillingCycleInfo":
        """Validate billing cycle date relationships."""
        if self.cycle_end < self.cycle_start:
            raise ValueError("cycle_end must be after cycle_start")
        return self


class GenerateInvoiceRequest(BaseCreateSchema):
    """
    Request to generate invoice for subscription cycle.

    Allows specifying the billing date and optionally overriding
    the standard billing amount.
    """

    subscription_id: UUID = Field(
        ..., description="Subscription to invoice"
    )
    billing_date: date = Field(
        ..., description="Invoice billing date"
    )

    # Optional overrides
    amount_override: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Override standard billing amount",
    )
    due_date_override: Optional[date] = Field(
        None, description="Override standard due date"
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional invoice notes",
    )

    # Line item adjustments
    discount_amount: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Discount amount to apply",
    )
    discount_reason: Optional[str] = Field(
        None,
        max_length=200,
        description="Reason for discount",
    )

    @model_validator(mode="after")
    def validate_discount(self) -> "GenerateInvoiceRequest":
        """Validate discount fields."""
        if self.discount_amount is not None and self.discount_amount > Decimal("0"):
            if not self.discount_reason:
                raise ValueError(
                    "discount_reason is required when discount_amount is provided"
                )
        return self


class InvoiceInfo(BaseSchema):
    """
    Generated invoice information.

    Contains all details of a generated invoice including
    status, amounts, and access URLs.
    """

    invoice_id: UUID = Field(..., description="Invoice unique ID")
    subscription_id: UUID = Field(..., description="Associated subscription")
    hostel_id: UUID = Field(..., description="Hostel ID")

    invoice_number: str = Field(
        ...,
        min_length=1,
        max_length=50,
        pattern=r"^INV-\d{4}-\d{6,}$",
        description="Invoice number (e.g., INV-2024-000001)",
    )
    invoice_date: date = Field(..., description="Invoice issue date")
    due_date: date = Field(..., description="Payment due date")

    # Amounts
    subtotal: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Subtotal before adjustments",
    )
    discount_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Total discount applied",
    )
    tax_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Tax amount",
    )
    amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Total invoice amount",
    )
    amount_paid: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Amount already paid",
    )
    amount_due: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Remaining amount due",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="ISO 4217 currency code",
    )

    status: InvoiceStatus = Field(
        default=InvoiceStatus.DRAFT,
        description="Invoice status",
    )

    # Access URLs
    invoice_url: Optional[HttpUrl] = Field(
        None, description="URL to view/download invoice"
    )
    payment_url: Optional[HttpUrl] = Field(
        None, description="URL to pay invoice online"
    )

    # Metadata
    notes: Optional[str] = Field(None, description="Invoice notes")

    @model_validator(mode="after")
    def validate_invoice_dates_and_amounts(self) -> "InvoiceInfo":
        """Validate invoice date relationships and amount calculations."""
        if self.due_date < self.invoice_date:
            raise ValueError("due_date cannot be before invoice_date")

        # Validate amount calculation
        expected_amount = self.subtotal - self.discount_amount + self.tax_amount
        if abs(self.amount - expected_amount) > Decimal("0.01"):
            raise ValueError(
                f"amount ({self.amount}) does not match calculated total ({expected_amount})"
            )

        # Validate amount_due
        expected_due = self.amount - self.amount_paid
        if abs(self.amount_due - expected_due) > Decimal("0.01"):
            raise ValueError(
                f"amount_due ({self.amount_due}) does not match outstanding ({expected_due})"
            )

        return self

    @property
    def is_overdue(self) -> bool:
        """Check if invoice is overdue based on current date."""
        from datetime import date as date_type
        return (
            self.status not in (InvoiceStatus.PAID, InvoiceStatus.CANCELLED)
            and date_type.today() > self.due_date
        )

    @property
    def is_fully_paid(self) -> bool:
        """Check if invoice is fully paid."""
        return self.amount_due <= Decimal("0")

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\subscription\subscription_cancellation.py ---
# --- File: app/schemas/subscription/subscription_cancellation.py ---
"""
Subscription cancellation schemas.

Handles subscription cancellation requests, processing,
and response tracking.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Optional
from uuid import UUID

from pydantic import Field, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "CancellationRequest",
    "CancellationResponse",
    "CancellationPreview",
]


class CancellationRequest(BaseCreateSchema):
    """
    Request to cancel a subscription.

    Supports both immediate cancellation and end-of-term cancellation
    with required reason tracking.
    """

    subscription_id: UUID = Field(
        ..., description="Subscription ID to cancel"
    )
    hostel_id: UUID = Field(
        ..., description="Hostel ID for verification"
    )

    cancellation_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for cancellation",
    )
    cancellation_category: Optional[str] = Field(
        None,
        max_length=50,
        description="Cancellation category (e.g., 'pricing', 'features', 'switching')",
    )

    cancel_immediately: bool = Field(
        default=False,
        description="Cancel immediately vs at end of current term",
    )

    # Optional feedback
    feedback: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional feedback for improvement",
    )
    would_recommend: Optional[bool] = Field(
        None, description="Would recommend to others"
    )

    @model_validator(mode="after")
    def validate_cancellation_reason(self) -> "CancellationRequest":
        """Validate cancellation reason is meaningful."""
        reason_words = len(self.cancellation_reason.split())
        if reason_words < 3:
            raise ValueError(
                "cancellation_reason must contain at least 3 words"
            )
        return self


class CancellationPreview(BaseSchema):
    """
    Preview of cancellation impact.

    Shows what will happen if the cancellation proceeds,
    including refund calculations and effective dates.
    """

    subscription_id: UUID = Field(..., description="Subscription ID")
    hostel_id: UUID = Field(..., description="Hostel ID")

    current_plan_name: str = Field(..., description="Current plan name")
    billing_cycle: str = Field(..., description="Current billing cycle")

    # Dates
    cancellation_effective_date: date = Field(
        ..., description="When cancellation takes effect"
    )
    current_period_end: date = Field(
        ..., description="Current billing period end date"
    )
    days_remaining: int = Field(
        ...,
        ge=0,
        description="Days remaining in current period",
    )

    # Financial impact
    refund_eligible: bool = Field(
        ..., description="Whether eligible for refund"
    )
    refund_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Calculated refund amount",
    )
    currency: str = Field(default="INR")

    # Warnings
    warnings: list[str] = Field(
        default_factory=list,
        description="Warnings about cancellation impact",
    )

    # Access impact
    access_ends_at: datetime = Field(
        ..., description="When service access ends"
    )


# Import Decimal for CancellationPreview
from decimal import Decimal


class CancellationResponse(BaseSchema):
    """
    Cancellation confirmation response.

    Confirms the cancellation was processed and provides
    all relevant details about the cancellation.
    """

    subscription_id: UUID = Field(..., description="Cancelled subscription ID")
    hostel_id: UUID = Field(..., description="Hostel ID")

    cancelled: bool = Field(
        ..., description="Whether cancellation was successful"
    )
    cancellation_effective_date: date = Field(
        ..., description="Date when cancellation takes effect"
    )
    cancelled_at: datetime = Field(
        ..., description="Timestamp when cancellation was processed"
    )
    cancelled_by: UUID = Field(
        ..., description="User ID who initiated cancellation"
    )

    # Refund info
    refund_issued: bool = Field(
        default=False, description="Whether refund was issued"
    )
    refund_amount: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Refund amount if applicable",
    )
    refund_reference: Optional[str] = Field(
        None,
        max_length=100,
        description="Refund transaction reference",
    )

    message: str = Field(..., description="Confirmation message")

    # Next steps
    reactivation_eligible: bool = Field(
        default=True,
        description="Whether subscription can be reactivated",
    )
    reactivation_deadline: Optional[date] = Field(
        None, description="Deadline to reactivate subscription"
    )

    @model_validator(mode="after")
    def validate_refund_fields(self) -> "CancellationResponse":
        """Validate refund fields consistency."""
        if self.refund_issued:
            if self.refund_amount is None or self.refund_amount <= Decimal("0"):
                raise ValueError(
                    "refund_amount must be positive when refund_issued is True"
                )
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\subscription\subscription_plan_base.py ---
# --- File: app/schemas/subscription/subscription_plan_base.py ---
"""
Subscription plan definition schemas.

Defines the structure for subscription plans including pricing,
features, limits, and configuration options.
"""

from __future__ import annotations

from decimal import Decimal
from typing import Any, Dict, List, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import SubscriptionPlan

__all__ = [
    "SubscriptionPlanBase",
    "PlanCreate",
    "PlanUpdate",
    "PlanFeatureConfig",
]


class PlanFeatureConfig(BaseSchema):
    """
    Configuration for a single plan feature.

    Provides structured feature definition with value,
    display label, and enablement status.
    """

    key: str = Field(..., description="Feature identifier key")
    label: str = Field(..., description="Human-readable feature label")
    value: Any = Field(..., description="Feature value")
    enabled: bool = Field(default=True, description="Feature enabled status")
    description: Optional[str] = Field(
        None, description="Feature description"
    )


class SubscriptionPlanBase(BaseSchema):
    """
    Base subscription plan schema.

    Contains all fields that define a subscription plan including
    identification, pricing, features, and limits.
    """

    plan_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        pattern=r"^[a-z][a-z0-9_]*$",
        description="Plan internal identifier (lowercase, underscores)",
    )
    display_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Plan display name for UI",
    )
    plan_type: SubscriptionPlan = Field(
        ..., description="Plan tier/type"
    )

    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Plan description",
    )
    short_description: Optional[str] = Field(
        None,
        max_length=200,
        description="Short description for cards/listings",
    )

    # Pricing
    price_monthly: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Monthly subscription price",
    )
    price_yearly: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Yearly subscription price",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="ISO 4217 currency code",
    )

    # Features as structured dict
    features: Dict[str, Any] = Field(
        default_factory=dict,
        description="Feature flags and configurations",
    )

    # Usage limits
    max_hostels: Optional[int] = Field(
        None,
        ge=1,
        description="Maximum number of hostels (None = unlimited)",
    )
    max_rooms_per_hostel: Optional[int] = Field(
        None,
        ge=1,
        description="Maximum rooms per hostel (None = unlimited)",
    )
    max_students: Optional[int] = Field(
        None,
        ge=1,
        description="Maximum total students (None = unlimited)",
    )
    max_admins: Optional[int] = Field(
        None,
        ge=1,
        description="Maximum admin users (None = unlimited)",
    )

    # Status and display
    is_active: bool = Field(
        default=True, description="Plan is available for new subscriptions"
    )
    is_public: bool = Field(
        default=True, description="Show on public pricing page"
    )
    is_featured: bool = Field(
        default=False, description="Highlight as featured/recommended plan"
    )
    sort_order: int = Field(
        default=0, description="Display ordering (lower = first)"
    )

    # Trial configuration
    trial_days: int = Field(
        default=0,
        ge=0,
        le=90,
        description="Trial period in days (0 = no trial)",
    )

    @model_validator(mode="after")
    def validate_pricing(self) -> "SubscriptionPlanBase":
        """Validate pricing logic."""
        # Yearly price should typically be discounted vs 12x monthly
        yearly_monthly_equivalent = self.price_monthly * 12
        if self.price_yearly > yearly_monthly_equivalent:
            raise ValueError(
                "price_yearly should not exceed 12x price_monthly"
            )
        return self

    @field_validator("plan_name")
    @classmethod
    def normalize_plan_name(cls, v: str) -> str:
        """Normalize plan name to lowercase."""
        return v.lower().strip()

    @property
    def yearly_savings(self) -> Decimal:
        """Calculate yearly savings compared to monthly billing."""
        monthly_yearly = self.price_monthly * 12
        return (monthly_yearly - self.price_yearly).quantize(Decimal("0.01"))

    @property
    def yearly_discount_percent(self) -> Decimal:
        """Calculate yearly discount percentage."""
        if self.price_monthly == Decimal("0"):
            return Decimal("0")
        monthly_yearly = self.price_monthly * 12
        if monthly_yearly == Decimal("0"):
            return Decimal("0")
        discount = (
            (monthly_yearly - self.price_yearly) / monthly_yearly * 100
        )
        return discount.quantize(Decimal("0.01"))


class PlanCreate(SubscriptionPlanBase, BaseCreateSchema):
    """
    Create new subscription plan.

    Inherits all fields from SubscriptionPlanBase for plan creation.
    """

    # Additional creation-specific fields
    created_by: Optional[str] = Field(
        None, description="Admin user who created the plan"
    )

    @field_validator("features")
    @classmethod
    def validate_features(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        """Validate feature dictionary structure."""
        if not isinstance(v, dict):
            raise ValueError("features must be a dictionary")
        return v


class PlanUpdate(BaseUpdateSchema):
    """
    Update subscription plan.

    All fields are optional to support partial updates.
    """

    display_name: Optional[str] = Field(
        None,
        min_length=3,
        max_length=100,
        description="Updated display name",
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Updated description",
    )
    short_description: Optional[str] = Field(
        None,
        max_length=200,
        description="Updated short description",
    )

    # Pricing updates
    price_monthly: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Updated monthly price",
    )
    price_yearly: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Updated yearly price",
    )
    currency: Optional[str] = Field(
        None,
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="Updated currency",
    )

    # Feature updates
    features: Optional[Dict[str, Any]] = Field(
        None, description="Updated features"
    )

    # Limit updates
    max_hostels: Optional[int] = Field(None, ge=1)
    max_rooms_per_hostel: Optional[int] = Field(None, ge=1)
    max_students: Optional[int] = Field(None, ge=1)
    max_admins: Optional[int] = Field(None, ge=1)

    # Status updates
    is_active: Optional[bool] = Field(None)
    is_public: Optional[bool] = Field(None)
    is_featured: Optional[bool] = Field(None)
    sort_order: Optional[int] = Field(None)

    # Trial updates
    trial_days: Optional[int] = Field(None, ge=0, le=90)

    @model_validator(mode="after")
    def validate_pricing_update(self) -> "PlanUpdate":
        """Validate pricing updates if both provided."""
        if self.price_monthly is not None and self.price_yearly is not None:
            yearly_monthly_equivalent = self.price_monthly * 12
            if self.price_yearly > yearly_monthly_equivalent:
                raise ValueError(
                    "price_yearly should not exceed 12x price_monthly"
                )
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\subscription\subscription_plan_response.py ---
# --- File: app/schemas/subscription/subscription_plan_response.py ---
"""
Subscription plan response and comparison schemas.

Provides structured responses for plan details, feature listings,
and plan comparison functionality.
"""

from __future__ import annotations

from decimal import Decimal
from typing import Any, Dict, List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import SubscriptionPlan

__all__ = [
    "PlanResponse",
    "PlanFeatures",
    "PlanComparison",
    "PlanSummary",
]


class PlanResponse(BaseResponseSchema):
    """
    Complete subscription plan response.

    Returns all plan details including pricing, features,
    limits, and computed properties.
    """

    plan_name: str = Field(..., description="Plan internal identifier")
    display_name: str = Field(..., description="Plan display name")
    plan_type: SubscriptionPlan = Field(..., description="Plan tier")

    description: Optional[str] = Field(None, description="Full description")
    short_description: Optional[str] = Field(
        None, description="Short description"
    )

    # Pricing
    price_monthly: Decimal = Field(..., description="Monthly price")
    price_yearly: Decimal = Field(..., description="Yearly price")
    currency: str = Field(..., description="Currency code")

    # Features
    features: Dict[str, Any] = Field(
        default_factory=dict, description="Feature configuration"
    )

    # Limits
    max_hostels: Optional[int] = Field(None, description="Max hostels")
    max_rooms_per_hostel: Optional[int] = Field(
        None, description="Max rooms per hostel"
    )
    max_students: Optional[int] = Field(None, description="Max students")
    max_admins: Optional[int] = Field(None, description="Max admin users")

    # Status
    is_active: bool = Field(..., description="Plan is active")
    is_public: bool = Field(..., description="Visible on pricing page")
    is_featured: bool = Field(
        default=False, description="Featured/recommended plan"
    )
    sort_order: int = Field(..., description="Display order")

    # Trial
    trial_days: int = Field(default=0, description="Trial period days")

    @computed_field
    @property
    def price_monthly_formatted(self) -> str:
        """Format monthly price with currency."""
        return f"{self.currency} {self.price_monthly:,.2f}"

    @computed_field
    @property
    def price_yearly_formatted(self) -> str:
        """Format yearly price with currency."""
        return f"{self.currency} {self.price_yearly:,.2f}"

    @computed_field
    @property
    def yearly_savings(self) -> Decimal:
        """Calculate yearly savings vs monthly billing."""
        return (self.price_monthly * 12 - self.price_yearly).quantize(
            Decimal("0.01")
        )

    @computed_field
    @property
    def yearly_discount_percent(self) -> Decimal:
        """Calculate yearly discount percentage."""
        if self.price_monthly == Decimal("0"):
            return Decimal("0")
        monthly_yearly = self.price_monthly * 12
        if monthly_yearly == Decimal("0"):
            return Decimal("0")
        return (
            (monthly_yearly - self.price_yearly) / monthly_yearly * 100
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def has_trial(self) -> bool:
        """Check if plan offers trial."""
        return self.trial_days > 0

    @computed_field
    @property
    def limits_display(self) -> Dict[str, str]:
        """Format limits for display."""
        return {
            "hostels": str(self.max_hostels) if self.max_hostels else "Unlimited",
            "rooms_per_hostel": (
                str(self.max_rooms_per_hostel)
                if self.max_rooms_per_hostel
                else "Unlimited"
            ),
            "students": str(self.max_students) if self.max_students else "Unlimited",
            "admins": str(self.max_admins) if self.max_admins else "Unlimited",
        }


class PlanSummary(BaseSchema):
    """
    Condensed plan summary for listings.

    Provides essential plan information for cards and lists.
    """

    id: str = Field(..., description="Plan ID")
    plan_name: str = Field(..., description="Plan identifier")
    display_name: str = Field(..., description="Display name")
    plan_type: SubscriptionPlan = Field(..., description="Plan tier")

    price_monthly: Decimal = Field(..., description="Monthly price")
    price_yearly: Decimal = Field(..., description="Yearly price")
    currency: str = Field(..., description="Currency")

    short_description: Optional[str] = Field(None)
    is_featured: bool = Field(default=False)
    trial_days: int = Field(default=0)


class PlanFeatures(BaseSchema):
    """
    Human-friendly plan feature matrix.

    Formats features for display in comparison tables
    and feature lists.
    """

    plan_name: str = Field(..., description="Plan identifier")
    display_name: str = Field(..., description="Plan display name")
    plan_type: SubscriptionPlan = Field(..., description="Plan tier")

    # Feature categories with human-readable values
    features: Dict[str, str] = Field(
        ...,
        description="Feature key to display value mapping",
    )
    feature_categories: Dict[str, List[str]] = Field(
        default_factory=dict,
        description="Category to feature keys mapping",
    )

    # Highlight features
    highlight_features: List[str] = Field(
        default_factory=list,
        description="Key features to highlight",
    )

    @classmethod
    def from_plan_response(
        cls,
        plan: PlanResponse,
        feature_labels: Dict[str, str],
    ) -> "PlanFeatures":
        """
        Create PlanFeatures from PlanResponse.

        Args:
            plan: The plan response to convert.
            feature_labels: Mapping of feature keys to display labels.

        Returns:
            PlanFeatures instance with formatted features.
        """
        formatted_features = {}
        for key, value in plan.features.items():
            label = feature_labels.get(key, key.replace("_", " ").title())
            if isinstance(value, bool):
                formatted_features[label] = "" if value else ""
            elif value is None:
                formatted_features[label] = "Unlimited"
            else:
                formatted_features[label] = str(value)

        return cls(
            plan_name=plan.plan_name,
            display_name=plan.display_name,
            plan_type=plan.plan_type,
            features=formatted_features,
        )


class PlanComparison(BaseSchema):
    """
    Compare multiple plans side by side.

    Provides a structured comparison matrix for displaying
    multiple plans with their features.
    """

    plans: List[PlanResponse] = Field(
        ...,
        min_length=2,
        description="Plans to compare",
    )
    feature_matrix: Dict[str, Dict[str, Any]] = Field(
        ...,
        description="Feature key -> plan_name -> value matrix",
    )
    feature_order: List[str] = Field(
        default_factory=list,
        description="Ordered list of feature keys for display",
    )
    category_order: List[str] = Field(
        default_factory=list,
        description="Ordered list of feature categories",
    )

    # Recommendations
    recommended_plan: Optional[str] = Field(
        None, description="Recommended plan name"
    )
    recommendation_reason: Optional[str] = Field(
        None, description="Reason for recommendation"
    )

    @classmethod
    def create(
        cls,
        plans: List[PlanResponse],
        feature_order: Optional[List[str]] = None,
    ) -> "PlanComparison":
        """
        Create comparison from list of plans.

        Args:
            plans: List of plans to compare.
            feature_order: Optional ordered list of features to include.

        Returns:
            PlanComparison instance with feature matrix.
        """
        # Build feature matrix
        all_features: set = set()
        for plan in plans:
            all_features.update(plan.features.keys())

        # Use provided order or alphabetical
        ordered_features = feature_order or sorted(all_features)

        feature_matrix: Dict[str, Dict[str, Any]] = {}
        for feature in ordered_features:
            feature_matrix[feature] = {}
            for plan in plans:
                feature_matrix[feature][plan.plan_name] = plan.features.get(
                    feature
                )

        # Add limit comparisons
        limit_features = ["max_hostels", "max_rooms_per_hostel", "max_students"]
        for limit in limit_features:
            feature_matrix[limit] = {}
            for plan in plans:
                feature_matrix[limit][plan.plan_name] = getattr(plan, limit)

        # Find featured plan as recommended
        recommended = next(
            (p.plan_name for p in plans if p.is_featured), None
        )

        return cls(
            plans=plans,
            feature_matrix=feature_matrix,
            feature_order=ordered_features + limit_features,
            recommended_plan=recommended,
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\subscription\subscription_response.py ---
# --- File: app/schemas/subscription/subscription_response.py ---
"""
Subscription response schemas.

Provides comprehensive response structures for subscription
data, billing history, and subscription summaries.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, HttpUrl, computed_field, model_validator

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import (
    BillingCycle,
    SubscriptionPlan,
    SubscriptionStatus,
)

__all__ = [
    "SubscriptionResponse",
    "SubscriptionSummary",
    "BillingHistoryItem",
    "BillingHistory",
]


class SubscriptionResponse(BaseResponseSchema):
    """
    Complete hostel subscription response.

    Returns all subscription details including plan information,
    billing details, and current status.
    """

    # Hostel info
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")

    # Plan info
    plan_id: UUID = Field(..., description="Subscription plan ID")
    plan_name: str = Field(..., description="Plan internal name")
    display_name: str = Field(..., description="Plan display name")
    plan_type: SubscriptionPlan = Field(..., description="Plan tier")

    # Subscription details
    subscription_reference: str = Field(
        ..., description="Unique subscription reference"
    )
    billing_cycle: BillingCycle = Field(..., description="Billing cycle")
    amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Billing amount",
    )
    currency: str = Field(default="INR", description="Currency code")

    # Dates
    start_date: date = Field(..., description="Subscription start date")
    end_date: date = Field(..., description="Subscription end date")
    auto_renew: bool = Field(..., description="Auto-renewal enabled")
    next_billing_date: Optional[date] = Field(
        None, description="Next billing date"
    )
    status: SubscriptionStatus = Field(..., description="Current status")

    # Trial info
    trial_end_date: Optional[date] = Field(
        None, description="Trial period end date"
    )
    is_in_trial: bool = Field(
        default=False, description="Currently in trial period"
    )

    # Payment info
    last_payment_date: Optional[date] = Field(
        None, description="Last payment date"
    )
    last_payment_amount: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Last payment amount",
    )

    # Cancellation info (if applicable)
    cancelled_at: Optional[datetime] = Field(
        None, description="Cancellation timestamp"
    )
    cancellation_effective_date: Optional[date] = Field(
        None, description="When cancellation takes effect"
    )

    @computed_field
    @property
    def days_until_expiry(self) -> int:
        """Calculate days until subscription expires."""
        today = date.today()
        if self.end_date < today:
            return 0
        return (self.end_date - today).days

    @computed_field
    @property
    def days_until_billing(self) -> Optional[int]:
        """Calculate days until next billing."""
        if self.next_billing_date is None:
            return None
        today = date.today()
        if self.next_billing_date < today:
            return 0
        return (self.next_billing_date - today).days

    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if subscription is currently active."""
        return self.status == SubscriptionStatus.ACTIVE

    @computed_field
    @property
    def is_expiring_soon(self) -> bool:
        """Check if subscription expires within 7 days."""
        return 0 < self.days_until_expiry <= 7

    @computed_field
    @property
    def amount_formatted(self) -> str:
        """Format amount with currency."""
        cycle_label = "mo" if self.billing_cycle == BillingCycle.MONTHLY else "yr"
        return f"{self.currency} {self.amount:,.2f}/{cycle_label}"


class SubscriptionSummary(BaseSchema):
    """
    Condensed subscription summary for listings.

    Provides essential subscription information for dashboards
    and list views.
    """

    id: str = Field(..., description="Subscription ID")
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")

    plan_name: str = Field(..., description="Plan name")
    plan_type: SubscriptionPlan = Field(..., description="Plan tier")
    status: SubscriptionStatus = Field(..., description="Status")

    billing_cycle: BillingCycle = Field(..., description="Billing cycle")
    amount: Decimal = Field(..., description="Billing amount")
    currency: str = Field(default="INR")

    end_date: date = Field(..., description="Expiry date")
    auto_renew: bool = Field(..., description="Auto-renewal status")

    is_in_trial: bool = Field(default=False)
    days_until_expiry: int = Field(..., description="Days until expiry")


class BillingHistoryItem(BaseSchema):
    """
    Single billing event in history.

    Represents one billing transaction with all relevant details.
    """

    id: Optional[UUID] = Field(None, description="Transaction ID")
    billing_date: date = Field(..., description="Billing date")

    # Amounts
    amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Billed amount",
    )
    currency: str = Field(default="INR", description="Currency code")

    # Status and references
    status: str = Field(
        ...,
        description="Payment status (pending, paid, failed, refunded)",
    )
    payment_reference: Optional[str] = Field(
        None,
        max_length=100,
        description="Payment transaction reference",
    )
    payment_method: Optional[str] = Field(
        None, description="Payment method used"
    )

    # Invoice
    invoice_number: Optional[str] = Field(
        None, description="Associated invoice number"
    )
    invoice_url: Optional[HttpUrl] = Field(
        None, description="Invoice download URL"
    )

    # Description
    description: Optional[str] = Field(
        None,
        max_length=255,
        description="Billing description",
    )

    # Period covered
    period_start: Optional[date] = Field(
        None, description="Billing period start"
    )
    period_end: Optional[date] = Field(
        None, description="Billing period end"
    )

    @computed_field
    @property
    def is_paid(self) -> bool:
        """Check if billing item is paid."""
        return self.status.lower() == "paid"


class BillingHistory(BaseSchema):
    """
    Complete subscription billing history.

    Aggregates all billing events with summary statistics.
    """

    subscription_id: UUID = Field(..., description="Subscription ID")
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: Optional[str] = Field(None, description="Hostel name")

    # Billing items
    items: List[BillingHistoryItem] = Field(
        default_factory=list,
        description="List of billing events",
    )

    # Summary totals
    total_billed: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Total amount billed",
    )
    total_paid: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Total amount paid",
    )
    total_outstanding: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Outstanding amount",
    )
    total_refunded: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Total refunded amount",
    )

    currency: str = Field(default="INR", description="Currency code")

    # Pagination info
    total_count: int = Field(
        default=0, ge=0, description="Total billing events"
    )
    page: int = Field(default=1, ge=1, description="Current page")
    page_size: int = Field(default=20, ge=1, description="Page size")

    @model_validator(mode="after")
    def validate_totals(self) -> "BillingHistory":
        """Validate total calculations."""
        expected_outstanding = self.total_billed - self.total_paid - self.total_refunded
        if expected_outstanding < Decimal("0"):
            expected_outstanding = Decimal("0")

        # Allow small floating point differences
        if abs(self.total_outstanding - expected_outstanding) > Decimal("0.01"):
            raise ValueError(
                f"total_outstanding ({self.total_outstanding}) does not match "
                f"calculated value ({expected_outstanding})"
            )
        return self

    @computed_field
    @property
    def has_outstanding(self) -> bool:
        """Check if there's outstanding balance."""
        return self.total_outstanding > Decimal("0")

    @computed_field
    @property
    def payment_rate(self) -> Decimal:
        """Calculate payment collection rate percentage."""
        if self.total_billed == Decimal("0"):
            return Decimal("100.00")
        return (
            (self.total_paid + self.total_refunded) / self.total_billed * 100
        ).quantize(Decimal("0.01"))

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\subscription\subscription_upgrade.py ---
# --- File: app/schemas/subscription/subscription_upgrade.py ---
"""
Subscription upgrade/downgrade schemas.

Handles plan change requests, previews, and confirmations
for subscription modifications.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from enum import Enum
from typing import List, Optional
from uuid import UUID

from pydantic import Field, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import BillingCycle

__all__ = [
    "PlanChangeType",
    "PlanChangeRequest",
    "PlanChangePreview",
    "PlanChangeConfirmation",
]


class PlanChangeType(str, Enum):
    """Type of plan change."""

    UPGRADE = "upgrade"
    DOWNGRADE = "downgrade"
    LATERAL = "lateral"  # Same tier, different billing cycle


class PlanChangeRequest(BaseCreateSchema):
    """
    Request to change subscription plan.

    Supports upgrades, downgrades, and billing cycle changes
    with configurable timing and proration.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    current_plan_id: UUID = Field(
        ..., description="Current subscription plan ID"
    )
    new_plan_id: UUID = Field(..., description="Target plan ID")
    billing_cycle: BillingCycle = Field(
        ..., description="Billing cycle for new plan"
    )

    # Timing
    effective_from: date = Field(
        ..., description="When new plan takes effect"
    )
    prorate: bool = Field(
        default=True,
        description="Apply proration for partial periods",
    )

    # Options
    apply_credit: bool = Field(
        default=True,
        description="Apply unused balance as credit",
    )
    preserve_trial: bool = Field(
        default=False,
        description="Preserve remaining trial days if applicable",
    )

    # Reason tracking
    change_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for plan change",
    )

    @model_validator(mode="after")
    def validate_plan_change(self) -> "PlanChangeRequest":
        """Validate plan change request."""
        if self.current_plan_id == self.new_plan_id:
            raise ValueError(
                "new_plan_id must be different from current_plan_id"
            )

        today = date.today()
        if self.effective_from < today:
            raise ValueError("effective_from cannot be in the past")

        return self


class PlanChangePreview(BaseSchema):
    """
    Preview cost impact of plan change.

    Shows detailed financial impact including prorations,
    credits, and final amounts before confirming the change.
    """

    # Plan info
    current_plan_id: UUID = Field(..., description="Current plan ID")
    current_plan_name: str = Field(..., description="Current plan name")
    current_plan_display: str = Field(
        ..., description="Current plan display name"
    )

    new_plan_id: UUID = Field(..., description="New plan ID")
    new_plan_name: str = Field(..., description="New plan name")
    new_plan_display: str = Field(..., description="New plan display name")

    # Change type
    change_type: PlanChangeType = Field(
        ..., description="Type of plan change"
    )

    # Pricing
    current_amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Current plan amount",
    )
    new_amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="New plan amount",
    )
    currency: str = Field(default="INR", description="Currency code")

    # Current period info
    current_period_start: date = Field(
        ..., description="Current billing period start"
    )
    current_period_end: date = Field(
        ..., description="Current billing period end"
    )
    days_remaining: int = Field(
        ...,
        ge=0,
        description="Days remaining in current period",
    )

    # Proration calculations
    prorated_credit: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Credit for unused portion of current plan",
    )
    prorated_charge: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Charge for new plan (prorated if applicable)",
    )

    # Final amounts
    amount_due_now: Decimal = Field(
        ...,
        decimal_places=2,
        description="Net amount due now (can be negative for credit)",
    )
    next_billing_amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Amount on next regular billing",
    )

    # Dates
    effective_from: date = Field(
        ..., description="When change takes effect"
    )
    next_billing_date: date = Field(
        ..., description="Next billing date after change"
    )

    # Additional info
    message: str = Field(..., description="Summary message")
    warnings: List[str] = Field(
        default_factory=list,
        description="Warnings about the plan change",
    )
    benefits: List[str] = Field(
        default_factory=list,
        description="Benefits of the new plan",
    )

    @computed_field
    @property
    def is_upgrade(self) -> bool:
        """Check if this is an upgrade."""
        return self.change_type == PlanChangeType.UPGRADE

    @computed_field
    @property
    def is_downgrade(self) -> bool:
        """Check if this is a downgrade."""
        return self.change_type == PlanChangeType.DOWNGRADE

    @computed_field
    @property
    def monthly_difference(self) -> Decimal:
        """Calculate monthly price difference."""
        return (self.new_amount - self.current_amount).quantize(
            Decimal("0.01")
        )

    @computed_field
    @property
    def savings_or_increase(self) -> str:
        """Format savings or increase message."""
        diff = self.monthly_difference
        if diff > Decimal("0"):
            return f"+{self.currency} {diff:,.2f}/period"
        elif diff < Decimal("0"):
            return f"-{self.currency} {abs(diff):,.2f}/period"
        return "No change"


# Import computed_field for PlanChangePreview
from pydantic import computed_field


class PlanChangeConfirmation(BaseSchema):
    """
    Confirmation of completed plan change.

    Returned after a plan change is successfully processed.
    """

    subscription_id: UUID = Field(..., description="Updated subscription ID")
    hostel_id: UUID = Field(..., description="Hostel ID")

    # Change details
    previous_plan_id: UUID = Field(..., description="Previous plan ID")
    previous_plan_name: str = Field(..., description="Previous plan name")
    new_plan_id: UUID = Field(..., description="New plan ID")
    new_plan_name: str = Field(..., description="New plan name")
    change_type: PlanChangeType = Field(..., description="Type of change")

    # Financial
    amount_charged: Decimal = Field(
        default=Decimal("0.00"),
        decimal_places=2,
        description="Amount charged for the change",
    )
    credit_applied: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Credit applied from previous plan",
    )
    currency: str = Field(default="INR")

    # Dates
    effective_from: date = Field(
        ..., description="When change took effect"
    )
    next_billing_date: date = Field(..., description="Next billing date")
    new_billing_amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="New regular billing amount",
    )

    # Confirmation
    processed_at: datetime = Field(
        ..., description="When change was processed"
    )
    confirmation_number: str = Field(
        ..., description="Change confirmation reference"
    )
    message: str = Field(..., description="Confirmation message")


# Import datetime for PlanChangeConfirmation
from datetime import datetime

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\subscription\__init__.py ---
# --- File: app/schemas/subscription/__init__.py ---
"""
Subscription schemas package.

This module provides comprehensive schemas for:
- Subscription plans (definition, pricing, features)
- Hostel subscriptions (lifecycle management)
- Billing and invoicing
- Plan upgrades/downgrades
- Commission tracking
"""

from __future__ import annotations

# Commission schemas
from app.schemas.subscription.commission import (
    BookingCommissionResponse,
    CommissionConfig,
    CommissionStatus,
    CommissionSummary,
)

# Base subscription schemas
from app.schemas.subscription.subscription_base import (
    SubscriptionBase,
    SubscriptionCreate,
    SubscriptionUpdate,
)

# Billing schemas
from app.schemas.subscription.subscription_billing import (
    BillingCycleInfo,
    GenerateInvoiceRequest,
    InvoiceInfo,
    InvoiceStatus,
)

# Cancellation schemas
from app.schemas.subscription.subscription_cancellation import (
    CancellationRequest,
    CancellationResponse,
)

# Plan definition schemas
from app.schemas.subscription.subscription_plan_base import (
    PlanCreate,
    PlanUpdate,
    SubscriptionPlanBase,
)

# Plan response schemas
from app.schemas.subscription.subscription_plan_response import (
    PlanComparison,
    PlanFeatures,
    PlanResponse,
)

# Subscription response schemas
from app.schemas.subscription.subscription_response import (
    BillingHistory,
    BillingHistoryItem,
    SubscriptionResponse,
    SubscriptionSummary,
)

# Upgrade/downgrade schemas
from app.schemas.subscription.subscription_upgrade import (
    PlanChangeRequest,
    PlanChangePreview,
    PlanChangeType,
)

__all__ = [
    # Enums
    "CommissionStatus",
    "InvoiceStatus",
    "PlanChangeType",
    # Commission
    "CommissionConfig",
    "BookingCommissionResponse",
    "CommissionSummary",
    # Subscription base
    "SubscriptionBase",
    "SubscriptionCreate",
    "SubscriptionUpdate",
    # Billing
    "BillingCycleInfo",
    "GenerateInvoiceRequest",
    "InvoiceInfo",
    # Cancellation
    "CancellationRequest",
    "CancellationResponse",
    # Plan base
    "SubscriptionPlanBase",
    "PlanCreate",
    "PlanUpdate",
    # Plan response
    "PlanResponse",
    "PlanFeatures",
    "PlanComparison",
    # Subscription response
    "SubscriptionResponse",
    "SubscriptionSummary",
    "BillingHistoryItem",
    "BillingHistory",
    # Upgrade/downgrade
    "PlanChangeRequest",
    "PlanChangePreview",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_activity.py ---
# --- File: app/schemas/supervisor/supervisor_activity.py ---
"""
Supervisor activity and audit log schemas with enhanced tracking.

Provides comprehensive activity monitoring, audit trails, and
performance analytics with optimized filtering and export capabilities.
"""

from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseFilterSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import AuditActionCategory
from app.schemas.common.filters import DateTimeRangeFilter

__all__ = [
    "SupervisorActivityLog",
    "ActivityDetail",
    "ActivitySummary",
    "ActivityFilterParams",
    "ActivityExportRequest",
    "TopActivity",
    "ActivityTimelinePoint",
    "ActivityMetrics",
]


class SupervisorActivityLog(BaseResponseSchema):
    """
    Supervisor activity log entry with enhanced metadata.
    
    Tracks all supervisor actions with context and performance data.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Action details
    action_type: str = Field(
        ...,
        description="Specific action performed",
        examples=[
            "complaint_resolved",
            "attendance_marked",
            "maintenance_created",
            "announcement_published",
        ],
    )
    action_category: AuditActionCategory = Field(
        ...,
        description="Action category for grouping",
    )
    action_description: str = Field(
        ...,
        description="Human-readable description",
    )
    
    # Entity affected
    entity_type: Optional[str] = Field(
        default=None,
        description="Type of entity affected",
        examples=["complaint", "student", "room", "maintenance_request"],
    )
    entity_id: Optional[str] = Field(
        default=None,
        description="ID of affected entity",
    )
    entity_name: Optional[str] = Field(
        default=None,
        description="Name/title of affected entity",
    )
    
    # Context and metadata
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional action details and context",
    )
    
    # Technical details
    ip_address: Optional[str] = Field(
        default=None,
        description="IP address of action origin",
    )
    user_agent: Optional[str] = Field(
        default=None,
        description="User agent string",
    )
    device_type: Optional[str] = Field(
        default=None,
        description="Device type (mobile/desktop/tablet)",
    )
    
    # Performance tracking
    response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Action response time in milliseconds",
    )
    success: bool = Field(
        default=True,
        description="Whether action completed successfully",
    )
    error_message: Optional[str] = Field(
        default=None,
        description="Error message if action failed",
    )

    @computed_field
    @property
    def action_display_name(self) -> str:
        """Get human-readable action name."""
        action_names = {
            "complaint_resolved": "Resolved Complaint",
            "complaint_assigned": "Assigned Complaint",
            "attendance_marked": "Marked Attendance",
            "leave_approved": "Approved Leave",
            "maintenance_created": "Created Maintenance Request",
            "maintenance_assigned": "Assigned Maintenance",
            "announcement_published": "Published Announcement",
            "student_contacted": "Contacted Student",
            "room_status_updated": "Updated Room Status",
            "menu_updated": "Updated Menu",
        }
        return action_names.get(self.action_type, self.action_type.replace("_", " ").title())


class ActivityDetail(BaseSchema):
    """
    Detailed activity information with change tracking.
    
    Comprehensive activity record with before/after states.
    """

    activity_id: str = Field(..., description="Activity ID")
    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    
    timestamp: datetime = Field(..., description="Activity timestamp")
    action_type: str = Field(..., description="Action type")
    action_category: AuditActionCategory = Field(..., description="Action category")
    action_description: str = Field(..., description="Action description")
    
    # Entity details
    entity_type: Optional[str] = Field(default=None, description="Entity type")
    entity_id: Optional[str] = Field(default=None, description="Entity ID")
    entity_name: Optional[str] = Field(default=None, description="Entity name")
    
    # Change tracking
    old_values: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Previous values before change",
    )
    new_values: Optional[Dict[str, Any]] = Field(
        default=None,
        description="New values after change",
    )
    
    # Context
    ip_address: Optional[str] = Field(default=None, description="IP address")
    user_agent: Optional[str] = Field(default=None, description="User agent")
    location: Optional[str] = Field(default=None, description="Geographic location")
    device_info: Optional[Dict[str, str]] = Field(
        default=None,
        description="Device information",
    )
    
    # Result
    success: bool = Field(default=True, description="Action success status")
    error_message: Optional[str] = Field(default=None, description="Error message")
    response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Response time in milliseconds",
    )
    
    # Impact assessment
    impact_level: Optional[str] = Field(
        default=None,
        pattern=r"^(low|medium|high|critical)$",
        description="Impact level of the action",
    )
    affected_users_count: Optional[int] = Field(
        default=None,
        ge=0,
        description="Number of users affected by action",
    )

    @computed_field
    @property
    def has_changes(self) -> bool:
        """Check if activity involved data changes."""
        return bool(self.old_values or self.new_values)

    @computed_field
    @property
    def change_summary(self) -> Optional[str]:
        """Generate summary of changes made."""
        if not self.has_changes:
            return None
        
        if not self.old_values or not self.new_values:
            return "Data modified"
        
        changes = []
        for key in self.new_values:
            if key in self.old_values and self.old_values[key] != self.new_values[key]:
                changes.append(f"{key}: {self.old_values[key]}  {self.new_values[key]}")
        
        return "; ".join(changes) if changes else "No changes detected"


class TopActivity(BaseSchema):
    """
    Top activity item for summary reports.
    
    Represents frequently performed activities.
    """

    action_type: str = Field(..., description="Action type")
    action_category: str = Field(..., description="Action category")
    action_display_name: str = Field(..., description="Human-readable name")
    count: int = Field(..., ge=0, description="Number of times performed")
    last_performed: datetime = Field(..., description="Last time performed")
    average_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Average response time",
    )
    success_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Success rate percentage",
    )

    @computed_field
    @property
    def frequency_description(self) -> str:
        """Get frequency description."""
        if self.count >= 100:
            return "Very Frequent"
        elif self.count >= 50:
            return "Frequent"
        elif self.count >= 20:
            return "Regular"
        elif self.count >= 10:
            return "Occasional"
        else:
            return "Rare"


class ActivityTimelinePoint(BaseSchema):
    """
    Activity timeline data point for trend analysis.
    
    Represents activity volume over time periods.
    """

    timestamp: datetime = Field(..., description="Time period")
    action_count: int = Field(..., ge=0, description="Total actions in period")
    unique_action_types: int = Field(..., ge=0, description="Unique action types")
    success_rate: float = Field(..., ge=0, le=100, description="Success rate %")
    
    # Category breakdown
    categories: Dict[str, int] = Field(
        default_factory=dict,
        description="Action count by category",
    )
    
    # Performance metrics
    average_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Average response time",
    )

    @computed_field
    @property
    def activity_level(self) -> str:
        """Categorize activity level."""
        if self.action_count >= 50:
            return "High"
        elif self.action_count >= 20:
            return "Medium"
        elif self.action_count >= 5:
            return "Low"
        else:
            return "Minimal"


class ActivityMetrics(BaseSchema):
    """
    Comprehensive activity metrics for performance analysis.
    
    Aggregated metrics for supervisor activity assessment.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    period_start: datetime = Field(..., description="Metrics period start")
    period_end: datetime = Field(..., description="Metrics period end")
    
    # Volume metrics
    total_actions: int = Field(..., ge=0, description="Total actions performed")
    unique_action_types: int = Field(..., ge=0, description="Unique action types")
    active_days: int = Field(..., ge=0, description="Days with activity")
    
    # Performance metrics
    overall_success_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Overall success rate percentage",
    )
    average_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Average response time",
    )
    
    # Category distribution
    actions_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Action count by category",
    )
    
    # Peak activity analysis
    peak_hour: Optional[int] = Field(
        default=None,
        ge=0,
        le=23,
        description="Hour with most activity (0-23)",
    )
    peak_day_of_week: Optional[int] = Field(
        default=None,
        ge=0,
        le=6,
        description="Day of week with most activity (0=Monday)",
    )
    
    # Efficiency metrics
    actions_per_day: float = Field(
        ...,
        ge=0,
        description="Average actions per active day",
    )
    response_time_trend: Optional[str] = Field(
        default=None,
        pattern=r"^(improving|stable|declining)$",
        description="Response time trend",
    )

    @computed_field
    @property
    def activity_score(self) -> float:
        """Calculate overall activity score (0-100)."""
        # Weighted scoring based on volume, consistency, and performance
        volume_score = min(self.total_actions / 100 * 40, 40)  # Max 40 points
        consistency_score = min(self.active_days / 30 * 30, 30)  # Max 30 points
        performance_score = self.overall_success_rate * 0.3  # Max 30 points
        
        return round(volume_score + consistency_score + performance_score, 2)

    @computed_field
    @property
    def productivity_level(self) -> str:
        """Categorize productivity level."""
        score = self.activity_score
        if score >= 80:
            return "Excellent"
        elif score >= 60:
            return "Good"
        elif score >= 40:
            return "Average"
        elif score >= 20:
            return "Below Average"
        else:
            return "Poor"


class ActivitySummary(BaseSchema):
    """
    Activity summary for supervisor dashboard.
    
    High-level activity overview with key insights.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    period_start: datetime = Field(..., description="Summary period start")
    period_end: datetime = Field(..., description="Summary period end")
    
    total_actions: int = Field(..., ge=0, description="Total actions")
    
    # Category breakdown
    actions_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of actions by category",
    )
    
    # Type breakdown
    actions_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of actions by type",
    )
    
    # Top activities
    top_activities: List[TopActivity] = Field(
        default_factory=list,
        max_length=10,
        description="Most frequent activities",
    )
    
    # Activity timeline
    activity_timeline: List[ActivityTimelinePoint] = Field(
        default_factory=list,
        description="Activity over time",
    )
    
    # Performance insights
    peak_hours: List[int] = Field(
        default_factory=list,
        description="Hours with most activity (0-23)",
    )
    most_productive_day: Optional[str] = Field(
        default=None,
        description="Day of week with highest activity",
    )
    
    # Efficiency metrics
    average_daily_actions: float = Field(
        ...,
        ge=0,
        description="Average actions per day",
    )
    success_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Overall success rate",
    )

    @computed_field
    @property
    def most_common_activity(self) -> Optional[str]:
        """Get most frequently performed activity."""
        if not self.top_activities:
            return None
        return self.top_activities[0].action_display_name

    @computed_field
    @property
    def activity_consistency(self) -> str:
        """Assess activity consistency."""
        if not self.activity_timeline:
            return "Unknown"
        
        # Calculate coefficient of variation
        counts = [point.action_count for point in self.activity_timeline]
        if not counts:
            return "No Data"
        
        mean_count = sum(counts) / len(counts)
        if mean_count == 0:
            return "No Activity"
        
        variance = sum((x - mean_count) ** 2 for x in counts) / len(counts)
        cv = (variance ** 0.5) / mean_count
        
        if cv < 0.3:
            return "Very Consistent"
        elif cv < 0.6:
            return "Consistent"
        elif cv < 1.0:
            return "Moderately Variable"
        else:
            return "Highly Variable"


class ActivityFilterParams(BaseFilterSchema):
    """
    Enhanced filter parameters for activity logs.
    
    Comprehensive filtering with performance optimizations.
    """

    # Supervisor filters
    supervisor_id: Optional[str] = Field(
        default=None,
        description="Filter by specific supervisor",
    )
    supervisor_ids: Optional[List[str]] = Field(
        default=None,
        max_length=20,
        description="Filter by multiple supervisors (max 20)",
    )
    
    # Hostel filter
    hostel_id: Optional[str] = Field(
        default=None,
        description="Filter by hostel",
    )
    
    # Time range
    date_range: Optional[DateTimeRangeFilter] = Field(
        default=None,
        description="Filter by date/time range",
    )
    
    # Action filters
    action_category: Optional[AuditActionCategory] = Field(
        default=None,
        description="Filter by action category",
    )
    action_categories: Optional[List[AuditActionCategory]] = Field(
        default=None,
        max_length=10,
        description="Filter by multiple categories",
    )
    action_type: Optional[str] = Field(
        default=None,
        description="Filter by specific action type",
    )
    action_types: Optional[List[str]] = Field(
        default=None,
        max_length=20,
        description="Filter by multiple action types",
    )
    
    # Entity filter
    entity_type: Optional[str] = Field(
        default=None,
        description="Filter by entity type",
    )
    entity_id: Optional[str] = Field(
        default=None,
        description="Filter by specific entity",
    )
    
    # Success filter
    success_only: Optional[bool] = Field(
        default=None,
        description="Show only successful actions",
    )
    failed_only: Optional[bool] = Field(
        default=None,
        description="Show only failed actions",
    )
    
    # Performance filters
    min_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum response time filter",
    )
    max_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Maximum response time filter",
    )
    
    # Device filters
    device_type: Optional[str] = Field(
        default=None,
        pattern=r"^(mobile|desktop|tablet)$",
        description="Filter by device type",
    )
    
    # Pagination and sorting
    page: int = Field(default=1, ge=1, description="Page number")
    page_size: int = Field(default=50, ge=1, le=100, description="Items per page")
    sort_by: str = Field(
        default="created_at",
        pattern=r"^(created_at|action_type|success|response_time_ms)$",
        description="Sort field",
    )
    sort_order: str = Field(
        default="desc",
        pattern=r"^(asc|desc)$",
        description="Sort order",
    )

    @field_validator("supervisor_ids")
    @classmethod
    def validate_supervisor_ids(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """Validate supervisor IDs list."""
        if v is not None:
            # Remove duplicates while preserving order
            seen = set()
            unique_ids = []
            for supervisor_id in v:
                if supervisor_id not in seen:
                    seen.add(supervisor_id)
                    unique_ids.append(supervisor_id)
            return unique_ids
        return v

    @model_validator(mode="after")
    def validate_filter_consistency(self) -> "ActivityFilterParams":
        """Validate filter consistency."""
        # Can't have both success_only and failed_only
        if self.success_only and self.failed_only:
            raise ValueError("Cannot filter for both success_only and failed_only")
        
        # Validate response time range
        if (self.min_response_time_ms is not None and 
            self.max_response_time_ms is not None and
            self.min_response_time_ms > self.max_response_time_ms):
            raise ValueError("min_response_time_ms cannot be greater than max_response_time_ms")
        
        return self


class ActivityExportRequest(BaseCreateSchema):
    """
    Export activity logs with customizable format and fields.
    
    Supports various export formats with field selection.
    """

    filters: ActivityFilterParams = Field(
        ...,
        description="Filter criteria for export",
    )
    format: str = Field(
        default="csv",
        pattern=r"^(csv|excel|pdf|json)$",
        description="Export file format",
    )
    
    # Field selection
    include_metadata: bool = Field(
        default=False,
        description="Include full metadata in export",
    )
    include_technical_details: bool = Field(
        default=False,
        description="Include IP, user agent, etc.",
    )
    include_performance_metrics: bool = Field(
        default=True,
        description="Include response times and success rates",
    )
    include_change_tracking: bool = Field(
        default=False,
        description="Include old/new values for changes",
    )
    
    # Grouping options
    group_by_category: bool = Field(
        default=False,
        description="Group activities by category",
    )
    group_by_date: bool = Field(
        default=False,
        description="Group activities by date",
    )
    
    # Summary options
    include_summary: bool = Field(
        default=True,
        description="Include summary statistics",
    )
    include_charts: bool = Field(
        default=False,
        description="Include charts (for PDF/Excel)",
    )

    @field_validator("format")
    @classmethod
    def normalize_format(cls, v: str) -> str:
        """Normalize format to lowercase."""
        return v.lower().strip()

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_assignment.py ---
# --- File: app/schemas/supervisor/supervisor_assignment.py ---
"""
Supervisor assignment schemas with enhanced validation.

Manages supervisor-hostel assignments with proper tracking,
permission management, and transfer handling.
"""

from __future__ import annotations

from datetime import date, datetime, timedelta
from typing import Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import PermissionLevel

__all__ = [
    "SupervisorAssignment",
    "AssignmentRequest",
    "AssignmentUpdate",
    "RevokeAssignmentRequest",
    "AssignmentTransfer",
    "AssignmentSummary",
]


class SupervisorAssignment(BaseResponseSchema):
    """
    Supervisor-hostel assignment response.
    
    Complete assignment information with metadata.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    supervisor_email: str = Field(..., description="Supervisor email")
    
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    assigned_by: str = Field(..., description="Admin who assigned")
    assigned_by_name: str = Field(..., description="Admin name")
    assigned_date: date = Field(..., description="Assignment date")
    
    is_active: bool = Field(..., description="Assignment is active")
    
    # Permission summary
    permission_level: str = Field(
        ...,
        description="Summary of permission level",
        examples=["Full Access", "Standard Access", "Limited Access"],
    )
    
    # Activity tracking
    last_active: Optional[datetime] = Field(
        default=None,
        description="Last activity timestamp",
    )
    total_days_assigned: int = Field(
        default=0,
        ge=0,
        description="Total days in current assignment",
    )

    @computed_field
    @property
    def assignment_duration_months(self) -> int:
        """Calculate assignment duration in months."""
        return self.total_days_assigned // 30


class AssignmentRequest(BaseCreateSchema):
    """
    Request to assign supervisor to hostel.
    
    Creates new supervisor-hostel assignment with employment details.
    """

    user_id: str = Field(
        ...,
        description="User ID to assign as supervisor",
    )
    hostel_id: str = Field(
        ...,
        description="Hostel ID",
    )
    
    # Employment details
    employee_id: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Employee/Staff ID",
    )
    join_date: date = Field(
        ...,
        description="Joining date",
    )
    employment_type: str = Field(
        default="full_time",
        pattern=r"^(full_time|part_time|contract)$",
        description="Employment type",
    )
    shift_timing: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Shift timing",
    )
    
    # Permissions (optional, will use defaults)
    permissions: Optional[dict] = Field(
        default=None,
        description="Custom permissions (uses template defaults if not provided)",
    )
    permission_template: Optional[str] = Field(
        default="junior_supervisor",
        description="Permission template to apply",
    )

    @field_validator("join_date")
    @classmethod
    def validate_join_date(cls, v: date) -> date:
        """Validate join date is reasonable."""
        today = date.today()
        
        # Allow up to 30 days in future for scheduled assignments
        if v > today + timedelta(days=30):
            raise ValueError("Join date cannot be more than 30 days in the future")
        
        # Allow up to 1 year in past for historical data entry
        if v < today - timedelta(days=365):
            raise ValueError("Join date cannot be more than 1 year in the past")
        
        return v

    @field_validator("employment_type")
    @classmethod
    def normalize_employment_type(cls, v: str) -> str:
        """Normalize employment type to lowercase."""
        return v.lower().strip()


class AssignmentUpdate(BaseUpdateSchema):
    """
    Update supervisor assignment details.
    
    Allows modification of employment details and assignment status.
    """

    employee_id: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Employee ID",
    )
    employment_type: Optional[str] = Field(
        default=None,
        pattern=r"^(full_time|part_time|contract)$",
        description="Employment type",
    )
    shift_timing: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Shift timing",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Assignment active status",
    )
    
    # Permission updates
    permissions: Optional[dict] = Field(
        default=None,
        description="Updated permissions",
    )

    @field_validator("employment_type")
    @classmethod
    def normalize_employment_type(cls, v: Optional[str]) -> Optional[str]:
        """Normalize employment type."""
        return v.lower().strip() if v else None


class RevokeAssignmentRequest(BaseCreateSchema):
    """
    Revoke supervisor assignment.
    
    Handles assignment revocation with handover support.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID",
    )
    revoke_date: date = Field(
        ...,
        description="Effective revocation date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for revocation",
    )
    
    # Handover
    handover_to_supervisor_id: Optional[str] = Field(
        default=None,
        description="Transfer responsibilities to another supervisor",
    )
    handover_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Handover instructions",
    )
    handover_period_days: int = Field(
        default=7,
        ge=0,
        le=30,
        description="Handover period in days",
    )

    @field_validator("revoke_date")
    @classmethod
    def validate_revoke_date(cls, v: date) -> date:
        """Validate revocation date."""
        today = date.today()
        
        # Can't revoke in past (except today)
        if v < today:
            raise ValueError("Revoke date cannot be in the past")
        
        # Limit future revocation
        if v > today + timedelta(days=90):
            raise ValueError("Revoke date cannot be more than 90 days in future")
        
        return v

    @model_validator(mode="after")
    def validate_handover_consistency(self) -> "RevokeAssignmentRequest":
        """Validate handover requirements."""
        if self.handover_to_supervisor_id:
            if not self.handover_notes:
                raise ValueError(
                    "handover_notes required when transferring to another supervisor"
                )
        
        return self


class AssignmentTransfer(BaseCreateSchema):
    """
    Transfer supervisor to different hostel.
    
    Manages supervisor reassignment between hostels with permission handling.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID",
    )
    from_hostel_id: str = Field(
        ...,
        description="Current hostel",
    )
    to_hostel_id: str = Field(
        ...,
        description="New hostel",
    )
    transfer_date: date = Field(
        ...,
        description="Transfer effective date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Transfer reason",
    )
    
    # Permission handling
    retain_permissions: bool = Field(
        default=True,
        description="Keep same permission set",
    )
    new_permissions: Optional[dict] = Field(
        default=None,
        description="New permissions if not retaining",
    )
    permission_template: Optional[str] = Field(
        default=None,
        description="Permission template to apply at new hostel",
    )

    @field_validator("transfer_date")
    @classmethod
    def validate_transfer_date(cls, v: date) -> date:
        """Validate transfer date."""
        today = date.today()
        
        if v < today:
            raise ValueError("Transfer date cannot be in the past")
        
        if v > today + timedelta(days=90):
            raise ValueError("Transfer date cannot be more than 90 days in future")
        
        return v

    @model_validator(mode="after")
    def validate_transfer_logic(self) -> "AssignmentTransfer":
        """Validate transfer business logic."""
        # Different hostels required
        if self.from_hostel_id == self.to_hostel_id:
            raise ValueError("from_hostel_id and to_hostel_id must be different")
        
        # Permission configuration
        if not self.retain_permissions:
            if not self.new_permissions and not self.permission_template:
                raise ValueError(
                    "Must provide new_permissions or permission_template "
                    "when not retaining permissions"
                )
        
        return self


class AssignmentSummary(BaseSchema):
    """
    Assignment summary for reporting.
    
    Aggregated assignment information for dashboards and reports.
    """

    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Assignment counts
    total_supervisors: int = Field(
        default=0,
        ge=0,
        description="Total assigned supervisors",
    )
    active_supervisors: int = Field(
        default=0,
        ge=0,
        description="Currently active supervisors",
    )
    on_leave_supervisors: int = Field(
        default=0,
        ge=0,
        description="Supervisors on leave",
    )
    
    # Activity metrics
    supervisors_online_now: int = Field(
        default=0,
        ge=0,
        description="Currently online",
    )
    supervisors_active_today: int = Field(
        default=0,
        ge=0,
        description="Active today",
    )
    
    # Performance summary
    average_performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average performance rating",
    )
    
    # Coverage
    shift_coverage: dict = Field(
        default_factory=dict,
        description="Coverage by shift",
    )

    @computed_field
    @property
    def active_percentage(self) -> Decimal:
        """Calculate percentage of active supervisors."""
        if self.total_supervisors == 0:
            return Decimal("100.00")
        
        rate = (self.active_supervisors / self.total_supervisors * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def needs_coverage(self) -> bool:
        """Check if hostel needs more supervisor coverage."""
        return self.active_supervisors < 1

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_base.py ---
# --- File: app/schemas/supervisor/supervisor_base.py ---
"""
Supervisor base schemas with enhanced validation and type safety.

Provides core supervisor management schemas including creation, updates,
status management, and hostel reassignment with comprehensive validation.
"""

from __future__ import annotations

from datetime import date, timedelta
from decimal import Decimal
from typing import Dict, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import EmploymentType, SupervisorStatus

__all__ = [
    "SupervisorBase",
    "SupervisorCreate",
    "SupervisorUpdate",
    "SupervisorStatusUpdate",
    "SupervisorReassignment",
    "SupervisorTermination",
]


# Constants for validation
class SupervisorValidationConstants:
    """Centralized validation constants for supervisor operations."""
    
    MAX_FUTURE_JOIN_DAYS = 30
    MAX_PAST_JOIN_YEARS = 50
    MIN_HANDOVER_PERIOD_DAYS = 0
    MAX_HANDOVER_PERIOD_DAYS = 30
    MAX_FUTURE_EFFECTIVE_DAYS = 30
    MAX_PAST_EFFECTIVE_DAYS = 7
    MAX_FUTURE_REASSIGNMENT_DAYS = 90
    MAX_FUTURE_TERMINATION_DAYS = 90
    MAX_PAST_TERMINATION_DAYS = 30
    MIN_REASON_LENGTH = 10
    MAX_REASON_LENGTH = 500
    MAX_NOTES_LENGTH = 1000
    MAX_EMPLOYEE_ID_LENGTH = 100
    MAX_DESIGNATION_LENGTH = 100
    MAX_SHIFT_TIMING_LENGTH = 100
    MIN_SALARY = 0
    MAX_PROBATION_MONTHS = 3


class SupervisorBase(BaseSchema):
    """
    Base supervisor schema with core attributes.
    
    Contains common fields shared across supervisor operations including
    employment details and assignment information.
    """

    user_id: str = Field(
        ...,
        description="Associated user account ID",
    )
    assigned_hostel_id: str = Field(
        ...,
        description="Currently assigned hostel ID",
    )

    # Employment details
    employee_id: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_EMPLOYEE_ID_LENGTH,
        description="Employee/Staff ID number",
        examples=["EMP001", "SUP-2024-001"],
    )
    join_date: date = Field(
        ...,
        description="Joining/start date",
    )
    employment_type: EmploymentType = Field(
        default=EmploymentType.FULL_TIME,
        description="Employment type/contract",
    )
    shift_timing: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_SHIFT_TIMING_LENGTH,
        description="Shift timing or working hours",
        examples=["9 AM - 6 PM", "Morning Shift", "24x7 Rotating"],
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_DESIGNATION_LENGTH,
        description="Job designation/title",
        examples=["Hostel Supervisor", "Senior Supervisor", "Floor Supervisor"],
    )
    salary: Optional[Decimal] = Field(
        default=None,
        ge=SupervisorValidationConstants.MIN_SALARY,
        max_digits=10,
        decimal_places=2,
        description="Monthly salary (confidential)",
    )

    @field_validator("employee_id", "shift_timing", "designation")
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """
        Normalize text fields by trimming and cleaning whitespace.
        
        Args:
            v: Input string value
            
        Returns:
            Normalized string or None if empty
        """
        if v is None:
            return None
        
        v = v.strip()
        if not v:
            return None
        
        # Remove excessive whitespace while preserving single spaces
        normalized = " ".join(v.split())
        
        # Special handling for employee_id - convert to uppercase
        return normalized.upper() if "employee_id" in str(cls) else normalized

    @field_validator("join_date")
    @classmethod
    def validate_join_date(cls, v: date) -> date:
        """
        Validate join date is within reasonable bounds.
        
        Args:
            v: Join date to validate
            
        Returns:
            Validated join date
            
        Raises:
            ValueError: If date is outside acceptable range
        """
        today = date.today()
        
        # Future date validation
        max_future = today + timedelta(days=SupervisorValidationConstants.MAX_FUTURE_JOIN_DAYS)
        if v > max_future:
            raise ValueError(
                f"Join date cannot be more than {SupervisorValidationConstants.MAX_FUTURE_JOIN_DAYS} days in the future"
            )
        
        # Past date validation
        max_past = today - timedelta(days=365 * SupervisorValidationConstants.MAX_PAST_JOIN_YEARS)
        if v < max_past:
            raise ValueError(
                f"Join date cannot be more than {SupervisorValidationConstants.MAX_PAST_JOIN_YEARS} years in the past"
            )
        
        return v

    @model_validator(mode="after")
    def validate_employment_consistency(self) -> "SupervisorBase":
        """
        Validate employment data consistency.
        
        Returns:
            Self with validated data
        """
        # Contract employees should have employee_id
        if self.employment_type == EmploymentType.CONTRACT and not self.employee_id:
            # Warning only - don't enforce
            pass
        
        return self


class SupervisorCreate(SupervisorBase, BaseCreateSchema):
    """
    Schema for creating a new supervisor.
    
    Used when assigning a user as supervisor to a hostel.
    Includes assignment tracking and initial permission configuration.
    """

    user_id: str = Field(
        ...,
        description="User ID to assign as supervisor (required)",
    )
    assigned_hostel_id: str = Field(
        ...,
        description="Hostel ID to assign supervisor to (required)",
    )
    join_date: date = Field(
        ...,
        description="Joining date (required)",
    )
    assigned_by: str = Field(
        ...,
        description="Admin user ID who is assigning the supervisor",
    )

    # Initial permissions (optional, defaults will be applied)
    permissions: Optional[Dict[str, bool | int | Decimal]] = Field(
        default=None,
        description="Initial permission settings (uses defaults if not provided)",
    )
    
    # Assignment metadata
    assignment_notes: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Notes about the assignment",
    )

    @field_validator("permissions")
    @classmethod
    def validate_permissions_structure(
        cls, 
        v: Optional[Dict[str, bool | int | Decimal]]
    ) -> Optional[Dict[str, bool | int | Decimal]]:
        """
        Validate permissions dictionary structure.
        
        Args:
            v: Permissions dictionary
            
        Returns:
            Validated permissions
        """
        if v is None:
            return None
        
        # Ensure all values are of correct types
        for key, value in v.items():
            if not isinstance(value, (bool, int, float, Decimal)):
                raise ValueError(
                    f"Permission '{key}' has invalid value type. "
                    f"Expected bool, int, or Decimal, got {type(value).__name__}"
                )
        
        return v


class SupervisorUpdate(BaseUpdateSchema):
    """
    Schema for updating supervisor information.
    
    All fields are optional for partial updates.
    Includes permission updates and status changes.
    """

    # Employment details
    employee_id: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_EMPLOYEE_ID_LENGTH,
        description="Employee ID",
    )
    employment_type: Optional[EmploymentType] = Field(
        default=None,
        description="Employment type",
    )
    shift_timing: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_SHIFT_TIMING_LENGTH,
        description="Shift timing",
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_DESIGNATION_LENGTH,
        description="Designation",
    )
    salary: Optional[Decimal] = Field(
        default=None,
        ge=SupervisorValidationConstants.MIN_SALARY,
        max_digits=10,
        decimal_places=2,
        description="Monthly salary",
    )

    # Status
    status: Optional[SupervisorStatus] = Field(
        default=None,
        description="Supervisor status",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Active status",
    )

    # Permissions
    permissions: Optional[Dict[str, bool | int | Decimal]] = Field(
        default=None,
        description="Updated permission settings",
    )

    # Notes
    notes: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Additional notes",
    )

    # Apply base validators
    _normalize_text = field_validator(
        "employee_id", "shift_timing", "designation"
    )(SupervisorBase.normalize_text_fields.__func__)

    @model_validator(mode="after")
    def validate_status_consistency(self) -> "SupervisorUpdate":
        """
        Validate status and is_active consistency.
        
        Returns:
            Self with validated data
        """
        # If setting to inactive status, ensure is_active is False
        if self.status in [SupervisorStatus.TERMINATED, SupervisorStatus.SUSPENDED]:
            if self.is_active is True:
                raise ValueError(
                    f"Cannot set is_active=True when status is {self.status.value}"
                )
        
        return self


class SupervisorStatusUpdate(BaseUpdateSchema):
    """
    Schema for updating supervisor status.
    
    Handles status transitions with proper documentation and validation.
    Supports termination, suspension, and leave management.
    """

    status: SupervisorStatus = Field(
        ...,
        description="New supervisor status",
    )
    is_active: bool = Field(
        ...,
        description="Active status (false for terminated/suspended)",
    )
    effective_date: date = Field(
        ...,
        description="Status change effective date",
    )
    reason: str = Field(
        ...,
        min_length=SupervisorValidationConstants.MIN_REASON_LENGTH,
        max_length=SupervisorValidationConstants.MAX_REASON_LENGTH,
        description="Reason for status change",
    )

    # Termination-specific fields
    termination_date: Optional[date] = Field(
        default=None,
        description="Termination date (required if status is TERMINATED)",
    )
    termination_reason: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_REASON_LENGTH,
        description="Detailed termination reason",
    )
    eligible_for_rehire: Optional[bool] = Field(
        default=None,
        description="Eligible for rehire in future",
    )

    # Suspension-specific fields
    suspension_start_date: Optional[date] = Field(
        default=None,
        description="Suspension start date (required if SUSPENDED)",
    )
    suspension_end_date: Optional[date] = Field(
        default=None,
        description="Expected suspension end date (required if SUSPENDED)",
    )
    suspension_reason: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_REASON_LENGTH,
        description="Detailed suspension reason",
    )

    # Leave-specific fields
    leave_start_date: Optional[date] = Field(
        default=None,
        description="Leave start date (required if ON_LEAVE)",
    )
    leave_end_date: Optional[date] = Field(
        default=None,
        description="Expected return date from leave (required if ON_LEAVE)",
    )
    leave_type: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Type of leave (sick, vacation, etc.)",
    )

    # Handover details
    handover_to: Optional[str] = Field(
        default=None,
        description="Supervisor ID for responsibility handover",
    )
    handover_notes: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Handover instructions",
    )

    @field_validator("effective_date")
    @classmethod
    def validate_effective_date(cls, v: date) -> date:
        """Validate effective date is within acceptable range."""
        today = date.today()
        
        min_date = today - timedelta(days=SupervisorValidationConstants.MAX_PAST_EFFECTIVE_DAYS)
        max_date = today + timedelta(days=SupervisorValidationConstants.MAX_FUTURE_EFFECTIVE_DAYS)
        
        if v < min_date:
            raise ValueError(
                f"Effective date cannot be more than {SupervisorValidationConstants.MAX_PAST_EFFECTIVE_DAYS} days in the past"
            )
        
        if v > max_date:
            raise ValueError(
                f"Effective date cannot be more than {SupervisorValidationConstants.MAX_FUTURE_EFFECTIVE_DAYS} days in the future"
            )
        
        return v

    @model_validator(mode="after")
    def validate_status_specific_requirements(self) -> "SupervisorStatusUpdate":
        """
        Validate status-specific required fields and constraints.
        
        Returns:
            Self with validated data
            
        Raises:
            ValueError: If required fields are missing for specific statuses
        """
        # Termination validation
        if self.status == SupervisorStatus.TERMINATED:
            if not self.termination_date:
                raise ValueError("termination_date is required for TERMINATED status")
            if not self.termination_reason:
                raise ValueError("termination_reason is required for TERMINATED status")
            if self.is_active:
                raise ValueError("is_active must be False for TERMINATED status")
        
        # Suspension validation
        if self.status == SupervisorStatus.SUSPENDED:
            if not self.suspension_start_date:
                raise ValueError("suspension_start_date is required for SUSPENDED status")
            if not self.suspension_end_date:
                raise ValueError("suspension_end_date is required for SUSPENDED status")
            if not self.suspension_reason:
                raise ValueError("suspension_reason is required for SUSPENDED status")
            if self.is_active:
                raise ValueError("is_active must be False for SUSPENDED status")
        
        # Leave validation
        if self.status == SupervisorStatus.ON_LEAVE:
            if not self.leave_start_date:
                raise ValueError("leave_start_date is required for ON_LEAVE status")
            if not self.leave_end_date:
                raise ValueError("leave_end_date is required for ON_LEAVE status")
        
        return self

    @model_validator(mode="after")
    def validate_date_ranges(self) -> "SupervisorStatusUpdate":
        """
        Validate date range consistency for suspension and leave.
        
        Returns:
            Self with validated dates
            
        Raises:
            ValueError: If end dates are before start dates
        """
        # Suspension date range
        if self.suspension_start_date and self.suspension_end_date:
            if self.suspension_end_date <= self.suspension_start_date:
                raise ValueError("suspension_end_date must be after suspension_start_date")
        
        # Leave date range
        if self.leave_start_date and self.leave_end_date:
            if self.leave_end_date <= self.leave_start_date:
                raise ValueError("leave_end_date must be after leave_start_date")
        
        return self


class SupervisorReassignment(BaseCreateSchema):
    """
    Schema for reassigning supervisor to different hostel.
    
    Handles supervisor transfer between hostels with proper tracking,
    permission handling, and optional salary adjustments.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID to reassign",
    )
    from_hostel_id: str = Field(
        ...,
        description="Current hostel ID",
    )
    new_hostel_id: str = Field(
        ...,
        description="New hostel ID to assign",
    )
    effective_date: date = Field(
        ...,
        description="Reassignment effective date",
    )
    reason: str = Field(
        ...,
        min_length=SupervisorValidationConstants.MIN_REASON_LENGTH,
        max_length=SupervisorValidationConstants.MAX_REASON_LENGTH,
        description="Reason for reassignment",
        examples=[
            "Staff shortage at new hostel",
            "Performance-based transfer",
            "Personal request",
            "Organizational restructuring",
        ],
    )

    # Permission handling
    retain_permissions: bool = Field(
        default=True,
        description="Retain same permission set at new hostel",
    )
    new_permissions: Optional[Dict[str, bool | int | Decimal]] = Field(
        default=None,
        description="New permission set (required if not retaining)",
    )

    # Salary adjustment
    salary_adjustment: Optional[Decimal] = Field(
        default=None,
        max_digits=10,
        decimal_places=2,
        description="Salary adjustment amount (positive or negative)",
    )
    salary_adjustment_reason: Optional[str] = Field(
        default=None,
        max_length=200,
        description="Reason for salary adjustment",
    )

    # Handover configuration
    handover_period_days: int = Field(
        default=7,
        ge=SupervisorValidationConstants.MIN_HANDOVER_PERIOD_DAYS,
        le=SupervisorValidationConstants.MAX_HANDOVER_PERIOD_DAYS,
        description="Handover period in days",
    )
    handover_to: Optional[str] = Field(
        default=None,
        description="Supervisor ID for handover at current hostel",
    )

    @field_validator("effective_date")
    @classmethod
    def validate_effective_date(cls, v: date) -> date:
        """Validate effective date is in acceptable future range."""
        today = date.today()
        
        if v < today:
            raise ValueError("Effective date cannot be in the past")
        
        max_date = today + timedelta(days=SupervisorValidationConstants.MAX_FUTURE_REASSIGNMENT_DAYS)
        if v > max_date:
            raise ValueError(
                f"Effective date cannot be more than {SupervisorValidationConstants.MAX_FUTURE_REASSIGNMENT_DAYS} days in the future"
            )
        
        return v

    @model_validator(mode="after")
    def validate_reassignment_logic(self) -> "SupervisorReassignment":
        """
        Validate reassignment business logic.
        
        Returns:
            Self with validated data
            
        Raises:
            ValueError: If reassignment logic is invalid
        """
        # Different hostel validation
        if self.from_hostel_id == self.new_hostel_id:
            raise ValueError("New hostel must be different from current hostel")
        
        # Permission configuration validation
        if not self.retain_permissions and not self.new_permissions:
            raise ValueError(
                "new_permissions must be provided when retain_permissions is False"
            )
        
        # Salary adjustment validation
        if self.salary_adjustment is not None and self.salary_adjustment != 0:
            if not self.salary_adjustment_reason:
                raise ValueError(
                    "salary_adjustment_reason is required when adjusting salary"
                )
        
        return self


class SupervisorTermination(BaseCreateSchema):
    """
    Schema for comprehensive supervisor termination.
    
    Handles complete termination process including exit interview,
    clearance verification, asset return, and final settlement.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID to terminate",
    )
    termination_date: date = Field(
        ...,
        description="Termination effective date",
    )
    termination_type: str = Field(
        ...,
        pattern=r"^(voluntary|involuntary|retirement|end_of_contract)$",
        description="Type of termination",
        examples=["voluntary", "involuntary", "retirement", "end_of_contract"],
    )
    reason: str = Field(
        ...,
        min_length=20,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Detailed termination reason",
    )

    # Notice period
    notice_period_served: bool = Field(
        ...,
        description="Whether notice period was served",
    )
    notice_period_days: Optional[int] = Field(
        default=None,
        ge=0,
        le=90,
        description="Notice period served in days",
    )

    # Clearance checklist
    hostel_clearance_obtained: bool = Field(
        default=False,
        description="Hostel clearance completed",
    )
    finance_clearance_obtained: bool = Field(
        default=False,
        description="Finance clearance completed",
    )
    admin_clearance_obtained: bool = Field(
        default=False,
        description="Admin clearance completed",
    )

    # Asset management
    assets_returned: bool = Field(
        default=False,
        description="All hostel assets returned",
    )
    asset_list: Optional[str] = Field(
        default=None,
        max_length=500,
        description="List of assets returned",
    )

    # Exit interview
    exit_interview_conducted: bool = Field(
        default=False,
        description="Exit interview completed",
    )
    exit_interview_notes: Optional[str] = Field(
        default=None,
        max_length=2000,
        description="Exit interview notes",
    )

    # Rehire eligibility
    eligible_for_rehire: bool = Field(
        ...,
        description="Eligible for future rehire",
    )
    rehire_notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Notes on rehire eligibility",
    )

    # Final settlement
    final_settlement_amount: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Final settlement amount",
    )
    settlement_date: Optional[date] = Field(
        default=None,
        description="Settlement payment date",
    )

    # Handover
    responsibilities_handover_to: Optional[str] = Field(
        default=None,
        description="Supervisor ID for handover",
    )
    handover_completed: bool = Field(
        default=False,
        description="Handover completion status",
    )
    handover_notes: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Handover notes",
    )

    @field_validator("termination_date")
    @classmethod
    def validate_termination_date(cls, v: date) -> date:
        """Validate termination date is within acceptable range."""
        today = date.today()
        
        min_date = today - timedelta(days=SupervisorValidationConstants.MAX_PAST_TERMINATION_DAYS)
        max_date = today + timedelta(days=SupervisorValidationConstants.MAX_FUTURE_TERMINATION_DAYS)
        
        if v < min_date:
            raise ValueError(
                f"Termination date cannot be more than {SupervisorValidationConstants.MAX_PAST_TERMINATION_DAYS} days in the past"
            )
        
        if v > max_date:
            raise ValueError(
                f"Termination date cannot be more than {SupervisorValidationConstants.MAX_FUTURE_TERMINATION_DAYS} days in the future"
            )
        
        return v

    @field_validator("termination_type")
    @classmethod
    def normalize_termination_type(cls, v: str) -> str:
        """Normalize termination type to lowercase."""
        return v.lower().strip()

    @model_validator(mode="after")
    def validate_termination_requirements(self) -> "SupervisorTermination":
        """
        Validate termination-specific business logic.
        
        Returns:
            Self with validated data
        """
        # Settlement validation
        if self.final_settlement_amount and self.final_settlement_amount > 0:
            if not self.settlement_date:
                raise ValueError(
                    "settlement_date is required when final_settlement_amount is provided"
                )
        
        # Notice period validation for voluntary termination
        if self.termination_type == "voluntary" and not self.notice_period_served:
            if self.notice_period_days is None or self.notice_period_days == 0:
                # Warning only - don't enforce strictly
                pass
        
        return self

    @model_validator(mode="after")
    def validate_clearance_completeness(self) -> "SupervisorTermination":
        """
        Validate clearance requirements for past terminations.
        
        Returns:
            Self with validation warnings (non-blocking)
        """
        # For past terminations, all clearances should ideally be complete
        if self.termination_date <= date.today():
            incomplete_clearances = []
            
            if not self.hostel_clearance_obtained:
                incomplete_clearances.append("hostel")
            if not self.finance_clearance_obtained:
                incomplete_clearances.append("finance")
            if not self.admin_clearance_obtained:
                incomplete_clearances.append("admin")
            
            # Log warning but don't block (can be handled at service layer)
            if incomplete_clearances:
                # This would typically trigger a warning in logs
                pass
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_dashboard.py ---
# --- File: app/schemas/supervisor/supervisor_dashboard.py ---
"""
Supervisor dashboard schemas with real-time metrics and insights.

Provides comprehensive dashboard data with performance indicators,
task management, and actionable insights.
"""

from __future__ import annotations

from datetime import date, datetime, time
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseSchema

__all__ = [
    "SupervisorDashboard",
    "DashboardMetrics",
    "TaskSummary",
    "RecentComplaintItem",
    "RecentMaintenanceItem",
    "PendingLeaveItem",
    "TodaySchedule",
    "DashboardAlert",
    "QuickActions",
    "PerformanceIndicators",
]


class DashboardMetrics(BaseSchema):
    """
    Key performance metrics for supervisor dashboard.
    
    Real-time metrics with trend indicators and benchmarks.
    """

    # Student metrics
    total_students: int = Field(..., ge=0, description="Total students in hostel")
    active_students: int = Field(..., ge=0, description="Currently active students")
    students_on_leave: int = Field(..., ge=0, description="Students on approved leave")
    new_students_this_month: int = Field(..., ge=0, description="New admissions this month")
    
    # Occupancy metrics
    total_beds: int = Field(..., ge=0, description="Total bed capacity")
    occupied_beds: int = Field(..., ge=0, description="Currently occupied beds")
    available_beds: int = Field(..., ge=0, description="Available beds")
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Current occupancy percentage",
    )
    occupancy_trend: str = Field(
        ...,
        pattern=r"^(increasing|stable|decreasing)$",
        description="Occupancy trend direction",
    )
    
    # Complaint metrics
    total_complaints: int = Field(..., ge=0, description="Total complaints (all time)")
    open_complaints: int = Field(..., ge=0, description="Currently open complaints")
    assigned_to_me: int = Field(..., ge=0, description="Complaints assigned to me")
    resolved_today: int = Field(..., ge=0, description="Complaints resolved today")
    resolved_this_week: int = Field(..., ge=0, description="Resolved this week")
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average resolution time in hours",
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="SLA compliance percentage",
    )
    
    # Maintenance metrics
    pending_maintenance: int = Field(..., ge=0, description="Pending maintenance requests")
    in_progress_maintenance: int = Field(..., ge=0, description="In-progress maintenance")
    completed_today: int = Field(..., ge=0, description="Completed today")
    overdue_maintenance: int = Field(..., ge=0, description="Overdue maintenance")
    maintenance_budget_used: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of maintenance budget used",
    )
    
    # Attendance metrics
    attendance_marked_today: bool = Field(..., description="Today's attendance marked")
    total_present_today: int = Field(..., ge=0, description="Students present today")
    total_absent_today: int = Field(..., ge=0, description="Students absent today")
    attendance_percentage_today: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Today's attendance percentage",
    )
    
    # Payment metrics (view-only)
    overdue_payments_count: int = Field(..., ge=0, description="Students with overdue payments")
    payment_collection_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Monthly payment collection rate",
    )
    
    # Communication metrics
    unread_admin_messages: int = Field(..., ge=0, description="Unread messages from admin")
    pending_announcements: int = Field(..., ge=0, description="Announcements pending approval")

    @computed_field
    @property
    def overall_health_score(self) -> Decimal:
        """Calculate overall hostel health score (0-100)."""
        # Weighted scoring based on key metrics
        occupancy_score = min(float(self.occupancy_percentage), 100) * 0.25
        complaint_score = max(0, 100 - (self.open_complaints * 5)) * 0.25
        maintenance_score = max(0, 100 - (self.pending_maintenance * 10)) * 0.25
        attendance_score = float(self.attendance_percentage_today) * 0.25
        
        total_score = occupancy_score + complaint_score + maintenance_score + attendance_score
        return Decimal(str(total_score)).quantize(Decimal("0.1"))

    @computed_field
    @property
    def needs_attention(self) -> List[str]:
        """Identify areas needing immediate attention."""
        issues = []
        
        if self.open_complaints > 5:
            issues.append("High number of open complaints")
        
        if self.overdue_maintenance > 0:
            issues.append("Overdue maintenance requests")
        
        if not self.attendance_marked_today:
            issues.append("Attendance not marked today")
        
        if self.occupancy_percentage < 70:
            issues.append("Low occupancy rate")
        
        if self.overdue_payments_count > 10:
            issues.append("Multiple overdue payments")
        
        return issues


class TaskSummary(BaseSchema):
    """
    Summary of pending tasks and priorities.
    
    Actionable task list with urgency indicators.
    """

    # High priority tasks
    urgent_complaints: int = Field(..., ge=0, description="Urgent complaints requiring attention")
    critical_maintenance: int = Field(..., ge=0, description="Critical maintenance requests")
    pending_leave_approvals: int = Field(..., ge=0, description="Leave requests awaiting approval")
    overdue_tasks: int = Field(..., ge=0, description="Overdue tasks")
    
    # Daily routine tasks
    attendance_pending: bool = Field(..., description="Daily attendance not yet marked")
    menu_published_today: bool = Field(..., description="Today's menu published")
    daily_inspection_done: bool = Field(..., description="Daily inspection completed")
    reports_pending: int = Field(..., ge=0, description="Reports pending submission")
    
    # Administrative tasks
    document_verifications_pending: int = Field(
        ...,
        ge=0,
        description="Student documents awaiting verification",
    )
    room_assignments_pending: int = Field(
        ...,
        ge=0,
        description="Room assignments to be processed",
    )
    
    # Overdue items
    overdue_complaint_resolutions: int = Field(
        ...,
        ge=0,
        description="Complaints past SLA deadline",
    )
    overdue_maintenance: int = Field(
        ...,
        ge=0,
        description="Maintenance past due date",
    )
    
    # Total pending
    total_pending_tasks: int = Field(
        ...,
        ge=0,
        description="Total tasks requiring action",
    )

    @computed_field
    @property
    def priority_score(self) -> int:
        """Calculate task priority score (higher = more urgent)."""
        score = 0
        score += self.urgent_complaints * 10
        score += self.critical_maintenance * 8
        score += self.overdue_complaint_resolutions * 15
        score += self.overdue_maintenance * 12
        score += self.pending_leave_approvals * 3
        
        if self.attendance_pending:
            score += 20
        
        return score

    @computed_field
    @property
    def workload_level(self) -> str:
        """Assess current workload level."""
        if self.total_pending_tasks == 0:
            return "Light"
        elif self.total_pending_tasks <= 5:
            return "Moderate"
        elif self.total_pending_tasks <= 15:
            return "Heavy"
        else:
            return "Overwhelming"


class RecentComplaintItem(BaseSchema):
    """Recent complaint for dashboard display."""
    
    complaint_id: str = Field(..., description="Complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")
    title: str = Field(..., description="Complaint title")
    category: str = Field(..., description="Complaint category")
    priority: str = Field(..., description="Priority level")
    status: str = Field(..., description="Current status")
    
    # Student info
    student_name: str = Field(..., description="Student name")
    room_number: str = Field(..., description="Room number")
    
    # Timing
    created_at: datetime = Field(..., description="Complaint creation time")
    age_hours: int = Field(..., ge=0, description="Hours since creation")
    sla_deadline: Optional[datetime] = Field(
        default=None,
        description="SLA deadline for resolution",
    )

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if complaint is past SLA deadline."""
        if not self.sla_deadline:
            return False
        return datetime.now() > self.sla_deadline

    @computed_field
    @property
    def urgency_indicator(self) -> str:
        """Get urgency indicator for UI."""
        if self.is_overdue:
            return "overdue"
        elif self.priority in ["urgent", "high"]:
            return "urgent"
        elif self.age_hours > 24:
            return "attention"
        else:
            return "normal"


class RecentMaintenanceItem(BaseSchema):
    """Recent maintenance request for dashboard."""
    
    request_id: str = Field(..., description="Maintenance request ID")
    request_number: str = Field(..., description="Request reference number")
    title: str = Field(..., description="Maintenance title")
    category: str = Field(..., description="Maintenance category")
    priority: str = Field(..., description="Priority level")
    status: str = Field(..., description="Current status")
    
    # Location
    room_number: Optional[str] = Field(default=None, description="Room number")
    location_description: Optional[str] = Field(
        default=None,
        description="Location description",
    )
    
    # Cost and timing
    estimated_cost: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Estimated cost",
    )
    created_at: datetime = Field(..., description="Request creation time")
    scheduled_date: Optional[date] = Field(
        default=None,
        description="Scheduled completion date",
    )
    
    # Assignment
    assigned_to: Optional[str] = Field(
        default=None,
        description="Assigned staff/vendor",
    )

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if maintenance is overdue."""
        if not self.scheduled_date:
            return False
        return date.today() > self.scheduled_date

    @computed_field
    @property
    def days_pending(self) -> int:
        """Calculate days since request creation."""
        return (datetime.now() - self.created_at).days


class PendingLeaveItem(BaseSchema):
    """Pending leave approval for dashboard."""
    
    leave_id: str = Field(..., description="Leave application ID")
    student_name: str = Field(..., description="Student name")
    room_number: str = Field(..., description="Room number")
    
    # Leave details
    leave_type: str = Field(..., description="Type of leave")
    from_date: date = Field(..., description="Leave start date")
    to_date: date = Field(..., description="Leave end date")
    total_days: int = Field(..., ge=1, description="Total leave days")
    reason: str = Field(..., description="Leave reason")
    
    # Application details
    applied_at: datetime = Field(..., description="Application timestamp")
    emergency_contact: Optional[str] = Field(
        default=None,
        description="Emergency contact during leave",
    )
    supporting_documents: bool = Field(
        default=False,
        description="Supporting documents provided",
    )

    @computed_field
    @property
    def is_urgent(self) -> bool:
        """Check if leave approval is urgent."""
        # Urgent if leave starts within 2 days
        return (self.from_date - date.today()).days <= 2

    @computed_field
    @property
    def pending_days(self) -> int:
        """Days since application was submitted."""
        return (datetime.now() - self.applied_at).days


class ScheduledMaintenanceItem(BaseSchema):
    """Scheduled maintenance for today."""
    
    maintenance_id: str = Field(..., description="Maintenance ID")
    title: str = Field(..., description="Maintenance title")
    scheduled_time: time = Field(..., description="Scheduled time")
    estimated_duration_hours: Optional[int] = Field(
        default=None,
        ge=1,
        description="Estimated duration in hours",
    )
    room_number: Optional[str] = Field(default=None, description="Room number")
    assigned_staff: Optional[str] = Field(default=None, description="Assigned staff")
    priority: str = Field(..., description="Priority level")


class ScheduledMeeting(BaseSchema):
    """Scheduled meeting for today."""
    
    meeting_id: str = Field(..., description="Meeting ID")
    title: str = Field(..., description="Meeting title")
    start_time: time = Field(..., description="Meeting start time")
    end_time: time = Field(..., description="Meeting end time")
    attendees: List[str] = Field(default_factory=list, description="Attendee names")
    location: str = Field(..., description="Meeting location")
    meeting_type: str = Field(
        ...,
        pattern=r"^(staff|admin|student|vendor|other)$",
        description="Type of meeting",
    )


class TodaySchedule(BaseSchema):
    """Today's schedule and planned activities."""
    
    date: date = Field(..., description="Schedule date")
    
    # Routine tasks
    attendance_marking_time: time = Field(
        ...,
        description="Expected time for attendance marking",
    )
    inspection_rounds: List[str] = Field(
        default_factory=list,
        description="Scheduled inspection areas",
    )
    
    # Scheduled activities
    scheduled_maintenance: List[ScheduledMaintenanceItem] = Field(
        default_factory=list,
        description="Maintenance scheduled for today",
    )
    scheduled_meetings: List[ScheduledMeeting] = Field(
        default_factory=list,
        description="Meetings scheduled for today",
    )
    
    # Special events
    special_events: List[str] = Field(
        default_factory=list,
        description="Special events or occasions",
    )
    
    # Deadlines
    report_deadlines: List[str] = Field(
        default_factory=list,
        description="Reports due today",
    )

    @computed_field
    @property
    def total_scheduled_items(self) -> int:
        """Count total scheduled items for the day."""
        return (
            len(self.scheduled_maintenance) +
            len(self.scheduled_meetings) +
            len(self.special_events) +
            len(self.report_deadlines)
        )

    @computed_field
    @property
    def schedule_density(self) -> str:
        """Assess schedule density for the day."""
        if self.total_scheduled_items == 0:
            return "Light"
        elif self.total_scheduled_items <= 3:
            return "Moderate"
        elif self.total_scheduled_items <= 6:
            return "Busy"
        else:
            return "Very Busy"


class DashboardAlert(BaseSchema):
    """Dashboard alert/notification with action support."""
    
    alert_id: str = Field(..., description="Alert ID")
    alert_type: str = Field(
        ...,
        pattern=r"^(urgent|warning|info|success)$",
        description="Alert severity level",
    )
    title: str = Field(..., description="Alert title")
    message: str = Field(..., description="Alert message")
    
    # Action support
    action_required: bool = Field(..., description="Whether action is required")
    action_url: Optional[str] = Field(default=None, description="Action URL")
    action_label: Optional[str] = Field(default=None, description="Action button label")
    
    # Metadata
    created_at: datetime = Field(..., description="Alert creation time")
    expires_at: Optional[datetime] = Field(default=None, description="Alert expiration")
    is_dismissible: bool = Field(default=True, description="Can be dismissed by user")
    
    # Context
    related_entity_type: Optional[str] = Field(
        default=None,
        description="Related entity type",
    )
    related_entity_id: Optional[str] = Field(
        default=None,
        description="Related entity ID",
    )

    @computed_field
    @property
    def is_expired(self) -> bool:
        """Check if alert has expired."""
        if not self.expires_at:
            return False
        return datetime.now() > self.expires_at

    @computed_field
    @property
    def age_minutes(self) -> int:
        """Calculate alert age in minutes."""
        return int((datetime.now() - self.created_at).total_seconds() / 60)


class QuickAction(BaseSchema):
    """Individual quick action button."""
    
    action_id: str = Field(..., description="Action identifier")
    label: str = Field(..., description="Action label")
    icon: str = Field(..., description="Icon identifier")
    url: str = Field(..., description="Action URL")
    
    # Badge support
    badge_count: Optional[int] = Field(
        default=None,
        ge=0,
        description="Number indicator (e.g., pending items)",
    )
    badge_type: Optional[str] = Field(
        default=None,
        pattern=r"^(info|warning|danger|success)$",
        description="Badge color type",
    )
    
    # Permissions
    requires_permission: Optional[str] = Field(
        default=None,
        description="Required permission to show action",
    )
    
    # Grouping
    category: str = Field(
        default="general",
        description="Action category for grouping",
    )


class QuickActions(BaseSchema):
    """Quick action buttons for dashboard."""
    
    actions: List[QuickAction] = Field(
        ...,
        description="Available quick actions",
    )

    @computed_field
    @property
    def actions_by_category(self) -> Dict[str, List[QuickAction]]:
        """Group actions by category."""
        grouped = {}
        for action in self.actions:
            category = action.category
            if category not in grouped:
                grouped[category] = []
            grouped[category].append(action)
        return grouped


class PerformanceIndicators(BaseSchema):
    """Key performance indicators for supervisor."""
    
    # Efficiency metrics
    complaint_resolution_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Complaint resolution rate %",
    )
    average_response_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average response time to issues",
    )
    task_completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Task completion rate %",
    )
    
    # Quality metrics
    student_satisfaction_score: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Student satisfaction rating",
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="SLA compliance rate %",
    )
    
    # Activity metrics
    daily_activity_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Daily activity score",
    )
    consistency_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Performance consistency score",
    )
    
    # Trend indicators
    performance_trend: str = Field(
        ...,
        pattern=r"^(improving|stable|declining)$",
        description="Overall performance trend",
    )
    
    # Benchmarking
    rank_among_peers: Optional[int] = Field(
        default=None,
        ge=1,
        description="Rank among peer supervisors",
    )
    total_peers: Optional[int] = Field(
        default=None,
        ge=1,
        description="Total number of peer supervisors",
    )

    @computed_field
    @property
    def overall_performance_score(self) -> Decimal:
        """Calculate overall performance score."""
        # Weighted average of key metrics
        weights = {
            'complaint_resolution': 0.25,
            'task_completion': 0.25,
            'sla_compliance': 0.25,
            'activity': 0.25,
        }
        
        score = (
            float(self.complaint_resolution_rate) * weights['complaint_resolution'] +
            float(self.task_completion_rate) * weights['task_completion'] +
            float(self.sla_compliance_rate) * weights['sla_compliance'] +
            float(self.daily_activity_score) * weights['activity']
        )
        
        return Decimal(str(score)).quantize(Decimal("0.1"))

    @computed_field
    @property
    def performance_grade(self) -> str:
        """Get performance grade based on overall score."""
        score = float(self.overall_performance_score)
        
        if score >= 90:
            return "A+"
        elif score >= 80:
            return "A"
        elif score >= 70:
            return "B+"
        elif score >= 60:
            return "B"
        elif score >= 50:
            return "C"
        else:
            return "D"


class SupervisorDashboard(BaseSchema):
    """
    Complete supervisor dashboard with real-time data.
    
    Comprehensive dashboard providing all necessary information
    for effective hostel management.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Core metrics
    metrics: DashboardMetrics = Field(..., description="Key performance metrics")
    
    # Task management
    tasks: TaskSummary = Field(..., description="Pending tasks summary")
    
    # Recent activity
    recent_complaints: List[RecentComplaintItem] = Field(
        default_factory=list,
        max_length=5,
        description="Recent complaints (max 5)",
    )
    recent_maintenance: List[RecentMaintenanceItem] = Field(
        default_factory=list,
        max_length=5,
        description="Recent maintenance requests (max 5)",
    )
    pending_leaves: List[PendingLeaveItem] = Field(
        default_factory=list,
        max_length=10,
        description="Pending leave approvals (max 10)",
    )
    
    # Schedule
    today_schedule: TodaySchedule = Field(..., description="Today's schedule")
    
    # Alerts and notifications
    alerts: List[DashboardAlert] = Field(
        default_factory=list,
        description="Active alerts and notifications",
    )
    
    # Quick actions
    quick_actions: QuickActions = Field(..., description="Available quick actions")
    
    # Performance indicators
    performance: PerformanceIndicators = Field(
        ...,
        description="Performance indicators",
    )
    
    # Activity tracking
    last_login: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp",
    )
    actions_today: int = Field(
        default=0,
        ge=0,
        description="Actions performed today",
    )
    online_duration_minutes: int = Field(
        default=0,
        ge=0,
        description="Online duration today (minutes)",
    )
    
    # Dashboard metadata
    dashboard_updated_at: datetime = Field(
        ...,
        description="Dashboard data timestamp",
    )
    refresh_interval_seconds: int = Field(
        default=300,
        ge=60,
        description="Recommended refresh interval",
    )

    @computed_field
    @property
    def critical_alerts_count(self) -> int:
        """Count critical alerts requiring immediate attention."""
        return sum(1 for alert in self.alerts if alert.alert_type == "urgent")

    @computed_field
    @property
    def workload_summary(self) -> str:
        """Get workload summary description."""
        total_pending = self.tasks.total_pending_tasks
        urgent_items = (
            self.tasks.urgent_complaints +
            self.tasks.critical_maintenance +
            self.tasks.overdue_tasks
        )
        
        if urgent_items > 5:
            return "Critical workload - immediate attention required"
        elif total_pending > 15:
            return "Heavy workload - prioritize urgent tasks"
        elif total_pending > 5:
            return "Moderate workload - manageable"
        else:
            return "Light workload - good job!"

    @computed_field
    @property
    def dashboard_health_status(self) -> str:
        """Overall dashboard health status."""
        health_score = float(self.metrics.overall_health_score)
        critical_alerts = self.critical_alerts_count
        urgent_tasks = (
            self.tasks.urgent_complaints +
            self.tasks.critical_maintenance +
            self.tasks.overdue_tasks
        )
        
        if critical_alerts > 0 or urgent_tasks > 5:
            return "Critical"
        elif health_score < 60 or urgent_tasks > 2:
            return "Warning"
        elif health_score < 80:
            return "Good"
        else:
            return "Excellent"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_performance.py ---
# --- File: app/schemas/supervisor/supervisor_performance.py ---
"""
Supervisor performance tracking schemas with comprehensive analytics.

Provides detailed performance measurement, goal tracking, and
comparative analysis with peer benchmarking.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "PerformanceMetrics",
    "PerformanceReport",
    "ComplaintPerformance",
    "AttendancePerformance",
    "MaintenancePerformance",
    "PerformanceTrendPoint",
    "PeerComparison",
    "PeriodComparison",
    "PerformanceReview",
    "PerformanceReviewResponse",
    "PerformanceGoal",
    "PerformanceGoalProgress",
    "PerformanceInsights",
]


class PerformanceMetrics(BaseSchema):
    """
    Comprehensive supervisor performance metrics.
    
    Aggregated performance data across all key areas with
    trend analysis and benchmarking.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_id: str = Field(..., description="Hostel ID")
    period_start: date = Field(..., description="Metrics period start")
    period_end: date = Field(..., description="Metrics period end")
    
    # ============ Complaint Handling Metrics ============
    complaints_handled: int = Field(..., ge=0, description="Total complaints handled")
    complaints_resolved: int = Field(..., ge=0, description="Complaints resolved")
    complaint_resolution_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Complaint resolution rate percentage",
    )
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average time to resolve complaints",
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="SLA compliance rate percentage",
    )
    first_response_time_minutes: Decimal = Field(
        ...,
        ge=0,
        description="Average first response time",
    )
    
    # ============ Attendance Management Metrics ============
    attendance_records_created: int = Field(
        ...,
        ge=0,
        description="Attendance records created",
    )
    attendance_accuracy: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Attendance accuracy percentage",
    )
    leaves_approved: int = Field(..., ge=0, description="Leave applications approved")
    leaves_rejected: int = Field(..., ge=0, description="Leave applications rejected")
    attendance_punctuality_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="On-time attendance marking rate",
    )
    
    # ============ Maintenance Management Metrics ============
    maintenance_requests_created: int = Field(
        ...,
        ge=0,
        description="Maintenance requests created",
    )
    maintenance_completed: int = Field(
        ...,
        ge=0,
        description="Maintenance requests completed",
    )
    maintenance_completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Maintenance completion rate",
    )
    average_maintenance_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average maintenance completion time",
    )
    maintenance_cost_efficiency: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Cost efficiency percentage",
    )
    
    # ============ Communication Metrics ============
    announcements_created: int = Field(
        ...,
        ge=0,
        description="Announcements created",
    )
    announcement_reach: int = Field(
        ...,
        ge=0,
        description="Total students reached by announcements",
    )
    student_interactions: int = Field(
        ...,
        ge=0,
        description="Direct student interactions",
    )
    
    # ============ Responsiveness Metrics ============
    average_first_response_time_minutes: Decimal = Field(
        ...,
        ge=0,
        description="Average first response time to issues",
    )
    availability_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Availability during working hours",
    )
    response_consistency_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Consistency in response times",
    )
    
    # ============ Student Satisfaction ============
    student_feedback_score: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average student feedback rating",
    )
    student_feedback_count: int = Field(
        ...,
        ge=0,
        description="Number of student feedback responses",
    )
    complaint_escalation_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of complaints escalated",
    )
    
    # ============ Overall Performance ============
    overall_performance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Calculated overall performance score",
    )
    performance_grade: str = Field(
        ...,
        pattern=r"^(A\+|A|B\+|B|C|D)$",
        description="Performance grade",
    )

    @computed_field
    @property
    def efficiency_score(self) -> Decimal:
        """Calculate efficiency score based on time metrics."""
        # Weighted score based on response times and completion rates
        response_score = max(0, 100 - float(self.average_first_response_time_minutes))
        completion_score = float(self.complaint_resolution_rate + self.maintenance_completion_rate) / 2
        
        efficiency = (response_score * 0.4 + completion_score * 0.6)
        return Decimal(str(efficiency)).quantize(Decimal("0.1"))

    @computed_field
    @property
    def quality_score(self) -> Decimal:
        """Calculate quality score based on accuracy and satisfaction."""
        quality_metrics = [
            float(self.attendance_accuracy),
            float(self.sla_compliance_rate),
            float(self.maintenance_cost_efficiency),
        ]
        
        if self.student_feedback_score:
            quality_metrics.append(float(self.student_feedback_score) * 20)  # Convert 5-point to 100-point
        
        average_quality = sum(quality_metrics) / len(quality_metrics)
        return Decimal(str(average_quality)).quantize(Decimal("0.1"))


class ComplaintPerformance(BaseSchema):
    """Detailed complaint handling performance analysis."""
    
    total_complaints: int = Field(..., ge=0, description="Total complaints handled")
    resolved_complaints: int = Field(..., ge=0, description="Successfully resolved")
    pending_complaints: int = Field(..., ge=0, description="Currently pending")
    escalated_complaints: int = Field(..., ge=0, description="Escalated to admin")
    
    # Category breakdown
    complaints_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaints by category",
    )
    
    # Priority breakdown
    complaints_by_priority: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaints by priority level",
    )
    
    # Resolution time analysis
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average resolution time",
    )
    fastest_resolution_hours: Decimal = Field(
        ...,
        ge=0,
        description="Fastest resolution time",
    )
    slowest_resolution_hours: Decimal = Field(
        ...,
        ge=0,
        description="Slowest resolution time",
    )
    median_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Median resolution time",
    )
    
    # SLA performance
    within_sla: int = Field(..., ge=0, description="Complaints resolved within SLA")
    breached_sla: int = Field(..., ge=0, description="SLA breaches")
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="SLA compliance percentage",
    )
    
    # Student satisfaction
    average_complaint_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average student rating for resolved complaints",
    )
    satisfaction_responses: int = Field(
        ...,
        ge=0,
        description="Number of satisfaction responses received",
    )

    @computed_field
    @property
    def resolution_efficiency(self) -> str:
        """Categorize resolution efficiency."""
        avg_hours = float(self.average_resolution_time_hours)
        
        if avg_hours <= 4:
            return "Excellent"
        elif avg_hours <= 12:
            return "Good"
        elif avg_hours <= 24:
            return "Average"
        elif avg_hours <= 48:
            return "Below Average"
        else:
            return "Poor"


class AttendancePerformance(BaseSchema):
    """Attendance management performance details."""
    
    total_attendance_records: int = Field(
        ...,
        ge=0,
        description="Total attendance records created",
    )
    days_attendance_marked: int = Field(
        ...,
        ge=0,
        description="Days attendance was marked",
    )
    days_attendance_missed: int = Field(
        ...,
        ge=0,
        description="Days attendance was not marked",
    )
    
    # Timeliness metrics
    on_time_marking_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of on-time attendance marking",
    )
    average_marking_delay_minutes: Decimal = Field(
        ...,
        ge=0,
        description="Average delay in attendance marking",
    )
    
    # Accuracy metrics
    corrections_made: int = Field(
        ...,
        ge=0,
        description="Number of attendance corrections made",
    )
    accuracy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Attendance accuracy rate",
    )
    
    # Leave management
    leaves_processed: int = Field(
        ...,
        ge=0,
        description="Total leave applications processed",
    )
    leaves_approved: int = Field(
        ...,
        ge=0,
        description="Leave applications approved",
    )
    leaves_rejected: int = Field(
        ...,
        ge=0,
        description="Leave applications rejected",
    )
    average_leave_approval_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average time to process leave applications",
    )

    @computed_field
    @property
    def attendance_consistency(self) -> str:
        """Assess attendance marking consistency."""
        total_days = self.days_attendance_marked + self.days_attendance_missed
        if total_days == 0:
            return "No Data"
        
        consistency_rate = (self.days_attendance_marked / total_days) * 100
        
        if consistency_rate >= 95:
            return "Excellent"
        elif consistency_rate >= 85:
            return "Good"
        elif consistency_rate >= 70:
            return "Average"
        else:
            return "Poor"

    @computed_field
    @property
    def leave_approval_rate(self) -> Decimal:
        """Calculate leave approval rate."""
        if self.leaves_processed == 0:
            return Decimal("0.00")
        
        rate = (self.leaves_approved / self.leaves_processed) * 100
        return Decimal(str(rate)).quantize(Decimal("0.01"))


class MaintenancePerformance(BaseSchema):
    """Maintenance management performance details."""
    
    requests_created: int = Field(
        ...,
        ge=0,
        description="Maintenance requests created",
    )
    requests_completed: int = Field(
        ...,
        ge=0,
        description="Maintenance requests completed",
    )
    requests_pending: int = Field(
        ...,
        ge=0,
        description="Currently pending requests",
    )
    requests_overdue: int = Field(
        ...,
        ge=0,
        description="Overdue maintenance requests",
    )
    
    # Category breakdown
    requests_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Requests by maintenance category",
    )
    
    # Completion time analysis
    average_completion_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average completion time",
    )
    fastest_completion_hours: Decimal = Field(
        ...,
        ge=0,
        description="Fastest completion time",
    )
    slowest_completion_hours: Decimal = Field(
        ...,
        ge=0,
        description="Slowest completion time",
    )
    
    # Cost management
    total_maintenance_cost: Decimal = Field(
        ...,
        ge=0,
        description="Total maintenance costs",
    )
    average_cost_per_request: Decimal = Field(
        ...,
        ge=0,
        description="Average cost per request",
    )
    budget_allocated: Decimal = Field(
        ...,
        ge=0,
        description="Allocated maintenance budget",
    )
    within_budget_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of requests within budget",
    )
    
    # Preventive maintenance
    preventive_tasks_completed: int = Field(
        ...,
        ge=0,
        description="Preventive maintenance tasks completed",
    )
    preventive_tasks_scheduled: int = Field(
        ...,
        ge=0,
        description="Preventive maintenance tasks scheduled",
    )
    preventive_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Preventive maintenance compliance rate",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate maintenance completion rate."""
        total_requests = self.requests_created
        if total_requests == 0:
            return Decimal("100.00")
        
        rate = (self.requests_completed / total_requests) * 100
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def budget_utilization(self) -> Decimal:
        """Calculate budget utilization percentage."""
        if self.budget_allocated == 0:
            return Decimal("0.00")
        
        utilization = (self.total_maintenance_cost / self.budget_allocated) * 100
        return Decimal(str(utilization)).quantize(Decimal("0.01"))
class PerformanceTrendPoint(BaseSchema):
    """Performance trend data point for analysis."""
    
    period: str = Field(
        ...,
        description="Time period identifier",
        examples=["2024-01", "Week 15", "Q1 2024"],
    )
    overall_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall performance score for period",
    )
    complaint_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Complaint handling score",
    )
    attendance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Attendance management score",
    )
    maintenance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Maintenance management score",
    )
    student_satisfaction_score: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=100,
        description="Student satisfaction score",
    )

    @computed_field
    @property
    def trend_indicator(self) -> str:
        """Get trend indicator for the period."""
        # This would typically be calculated by comparing with previous period
        # For now, return based on overall score
        score = float(self.overall_score)
        if score >= 85:
            return "excellent"
        elif score >= 70:
            return "good"
        elif score >= 55:
            return "average"
        else:
            return "needs_improvement"


class PeerComparison(BaseSchema):
    """Comparison with peer supervisors."""
    
    total_supervisors: int = Field(
        ...,
        ge=1,
        description="Total number of supervisors in comparison",
    )
    rank: int = Field(
        ...,
        ge=1,
        description="Supervisor's rank among peers (1 = best)",
    )
    percentile: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Performance percentile",
    )
    
    # Metric comparisons
    metrics_vs_average: Dict[str, "MetricComparison"] = Field(
        default_factory=dict,
        description="Individual metric comparisons",
    )
    
    # Top performers
    top_performer_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Score of top performer",
    )
    score_gap_to_top: Decimal = Field(
        ...,
        ge=0,
        description="Gap to top performer",
    )

    @computed_field
    @property
    def performance_tier(self) -> str:
        """Categorize performance tier among peers."""
        if self.percentile >= 90:
            return "Top Performer"
        elif self.percentile >= 75:
            return "High Performer"
        elif self.percentile >= 50:
            return "Average Performer"
        elif self.percentile >= 25:
            return "Below Average"
        else:
            return "Needs Improvement"


class MetricComparison(BaseSchema):
    """Individual metric comparison with peers."""
    
    metric_name: str = Field(..., description="Name of the metric")
    supervisor_value: Decimal = Field(..., description="Supervisor's value")
    peer_average: Decimal = Field(..., description="Peer average value")
    peer_median: Decimal = Field(..., description="Peer median value")
    best_peer_value: Decimal = Field(..., description="Best peer value")
    difference_from_average: Decimal = Field(
        ...,
        description="Difference from peer average",
    )
    difference_percentage: Decimal = Field(
        ...,
        description="Percentage difference from average",
    )
    better_than_average: bool = Field(
        ...,
        description="Whether supervisor performs better than average",
    )

    @computed_field
    @property
    def performance_vs_peers(self) -> str:
        """Describe performance relative to peers."""
        if self.better_than_average:
            if float(self.difference_percentage) >= 20:
                return "Significantly Above Average"
            elif float(self.difference_percentage) >= 10:
                return "Above Average"
            else:
                return "Slightly Above Average"
        else:
            if float(abs(self.difference_percentage)) >= 20:
                return "Significantly Below Average"
            elif float(abs(self.difference_percentage)) >= 10:
                return "Below Average"
            else:
                return "Slightly Below Average"


class PeriodComparison(BaseSchema):
    """Comparison with previous period."""
    
    previous_period: DateRangeFilter = Field(
        ...,
        description="Previous comparison period",
    )
    current_period: DateRangeFilter = Field(
        ...,
        description="Current period",
    )
    
    # Overall change
    overall_score_change: Decimal = Field(
        ...,
        description="Percentage change in overall score",
    )
    
    # Metric changes
    metric_changes: Dict[str, Decimal] = Field(
        ...,
        description="Percentage change for each metric",
    )
    
    # Improvement/decline indicators
    improved_metrics: List[str] = Field(
        default_factory=list,
        description="Metrics that improved",
    )
    declined_metrics: List[str] = Field(
        default_factory=list,
        description="Metrics that declined",
    )
    stable_metrics: List[str] = Field(
        default_factory=list,
        description="Metrics that remained stable",
    )

    @computed_field
    @property
    def overall_trend(self) -> str:
        """Determine overall performance trend."""
        if self.overall_score_change >= 5:
            return "Improving"
        elif self.overall_score_change <= -5:
            return "Declining"
        else:
            return "Stable"

    @computed_field
    @property
    def improvement_summary(self) -> str:
        """Generate improvement summary."""
        improved_count = len(self.improved_metrics)
        declined_count = len(self.declined_metrics)
        
        if improved_count > declined_count:
            return f"Improved in {improved_count} areas, declined in {declined_count}"
        elif declined_count > improved_count:
            return f"Declined in {declined_count} areas, improved in {improved_count}"
        else:
            return f"Mixed performance: {improved_count} improved, {declined_count} declined"


class PerformanceReport(BaseSchema):
    """Comprehensive performance report."""
    
    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_name: str = Field(..., description="Hostel name")
    report_period: DateRangeFilter = Field(..., description="Report period")
    generated_at: datetime = Field(..., description="Report generation timestamp")
    
    # Summary metrics
    summary: PerformanceMetrics = Field(..., description="Summary performance metrics")
    
    # Detailed breakdown
    complaint_performance: ComplaintPerformance = Field(
        ...,
        description="Complaint handling performance",
    )
    attendance_performance: AttendancePerformance = Field(
        ...,
        description="Attendance management performance",
    )
    maintenance_performance: MaintenancePerformance = Field(
        ...,
        description="Maintenance management performance",
    )
    
    # Trends and comparisons
    performance_trends: List[PerformanceTrendPoint] = Field(
        default_factory=list,
        description="Performance trends over time",
    )
    comparison_with_peers: Optional[PeerComparison] = Field(
        default=None,
        description="Comparison with peer supervisors",
    )
    comparison_with_previous_period: Optional[PeriodComparison] = Field(
        default=None,
        description="Comparison with previous period",
    )
    
    # Insights and recommendations
    strengths: List[str] = Field(
        default_factory=list,
        description="Identified strengths",
    )
    areas_for_improvement: List[str] = Field(
        default_factory=list,
        description="Areas needing improvement",
    )
    recommendations: List[str] = Field(
        default_factory=list,
        description="Specific recommendations",
    )
    
    # Goals and targets
    current_goals: List["PerformanceGoalProgress"] = Field(
        default_factory=list,
        description="Current performance goals progress",
    )

    @computed_field
    @property
    def report_summary(self) -> str:
        """Generate executive summary of the report."""
        score = float(self.summary.overall_performance_score)
        grade = self.summary.performance_grade
        
        summary = f"Overall Performance: {score:.1f}/100 (Grade: {grade}). "
        
        if self.comparison_with_previous_period:
            trend = self.comparison_with_previous_period.overall_trend
            summary += f"Trend: {trend}. "
        
        if self.comparison_with_peers:
            tier = self.comparison_with_peers.performance_tier
            summary += f"Peer Ranking: {tier}."
        
        return summary


class PerformanceReview(BaseCreateSchema):
    """Performance review by admin."""
    
    supervisor_id: str = Field(..., description="Supervisor being reviewed")
    review_period: DateRangeFilter = Field(..., description="Review period")
    
    # Ratings (1-5 scale)
    complaint_handling_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Complaint handling rating",
    )
    attendance_management_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Attendance management rating",
    )
    maintenance_management_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Maintenance management rating",
    )
    communication_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Communication skills rating",
    )
    professionalism_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Professionalism rating",
    )
    reliability_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Reliability rating",
    )
    initiative_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Initiative and proactiveness rating",
    )
    
    # Overall rating
    overall_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Overall performance rating",
    )
    
    # Textual feedback
    strengths: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Supervisor strengths",
    )
    areas_for_improvement: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Areas to improve",
    )
    goals_for_next_period: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Goals for next review period",
    )
    
    # Additional feedback
    admin_comments: Optional[str] = Field(
        default=None,
        max_length=2000,
        description="Additional admin comments",
    )
    
    # Action items
    action_items: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Specific action items (max 10)",
    )
    
    # Development recommendations
    training_recommendations: List[str] = Field(
        default_factory=list,
        description="Recommended training or development",
    )

    @field_validator("action_items", "training_recommendations")
    @classmethod
    def validate_non_empty_items(cls, v: List[str]) -> List[str]:
        """Remove empty items from lists."""
        return [item.strip() for item in v if item.strip()]

    @computed_field
    @property
    def average_rating(self) -> Decimal:
        """Calculate average of all individual ratings."""
        ratings = [
            self.complaint_handling_rating,
            self.attendance_management_rating,
            self.maintenance_management_rating,
            self.communication_rating,
            self.professionalism_rating,
            self.reliability_rating,
            self.initiative_rating,
        ]
        
        average = sum(float(r) for r in ratings) / len(ratings)
        return Decimal(str(average)).quantize(Decimal("0.1"))


class PerformanceReviewResponse(BaseSchema):
    """Performance review response with acknowledgment."""
    
    review_id: str = Field(..., description="Review ID")
    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    reviewed_by: str = Field(..., description="Reviewer ID")
    reviewed_by_name: str = Field(..., description="Reviewer name")
    review_date: date = Field(..., description="Review date")
    
    review_period: DateRangeFilter = Field(..., description="Review period")
    
    # Ratings
    ratings: Dict[str, Decimal] = Field(
        ...,
        description="All ratings by category",
    )
    overall_rating: Decimal = Field(..., description="Overall rating")
    
    # Feedback
    strengths: str = Field(..., description="Identified strengths")
    areas_for_improvement: str = Field(..., description="Areas for improvement")
    goals_for_next_period: str = Field(..., description="Next period goals")
    admin_comments: Optional[str] = Field(default=None, description="Admin comments")
    
    # Actions and development
    action_items: List[str] = Field(default_factory=list, description="Action items")
    training_recommendations: List[str] = Field(
        default_factory=list,
        description="Training recommendations",
    )
    
    # Supervisor acknowledgment
    acknowledged: bool = Field(default=False, description="Supervisor acknowledged review")
    acknowledged_at: Optional[datetime] = Field(
        default=None,
        description="Acknowledgment timestamp",
    )
    supervisor_comments: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Supervisor's response comments",
    )

    @computed_field
    @property
    def performance_level(self) -> str:
        """Categorize performance level based on overall rating."""
        rating = float(self.overall_rating)
        
        if rating >= 4.5:
            return "Outstanding"
        elif rating >= 4.0:
            return "Exceeds Expectations"
        elif rating >= 3.0:
            return "Meets Expectations"
        elif rating >= 2.0:
            return "Below Expectations"
        else:
            return "Unsatisfactory"


class PerformanceGoal(BaseCreateSchema):
    """Set performance goal for supervisor."""
    
    supervisor_id: str = Field(..., description="Supervisor ID")
    goal_name: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Goal name",
    )
    goal_description: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Detailed goal description",
    )
    
    # Measurable target
    metric_name: str = Field(
        ...,
        description="Metric to measure",
        examples=[
            "complaint_resolution_rate",
            "sla_compliance_rate",
            "attendance_punctuality_rate",
        ],
    )
    target_value: Decimal = Field(
        ...,
        description="Target value to achieve",
    )
    current_value: Optional[Decimal] = Field(
        default=None,
        description="Current baseline value",
    )
    
    # Timeline
    start_date: date = Field(..., description="Goal start date")
    end_date: date = Field(..., description="Goal target completion date")
    
    # Priority and category
    priority: str = Field(
        default="medium",
        pattern=r"^(low|medium|high|critical)$",
        description="Goal priority level",
    )
    category: str = Field(
        ...,
        pattern=r"^(complaint|attendance|maintenance|communication|efficiency|quality)$",
        description="Goal category",
    )
    
    # Tracking
    measurement_frequency: str = Field(
        default="weekly",
        pattern=r"^(daily|weekly|monthly)$",
        description="How often to measure progress",
    )

    @field_validator("end_date")
    @classmethod
    def validate_end_date(cls, v: date, info) -> date:
        """Validate end date is after start date."""
        start_date = info.data.get("start_date")
        if start_date and v <= start_date:
            raise ValueError("End date must be after start date")
        return v

    @computed_field
    @property
    def duration_days(self) -> int:
        """Calculate goal duration in days."""
        return (self.end_date - self.start_date).days


class PerformanceGoalProgress(BaseSchema):
    """Track progress on performance goal."""
    
    goal_id: str = Field(..., description="Goal ID")
    goal_name: str = Field(..., description="Goal name")
    metric_name: str = Field(..., description="Metric being measured")
    
    # Values
    target_value: Decimal = Field(..., description="Target value")
    current_value: Decimal = Field(..., description="Current achieved value")
    baseline_value: Optional[Decimal] = Field(
        default=None,
        description="Starting baseline value",
    )
    
    # Progress calculation
    progress_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Progress percentage towards goal",
    )
    
    # Timeline
    start_date: date = Field(..., description="Goal start date")
    end_date: date = Field(..., description="Goal end date")
    days_remaining: int = Field(..., ge=0, description="Days remaining to achieve goal")
    
    # Status
    status: str = Field(
        ...,
        pattern=r"^(on_track|at_risk|behind|completed|failed|paused)$",
        description="Goal progress status",
    )
    
    # Tracking
    last_updated: datetime = Field(..., description="Last progress update")
    measurement_history: List[Dict[str, any]] = Field(
        default_factory=list,
        description="Historical measurements",
    )

    @computed_field
    @property
    def days_elapsed(self) -> int:
        """Calculate days elapsed since goal start."""
        return (date.today() - self.start_date).days

    @computed_field
    @property
    def time_progress_percentage(self) -> Decimal:
        """Calculate time progress percentage."""
        total_days = (self.end_date - self.start_date).days
        if total_days == 0:
            return Decimal("100.00")
        
        elapsed_days = self.days_elapsed
        time_progress = min(100, (elapsed_days / total_days) * 100)
        return Decimal(str(time_progress)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_on_schedule(self) -> bool:
        """Check if goal progress is on schedule."""
        time_progress = float(self.time_progress_percentage)
        actual_progress = float(self.progress_percentage)
        
        # Allow 10% tolerance
        return actual_progress >= (time_progress - 10)

    @computed_field
    @property
    def projected_completion_date(self) -> Optional[date]:
        """Project completion date based on current progress rate."""
        if self.progress_percentage == 0:
            return None
        
        days_elapsed = self.days_elapsed
        if days_elapsed == 0:
            return None
        
        progress_rate = float(self.progress_percentage) / days_elapsed
        if progress_rate == 0:
            return None
        
        remaining_progress = 100 - float(self.progress_percentage)
        days_to_complete = remaining_progress / progress_rate
        
        from datetime import timedelta
        projected_date = date.today() + timedelta(days=int(days_to_complete))
        return projected_date


class PerformanceInsights(BaseSchema):
    """AI-generated performance insights and recommendations."""
    
    supervisor_id: str = Field(..., description="Supervisor ID")
    analysis_period: DateRangeFilter = Field(..., description="Analysis period")
    generated_at: datetime = Field(..., description="Insights generation timestamp")
    
    # Key insights
    top_strengths: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 identified strengths",
    )
    improvement_opportunities: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 improvement opportunities",
    )
    
    # Trend analysis
    performance_trends: Dict[str, str] = Field(
        default_factory=dict,
        description="Trend analysis for each metric",
    )
    
    # Predictive insights
    risk_factors: List[str] = Field(
        default_factory=list,
        description="Identified risk factors",
    )
    success_indicators: List[str] = Field(
        default_factory=list,
        description="Positive success indicators",
    )
    
    # Recommendations
    immediate_actions: List[str] = Field(
        default_factory=list,
        max_length=3,
        description="Immediate actions recommended",
    )
    long_term_development: List[str] = Field(
        default_factory=list,
        max_length=3,
        description="Long-term development recommendations",
    )
    
    # Benchmarking insights
    peer_comparison_insights: List[str] = Field(
        default_factory=list,
        description="Insights from peer comparison",
    )
    
    # Confidence scores
    insight_confidence: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Confidence level in insights (0-100)",
    )

    @computed_field
    @property
    def overall_assessment(self) -> str:
        """Generate overall performance assessment."""
        strengths_count = len(self.top_strengths)
        improvements_count = len(self.improvement_opportunities)
        risks_count = len(self.risk_factors)
        
        if strengths_count > improvements_count and risks_count == 0:
            return "Strong performer with consistent results"
        elif improvements_count > strengths_count:
            return "Developing performer with growth potential"
        elif risks_count > 0:
            return "Requires attention and support"
        else:
            return "Balanced performer with mixed results"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_permissions.py ---
# --- File: app/schemas/supervisor/supervisor_permissions.py ---
"""
Supervisor permission schemas with comprehensive access control.

Provides granular permission management with templates, bulk operations,
and audit tracking. Optimized for performance and maintainability.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Any, Dict, List, Literal, Optional, Set

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema

__all__ = [
    "SupervisorPermissions",
    "PermissionUpdate",
    "PermissionCheckRequest",
    "PermissionCheckResponse",
    "BulkPermissionUpdate",
    "PermissionTemplate",
    "ApplyPermissionTemplate",
    "PermissionAuditLog",
    "PermissionConstants",
]


class PermissionConstants:
    """Centralized constants for permission management."""
    
    # Permission categories
    COMPLAINT_PERMISSIONS = {
        "can_manage_complaints",
        "can_assign_complaints",
        "can_resolve_complaints",
        "can_close_complaints",
    }
    
    ATTENDANCE_PERMISSIONS = {
        "can_record_attendance",
        "can_approve_leaves",
        "can_edit_past_attendance",
    }
    
    MAINTENANCE_PERMISSIONS = {
        "can_manage_maintenance",
        "can_assign_maintenance",
        "can_approve_maintenance_costs",
        "can_schedule_preventive_maintenance",
    }
    
    COMMUNICATION_PERMISSIONS = {
        "can_create_announcements",
        "can_send_push_notifications",
        "can_send_sms",
        "can_send_email",
    }
    
    # Threshold defaults
    DEFAULT_MAINTENANCE_THRESHOLD = Decimal("5000.00")
    DEFAULT_LEAVE_APPROVAL_DAYS = 3
    DEFAULT_PAST_ATTENDANCE_EDIT_DAYS = 7
    
    # Permission templates
    JUNIOR_SUPERVISOR_TEMPLATE = "junior_supervisor"
    SENIOR_SUPERVISOR_TEMPLATE = "senior_supervisor"
    HEAD_SUPERVISOR_TEMPLATE = "head_supervisor"
    LIMITED_ACCESS_TEMPLATE = "limited_access"
    
    # Validation constraints
    MIN_LEAVE_APPROVAL_DAYS = 1
    MAX_LEAVE_APPROVAL_DAYS = 10
    MIN_PAST_EDIT_DAYS = 1
    MAX_PAST_EDIT_DAYS = 30
    MIN_MAINTENANCE_THRESHOLD = Decimal("0.00")
    MAX_MAINTENANCE_THRESHOLD = Decimal("100000.00")


class SupervisorPermissions(BaseSchema):
    """
    Comprehensive supervisor permission configuration.
    
    Provides granular control over supervisor capabilities with
    dependency validation and threshold-based permissions.
    """

    # ============ Complaint Management ============
    can_manage_complaints: bool = Field(
        default=True,
        description="Can view and manage complaints",
    )
    can_assign_complaints: bool = Field(
        default=True,
        description="Can assign complaints to staff/vendors",
    )
    can_resolve_complaints: bool = Field(
        default=True,
        description="Can mark complaints as resolved",
    )
    can_close_complaints: bool = Field(
        default=False,
        description="Can permanently close complaints (admin-level)",
    )
    complaint_priority_limit: Optional[Literal["low", "medium", "high", "urgent"]] = Field(
        default=None,
        description="Maximum priority level can handle independently",
    )

    # ============ Attendance Management ============
    can_record_attendance: bool = Field(
        default=True,
        description="Can record daily student attendance",
    )
    can_approve_leaves: bool = Field(
        default=True,
        description="Can approve leave applications",
    )
    max_leave_days_approval: int = Field(
        default=PermissionConstants.DEFAULT_LEAVE_APPROVAL_DAYS,
        ge=PermissionConstants.MIN_LEAVE_APPROVAL_DAYS,
        le=PermissionConstants.MAX_LEAVE_APPROVAL_DAYS,
        description="Maximum days of leave can approve independently",
    )
    can_edit_past_attendance: bool = Field(
        default=False,
        description="Can edit past attendance records",
    )
    past_attendance_edit_days: int = Field(
        default=PermissionConstants.DEFAULT_PAST_ATTENDANCE_EDIT_DAYS,
        ge=PermissionConstants.MIN_PAST_EDIT_DAYS,
        le=PermissionConstants.MAX_PAST_EDIT_DAYS,
        description="Days back can edit attendance (if permitted)",
    )

    # ============ Maintenance Management ============
    can_manage_maintenance: bool = Field(
        default=True,
        description="Can create and manage maintenance requests",
    )
    can_assign_maintenance: bool = Field(
        default=True,
        description="Can assign maintenance tasks to staff",
    )
    can_approve_maintenance_costs: bool = Field(
        default=False,
        description="Can approve maintenance costs",
    )
    maintenance_approval_threshold: Decimal = Field(
        default=PermissionConstants.DEFAULT_MAINTENANCE_THRESHOLD,
        ge=PermissionConstants.MIN_MAINTENANCE_THRESHOLD,
        le=PermissionConstants.MAX_MAINTENANCE_THRESHOLD,
        max_digits=10,
        decimal_places=2,
        description="Maximum repair cost can approve independently (INR)",
    )
    can_schedule_preventive_maintenance: bool = Field(
        default=True,
        description="Can schedule preventive maintenance",
    )

    # ============ Mess/Menu Management ============
    can_update_mess_menu: bool = Field(
        default=True,
        description="Can update daily mess menu",
    )
    menu_requires_approval: bool = Field(
        default=False,
        description="Menu changes require admin approval",
    )
    can_publish_special_menus: bool = Field(
        default=False,
        description="Can publish special occasion menus",
    )
    can_manage_meal_preferences: bool = Field(
        default=True,
        description="Can manage student meal preferences",
    )

    # ============ Communication ============
    can_create_announcements: bool = Field(
        default=True,
        description="Can create announcements",
    )
    urgent_announcement_requires_approval: bool = Field(
        default=True,
        description="Urgent announcements require admin approval",
    )
    can_send_push_notifications: bool = Field(
        default=False,
        description="Can send push notifications to students",
    )
    can_send_sms: bool = Field(
        default=False,
        description="Can send SMS to students",
    )
    can_send_email: bool = Field(
        default=True,
        description="Can send emails to students",
    )

    # ============ Student Management ============
    can_view_student_profiles: bool = Field(
        default=True,
        description="Can view student profiles and details",
    )
    can_update_student_contacts: bool = Field(
        default=True,
        description="Can update student contact information",
    )
    can_view_student_payments: bool = Field(
        default=True,
        description="Can view student payment status (read-only)",
    )
    can_view_student_documents: bool = Field(
        default=True,
        description="Can view student documents",
    )
    can_verify_student_documents: bool = Field(
        default=False,
        description="Can verify student documents",
    )

    # ============ Financial Access ============
    can_view_financial_reports: bool = Field(
        default=False,
        description="Can view detailed financial reports",
    )
    can_view_revenue_data: bool = Field(
        default=False,
        description="Can view revenue and collection data",
    )
    can_view_expense_data: bool = Field(
        default=False,
        description="Can view expense data",
    )
    can_generate_payment_reminders: bool = Field(
        default=True,
        description="Can generate payment reminders",
    )

    # ============ Room and Bed Management ============
    can_view_room_availability: bool = Field(
        default=True,
        description="Can view room and bed availability",
    )
    can_suggest_room_transfers: bool = Field(
        default=True,
        description="Can suggest room transfers (requires admin approval)",
    )
    can_assign_beds: bool = Field(
        default=False,
        description="Can assign beds to students",
    )
    can_update_room_status: bool = Field(
        default=True,
        description="Can update room maintenance status",
    )

    # ============ Booking Management ============
    can_view_bookings: bool = Field(
        default=True,
        description="Can view booking requests",
    )
    can_contact_visitors: bool = Field(
        default=True,
        description="Can contact visitors for inquiries",
    )
    can_approve_bookings: bool = Field(
        default=False,
        description="Can approve booking requests",
    )

    # ============ Reporting ============
    can_generate_reports: bool = Field(
        default=True,
        description="Can generate operational reports",
    )
    can_export_data: bool = Field(
        default=False,
        description="Can export data (CSV, Excel)",
    )

    # ============ Security and Access ============
    can_view_cctv: bool = Field(
        default=False,
        description="Can access CCTV footage",
    )
    can_manage_visitor_log: bool = Field(
        default=True,
        description="Can manage visitor entry/exit log",
    )

    @model_validator(mode="after")
    def validate_permission_dependencies(self) -> "SupervisorPermissions":
        """
        Validate permission dependencies and ensure consistency.
        
        Returns:
            Self with validated and corrected permissions
        """
        # Complaint management hierarchy
        if not self.can_manage_complaints:
            self.can_assign_complaints = False
            self.can_resolve_complaints = False
            self.can_close_complaints = False
        
        # Maintenance management hierarchy
        if not self.can_manage_maintenance:
            self.can_assign_maintenance = False
            self.can_approve_maintenance_costs = False
            self.can_schedule_preventive_maintenance = False
        
        # Menu management hierarchy
        if not self.can_update_mess_menu:
            self.can_publish_special_menus = False
        
        # Financial access hierarchy
        if not self.can_view_financial_reports:
            # If can't view reports, shouldn't see detailed revenue/expense
            pass  # Allow viewing revenue/expense without full report access
        
        return self

    @model_validator(mode="after")
    def validate_threshold_consistency(self) -> "SupervisorPermissions":
        """
        Validate threshold-based permissions.
        
        Returns:
            Self with validated thresholds
        """
        # If can't approve costs, threshold is irrelevant
        if not self.can_approve_maintenance_costs:
            self.maintenance_approval_threshold = Decimal("0.00")
        
        # If can't approve leaves, max days is irrelevant
        if not self.can_approve_leaves:
            self.max_leave_days_approval = 0
        
        # If can't edit past attendance, days limit is irrelevant
        if not self.can_edit_past_attendance:
            self.past_attendance_edit_days = 0
        
        return self

    def get_permission_summary(self) -> Dict[str, int]:
        """
        Get summary of permissions by category.
        
        Returns:
            Dictionary with permission counts per category
        """
        summary = {
            "complaint_permissions": 0,
            "attendance_permissions": 0,
            "maintenance_permissions": 0,
            "communication_permissions": 0,
            "student_permissions": 0,
            "financial_permissions": 0,
            "room_permissions": 0,
            "booking_permissions": 0,
            "reporting_permissions": 0,
            "security_permissions": 0,
        }
        
        # Count enabled permissions per category
        if self.can_manage_complaints:
            summary["complaint_permissions"] += 1
        if self.can_assign_complaints:
            summary["complaint_permissions"] += 1
        if self.can_resolve_complaints:
            summary["complaint_permissions"] += 1
        if self.can_close_complaints:
            summary["complaint_permissions"] += 1
        
        if self.can_record_attendance:
            summary["attendance_permissions"] += 1
        if self.can_approve_leaves:
            summary["attendance_permissions"] += 1
        if self.can_edit_past_attendance:
            summary["attendance_permissions"] += 1
        
        if self.can_manage_maintenance:
            summary["maintenance_permissions"] += 1
        if self.can_assign_maintenance:
            summary["maintenance_permissions"] += 1
        if self.can_approve_maintenance_costs:
            summary["maintenance_permissions"] += 1
        if self.can_schedule_preventive_maintenance:
            summary["maintenance_permissions"] += 1
        
        if self.can_create_announcements:
            summary["communication_permissions"] += 1
        if self.can_send_push_notifications:
            summary["communication_permissions"] += 1
        if self.can_send_sms:
            summary["communication_permissions"] += 1
        if self.can_send_email:
            summary["communication_permissions"] += 1
        
        if self.can_view_student_profiles:
            summary["student_permissions"] += 1
        if self.can_update_student_contacts:
            summary["student_permissions"] += 1
        if self.can_view_student_payments:
            summary["student_permissions"] += 1
        if self.can_view_student_documents:
            summary["student_permissions"] += 1
        if self.can_verify_student_documents:
            summary["student_permissions"] += 1
        
        if self.can_view_financial_reports:
            summary["financial_permissions"] += 1
        if self.can_view_revenue_data:
            summary["financial_permissions"] += 1
        if self.can_view_expense_data:
            summary["financial_permissions"] += 1
        if self.can_generate_payment_reminders:
            summary["financial_permissions"] += 1
        
        if self.can_view_room_availability:
            summary["room_permissions"] += 1
        if self.can_suggest_room_transfers:
            summary["room_permissions"] += 1
        if self.can_assign_beds:
            summary["room_permissions"] += 1
        if self.can_update_room_status:
            summary["room_permissions"] += 1
        
        if self.can_view_bookings:
            summary["booking_permissions"] += 1
        if self.can_contact_visitors:
            summary["booking_permissions"] += 1
        if self.can_approve_bookings:
            summary["booking_permissions"] += 1
        
        if self.can_generate_reports:
            summary["reporting_permissions"] += 1
        if self.can_export_data:
            summary["reporting_permissions"] += 1
        
        if self.can_view_cctv:
            summary["security_permissions"] += 1
        if self.can_manage_visitor_log:
            summary["security_permissions"] += 1
        
        return summary


class PermissionUpdate(BaseUpdateSchema):
    """
    Update supervisor permissions with validation.
    
    Allows partial permission updates with audit trail support.
    """

    permissions: Dict[str, bool | int | Decimal] = Field(
        ...,
        description="Permission key-value pairs to update",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for permission change",
    )

    @field_validator("permissions")
    @classmethod
    def validate_permissions(cls, v: Dict[str, bool | int | Decimal]) -> Dict[str, bool | int | Decimal]:
        """
        Validate permission keys and value types.
        
        Args:
            v: Permissions dictionary
            
        Returns:
            Validated permissions
            
        Raises:
            ValueError: If invalid keys or value types
        """
        valid_keys = set(SupervisorPermissions.model_fields.keys())
        provided_keys = set(v.keys())
        
        # Check for invalid keys
        invalid_keys = provided_keys - valid_keys
        if invalid_keys:
            raise ValueError(
                f"Invalid permission keys: {', '.join(sorted(invalid_keys))}"
            )
        
        # Validate value types based on field annotations
        for key, value in v.items():
            field_info = SupervisorPermissions.model_fields.get(key)
            if not field_info:
                continue
            
            # Get expected type
            expected_type = field_info.annotation
            
            # Handle Optional types
            if hasattr(expected_type, "__origin__"):
                # Extract actual type from Optional
                args = getattr(expected_type, "__args__", ())
                if args:
                    expected_type = args[0]
            
            # Validate type
            if expected_type == bool:
                if not isinstance(value, bool):
                    raise ValueError(f"{key} must be a boolean value")
            elif expected_type == int:
                if not isinstance(value, int) or isinstance(value, bool):
                    raise ValueError(f"{key} must be an integer value")
            elif expected_type == Decimal:
                if not isinstance(value, (Decimal, int, float)):
                    raise ValueError(f"{key} must be a numeric value")
                # Convert to Decimal if needed
                if not isinstance(value, Decimal):
                    v[key] = Decimal(str(value))
        
        return v


class PermissionCheckRequest(BaseCreateSchema):
    """
    Request to check specific permission.
    
    Validates supervisor permission with optional context for
    threshold-based permissions.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID to check",
    )
    permission_key: str = Field(
        ...,
        description="Permission to check",
        examples=[
            "can_resolve_complaints",
            "can_approve_leaves",
            "can_approve_maintenance_costs",
        ],
    )
    context: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Additional context for permission check",
        examples=[
            {"amount": 7500},
            {"leave_days": 5},
            {"priority": "urgent"},
        ],
    )

    @field_validator("permission_key")
    @classmethod
    def validate_permission_key(cls, v: str) -> str:
        """
        Validate permission key exists.
        
        Args:
            v: Permission key to validate
            
        Returns:
            Validated permission key
            
        Raises:
            ValueError: If permission key doesn't exist
        """
        valid_keys = set(SupervisorPermissions.model_fields.keys())
        if v not in valid_keys:
            raise ValueError(
                f"Invalid permission key: {v}. "
                f"Valid keys: {', '.join(sorted(valid_keys))}"
            )
        return v


class PermissionCheckResponse(BaseSchema):
    """
    Response for permission check.
    
    Provides detailed information about permission status and
    any threshold restrictions.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    permission_key: str = Field(..., description="Permission checked")
    has_permission: bool = Field(
        ...,
        description="Whether supervisor has permission",
    )
    requires_approval: bool = Field(
        default=False,
        description="Whether action requires admin approval",
    )
    threshold_exceeded: bool = Field(
        default=False,
        description="Whether threshold limit is exceeded",
    )
    message: Optional[str] = Field(
        default=None,
        description="Explanation message",
    )

    # Threshold details
    threshold_value: Optional[Decimal] = Field(
        default=None,
        description="Configured threshold value",
    )
    actual_value: Optional[Decimal] = Field(
        default=None,
        description="Actual value being checked",
    )
    allowed_value: Optional[Decimal] = Field(
        default=None,
        description="Maximum allowed value",
    )

    def get_detailed_message(self) -> str:
        """
        Get detailed human-readable message.
        
        Returns:
            Detailed explanation of permission status
        """
        if self.has_permission and not self.threshold_exceeded:
            return f"Permission granted for {self.permission_key}"
        
        if self.threshold_exceeded:
            return (
                f"Threshold exceeded: {self.actual_value} exceeds "
                f"allowed limit of {self.threshold_value}. Admin approval required."
            )
        
        if self.requires_approval:
            return f"Action requires admin approval for {self.permission_key}"
        
        return f"Permission denied for {self.permission_key}"


class BulkPermissionUpdate(BaseUpdateSchema):
    """
    Update permissions for multiple supervisors.
    
    Efficient batch permission updates with validation and audit support.
    """

    supervisor_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Supervisor IDs to update (max 50)",
    )
    permissions: Dict[str, bool | int | Decimal] = Field(
        ...,
        description="Permissions to update for all supervisors",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for bulk permission change",
    )
    effective_date: Optional[datetime] = Field(
        default=None,
        description="Effective date for permission change",
    )

    @field_validator("supervisor_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[str]) -> List[str]:
        """Ensure supervisor IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Supervisor IDs must be unique")
        return v

    # Reuse permission validation
    _validate_permissions = field_validator("permissions")(
        PermissionUpdate.validate_permissions.__func__
    )


class PermissionTemplate(BaseSchema):
    """
    Permission template for quick assignment.
    
    Predefined permission sets for different supervisor levels.
    Supports system templates and custom templates.
    """

    template_id: str = Field(
        ...,
        description="Template unique identifier",
    )
    template_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Template name",
    )
    description: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Template description",
    )
    permissions: SupervisorPermissions = Field(
        ...,
        description="Permission configuration",
    )
    is_system_template: bool = Field(
        default=False,
        description="System-defined template (cannot be modified)",
    )
    is_active: bool = Field(
        default=True,
        description="Template is active and can be used",
    )
    created_at: Optional[datetime] = Field(
        default=None,
        description="Template creation timestamp",
    )
    created_by: Optional[str] = Field(
        default=None,
        description="Admin who created template",
    )
    updated_at: Optional[datetime] = Field(
        default=None,
        description="Last update timestamp",
    )

    @classmethod
    def get_system_templates(cls) -> Dict[str, "PermissionTemplate"]:
        """
        Get predefined system templates.
        
        Returns:
            Dictionary of template name to template object
        """
        templates = {}
        
        # Junior Supervisor Template - Basic permissions
        templates[PermissionConstants.JUNIOR_SUPERVISOR_TEMPLATE] = cls(
            template_id="sys_junior_supervisor",
            template_name="Junior Supervisor",
            description="Basic permissions for junior supervisors",
            permissions=SupervisorPermissions(
                can_manage_complaints=True,
                can_assign_complaints=False,
                can_resolve_complaints=True,
                can_close_complaints=False,
                can_record_attendance=True,
                can_approve_leaves=True,
                max_leave_days_approval=2,
                can_edit_past_attendance=False,
                can_manage_maintenance=True,
                can_assign_maintenance=False,
                can_approve_maintenance_costs=False,
                can_update_mess_menu=True,
                can_publish_special_menus=False,
                can_create_announcements=True,
                urgent_announcement_requires_approval=True,
                can_send_email=True,
                can_send_sms=False,
                can_send_push_notifications=False,
                can_view_student_profiles=True,
                can_view_student_payments=True,
                can_view_financial_reports=False,
                can_generate_reports=True,
                can_export_data=False,
            ),
            is_system_template=True,
        )
        
        # Senior Supervisor Template - Extended permissions
        templates[PermissionConstants.SENIOR_SUPERVISOR_TEMPLATE] = cls(
            template_id="sys_senior_supervisor",
            template_name="Senior Supervisor",
            description="Extended permissions for senior supervisors",
            permissions=SupervisorPermissions(
                can_manage_complaints=True,
                can_assign_complaints=True,
                can_resolve_complaints=True,
                can_close_complaints=False,
                can_record_attendance=True,
                can_approve_leaves=True,
                max_leave_days_approval=5,
                can_edit_past_attendance=True,
                past_attendance_edit_days=7,
                can_manage_maintenance=True,
                can_assign_maintenance=True,
                can_approve_maintenance_costs=True,
                maintenance_approval_threshold=Decimal("10000.00"),
                can_schedule_preventive_maintenance=True,
                can_update_mess_menu=True,
                can_publish_special_menus=True,
                can_create_announcements=True,
                urgent_announcement_requires_approval=False,
                can_send_email=True,
                can_send_sms=True,
                can_send_push_notifications=False,
                can_view_student_profiles=True,
                can_view_student_payments=True,
                can_view_financial_reports=True,
                can_view_revenue_data=True,
                can_generate_reports=True,
                can_export_data=True,
                can_suggest_room_transfers=True,
                can_assign_beds=False,
            ),
            is_system_template=True,
        )
        
        # Head Supervisor Template - Full permissions
        templates[PermissionConstants.HEAD_SUPERVISOR_TEMPLATE] = cls(
            template_id="sys_head_supervisor",
            template_name="Head Supervisor",
            description="Full permissions for head supervisors",
            permissions=SupervisorPermissions(
                can_manage_complaints=True,
                can_assign_complaints=True,
                can_resolve_complaints=True,
                can_close_complaints=True,
                can_record_attendance=True,
                can_approve_leaves=True,
                max_leave_days_approval=10,
                can_edit_past_attendance=True,
                past_attendance_edit_days=30,
                can_manage_maintenance=True,
                can_assign_maintenance=True,
                can_approve_maintenance_costs=True,
                maintenance_approval_threshold=Decimal("50000.00"),
                can_schedule_preventive_maintenance=True,
                can_update_mess_menu=True,
                can_publish_special_menus=True,
                can_create_announcements=True,
                urgent_announcement_requires_approval=False,
                can_send_email=True,
                can_send_sms=True,
                can_send_push_notifications=True,
                can_view_student_profiles=True,
                can_update_student_contacts=True,
                can_view_student_payments=True,
                can_view_student_documents=True,
                can_verify_student_documents=True,
                can_view_financial_reports=True,
                can_view_revenue_data=True,
                can_view_expense_data=True,
                can_generate_reports=True,
                can_export_data=True,
                can_view_room_availability=True,
                can_suggest_room_transfers=True,
                can_assign_beds=True,
                can_update_room_status=True,
                can_approve_bookings=True,
                can_view_cctv=True,
            ),
            is_system_template=True,
        )
        
        # Limited Access Template - Minimal permissions
        templates[PermissionConstants.LIMITED_ACCESS_TEMPLATE] = cls(
            template_id="sys_limited_access",
            template_name="Limited Access",
            description="Minimal permissions for restricted access",
            permissions=SupervisorPermissions(
                can_manage_complaints=True,
                can_assign_complaints=False,
                can_resolve_complaints=False,
                can_close_complaints=False,
                can_record_attendance=True,
                can_approve_leaves=False,
                can_edit_past_attendance=False,
                can_manage_maintenance=True,
                can_assign_maintenance=False,
                can_approve_maintenance_costs=False,
                can_update_mess_menu=False,
                can_create_announcements=False,
                can_send_email=False,
                can_send_sms=False,
                can_send_push_notifications=False,
                can_view_student_profiles=True,
                can_view_student_payments=False,
                can_view_financial_reports=False,
                can_generate_reports=False,
                can_export_data=False,
            ),
            is_system_template=True,
        )
        
        return templates


class ApplyPermissionTemplate(BaseCreateSchema):
    """
    Apply permission template to supervisor(s).
    
    Supports both override and merge modes with validation.
    """

    supervisor_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Supervisor IDs to apply template to (max 50)",
    )
    template_name: str = Field(
        ...,
        description="Template name to apply",
    )
    override_existing: bool = Field(
        default=True,
        description="Override existing permissions completely",
    )
    merge_permissions: bool = Field(
        default=False,
        description="Merge with existing permissions (upgrade only)",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for applying template",
    )

    @field_validator("supervisor_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[str]) -> List[str]:
        """Ensure supervisor IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Supervisor IDs must be unique")
        return v

    @model_validator(mode="after")
    def validate_mode_selection(self) -> "ApplyPermissionTemplate":
        """
        Ensure only one application mode is selected.
        
        Returns:
            Self with validated mode
            
        Raises:
            ValueError: If both modes are selected
        """
        if self.override_existing and self.merge_permissions:
            raise ValueError(
                "Cannot both override and merge permissions. "
                "Choose either override_existing=True OR merge_permissions=True"
            )
        
        if not self.override_existing and not self.merge_permissions:
            # Default to override
            self.override_existing = True
        
        return self


class PermissionAuditLog(BaseSchema):
    """
    Permission change audit log.
    
    Comprehensive tracking of permission modifications for compliance
    and security auditing.
    """

    audit_id: str = Field(..., description="Audit log ID")
    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")

    # Change metadata
    changed_by: str = Field(..., description="Admin who made changes")
    changed_by_name: str = Field(..., description="Admin name")
    changed_at: datetime = Field(..., description="Change timestamp")

    # Change details
    permission_changes: Dict[str, Dict[str, Any]] = Field(
        ...,
        description="Permission changes in format {permission: {old: value, new: value}}",
    )
    change_type: Literal["grant", "revoke", "update", "template_applied"] = Field(
        ...,
        description="Type of change",
    )
    reason: Optional[str] = Field(
        default=None,
        description="Reason for change",
    )

    # Context
    ip_address: Optional[str] = Field(
        default=None,
        description="IP address of change initiator",
    )
    user_agent: Optional[str] = Field(
        default=None,
        description="User agent string",
    )
    template_applied: Optional[str] = Field(
        default=None,
        description="Template name if template was applied",
    )

    # Approval tracking (if applicable)
    requires_approval: bool = Field(
        default=False,
        description="Whether change requires approval",
    )
    approved_by: Optional[str] = Field(
        default=None,
        description="Admin who approved change",
    )
    approved_at: Optional[datetime] = Field(
        default=None,
        description="Approval timestamp",
    )

    @computed_field
    @property
    def changes_count(self) -> int:
        """Count of permission changes made."""
        return len(self.permission_changes)

    @computed_field
    @property
    def change_summary(self) -> str:
        """Human-readable summary of changes."""
        if self.template_applied:
            return f"Applied template '{self.template_applied}' ({self.changes_count} permissions changed)"
        
        return f"{self.change_type.title()}: {self.changes_count} permission(s) modified"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_profile.py ---
# --- File: app/schemas/supervisor/supervisor_profile.py ---
"""
Supervisor profile schemas with employment and personal information.

Provides comprehensive profile management with employment history,
performance summaries, and personal preferences.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import EmploymentType, SupervisorStatus

__all__ = [
    "SupervisorProfile",
    "SupervisorEmployment",
    "PerformanceSummary",
    "SupervisorProfileUpdate",
    "EmploymentHistory",
    "SupervisorPreferences",
]


class SupervisorEmployment(BaseSchema):
    """Detailed supervisor employment information."""
    
    employee_id: Optional[str] = Field(
        default=None,
        description="Employee/Staff ID",
    )
    join_date: date = Field(..., description="Joining date")
    employment_type: EmploymentType = Field(..., description="Employment type")
    shift_timing: Optional[str] = Field(
        default=None,
        description="Shift timing or working hours",
    )
    designation: Optional[str] = Field(
        default=None,
        description="Job designation/title",
    )
    
    # Current status
    status: SupervisorStatus = Field(..., description="Current employment status")
    is_active: bool = Field(..., description="Active employment status")
    
    # Contract details
    contract_start_date: Optional[date] = Field(
        default=None,
        description="Contract start date (for contract employees)",
    )
    contract_end_date: Optional[date] = Field(
        default=None,
        description="Contract end date (for contract employees)",
    )
    
    # Termination details (if applicable)
    termination_date: Optional[date] = Field(
        default=None,
        description="Termination date",
    )
    termination_reason: Optional[str] = Field(
        default=None,
        description="Termination reason",
    )
    eligible_for_rehire: Optional[bool] = Field(
        default=None,
        description="Eligible for rehire",
    )
    
    # Assignment details
    assigned_by: str = Field(..., description="Admin who assigned")
    assigned_by_name: str = Field(..., description="Admin name")
    assigned_date: date = Field(..., description="Assignment date")
    
    # Compensation (admin view only)
    salary: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Monthly salary",
    )
    last_salary_revision: Optional[date] = Field(
        default=None,
        description="Last salary revision date",
    )

    @computed_field
    @property
    def tenure_days(self) -> int:
        """Calculate total tenure in days."""
        end_date = self.termination_date or date.today()
        return (end_date - self.join_date).days

    @computed_field
    @property
    def tenure_display(self) -> str:
        """Get human-readable tenure."""
        days = self.tenure_days
        
        if days < 30:
            return f"{days} days"
        
        months = days // 30
        if months < 12:
            return f"{months} months"
        
        years = months // 12
        remaining_months = months % 12
        
        if remaining_months == 0:
            return f"{years} {'year' if years == 1 else 'years'}"
        
        return f"{years}y {remaining_months}m"

    @computed_field
    @property
    def is_contract_employee(self) -> bool:
        """Check if employee is on contract."""
        return self.employment_type == EmploymentType.CONTRACT

    @computed_field
    @property
    def contract_status(self) -> Optional[str]:
        """Get contract status for contract employees."""
        if not self.is_contract_employee or not self.contract_end_date:
            return None
        
        today = date.today()
        days_remaining = (self.contract_end_date - today).days
        
        if days_remaining < 0:
            return "Expired"
        elif days_remaining == 0:
            return "Expires Today"
        elif days_remaining <= 30:
            return f"Expires in {days_remaining} days"
        else:
            return "Active"


class PerformanceSummary(BaseSchema):
    """Performance summary for supervisor profile."""
    
    # Complaint handling
    total_complaints_resolved: int = Field(
        default=0,
        ge=0,
        description="Total complaints resolved",
    )
    average_resolution_time_hours: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average resolution time in hours",
    )
    sla_compliance_rate: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        le=100,
        description="SLA compliance rate percentage",
    )
    
    # Attendance management
    total_attendance_records: int = Field(
        default=0,
        ge=0,
        description="Total attendance records created",
    )
    attendance_punctuality_rate: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        le=100,
        description="On-time attendance marking rate",
    )
    
    # Maintenance management
    total_maintenance_requests: int = Field(
        default=0,
        ge=0,
        description="Total maintenance requests handled",
    )
    maintenance_completion_rate: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        le=100,
        description="Maintenance completion rate",
    )
    
    # Current month performance
    current_month_complaints: int = Field(
        default=0,
        ge=0,
        description="Complaints handled this month",
    )
    current_month_attendance_records: int = Field(
        default=0,
        ge=0,
        description="Attendance records this month",
    )
    current_month_maintenance: int = Field(
        default=0,
        ge=0,
        description="Maintenance requests this month",
    )
    
    # Overall ratings
    performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Latest performance rating (1-5 scale)",
    )
    last_performance_review: Optional[date] = Field(
        default=None,
        description="Last performance review date",
    )
    
    # Student feedback
    student_satisfaction_score: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average student satisfaction rating",
    )
    student_feedback_count: int = Field(
        default=0,
        ge=0,
        description="Number of student feedback responses",
    )

    @computed_field
    @property
    def overall_efficiency_score(self) -> Decimal:
        """Calculate overall efficiency score."""
        scores = [
            float(self.sla_compliance_rate),
            float(self.attendance_punctuality_rate),
            float(self.maintenance_completion_rate),
        ]
        
        average_score = sum(scores) / len(scores)
        return Decimal(str(average_score)).quantize(Decimal("0.1"))

    @computed_field
    @property
    def performance_level(self) -> str:
        """Categorize performance level."""
        if not self.performance_rating:
            return "Not Rated"
        
        rating = float(self.performance_rating)
        if rating >= 4.5:
            return "Outstanding"
        elif rating >= 4.0:
            return "Excellent"
        elif rating >= 3.5:
            return "Good"
        elif rating >= 3.0:
            return "Satisfactory"
        elif rating >= 2.0:
            return "Needs Improvement"
        else:
            return "Unsatisfactory"


class EmploymentHistory(BaseSchema):
    """Employment history entry."""
    
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    start_date: date = Field(..., description="Assignment start date")
    end_date: Optional[date] = Field(
        default=None,
        description="Assignment end date (null if current)",
    )
    designation: Optional[str] = Field(
        default=None,
        description="Designation during this period",
    )
    employment_type: EmploymentType = Field(
        ...,
        description="Employment type during this period",
    )
    reason_for_change: Optional[str] = Field(
        default=None,
        description="Reason for assignment change/end",
    )
    performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Performance rating for this period",
    )

    @computed_field
    @property
    def duration_days(self) -> int:
        """Calculate duration of this assignment."""
        end = self.end_date or date.today()
        return (end - self.start_date).days

    @computed_field
    @property
    def is_current(self) -> bool:
        """Check if this is the current assignment."""
        return self.end_date is None


class SupervisorPreferences(BaseSchema):
    """Supervisor personal preferences and settings."""
    
    # Notification preferences
    email_notifications: bool = Field(
        default=True,
        description="Enable email notifications",
    )
    sms_notifications: bool = Field(
        default=True,
        description="Enable SMS notifications",
    )
    push_notifications: bool = Field(
        default=True,
        description="Enable push notifications",
    )
    
    # Notification types
    complaint_notifications: bool = Field(
        default=True,
        description="Receive complaint notifications",
    )
    maintenance_notifications: bool = Field(
        default=True,
        description="Receive maintenance notifications",
    )
    attendance_reminders: bool = Field(
        default=True,
        description="Receive attendance marking reminders",
    )
    admin_announcements: bool = Field(
        default=True,
        description="Receive admin announcements",
    )
    
    # Dashboard preferences
    dashboard_refresh_interval: int = Field(
        default=300,
        ge=60,
        le=3600,
        description="Dashboard auto-refresh interval in seconds",
    )
    default_view: str = Field(
        default="dashboard",
        pattern=r"^(dashboard|complaints|attendance|maintenance|reports)$",
        description="Default view on login",
    )
    
    # Language and locale
    preferred_language: str = Field(
        default="en",
        pattern=r"^(en|hi|ta|te|bn|mr|gu)$",
        description="Preferred language",
    )
    timezone: str = Field(
        default="Asia/Kolkata",
        description="Preferred timezone",
    )
    
    # Working hours
    work_start_time: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Work start time (HH:MM)",
    )
    work_end_time: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Work end time (HH:MM)",
    )


class SupervisorProfile(BaseSchema):
    """Complete supervisor profile with all information."""
    
    id: str = Field(..., description="Supervisor ID")
    user_id: str = Field(..., description="User ID")
    
    # Personal information
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email address")
    phone: str = Field(..., description="Phone number")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )
    
    # Current assignment
    hostel_id: str = Field(..., description="Current hostel ID")
    hostel_name: str = Field(..., description="Current hostel name")
    
    # Employment details
    employment: SupervisorEmployment = Field(
        ...,
        description="Current employment information",
    )
    
    # Employment history
    employment_history: List[EmploymentHistory] = Field(
        default_factory=list,
        description="Employment history",
    )
    
    # Permissions
    permissions: dict = Field(
        default_factory=dict,
        description="Current permission settings",
    )
    
    # Performance
    performance_summary: PerformanceSummary = Field(
        ...,
        description="Performance summary",
    )
    
    # Preferences
    preferences: SupervisorPreferences = Field(
        ...,
        description="Personal preferences",
    )
    
    # Activity tracking
    last_login: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp",
    )
    total_logins: int = Field(
        default=0,
        ge=0,
        description="Total login count",
    )
    last_activity: Optional[datetime] = Field(
        default=None,
        description="Last activity timestamp",
    )

    @computed_field
    @property
    def total_experience_days(self) -> int:
        """Calculate total experience across all assignments."""
        total_days = 0
        for history in self.employment_history:
            total_days += history.duration_days
        
        # Add current assignment
        total_days += self.employment.tenure_days
        return total_days

    @computed_field
    @property
    def experience_display(self) -> str:
        """Get human-readable total experience."""
        days = self.total_experience_days
        
        if days < 30:
            return f"{days} days"
        
        months = days // 30
        if months < 12:
            return f"{months} months"
        
        years = months // 12
        remaining_months = months % 12
        
        if remaining_months == 0:
            return f"{years} {'year' if years == 1 else 'years'}"
        
        return f"{years}y {remaining_months}m"

    @computed_field
    @property
    def hostels_worked(self) -> int:
        """Count number of different hostels worked at."""
        hostel_ids = {self.hostel_id}
        for history in self.employment_history:
            hostel_ids.add(history.hostel_id)
        return len(hostel_ids)


class SupervisorProfileUpdate(BaseUpdateSchema):
    """Update supervisor profile (supervisor can update own profile)."""
    
    # Contact updates (may require admin approval)
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number",
    )
    
    # Preferences updates
    preferences: Optional[SupervisorPreferences] = Field(
        default=None,
        description="Updated preferences",
    )
    
    # Emergency contact
    emergency_contact_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone",
    )
    emergency_contact_relation: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Emergency contact relation",
    )
    
    # Personal notes
    notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Personal notes",
    )

    @field_validator("phone", "emergency_contact_phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone numbers."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_response.py ---
# --- File: app/schemas/supervisor/supervisor_response.py ---
"""
Supervisor response schemas for API responses.

Provides optimized response formats with computed properties
and efficient data serialization.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from functools import cached_property
from typing import Dict, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import EmploymentType, SupervisorStatus

__all__ = [
    "SupervisorResponse",
    "SupervisorDetail",
    "SupervisorListItem",
    "SupervisorSummary",
    "SupervisorEmploymentInfo",
    "SupervisorStatistics",
]


class SupervisorResponse(BaseResponseSchema):
    """
    Standard supervisor response schema.
    
    Optimized for general API responses with essential information.
    """

    user_id: str = Field(..., description="User ID")
    full_name: str = Field(..., description="Supervisor full name")
    email: str = Field(..., description="Email address")
    phone: str = Field(..., description="Phone number")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )

    # Assignment
    assigned_hostel_id: str = Field(..., description="Assigned hostel ID")
    hostel_name: str = Field(..., description="Hostel name")

    # Employment
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    join_date: date = Field(..., description="Joining date")
    employment_type: EmploymentType = Field(..., description="Employment type")
    designation: Optional[str] = Field(default=None, description="Designation")

    # Status
    status: SupervisorStatus = Field(..., description="Current status")
    is_active: bool = Field(..., description="Active status")

    # Assignment metadata
    assigned_by: str = Field(..., description="Admin who assigned")
    assigned_date: date = Field(..., description="Assignment date")

    @computed_field
    @property
    def tenure_days(self) -> int:
        """Calculate tenure in days since joining."""
        return (date.today() - self.join_date).days

    @computed_field
    @property
    def tenure_months(self) -> int:
        """Calculate approximate tenure in months."""
        return self.tenure_days // 30

    @computed_field
    @property
    def is_probation(self) -> bool:
        """Check if supervisor is in probation period (first 3 months)."""
        return self.tenure_months < 3


class SupervisorDetail(BaseResponseSchema):
    """
    Detailed supervisor information.
    
    Comprehensive profile with all attributes and computed metrics.
    """

    # User information
    user_id: str = Field(..., description="User ID")
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    gender: Optional[str] = Field(default=None, description="Gender")
    date_of_birth: Optional[date] = Field(default=None, description="Date of birth")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )

    # Hostel assignment
    assigned_hostel_id: str = Field(..., description="Assigned hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    assigned_by: str = Field(..., description="Admin user ID who assigned")
    assigned_by_name: str = Field(..., description="Admin name")
    assigned_date: date = Field(..., description="Assignment date")

    # Employment details
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    join_date: date = Field(..., description="Joining date")
    employment_type: EmploymentType = Field(..., description="Employment type")
    shift_timing: Optional[str] = Field(default=None, description="Shift timing")
    designation: Optional[str] = Field(default=None, description="Designation")
    salary: Optional[Decimal] = Field(
        default=None,
        description="Monthly salary (admin view only)",
    )

    # Status
    status: SupervisorStatus = Field(..., description="Current status")
    is_active: bool = Field(..., description="Active status")

    # Termination information
    termination_date: Optional[date] = Field(
        default=None,
        description="Termination date",
    )
    termination_reason: Optional[str] = Field(
        default=None,
        description="Termination reason",
    )
    eligible_for_rehire: Optional[bool] = Field(
        default=None,
        description="Rehire eligibility",
    )

    # Suspension information
    suspension_start_date: Optional[date] = Field(
        default=None,
        description="Suspension start date",
    )
    suspension_end_date: Optional[date] = Field(
        default=None,
        description="Suspension end date",
    )
    suspension_reason: Optional[str] = Field(
        default=None,
        description="Suspension reason",
    )

    # Permissions (optimized structure)
    permissions: Dict[str, bool | int | Decimal] = Field(
        default_factory=dict,
        description="Permission settings",
    )

    # Performance metrics (aggregated)
    total_complaints_resolved: int = Field(
        default=0,
        ge=0,
        description="Total complaints resolved",
    )
    average_resolution_time_hours: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average complaint resolution time",
    )
    total_attendance_records: int = Field(
        default=0,
        ge=0,
        description="Total attendance records created",
    )
    total_maintenance_requests: int = Field(
        default=0,
        ge=0,
        description="Total maintenance requests",
    )
    last_performance_review: Optional[date] = Field(
        default=None,
        description="Last performance review date",
    )
    performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Latest performance rating",
    )

    # Activity tracking
    last_login: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp",
    )
    total_logins: int = Field(
        default=0,
        ge=0,
        description="Total login count",
    )
    last_activity: Optional[datetime] = Field(
        default=None,
        description="Last activity timestamp",
    )

    # Administrative notes
    notes: Optional[str] = Field(
        default=None,
        description="Administrative notes",
    )

    @computed_field
    @property
    def age(self) -> Optional[int]:
        """Calculate age from date of birth."""
        if not self.date_of_birth:
            return None
        
        today = date.today()
        age = (
            today.year
            - self.date_of_birth.year
            - ((today.month, today.day) < (self.date_of_birth.month, self.date_of_birth.day))
        )
        return age

    @computed_field
    @property
    def tenure_months(self) -> int:
        """Calculate tenure in complete months."""
        return (date.today() - self.join_date).days // 30

    @computed_field
    @property
    def tenure_years(self) -> int:
        """Calculate tenure in complete years."""
        return self.tenure_months // 12

    @computed_field
    @property
    def is_probation(self) -> bool:
        """Check if supervisor is in probation period."""
        return self.tenure_months < 3

    @computed_field
    @property
    def can_work(self) -> bool:
        """Check if supervisor is currently allowed to work."""
        return self.is_active and self.status == SupervisorStatus.ACTIVE

    @computed_field
    @property
    def suspension_days_remaining(self) -> Optional[int]:
        """Calculate remaining suspension days if currently suspended."""
        if self.status != SupervisorStatus.SUSPENDED or not self.suspension_end_date:
            return None
        
        remaining = (self.suspension_end_date - date.today()).days
        return max(0, remaining)


class SupervisorListItem(BaseSchema):
    """
    Supervisor list item for efficient list rendering.
    
    Minimal information optimized for table/grid views.
    """

    id: str = Field(..., description="Supervisor ID")
    user_id: str = Field(..., description="User ID")
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )

    # Assignment
    hostel_name: str = Field(..., description="Assigned hostel")
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    designation: Optional[str] = Field(default=None, description="Designation")

    # Employment
    employment_type: EmploymentType = Field(..., description="Employment type")
    join_date: date = Field(..., description="Joining date")

    # Status
    status: SupervisorStatus = Field(..., description="Status")
    is_active: bool = Field(..., description="Active status")

    # Performance (current month)
    performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Performance rating",
    )
    complaints_resolved_this_month: int = Field(
        default=0,
        ge=0,
        description="Complaints resolved this month",
    )

    # Activity
    last_login: Optional[datetime] = Field(
        default=None,
        description="Last login",
    )

    @computed_field
    @property
    def tenure_months(self) -> int:
        """Calculate tenure in months."""
        return (date.today() - self.join_date).days // 30

    @computed_field
    @property
    def display_status(self) -> str:
        """Get human-readable status."""
        status_map = {
            SupervisorStatus.ACTIVE: "Active",
            SupervisorStatus.ON_LEAVE: "On Leave",
            SupervisorStatus.SUSPENDED: "Suspended",
            SupervisorStatus.TERMINATED: "Terminated",
        }
        return status_map.get(self.status, self.status.value)


class SupervisorSummary(BaseSchema):
    """
    Supervisor summary for dashboards.
    
    Optimized for quick overview with key metrics.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    designation: Optional[str] = Field(default=None, description="Designation")

    # Status
    status: SupervisorStatus = Field(..., description="Status")
    is_active: bool = Field(..., description="Active status")
    shift_timing: Optional[str] = Field(default=None, description="Shift timing")

    # Current month metrics
    complaints_handled_this_month: int = Field(
        default=0,
        ge=0,
        description="Complaints handled",
    )
    complaints_resolved_this_month: int = Field(
        default=0,
        ge=0,
        description="Complaints resolved",
    )
    attendance_records_this_month: int = Field(
        default=0,
        ge=0,
        description="Attendance records",
    )
    maintenance_requests_this_month: int = Field(
        default=0,
        ge=0,
        description="Maintenance requests",
    )

    # Activity
    last_active: Optional[datetime] = Field(
        default=None,
        description="Last activity",
    )
    is_online: bool = Field(
        default=False,
        description="Currently online",
    )

    @computed_field
    @property
    def complaint_resolution_rate(self) -> Decimal:
        """Calculate complaint resolution rate percentage."""
        if self.complaints_handled_this_month == 0:
            return Decimal("100.00")
        
        rate = (
            self.complaints_resolved_this_month
            / self.complaints_handled_this_month
            * 100
        )
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def activity_status(self) -> str:
        """Get human-readable activity status."""
        if self.is_online:
            return "Online"
        
        if not self.last_active:
            return "Never"
        
        hours_ago = (datetime.now() - self.last_active).total_seconds() / 3600
        
        if hours_ago < 1:
            return "Active recently"
        elif hours_ago < 24:
            return f"Active {int(hours_ago)}h ago"
        else:
            days_ago = int(hours_ago / 24)
            return f"Active {days_ago}d ago"


class SupervisorEmploymentInfo(BaseSchema):
    """
    Detailed employment information.
    
    Comprehensive contract and compensation details.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")

    # Employment details
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    join_date: date = Field(..., description="Joining date")
    employment_type: EmploymentType = Field(..., description="Employment type")
    designation: Optional[str] = Field(default=None, description="Designation")
    shift_timing: Optional[str] = Field(default=None, description="Shift timing")

    # Contract
    contract_start_date: Optional[date] = Field(
        default=None,
        description="Contract start date",
    )
    contract_end_date: Optional[date] = Field(
        default=None,
        description="Contract end date",
    )
    is_contract_active: bool = Field(
        default=True,
        description="Contract active status",
    )

    # Compensation
    salary: Optional[Decimal] = Field(
        default=None,
        description="Monthly salary",
    )
    last_salary_revision: Optional[date] = Field(
        default=None,
        description="Last salary revision date",
    )

    # Status
    status: SupervisorStatus = Field(..., description="Current status")
    is_active: bool = Field(..., description="Active status")

    # Assignment
    assigned_hostel: str = Field(..., description="Assigned hostel")
    assigned_by: str = Field(..., description="Admin who assigned")
    assigned_date: date = Field(..., description="Assignment date")

    # Termination
    termination_date: Optional[date] = Field(
        default=None,
        description="Termination date",
    )
    termination_reason: Optional[str] = Field(
        default=None,
        description="Termination reason",
    )
    eligible_for_rehire: Optional[bool] = Field(
        default=None,
        description="Rehire eligibility",
    )

    @computed_field
    @property
    def tenure_days(self) -> int:
        """Calculate total tenure in days."""
        end_date = self.termination_date or date.today()
        return (end_date - self.join_date).days

    @computed_field
    @property
    def tenure_display(self) -> str:
        """Get human-readable tenure."""
        days = self.tenure_days
        
        if days < 30:
            return f"{days} days"
        
        months = days // 30
        if months < 12:
            return f"{months} months"
        
        years = months // 12
        remaining_months = months % 12
        
        if remaining_months == 0:
            return f"{years} {'year' if years == 1 else 'years'}"
        
        return f"{years}y {remaining_months}m"

    @computed_field
    @property
    def is_contract_expiring_soon(self) -> bool:
        """Check if contract expires within 30 days."""
        if not self.contract_end_date or not self.is_contract_active:
            return False
        
        days_until_expiry = (self.contract_end_date - date.today()).days
        return 0 < days_until_expiry <= 30

    @computed_field
    @property
    def contract_status(self) -> str:
        """Get contract status description."""
        if not self.contract_end_date:
            return "Permanent"
        
        if not self.is_contract_active:
            return "Expired"
        
        days_remaining = (self.contract_end_date - date.today()).days
        
        if days_remaining < 0:
            return "Expired"
        elif days_remaining == 0:
            return "Expires today"
        elif days_remaining <= 7:
            return f"Expires in {days_remaining} days (urgent)"
        elif days_remaining <= 30:
            return f"Expires in {days_remaining} days"
        else:
            return f"Active (expires {self.contract_end_date.strftime('%b %Y')})"


class SupervisorStatistics(BaseSchema):
    """
    Comprehensive statistics and performance metrics.
    
    Aggregated data for reporting and analysis.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    calculation_period: str = Field(
        ...,
        description="Period for statistics",
        examples=["Last 30 days", "This month", "2024-01"],
    )

    # Complaint metrics
    total_complaints_assigned: int = Field(
        default=0,
        ge=0,
        description="Total complaints assigned",
    )
    complaints_resolved: int = Field(
        default=0,
        ge=0,
        description="Complaints resolved",
    )
    complaints_pending: int = Field(
        default=0,
        ge=0,
        description="Complaints pending",
    )
    average_resolution_time_hours: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average resolution time",
    )
    sla_compliance_rate: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        le=100,
        description="SLA compliance percentage",
    )

    # Attendance metrics
    attendance_records_created: int = Field(
        default=0,
        ge=0,
        description="Attendance records created",
    )
    attendance_marked_on_time: int = Field(
        default=0,
        ge=0,
        description="Attendance marked on time",
    )
    leaves_processed: int = Field(
        default=0,
        ge=0,
        description="Leave requests processed",
    )

    # Maintenance metrics
    maintenance_requests_created: int = Field(
        default=0,
        ge=0,
        description="Maintenance requests created",
    )
    maintenance_completed: int = Field(
        default=0,
        ge=0,
        description="Maintenance completed",
    )
    average_maintenance_completion_hours: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average completion time",
    )

    # Communication metrics
    announcements_created: int = Field(
        default=0,
        ge=0,
        description="Announcements created",
    )
    announcement_reach: int = Field(
        default=0,
        ge=0,
        description="Total students reached",
    )

    # Activity metrics
    total_logins: int = Field(
        default=0,
        ge=0,
        description="Total logins",
    )
    active_days: int = Field(
        default=0,
        ge=0,
        description="Days with activity",
    )
    average_response_time_minutes: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average response time",
    )

    # Overall performance
    overall_performance_score: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Calculated performance score",
    )

    @computed_field
    @property
    def complaint_resolution_rate(self) -> Decimal:
        """Calculate complaint resolution rate percentage."""
        if self.total_complaints_assigned == 0:
            return Decimal("100.00")
        
        rate = (self.complaints_resolved / self.total_complaints_assigned * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def maintenance_completion_rate(self) -> Decimal:
        """Calculate maintenance completion rate percentage."""
        if self.maintenance_requests_created == 0:
            return Decimal("100.00")
        
        rate = (self.maintenance_completed / self.maintenance_requests_created * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def attendance_punctuality_rate(self) -> Decimal:
        """Calculate attendance marking punctuality rate."""
        if self.attendance_records_created == 0:
            return Decimal("100.00")
        
        rate = (self.attendance_marked_on_time / self.attendance_records_created * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def activity_rate(self) -> Decimal:
        """Calculate activity rate (active days / total days in period)."""
        # Assuming 30 days for "This month" or "Last 30 days"
        # In real implementation, this would be calculated from period
        total_days = 30
        
        if self.active_days == 0:
            return Decimal("0.00")
        
        rate = (self.active_days / total_days * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def performance_grade(self) -> str:
        """Get performance grade based on overall score."""
        score = float(self.overall_performance_score)
        
        if score >= 90:
            return "A+ (Excellent)"
        elif score >= 80:
            return "A (Very Good)"
        elif score >= 70:
            return "B+ (Good)"
        elif score >= 60:
            return "B (Satisfactory)"
        elif score >= 50:
            return "C (Needs Improvement)"
        else:
            return "D (Poor)"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\__init__.py ---
"""
Supervisor schemas package
"""
from app.schemas.supervisor.supervisor_base import (
    SupervisorBase,
    SupervisorCreate,
    SupervisorUpdate
)
from app.schemas.supervisor.supervisor_response import (
    SupervisorResponse,
    SupervisorDetail,
    SupervisorListItem
)
from app.schemas.supervisor.supervisor_profile import (
    SupervisorProfile,
    SupervisorEmployment,
    SupervisorProfileUpdate
)
from app.schemas.supervisor.supervisor_permissions import (
    SupervisorPermissions,
    PermissionUpdate,
    PermissionCheckRequest,
    PermissionCheckResponse
)
from app.schemas.supervisor.supervisor_assignment import (
    SupervisorAssignment,
    AssignmentRequest,
    AssignmentUpdate,
    RevokeAssignmentRequest
)
from app.schemas.supervisor.supervisor_activity import (
    SupervisorActivityLog,
    ActivitySummary,
    ActivityDetail,
    ActivityFilterParams
)
from app.schemas.supervisor.supervisor_dashboard import (
    SupervisorDashboard,
    DashboardMetrics,
    TaskSummary
)
from app.schemas.supervisor.supervisor_performance import (
    PerformanceMetrics,
    PerformanceReport,
    PerformanceReview
)

__all__ = [
    # Base
    "SupervisorBase",
    "SupervisorCreate",
    "SupervisorUpdate",
    
    # Response
    "SupervisorResponse",
    "SupervisorDetail",
    "SupervisorListItem",
    
    # Profile
    "SupervisorProfile",
    "SupervisorEmployment",
    "SupervisorProfileUpdate",
    
    # Permissions
    "SupervisorPermissions",
    "PermissionUpdate",
    "PermissionCheckRequest",
    "PermissionCheckResponse",
    
    # Assignment
    "SupervisorAssignment",
    "AssignmentRequest",
    "AssignmentUpdate",
    "RevokeAssignmentRequest",
    
    # Activity
    "SupervisorActivityLog",
    "ActivitySummary",
    "ActivityDetail",
    "ActivityFilterParams",
    
    # Dashboard
    "SupervisorDashboard",
    "DashboardMetrics",
    "TaskSummary",
    
    # Performance
    "PerformanceMetrics",
    "PerformanceReport",
    "PerformanceReview",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_activity.py ---
# --- File: app/schemas/supervisor/supervisor_activity.py ---
"""
Supervisor activity and audit log schemas with enhanced tracking.

Provides comprehensive activity monitoring, audit trails, and
performance analytics with optimized filtering and export capabilities.
"""

from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseFilterSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import AuditActionCategory
from app.schemas.common.filters import DateTimeRangeFilter

__all__ = [
    "SupervisorActivityLog",
    "ActivityDetail",
    "ActivitySummary",
    "ActivityFilterParams",
    "ActivityExportRequest",
    "TopActivity",
    "ActivityTimelinePoint",
    "ActivityMetrics",
]


class SupervisorActivityLog(BaseResponseSchema):
    """
    Supervisor activity log entry with enhanced metadata.
    
    Tracks all supervisor actions with context and performance data.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Action details
    action_type: str = Field(
        ...,
        description="Specific action performed",
        examples=[
            "complaint_resolved",
            "attendance_marked",
            "maintenance_created",
            "announcement_published",
        ],
    )
    action_category: AuditActionCategory = Field(
        ...,
        description="Action category for grouping",
    )
    action_description: str = Field(
        ...,
        description="Human-readable description",
    )
    
    # Entity affected
    entity_type: Optional[str] = Field(
        default=None,
        description="Type of entity affected",
        examples=["complaint", "student", "room", "maintenance_request"],
    )
    entity_id: Optional[str] = Field(
        default=None,
        description="ID of affected entity",
    )
    entity_name: Optional[str] = Field(
        default=None,
        description="Name/title of affected entity",
    )
    
    # Context and metadata
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional action details and context",
    )
    
    # Technical details
    ip_address: Optional[str] = Field(
        default=None,
        description="IP address of action origin",
    )
    user_agent: Optional[str] = Field(
        default=None,
        description="User agent string",
    )
    device_type: Optional[str] = Field(
        default=None,
        description="Device type (mobile/desktop/tablet)",
    )
    
    # Performance tracking
    response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Action response time in milliseconds",
    )
    success: bool = Field(
        default=True,
        description="Whether action completed successfully",
    )
    error_message: Optional[str] = Field(
        default=None,
        description="Error message if action failed",
    )

    @computed_field
    @property
    def action_display_name(self) -> str:
        """Get human-readable action name."""
        action_names = {
            "complaint_resolved": "Resolved Complaint",
            "complaint_assigned": "Assigned Complaint",
            "attendance_marked": "Marked Attendance",
            "leave_approved": "Approved Leave",
            "maintenance_created": "Created Maintenance Request",
            "maintenance_assigned": "Assigned Maintenance",
            "announcement_published": "Published Announcement",
            "student_contacted": "Contacted Student",
            "room_status_updated": "Updated Room Status",
            "menu_updated": "Updated Menu",
        }
        return action_names.get(self.action_type, self.action_type.replace("_", " ").title())


class ActivityDetail(BaseSchema):
    """
    Detailed activity information with change tracking.
    
    Comprehensive activity record with before/after states.
    """

    activity_id: str = Field(..., description="Activity ID")
    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    
    timestamp: datetime = Field(..., description="Activity timestamp")
    action_type: str = Field(..., description="Action type")
    action_category: AuditActionCategory = Field(..., description="Action category")
    action_description: str = Field(..., description="Action description")
    
    # Entity details
    entity_type: Optional[str] = Field(default=None, description="Entity type")
    entity_id: Optional[str] = Field(default=None, description="Entity ID")
    entity_name: Optional[str] = Field(default=None, description="Entity name")
    
    # Change tracking
    old_values: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Previous values before change",
    )
    new_values: Optional[Dict[str, Any]] = Field(
        default=None,
        description="New values after change",
    )
    
    # Context
    ip_address: Optional[str] = Field(default=None, description="IP address")
    user_agent: Optional[str] = Field(default=None, description="User agent")
    location: Optional[str] = Field(default=None, description="Geographic location")
    device_info: Optional[Dict[str, str]] = Field(
        default=None,
        description="Device information",
    )
    
    # Result
    success: bool = Field(default=True, description="Action success status")
    error_message: Optional[str] = Field(default=None, description="Error message")
    response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Response time in milliseconds",
    )
    
    # Impact assessment
    impact_level: Optional[str] = Field(
        default=None,
        pattern=r"^(low|medium|high|critical)$",
        description="Impact level of the action",
    )
    affected_users_count: Optional[int] = Field(
        default=None,
        ge=0,
        description="Number of users affected by action",
    )

    @computed_field
    @property
    def has_changes(self) -> bool:
        """Check if activity involved data changes."""
        return bool(self.old_values or self.new_values)

    @computed_field
    @property
    def change_summary(self) -> Optional[str]:
        """Generate summary of changes made."""
        if not self.has_changes:
            return None
        
        if not self.old_values or not self.new_values:
            return "Data modified"
        
        changes = []
        for key in self.new_values:
            if key in self.old_values and self.old_values[key] != self.new_values[key]:
                changes.append(f"{key}: {self.old_values[key]}  {self.new_values[key]}")
        
        return "; ".join(changes) if changes else "No changes detected"


class TopActivity(BaseSchema):
    """
    Top activity item for summary reports.
    
    Represents frequently performed activities.
    """

    action_type: str = Field(..., description="Action type")
    action_category: str = Field(..., description="Action category")
    action_display_name: str = Field(..., description="Human-readable name")
    count: int = Field(..., ge=0, description="Number of times performed")
    last_performed: datetime = Field(..., description="Last time performed")
    average_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Average response time",
    )
    success_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Success rate percentage",
    )

    @computed_field
    @property
    def frequency_description(self) -> str:
        """Get frequency description."""
        if self.count >= 100:
            return "Very Frequent"
        elif self.count >= 50:
            return "Frequent"
        elif self.count >= 20:
            return "Regular"
        elif self.count >= 10:
            return "Occasional"
        else:
            return "Rare"


class ActivityTimelinePoint(BaseSchema):
    """
    Activity timeline data point for trend analysis.
    
    Represents activity volume over time periods.
    """

    timestamp: datetime = Field(..., description="Time period")
    action_count: int = Field(..., ge=0, description="Total actions in period")
    unique_action_types: int = Field(..., ge=0, description="Unique action types")
    success_rate: float = Field(..., ge=0, le=100, description="Success rate %")
    
    # Category breakdown
    categories: Dict[str, int] = Field(
        default_factory=dict,
        description="Action count by category",
    )
    
    # Performance metrics
    average_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Average response time",
    )

    @computed_field
    @property
    def activity_level(self) -> str:
        """Categorize activity level."""
        if self.action_count >= 50:
            return "High"
        elif self.action_count >= 20:
            return "Medium"
        elif self.action_count >= 5:
            return "Low"
        else:
            return "Minimal"


class ActivityMetrics(BaseSchema):
    """
    Comprehensive activity metrics for performance analysis.
    
    Aggregated metrics for supervisor activity assessment.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    period_start: datetime = Field(..., description="Metrics period start")
    period_end: datetime = Field(..., description="Metrics period end")
    
    # Volume metrics
    total_actions: int = Field(..., ge=0, description="Total actions performed")
    unique_action_types: int = Field(..., ge=0, description="Unique action types")
    active_days: int = Field(..., ge=0, description="Days with activity")
    
    # Performance metrics
    overall_success_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Overall success rate percentage",
    )
    average_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Average response time",
    )
    
    # Category distribution
    actions_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Action count by category",
    )
    
    # Peak activity analysis
    peak_hour: Optional[int] = Field(
        default=None,
        ge=0,
        le=23,
        description="Hour with most activity (0-23)",
    )
    peak_day_of_week: Optional[int] = Field(
        default=None,
        ge=0,
        le=6,
        description="Day of week with most activity (0=Monday)",
    )
    
    # Efficiency metrics
    actions_per_day: float = Field(
        ...,
        ge=0,
        description="Average actions per active day",
    )
    response_time_trend: Optional[str] = Field(
        default=None,
        pattern=r"^(improving|stable|declining)$",
        description="Response time trend",
    )

    @computed_field
    @property
    def activity_score(self) -> float:
        """Calculate overall activity score (0-100)."""
        # Weighted scoring based on volume, consistency, and performance
        volume_score = min(self.total_actions / 100 * 40, 40)  # Max 40 points
        consistency_score = min(self.active_days / 30 * 30, 30)  # Max 30 points
        performance_score = self.overall_success_rate * 0.3  # Max 30 points
        
        return round(volume_score + consistency_score + performance_score, 2)

    @computed_field
    @property
    def productivity_level(self) -> str:
        """Categorize productivity level."""
        score = self.activity_score
        if score >= 80:
            return "Excellent"
        elif score >= 60:
            return "Good"
        elif score >= 40:
            return "Average"
        elif score >= 20:
            return "Below Average"
        else:
            return "Poor"


class ActivitySummary(BaseSchema):
    """
    Activity summary for supervisor dashboard.
    
    High-level activity overview with key insights.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    period_start: datetime = Field(..., description="Summary period start")
    period_end: datetime = Field(..., description="Summary period end")
    
    total_actions: int = Field(..., ge=0, description="Total actions")
    
    # Category breakdown
    actions_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of actions by category",
    )
    
    # Type breakdown
    actions_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of actions by type",
    )
    
    # Top activities
    top_activities: List[TopActivity] = Field(
        default_factory=list,
        max_length=10,
        description="Most frequent activities",
    )
    
    # Activity timeline
    activity_timeline: List[ActivityTimelinePoint] = Field(
        default_factory=list,
        description="Activity over time",
    )
    
    # Performance insights
    peak_hours: List[int] = Field(
        default_factory=list,
        description="Hours with most activity (0-23)",
    )
    most_productive_day: Optional[str] = Field(
        default=None,
        description="Day of week with highest activity",
    )
    
    # Efficiency metrics
    average_daily_actions: float = Field(
        ...,
        ge=0,
        description="Average actions per day",
    )
    success_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Overall success rate",
    )

    @computed_field
    @property
    def most_common_activity(self) -> Optional[str]:
        """Get most frequently performed activity."""
        if not self.top_activities:
            return None
        return self.top_activities[0].action_display_name

    @computed_field
    @property
    def activity_consistency(self) -> str:
        """Assess activity consistency."""
        if not self.activity_timeline:
            return "Unknown"
        
        # Calculate coefficient of variation
        counts = [point.action_count for point in self.activity_timeline]
        if not counts:
            return "No Data"
        
        mean_count = sum(counts) / len(counts)
        if mean_count == 0:
            return "No Activity"
        
        variance = sum((x - mean_count) ** 2 for x in counts) / len(counts)
        cv = (variance ** 0.5) / mean_count
        
        if cv < 0.3:
            return "Very Consistent"
        elif cv < 0.6:
            return "Consistent"
        elif cv < 1.0:
            return "Moderately Variable"
        else:
            return "Highly Variable"


class ActivityFilterParams(BaseFilterSchema):
    """
    Enhanced filter parameters for activity logs.
    
    Comprehensive filtering with performance optimizations.
    """

    # Supervisor filters
    supervisor_id: Optional[str] = Field(
        default=None,
        description="Filter by specific supervisor",
    )
    supervisor_ids: Optional[List[str]] = Field(
        default=None,
        max_length=20,
        description="Filter by multiple supervisors (max 20)",
    )
    
    # Hostel filter
    hostel_id: Optional[str] = Field(
        default=None,
        description="Filter by hostel",
    )
    
    # Time range
    date_range: Optional[DateTimeRangeFilter] = Field(
        default=None,
        description="Filter by date/time range",
    )
    
    # Action filters
    action_category: Optional[AuditActionCategory] = Field(
        default=None,
        description="Filter by action category",
    )
    action_categories: Optional[List[AuditActionCategory]] = Field(
        default=None,
        max_length=10,
        description="Filter by multiple categories",
    )
    action_type: Optional[str] = Field(
        default=None,
        description="Filter by specific action type",
    )
    action_types: Optional[List[str]] = Field(
        default=None,
        max_length=20,
        description="Filter by multiple action types",
    )
    
    # Entity filter
    entity_type: Optional[str] = Field(
        default=None,
        description="Filter by entity type",
    )
    entity_id: Optional[str] = Field(
        default=None,
        description="Filter by specific entity",
    )
    
    # Success filter
    success_only: Optional[bool] = Field(
        default=None,
        description="Show only successful actions",
    )
    failed_only: Optional[bool] = Field(
        default=None,
        description="Show only failed actions",
    )
    
    # Performance filters
    min_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Minimum response time filter",
    )
    max_response_time_ms: Optional[int] = Field(
        default=None,
        ge=0,
        description="Maximum response time filter",
    )
    
    # Device filters
    device_type: Optional[str] = Field(
        default=None,
        pattern=r"^(mobile|desktop|tablet)$",
        description="Filter by device type",
    )
    
    # Pagination and sorting
    page: int = Field(default=1, ge=1, description="Page number")
    page_size: int = Field(default=50, ge=1, le=100, description="Items per page")
    sort_by: str = Field(
        default="created_at",
        pattern=r"^(created_at|action_type|success|response_time_ms)$",
        description="Sort field",
    )
    sort_order: str = Field(
        default="desc",
        pattern=r"^(asc|desc)$",
        description="Sort order",
    )

    @field_validator("supervisor_ids")
    @classmethod
    def validate_supervisor_ids(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """Validate supervisor IDs list."""
        if v is not None:
            # Remove duplicates while preserving order
            seen = set()
            unique_ids = []
            for supervisor_id in v:
                if supervisor_id not in seen:
                    seen.add(supervisor_id)
                    unique_ids.append(supervisor_id)
            return unique_ids
        return v

    @model_validator(mode="after")
    def validate_filter_consistency(self) -> "ActivityFilterParams":
        """Validate filter consistency."""
        # Can't have both success_only and failed_only
        if self.success_only and self.failed_only:
            raise ValueError("Cannot filter for both success_only and failed_only")
        
        # Validate response time range
        if (self.min_response_time_ms is not None and 
            self.max_response_time_ms is not None and
            self.min_response_time_ms > self.max_response_time_ms):
            raise ValueError("min_response_time_ms cannot be greater than max_response_time_ms")
        
        return self


class ActivityExportRequest(BaseCreateSchema):
    """
    Export activity logs with customizable format and fields.
    
    Supports various export formats with field selection.
    """

    filters: ActivityFilterParams = Field(
        ...,
        description="Filter criteria for export",
    )
    format: str = Field(
        default="csv",
        pattern=r"^(csv|excel|pdf|json)$",
        description="Export file format",
    )
    
    # Field selection
    include_metadata: bool = Field(
        default=False,
        description="Include full metadata in export",
    )
    include_technical_details: bool = Field(
        default=False,
        description="Include IP, user agent, etc.",
    )
    include_performance_metrics: bool = Field(
        default=True,
        description="Include response times and success rates",
    )
    include_change_tracking: bool = Field(
        default=False,
        description="Include old/new values for changes",
    )
    
    # Grouping options
    group_by_category: bool = Field(
        default=False,
        description="Group activities by category",
    )
    group_by_date: bool = Field(
        default=False,
        description="Group activities by date",
    )
    
    # Summary options
    include_summary: bool = Field(
        default=True,
        description="Include summary statistics",
    )
    include_charts: bool = Field(
        default=False,
        description="Include charts (for PDF/Excel)",
    )

    @field_validator("format")
    @classmethod
    def normalize_format(cls, v: str) -> str:
        """Normalize format to lowercase."""
        return v.lower().strip()

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_assignment.py ---
# --- File: app/schemas/supervisor/supervisor_assignment.py ---
"""
Supervisor assignment schemas with enhanced validation.

Manages supervisor-hostel assignments with proper tracking,
permission management, and transfer handling.
"""

from __future__ import annotations

from datetime import date, datetime, timedelta
from typing import Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import PermissionLevel

__all__ = [
    "SupervisorAssignment",
    "AssignmentRequest",
    "AssignmentUpdate",
    "RevokeAssignmentRequest",
    "AssignmentTransfer",
    "AssignmentSummary",
]


class SupervisorAssignment(BaseResponseSchema):
    """
    Supervisor-hostel assignment response.
    
    Complete assignment information with metadata.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    supervisor_email: str = Field(..., description="Supervisor email")
    
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    assigned_by: str = Field(..., description="Admin who assigned")
    assigned_by_name: str = Field(..., description="Admin name")
    assigned_date: date = Field(..., description="Assignment date")
    
    is_active: bool = Field(..., description="Assignment is active")
    
    # Permission summary
    permission_level: str = Field(
        ...,
        description="Summary of permission level",
        examples=["Full Access", "Standard Access", "Limited Access"],
    )
    
    # Activity tracking
    last_active: Optional[datetime] = Field(
        default=None,
        description="Last activity timestamp",
    )
    total_days_assigned: int = Field(
        default=0,
        ge=0,
        description="Total days in current assignment",
    )

    @computed_field
    @property
    def assignment_duration_months(self) -> int:
        """Calculate assignment duration in months."""
        return self.total_days_assigned // 30


class AssignmentRequest(BaseCreateSchema):
    """
    Request to assign supervisor to hostel.
    
    Creates new supervisor-hostel assignment with employment details.
    """

    user_id: str = Field(
        ...,
        description="User ID to assign as supervisor",
    )
    hostel_id: str = Field(
        ...,
        description="Hostel ID",
    )
    
    # Employment details
    employee_id: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Employee/Staff ID",
    )
    join_date: date = Field(
        ...,
        description="Joining date",
    )
    employment_type: str = Field(
        default="full_time",
        pattern=r"^(full_time|part_time|contract)$",
        description="Employment type",
    )
    shift_timing: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Shift timing",
    )
    
    # Permissions (optional, will use defaults)
    permissions: Optional[dict] = Field(
        default=None,
        description="Custom permissions (uses template defaults if not provided)",
    )
    permission_template: Optional[str] = Field(
        default="junior_supervisor",
        description="Permission template to apply",
    )

    @field_validator("join_date")
    @classmethod
    def validate_join_date(cls, v: date) -> date:
        """Validate join date is reasonable."""
        today = date.today()
        
        # Allow up to 30 days in future for scheduled assignments
        if v > today + timedelta(days=30):
            raise ValueError("Join date cannot be more than 30 days in the future")
        
        # Allow up to 1 year in past for historical data entry
        if v < today - timedelta(days=365):
            raise ValueError("Join date cannot be more than 1 year in the past")
        
        return v

    @field_validator("employment_type")
    @classmethod
    def normalize_employment_type(cls, v: str) -> str:
        """Normalize employment type to lowercase."""
        return v.lower().strip()


class AssignmentUpdate(BaseUpdateSchema):
    """
    Update supervisor assignment details.
    
    Allows modification of employment details and assignment status.
    """

    employee_id: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Employee ID",
    )
    employment_type: Optional[str] = Field(
        default=None,
        pattern=r"^(full_time|part_time|contract)$",
        description="Employment type",
    )
    shift_timing: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Shift timing",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Assignment active status",
    )
    
    # Permission updates
    permissions: Optional[dict] = Field(
        default=None,
        description="Updated permissions",
    )

    @field_validator("employment_type")
    @classmethod
    def normalize_employment_type(cls, v: Optional[str]) -> Optional[str]:
        """Normalize employment type."""
        return v.lower().strip() if v else None


class RevokeAssignmentRequest(BaseCreateSchema):
    """
    Revoke supervisor assignment.
    
    Handles assignment revocation with handover support.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID",
    )
    revoke_date: date = Field(
        ...,
        description="Effective revocation date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for revocation",
    )
    
    # Handover
    handover_to_supervisor_id: Optional[str] = Field(
        default=None,
        description="Transfer responsibilities to another supervisor",
    )
    handover_notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Handover instructions",
    )
    handover_period_days: int = Field(
        default=7,
        ge=0,
        le=30,
        description="Handover period in days",
    )

    @field_validator("revoke_date")
    @classmethod
    def validate_revoke_date(cls, v: date) -> date:
        """Validate revocation date."""
        today = date.today()
        
        # Can't revoke in past (except today)
        if v < today:
            raise ValueError("Revoke date cannot be in the past")
        
        # Limit future revocation
        if v > today + timedelta(days=90):
            raise ValueError("Revoke date cannot be more than 90 days in future")
        
        return v

    @model_validator(mode="after")
    def validate_handover_consistency(self) -> "RevokeAssignmentRequest":
        """Validate handover requirements."""
        if self.handover_to_supervisor_id:
            if not self.handover_notes:
                raise ValueError(
                    "handover_notes required when transferring to another supervisor"
                )
        
        return self


class AssignmentTransfer(BaseCreateSchema):
    """
    Transfer supervisor to different hostel.
    
    Manages supervisor reassignment between hostels with permission handling.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID",
    )
    from_hostel_id: str = Field(
        ...,
        description="Current hostel",
    )
    to_hostel_id: str = Field(
        ...,
        description="New hostel",
    )
    transfer_date: date = Field(
        ...,
        description="Transfer effective date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Transfer reason",
    )
    
    # Permission handling
    retain_permissions: bool = Field(
        default=True,
        description="Keep same permission set",
    )
    new_permissions: Optional[dict] = Field(
        default=None,
        description="New permissions if not retaining",
    )
    permission_template: Optional[str] = Field(
        default=None,
        description="Permission template to apply at new hostel",
    )

    @field_validator("transfer_date")
    @classmethod
    def validate_transfer_date(cls, v: date) -> date:
        """Validate transfer date."""
        today = date.today()
        
        if v < today:
            raise ValueError("Transfer date cannot be in the past")
        
        if v > today + timedelta(days=90):
            raise ValueError("Transfer date cannot be more than 90 days in future")
        
        return v

    @model_validator(mode="after")
    def validate_transfer_logic(self) -> "AssignmentTransfer":
        """Validate transfer business logic."""
        # Different hostels required
        if self.from_hostel_id == self.to_hostel_id:
            raise ValueError("from_hostel_id and to_hostel_id must be different")
        
        # Permission configuration
        if not self.retain_permissions:
            if not self.new_permissions and not self.permission_template:
                raise ValueError(
                    "Must provide new_permissions or permission_template "
                    "when not retaining permissions"
                )
        
        return self


class AssignmentSummary(BaseSchema):
    """
    Assignment summary for reporting.
    
    Aggregated assignment information for dashboards and reports.
    """

    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Assignment counts
    total_supervisors: int = Field(
        default=0,
        ge=0,
        description="Total assigned supervisors",
    )
    active_supervisors: int = Field(
        default=0,
        ge=0,
        description="Currently active supervisors",
    )
    on_leave_supervisors: int = Field(
        default=0,
        ge=0,
        description="Supervisors on leave",
    )
    
    # Activity metrics
    supervisors_online_now: int = Field(
        default=0,
        ge=0,
        description="Currently online",
    )
    supervisors_active_today: int = Field(
        default=0,
        ge=0,
        description="Active today",
    )
    
    # Performance summary
    average_performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average performance rating",
    )
    
    # Coverage
    shift_coverage: dict = Field(
        default_factory=dict,
        description="Coverage by shift",
    )

    @computed_field
    @property
    def active_percentage(self) -> Decimal:
        """Calculate percentage of active supervisors."""
        if self.total_supervisors == 0:
            return Decimal("100.00")
        
        rate = (self.active_supervisors / self.total_supervisors * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def needs_coverage(self) -> bool:
        """Check if hostel needs more supervisor coverage."""
        return self.active_supervisors < 1

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_base.py ---
# --- File: app/schemas/supervisor/supervisor_base.py ---
"""
Supervisor base schemas with enhanced validation and type safety.

Provides core supervisor management schemas including creation, updates,
status management, and hostel reassignment with comprehensive validation.
"""

from __future__ import annotations

from datetime import date, timedelta
from decimal import Decimal
from typing import Dict, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import EmploymentType, SupervisorStatus

__all__ = [
    "SupervisorBase",
    "SupervisorCreate",
    "SupervisorUpdate",
    "SupervisorStatusUpdate",
    "SupervisorReassignment",
    "SupervisorTermination",
]


# Constants for validation
class SupervisorValidationConstants:
    """Centralized validation constants for supervisor operations."""
    
    MAX_FUTURE_JOIN_DAYS = 30
    MAX_PAST_JOIN_YEARS = 50
    MIN_HANDOVER_PERIOD_DAYS = 0
    MAX_HANDOVER_PERIOD_DAYS = 30
    MAX_FUTURE_EFFECTIVE_DAYS = 30
    MAX_PAST_EFFECTIVE_DAYS = 7
    MAX_FUTURE_REASSIGNMENT_DAYS = 90
    MAX_FUTURE_TERMINATION_DAYS = 90
    MAX_PAST_TERMINATION_DAYS = 30
    MIN_REASON_LENGTH = 10
    MAX_REASON_LENGTH = 500
    MAX_NOTES_LENGTH = 1000
    MAX_EMPLOYEE_ID_LENGTH = 100
    MAX_DESIGNATION_LENGTH = 100
    MAX_SHIFT_TIMING_LENGTH = 100
    MIN_SALARY = 0
    MAX_PROBATION_MONTHS = 3


class SupervisorBase(BaseSchema):
    """
    Base supervisor schema with core attributes.
    
    Contains common fields shared across supervisor operations including
    employment details and assignment information.
    """

    user_id: str = Field(
        ...,
        description="Associated user account ID",
    )
    assigned_hostel_id: str = Field(
        ...,
        description="Currently assigned hostel ID",
    )

    # Employment details
    employee_id: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_EMPLOYEE_ID_LENGTH,
        description="Employee/Staff ID number",
        examples=["EMP001", "SUP-2024-001"],
    )
    join_date: date = Field(
        ...,
        description="Joining/start date",
    )
    employment_type: EmploymentType = Field(
        default=EmploymentType.FULL_TIME,
        description="Employment type/contract",
    )
    shift_timing: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_SHIFT_TIMING_LENGTH,
        description="Shift timing or working hours",
        examples=["9 AM - 6 PM", "Morning Shift", "24x7 Rotating"],
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_DESIGNATION_LENGTH,
        description="Job designation/title",
        examples=["Hostel Supervisor", "Senior Supervisor", "Floor Supervisor"],
    )
    salary: Optional[Decimal] = Field(
        default=None,
        ge=SupervisorValidationConstants.MIN_SALARY,
        max_digits=10,
        decimal_places=2,
        description="Monthly salary (confidential)",
    )

    @field_validator("employee_id", "shift_timing", "designation")
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """
        Normalize text fields by trimming and cleaning whitespace.
        
        Args:
            v: Input string value
            
        Returns:
            Normalized string or None if empty
        """
        if v is None:
            return None
        
        v = v.strip()
        if not v:
            return None
        
        # Remove excessive whitespace while preserving single spaces
        normalized = " ".join(v.split())
        
        # Special handling for employee_id - convert to uppercase
        return normalized.upper() if "employee_id" in str(cls) else normalized

    @field_validator("join_date")
    @classmethod
    def validate_join_date(cls, v: date) -> date:
        """
        Validate join date is within reasonable bounds.
        
        Args:
            v: Join date to validate
            
        Returns:
            Validated join date
            
        Raises:
            ValueError: If date is outside acceptable range
        """
        today = date.today()
        
        # Future date validation
        max_future = today + timedelta(days=SupervisorValidationConstants.MAX_FUTURE_JOIN_DAYS)
        if v > max_future:
            raise ValueError(
                f"Join date cannot be more than {SupervisorValidationConstants.MAX_FUTURE_JOIN_DAYS} days in the future"
            )
        
        # Past date validation
        max_past = today - timedelta(days=365 * SupervisorValidationConstants.MAX_PAST_JOIN_YEARS)
        if v < max_past:
            raise ValueError(
                f"Join date cannot be more than {SupervisorValidationConstants.MAX_PAST_JOIN_YEARS} years in the past"
            )
        
        return v

    @model_validator(mode="after")
    def validate_employment_consistency(self) -> "SupervisorBase":
        """
        Validate employment data consistency.
        
        Returns:
            Self with validated data
        """
        # Contract employees should have employee_id
        if self.employment_type == EmploymentType.CONTRACT and not self.employee_id:
            # Warning only - don't enforce
            pass
        
        return self


class SupervisorCreate(SupervisorBase, BaseCreateSchema):
    """
    Schema for creating a new supervisor.
    
    Used when assigning a user as supervisor to a hostel.
    Includes assignment tracking and initial permission configuration.
    """

    user_id: str = Field(
        ...,
        description="User ID to assign as supervisor (required)",
    )
    assigned_hostel_id: str = Field(
        ...,
        description="Hostel ID to assign supervisor to (required)",
    )
    join_date: date = Field(
        ...,
        description="Joining date (required)",
    )
    assigned_by: str = Field(
        ...,
        description="Admin user ID who is assigning the supervisor",
    )

    # Initial permissions (optional, defaults will be applied)
    permissions: Optional[Dict[str, bool | int | Decimal]] = Field(
        default=None,
        description="Initial permission settings (uses defaults if not provided)",
    )
    
    # Assignment metadata
    assignment_notes: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Notes about the assignment",
    )

    @field_validator("permissions")
    @classmethod
    def validate_permissions_structure(
        cls, 
        v: Optional[Dict[str, bool | int | Decimal]]
    ) -> Optional[Dict[str, bool | int | Decimal]]:
        """
        Validate permissions dictionary structure.
        
        Args:
            v: Permissions dictionary
            
        Returns:
            Validated permissions
        """
        if v is None:
            return None
        
        # Ensure all values are of correct types
        for key, value in v.items():
            if not isinstance(value, (bool, int, float, Decimal)):
                raise ValueError(
                    f"Permission '{key}' has invalid value type. "
                    f"Expected bool, int, or Decimal, got {type(value).__name__}"
                )
        
        return v


class SupervisorUpdate(BaseUpdateSchema):
    """
    Schema for updating supervisor information.
    
    All fields are optional for partial updates.
    Includes permission updates and status changes.
    """

    # Employment details
    employee_id: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_EMPLOYEE_ID_LENGTH,
        description="Employee ID",
    )
    employment_type: Optional[EmploymentType] = Field(
        default=None,
        description="Employment type",
    )
    shift_timing: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_SHIFT_TIMING_LENGTH,
        description="Shift timing",
    )
    designation: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_DESIGNATION_LENGTH,
        description="Designation",
    )
    salary: Optional[Decimal] = Field(
        default=None,
        ge=SupervisorValidationConstants.MIN_SALARY,
        max_digits=10,
        decimal_places=2,
        description="Monthly salary",
    )

    # Status
    status: Optional[SupervisorStatus] = Field(
        default=None,
        description="Supervisor status",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Active status",
    )

    # Permissions
    permissions: Optional[Dict[str, bool | int | Decimal]] = Field(
        default=None,
        description="Updated permission settings",
    )

    # Notes
    notes: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Additional notes",
    )

    # Apply base validators
    _normalize_text = field_validator(
        "employee_id", "shift_timing", "designation"
    )(SupervisorBase.normalize_text_fields.__func__)

    @model_validator(mode="after")
    def validate_status_consistency(self) -> "SupervisorUpdate":
        """
        Validate status and is_active consistency.
        
        Returns:
            Self with validated data
        """
        # If setting to inactive status, ensure is_active is False
        if self.status in [SupervisorStatus.TERMINATED, SupervisorStatus.SUSPENDED]:
            if self.is_active is True:
                raise ValueError(
                    f"Cannot set is_active=True when status is {self.status.value}"
                )
        
        return self


class SupervisorStatusUpdate(BaseUpdateSchema):
    """
    Schema for updating supervisor status.
    
    Handles status transitions with proper documentation and validation.
    Supports termination, suspension, and leave management.
    """

    status: SupervisorStatus = Field(
        ...,
        description="New supervisor status",
    )
    is_active: bool = Field(
        ...,
        description="Active status (false for terminated/suspended)",
    )
    effective_date: date = Field(
        ...,
        description="Status change effective date",
    )
    reason: str = Field(
        ...,
        min_length=SupervisorValidationConstants.MIN_REASON_LENGTH,
        max_length=SupervisorValidationConstants.MAX_REASON_LENGTH,
        description="Reason for status change",
    )

    # Termination-specific fields
    termination_date: Optional[date] = Field(
        default=None,
        description="Termination date (required if status is TERMINATED)",
    )
    termination_reason: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_REASON_LENGTH,
        description="Detailed termination reason",
    )
    eligible_for_rehire: Optional[bool] = Field(
        default=None,
        description="Eligible for rehire in future",
    )

    # Suspension-specific fields
    suspension_start_date: Optional[date] = Field(
        default=None,
        description="Suspension start date (required if SUSPENDED)",
    )
    suspension_end_date: Optional[date] = Field(
        default=None,
        description="Expected suspension end date (required if SUSPENDED)",
    )
    suspension_reason: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_REASON_LENGTH,
        description="Detailed suspension reason",
    )

    # Leave-specific fields
    leave_start_date: Optional[date] = Field(
        default=None,
        description="Leave start date (required if ON_LEAVE)",
    )
    leave_end_date: Optional[date] = Field(
        default=None,
        description="Expected return date from leave (required if ON_LEAVE)",
    )
    leave_type: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Type of leave (sick, vacation, etc.)",
    )

    # Handover details
    handover_to: Optional[str] = Field(
        default=None,
        description="Supervisor ID for responsibility handover",
    )
    handover_notes: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Handover instructions",
    )

    @field_validator("effective_date")
    @classmethod
    def validate_effective_date(cls, v: date) -> date:
        """Validate effective date is within acceptable range."""
        today = date.today()
        
        min_date = today - timedelta(days=SupervisorValidationConstants.MAX_PAST_EFFECTIVE_DAYS)
        max_date = today + timedelta(days=SupervisorValidationConstants.MAX_FUTURE_EFFECTIVE_DAYS)
        
        if v < min_date:
            raise ValueError(
                f"Effective date cannot be more than {SupervisorValidationConstants.MAX_PAST_EFFECTIVE_DAYS} days in the past"
            )
        
        if v > max_date:
            raise ValueError(
                f"Effective date cannot be more than {SupervisorValidationConstants.MAX_FUTURE_EFFECTIVE_DAYS} days in the future"
            )
        
        return v

    @model_validator(mode="after")
    def validate_status_specific_requirements(self) -> "SupervisorStatusUpdate":
        """
        Validate status-specific required fields and constraints.
        
        Returns:
            Self with validated data
            
        Raises:
            ValueError: If required fields are missing for specific statuses
        """
        # Termination validation
        if self.status == SupervisorStatus.TERMINATED:
            if not self.termination_date:
                raise ValueError("termination_date is required for TERMINATED status")
            if not self.termination_reason:
                raise ValueError("termination_reason is required for TERMINATED status")
            if self.is_active:
                raise ValueError("is_active must be False for TERMINATED status")
        
        # Suspension validation
        if self.status == SupervisorStatus.SUSPENDED:
            if not self.suspension_start_date:
                raise ValueError("suspension_start_date is required for SUSPENDED status")
            if not self.suspension_end_date:
                raise ValueError("suspension_end_date is required for SUSPENDED status")
            if not self.suspension_reason:
                raise ValueError("suspension_reason is required for SUSPENDED status")
            if self.is_active:
                raise ValueError("is_active must be False for SUSPENDED status")
        
        # Leave validation
        if self.status == SupervisorStatus.ON_LEAVE:
            if not self.leave_start_date:
                raise ValueError("leave_start_date is required for ON_LEAVE status")
            if not self.leave_end_date:
                raise ValueError("leave_end_date is required for ON_LEAVE status")
        
        return self

    @model_validator(mode="after")
    def validate_date_ranges(self) -> "SupervisorStatusUpdate":
        """
        Validate date range consistency for suspension and leave.
        
        Returns:
            Self with validated dates
            
        Raises:
            ValueError: If end dates are before start dates
        """
        # Suspension date range
        if self.suspension_start_date and self.suspension_end_date:
            if self.suspension_end_date <= self.suspension_start_date:
                raise ValueError("suspension_end_date must be after suspension_start_date")
        
        # Leave date range
        if self.leave_start_date and self.leave_end_date:
            if self.leave_end_date <= self.leave_start_date:
                raise ValueError("leave_end_date must be after leave_start_date")
        
        return self


class SupervisorReassignment(BaseCreateSchema):
    """
    Schema for reassigning supervisor to different hostel.
    
    Handles supervisor transfer between hostels with proper tracking,
    permission handling, and optional salary adjustments.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID to reassign",
    )
    from_hostel_id: str = Field(
        ...,
        description="Current hostel ID",
    )
    new_hostel_id: str = Field(
        ...,
        description="New hostel ID to assign",
    )
    effective_date: date = Field(
        ...,
        description="Reassignment effective date",
    )
    reason: str = Field(
        ...,
        min_length=SupervisorValidationConstants.MIN_REASON_LENGTH,
        max_length=SupervisorValidationConstants.MAX_REASON_LENGTH,
        description="Reason for reassignment",
        examples=[
            "Staff shortage at new hostel",
            "Performance-based transfer",
            "Personal request",
            "Organizational restructuring",
        ],
    )

    # Permission handling
    retain_permissions: bool = Field(
        default=True,
        description="Retain same permission set at new hostel",
    )
    new_permissions: Optional[Dict[str, bool | int | Decimal]] = Field(
        default=None,
        description="New permission set (required if not retaining)",
    )

    # Salary adjustment
    salary_adjustment: Optional[Decimal] = Field(
        default=None,
        max_digits=10,
        decimal_places=2,
        description="Salary adjustment amount (positive or negative)",
    )
    salary_adjustment_reason: Optional[str] = Field(
        default=None,
        max_length=200,
        description="Reason for salary adjustment",
    )

    # Handover configuration
    handover_period_days: int = Field(
        default=7,
        ge=SupervisorValidationConstants.MIN_HANDOVER_PERIOD_DAYS,
        le=SupervisorValidationConstants.MAX_HANDOVER_PERIOD_DAYS,
        description="Handover period in days",
    )
    handover_to: Optional[str] = Field(
        default=None,
        description="Supervisor ID for handover at current hostel",
    )

    @field_validator("effective_date")
    @classmethod
    def validate_effective_date(cls, v: date) -> date:
        """Validate effective date is in acceptable future range."""
        today = date.today()
        
        if v < today:
            raise ValueError("Effective date cannot be in the past")
        
        max_date = today + timedelta(days=SupervisorValidationConstants.MAX_FUTURE_REASSIGNMENT_DAYS)
        if v > max_date:
            raise ValueError(
                f"Effective date cannot be more than {SupervisorValidationConstants.MAX_FUTURE_REASSIGNMENT_DAYS} days in the future"
            )
        
        return v

    @model_validator(mode="after")
    def validate_reassignment_logic(self) -> "SupervisorReassignment":
        """
        Validate reassignment business logic.
        
        Returns:
            Self with validated data
            
        Raises:
            ValueError: If reassignment logic is invalid
        """
        # Different hostel validation
        if self.from_hostel_id == self.new_hostel_id:
            raise ValueError("New hostel must be different from current hostel")
        
        # Permission configuration validation
        if not self.retain_permissions and not self.new_permissions:
            raise ValueError(
                "new_permissions must be provided when retain_permissions is False"
            )
        
        # Salary adjustment validation
        if self.salary_adjustment is not None and self.salary_adjustment != 0:
            if not self.salary_adjustment_reason:
                raise ValueError(
                    "salary_adjustment_reason is required when adjusting salary"
                )
        
        return self


class SupervisorTermination(BaseCreateSchema):
    """
    Schema for comprehensive supervisor termination.
    
    Handles complete termination process including exit interview,
    clearance verification, asset return, and final settlement.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID to terminate",
    )
    termination_date: date = Field(
        ...,
        description="Termination effective date",
    )
    termination_type: str = Field(
        ...,
        pattern=r"^(voluntary|involuntary|retirement|end_of_contract)$",
        description="Type of termination",
        examples=["voluntary", "involuntary", "retirement", "end_of_contract"],
    )
    reason: str = Field(
        ...,
        min_length=20,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Detailed termination reason",
    )

    # Notice period
    notice_period_served: bool = Field(
        ...,
        description="Whether notice period was served",
    )
    notice_period_days: Optional[int] = Field(
        default=None,
        ge=0,
        le=90,
        description="Notice period served in days",
    )

    # Clearance checklist
    hostel_clearance_obtained: bool = Field(
        default=False,
        description="Hostel clearance completed",
    )
    finance_clearance_obtained: bool = Field(
        default=False,
        description="Finance clearance completed",
    )
    admin_clearance_obtained: bool = Field(
        default=False,
        description="Admin clearance completed",
    )

    # Asset management
    assets_returned: bool = Field(
        default=False,
        description="All hostel assets returned",
    )
    asset_list: Optional[str] = Field(
        default=None,
        max_length=500,
        description="List of assets returned",
    )

    # Exit interview
    exit_interview_conducted: bool = Field(
        default=False,
        description="Exit interview completed",
    )
    exit_interview_notes: Optional[str] = Field(
        default=None,
        max_length=2000,
        description="Exit interview notes",
    )

    # Rehire eligibility
    eligible_for_rehire: bool = Field(
        ...,
        description="Eligible for future rehire",
    )
    rehire_notes: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Notes on rehire eligibility",
    )

    # Final settlement
    final_settlement_amount: Optional[Decimal] = Field(
        default=None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Final settlement amount",
    )
    settlement_date: Optional[date] = Field(
        default=None,
        description="Settlement payment date",
    )

    # Handover
    responsibilities_handover_to: Optional[str] = Field(
        default=None,
        description="Supervisor ID for handover",
    )
    handover_completed: bool = Field(
        default=False,
        description="Handover completion status",
    )
    handover_notes: Optional[str] = Field(
        default=None,
        max_length=SupervisorValidationConstants.MAX_NOTES_LENGTH,
        description="Handover notes",
    )

    @field_validator("termination_date")
    @classmethod
    def validate_termination_date(cls, v: date) -> date:
        """Validate termination date is within acceptable range."""
        today = date.today()
        
        min_date = today - timedelta(days=SupervisorValidationConstants.MAX_PAST_TERMINATION_DAYS)
        max_date = today + timedelta(days=SupervisorValidationConstants.MAX_FUTURE_TERMINATION_DAYS)
        
        if v < min_date:
            raise ValueError(
                f"Termination date cannot be more than {SupervisorValidationConstants.MAX_PAST_TERMINATION_DAYS} days in the past"
            )
        
        if v > max_date:
            raise ValueError(
                f"Termination date cannot be more than {SupervisorValidationConstants.MAX_FUTURE_TERMINATION_DAYS} days in the future"
            )
        
        return v

    @field_validator("termination_type")
    @classmethod
    def normalize_termination_type(cls, v: str) -> str:
        """Normalize termination type to lowercase."""
        return v.lower().strip()

    @model_validator(mode="after")
    def validate_termination_requirements(self) -> "SupervisorTermination":
        """
        Validate termination-specific business logic.
        
        Returns:
            Self with validated data
        """
        # Settlement validation
        if self.final_settlement_amount and self.final_settlement_amount > 0:
            if not self.settlement_date:
                raise ValueError(
                    "settlement_date is required when final_settlement_amount is provided"
                )
        
        # Notice period validation for voluntary termination
        if self.termination_type == "voluntary" and not self.notice_period_served:
            if self.notice_period_days is None or self.notice_period_days == 0:
                # Warning only - don't enforce strictly
                pass
        
        return self

    @model_validator(mode="after")
    def validate_clearance_completeness(self) -> "SupervisorTermination":
        """
        Validate clearance requirements for past terminations.
        
        Returns:
            Self with validation warnings (non-blocking)
        """
        # For past terminations, all clearances should ideally be complete
        if self.termination_date <= date.today():
            incomplete_clearances = []
            
            if not self.hostel_clearance_obtained:
                incomplete_clearances.append("hostel")
            if not self.finance_clearance_obtained:
                incomplete_clearances.append("finance")
            if not self.admin_clearance_obtained:
                incomplete_clearances.append("admin")
            
            # Log warning but don't block (can be handled at service layer)
            if incomplete_clearances:
                # This would typically trigger a warning in logs
                pass
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_dashboard.py ---
# --- File: app/schemas/supervisor/supervisor_dashboard.py ---
"""
Supervisor dashboard schemas with real-time metrics and insights.

Provides comprehensive dashboard data with performance indicators,
task management, and actionable insights.
"""

from __future__ import annotations

from datetime import date, datetime, time
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseSchema

__all__ = [
    "SupervisorDashboard",
    "DashboardMetrics",
    "TaskSummary",
    "RecentComplaintItem",
    "RecentMaintenanceItem",
    "PendingLeaveItem",
    "TodaySchedule",
    "DashboardAlert",
    "QuickActions",
    "PerformanceIndicators",
]


class DashboardMetrics(BaseSchema):
    """
    Key performance metrics for supervisor dashboard.
    
    Real-time metrics with trend indicators and benchmarks.
    """

    # Student metrics
    total_students: int = Field(..., ge=0, description="Total students in hostel")
    active_students: int = Field(..., ge=0, description="Currently active students")
    students_on_leave: int = Field(..., ge=0, description="Students on approved leave")
    new_students_this_month: int = Field(..., ge=0, description="New admissions this month")
    
    # Occupancy metrics
    total_beds: int = Field(..., ge=0, description="Total bed capacity")
    occupied_beds: int = Field(..., ge=0, description="Currently occupied beds")
    available_beds: int = Field(..., ge=0, description="Available beds")
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Current occupancy percentage",
    )
    occupancy_trend: str = Field(
        ...,
        pattern=r"^(increasing|stable|decreasing)$",
        description="Occupancy trend direction",
    )
    
    # Complaint metrics
    total_complaints: int = Field(..., ge=0, description="Total complaints (all time)")
    open_complaints: int = Field(..., ge=0, description="Currently open complaints")
    assigned_to_me: int = Field(..., ge=0, description="Complaints assigned to me")
    resolved_today: int = Field(..., ge=0, description="Complaints resolved today")
    resolved_this_week: int = Field(..., ge=0, description="Resolved this week")
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average resolution time in hours",
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="SLA compliance percentage",
    )
    
    # Maintenance metrics
    pending_maintenance: int = Field(..., ge=0, description="Pending maintenance requests")
    in_progress_maintenance: int = Field(..., ge=0, description="In-progress maintenance")
    completed_today: int = Field(..., ge=0, description="Completed today")
    overdue_maintenance: int = Field(..., ge=0, description="Overdue maintenance")
    maintenance_budget_used: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of maintenance budget used",
    )
    
    # Attendance metrics
    attendance_marked_today: bool = Field(..., description="Today's attendance marked")
    total_present_today: int = Field(..., ge=0, description="Students present today")
    total_absent_today: int = Field(..., ge=0, description="Students absent today")
    attendance_percentage_today: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Today's attendance percentage",
    )
    
    # Payment metrics (view-only)
    overdue_payments_count: int = Field(..., ge=0, description="Students with overdue payments")
    payment_collection_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Monthly payment collection rate",
    )
    
    # Communication metrics
    unread_admin_messages: int = Field(..., ge=0, description="Unread messages from admin")
    pending_announcements: int = Field(..., ge=0, description="Announcements pending approval")

    @computed_field
    @property
    def overall_health_score(self) -> Decimal:
        """Calculate overall hostel health score (0-100)."""
        # Weighted scoring based on key metrics
        occupancy_score = min(float(self.occupancy_percentage), 100) * 0.25
        complaint_score = max(0, 100 - (self.open_complaints * 5)) * 0.25
        maintenance_score = max(0, 100 - (self.pending_maintenance * 10)) * 0.25
        attendance_score = float(self.attendance_percentage_today) * 0.25
        
        total_score = occupancy_score + complaint_score + maintenance_score + attendance_score
        return Decimal(str(total_score)).quantize(Decimal("0.1"))

    @computed_field
    @property
    def needs_attention(self) -> List[str]:
        """Identify areas needing immediate attention."""
        issues = []
        
        if self.open_complaints > 5:
            issues.append("High number of open complaints")
        
        if self.overdue_maintenance > 0:
            issues.append("Overdue maintenance requests")
        
        if not self.attendance_marked_today:
            issues.append("Attendance not marked today")
        
        if self.occupancy_percentage < 70:
            issues.append("Low occupancy rate")
        
        if self.overdue_payments_count > 10:
            issues.append("Multiple overdue payments")
        
        return issues


class TaskSummary(BaseSchema):
    """
    Summary of pending tasks and priorities.
    
    Actionable task list with urgency indicators.
    """

    # High priority tasks
    urgent_complaints: int = Field(..., ge=0, description="Urgent complaints requiring attention")
    critical_maintenance: int = Field(..., ge=0, description="Critical maintenance requests")
    pending_leave_approvals: int = Field(..., ge=0, description="Leave requests awaiting approval")
    overdue_tasks: int = Field(..., ge=0, description="Overdue tasks")
    
    # Daily routine tasks
    attendance_pending: bool = Field(..., description="Daily attendance not yet marked")
    menu_published_today: bool = Field(..., description="Today's menu published")
    daily_inspection_done: bool = Field(..., description="Daily inspection completed")
    reports_pending: int = Field(..., ge=0, description="Reports pending submission")
    
    # Administrative tasks
    document_verifications_pending: int = Field(
        ...,
        ge=0,
        description="Student documents awaiting verification",
    )
    room_assignments_pending: int = Field(
        ...,
        ge=0,
        description="Room assignments to be processed",
    )
    
    # Overdue items
    overdue_complaint_resolutions: int = Field(
        ...,
        ge=0,
        description="Complaints past SLA deadline",
    )
    overdue_maintenance: int = Field(
        ...,
        ge=0,
        description="Maintenance past due date",
    )
    
    # Total pending
    total_pending_tasks: int = Field(
        ...,
        ge=0,
        description="Total tasks requiring action",
    )

    @computed_field
    @property
    def priority_score(self) -> int:
        """Calculate task priority score (higher = more urgent)."""
        score = 0
        score += self.urgent_complaints * 10
        score += self.critical_maintenance * 8
        score += self.overdue_complaint_resolutions * 15
        score += self.overdue_maintenance * 12
        score += self.pending_leave_approvals * 3
        
        if self.attendance_pending:
            score += 20
        
        return score

    @computed_field
    @property
    def workload_level(self) -> str:
        """Assess current workload level."""
        if self.total_pending_tasks == 0:
            return "Light"
        elif self.total_pending_tasks <= 5:
            return "Moderate"
        elif self.total_pending_tasks <= 15:
            return "Heavy"
        else:
            return "Overwhelming"


class RecentComplaintItem(BaseSchema):
    """Recent complaint for dashboard display."""
    
    complaint_id: str = Field(..., description="Complaint ID")
    complaint_number: str = Field(..., description="Complaint reference number")
    title: str = Field(..., description="Complaint title")
    category: str = Field(..., description="Complaint category")
    priority: str = Field(..., description="Priority level")
    status: str = Field(..., description="Current status")
    
    # Student info
    student_name: str = Field(..., description="Student name")
    room_number: str = Field(..., description="Room number")
    
    # Timing
    created_at: datetime = Field(..., description="Complaint creation time")
    age_hours: int = Field(..., ge=0, description="Hours since creation")
    sla_deadline: Optional[datetime] = Field(
        default=None,
        description="SLA deadline for resolution",
    )

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if complaint is past SLA deadline."""
        if not self.sla_deadline:
            return False
        return datetime.now() > self.sla_deadline

    @computed_field
    @property
    def urgency_indicator(self) -> str:
        """Get urgency indicator for UI."""
        if self.is_overdue:
            return "overdue"
        elif self.priority in ["urgent", "high"]:
            return "urgent"
        elif self.age_hours > 24:
            return "attention"
        else:
            return "normal"


class RecentMaintenanceItem(BaseSchema):
    """Recent maintenance request for dashboard."""
    
    request_id: str = Field(..., description="Maintenance request ID")
    request_number: str = Field(..., description="Request reference number")
    title: str = Field(..., description="Maintenance title")
    category: str = Field(..., description="Maintenance category")
    priority: str = Field(..., description="Priority level")
    status: str = Field(..., description="Current status")
    
    # Location
    room_number: Optional[str] = Field(default=None, description="Room number")
    location_description: Optional[str] = Field(
        default=None,
        description="Location description",
    )
    
    # Cost and timing
    estimated_cost: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Estimated cost",
    )
    created_at: datetime = Field(..., description="Request creation time")
    scheduled_date: Optional[date] = Field(
        default=None,
        description="Scheduled completion date",
    )
    
    # Assignment
    assigned_to: Optional[str] = Field(
        default=None,
        description="Assigned staff/vendor",
    )

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if maintenance is overdue."""
        if not self.scheduled_date:
            return False
        return date.today() > self.scheduled_date

    @computed_field
    @property
    def days_pending(self) -> int:
        """Calculate days since request creation."""
        return (datetime.now() - self.created_at).days


class PendingLeaveItem(BaseSchema):
    """Pending leave approval for dashboard."""
    
    leave_id: str = Field(..., description="Leave application ID")
    student_name: str = Field(..., description="Student name")
    room_number: str = Field(..., description="Room number")
    
    # Leave details
    leave_type: str = Field(..., description="Type of leave")
    from_date: date = Field(..., description="Leave start date")
    to_date: date = Field(..., description="Leave end date")
    total_days: int = Field(..., ge=1, description="Total leave days")
    reason: str = Field(..., description="Leave reason")
    
    # Application details
    applied_at: datetime = Field(..., description="Application timestamp")
    emergency_contact: Optional[str] = Field(
        default=None,
        description="Emergency contact during leave",
    )
    supporting_documents: bool = Field(
        default=False,
        description="Supporting documents provided",
    )

    @computed_field
    @property
    def is_urgent(self) -> bool:
        """Check if leave approval is urgent."""
        # Urgent if leave starts within 2 days
        return (self.from_date - date.today()).days <= 2

    @computed_field
    @property
    def pending_days(self) -> int:
        """Days since application was submitted."""
        return (datetime.now() - self.applied_at).days


class ScheduledMaintenanceItem(BaseSchema):
    """Scheduled maintenance for today."""
    
    maintenance_id: str = Field(..., description="Maintenance ID")
    title: str = Field(..., description="Maintenance title")
    scheduled_time: time = Field(..., description="Scheduled time")
    estimated_duration_hours: Optional[int] = Field(
        default=None,
        ge=1,
        description="Estimated duration in hours",
    )
    room_number: Optional[str] = Field(default=None, description="Room number")
    assigned_staff: Optional[str] = Field(default=None, description="Assigned staff")
    priority: str = Field(..., description="Priority level")


class ScheduledMeeting(BaseSchema):
    """Scheduled meeting for today."""
    
    meeting_id: str = Field(..., description="Meeting ID")
    title: str = Field(..., description="Meeting title")
    start_time: time = Field(..., description="Meeting start time")
    end_time: time = Field(..., description="Meeting end time")
    attendees: List[str] = Field(default_factory=list, description="Attendee names")
    location: str = Field(..., description="Meeting location")
    meeting_type: str = Field(
        ...,
        pattern=r"^(staff|admin|student|vendor|other)$",
        description="Type of meeting",
    )


class TodaySchedule(BaseSchema):
    """Today's schedule and planned activities."""
    
    date: date = Field(..., description="Schedule date")
    
    # Routine tasks
    attendance_marking_time: time = Field(
        ...,
        description="Expected time for attendance marking",
    )
    inspection_rounds: List[str] = Field(
        default_factory=list,
        description="Scheduled inspection areas",
    )
    
    # Scheduled activities
    scheduled_maintenance: List[ScheduledMaintenanceItem] = Field(
        default_factory=list,
        description="Maintenance scheduled for today",
    )
    scheduled_meetings: List[ScheduledMeeting] = Field(
        default_factory=list,
        description="Meetings scheduled for today",
    )
    
    # Special events
    special_events: List[str] = Field(
        default_factory=list,
        description="Special events or occasions",
    )
    
    # Deadlines
    report_deadlines: List[str] = Field(
        default_factory=list,
        description="Reports due today",
    )

    @computed_field
    @property
    def total_scheduled_items(self) -> int:
        """Count total scheduled items for the day."""
        return (
            len(self.scheduled_maintenance) +
            len(self.scheduled_meetings) +
            len(self.special_events) +
            len(self.report_deadlines)
        )

    @computed_field
    @property
    def schedule_density(self) -> str:
        """Assess schedule density for the day."""
        if self.total_scheduled_items == 0:
            return "Light"
        elif self.total_scheduled_items <= 3:
            return "Moderate"
        elif self.total_scheduled_items <= 6:
            return "Busy"
        else:
            return "Very Busy"


class DashboardAlert(BaseSchema):
    """Dashboard alert/notification with action support."""
    
    alert_id: str = Field(..., description="Alert ID")
    alert_type: str = Field(
        ...,
        pattern=r"^(urgent|warning|info|success)$",
        description="Alert severity level",
    )
    title: str = Field(..., description="Alert title")
    message: str = Field(..., description="Alert message")
    
    # Action support
    action_required: bool = Field(..., description="Whether action is required")
    action_url: Optional[str] = Field(default=None, description="Action URL")
    action_label: Optional[str] = Field(default=None, description="Action button label")
    
    # Metadata
    created_at: datetime = Field(..., description="Alert creation time")
    expires_at: Optional[datetime] = Field(default=None, description="Alert expiration")
    is_dismissible: bool = Field(default=True, description="Can be dismissed by user")
    
    # Context
    related_entity_type: Optional[str] = Field(
        default=None,
        description="Related entity type",
    )
    related_entity_id: Optional[str] = Field(
        default=None,
        description="Related entity ID",
    )

    @computed_field
    @property
    def is_expired(self) -> bool:
        """Check if alert has expired."""
        if not self.expires_at:
            return False
        return datetime.now() > self.expires_at

    @computed_field
    @property
    def age_minutes(self) -> int:
        """Calculate alert age in minutes."""
        return int((datetime.now() - self.created_at).total_seconds() / 60)


class QuickAction(BaseSchema):
    """Individual quick action button."""
    
    action_id: str = Field(..., description="Action identifier")
    label: str = Field(..., description="Action label")
    icon: str = Field(..., description="Icon identifier")
    url: str = Field(..., description="Action URL")
    
    # Badge support
    badge_count: Optional[int] = Field(
        default=None,
        ge=0,
        description="Number indicator (e.g., pending items)",
    )
    badge_type: Optional[str] = Field(
        default=None,
        pattern=r"^(info|warning|danger|success)$",
        description="Badge color type",
    )
    
    # Permissions
    requires_permission: Optional[str] = Field(
        default=None,
        description="Required permission to show action",
    )
    
    # Grouping
    category: str = Field(
        default="general",
        description="Action category for grouping",
    )


class QuickActions(BaseSchema):
    """Quick action buttons for dashboard."""
    
    actions: List[QuickAction] = Field(
        ...,
        description="Available quick actions",
    )

    @computed_field
    @property
    def actions_by_category(self) -> Dict[str, List[QuickAction]]:
        """Group actions by category."""
        grouped = {}
        for action in self.actions:
            category = action.category
            if category not in grouped:
                grouped[category] = []
            grouped[category].append(action)
        return grouped


class PerformanceIndicators(BaseSchema):
    """Key performance indicators for supervisor."""
    
    # Efficiency metrics
    complaint_resolution_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Complaint resolution rate %",
    )
    average_response_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average response time to issues",
    )
    task_completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Task completion rate %",
    )
    
    # Quality metrics
    student_satisfaction_score: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Student satisfaction rating",
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="SLA compliance rate %",
    )
    
    # Activity metrics
    daily_activity_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Daily activity score",
    )
    consistency_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Performance consistency score",
    )
    
    # Trend indicators
    performance_trend: str = Field(
        ...,
        pattern=r"^(improving|stable|declining)$",
        description="Overall performance trend",
    )
    
    # Benchmarking
    rank_among_peers: Optional[int] = Field(
        default=None,
        ge=1,
        description="Rank among peer supervisors",
    )
    total_peers: Optional[int] = Field(
        default=None,
        ge=1,
        description="Total number of peer supervisors",
    )

    @computed_field
    @property
    def overall_performance_score(self) -> Decimal:
        """Calculate overall performance score."""
        # Weighted average of key metrics
        weights = {
            'complaint_resolution': 0.25,
            'task_completion': 0.25,
            'sla_compliance': 0.25,
            'activity': 0.25,
        }
        
        score = (
            float(self.complaint_resolution_rate) * weights['complaint_resolution'] +
            float(self.task_completion_rate) * weights['task_completion'] +
            float(self.sla_compliance_rate) * weights['sla_compliance'] +
            float(self.daily_activity_score) * weights['activity']
        )
        
        return Decimal(str(score)).quantize(Decimal("0.1"))

    @computed_field
    @property
    def performance_grade(self) -> str:
        """Get performance grade based on overall score."""
        score = float(self.overall_performance_score)
        
        if score >= 90:
            return "A+"
        elif score >= 80:
            return "A"
        elif score >= 70:
            return "B+"
        elif score >= 60:
            return "B"
        elif score >= 50:
            return "C"
        else:
            return "D"


class SupervisorDashboard(BaseSchema):
    """
    Complete supervisor dashboard with real-time data.
    
    Comprehensive dashboard providing all necessary information
    for effective hostel management.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    
    # Core metrics
    metrics: DashboardMetrics = Field(..., description="Key performance metrics")
    
    # Task management
    tasks: TaskSummary = Field(..., description="Pending tasks summary")
    
    # Recent activity
    recent_complaints: List[RecentComplaintItem] = Field(
        default_factory=list,
        max_length=5,
        description="Recent complaints (max 5)",
    )
    recent_maintenance: List[RecentMaintenanceItem] = Field(
        default_factory=list,
        max_length=5,
        description="Recent maintenance requests (max 5)",
    )
    pending_leaves: List[PendingLeaveItem] = Field(
        default_factory=list,
        max_length=10,
        description="Pending leave approvals (max 10)",
    )
    
    # Schedule
    today_schedule: TodaySchedule = Field(..., description="Today's schedule")
    
    # Alerts and notifications
    alerts: List[DashboardAlert] = Field(
        default_factory=list,
        description="Active alerts and notifications",
    )
    
    # Quick actions
    quick_actions: QuickActions = Field(..., description="Available quick actions")
    
    # Performance indicators
    performance: PerformanceIndicators = Field(
        ...,
        description="Performance indicators",
    )
    
    # Activity tracking
    last_login: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp",
    )
    actions_today: int = Field(
        default=0,
        ge=0,
        description="Actions performed today",
    )
    online_duration_minutes: int = Field(
        default=0,
        ge=0,
        description="Online duration today (minutes)",
    )
    
    # Dashboard metadata
    dashboard_updated_at: datetime = Field(
        ...,
        description="Dashboard data timestamp",
    )
    refresh_interval_seconds: int = Field(
        default=300,
        ge=60,
        description="Recommended refresh interval",
    )

    @computed_field
    @property
    def critical_alerts_count(self) -> int:
        """Count critical alerts requiring immediate attention."""
        return sum(1 for alert in self.alerts if alert.alert_type == "urgent")

    @computed_field
    @property
    def workload_summary(self) -> str:
        """Get workload summary description."""
        total_pending = self.tasks.total_pending_tasks
        urgent_items = (
            self.tasks.urgent_complaints +
            self.tasks.critical_maintenance +
            self.tasks.overdue_tasks
        )
        
        if urgent_items > 5:
            return "Critical workload - immediate attention required"
        elif total_pending > 15:
            return "Heavy workload - prioritize urgent tasks"
        elif total_pending > 5:
            return "Moderate workload - manageable"
        else:
            return "Light workload - good job!"

    @computed_field
    @property
    def dashboard_health_status(self) -> str:
        """Overall dashboard health status."""
        health_score = float(self.metrics.overall_health_score)
        critical_alerts = self.critical_alerts_count
        urgent_tasks = (
            self.tasks.urgent_complaints +
            self.tasks.critical_maintenance +
            self.tasks.overdue_tasks
        )
        
        if critical_alerts > 0 or urgent_tasks > 5:
            return "Critical"
        elif health_score < 60 or urgent_tasks > 2:
            return "Warning"
        elif health_score < 80:
            return "Good"
        else:
            return "Excellent"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_performance.py ---
# --- File: app/schemas/supervisor/supervisor_performance.py ---
"""
Supervisor performance tracking schemas with comprehensive analytics.

Provides detailed performance measurement, goal tracking, and
comparative analysis with peer benchmarking.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "PerformanceMetrics",
    "PerformanceReport",
    "ComplaintPerformance",
    "AttendancePerformance",
    "MaintenancePerformance",
    "PerformanceTrendPoint",
    "PeerComparison",
    "PeriodComparison",
    "PerformanceReview",
    "PerformanceReviewResponse",
    "PerformanceGoal",
    "PerformanceGoalProgress",
    "PerformanceInsights",
]


class PerformanceMetrics(BaseSchema):
    """
    Comprehensive supervisor performance metrics.
    
    Aggregated performance data across all key areas with
    trend analysis and benchmarking.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_id: str = Field(..., description="Hostel ID")
    period_start: date = Field(..., description="Metrics period start")
    period_end: date = Field(..., description="Metrics period end")
    
    # ============ Complaint Handling Metrics ============
    complaints_handled: int = Field(..., ge=0, description="Total complaints handled")
    complaints_resolved: int = Field(..., ge=0, description="Complaints resolved")
    complaint_resolution_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Complaint resolution rate percentage",
    )
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average time to resolve complaints",
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="SLA compliance rate percentage",
    )
    first_response_time_minutes: Decimal = Field(
        ...,
        ge=0,
        description="Average first response time",
    )
    
    # ============ Attendance Management Metrics ============
    attendance_records_created: int = Field(
        ...,
        ge=0,
        description="Attendance records created",
    )
    attendance_accuracy: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Attendance accuracy percentage",
    )
    leaves_approved: int = Field(..., ge=0, description="Leave applications approved")
    leaves_rejected: int = Field(..., ge=0, description="Leave applications rejected")
    attendance_punctuality_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="On-time attendance marking rate",
    )
    
    # ============ Maintenance Management Metrics ============
    maintenance_requests_created: int = Field(
        ...,
        ge=0,
        description="Maintenance requests created",
    )
    maintenance_completed: int = Field(
        ...,
        ge=0,
        description="Maintenance requests completed",
    )
    maintenance_completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Maintenance completion rate",
    )
    average_maintenance_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average maintenance completion time",
    )
    maintenance_cost_efficiency: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Cost efficiency percentage",
    )
    
    # ============ Communication Metrics ============
    announcements_created: int = Field(
        ...,
        ge=0,
        description="Announcements created",
    )
    announcement_reach: int = Field(
        ...,
        ge=0,
        description="Total students reached by announcements",
    )
    student_interactions: int = Field(
        ...,
        ge=0,
        description="Direct student interactions",
    )
    
    # ============ Responsiveness Metrics ============
    average_first_response_time_minutes: Decimal = Field(
        ...,
        ge=0,
        description="Average first response time to issues",
    )
    availability_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Availability during working hours",
    )
    response_consistency_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Consistency in response times",
    )
    
    # ============ Student Satisfaction ============
    student_feedback_score: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average student feedback rating",
    )
    student_feedback_count: int = Field(
        ...,
        ge=0,
        description="Number of student feedback responses",
    )
    complaint_escalation_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of complaints escalated",
    )
    
    # ============ Overall Performance ============
    overall_performance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Calculated overall performance score",
    )
    performance_grade: str = Field(
        ...,
        pattern=r"^(A\+|A|B\+|B|C|D)$",
        description="Performance grade",
    )

    @computed_field
    @property
    def efficiency_score(self) -> Decimal:
        """Calculate efficiency score based on time metrics."""
        # Weighted score based on response times and completion rates
        response_score = max(0, 100 - float(self.average_first_response_time_minutes))
        completion_score = float(self.complaint_resolution_rate + self.maintenance_completion_rate) / 2
        
        efficiency = (response_score * 0.4 + completion_score * 0.6)
        return Decimal(str(efficiency)).quantize(Decimal("0.1"))

    @computed_field
    @property
    def quality_score(self) -> Decimal:
        """Calculate quality score based on accuracy and satisfaction."""
        quality_metrics = [
            float(self.attendance_accuracy),
            float(self.sla_compliance_rate),
            float(self.maintenance_cost_efficiency),
        ]
        
        if self.student_feedback_score:
            quality_metrics.append(float(self.student_feedback_score) * 20)  # Convert 5-point to 100-point
        
        average_quality = sum(quality_metrics) / len(quality_metrics)
        return Decimal(str(average_quality)).quantize(Decimal("0.1"))


class ComplaintPerformance(BaseSchema):
    """Detailed complaint handling performance analysis."""
    
    total_complaints: int = Field(..., ge=0, description="Total complaints handled")
    resolved_complaints: int = Field(..., ge=0, description="Successfully resolved")
    pending_complaints: int = Field(..., ge=0, description="Currently pending")
    escalated_complaints: int = Field(..., ge=0, description="Escalated to admin")
    
    # Category breakdown
    complaints_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaints by category",
    )
    
    # Priority breakdown
    complaints_by_priority: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaints by priority level",
    )
    
    # Resolution time analysis
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average resolution time",
    )
    fastest_resolution_hours: Decimal = Field(
        ...,
        ge=0,
        description="Fastest resolution time",
    )
    slowest_resolution_hours: Decimal = Field(
        ...,
        ge=0,
        description="Slowest resolution time",
    )
    median_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Median resolution time",
    )
    
    # SLA performance
    within_sla: int = Field(..., ge=0, description="Complaints resolved within SLA")
    breached_sla: int = Field(..., ge=0, description="SLA breaches")
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="SLA compliance percentage",
    )
    
    # Student satisfaction
    average_complaint_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average student rating for resolved complaints",
    )
    satisfaction_responses: int = Field(
        ...,
        ge=0,
        description="Number of satisfaction responses received",
    )

    @computed_field
    @property
    def resolution_efficiency(self) -> str:
        """Categorize resolution efficiency."""
        avg_hours = float(self.average_resolution_time_hours)
        
        if avg_hours <= 4:
            return "Excellent"
        elif avg_hours <= 12:
            return "Good"
        elif avg_hours <= 24:
            return "Average"
        elif avg_hours <= 48:
            return "Below Average"
        else:
            return "Poor"


class AttendancePerformance(BaseSchema):
    """Attendance management performance details."""
    
    total_attendance_records: int = Field(
        ...,
        ge=0,
        description="Total attendance records created",
    )
    days_attendance_marked: int = Field(
        ...,
        ge=0,
        description="Days attendance was marked",
    )
    days_attendance_missed: int = Field(
        ...,
        ge=0,
        description="Days attendance was not marked",
    )
    
    # Timeliness metrics
    on_time_marking_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of on-time attendance marking",
    )
    average_marking_delay_minutes: Decimal = Field(
        ...,
        ge=0,
        description="Average delay in attendance marking",
    )
    
    # Accuracy metrics
    corrections_made: int = Field(
        ...,
        ge=0,
        description="Number of attendance corrections made",
    )
    accuracy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Attendance accuracy rate",
    )
    
    # Leave management
    leaves_processed: int = Field(
        ...,
        ge=0,
        description="Total leave applications processed",
    )
    leaves_approved: int = Field(
        ...,
        ge=0,
        description="Leave applications approved",
    )
    leaves_rejected: int = Field(
        ...,
        ge=0,
        description="Leave applications rejected",
    )
    average_leave_approval_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average time to process leave applications",
    )

    @computed_field
    @property
    def attendance_consistency(self) -> str:
        """Assess attendance marking consistency."""
        total_days = self.days_attendance_marked + self.days_attendance_missed
        if total_days == 0:
            return "No Data"
        
        consistency_rate = (self.days_attendance_marked / total_days) * 100
        
        if consistency_rate >= 95:
            return "Excellent"
        elif consistency_rate >= 85:
            return "Good"
        elif consistency_rate >= 70:
            return "Average"
        else:
            return "Poor"

    @computed_field
    @property
    def leave_approval_rate(self) -> Decimal:
        """Calculate leave approval rate."""
        if self.leaves_processed == 0:
            return Decimal("0.00")
        
        rate = (self.leaves_approved / self.leaves_processed) * 100
        return Decimal(str(rate)).quantize(Decimal("0.01"))


class MaintenancePerformance(BaseSchema):
    """Maintenance management performance details."""
    
    requests_created: int = Field(
        ...,
        ge=0,
        description="Maintenance requests created",
    )
    requests_completed: int = Field(
        ...,
        ge=0,
        description="Maintenance requests completed",
    )
    requests_pending: int = Field(
        ...,
        ge=0,
        description="Currently pending requests",
    )
    requests_overdue: int = Field(
        ...,
        ge=0,
        description="Overdue maintenance requests",
    )
    
    # Category breakdown
    requests_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Requests by maintenance category",
    )
    
    # Completion time analysis
    average_completion_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average completion time",
    )
    fastest_completion_hours: Decimal = Field(
        ...,
        ge=0,
        description="Fastest completion time",
    )
    slowest_completion_hours: Decimal = Field(
        ...,
        ge=0,
        description="Slowest completion time",
    )
    
    # Cost management
    total_maintenance_cost: Decimal = Field(
        ...,
        ge=0,
        description="Total maintenance costs",
    )
    average_cost_per_request: Decimal = Field(
        ...,
        ge=0,
        description="Average cost per request",
    )
    budget_allocated: Decimal = Field(
        ...,
        ge=0,
        description="Allocated maintenance budget",
    )
    within_budget_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of requests within budget",
    )
    
    # Preventive maintenance
    preventive_tasks_completed: int = Field(
        ...,
        ge=0,
        description="Preventive maintenance tasks completed",
    )
    preventive_tasks_scheduled: int = Field(
        ...,
        ge=0,
        description="Preventive maintenance tasks scheduled",
    )
    preventive_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Preventive maintenance compliance rate",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate maintenance completion rate."""
        total_requests = self.requests_created
        if total_requests == 0:
            return Decimal("100.00")
        
        rate = (self.requests_completed / total_requests) * 100
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def budget_utilization(self) -> Decimal:
        """Calculate budget utilization percentage."""
        if self.budget_allocated == 0:
            return Decimal("0.00")
        
        utilization = (self.total_maintenance_cost / self.budget_allocated) * 100
        return Decimal(str(utilization)).quantize(Decimal("0.01"))
class PerformanceTrendPoint(BaseSchema):
    """Performance trend data point for analysis."""
    
    period: str = Field(
        ...,
        description="Time period identifier",
        examples=["2024-01", "Week 15", "Q1 2024"],
    )
    overall_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall performance score for period",
    )
    complaint_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Complaint handling score",
    )
    attendance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Attendance management score",
    )
    maintenance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Maintenance management score",
    )
    student_satisfaction_score: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=100,
        description="Student satisfaction score",
    )

    @computed_field
    @property
    def trend_indicator(self) -> str:
        """Get trend indicator for the period."""
        # This would typically be calculated by comparing with previous period
        # For now, return based on overall score
        score = float(self.overall_score)
        if score >= 85:
            return "excellent"
        elif score >= 70:
            return "good"
        elif score >= 55:
            return "average"
        else:
            return "needs_improvement"


class PeerComparison(BaseSchema):
    """Comparison with peer supervisors."""
    
    total_supervisors: int = Field(
        ...,
        ge=1,
        description="Total number of supervisors in comparison",
    )
    rank: int = Field(
        ...,
        ge=1,
        description="Supervisor's rank among peers (1 = best)",
    )
    percentile: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Performance percentile",
    )
    
    # Metric comparisons
    metrics_vs_average: Dict[str, "MetricComparison"] = Field(
        default_factory=dict,
        description="Individual metric comparisons",
    )
    
    # Top performers
    top_performer_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Score of top performer",
    )
    score_gap_to_top: Decimal = Field(
        ...,
        ge=0,
        description="Gap to top performer",
    )

    @computed_field
    @property
    def performance_tier(self) -> str:
        """Categorize performance tier among peers."""
        if self.percentile >= 90:
            return "Top Performer"
        elif self.percentile >= 75:
            return "High Performer"
        elif self.percentile >= 50:
            return "Average Performer"
        elif self.percentile >= 25:
            return "Below Average"
        else:
            return "Needs Improvement"


class MetricComparison(BaseSchema):
    """Individual metric comparison with peers."""
    
    metric_name: str = Field(..., description="Name of the metric")
    supervisor_value: Decimal = Field(..., description="Supervisor's value")
    peer_average: Decimal = Field(..., description="Peer average value")
    peer_median: Decimal = Field(..., description="Peer median value")
    best_peer_value: Decimal = Field(..., description="Best peer value")
    difference_from_average: Decimal = Field(
        ...,
        description="Difference from peer average",
    )
    difference_percentage: Decimal = Field(
        ...,
        description="Percentage difference from average",
    )
    better_than_average: bool = Field(
        ...,
        description="Whether supervisor performs better than average",
    )

    @computed_field
    @property
    def performance_vs_peers(self) -> str:
        """Describe performance relative to peers."""
        if self.better_than_average:
            if float(self.difference_percentage) >= 20:
                return "Significantly Above Average"
            elif float(self.difference_percentage) >= 10:
                return "Above Average"
            else:
                return "Slightly Above Average"
        else:
            if float(abs(self.difference_percentage)) >= 20:
                return "Significantly Below Average"
            elif float(abs(self.difference_percentage)) >= 10:
                return "Below Average"
            else:
                return "Slightly Below Average"


class PeriodComparison(BaseSchema):
    """Comparison with previous period."""
    
    previous_period: DateRangeFilter = Field(
        ...,
        description="Previous comparison period",
    )
    current_period: DateRangeFilter = Field(
        ...,
        description="Current period",
    )
    
    # Overall change
    overall_score_change: Decimal = Field(
        ...,
        description="Percentage change in overall score",
    )
    
    # Metric changes
    metric_changes: Dict[str, Decimal] = Field(
        ...,
        description="Percentage change for each metric",
    )
    
    # Improvement/decline indicators
    improved_metrics: List[str] = Field(
        default_factory=list,
        description="Metrics that improved",
    )
    declined_metrics: List[str] = Field(
        default_factory=list,
        description="Metrics that declined",
    )
    stable_metrics: List[str] = Field(
        default_factory=list,
        description="Metrics that remained stable",
    )

    @computed_field
    @property
    def overall_trend(self) -> str:
        """Determine overall performance trend."""
        if self.overall_score_change >= 5:
            return "Improving"
        elif self.overall_score_change <= -5:
            return "Declining"
        else:
            return "Stable"

    @computed_field
    @property
    def improvement_summary(self) -> str:
        """Generate improvement summary."""
        improved_count = len(self.improved_metrics)
        declined_count = len(self.declined_metrics)
        
        if improved_count > declined_count:
            return f"Improved in {improved_count} areas, declined in {declined_count}"
        elif declined_count > improved_count:
            return f"Declined in {declined_count} areas, improved in {improved_count}"
        else:
            return f"Mixed performance: {improved_count} improved, {declined_count} declined"


class PerformanceReport(BaseSchema):
    """Comprehensive performance report."""
    
    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_name: str = Field(..., description="Hostel name")
    report_period: DateRangeFilter = Field(..., description="Report period")
    generated_at: datetime = Field(..., description="Report generation timestamp")
    
    # Summary metrics
    summary: PerformanceMetrics = Field(..., description="Summary performance metrics")
    
    # Detailed breakdown
    complaint_performance: ComplaintPerformance = Field(
        ...,
        description="Complaint handling performance",
    )
    attendance_performance: AttendancePerformance = Field(
        ...,
        description="Attendance management performance",
    )
    maintenance_performance: MaintenancePerformance = Field(
        ...,
        description="Maintenance management performance",
    )
    
    # Trends and comparisons
    performance_trends: List[PerformanceTrendPoint] = Field(
        default_factory=list,
        description="Performance trends over time",
    )
    comparison_with_peers: Optional[PeerComparison] = Field(
        default=None,
        description="Comparison with peer supervisors",
    )
    comparison_with_previous_period: Optional[PeriodComparison] = Field(
        default=None,
        description="Comparison with previous period",
    )
    
    # Insights and recommendations
    strengths: List[str] = Field(
        default_factory=list,
        description="Identified strengths",
    )
    areas_for_improvement: List[str] = Field(
        default_factory=list,
        description="Areas needing improvement",
    )
    recommendations: List[str] = Field(
        default_factory=list,
        description="Specific recommendations",
    )
    
    # Goals and targets
    current_goals: List["PerformanceGoalProgress"] = Field(
        default_factory=list,
        description="Current performance goals progress",
    )

    @computed_field
    @property
    def report_summary(self) -> str:
        """Generate executive summary of the report."""
        score = float(self.summary.overall_performance_score)
        grade = self.summary.performance_grade
        
        summary = f"Overall Performance: {score:.1f}/100 (Grade: {grade}). "
        
        if self.comparison_with_previous_period:
            trend = self.comparison_with_previous_period.overall_trend
            summary += f"Trend: {trend}. "
        
        if self.comparison_with_peers:
            tier = self.comparison_with_peers.performance_tier
            summary += f"Peer Ranking: {tier}."
        
        return summary


class PerformanceReview(BaseCreateSchema):
    """Performance review by admin."""
    
    supervisor_id: str = Field(..., description="Supervisor being reviewed")
    review_period: DateRangeFilter = Field(..., description="Review period")
    
    # Ratings (1-5 scale)
    complaint_handling_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Complaint handling rating",
    )
    attendance_management_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Attendance management rating",
    )
    maintenance_management_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Maintenance management rating",
    )
    communication_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Communication skills rating",
    )
    professionalism_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Professionalism rating",
    )
    reliability_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Reliability rating",
    )
    initiative_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Initiative and proactiveness rating",
    )
    
    # Overall rating
    overall_rating: Decimal = Field(
        ...,
        ge=1,
        le=5,
        description="Overall performance rating",
    )
    
    # Textual feedback
    strengths: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Supervisor strengths",
    )
    areas_for_improvement: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Areas to improve",
    )
    goals_for_next_period: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Goals for next review period",
    )
    
    # Additional feedback
    admin_comments: Optional[str] = Field(
        default=None,
        max_length=2000,
        description="Additional admin comments",
    )
    
    # Action items
    action_items: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Specific action items (max 10)",
    )
    
    # Development recommendations
    training_recommendations: List[str] = Field(
        default_factory=list,
        description="Recommended training or development",
    )

    @field_validator("action_items", "training_recommendations")
    @classmethod
    def validate_non_empty_items(cls, v: List[str]) -> List[str]:
        """Remove empty items from lists."""
        return [item.strip() for item in v if item.strip()]

    @computed_field
    @property
    def average_rating(self) -> Decimal:
        """Calculate average of all individual ratings."""
        ratings = [
            self.complaint_handling_rating,
            self.attendance_management_rating,
            self.maintenance_management_rating,
            self.communication_rating,
            self.professionalism_rating,
            self.reliability_rating,
            self.initiative_rating,
        ]
        
        average = sum(float(r) for r in ratings) / len(ratings)
        return Decimal(str(average)).quantize(Decimal("0.1"))


class PerformanceReviewResponse(BaseSchema):
    """Performance review response with acknowledgment."""
    
    review_id: str = Field(..., description="Review ID")
    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    reviewed_by: str = Field(..., description="Reviewer ID")
    reviewed_by_name: str = Field(..., description="Reviewer name")
    review_date: date = Field(..., description="Review date")
    
    review_period: DateRangeFilter = Field(..., description="Review period")
    
    # Ratings
    ratings: Dict[str, Decimal] = Field(
        ...,
        description="All ratings by category",
    )
    overall_rating: Decimal = Field(..., description="Overall rating")
    
    # Feedback
    strengths: str = Field(..., description="Identified strengths")
    areas_for_improvement: str = Field(..., description="Areas for improvement")
    goals_for_next_period: str = Field(..., description="Next period goals")
    admin_comments: Optional[str] = Field(default=None, description="Admin comments")
    
    # Actions and development
    action_items: List[str] = Field(default_factory=list, description="Action items")
    training_recommendations: List[str] = Field(
        default_factory=list,
        description="Training recommendations",
    )
    
    # Supervisor acknowledgment
    acknowledged: bool = Field(default=False, description="Supervisor acknowledged review")
    acknowledged_at: Optional[datetime] = Field(
        default=None,
        description="Acknowledgment timestamp",
    )
    supervisor_comments: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Supervisor's response comments",
    )

    @computed_field
    @property
    def performance_level(self) -> str:
        """Categorize performance level based on overall rating."""
        rating = float(self.overall_rating)
        
        if rating >= 4.5:
            return "Outstanding"
        elif rating >= 4.0:
            return "Exceeds Expectations"
        elif rating >= 3.0:
            return "Meets Expectations"
        elif rating >= 2.0:
            return "Below Expectations"
        else:
            return "Unsatisfactory"


class PerformanceGoal(BaseCreateSchema):
    """Set performance goal for supervisor."""
    
    supervisor_id: str = Field(..., description="Supervisor ID")
    goal_name: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Goal name",
    )
    goal_description: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Detailed goal description",
    )
    
    # Measurable target
    metric_name: str = Field(
        ...,
        description="Metric to measure",
        examples=[
            "complaint_resolution_rate",
            "sla_compliance_rate",
            "attendance_punctuality_rate",
        ],
    )
    target_value: Decimal = Field(
        ...,
        description="Target value to achieve",
    )
    current_value: Optional[Decimal] = Field(
        default=None,
        description="Current baseline value",
    )
    
    # Timeline
    start_date: date = Field(..., description="Goal start date")
    end_date: date = Field(..., description="Goal target completion date")
    
    # Priority and category
    priority: str = Field(
        default="medium",
        pattern=r"^(low|medium|high|critical)$",
        description="Goal priority level",
    )
    category: str = Field(
        ...,
        pattern=r"^(complaint|attendance|maintenance|communication|efficiency|quality)$",
        description="Goal category",
    )
    
    # Tracking
    measurement_frequency: str = Field(
        default="weekly",
        pattern=r"^(daily|weekly|monthly)$",
        description="How often to measure progress",
    )

    @field_validator("end_date")
    @classmethod
    def validate_end_date(cls, v: date, info) -> date:
        """Validate end date is after start date."""
        start_date = info.data.get("start_date")
        if start_date and v <= start_date:
            raise ValueError("End date must be after start date")
        return v

    @computed_field
    @property
    def duration_days(self) -> int:
        """Calculate goal duration in days."""
        return (self.end_date - self.start_date).days


class PerformanceGoalProgress(BaseSchema):
    """Track progress on performance goal."""
    
    goal_id: str = Field(..., description="Goal ID")
    goal_name: str = Field(..., description="Goal name")
    metric_name: str = Field(..., description="Metric being measured")
    
    # Values
    target_value: Decimal = Field(..., description="Target value")
    current_value: Decimal = Field(..., description="Current achieved value")
    baseline_value: Optional[Decimal] = Field(
        default=None,
        description="Starting baseline value",
    )
    
    # Progress calculation
    progress_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Progress percentage towards goal",
    )
    
    # Timeline
    start_date: date = Field(..., description="Goal start date")
    end_date: date = Field(..., description="Goal end date")
    days_remaining: int = Field(..., ge=0, description="Days remaining to achieve goal")
    
    # Status
    status: str = Field(
        ...,
        pattern=r"^(on_track|at_risk|behind|completed|failed|paused)$",
        description="Goal progress status",
    )
    
    # Tracking
    last_updated: datetime = Field(..., description="Last progress update")
    measurement_history: List[Dict[str, any]] = Field(
        default_factory=list,
        description="Historical measurements",
    )

    @computed_field
    @property
    def days_elapsed(self) -> int:
        """Calculate days elapsed since goal start."""
        return (date.today() - self.start_date).days

    @computed_field
    @property
    def time_progress_percentage(self) -> Decimal:
        """Calculate time progress percentage."""
        total_days = (self.end_date - self.start_date).days
        if total_days == 0:
            return Decimal("100.00")
        
        elapsed_days = self.days_elapsed
        time_progress = min(100, (elapsed_days / total_days) * 100)
        return Decimal(str(time_progress)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_on_schedule(self) -> bool:
        """Check if goal progress is on schedule."""
        time_progress = float(self.time_progress_percentage)
        actual_progress = float(self.progress_percentage)
        
        # Allow 10% tolerance
        return actual_progress >= (time_progress - 10)

    @computed_field
    @property
    def projected_completion_date(self) -> Optional[date]:
        """Project completion date based on current progress rate."""
        if self.progress_percentage == 0:
            return None
        
        days_elapsed = self.days_elapsed
        if days_elapsed == 0:
            return None
        
        progress_rate = float(self.progress_percentage) / days_elapsed
        if progress_rate == 0:
            return None
        
        remaining_progress = 100 - float(self.progress_percentage)
        days_to_complete = remaining_progress / progress_rate
        
        from datetime import timedelta
        projected_date = date.today() + timedelta(days=int(days_to_complete))
        return projected_date


class PerformanceInsights(BaseSchema):
    """AI-generated performance insights and recommendations."""
    
    supervisor_id: str = Field(..., description="Supervisor ID")
    analysis_period: DateRangeFilter = Field(..., description="Analysis period")
    generated_at: datetime = Field(..., description="Insights generation timestamp")
    
    # Key insights
    top_strengths: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 identified strengths",
    )
    improvement_opportunities: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 improvement opportunities",
    )
    
    # Trend analysis
    performance_trends: Dict[str, str] = Field(
        default_factory=dict,
        description="Trend analysis for each metric",
    )
    
    # Predictive insights
    risk_factors: List[str] = Field(
        default_factory=list,
        description="Identified risk factors",
    )
    success_indicators: List[str] = Field(
        default_factory=list,
        description="Positive success indicators",
    )
    
    # Recommendations
    immediate_actions: List[str] = Field(
        default_factory=list,
        max_length=3,
        description="Immediate actions recommended",
    )
    long_term_development: List[str] = Field(
        default_factory=list,
        max_length=3,
        description="Long-term development recommendations",
    )
    
    # Benchmarking insights
    peer_comparison_insights: List[str] = Field(
        default_factory=list,
        description="Insights from peer comparison",
    )
    
    # Confidence scores
    insight_confidence: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Confidence level in insights (0-100)",
    )

    @computed_field
    @property
    def overall_assessment(self) -> str:
        """Generate overall performance assessment."""
        strengths_count = len(self.top_strengths)
        improvements_count = len(self.improvement_opportunities)
        risks_count = len(self.risk_factors)
        
        if strengths_count > improvements_count and risks_count == 0:
            return "Strong performer with consistent results"
        elif improvements_count > strengths_count:
            return "Developing performer with growth potential"
        elif risks_count > 0:
            return "Requires attention and support"
        else:
            return "Balanced performer with mixed results"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_permissions.py ---
# --- File: app/schemas/supervisor/supervisor_permissions.py ---
"""
Supervisor permission schemas with comprehensive access control.

Provides granular permission management with templates, bulk operations,
and audit tracking. Optimized for performance and maintainability.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Any, Dict, List, Literal, Optional, Set

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema

__all__ = [
    "SupervisorPermissions",
    "PermissionUpdate",
    "PermissionCheckRequest",
    "PermissionCheckResponse",
    "BulkPermissionUpdate",
    "PermissionTemplate",
    "ApplyPermissionTemplate",
    "PermissionAuditLog",
    "PermissionConstants",
]


class PermissionConstants:
    """Centralized constants for permission management."""
    
    # Permission categories
    COMPLAINT_PERMISSIONS = {
        "can_manage_complaints",
        "can_assign_complaints",
        "can_resolve_complaints",
        "can_close_complaints",
    }
    
    ATTENDANCE_PERMISSIONS = {
        "can_record_attendance",
        "can_approve_leaves",
        "can_edit_past_attendance",
    }
    
    MAINTENANCE_PERMISSIONS = {
        "can_manage_maintenance",
        "can_assign_maintenance",
        "can_approve_maintenance_costs",
        "can_schedule_preventive_maintenance",
    }
    
    COMMUNICATION_PERMISSIONS = {
        "can_create_announcements",
        "can_send_push_notifications",
        "can_send_sms",
        "can_send_email",
    }
    
    # Threshold defaults
    DEFAULT_MAINTENANCE_THRESHOLD = Decimal("5000.00")
    DEFAULT_LEAVE_APPROVAL_DAYS = 3
    DEFAULT_PAST_ATTENDANCE_EDIT_DAYS = 7
    
    # Permission templates
    JUNIOR_SUPERVISOR_TEMPLATE = "junior_supervisor"
    SENIOR_SUPERVISOR_TEMPLATE = "senior_supervisor"
    HEAD_SUPERVISOR_TEMPLATE = "head_supervisor"
    LIMITED_ACCESS_TEMPLATE = "limited_access"
    
    # Validation constraints
    MIN_LEAVE_APPROVAL_DAYS = 1
    MAX_LEAVE_APPROVAL_DAYS = 10
    MIN_PAST_EDIT_DAYS = 1
    MAX_PAST_EDIT_DAYS = 30
    MIN_MAINTENANCE_THRESHOLD = Decimal("0.00")
    MAX_MAINTENANCE_THRESHOLD = Decimal("100000.00")


class SupervisorPermissions(BaseSchema):
    """
    Comprehensive supervisor permission configuration.
    
    Provides granular control over supervisor capabilities with
    dependency validation and threshold-based permissions.
    """

    # ============ Complaint Management ============
    can_manage_complaints: bool = Field(
        default=True,
        description="Can view and manage complaints",
    )
    can_assign_complaints: bool = Field(
        default=True,
        description="Can assign complaints to staff/vendors",
    )
    can_resolve_complaints: bool = Field(
        default=True,
        description="Can mark complaints as resolved",
    )
    can_close_complaints: bool = Field(
        default=False,
        description="Can permanently close complaints (admin-level)",
    )
    complaint_priority_limit: Optional[Literal["low", "medium", "high", "urgent"]] = Field(
        default=None,
        description="Maximum priority level can handle independently",
    )

    # ============ Attendance Management ============
    can_record_attendance: bool = Field(
        default=True,
        description="Can record daily student attendance",
    )
    can_approve_leaves: bool = Field(
        default=True,
        description="Can approve leave applications",
    )
    max_leave_days_approval: int = Field(
        default=PermissionConstants.DEFAULT_LEAVE_APPROVAL_DAYS,
        ge=PermissionConstants.MIN_LEAVE_APPROVAL_DAYS,
        le=PermissionConstants.MAX_LEAVE_APPROVAL_DAYS,
        description="Maximum days of leave can approve independently",
    )
    can_edit_past_attendance: bool = Field(
        default=False,
        description="Can edit past attendance records",
    )
    past_attendance_edit_days: int = Field(
        default=PermissionConstants.DEFAULT_PAST_ATTENDANCE_EDIT_DAYS,
        ge=PermissionConstants.MIN_PAST_EDIT_DAYS,
        le=PermissionConstants.MAX_PAST_EDIT_DAYS,
        description="Days back can edit attendance (if permitted)",
    )

    # ============ Maintenance Management ============
    can_manage_maintenance: bool = Field(
        default=True,
        description="Can create and manage maintenance requests",
    )
    can_assign_maintenance: bool = Field(
        default=True,
        description="Can assign maintenance tasks to staff",
    )
    can_approve_maintenance_costs: bool = Field(
        default=False,
        description="Can approve maintenance costs",
    )
    maintenance_approval_threshold: Decimal = Field(
        default=PermissionConstants.DEFAULT_MAINTENANCE_THRESHOLD,
        ge=PermissionConstants.MIN_MAINTENANCE_THRESHOLD,
        le=PermissionConstants.MAX_MAINTENANCE_THRESHOLD,
        max_digits=10,
        decimal_places=2,
        description="Maximum repair cost can approve independently (INR)",
    )
    can_schedule_preventive_maintenance: bool = Field(
        default=True,
        description="Can schedule preventive maintenance",
    )

    # ============ Mess/Menu Management ============
    can_update_mess_menu: bool = Field(
        default=True,
        description="Can update daily mess menu",
    )
    menu_requires_approval: bool = Field(
        default=False,
        description="Menu changes require admin approval",
    )
    can_publish_special_menus: bool = Field(
        default=False,
        description="Can publish special occasion menus",
    )
    can_manage_meal_preferences: bool = Field(
        default=True,
        description="Can manage student meal preferences",
    )

    # ============ Communication ============
    can_create_announcements: bool = Field(
        default=True,
        description="Can create announcements",
    )
    urgent_announcement_requires_approval: bool = Field(
        default=True,
        description="Urgent announcements require admin approval",
    )
    can_send_push_notifications: bool = Field(
        default=False,
        description="Can send push notifications to students",
    )
    can_send_sms: bool = Field(
        default=False,
        description="Can send SMS to students",
    )
    can_send_email: bool = Field(
        default=True,
        description="Can send emails to students",
    )

    # ============ Student Management ============
    can_view_student_profiles: bool = Field(
        default=True,
        description="Can view student profiles and details",
    )
    can_update_student_contacts: bool = Field(
        default=True,
        description="Can update student contact information",
    )
    can_view_student_payments: bool = Field(
        default=True,
        description="Can view student payment status (read-only)",
    )
    can_view_student_documents: bool = Field(
        default=True,
        description="Can view student documents",
    )
    can_verify_student_documents: bool = Field(
        default=False,
        description="Can verify student documents",
    )

    # ============ Financial Access ============
    can_view_financial_reports: bool = Field(
        default=False,
        description="Can view detailed financial reports",
    )
    can_view_revenue_data: bool = Field(
        default=False,
        description="Can view revenue and collection data",
    )
    can_view_expense_data: bool = Field(
        default=False,
        description="Can view expense data",
    )
    can_generate_payment_reminders: bool = Field(
        default=True,
        description="Can generate payment reminders",
    )

    # ============ Room and Bed Management ============
    can_view_room_availability: bool = Field(
        default=True,
        description="Can view room and bed availability",
    )
    can_suggest_room_transfers: bool = Field(
        default=True,
        description="Can suggest room transfers (requires admin approval)",
    )
    can_assign_beds: bool = Field(
        default=False,
        description="Can assign beds to students",
    )
    can_update_room_status: bool = Field(
        default=True,
        description="Can update room maintenance status",
    )

    # ============ Booking Management ============
    can_view_bookings: bool = Field(
        default=True,
        description="Can view booking requests",
    )
    can_contact_visitors: bool = Field(
        default=True,
        description="Can contact visitors for inquiries",
    )
    can_approve_bookings: bool = Field(
        default=False,
        description="Can approve booking requests",
    )

    # ============ Reporting ============
    can_generate_reports: bool = Field(
        default=True,
        description="Can generate operational reports",
    )
    can_export_data: bool = Field(
        default=False,
        description="Can export data (CSV, Excel)",
    )

    # ============ Security and Access ============
    can_view_cctv: bool = Field(
        default=False,
        description="Can access CCTV footage",
    )
    can_manage_visitor_log: bool = Field(
        default=True,
        description="Can manage visitor entry/exit log",
    )

    @model_validator(mode="after")
    def validate_permission_dependencies(self) -> "SupervisorPermissions":
        """
        Validate permission dependencies and ensure consistency.
        
        Returns:
            Self with validated and corrected permissions
        """
        # Complaint management hierarchy
        if not self.can_manage_complaints:
            self.can_assign_complaints = False
            self.can_resolve_complaints = False
            self.can_close_complaints = False
        
        # Maintenance management hierarchy
        if not self.can_manage_maintenance:
            self.can_assign_maintenance = False
            self.can_approve_maintenance_costs = False
            self.can_schedule_preventive_maintenance = False
        
        # Menu management hierarchy
        if not self.can_update_mess_menu:
            self.can_publish_special_menus = False
        
        # Financial access hierarchy
        if not self.can_view_financial_reports:
            # If can't view reports, shouldn't see detailed revenue/expense
            pass  # Allow viewing revenue/expense without full report access
        
        return self

    @model_validator(mode="after")
    def validate_threshold_consistency(self) -> "SupervisorPermissions":
        """
        Validate threshold-based permissions.
        
        Returns:
            Self with validated thresholds
        """
        # If can't approve costs, threshold is irrelevant
        if not self.can_approve_maintenance_costs:
            self.maintenance_approval_threshold = Decimal("0.00")
        
        # If can't approve leaves, max days is irrelevant
        if not self.can_approve_leaves:
            self.max_leave_days_approval = 0
        
        # If can't edit past attendance, days limit is irrelevant
        if not self.can_edit_past_attendance:
            self.past_attendance_edit_days = 0
        
        return self

    def get_permission_summary(self) -> Dict[str, int]:
        """
        Get summary of permissions by category.
        
        Returns:
            Dictionary with permission counts per category
        """
        summary = {
            "complaint_permissions": 0,
            "attendance_permissions": 0,
            "maintenance_permissions": 0,
            "communication_permissions": 0,
            "student_permissions": 0,
            "financial_permissions": 0,
            "room_permissions": 0,
            "booking_permissions": 0,
            "reporting_permissions": 0,
            "security_permissions": 0,
        }
        
        # Count enabled permissions per category
        if self.can_manage_complaints:
            summary["complaint_permissions"] += 1
        if self.can_assign_complaints:
            summary["complaint_permissions"] += 1
        if self.can_resolve_complaints:
            summary["complaint_permissions"] += 1
        if self.can_close_complaints:
            summary["complaint_permissions"] += 1
        
        if self.can_record_attendance:
            summary["attendance_permissions"] += 1
        if self.can_approve_leaves:
            summary["attendance_permissions"] += 1
        if self.can_edit_past_attendance:
            summary["attendance_permissions"] += 1
        
        if self.can_manage_maintenance:
            summary["maintenance_permissions"] += 1
        if self.can_assign_maintenance:
            summary["maintenance_permissions"] += 1
        if self.can_approve_maintenance_costs:
            summary["maintenance_permissions"] += 1
        if self.can_schedule_preventive_maintenance:
            summary["maintenance_permissions"] += 1
        
        if self.can_create_announcements:
            summary["communication_permissions"] += 1
        if self.can_send_push_notifications:
            summary["communication_permissions"] += 1
        if self.can_send_sms:
            summary["communication_permissions"] += 1
        if self.can_send_email:
            summary["communication_permissions"] += 1
        
        if self.can_view_student_profiles:
            summary["student_permissions"] += 1
        if self.can_update_student_contacts:
            summary["student_permissions"] += 1
        if self.can_view_student_payments:
            summary["student_permissions"] += 1
        if self.can_view_student_documents:
            summary["student_permissions"] += 1
        if self.can_verify_student_documents:
            summary["student_permissions"] += 1
        
        if self.can_view_financial_reports:
            summary["financial_permissions"] += 1
        if self.can_view_revenue_data:
            summary["financial_permissions"] += 1
        if self.can_view_expense_data:
            summary["financial_permissions"] += 1
        if self.can_generate_payment_reminders:
            summary["financial_permissions"] += 1
        
        if self.can_view_room_availability:
            summary["room_permissions"] += 1
        if self.can_suggest_room_transfers:
            summary["room_permissions"] += 1
        if self.can_assign_beds:
            summary["room_permissions"] += 1
        if self.can_update_room_status:
            summary["room_permissions"] += 1
        
        if self.can_view_bookings:
            summary["booking_permissions"] += 1
        if self.can_contact_visitors:
            summary["booking_permissions"] += 1
        if self.can_approve_bookings:
            summary["booking_permissions"] += 1
        
        if self.can_generate_reports:
            summary["reporting_permissions"] += 1
        if self.can_export_data:
            summary["reporting_permissions"] += 1
        
        if self.can_view_cctv:
            summary["security_permissions"] += 1
        if self.can_manage_visitor_log:
            summary["security_permissions"] += 1
        
        return summary


class PermissionUpdate(BaseUpdateSchema):
    """
    Update supervisor permissions with validation.
    
    Allows partial permission updates with audit trail support.
    """

    permissions: Dict[str, bool | int | Decimal] = Field(
        ...,
        description="Permission key-value pairs to update",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for permission change",
    )

    @field_validator("permissions")
    @classmethod
    def validate_permissions(cls, v: Dict[str, bool | int | Decimal]) -> Dict[str, bool | int | Decimal]:
        """
        Validate permission keys and value types.
        
        Args:
            v: Permissions dictionary
            
        Returns:
            Validated permissions
            
        Raises:
            ValueError: If invalid keys or value types
        """
        valid_keys = set(SupervisorPermissions.model_fields.keys())
        provided_keys = set(v.keys())
        
        # Check for invalid keys
        invalid_keys = provided_keys - valid_keys
        if invalid_keys:
            raise ValueError(
                f"Invalid permission keys: {', '.join(sorted(invalid_keys))}"
            )
        
        # Validate value types based on field annotations
        for key, value in v.items():
            field_info = SupervisorPermissions.model_fields.get(key)
            if not field_info:
                continue
            
            # Get expected type
            expected_type = field_info.annotation
            
            # Handle Optional types
            if hasattr(expected_type, "__origin__"):
                # Extract actual type from Optional
                args = getattr(expected_type, "__args__", ())
                if args:
                    expected_type = args[0]
            
            # Validate type
            if expected_type == bool:
                if not isinstance(value, bool):
                    raise ValueError(f"{key} must be a boolean value")
            elif expected_type == int:
                if not isinstance(value, int) or isinstance(value, bool):
                    raise ValueError(f"{key} must be an integer value")
            elif expected_type == Decimal:
                if not isinstance(value, (Decimal, int, float)):
                    raise ValueError(f"{key} must be a numeric value")
                # Convert to Decimal if needed
                if not isinstance(value, Decimal):
                    v[key] = Decimal(str(value))
        
        return v


class PermissionCheckRequest(BaseCreateSchema):
    """
    Request to check specific permission.
    
    Validates supervisor permission with optional context for
    threshold-based permissions.
    """

    supervisor_id: str = Field(
        ...,
        description="Supervisor ID to check",
    )
    permission_key: str = Field(
        ...,
        description="Permission to check",
        examples=[
            "can_resolve_complaints",
            "can_approve_leaves",
            "can_approve_maintenance_costs",
        ],
    )
    context: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Additional context for permission check",
        examples=[
            {"amount": 7500},
            {"leave_days": 5},
            {"priority": "urgent"},
        ],
    )

    @field_validator("permission_key")
    @classmethod
    def validate_permission_key(cls, v: str) -> str:
        """
        Validate permission key exists.
        
        Args:
            v: Permission key to validate
            
        Returns:
            Validated permission key
            
        Raises:
            ValueError: If permission key doesn't exist
        """
        valid_keys = set(SupervisorPermissions.model_fields.keys())
        if v not in valid_keys:
            raise ValueError(
                f"Invalid permission key: {v}. "
                f"Valid keys: {', '.join(sorted(valid_keys))}"
            )
        return v


class PermissionCheckResponse(BaseSchema):
    """
    Response for permission check.
    
    Provides detailed information about permission status and
    any threshold restrictions.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    permission_key: str = Field(..., description="Permission checked")
    has_permission: bool = Field(
        ...,
        description="Whether supervisor has permission",
    )
    requires_approval: bool = Field(
        default=False,
        description="Whether action requires admin approval",
    )
    threshold_exceeded: bool = Field(
        default=False,
        description="Whether threshold limit is exceeded",
    )
    message: Optional[str] = Field(
        default=None,
        description="Explanation message",
    )

    # Threshold details
    threshold_value: Optional[Decimal] = Field(
        default=None,
        description="Configured threshold value",
    )
    actual_value: Optional[Decimal] = Field(
        default=None,
        description="Actual value being checked",
    )
    allowed_value: Optional[Decimal] = Field(
        default=None,
        description="Maximum allowed value",
    )

    def get_detailed_message(self) -> str:
        """
        Get detailed human-readable message.
        
        Returns:
            Detailed explanation of permission status
        """
        if self.has_permission and not self.threshold_exceeded:
            return f"Permission granted for {self.permission_key}"
        
        if self.threshold_exceeded:
            return (
                f"Threshold exceeded: {self.actual_value} exceeds "
                f"allowed limit of {self.threshold_value}. Admin approval required."
            )
        
        if self.requires_approval:
            return f"Action requires admin approval for {self.permission_key}"
        
        return f"Permission denied for {self.permission_key}"


class BulkPermissionUpdate(BaseUpdateSchema):
    """
    Update permissions for multiple supervisors.
    
    Efficient batch permission updates with validation and audit support.
    """

    supervisor_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Supervisor IDs to update (max 50)",
    )
    permissions: Dict[str, bool | int | Decimal] = Field(
        ...,
        description="Permissions to update for all supervisors",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for bulk permission change",
    )
    effective_date: Optional[datetime] = Field(
        default=None,
        description="Effective date for permission change",
    )

    @field_validator("supervisor_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[str]) -> List[str]:
        """Ensure supervisor IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Supervisor IDs must be unique")
        return v

    # Reuse permission validation
    _validate_permissions = field_validator("permissions")(
        PermissionUpdate.validate_permissions.__func__
    )


class PermissionTemplate(BaseSchema):
    """
    Permission template for quick assignment.
    
    Predefined permission sets for different supervisor levels.
    Supports system templates and custom templates.
    """

    template_id: str = Field(
        ...,
        description="Template unique identifier",
    )
    template_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Template name",
    )
    description: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Template description",
    )
    permissions: SupervisorPermissions = Field(
        ...,
        description="Permission configuration",
    )
    is_system_template: bool = Field(
        default=False,
        description="System-defined template (cannot be modified)",
    )
    is_active: bool = Field(
        default=True,
        description="Template is active and can be used",
    )
    created_at: Optional[datetime] = Field(
        default=None,
        description="Template creation timestamp",
    )
    created_by: Optional[str] = Field(
        default=None,
        description="Admin who created template",
    )
    updated_at: Optional[datetime] = Field(
        default=None,
        description="Last update timestamp",
    )

    @classmethod
    def get_system_templates(cls) -> Dict[str, "PermissionTemplate"]:
        """
        Get predefined system templates.
        
        Returns:
            Dictionary of template name to template object
        """
        templates = {}
        
        # Junior Supervisor Template - Basic permissions
        templates[PermissionConstants.JUNIOR_SUPERVISOR_TEMPLATE] = cls(
            template_id="sys_junior_supervisor",
            template_name="Junior Supervisor",
            description="Basic permissions for junior supervisors",
            permissions=SupervisorPermissions(
                can_manage_complaints=True,
                can_assign_complaints=False,
                can_resolve_complaints=True,
                can_close_complaints=False,
                can_record_attendance=True,
                can_approve_leaves=True,
                max_leave_days_approval=2,
                can_edit_past_attendance=False,
                can_manage_maintenance=True,
                can_assign_maintenance=False,
                can_approve_maintenance_costs=False,
                can_update_mess_menu=True,
                can_publish_special_menus=False,
                can_create_announcements=True,
                urgent_announcement_requires_approval=True,
                can_send_email=True,
                can_send_sms=False,
                can_send_push_notifications=False,
                can_view_student_profiles=True,
                can_view_student_payments=True,
                can_view_financial_reports=False,
                can_generate_reports=True,
                can_export_data=False,
            ),
            is_system_template=True,
        )
        
        # Senior Supervisor Template - Extended permissions
        templates[PermissionConstants.SENIOR_SUPERVISOR_TEMPLATE] = cls(
            template_id="sys_senior_supervisor",
            template_name="Senior Supervisor",
            description="Extended permissions for senior supervisors",
            permissions=SupervisorPermissions(
                can_manage_complaints=True,
                can_assign_complaints=True,
                can_resolve_complaints=True,
                can_close_complaints=False,
                can_record_attendance=True,
                can_approve_leaves=True,
                max_leave_days_approval=5,
                can_edit_past_attendance=True,
                past_attendance_edit_days=7,
                can_manage_maintenance=True,
                can_assign_maintenance=True,
                can_approve_maintenance_costs=True,
                maintenance_approval_threshold=Decimal("10000.00"),
                can_schedule_preventive_maintenance=True,
                can_update_mess_menu=True,
                can_publish_special_menus=True,
                can_create_announcements=True,
                urgent_announcement_requires_approval=False,
                can_send_email=True,
                can_send_sms=True,
                can_send_push_notifications=False,
                can_view_student_profiles=True,
                can_view_student_payments=True,
                can_view_financial_reports=True,
                can_view_revenue_data=True,
                can_generate_reports=True,
                can_export_data=True,
                can_suggest_room_transfers=True,
                can_assign_beds=False,
            ),
            is_system_template=True,
        )
        
        # Head Supervisor Template - Full permissions
        templates[PermissionConstants.HEAD_SUPERVISOR_TEMPLATE] = cls(
            template_id="sys_head_supervisor",
            template_name="Head Supervisor",
            description="Full permissions for head supervisors",
            permissions=SupervisorPermissions(
                can_manage_complaints=True,
                can_assign_complaints=True,
                can_resolve_complaints=True,
                can_close_complaints=True,
                can_record_attendance=True,
                can_approve_leaves=True,
                max_leave_days_approval=10,
                can_edit_past_attendance=True,
                past_attendance_edit_days=30,
                can_manage_maintenance=True,
                can_assign_maintenance=True,
                can_approve_maintenance_costs=True,
                maintenance_approval_threshold=Decimal("50000.00"),
                can_schedule_preventive_maintenance=True,
                can_update_mess_menu=True,
                can_publish_special_menus=True,
                can_create_announcements=True,
                urgent_announcement_requires_approval=False,
                can_send_email=True,
                can_send_sms=True,
                can_send_push_notifications=True,
                can_view_student_profiles=True,
                can_update_student_contacts=True,
                can_view_student_payments=True,
                can_view_student_documents=True,
                can_verify_student_documents=True,
                can_view_financial_reports=True,
                can_view_revenue_data=True,
                can_view_expense_data=True,
                can_generate_reports=True,
                can_export_data=True,
                can_view_room_availability=True,
                can_suggest_room_transfers=True,
                can_assign_beds=True,
                can_update_room_status=True,
                can_approve_bookings=True,
                can_view_cctv=True,
            ),
            is_system_template=True,
        )
        
        # Limited Access Template - Minimal permissions
        templates[PermissionConstants.LIMITED_ACCESS_TEMPLATE] = cls(
            template_id="sys_limited_access",
            template_name="Limited Access",
            description="Minimal permissions for restricted access",
            permissions=SupervisorPermissions(
                can_manage_complaints=True,
                can_assign_complaints=False,
                can_resolve_complaints=False,
                can_close_complaints=False,
                can_record_attendance=True,
                can_approve_leaves=False,
                can_edit_past_attendance=False,
                can_manage_maintenance=True,
                can_assign_maintenance=False,
                can_approve_maintenance_costs=False,
                can_update_mess_menu=False,
                can_create_announcements=False,
                can_send_email=False,
                can_send_sms=False,
                can_send_push_notifications=False,
                can_view_student_profiles=True,
                can_view_student_payments=False,
                can_view_financial_reports=False,
                can_generate_reports=False,
                can_export_data=False,
            ),
            is_system_template=True,
        )
        
        return templates


class ApplyPermissionTemplate(BaseCreateSchema):
    """
    Apply permission template to supervisor(s).
    
    Supports both override and merge modes with validation.
    """

    supervisor_ids: List[str] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Supervisor IDs to apply template to (max 50)",
    )
    template_name: str = Field(
        ...,
        description="Template name to apply",
    )
    override_existing: bool = Field(
        default=True,
        description="Override existing permissions completely",
    )
    merge_permissions: bool = Field(
        default=False,
        description="Merge with existing permissions (upgrade only)",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for applying template",
    )

    @field_validator("supervisor_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[str]) -> List[str]:
        """Ensure supervisor IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Supervisor IDs must be unique")
        return v

    @model_validator(mode="after")
    def validate_mode_selection(self) -> "ApplyPermissionTemplate":
        """
        Ensure only one application mode is selected.
        
        Returns:
            Self with validated mode
            
        Raises:
            ValueError: If both modes are selected
        """
        if self.override_existing and self.merge_permissions:
            raise ValueError(
                "Cannot both override and merge permissions. "
                "Choose either override_existing=True OR merge_permissions=True"
            )
        
        if not self.override_existing and not self.merge_permissions:
            # Default to override
            self.override_existing = True
        
        return self


class PermissionAuditLog(BaseSchema):
    """
    Permission change audit log.
    
    Comprehensive tracking of permission modifications for compliance
    and security auditing.
    """

    audit_id: str = Field(..., description="Audit log ID")
    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")

    # Change metadata
    changed_by: str = Field(..., description="Admin who made changes")
    changed_by_name: str = Field(..., description="Admin name")
    changed_at: datetime = Field(..., description="Change timestamp")

    # Change details
    permission_changes: Dict[str, Dict[str, Any]] = Field(
        ...,
        description="Permission changes in format {permission: {old: value, new: value}}",
    )
    change_type: Literal["grant", "revoke", "update", "template_applied"] = Field(
        ...,
        description="Type of change",
    )
    reason: Optional[str] = Field(
        default=None,
        description="Reason for change",
    )

    # Context
    ip_address: Optional[str] = Field(
        default=None,
        description="IP address of change initiator",
    )
    user_agent: Optional[str] = Field(
        default=None,
        description="User agent string",
    )
    template_applied: Optional[str] = Field(
        default=None,
        description="Template name if template was applied",
    )

    # Approval tracking (if applicable)
    requires_approval: bool = Field(
        default=False,
        description="Whether change requires approval",
    )
    approved_by: Optional[str] = Field(
        default=None,
        description="Admin who approved change",
    )
    approved_at: Optional[datetime] = Field(
        default=None,
        description="Approval timestamp",
    )

    @computed_field
    @property
    def changes_count(self) -> int:
        """Count of permission changes made."""
        return len(self.permission_changes)

    @computed_field
    @property
    def change_summary(self) -> str:
        """Human-readable summary of changes."""
        if self.template_applied:
            return f"Applied template '{self.template_applied}' ({self.changes_count} permissions changed)"
        
        return f"{self.change_type.title()}: {self.changes_count} permission(s) modified"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_profile.py ---
# --- File: app/schemas/supervisor/supervisor_profile.py ---
"""
Supervisor profile schemas with employment and personal information.

Provides comprehensive profile management with employment history,
performance summaries, and personal preferences.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import EmploymentType, SupervisorStatus

__all__ = [
    "SupervisorProfile",
    "SupervisorEmployment",
    "PerformanceSummary",
    "SupervisorProfileUpdate",
    "EmploymentHistory",
    "SupervisorPreferences",
]


class SupervisorEmployment(BaseSchema):
    """Detailed supervisor employment information."""
    
    employee_id: Optional[str] = Field(
        default=None,
        description="Employee/Staff ID",
    )
    join_date: date = Field(..., description="Joining date")
    employment_type: EmploymentType = Field(..., description="Employment type")
    shift_timing: Optional[str] = Field(
        default=None,
        description="Shift timing or working hours",
    )
    designation: Optional[str] = Field(
        default=None,
        description="Job designation/title",
    )
    
    # Current status
    status: SupervisorStatus = Field(..., description="Current employment status")
    is_active: bool = Field(..., description="Active employment status")
    
    # Contract details
    contract_start_date: Optional[date] = Field(
        default=None,
        description="Contract start date (for contract employees)",
    )
    contract_end_date: Optional[date] = Field(
        default=None,
        description="Contract end date (for contract employees)",
    )
    
    # Termination details (if applicable)
    termination_date: Optional[date] = Field(
        default=None,
        description="Termination date",
    )
    termination_reason: Optional[str] = Field(
        default=None,
        description="Termination reason",
    )
    eligible_for_rehire: Optional[bool] = Field(
        default=None,
        description="Eligible for rehire",
    )
    
    # Assignment details
    assigned_by: str = Field(..., description="Admin who assigned")
    assigned_by_name: str = Field(..., description="Admin name")
    assigned_date: date = Field(..., description="Assignment date")
    
    # Compensation (admin view only)
    salary: Optional[Decimal] = Field(
        default=None,
        ge=0,
        description="Monthly salary",
    )
    last_salary_revision: Optional[date] = Field(
        default=None,
        description="Last salary revision date",
    )

    @computed_field
    @property
    def tenure_days(self) -> int:
        """Calculate total tenure in days."""
        end_date = self.termination_date or date.today()
        return (end_date - self.join_date).days

    @computed_field
    @property
    def tenure_display(self) -> str:
        """Get human-readable tenure."""
        days = self.tenure_days
        
        if days < 30:
            return f"{days} days"
        
        months = days // 30
        if months < 12:
            return f"{months} months"
        
        years = months // 12
        remaining_months = months % 12
        
        if remaining_months == 0:
            return f"{years} {'year' if years == 1 else 'years'}"
        
        return f"{years}y {remaining_months}m"

    @computed_field
    @property
    def is_contract_employee(self) -> bool:
        """Check if employee is on contract."""
        return self.employment_type == EmploymentType.CONTRACT

    @computed_field
    @property
    def contract_status(self) -> Optional[str]:
        """Get contract status for contract employees."""
        if not self.is_contract_employee or not self.contract_end_date:
            return None
        
        today = date.today()
        days_remaining = (self.contract_end_date - today).days
        
        if days_remaining < 0:
            return "Expired"
        elif days_remaining == 0:
            return "Expires Today"
        elif days_remaining <= 30:
            return f"Expires in {days_remaining} days"
        else:
            return "Active"


class PerformanceSummary(BaseSchema):
    """Performance summary for supervisor profile."""
    
    # Complaint handling
    total_complaints_resolved: int = Field(
        default=0,
        ge=0,
        description="Total complaints resolved",
    )
    average_resolution_time_hours: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average resolution time in hours",
    )
    sla_compliance_rate: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        le=100,
        description="SLA compliance rate percentage",
    )
    
    # Attendance management
    total_attendance_records: int = Field(
        default=0,
        ge=0,
        description="Total attendance records created",
    )
    attendance_punctuality_rate: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        le=100,
        description="On-time attendance marking rate",
    )
    
    # Maintenance management
    total_maintenance_requests: int = Field(
        default=0,
        ge=0,
        description="Total maintenance requests handled",
    )
    maintenance_completion_rate: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        le=100,
        description="Maintenance completion rate",
    )
    
    # Current month performance
    current_month_complaints: int = Field(
        default=0,
        ge=0,
        description="Complaints handled this month",
    )
    current_month_attendance_records: int = Field(
        default=0,
        ge=0,
        description="Attendance records this month",
    )
    current_month_maintenance: int = Field(
        default=0,
        ge=0,
        description="Maintenance requests this month",
    )
    
    # Overall ratings
    performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Latest performance rating (1-5 scale)",
    )
    last_performance_review: Optional[date] = Field(
        default=None,
        description="Last performance review date",
    )
    
    # Student feedback
    student_satisfaction_score: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average student satisfaction rating",
    )
    student_feedback_count: int = Field(
        default=0,
        ge=0,
        description="Number of student feedback responses",
    )

    @computed_field
    @property
    def overall_efficiency_score(self) -> Decimal:
        """Calculate overall efficiency score."""
        scores = [
            float(self.sla_compliance_rate),
            float(self.attendance_punctuality_rate),
            float(self.maintenance_completion_rate),
        ]
        
        average_score = sum(scores) / len(scores)
        return Decimal(str(average_score)).quantize(Decimal("0.1"))

    @computed_field
    @property
    def performance_level(self) -> str:
        """Categorize performance level."""
        if not self.performance_rating:
            return "Not Rated"
        
        rating = float(self.performance_rating)
        if rating >= 4.5:
            return "Outstanding"
        elif rating >= 4.0:
            return "Excellent"
        elif rating >= 3.5:
            return "Good"
        elif rating >= 3.0:
            return "Satisfactory"
        elif rating >= 2.0:
            return "Needs Improvement"
        else:
            return "Unsatisfactory"


class EmploymentHistory(BaseSchema):
    """Employment history entry."""
    
    hostel_id: str = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    start_date: date = Field(..., description="Assignment start date")
    end_date: Optional[date] = Field(
        default=None,
        description="Assignment end date (null if current)",
    )
    designation: Optional[str] = Field(
        default=None,
        description="Designation during this period",
    )
    employment_type: EmploymentType = Field(
        ...,
        description="Employment type during this period",
    )
    reason_for_change: Optional[str] = Field(
        default=None,
        description="Reason for assignment change/end",
    )
    performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Performance rating for this period",
    )

    @computed_field
    @property
    def duration_days(self) -> int:
        """Calculate duration of this assignment."""
        end = self.end_date or date.today()
        return (end - self.start_date).days

    @computed_field
    @property
    def is_current(self) -> bool:
        """Check if this is the current assignment."""
        return self.end_date is None


class SupervisorPreferences(BaseSchema):
    """Supervisor personal preferences and settings."""
    
    # Notification preferences
    email_notifications: bool = Field(
        default=True,
        description="Enable email notifications",
    )
    sms_notifications: bool = Field(
        default=True,
        description="Enable SMS notifications",
    )
    push_notifications: bool = Field(
        default=True,
        description="Enable push notifications",
    )
    
    # Notification types
    complaint_notifications: bool = Field(
        default=True,
        description="Receive complaint notifications",
    )
    maintenance_notifications: bool = Field(
        default=True,
        description="Receive maintenance notifications",
    )
    attendance_reminders: bool = Field(
        default=True,
        description="Receive attendance marking reminders",
    )
    admin_announcements: bool = Field(
        default=True,
        description="Receive admin announcements",
    )
    
    # Dashboard preferences
    dashboard_refresh_interval: int = Field(
        default=300,
        ge=60,
        le=3600,
        description="Dashboard auto-refresh interval in seconds",
    )
    default_view: str = Field(
        default="dashboard",
        pattern=r"^(dashboard|complaints|attendance|maintenance|reports)$",
        description="Default view on login",
    )
    
    # Language and locale
    preferred_language: str = Field(
        default="en",
        pattern=r"^(en|hi|ta|te|bn|mr|gu)$",
        description="Preferred language",
    )
    timezone: str = Field(
        default="Asia/Kolkata",
        description="Preferred timezone",
    )
    
    # Working hours
    work_start_time: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Work start time (HH:MM)",
    )
    work_end_time: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Work end time (HH:MM)",
    )


class SupervisorProfile(BaseSchema):
    """Complete supervisor profile with all information."""
    
    id: str = Field(..., description="Supervisor ID")
    user_id: str = Field(..., description="User ID")
    
    # Personal information
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email address")
    phone: str = Field(..., description="Phone number")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )
    
    # Current assignment
    hostel_id: str = Field(..., description="Current hostel ID")
    hostel_name: str = Field(..., description="Current hostel name")
    
    # Employment details
    employment: SupervisorEmployment = Field(
        ...,
        description="Current employment information",
    )
    
    # Employment history
    employment_history: List[EmploymentHistory] = Field(
        default_factory=list,
        description="Employment history",
    )
    
    # Permissions
    permissions: dict = Field(
        default_factory=dict,
        description="Current permission settings",
    )
    
    # Performance
    performance_summary: PerformanceSummary = Field(
        ...,
        description="Performance summary",
    )
    
    # Preferences
    preferences: SupervisorPreferences = Field(
        ...,
        description="Personal preferences",
    )
    
    # Activity tracking
    last_login: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp",
    )
    total_logins: int = Field(
        default=0,
        ge=0,
        description="Total login count",
    )
    last_activity: Optional[datetime] = Field(
        default=None,
        description="Last activity timestamp",
    )

    @computed_field
    @property
    def total_experience_days(self) -> int:
        """Calculate total experience across all assignments."""
        total_days = 0
        for history in self.employment_history:
            total_days += history.duration_days
        
        # Add current assignment
        total_days += self.employment.tenure_days
        return total_days

    @computed_field
    @property
    def experience_display(self) -> str:
        """Get human-readable total experience."""
        days = self.total_experience_days
        
        if days < 30:
            return f"{days} days"
        
        months = days // 30
        if months < 12:
            return f"{months} months"
        
        years = months // 12
        remaining_months = months % 12
        
        if remaining_months == 0:
            return f"{years} {'year' if years == 1 else 'years'}"
        
        return f"{years}y {remaining_months}m"

    @computed_field
    @property
    def hostels_worked(self) -> int:
        """Count number of different hostels worked at."""
        hostel_ids = {self.hostel_id}
        for history in self.employment_history:
            hostel_ids.add(history.hostel_id)
        return len(hostel_ids)


class SupervisorProfileUpdate(BaseUpdateSchema):
    """Update supervisor profile (supervisor can update own profile)."""
    
    # Contact updates (may require admin approval)
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number",
    )
    
    # Preferences updates
    preferences: Optional[SupervisorPreferences] = Field(
        default=None,
        description="Updated preferences",
    )
    
    # Emergency contact
    emergency_contact_name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone",
    )
    emergency_contact_relation: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Emergency contact relation",
    )
    
    # Personal notes
    notes: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Personal notes",
    )

    @field_validator("phone", "emergency_contact_phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone numbers."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\supervisor_response.py ---
# --- File: app/schemas/supervisor/supervisor_response.py ---
"""
Supervisor response schemas for API responses.

Provides optimized response formats with computed properties
and efficient data serialization.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from functools import cached_property
from typing import Dict, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import EmploymentType, SupervisorStatus

__all__ = [
    "SupervisorResponse",
    "SupervisorDetail",
    "SupervisorListItem",
    "SupervisorSummary",
    "SupervisorEmploymentInfo",
    "SupervisorStatistics",
]


class SupervisorResponse(BaseResponseSchema):
    """
    Standard supervisor response schema.
    
    Optimized for general API responses with essential information.
    """

    user_id: str = Field(..., description="User ID")
    full_name: str = Field(..., description="Supervisor full name")
    email: str = Field(..., description="Email address")
    phone: str = Field(..., description="Phone number")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )

    # Assignment
    assigned_hostel_id: str = Field(..., description="Assigned hostel ID")
    hostel_name: str = Field(..., description="Hostel name")

    # Employment
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    join_date: date = Field(..., description="Joining date")
    employment_type: EmploymentType = Field(..., description="Employment type")
    designation: Optional[str] = Field(default=None, description="Designation")

    # Status
    status: SupervisorStatus = Field(..., description="Current status")
    is_active: bool = Field(..., description="Active status")

    # Assignment metadata
    assigned_by: str = Field(..., description="Admin who assigned")
    assigned_date: date = Field(..., description="Assignment date")

    @computed_field
    @property
    def tenure_days(self) -> int:
        """Calculate tenure in days since joining."""
        return (date.today() - self.join_date).days

    @computed_field
    @property
    def tenure_months(self) -> int:
        """Calculate approximate tenure in months."""
        return self.tenure_days // 30

    @computed_field
    @property
    def is_probation(self) -> bool:
        """Check if supervisor is in probation period (first 3 months)."""
        return self.tenure_months < 3


class SupervisorDetail(BaseResponseSchema):
    """
    Detailed supervisor information.
    
    Comprehensive profile with all attributes and computed metrics.
    """

    # User information
    user_id: str = Field(..., description="User ID")
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    gender: Optional[str] = Field(default=None, description="Gender")
    date_of_birth: Optional[date] = Field(default=None, description="Date of birth")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )

    # Hostel assignment
    assigned_hostel_id: str = Field(..., description="Assigned hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    assigned_by: str = Field(..., description="Admin user ID who assigned")
    assigned_by_name: str = Field(..., description="Admin name")
    assigned_date: date = Field(..., description="Assignment date")

    # Employment details
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    join_date: date = Field(..., description="Joining date")
    employment_type: EmploymentType = Field(..., description="Employment type")
    shift_timing: Optional[str] = Field(default=None, description="Shift timing")
    designation: Optional[str] = Field(default=None, description="Designation")
    salary: Optional[Decimal] = Field(
        default=None,
        description="Monthly salary (admin view only)",
    )

    # Status
    status: SupervisorStatus = Field(..., description="Current status")
    is_active: bool = Field(..., description="Active status")

    # Termination information
    termination_date: Optional[date] = Field(
        default=None,
        description="Termination date",
    )
    termination_reason: Optional[str] = Field(
        default=None,
        description="Termination reason",
    )
    eligible_for_rehire: Optional[bool] = Field(
        default=None,
        description="Rehire eligibility",
    )

    # Suspension information
    suspension_start_date: Optional[date] = Field(
        default=None,
        description="Suspension start date",
    )
    suspension_end_date: Optional[date] = Field(
        default=None,
        description="Suspension end date",
    )
    suspension_reason: Optional[str] = Field(
        default=None,
        description="Suspension reason",
    )

    # Permissions (optimized structure)
    permissions: Dict[str, bool | int | Decimal] = Field(
        default_factory=dict,
        description="Permission settings",
    )

    # Performance metrics (aggregated)
    total_complaints_resolved: int = Field(
        default=0,
        ge=0,
        description="Total complaints resolved",
    )
    average_resolution_time_hours: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average complaint resolution time",
    )
    total_attendance_records: int = Field(
        default=0,
        ge=0,
        description="Total attendance records created",
    )
    total_maintenance_requests: int = Field(
        default=0,
        ge=0,
        description="Total maintenance requests",
    )
    last_performance_review: Optional[date] = Field(
        default=None,
        description="Last performance review date",
    )
    performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Latest performance rating",
    )

    # Activity tracking
    last_login: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp",
    )
    total_logins: int = Field(
        default=0,
        ge=0,
        description="Total login count",
    )
    last_activity: Optional[datetime] = Field(
        default=None,
        description="Last activity timestamp",
    )

    # Administrative notes
    notes: Optional[str] = Field(
        default=None,
        description="Administrative notes",
    )

    @computed_field
    @property
    def age(self) -> Optional[int]:
        """Calculate age from date of birth."""
        if not self.date_of_birth:
            return None
        
        today = date.today()
        age = (
            today.year
            - self.date_of_birth.year
            - ((today.month, today.day) < (self.date_of_birth.month, self.date_of_birth.day))
        )
        return age

    @computed_field
    @property
    def tenure_months(self) -> int:
        """Calculate tenure in complete months."""
        return (date.today() - self.join_date).days // 30

    @computed_field
    @property
    def tenure_years(self) -> int:
        """Calculate tenure in complete years."""
        return self.tenure_months // 12

    @computed_field
    @property
    def is_probation(self) -> bool:
        """Check if supervisor is in probation period."""
        return self.tenure_months < 3

    @computed_field
    @property
    def can_work(self) -> bool:
        """Check if supervisor is currently allowed to work."""
        return self.is_active and self.status == SupervisorStatus.ACTIVE

    @computed_field
    @property
    def suspension_days_remaining(self) -> Optional[int]:
        """Calculate remaining suspension days if currently suspended."""
        if self.status != SupervisorStatus.SUSPENDED or not self.suspension_end_date:
            return None
        
        remaining = (self.suspension_end_date - date.today()).days
        return max(0, remaining)


class SupervisorListItem(BaseSchema):
    """
    Supervisor list item for efficient list rendering.
    
    Minimal information optimized for table/grid views.
    """

    id: str = Field(..., description="Supervisor ID")
    user_id: str = Field(..., description="User ID")
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image",
    )

    # Assignment
    hostel_name: str = Field(..., description="Assigned hostel")
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    designation: Optional[str] = Field(default=None, description="Designation")

    # Employment
    employment_type: EmploymentType = Field(..., description="Employment type")
    join_date: date = Field(..., description="Joining date")

    # Status
    status: SupervisorStatus = Field(..., description="Status")
    is_active: bool = Field(..., description="Active status")

    # Performance (current month)
    performance_rating: Optional[Decimal] = Field(
        default=None,
        ge=0,
        le=5,
        description="Performance rating",
    )
    complaints_resolved_this_month: int = Field(
        default=0,
        ge=0,
        description="Complaints resolved this month",
    )

    # Activity
    last_login: Optional[datetime] = Field(
        default=None,
        description="Last login",
    )

    @computed_field
    @property
    def tenure_months(self) -> int:
        """Calculate tenure in months."""
        return (date.today() - self.join_date).days // 30

    @computed_field
    @property
    def display_status(self) -> str:
        """Get human-readable status."""
        status_map = {
            SupervisorStatus.ACTIVE: "Active",
            SupervisorStatus.ON_LEAVE: "On Leave",
            SupervisorStatus.SUSPENDED: "Suspended",
            SupervisorStatus.TERMINATED: "Terminated",
        }
        return status_map.get(self.status, self.status.value)


class SupervisorSummary(BaseSchema):
    """
    Supervisor summary for dashboards.
    
    Optimized for quick overview with key metrics.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    full_name: str = Field(..., description="Full name")
    email: str = Field(..., description="Email")
    phone: str = Field(..., description="Phone")
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    designation: Optional[str] = Field(default=None, description="Designation")

    # Status
    status: SupervisorStatus = Field(..., description="Status")
    is_active: bool = Field(..., description="Active status")
    shift_timing: Optional[str] = Field(default=None, description="Shift timing")

    # Current month metrics
    complaints_handled_this_month: int = Field(
        default=0,
        ge=0,
        description="Complaints handled",
    )
    complaints_resolved_this_month: int = Field(
        default=0,
        ge=0,
        description="Complaints resolved",
    )
    attendance_records_this_month: int = Field(
        default=0,
        ge=0,
        description="Attendance records",
    )
    maintenance_requests_this_month: int = Field(
        default=0,
        ge=0,
        description="Maintenance requests",
    )

    # Activity
    last_active: Optional[datetime] = Field(
        default=None,
        description="Last activity",
    )
    is_online: bool = Field(
        default=False,
        description="Currently online",
    )

    @computed_field
    @property
    def complaint_resolution_rate(self) -> Decimal:
        """Calculate complaint resolution rate percentage."""
        if self.complaints_handled_this_month == 0:
            return Decimal("100.00")
        
        rate = (
            self.complaints_resolved_this_month
            / self.complaints_handled_this_month
            * 100
        )
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def activity_status(self) -> str:
        """Get human-readable activity status."""
        if self.is_online:
            return "Online"
        
        if not self.last_active:
            return "Never"
        
        hours_ago = (datetime.now() - self.last_active).total_seconds() / 3600
        
        if hours_ago < 1:
            return "Active recently"
        elif hours_ago < 24:
            return f"Active {int(hours_ago)}h ago"
        else:
            days_ago = int(hours_ago / 24)
            return f"Active {days_ago}d ago"


class SupervisorEmploymentInfo(BaseSchema):
    """
    Detailed employment information.
    
    Comprehensive contract and compensation details.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")

    # Employment details
    employee_id: Optional[str] = Field(default=None, description="Employee ID")
    join_date: date = Field(..., description="Joining date")
    employment_type: EmploymentType = Field(..., description="Employment type")
    designation: Optional[str] = Field(default=None, description="Designation")
    shift_timing: Optional[str] = Field(default=None, description="Shift timing")

    # Contract
    contract_start_date: Optional[date] = Field(
        default=None,
        description="Contract start date",
    )
    contract_end_date: Optional[date] = Field(
        default=None,
        description="Contract end date",
    )
    is_contract_active: bool = Field(
        default=True,
        description="Contract active status",
    )

    # Compensation
    salary: Optional[Decimal] = Field(
        default=None,
        description="Monthly salary",
    )
    last_salary_revision: Optional[date] = Field(
        default=None,
        description="Last salary revision date",
    )

    # Status
    status: SupervisorStatus = Field(..., description="Current status")
    is_active: bool = Field(..., description="Active status")

    # Assignment
    assigned_hostel: str = Field(..., description="Assigned hostel")
    assigned_by: str = Field(..., description="Admin who assigned")
    assigned_date: date = Field(..., description="Assignment date")

    # Termination
    termination_date: Optional[date] = Field(
        default=None,
        description="Termination date",
    )
    termination_reason: Optional[str] = Field(
        default=None,
        description="Termination reason",
    )
    eligible_for_rehire: Optional[bool] = Field(
        default=None,
        description="Rehire eligibility",
    )

    @computed_field
    @property
    def tenure_days(self) -> int:
        """Calculate total tenure in days."""
        end_date = self.termination_date or date.today()
        return (end_date - self.join_date).days

    @computed_field
    @property
    def tenure_display(self) -> str:
        """Get human-readable tenure."""
        days = self.tenure_days
        
        if days < 30:
            return f"{days} days"
        
        months = days // 30
        if months < 12:
            return f"{months} months"
        
        years = months // 12
        remaining_months = months % 12
        
        if remaining_months == 0:
            return f"{years} {'year' if years == 1 else 'years'}"
        
        return f"{years}y {remaining_months}m"

    @computed_field
    @property
    def is_contract_expiring_soon(self) -> bool:
        """Check if contract expires within 30 days."""
        if not self.contract_end_date or not self.is_contract_active:
            return False
        
        days_until_expiry = (self.contract_end_date - date.today()).days
        return 0 < days_until_expiry <= 30

    @computed_field
    @property
    def contract_status(self) -> str:
        """Get contract status description."""
        if not self.contract_end_date:
            return "Permanent"
        
        if not self.is_contract_active:
            return "Expired"
        
        days_remaining = (self.contract_end_date - date.today()).days
        
        if days_remaining < 0:
            return "Expired"
        elif days_remaining == 0:
            return "Expires today"
        elif days_remaining <= 7:
            return f"Expires in {days_remaining} days (urgent)"
        elif days_remaining <= 30:
            return f"Expires in {days_remaining} days"
        else:
            return f"Active (expires {self.contract_end_date.strftime('%b %Y')})"


class SupervisorStatistics(BaseSchema):
    """
    Comprehensive statistics and performance metrics.
    
    Aggregated data for reporting and analysis.
    """

    supervisor_id: str = Field(..., description="Supervisor ID")
    supervisor_name: str = Field(..., description="Supervisor name")
    calculation_period: str = Field(
        ...,
        description="Period for statistics",
        examples=["Last 30 days", "This month", "2024-01"],
    )

    # Complaint metrics
    total_complaints_assigned: int = Field(
        default=0,
        ge=0,
        description="Total complaints assigned",
    )
    complaints_resolved: int = Field(
        default=0,
        ge=0,
        description="Complaints resolved",
    )
    complaints_pending: int = Field(
        default=0,
        ge=0,
        description="Complaints pending",
    )
    average_resolution_time_hours: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average resolution time",
    )
    sla_compliance_rate: Decimal = Field(
        default=Decimal("100.00"),
        ge=0,
        le=100,
        description="SLA compliance percentage",
    )

    # Attendance metrics
    attendance_records_created: int = Field(
        default=0,
        ge=0,
        description="Attendance records created",
    )
    attendance_marked_on_time: int = Field(
        default=0,
        ge=0,
        description="Attendance marked on time",
    )
    leaves_processed: int = Field(
        default=0,
        ge=0,
        description="Leave requests processed",
    )

    # Maintenance metrics
    maintenance_requests_created: int = Field(
        default=0,
        ge=0,
        description="Maintenance requests created",
    )
    maintenance_completed: int = Field(
        default=0,
        ge=0,
        description="Maintenance completed",
    )
    average_maintenance_completion_hours: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average completion time",
    )

    # Communication metrics
    announcements_created: int = Field(
        default=0,
        ge=0,
        description="Announcements created",
    )
    announcement_reach: int = Field(
        default=0,
        ge=0,
        description="Total students reached",
    )

    # Activity metrics
    total_logins: int = Field(
        default=0,
        ge=0,
        description="Total logins",
    )
    active_days: int = Field(
        default=0,
        ge=0,
        description="Days with activity",
    )
    average_response_time_minutes: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average response time",
    )

    # Overall performance
    overall_performance_score: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Calculated performance score",
    )

    @computed_field
    @property
    def complaint_resolution_rate(self) -> Decimal:
        """Calculate complaint resolution rate percentage."""
        if self.total_complaints_assigned == 0:
            return Decimal("100.00")
        
        rate = (self.complaints_resolved / self.total_complaints_assigned * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def maintenance_completion_rate(self) -> Decimal:
        """Calculate maintenance completion rate percentage."""
        if self.maintenance_requests_created == 0:
            return Decimal("100.00")
        
        rate = (self.maintenance_completed / self.maintenance_requests_created * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def attendance_punctuality_rate(self) -> Decimal:
        """Calculate attendance marking punctuality rate."""
        if self.attendance_records_created == 0:
            return Decimal("100.00")
        
        rate = (self.attendance_marked_on_time / self.attendance_records_created * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def activity_rate(self) -> Decimal:
        """Calculate activity rate (active days / total days in period)."""
        # Assuming 30 days for "This month" or "Last 30 days"
        # In real implementation, this would be calculated from period
        total_days = 30
        
        if self.active_days == 0:
            return Decimal("0.00")
        
        rate = (self.active_days / total_days * 100)
        return Decimal(str(rate)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def performance_grade(self) -> str:
        """Get performance grade based on overall score."""
        score = float(self.overall_performance_score)
        
        if score >= 90:
            return "A+ (Excellent)"
        elif score >= 80:
            return "A (Very Good)"
        elif score >= 70:
            return "B+ (Good)"
        elif score >= 60:
            return "B (Satisfactory)"
        elif score >= 50:
            return "C (Needs Improvement)"
        else:
            return "D (Poor)"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\supervisor\__init__.py ---
"""
Supervisor schemas package
"""
from app.schemas.supervisor.supervisor_base import (
    SupervisorBase,
    SupervisorCreate,
    SupervisorUpdate
)
from app.schemas.supervisor.supervisor_response import (
    SupervisorResponse,
    SupervisorDetail,
    SupervisorListItem
)
from app.schemas.supervisor.supervisor_profile import (
    SupervisorProfile,
    SupervisorEmployment,
    SupervisorProfileUpdate
)
from app.schemas.supervisor.supervisor_permissions import (
    SupervisorPermissions,
    PermissionUpdate,
    PermissionCheckRequest,
    PermissionCheckResponse
)
from app.schemas.supervisor.supervisor_assignment import (
    SupervisorAssignment,
    AssignmentRequest,
    AssignmentUpdate,
    RevokeAssignmentRequest
)
from app.schemas.supervisor.supervisor_activity import (
    SupervisorActivityLog,
    ActivitySummary,
    ActivityDetail,
    ActivityFilterParams
)
from app.schemas.supervisor.supervisor_dashboard import (
    SupervisorDashboard,
    DashboardMetrics,
    TaskSummary
)
from app.schemas.supervisor.supervisor_performance import (
    PerformanceMetrics,
    PerformanceReport,
    PerformanceReview
)

__all__ = [
    # Base
    "SupervisorBase",
    "SupervisorCreate",
    "SupervisorUpdate",
    
    # Response
    "SupervisorResponse",
    "SupervisorDetail",
    "SupervisorListItem",
    
    # Profile
    "SupervisorProfile",
    "SupervisorEmployment",
    "SupervisorProfileUpdate",
    
    # Permissions
    "SupervisorPermissions",
    "PermissionUpdate",
    "PermissionCheckRequest",
    "PermissionCheckResponse",
    
    # Assignment
    "SupervisorAssignment",
    "AssignmentRequest",
    "AssignmentUpdate",
    "RevokeAssignmentRequest",
    
    # Activity
    "SupervisorActivityLog",
    "ActivitySummary",
    "ActivityDetail",
    "ActivityFilterParams",
    
    # Dashboard
    "SupervisorDashboard",
    "DashboardMetrics",
    "TaskSummary",
    
    # Performance
    "PerformanceMetrics",
    "PerformanceReport",
    "PerformanceReview",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\user =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\user\all_folders_files_content.txt ---
### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\user ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\user =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\user\user_base.py ---
# --- File: app/schemas/user/user_base.py ---
"""
User base schemas with enhanced validation and type safety.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import Gender, UserRole
from app.schemas.common.mixins import AddressMixin, EmergencyContactMixin

__all__ = [
    "UserBase",
    "UserCreate",
    "UserUpdate",
    "UserAddressUpdate",
    "UserEmergencyContactUpdate",
]


class UserBase(BaseSchema):
    """
    Base user schema with core user attributes.
    
    Contains common fields shared across user operations.
    """

    email: EmailStr = Field(
        ...,
        description="Email address (must be unique)",
        examples=["user@example.com"],
    )
    phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number (E.164 format recommended)",
        examples=["+919876543210"],
    )
    full_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Full name",
        examples=["John Doe"],
    )
    user_role: UserRole = Field(
        ...,
        description="User role for authorization",
    )
    gender: Optional[Gender] = Field(
        default=None,
        description="Gender (optional)",
    )
    date_of_birth: Optional[date] = Field(
        default=None,
        description="Date of birth",
    )
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
        examples=["https://example.com/images/profile.jpg"],
    )

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: EmailStr) -> str:
        """Normalize email to lowercase and trim whitespace."""
        return v.lower().strip()

    @field_validator("phone")
    @classmethod
    def normalize_phone(cls, v: str) -> str:
        """Normalize phone number by removing spaces and dashes."""
        return v.replace(" ", "").replace("-", "").strip()

    @field_validator("full_name")
    @classmethod
    def validate_full_name(cls, v: str) -> str:
        """
        Validate and normalize full name.
        
        Ensures name is properly formatted and contains valid characters.
        """
        v = v.strip()
        if len(v) < 2:
            raise ValueError("Full name must be at least 2 characters")
        if v.isdigit():
            raise ValueError("Full name cannot be only numbers")
        # Remove excessive whitespace
        v = " ".join(v.split())
        return v

    @field_validator("date_of_birth")
    @classmethod
    def validate_age(cls, v: Optional[date]) -> Optional[date]:
        """
        Validate user age constraints.
        
        Ensures user is at least 16 years old and date is not in the future.
        """
        if v is None:
            return v

        today = date.today()
        
        # Check if date is in the future
        if v >= today:
            raise ValueError("Date of birth cannot be in the future")

        # Calculate age
        age = today.year - v.year - ((today.month, today.day) < (v.month, v.day))
        
        if age < 16:
            raise ValueError("User must be at least 16 years old")
        if age > 100:
            raise ValueError("Invalid date of birth (age exceeds 100 years)")

        return v

    @field_validator("profile_image_url")
    @classmethod
    def validate_image_url(cls, v: Optional[str]) -> Optional[str]:
        """Validate profile image URL format."""
        if v is not None:
            v = v.strip()
            if v and not (v.startswith("http://") or v.startswith("https://")):
                raise ValueError("Profile image URL must start with http:// or https://")
        return v


class UserCreate(UserBase, BaseCreateSchema):
    """
    Create user schema with password validation.
    
    Used for creating new user accounts.
    """

    password: str = Field(
        ...,
        min_length=8,
        max_length=128,
        description="Password (min 8 chars with complexity requirements)",
    )

    @field_validator("password")
    @classmethod
    def validate_password_strength(cls, v: str) -> str:
        """
        Validate password meets strength requirements.
        
        Requirements:
        - Minimum 8 characters
        - At least one digit
        - At least one uppercase letter
        - At least one lowercase letter
        """
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters long")
        if not any(c.isdigit() for c in v):
            raise ValueError("Password must contain at least one digit")
        if not any(c.isupper() for c in v):
            raise ValueError("Password must contain at least one uppercase letter")
        if not any(c.islower() for c in v):
            raise ValueError("Password must contain at least one lowercase letter")
        return v


class UserUpdate(BaseUpdateSchema):
    """
    Update user schema with all fields optional.
    
    Used for partial updates to user profiles.
    """

    email: Optional[EmailStr] = Field(
        default=None,
        description="Email address",
    )
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number",
    )
    full_name: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=255,
        description="Full name",
    )
    gender: Optional[Gender] = Field(
        default=None,
        description="Gender",
    )
    date_of_birth: Optional[date] = Field(
        default=None,
        description="Date of birth",
    )
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Account active status",
    )

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: Optional[EmailStr]) -> Optional[str]:
        """Normalize email to lowercase and trim whitespace."""
        if v is not None:
            return v.lower().strip()
        return v

    @field_validator("phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone number by removing spaces and dashes."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return v

    @field_validator("full_name")
    @classmethod
    def validate_full_name(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize full name."""
        if v is not None:
            v = v.strip()
            if len(v) < 2:
                raise ValueError("Full name must be at least 2 characters")
            if v.isdigit():
                raise ValueError("Full name cannot be only numbers")
            v = " ".join(v.split())
        return v

    @field_validator("date_of_birth")
    @classmethod
    def validate_age(cls, v: Optional[date]) -> Optional[date]:
        """Validate user age constraints."""
        if v is not None:
            today = date.today()
            if v >= today:
                raise ValueError("Date of birth cannot be in the future")

            age = today.year - v.year - ((today.month, today.day) < (v.month, v.day))
            if age < 16:
                raise ValueError("User must be at least 16 years old")
            if age > 100:
                raise ValueError("Invalid date of birth")
        return v

    @field_validator("profile_image_url")
    @classmethod
    def validate_image_url(cls, v: Optional[str]) -> Optional[str]:
        """Validate profile image URL format."""
        if v is not None:
            v = v.strip()
            if v and not (v.startswith("http://") or v.startswith("https://")):
                raise ValueError("Profile image URL must start with http:// or https://")
        return v


class UserAddressUpdate(AddressMixin, BaseUpdateSchema):
    """
    Update user address information.
    
    Inherits address fields from AddressMixin.
    """

    # Override to make all fields optional for updates
    address_line1: Optional[str] = Field(
        default=None,
        min_length=5,
        max_length=255,
        description="Address line 1",
    )
    address_line2: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Address line 2",
    )
    city: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="City",
    )
    state: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="State",
    )
    pincode: Optional[str] = Field(
        default=None,
        pattern=r"^\d{6}$",
        description="6-digit pincode",
    )
    country: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="Country",
    )


class UserEmergencyContactUpdate(EmergencyContactMixin, BaseUpdateSchema):
    """
    Update emergency contact information.
    
    Inherits emergency contact fields from EmergencyContactMixin.
    """

    # Override to make all fields optional for updates
    emergency_contact_name: Optional[str] = Field(
        default=None,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone",
    )
    emergency_contact_relation: Optional[str] = Field(
        default=None,
        description="Relation to user",
    )

    @field_validator("emergency_contact_phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone number by removing spaces and dashes."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\user\user_profile.py ---
# --- File: app/schemas/user/user_profile.py ---
"""
User profile update schemas with comprehensive field validation.
"""

from __future__ import annotations

from datetime import date
from typing import Optional

from pydantic import EmailStr, Field, HttpUrl, field_validator

from app.schemas.common.base import BaseUpdateSchema
from app.schemas.common.enums import Gender

__all__ = [
    "ProfileUpdate",
    "ProfileImageUpdate",
    "ContactInfoUpdate",
    "NotificationPreferencesUpdate",
]


class ProfileUpdate(BaseUpdateSchema):
    """
    Update user profile information.
    
    Comprehensive profile update with personal and address information.
    """

    full_name: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=255,
        description="Full name",
        examples=["John Doe"],
    )
    gender: Optional[Gender] = Field(
        default=None,
        description="Gender",
    )
    date_of_birth: Optional[date] = Field(
        default=None,
        description="Date of birth",
    )
    address_line1: Optional[str] = Field(
        default=None,
        min_length=5,
        max_length=255,
        description="Address line 1",
    )
    address_line2: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Address line 2 (optional)",
    )
    city: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="City",
    )
    state: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="State",
    )
    pincode: Optional[str] = Field(
        default=None,
        pattern=r"^\d{6}$",
        description="6-digit pincode",
    )
    country: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="Country",
    )

    @field_validator("full_name")
    @classmethod
    def validate_full_name(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize full name."""
        if v is not None:
            v = v.strip()
            if len(v) < 2:
                raise ValueError("Full name must be at least 2 characters")
            if v.isdigit():
                raise ValueError("Full name cannot be only numbers")
            # Remove excessive whitespace
            v = " ".join(v.split())
        return v

    @field_validator("date_of_birth")
    @classmethod
    def validate_age(cls, v: Optional[date]) -> Optional[date]:
        """Validate date of birth for reasonable age constraints."""
        if v is not None:
            today = date.today()
            if v >= today:
                raise ValueError("Date of birth cannot be in the future")

            age = today.year - v.year - ((today.month, today.day) < (v.month, v.day))
            if age < 16:
                raise ValueError("User must be at least 16 years old")
            if age > 100:
                raise ValueError("Invalid date of birth")
        return v

    @field_validator("city", "state", "country")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize text fields."""
        if v is not None:
            v = v.strip()
            if v.isdigit():
                raise ValueError("Field cannot be only numbers")
            v = " ".join(v.split())
        return v


class ProfileImageUpdate(BaseUpdateSchema):
    """
    Update user profile image.
    
    Validates and updates the profile image URL.
    """

    profile_image_url: HttpUrl = Field(
        ...,
        description="Profile image URL (must be valid HTTP/HTTPS URL)",
        examples=["https://example.com/images/profile.jpg"],
    )


class ContactInfoUpdate(BaseUpdateSchema):
    """
    Update user contact information.
    
    Includes phone, email, and emergency contact details.
    """

    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number (E.164 format recommended)",
        examples=["+919876543210"],
    )
    email: Optional[EmailStr] = Field(
        default=None,
        description="Email address",
        examples=["user@example.com"],
    )
    emergency_contact_name: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=255,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone number",
    )
    emergency_contact_relation: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="Relation to emergency contact",
        examples=["Father", "Mother", "Spouse", "Friend"],
    )

    @field_validator("phone", "emergency_contact_phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone number by removing spaces and dashes."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return v

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: Optional[EmailStr]) -> Optional[str]:
        """Normalize email to lowercase and trim whitespace."""
        if v is not None:
            return v.lower().strip()
        return v

    @field_validator("emergency_contact_name", "emergency_contact_relation")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize text fields."""
        if v is not None:
            v = v.strip()
            if v.isdigit():
                raise ValueError("Field cannot be only numbers")
            v = " ".join(v.split())
        return v


class NotificationPreferencesUpdate(BaseUpdateSchema):
    """
    Update user notification preferences.
    
    Granular control over different notification channels and types.
    """

    # Channel preferences
    email_notifications: bool = Field(
        default=True,
        description="Enable email notifications",
    )
    sms_notifications: bool = Field(
        default=True,
        description="Enable SMS notifications",
    )
    push_notifications: bool = Field(
        default=True,
        description="Enable push notifications",
    )

    # Notification type preferences
    booking_notifications: bool = Field(
        default=True,
        description="Receive booking-related notifications",
    )
    payment_notifications: bool = Field(
        default=True,
        description="Receive payment notifications",
    )
    complaint_notifications: bool = Field(
        default=True,
        description="Receive complaint status updates",
    )
    announcement_notifications: bool = Field(
        default=True,
        description="Receive hostel announcements",
    )
    maintenance_notifications: bool = Field(
        default=True,
        description="Receive maintenance updates",
    )
    marketing_notifications: bool = Field(
        default=False,
        description="Receive marketing communications (opt-in)",
    )

    # Advanced preferences
    digest_frequency: Optional[str] = Field(
        default=None,
        pattern=r"^(immediate|daily|weekly|never)$",
        description="Notification digest frequency",
        examples=["immediate", "daily", "weekly", "never"],
    )
    quiet_hours_start: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Quiet hours start time (HH:MM format)",
        examples=["22:00"],
    )
    quiet_hours_end: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Quiet hours end time (HH:MM format)",
        examples=["08:00"],
    )

    @field_validator("digest_frequency")
    @classmethod
    def normalize_digest_frequency(cls, v: Optional[str]) -> Optional[str]:
        """Normalize digest frequency to lowercase."""
        if v is not None:
            return v.lower().strip()
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\user\user_response.py ---
# --- File: app/schemas/user/user_response.py ---
"""
User response schemas with comprehensive user information.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Optional
from uuid import UUID

from pydantic import Field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import Gender, UserRole

__all__ = [
    "UserResponse",
    "UserDetail",
    "UserListItem",
    "UserProfile",
    "UserStats",
]


class UserResponse(BaseResponseSchema):
    """
    Standard user response schema.
    
    Returns essential user information for general API responses.
    """

    email: str = Field(
        ...,
        description="Email address",
    )
    phone: str = Field(
        ...,
        description="Phone number",
    )
    full_name: str = Field(
        ...,
        description="Full name",
    )
    user_role: UserRole = Field(
        ...,
        description="User role",
    )
    is_active: bool = Field(
        ...,
        description="Account active status",
    )
    is_email_verified: bool = Field(
        ...,
        description="Email verification status",
    )
    is_phone_verified: bool = Field(
        ...,
        description="Phone verification status",
    )
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )
    last_login_at: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp (UTC)",
    )


class UserDetail(BaseResponseSchema):
    """
    Detailed user information schema.
    
    Comprehensive user profile with all available information.
    """

    # Basic information
    email: str = Field(..., description="Email address")
    phone: str = Field(..., description="Phone number")
    full_name: str = Field(..., description="Full name")
    user_role: UserRole = Field(..., description="User role")
    gender: Optional[Gender] = Field(default=None, description="Gender")
    date_of_birth: Optional[date] = Field(default=None, description="Date of birth")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )

    # Address information
    address_line1: Optional[str] = Field(
        default=None,
        description="Address line 1",
    )
    address_line2: Optional[str] = Field(
        default=None,
        description="Address line 2",
    )
    city: Optional[str] = Field(default=None, description="City")
    state: Optional[str] = Field(default=None, description="State")
    country: Optional[str] = Field(default=None, description="Country")
    pincode: Optional[str] = Field(default=None, description="Pincode")

    # Emergency contact
    emergency_contact_name: Optional[str] = Field(
        default=None,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        default=None,
        description="Emergency contact phone",
    )
    emergency_contact_relation: Optional[str] = Field(
        default=None,
        description="Relation to emergency contact",
    )

    # Account status
    is_active: bool = Field(..., description="Account active status")
    is_email_verified: bool = Field(..., description="Email verification status")
    is_phone_verified: bool = Field(..., description="Phone verification status")
    email_verified_at: Optional[datetime] = Field(
        default=None,
        description="Email verification timestamp",
    )
    phone_verified_at: Optional[datetime] = Field(
        default=None,
        description="Phone verification timestamp",
    )
    last_login_at: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp",
    )
    last_password_change_at: Optional[datetime] = Field(
        default=None,
        description="Last password change timestamp",
    )


class UserListItem(BaseSchema):
    """
    User list item schema.
    
    Minimal user information for list views and search results.
    """

    id: UUID = Field(..., description="User ID")
    email: str = Field(..., description="Email address")
    full_name: str = Field(..., description="Full name")
    user_role: UserRole = Field(..., description="User role")
    is_active: bool = Field(..., description="Account active status")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )
    created_at: datetime = Field(..., description="Registration date")
    last_login_at: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp",
    )


class UserProfile(BaseSchema):
    """
    Public user profile schema.
    
    Limited information suitable for public display.
    """

    id: UUID = Field(..., description="User ID")
    full_name: str = Field(..., description="Full name")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )
    user_role: UserRole = Field(..., description="User role")
    member_since: datetime = Field(
        ...,
        description="Member since (registration date)",
    )


class UserStats(BaseSchema):
    """
    User statistics schema.
    
    Aggregate statistics about user activity and engagement.
    """

    user_id: UUID = Field(..., description="User ID")
    total_bookings: int = Field(
        default=0,
        ge=0,
        description="Total number of bookings",
    )
    active_bookings: int = Field(
        default=0,
        ge=0,
        description="Number of active bookings",
    )
    completed_bookings: int = Field(
        default=0,
        ge=0,
        description="Number of completed bookings",
    )
    total_payments: int = Field(
        default=0,
        ge=0,
        description="Total number of payments",
    )
    total_amount_paid: float = Field(
        default=0.0,
        ge=0,
        description="Total amount paid (in currency)",
    )
    total_complaints: int = Field(
        default=0,
        ge=0,
        description="Total number of complaints raised",
    )
    resolved_complaints: int = Field(
        default=0,
        ge=0,
        description="Number of resolved complaints",
    )
    average_rating_given: Optional[float] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average rating given to hostels",
    )
    account_age_days: int = Field(
        ...,
        ge=0,
        description="Account age in days",
    )
    last_activity_at: Optional[datetime] = Field(
        default=None,
        description="Last activity timestamp",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\user\user_session.py ---
# --- File: app/schemas/user/user_session.py ---
"""
User session schemas with enhanced tracking and management.
"""

from __future__ import annotations

from datetime import datetime
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, IPvAnyAddress, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "UserSession",
    "SessionInfo",
    "ActiveSessionsList",
    "RevokeSessionRequest",
    "RevokeAllSessionsRequest",
    "CreateSessionRequest",
]


class UserSession(BaseResponseSchema):
    """
    User session database model representation.
    
    Persistent session information stored in database.
    """

    user_id: UUID = Field(
        ...,
        description="User ID associated with session",
    )
    device_info: Optional[Dict[str, str]] = Field(
        default=None,
        description="Device information (user agent, platform, etc.)",
    )
    ip_address: Optional[str] = Field(
        default=None,
        description="IP address from which session was created",
    )
    is_revoked: bool = Field(
        default=False,
        description="Whether session has been revoked",
    )
    expires_at: datetime = Field(
        ...,
        description="Session expiration timestamp (UTC)",
    )
    last_activity: datetime = Field(
        ...,
        description="Last activity timestamp (UTC)",
    )


class SessionInfo(BaseSchema):
    """
    Session information for display to users.
    
    Enhanced session details for frontend presentation.
    """

    session_id: UUID = Field(
        ...,
        description="Unique session identifier",
    )
    device_name: Optional[str] = Field(
        default=None,
        description="Device name/description",
        examples=["iPhone 13", "Chrome on Windows"],
    )
    device_type: Optional[str] = Field(
        default=None,
        description="Device category",
        examples=["mobile", "desktop", "tablet"],
    )
    browser: Optional[str] = Field(
        default=None,
        description="Browser name and version",
        examples=["Chrome 120.0", "Safari 17.1"],
    )
    os: Optional[str] = Field(
        default=None,
        description="Operating system",
        examples=["Windows 11", "macOS 14.0", "iOS 17.0"],
    )
    ip_address: Optional[str] = Field(
        default=None,
        description="IP address (masked for privacy)",
        examples=["192.168.1.***"],
    )
    location: Optional[str] = Field(
        default=None,
        description="Approximate location (city, country)",
        examples=["Mumbai, India", "New York, USA"],
    )
    is_current: bool = Field(
        default=False,
        description="Whether this is the current session",
    )
    created_at: datetime = Field(
        ...,
        description="Session creation timestamp",
    )
    last_activity: datetime = Field(
        ...,
        description="Last activity timestamp",
    )
    expires_at: datetime = Field(
        ...,
        description="Session expiration timestamp",
    )


class ActiveSessionsList(BaseSchema):
    """
    List of active user sessions.
    
    Response schema for retrieving all active sessions.
    """

    sessions: List[SessionInfo] = Field(
        ...,
        description="List of active sessions",
    )
    total_sessions: int = Field(
        ...,
        ge=0,
        description="Total number of active sessions",
    )
    current_session_id: Optional[UUID] = Field(
        default=None,
        description="ID of the current session making the request",
    )


class RevokeSessionRequest(BaseCreateSchema):
    """
    Request to revoke a specific session.
    
    Used to terminate a single session by ID.
    """

    session_id: UUID = Field(
        ...,
        description="Session ID to revoke",
    )


class RevokeAllSessionsRequest(BaseCreateSchema):
    """
    Request to revoke all sessions.
    
    Option to keep current session active for security.
    """

    keep_current: bool = Field(
        default=True,
        description="Keep current session active after revoking others",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for revoking all sessions (optional)",
        examples=["Security concern", "Lost device"],
    )


class CreateSessionRequest(BaseCreateSchema):
    """
    Request to create a new session.
    
    Used during login to track session information.
    """

    user_id: UUID = Field(
        ...,
        description="User ID for the session",
    )
    device_info: Optional[Dict[str, str]] = Field(
        default=None,
        description="Device information",
    )
    ip_address: Optional[str] = Field(
        default=None,
        description="IP address",
    )
    user_agent: Optional[str] = Field(
        default=None,
        max_length=500,
        description="User agent string",
    )
    remember_me: bool = Field(
        default=False,
        description="Whether to extend session duration",
    )

    @field_validator("ip_address")
    @classmethod
    def validate_ip_address(cls, v: Optional[str]) -> Optional[str]:
        """Validate IP address format."""
        if v is not None:
            v = v.strip()
            # Basic IP validation - can be enhanced
            if v and not (
                v.replace(".", "").replace(":", "").isalnum()
            ):
                raise ValueError("Invalid IP address format")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\user\__init__.py ---
# --- File: app/schemas/user/__init__.py ---
"""
User schemas package.

Re-exports commonly used user-related schemas for convenient imports.

Example:
    from app.schemas.user import UserCreate, UserResponse, ProfileUpdate
"""

from __future__ import annotations

from app.schemas.user.user_base import (
    UserAddressUpdate,
    UserBase,
    UserCreate,
    UserEmergencyContactUpdate,
    UserUpdate,
)
from app.schemas.user.user_profile import (
    ContactInfoUpdate,
    NotificationPreferencesUpdate,
    ProfileImageUpdate,
    ProfileUpdate,
)
from app.schemas.user.user_response import (
    UserDetail,
    UserListItem,
    UserProfile,
    UserResponse,
    UserStats,
)
from app.schemas.user.user_session import (
    ActiveSessionsList,
    CreateSessionRequest,
    RevokeAllSessionsRequest,
    RevokeSessionRequest,
    SessionInfo,
    UserSession,
)

__all__ = [
    # Base
    "UserBase",
    "UserCreate",
    "UserUpdate",
    "UserAddressUpdate",
    "UserEmergencyContactUpdate",
    # Profile
    "ProfileUpdate",
    "ProfileImageUpdate",
    "ContactInfoUpdate",
    "NotificationPreferencesUpdate",
    # Response
    "UserResponse",
    "UserDetail",
    "UserListItem",
    "UserProfile",
    "UserStats",
    # Session
    "UserSession",
    "SessionInfo",
    "ActiveSessionsList",
    "RevokeSessionRequest",
    "RevokeAllSessionsRequest",
    "CreateSessionRequest",
]


# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\user\user_base.py ---
# --- File: app/schemas/user/user_base.py ---
"""
User base schemas with enhanced validation and type safety.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import Gender, UserRole
from app.schemas.common.mixins import AddressMixin, EmergencyContactMixin

__all__ = [
    "UserBase",
    "UserCreate",
    "UserUpdate",
    "UserAddressUpdate",
    "UserEmergencyContactUpdate",
]


class UserBase(BaseSchema):
    """
    Base user schema with core user attributes.
    
    Contains common fields shared across user operations.
    """

    email: EmailStr = Field(
        ...,
        description="Email address (must be unique)",
        examples=["user@example.com"],
    )
    phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number (E.164 format recommended)",
        examples=["+919876543210"],
    )
    full_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Full name",
        examples=["John Doe"],
    )
    user_role: UserRole = Field(
        ...,
        description="User role for authorization",
    )
    gender: Optional[Gender] = Field(
        default=None,
        description="Gender (optional)",
    )
    date_of_birth: Optional[date] = Field(
        default=None,
        description="Date of birth",
    )
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
        examples=["https://example.com/images/profile.jpg"],
    )

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: EmailStr) -> str:
        """Normalize email to lowercase and trim whitespace."""
        return v.lower().strip()

    @field_validator("phone")
    @classmethod
    def normalize_phone(cls, v: str) -> str:
        """Normalize phone number by removing spaces and dashes."""
        return v.replace(" ", "").replace("-", "").strip()

    @field_validator("full_name")
    @classmethod
    def validate_full_name(cls, v: str) -> str:
        """
        Validate and normalize full name.
        
        Ensures name is properly formatted and contains valid characters.
        """
        v = v.strip()
        if len(v) < 2:
            raise ValueError("Full name must be at least 2 characters")
        if v.isdigit():
            raise ValueError("Full name cannot be only numbers")
        # Remove excessive whitespace
        v = " ".join(v.split())
        return v

    @field_validator("date_of_birth")
    @classmethod
    def validate_age(cls, v: Optional[date]) -> Optional[date]:
        """
        Validate user age constraints.
        
        Ensures user is at least 16 years old and date is not in the future.
        """
        if v is None:
            return v

        today = date.today()
        
        # Check if date is in the future
        if v >= today:
            raise ValueError("Date of birth cannot be in the future")

        # Calculate age
        age = today.year - v.year - ((today.month, today.day) < (v.month, v.day))
        
        if age < 16:
            raise ValueError("User must be at least 16 years old")
        if age > 100:
            raise ValueError("Invalid date of birth (age exceeds 100 years)")

        return v

    @field_validator("profile_image_url")
    @classmethod
    def validate_image_url(cls, v: Optional[str]) -> Optional[str]:
        """Validate profile image URL format."""
        if v is not None:
            v = v.strip()
            if v and not (v.startswith("http://") or v.startswith("https://")):
                raise ValueError("Profile image URL must start with http:// or https://")
        return v


class UserCreate(UserBase, BaseCreateSchema):
    """
    Create user schema with password validation.
    
    Used for creating new user accounts.
    """

    password: str = Field(
        ...,
        min_length=8,
        max_length=128,
        description="Password (min 8 chars with complexity requirements)",
    )

    @field_validator("password")
    @classmethod
    def validate_password_strength(cls, v: str) -> str:
        """
        Validate password meets strength requirements.
        
        Requirements:
        - Minimum 8 characters
        - At least one digit
        - At least one uppercase letter
        - At least one lowercase letter
        """
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters long")
        if not any(c.isdigit() for c in v):
            raise ValueError("Password must contain at least one digit")
        if not any(c.isupper() for c in v):
            raise ValueError("Password must contain at least one uppercase letter")
        if not any(c.islower() for c in v):
            raise ValueError("Password must contain at least one lowercase letter")
        return v


class UserUpdate(BaseUpdateSchema):
    """
    Update user schema with all fields optional.
    
    Used for partial updates to user profiles.
    """

    email: Optional[EmailStr] = Field(
        default=None,
        description="Email address",
    )
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number",
    )
    full_name: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=255,
        description="Full name",
    )
    gender: Optional[Gender] = Field(
        default=None,
        description="Gender",
    )
    date_of_birth: Optional[date] = Field(
        default=None,
        description="Date of birth",
    )
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )
    is_active: Optional[bool] = Field(
        default=None,
        description="Account active status",
    )

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: Optional[EmailStr]) -> Optional[str]:
        """Normalize email to lowercase and trim whitespace."""
        if v is not None:
            return v.lower().strip()
        return v

    @field_validator("phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone number by removing spaces and dashes."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return v

    @field_validator("full_name")
    @classmethod
    def validate_full_name(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize full name."""
        if v is not None:
            v = v.strip()
            if len(v) < 2:
                raise ValueError("Full name must be at least 2 characters")
            if v.isdigit():
                raise ValueError("Full name cannot be only numbers")
            v = " ".join(v.split())
        return v

    @field_validator("date_of_birth")
    @classmethod
    def validate_age(cls, v: Optional[date]) -> Optional[date]:
        """Validate user age constraints."""
        if v is not None:
            today = date.today()
            if v >= today:
                raise ValueError("Date of birth cannot be in the future")

            age = today.year - v.year - ((today.month, today.day) < (v.month, v.day))
            if age < 16:
                raise ValueError("User must be at least 16 years old")
            if age > 100:
                raise ValueError("Invalid date of birth")
        return v

    @field_validator("profile_image_url")
    @classmethod
    def validate_image_url(cls, v: Optional[str]) -> Optional[str]:
        """Validate profile image URL format."""
        if v is not None:
            v = v.strip()
            if v and not (v.startswith("http://") or v.startswith("https://")):
                raise ValueError("Profile image URL must start with http:// or https://")
        return v


class UserAddressUpdate(AddressMixin, BaseUpdateSchema):
    """
    Update user address information.
    
    Inherits address fields from AddressMixin.
    """

    # Override to make all fields optional for updates
    address_line1: Optional[str] = Field(
        default=None,
        min_length=5,
        max_length=255,
        description="Address line 1",
    )
    address_line2: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Address line 2",
    )
    city: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="City",
    )
    state: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="State",
    )
    pincode: Optional[str] = Field(
        default=None,
        pattern=r"^\d{6}$",
        description="6-digit pincode",
    )
    country: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="Country",
    )


class UserEmergencyContactUpdate(EmergencyContactMixin, BaseUpdateSchema):
    """
    Update emergency contact information.
    
    Inherits emergency contact fields from EmergencyContactMixin.
    """

    # Override to make all fields optional for updates
    emergency_contact_name: Optional[str] = Field(
        default=None,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone",
    )
    emergency_contact_relation: Optional[str] = Field(
        default=None,
        description="Relation to user",
    )

    @field_validator("emergency_contact_phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone number by removing spaces and dashes."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\user\user_profile.py ---
# --- File: app/schemas/user/user_profile.py ---
"""
User profile update schemas with comprehensive field validation.
"""

from __future__ import annotations

from datetime import date
from typing import Optional

from pydantic import EmailStr, Field, HttpUrl, field_validator

from app.schemas.common.base import BaseUpdateSchema
from app.schemas.common.enums import Gender

__all__ = [
    "ProfileUpdate",
    "ProfileImageUpdate",
    "ContactInfoUpdate",
    "NotificationPreferencesUpdate",
]


class ProfileUpdate(BaseUpdateSchema):
    """
    Update user profile information.
    
    Comprehensive profile update with personal and address information.
    """

    full_name: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=255,
        description="Full name",
        examples=["John Doe"],
    )
    gender: Optional[Gender] = Field(
        default=None,
        description="Gender",
    )
    date_of_birth: Optional[date] = Field(
        default=None,
        description="Date of birth",
    )
    address_line1: Optional[str] = Field(
        default=None,
        min_length=5,
        max_length=255,
        description="Address line 1",
    )
    address_line2: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Address line 2 (optional)",
    )
    city: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="City",
    )
    state: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="State",
    )
    pincode: Optional[str] = Field(
        default=None,
        pattern=r"^\d{6}$",
        description="6-digit pincode",
    )
    country: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="Country",
    )

    @field_validator("full_name")
    @classmethod
    def validate_full_name(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize full name."""
        if v is not None:
            v = v.strip()
            if len(v) < 2:
                raise ValueError("Full name must be at least 2 characters")
            if v.isdigit():
                raise ValueError("Full name cannot be only numbers")
            # Remove excessive whitespace
            v = " ".join(v.split())
        return v

    @field_validator("date_of_birth")
    @classmethod
    def validate_age(cls, v: Optional[date]) -> Optional[date]:
        """Validate date of birth for reasonable age constraints."""
        if v is not None:
            today = date.today()
            if v >= today:
                raise ValueError("Date of birth cannot be in the future")

            age = today.year - v.year - ((today.month, today.day) < (v.month, v.day))
            if age < 16:
                raise ValueError("User must be at least 16 years old")
            if age > 100:
                raise ValueError("Invalid date of birth")
        return v

    @field_validator("city", "state", "country")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize text fields."""
        if v is not None:
            v = v.strip()
            if v.isdigit():
                raise ValueError("Field cannot be only numbers")
            v = " ".join(v.split())
        return v


class ProfileImageUpdate(BaseUpdateSchema):
    """
    Update user profile image.
    
    Validates and updates the profile image URL.
    """

    profile_image_url: HttpUrl = Field(
        ...,
        description="Profile image URL (must be valid HTTP/HTTPS URL)",
        examples=["https://example.com/images/profile.jpg"],
    )


class ContactInfoUpdate(BaseUpdateSchema):
    """
    Update user contact information.
    
    Includes phone, email, and emergency contact details.
    """

    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number (E.164 format recommended)",
        examples=["+919876543210"],
    )
    email: Optional[EmailStr] = Field(
        default=None,
        description="Email address",
        examples=["user@example.com"],
    )
    emergency_contact_name: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=255,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone number",
    )
    emergency_contact_relation: Optional[str] = Field(
        default=None,
        min_length=2,
        max_length=100,
        description="Relation to emergency contact",
        examples=["Father", "Mother", "Spouse", "Friend"],
    )

    @field_validator("phone", "emergency_contact_phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone number by removing spaces and dashes."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return v

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: Optional[EmailStr]) -> Optional[str]:
        """Normalize email to lowercase and trim whitespace."""
        if v is not None:
            return v.lower().strip()
        return v

    @field_validator("emergency_contact_name", "emergency_contact_relation")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize text fields."""
        if v is not None:
            v = v.strip()
            if v.isdigit():
                raise ValueError("Field cannot be only numbers")
            v = " ".join(v.split())
        return v


class NotificationPreferencesUpdate(BaseUpdateSchema):
    """
    Update user notification preferences.
    
    Granular control over different notification channels and types.
    """

    # Channel preferences
    email_notifications: bool = Field(
        default=True,
        description="Enable email notifications",
    )
    sms_notifications: bool = Field(
        default=True,
        description="Enable SMS notifications",
    )
    push_notifications: bool = Field(
        default=True,
        description="Enable push notifications",
    )

    # Notification type preferences
    booking_notifications: bool = Field(
        default=True,
        description="Receive booking-related notifications",
    )
    payment_notifications: bool = Field(
        default=True,
        description="Receive payment notifications",
    )
    complaint_notifications: bool = Field(
        default=True,
        description="Receive complaint status updates",
    )
    announcement_notifications: bool = Field(
        default=True,
        description="Receive hostel announcements",
    )
    maintenance_notifications: bool = Field(
        default=True,
        description="Receive maintenance updates",
    )
    marketing_notifications: bool = Field(
        default=False,
        description="Receive marketing communications (opt-in)",
    )

    # Advanced preferences
    digest_frequency: Optional[str] = Field(
        default=None,
        pattern=r"^(immediate|daily|weekly|never)$",
        description="Notification digest frequency",
        examples=["immediate", "daily", "weekly", "never"],
    )
    quiet_hours_start: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Quiet hours start time (HH:MM format)",
        examples=["22:00"],
    )
    quiet_hours_end: Optional[str] = Field(
        default=None,
        pattern=r"^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Quiet hours end time (HH:MM format)",
        examples=["08:00"],
    )

    @field_validator("digest_frequency")
    @classmethod
    def normalize_digest_frequency(cls, v: Optional[str]) -> Optional[str]:
        """Normalize digest frequency to lowercase."""
        if v is not None:
            return v.lower().strip()
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\user\user_response.py ---
# --- File: app/schemas/user/user_response.py ---
"""
User response schemas with comprehensive user information.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Optional
from uuid import UUID

from pydantic import Field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import Gender, UserRole

__all__ = [
    "UserResponse",
    "UserDetail",
    "UserListItem",
    "UserProfile",
    "UserStats",
]


class UserResponse(BaseResponseSchema):
    """
    Standard user response schema.
    
    Returns essential user information for general API responses.
    """

    email: str = Field(
        ...,
        description="Email address",
    )
    phone: str = Field(
        ...,
        description="Phone number",
    )
    full_name: str = Field(
        ...,
        description="Full name",
    )
    user_role: UserRole = Field(
        ...,
        description="User role",
    )
    is_active: bool = Field(
        ...,
        description="Account active status",
    )
    is_email_verified: bool = Field(
        ...,
        description="Email verification status",
    )
    is_phone_verified: bool = Field(
        ...,
        description="Phone verification status",
    )
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )
    last_login_at: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp (UTC)",
    )


class UserDetail(BaseResponseSchema):
    """
    Detailed user information schema.
    
    Comprehensive user profile with all available information.
    """

    # Basic information
    email: str = Field(..., description="Email address")
    phone: str = Field(..., description="Phone number")
    full_name: str = Field(..., description="Full name")
    user_role: UserRole = Field(..., description="User role")
    gender: Optional[Gender] = Field(default=None, description="Gender")
    date_of_birth: Optional[date] = Field(default=None, description="Date of birth")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )

    # Address information
    address_line1: Optional[str] = Field(
        default=None,
        description="Address line 1",
    )
    address_line2: Optional[str] = Field(
        default=None,
        description="Address line 2",
    )
    city: Optional[str] = Field(default=None, description="City")
    state: Optional[str] = Field(default=None, description="State")
    country: Optional[str] = Field(default=None, description="Country")
    pincode: Optional[str] = Field(default=None, description="Pincode")

    # Emergency contact
    emergency_contact_name: Optional[str] = Field(
        default=None,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        default=None,
        description="Emergency contact phone",
    )
    emergency_contact_relation: Optional[str] = Field(
        default=None,
        description="Relation to emergency contact",
    )

    # Account status
    is_active: bool = Field(..., description="Account active status")
    is_email_verified: bool = Field(..., description="Email verification status")
    is_phone_verified: bool = Field(..., description="Phone verification status")
    email_verified_at: Optional[datetime] = Field(
        default=None,
        description="Email verification timestamp",
    )
    phone_verified_at: Optional[datetime] = Field(
        default=None,
        description="Phone verification timestamp",
    )
    last_login_at: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp",
    )
    last_password_change_at: Optional[datetime] = Field(
        default=None,
        description="Last password change timestamp",
    )


class UserListItem(BaseSchema):
    """
    User list item schema.
    
    Minimal user information for list views and search results.
    """

    id: UUID = Field(..., description="User ID")
    email: str = Field(..., description="Email address")
    full_name: str = Field(..., description="Full name")
    user_role: UserRole = Field(..., description="User role")
    is_active: bool = Field(..., description="Account active status")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )
    created_at: datetime = Field(..., description="Registration date")
    last_login_at: Optional[datetime] = Field(
        default=None,
        description="Last login timestamp",
    )


class UserProfile(BaseSchema):
    """
    Public user profile schema.
    
    Limited information suitable for public display.
    """

    id: UUID = Field(..., description="User ID")
    full_name: str = Field(..., description="Full name")
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
    )
    user_role: UserRole = Field(..., description="User role")
    member_since: datetime = Field(
        ...,
        description="Member since (registration date)",
    )


class UserStats(BaseSchema):
    """
    User statistics schema.
    
    Aggregate statistics about user activity and engagement.
    """

    user_id: UUID = Field(..., description="User ID")
    total_bookings: int = Field(
        default=0,
        ge=0,
        description="Total number of bookings",
    )
    active_bookings: int = Field(
        default=0,
        ge=0,
        description="Number of active bookings",
    )
    completed_bookings: int = Field(
        default=0,
        ge=0,
        description="Number of completed bookings",
    )
    total_payments: int = Field(
        default=0,
        ge=0,
        description="Total number of payments",
    )
    total_amount_paid: float = Field(
        default=0.0,
        ge=0,
        description="Total amount paid (in currency)",
    )
    total_complaints: int = Field(
        default=0,
        ge=0,
        description="Total number of complaints raised",
    )
    resolved_complaints: int = Field(
        default=0,
        ge=0,
        description="Number of resolved complaints",
    )
    average_rating_given: Optional[float] = Field(
        default=None,
        ge=0,
        le=5,
        description="Average rating given to hostels",
    )
    account_age_days: int = Field(
        ...,
        ge=0,
        description="Account age in days",
    )
    last_activity_at: Optional[datetime] = Field(
        default=None,
        description="Last activity timestamp",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\user\user_session.py ---
# --- File: app/schemas/user/user_session.py ---
"""
User session schemas with enhanced tracking and management.
"""

from __future__ import annotations

from datetime import datetime
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, IPvAnyAddress, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "UserSession",
    "SessionInfo",
    "ActiveSessionsList",
    "RevokeSessionRequest",
    "RevokeAllSessionsRequest",
    "CreateSessionRequest",
]


class UserSession(BaseResponseSchema):
    """
    User session database model representation.
    
    Persistent session information stored in database.
    """

    user_id: UUID = Field(
        ...,
        description="User ID associated with session",
    )
    device_info: Optional[Dict[str, str]] = Field(
        default=None,
        description="Device information (user agent, platform, etc.)",
    )
    ip_address: Optional[str] = Field(
        default=None,
        description="IP address from which session was created",
    )
    is_revoked: bool = Field(
        default=False,
        description="Whether session has been revoked",
    )
    expires_at: datetime = Field(
        ...,
        description="Session expiration timestamp (UTC)",
    )
    last_activity: datetime = Field(
        ...,
        description="Last activity timestamp (UTC)",
    )


class SessionInfo(BaseSchema):
    """
    Session information for display to users.
    
    Enhanced session details for frontend presentation.
    """

    session_id: UUID = Field(
        ...,
        description="Unique session identifier",
    )
    device_name: Optional[str] = Field(
        default=None,
        description="Device name/description",
        examples=["iPhone 13", "Chrome on Windows"],
    )
    device_type: Optional[str] = Field(
        default=None,
        description="Device category",
        examples=["mobile", "desktop", "tablet"],
    )
    browser: Optional[str] = Field(
        default=None,
        description="Browser name and version",
        examples=["Chrome 120.0", "Safari 17.1"],
    )
    os: Optional[str] = Field(
        default=None,
        description="Operating system",
        examples=["Windows 11", "macOS 14.0", "iOS 17.0"],
    )
    ip_address: Optional[str] = Field(
        default=None,
        description="IP address (masked for privacy)",
        examples=["192.168.1.***"],
    )
    location: Optional[str] = Field(
        default=None,
        description="Approximate location (city, country)",
        examples=["Mumbai, India", "New York, USA"],
    )
    is_current: bool = Field(
        default=False,
        description="Whether this is the current session",
    )
    created_at: datetime = Field(
        ...,
        description="Session creation timestamp",
    )
    last_activity: datetime = Field(
        ...,
        description="Last activity timestamp",
    )
    expires_at: datetime = Field(
        ...,
        description="Session expiration timestamp",
    )


class ActiveSessionsList(BaseSchema):
    """
    List of active user sessions.
    
    Response schema for retrieving all active sessions.
    """

    sessions: List[SessionInfo] = Field(
        ...,
        description="List of active sessions",
    )
    total_sessions: int = Field(
        ...,
        ge=0,
        description="Total number of active sessions",
    )
    current_session_id: Optional[UUID] = Field(
        default=None,
        description="ID of the current session making the request",
    )


class RevokeSessionRequest(BaseCreateSchema):
    """
    Request to revoke a specific session.
    
    Used to terminate a single session by ID.
    """

    session_id: UUID = Field(
        ...,
        description="Session ID to revoke",
    )


class RevokeAllSessionsRequest(BaseCreateSchema):
    """
    Request to revoke all sessions.
    
    Option to keep current session active for security.
    """

    keep_current: bool = Field(
        default=True,
        description="Keep current session active after revoking others",
    )
    reason: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Reason for revoking all sessions (optional)",
        examples=["Security concern", "Lost device"],
    )


class CreateSessionRequest(BaseCreateSchema):
    """
    Request to create a new session.
    
    Used during login to track session information.
    """

    user_id: UUID = Field(
        ...,
        description="User ID for the session",
    )
    device_info: Optional[Dict[str, str]] = Field(
        default=None,
        description="Device information",
    )
    ip_address: Optional[str] = Field(
        default=None,
        description="IP address",
    )
    user_agent: Optional[str] = Field(
        default=None,
        max_length=500,
        description="User agent string",
    )
    remember_me: bool = Field(
        default=False,
        description="Whether to extend session duration",
    )

    @field_validator("ip_address")
    @classmethod
    def validate_ip_address(cls, v: Optional[str]) -> Optional[str]:
        """Validate IP address format."""
        if v is not None:
            v = v.strip()
            # Basic IP validation - can be enhanced
            if v and not (
                v.replace(".", "").replace(":", "").isalnum()
            ):
                raise ValueError("Invalid IP address format")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\user\__init__.py ---
# --- File: app/schemas/user/__init__.py ---
"""
User schemas package.

Re-exports commonly used user-related schemas for convenient imports.

Example:
    from app.schemas.user import UserCreate, UserResponse, ProfileUpdate
"""

from __future__ import annotations

from app.schemas.user.user_base import (
    UserAddressUpdate,
    UserBase,
    UserCreate,
    UserEmergencyContactUpdate,
    UserUpdate,
)
from app.schemas.user.user_profile import (
    ContactInfoUpdate,
    NotificationPreferencesUpdate,
    ProfileImageUpdate,
    ProfileUpdate,
)
from app.schemas.user.user_response import (
    UserDetail,
    UserListItem,
    UserProfile,
    UserResponse,
    UserStats,
)
from app.schemas.user.user_session import (
    ActiveSessionsList,
    CreateSessionRequest,
    RevokeAllSessionsRequest,
    RevokeSessionRequest,
    SessionInfo,
    UserSession,
)

__all__ = [
    # Base
    "UserBase",
    "UserCreate",
    "UserUpdate",
    "UserAddressUpdate",
    "UserEmergencyContactUpdate",
    # Profile
    "ProfileUpdate",
    "ProfileImageUpdate",
    "ContactInfoUpdate",
    "NotificationPreferencesUpdate",
    # Response
    "UserResponse",
    "UserDetail",
    "UserListItem",
    "UserProfile",
    "UserStats",
    # Session
    "UserSession",
    "SessionInfo",
    "ActiveSessionsList",
    "RevokeSessionRequest",
    "RevokeAllSessionsRequest",
    "CreateSessionRequest",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\user\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\visitor =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\visitor\visitor_base.py ---
# --- File: app/schemas/visitor/visitor_base.py ---
"""
Visitor base schemas with comprehensive validation and documentation.

This module defines the core visitor schemas for profile management,
preferences, and notification settings.
"""

from __future__ import annotations

from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import RoomType

__all__ = [
    "VisitorBase",
    "VisitorCreate",
    "VisitorUpdate",
]


class VisitorBase(BaseSchema):
    """
    Base visitor schema with preferences and notification settings.
    
    This schema contains all common fields used across visitor operations
    including room preferences, budget constraints, location preferences,
    and notification settings.
    """

    user_id: UUID = Field(
        ...,
        description="Unique identifier of the associated user account",
    )

    # Room Preferences
    preferred_room_type: Optional[RoomType] = Field(
        None,
        description="Preferred room type (single, double, triple, etc.)",
    )

    # Budget Constraints
    budget_min: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Minimum budget per month in local currency",
    )
    budget_max: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Maximum budget per month in local currency",
    )

    # Location Preferences
    preferred_cities: List[str] = Field(
        default_factory=list,
        description="List of preferred cities for hostel search",
        max_length=20,
    )

    # Amenity Preferences
    preferred_amenities: List[str] = Field(
        default_factory=list,
        description="List of must-have amenities (WiFi, AC, Mess, etc.)",
        max_length=30,
    )

    # Saved/Favorite Hostels
    favorite_hostel_ids: List[UUID] = Field(
        default_factory=list,
        description="List of favorite/saved hostel IDs",
        max_length=100,
    )

    # Notification Preferences
    email_notifications: bool = Field(
        True,
        description="Enable/disable email notifications",
    )
    sms_notifications: bool = Field(
        True,
        description="Enable/disable SMS notifications",
    )
    push_notifications: bool = Field(
        True,
        description="Enable/disable push notifications",
    )

    @field_validator("budget_min", "budget_max")
    @classmethod
    def validate_budget_positive(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Ensure budget values are positive if provided."""
        if v is not None and v < 0:
            raise ValueError("Budget must be a positive value")
        return v

    @model_validator(mode="after")
    def validate_budget_range(self) -> "VisitorBase":
        """Validate that budget_max is greater than or equal to budget_min."""
        if (
            self.budget_min is not None
            and self.budget_max is not None
            and self.budget_max < self.budget_min
        ):
            raise ValueError(
                f"Maximum budget ({self.budget_max}) must be greater than or "
                f"equal to minimum budget ({self.budget_min})"
            )
        return self

    @field_validator("preferred_cities")
    @classmethod
    def validate_cities(cls, v: List[str]) -> List[str]:
        """Validate and normalize city names."""
        if not v:
            return v

        # Remove duplicates while preserving order
        seen = set()
        unique_cities = []
        for city in v:
            city_normalized = city.strip().title()
            if city_normalized and city_normalized not in seen:
                seen.add(city_normalized)
                unique_cities.append(city_normalized)

        if len(unique_cities) > 20:
            raise ValueError("Maximum 20 preferred cities allowed")

        return unique_cities

    @field_validator("preferred_amenities")
    @classmethod
    def validate_amenities(cls, v: List[str]) -> List[str]:
        """Validate and normalize amenity names."""
        if not v:
            return v

        # Remove duplicates and normalize
        seen = set()
        unique_amenities = []
        for amenity in v:
            amenity_normalized = amenity.strip().lower()
            if amenity_normalized and amenity_normalized not in seen:
                seen.add(amenity_normalized)
                unique_amenities.append(amenity_normalized)

        if len(unique_amenities) > 30:
            raise ValueError("Maximum 30 preferred amenities allowed")

        return unique_amenities

    @field_validator("favorite_hostel_ids")
    @classmethod
    def validate_favorites(cls, v: List[UUID]) -> List[UUID]:
        """Validate favorite hostel IDs list."""
        if not v:
            return v

        # Remove duplicates while preserving order
        seen = set()
        unique_favorites = []
        for hostel_id in v:
            if hostel_id not in seen:
                seen.add(hostel_id)
                unique_favorites.append(hostel_id)

        if len(unique_favorites) > 100:
            raise ValueError("Maximum 100 favorite hostels allowed")

        return unique_favorites

    @property
    def has_budget_preference(self) -> bool:
        """Check if visitor has set any budget preference."""
        return self.budget_min is not None or self.budget_max is not None

    @property
    def has_location_preference(self) -> bool:
        """Check if visitor has set location preferences."""
        return len(self.preferred_cities) > 0

    @property
    def notification_enabled_count(self) -> int:
        """Count how many notification channels are enabled."""
        return sum(
            [
                self.email_notifications,
                self.sms_notifications,
                self.push_notifications,
            ]
        )


class VisitorCreate(VisitorBase, BaseCreateSchema):
    """
    Schema for creating a new visitor profile.
    
    Inherits all fields from VisitorBase. All fields are optional
    at creation except user_id, allowing visitors to gradually
    build their preferences.
    """

    # Override to make fields optional at creation
    preferred_cities: List[str] = Field(
        default_factory=list,
        description="List of preferred cities (can be added later)",
    )
    preferred_amenities: List[str] = Field(
        default_factory=list,
        description="List of preferred amenities (can be added later)",
    )
    favorite_hostel_ids: List[UUID] = Field(
        default_factory=list,
        description="Initially empty, populated as user saves hostels",
    )


class VisitorUpdate(BaseUpdateSchema):
    """
    Schema for updating visitor profile.
    
    All fields are optional, allowing partial updates.
    Only provided fields will be updated.
    """

    # Room Preferences
    preferred_room_type: Optional[RoomType] = Field(
        None,
        description="Update preferred room type",
    )

    # Budget
    budget_min: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Update minimum budget",
    )
    budget_max: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Update maximum budget",
    )

    # Location
    preferred_cities: Optional[List[str]] = Field(
        None,
        description="Update preferred cities list",
    )

    # Amenities
    preferred_amenities: Optional[List[str]] = Field(
        None,
        description="Update preferred amenities list",
    )

    # Notification Preferences
    email_notifications: Optional[bool] = Field(
        None,
        description="Enable/disable email notifications",
    )
    sms_notifications: Optional[bool] = Field(
        None,
        description="Enable/disable SMS notifications",
    )
    push_notifications: Optional[bool] = Field(
        None,
        description="Enable/disable push notifications",
    )

    @field_validator("budget_min", "budget_max")
    @classmethod
    def validate_budget_positive(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Ensure budget values are positive if provided."""
        if v is not None and v < 0:
            raise ValueError("Budget must be a positive value")
        return v

    @model_validator(mode="after")
    def validate_budget_range(self) -> "VisitorUpdate":
        """Validate that budget_max is greater than or equal to budget_min if both provided."""
        if (
            self.budget_min is not None
            and self.budget_max is not None
            and self.budget_max < self.budget_min
        ):
            raise ValueError(
                f"Maximum budget ({self.budget_max}) must be greater than or "
                f"equal to minimum budget ({self.budget_min})"
            )
        return self

    @field_validator("preferred_cities")
    @classmethod
    def validate_cities(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """Validate and normalize city names."""
        if v is None:
            return v

        # Remove duplicates while preserving order
        seen = set()
        unique_cities = []
        for city in v:
            city_normalized = city.strip().title()
            if city_normalized and city_normalized not in seen:
                seen.add(city_normalized)
                unique_cities.append(city_normalized)

        if len(unique_cities) > 20:
            raise ValueError("Maximum 20 preferred cities allowed")

        return unique_cities

    @field_validator("preferred_amenities")
    @classmethod
    def validate_amenities(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """Validate and normalize amenity names."""
        if v is None:
            return v

        # Remove duplicates and normalize
        seen = set()
        unique_amenities = []
        for amenity in v:
            amenity_normalized = amenity.strip().lower()
            if amenity_normalized and amenity_normalized not in seen:
                seen.add(amenity_normalized)
                unique_amenities.append(amenity_normalized)

        if len(unique_amenities) > 30:
            raise ValueError("Maximum 30 preferred amenities allowed")

        return unique_amenities

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\visitor\visitor_dashboard.py ---
# --- File: app/schemas/visitor/visitor_dashboard.py ---
"""
Visitor dashboard schemas for comprehensive dashboard views.

This module defines schemas for visitor dashboard including saved hostels,
booking history, recent activity, recommendations, and alerts.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator

from app.schemas.common.base import BaseSchema

__all__ = [
    "VisitorDashboard",
    "SavedHostels",
    "SavedHostelItem",
    "BookingHistory",
    "BookingHistoryItem",
    "RecentSearch",
    "RecentlyViewedHostel",
    "RecommendedHostel",
    "PriceDropAlert",
    "AvailabilityAlert",
]


class SavedHostelItem(BaseSchema):
    """
    Individual saved/favorite hostel item.
    
    Contains hostel details, pricing information, and
    tracking metadata for saved hostels.
    """

    hostel_id: UUID = Field(
        ...,
        description="Unique hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Name of the hostel",
    )
    hostel_city: str = Field(
        ...,
        description="City where hostel is located",
    )
    starting_price: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Starting price per month",
    )
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average rating (0-5)",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Number of available beds",
    )
    cover_image_url: Optional[str] = Field(
        None,
        description="URL to cover image",
    )

    # Save Metadata
    saved_at: datetime = Field(
        ...,
        description="When hostel was saved to favorites",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Personal notes about this hostel",
    )

    # Price Tracking
    price_when_saved: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Price when hostel was first saved",
    )
    current_price: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Current price",
    )
    price_changed: bool = Field(
        ...,
        description="Whether price has changed since saving",
    )
    price_change_percentage: Optional[Decimal] = Field(
        None,
        description="Percentage change in price (negative = drop, positive = increase)",
    )

    @computed_field
    @property
    def has_availability(self) -> bool:
        """Check if hostel has available beds."""
        return self.available_beds > 0

    @computed_field
    @property
    def price_drop_amount(self) -> Optional[Decimal]:
        """Calculate absolute price drop amount if applicable."""
        if self.price_changed and self.current_price < self.price_when_saved:
            return (self.price_when_saved - self.current_price).quantize(
                Decimal("0.01")
            )
        return None

    @computed_field
    @property
    def is_good_deal(self) -> bool:
        """Determine if this is a good deal (price dropped or high rating with availability)."""
        price_dropped = (
            self.price_changed and self.current_price < self.price_when_saved
        )
        high_rated_available = self.average_rating >= Decimal("4.0") and self.has_availability
        return price_dropped or high_rated_available


class SavedHostels(BaseSchema):
    """
    Collection of saved/favorite hostels.
    """

    total_saved: int = Field(
        ...,
        ge=0,
        description="Total number of saved hostels",
    )
    hostels: List[SavedHostelItem] = Field(
        default_factory=list,
        description="List of saved hostel items",
    )

    @computed_field
    @property
    def hostels_with_price_drops(self) -> int:
        """Count hostels with price drops."""
        return sum(
            1
            for h in self.hostels
            if h.price_changed and h.current_price < h.price_when_saved
        )

    @computed_field
    @property
    def hostels_with_availability(self) -> int:
        """Count hostels with available beds."""
        return sum(1 for h in self.hostels if h.has_availability)


class BookingHistoryItem(BaseSchema):
    """
    Individual booking in history.
    
    Contains booking details, status, and available actions.
    """

    booking_id: UUID = Field(
        ...,
        description="Unique booking identifier",
    )
    booking_reference: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Human-readable booking reference",
    )
    hostel_id: UUID = Field(
        ...,
        description="Associated hostel ID",
    )
    hostel_name: str = Field(
        ...,
        description="Name of the hostel",
    )
    room_type: str = Field(
        ...,
        description="Type of room booked",
    )

    # Dates
    booking_date: datetime = Field(
        ...,
        description="When booking was made",
    )
    check_in_date: date = Field(
        ...,
        description="Check-in date",
    )
    duration_months: int = Field(
        ...,
        ge=1,
        description="Booking duration in months",
    )

    # Status and Payment
    status: str = Field(
        ...,
        description="Current booking status",
    )
    total_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total booking amount",
    )

    # Available Actions
    can_cancel: bool = Field(
        ...,
        description="Whether booking can be cancelled",
    )
    can_modify: bool = Field(
        ...,
        description="Whether booking can be modified",
    )
    can_review: bool = Field(
        ...,
        description="Whether hostel can be reviewed",
    )

    @computed_field
    @property
    def check_out_date(self) -> date:
        """Calculate check-out date based on duration."""
        from dateutil.relativedelta import relativedelta

        return self.check_in_date + relativedelta(months=self.duration_months)

    @computed_field
    @property
    def days_until_checkin(self) -> int:
        """Calculate days until check-in."""
        return (self.check_in_date - date.today()).days

    @computed_field
    @property
    def is_upcoming(self) -> bool:
        """Check if booking is upcoming."""
        return self.check_in_date > date.today()


class BookingHistory(BaseSchema):
    """
    Booking history summary with statistics.
    """

    total_bookings: int = Field(
        ...,
        ge=0,
        description="Total number of bookings",
    )
    active_bookings: int = Field(
        ...,
        ge=0,
        description="Number of active bookings",
    )
    completed_bookings: int = Field(
        ...,
        ge=0,
        description="Number of completed bookings",
    )
    cancelled_bookings: int = Field(
        ...,
        ge=0,
        description="Number of cancelled bookings",
    )

    bookings: List[BookingHistoryItem] = Field(
        default_factory=list,
        description="List of booking items",
    )

    @computed_field
    @property
    def cancellation_rate(self) -> Decimal:
        """Calculate cancellation rate as percentage."""
        if self.total_bookings == 0:
            return Decimal("0")
        return Decimal(
            (self.cancelled_bookings / self.total_bookings) * 100
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate as percentage."""
        if self.total_bookings == 0:
            return Decimal("0")
        return Decimal(
            (self.completed_bookings / self.total_bookings) * 100
        ).quantize(Decimal("0.01"))


class RecentSearch(BaseSchema):
    """
    Recent search item with metadata.
    """

    search_id: UUID = Field(
        ...,
        description="Unique search identifier",
    )
    search_query: Optional[str] = Field(
        None,
        max_length=255,
        description="Search query text",
    )
    filters_applied: Dict = Field(
        default_factory=dict,
        description="Filters applied in this search",
    )
    results_count: int = Field(
        ...,
        ge=0,
        description="Number of results found",
    )
    searched_at: datetime = Field(
        ...,
        description="When search was performed",
    )

    @computed_field
    @property
    def filters_count(self) -> int:
        """Count number of filters applied."""
        return len(self.filters_applied)


class RecentlyViewedHostel(BaseSchema):
    """
    Recently viewed hostel item.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    hostel_city: str = Field(
        ...,
        description="City",
    )
    starting_price: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Starting price",
    )
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average rating",
    )
    cover_image_url: Optional[str] = Field(
        None,
        description="Cover image URL",
    )

    viewed_at: datetime = Field(
        ...,
        description="When hostel was last viewed",
    )
    view_count: int = Field(
        ...,
        ge=1,
        description="Number of times this hostel was viewed",
    )

    @computed_field
    @property
    def is_highly_viewed(self) -> bool:
        """Check if hostel has been viewed multiple times (interest indicator)."""
        return self.view_count >= 3


class RecommendedHostel(BaseSchema):
    """
    Recommended hostel based on visitor preferences.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    hostel_city: str = Field(
        ...,
        description="City",
    )
    starting_price: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Starting price",
    )
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average rating",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Available beds",
    )
    cover_image_url: Optional[str] = Field(
        None,
        description="Cover image URL",
    )

    match_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="How well hostel matches visitor preferences (0-100)",
    )
    match_reasons: List[str] = Field(
        ...,
        min_length=1,
        description="Reasons why this hostel is recommended",
    )

    @field_validator("match_reasons")
    @classmethod
    def validate_match_reasons(cls, v: List[str]) -> List[str]:
        """Ensure match reasons are not empty."""
        if not v or len(v) == 0:
            raise ValueError("At least one match reason must be provided")
        return v

    @computed_field
    @property
    def is_excellent_match(self) -> bool:
        """Check if this is an excellent match (score >= 80)."""
        return self.match_score >= Decimal("80")


class PriceDropAlert(BaseSchema):
    """
    Price drop alert for saved hostel.
    """

    alert_id: UUID = Field(
        ...,
        description="Alert identifier",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )

    previous_price: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Previous price",
    )
    new_price: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="New reduced price",
    )
    discount_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Discount percentage",
    )

    alert_created: datetime = Field(
        ...,
        description="When alert was created",
    )
    is_read: bool = Field(
        ...,
        description="Whether alert has been read",
    )

    @computed_field
    @property
    def savings_amount(self) -> Decimal:
        """Calculate absolute savings amount."""
        return (self.previous_price - self.new_price).quantize(Decimal("0.01"))


class AvailabilityAlert(BaseSchema):
    """
    Availability alert for previously full hostel.
    """

    alert_id: UUID = Field(
        ...,
        description="Alert identifier",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    room_type: str = Field(
        ...,
        description="Room type that became available",
    )

    message: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Alert message",
    )

    alert_created: datetime = Field(
        ...,
        description="When alert was created",
    )
    is_read: bool = Field(
        ...,
        description="Whether alert has been read",
    )


class VisitorDashboard(BaseSchema):
    """
    Comprehensive visitor dashboard overview.
    
    Contains all information needed for visitor dashboard including
    saved hostels, booking history, recent activity, recommendations,
    and alerts.
    """

    visitor_id: UUID = Field(
        ...,
        description="Visitor identifier",
    )
    visitor_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Visitor full name",
    )

    # Saved Hostels Section
    saved_hostels: SavedHostels = Field(
        ...,
        description="Saved/favorite hostels",
    )

    # Booking History Section
    booking_history: BookingHistory = Field(
        ...,
        description="Booking history and statistics",
    )

    # Recent Activity
    recent_searches: List[RecentSearch] = Field(
        default_factory=list,
        max_length=5,
        description="5 most recent searches",
    )
    recently_viewed: List[RecentlyViewedHostel] = Field(
        default_factory=list,
        max_length=10,
        description="10 most recently viewed hostels",
    )

    # Recommendations
    recommended_hostels: List[RecommendedHostel] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 recommended hostels",
    )

    # Alerts
    price_drop_alerts: List[PriceDropAlert] = Field(
        default_factory=list,
        description="Active price drop alerts",
    )
    availability_alerts: List[AvailabilityAlert] = Field(
        default_factory=list,
        description="Active availability alerts",
    )

    # Overall Statistics
    total_searches: int = Field(
        ...,
        ge=0,
        description="Total number of searches performed",
    )
    total_hostel_views: int = Field(
        ...,
        ge=0,
        description="Total hostel views",
    )
    total_bookings: int = Field(
        ...,
        ge=0,
        description="Total bookings made",
    )

    @computed_field
    @property
    def unread_alerts_count(self) -> int:
        """Count total unread alerts."""
        price_alerts = sum(1 for alert in self.price_drop_alerts if not alert.is_read)
        availability_alerts = sum(
            1 for alert in self.availability_alerts if not alert.is_read
        )
        return price_alerts + availability_alerts

    @computed_field
    @property
    def has_activity(self) -> bool:
        """Check if visitor has any activity."""
        return (
            self.total_searches > 0
            or self.total_hostel_views > 0
            or self.total_bookings > 0
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\visitor\visitor_favorites.py ---
# --- File: app/schemas/visitor/visitor_favorites.py ---
"""
Visitor favorites/wishlist schemas.

This module defines schemas for managing visitor's favorite hostels,
including adding, removing, updating notes, and comparing favorites.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "FavoriteRequest",
    "FavoritesList",
    "FavoriteHostelItem",
    "FavoriteUpdate",
    "FavoritesExport",
    "FavoriteComparison",
]


class FavoriteRequest(BaseCreateSchema):
    """
    Request to add or remove hostel from favorites.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID to add/remove from favorites",
    )
    is_favorite: bool = Field(
        ...,
        description="True to add to favorites, False to remove",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Optional personal notes about this hostel",
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Validate and clean notes."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
            if len(v) > 500:
                raise ValueError("Notes must not exceed 500 characters")
        return v


class FavoriteHostelItem(BaseSchema):
    """
    Individual favorite hostel with detailed information.
    
    Contains hostel details, pricing tracking, availability,
    rating information, and favorite metadata.
    """

    favorite_id: UUID = Field(
        ...,
        description="Unique favorite record identifier",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Hostel name",
    )
    hostel_slug: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="URL-friendly hostel slug",
    )
    hostel_city: str = Field(
        ...,
        description="City where hostel is located",
    )
    hostel_type: str = Field(
        ...,
        description="Hostel type (boys/girls/co-ed)",
    )

    # Pricing Information
    starting_price_monthly: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Current starting price per month",
    )
    price_when_saved: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Price when hostel was saved",
    )
    current_price: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Current price",
    )
    has_price_drop: bool = Field(
        ...,
        description="Whether price has dropped since saving",
    )
    price_drop_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Price drop percentage if applicable",
    )

    # Availability
    available_beds: int = Field(
        ...,
        ge=0,
        description="Number of available beds",
    )
    has_availability: bool = Field(
        ...,
        description="Whether hostel has available beds",
    )

    # Rating Information
    average_rating: Decimal = Field(
        ...,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average rating (0-5)",
    )
    total_reviews: int = Field(
        ...,
        ge=0,
        description="Total number of reviews",
    )

    # Media
    cover_image_url: Optional[str] = Field(
        None,
        description="Cover image URL",
    )

    # Favorite Metadata
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Personal notes about this hostel",
    )
    added_to_favorites: datetime = Field(
        ...,
        description="When hostel was added to favorites",
    )

    # View Tracking
    times_viewed: int = Field(
        ...,
        ge=0,
        description="Number of times hostel was viewed",
    )
    last_viewed: Optional[datetime] = Field(
        None,
        description="When hostel was last viewed",
    )

    @computed_field
    @property
    def price_savings(self) -> Optional[Decimal]:
        """Calculate price savings if price dropped."""
        if self.has_price_drop:
            return (self.price_when_saved - self.current_price).quantize(
                Decimal("0.01")
            )
        return None

    @computed_field
    @property
    def days_in_favorites(self) -> int:
        """Calculate days since hostel was added to favorites."""
        return (datetime.utcnow() - self.added_to_favorites).days

    @computed_field
    @property
    def is_highly_rated(self) -> bool:
        """Check if hostel is highly rated (>= 4.0 stars)."""
        return self.average_rating >= Decimal("4.0")

    @computed_field
    @property
    def is_popular(self) -> bool:
        """Check if hostel is popular (many reviews)."""
        return self.total_reviews >= 50

    @computed_field
    @property
    def is_frequently_viewed(self) -> bool:
        """Check if visitor views this hostel frequently."""
        return self.times_viewed >= 3


class FavoritesList(BaseSchema):
    """
    List of favorite hostels with summary statistics.
    """

    visitor_id: UUID = Field(
        ...,
        description="Visitor identifier",
    )
    total_favorites: int = Field(
        ...,
        ge=0,
        description="Total number of favorite hostels",
    )
    favorites: List[FavoriteHostelItem] = Field(
        default_factory=list,
        description="List of favorite hostel items",
    )

    @computed_field
    @property
    def favorites_with_availability(self) -> int:
        """Count favorites with available beds."""
        return sum(1 for fav in self.favorites if fav.has_availability)

    @computed_field
    @property
    def favorites_with_price_drops(self) -> int:
        """Count favorites with price drops."""
        return sum(1 for fav in self.favorites if fav.has_price_drop)

    @computed_field
    @property
    def total_potential_savings(self) -> Decimal:
        """Calculate total potential savings from price drops."""
        total = Decimal("0")
        for fav in self.favorites:
            if fav.price_savings:
                total += fav.price_savings
        return total.quantize(Decimal("0.01"))


class FavoriteUpdate(BaseCreateSchema):
    """
    Update notes for a favorite hostel.
    """

    favorite_id: UUID = Field(
        ...,
        description="Favorite record identifier",
    )
    notes: str = Field(
        ...,
        max_length=500,
        description="Updated personal notes",
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: str) -> str:
        """Validate and clean notes."""
        v = v.strip()
        if len(v) > 500:
            raise ValueError("Notes must not exceed 500 characters")
        return v


class FavoritesExport(BaseSchema):
    """
    Export favorites list in various formats.
    """

    format: str = Field(
        "pdf",
        pattern=r"^(pdf|csv|json)$",
        description="Export format: pdf, csv, or json",
    )
    include_prices: bool = Field(
        True,
        description="Include pricing information in export",
    )
    include_notes: bool = Field(
        True,
        description="Include personal notes in export",
    )

    @field_validator("format")
    @classmethod
    def validate_format(cls, v: str) -> str:
        """Validate and normalize format."""
        v = v.lower().strip()
        if v not in ["pdf", "csv", "json"]:
            raise ValueError("Format must be one of: pdf, csv, json")
        return v


class FavoriteComparison(BaseSchema):
    """
    Compare multiple favorite hostels side-by-side.
    """

    favorite_ids: List[UUID] = Field(
        ...,
        min_length=2,
        max_length=4,
        description="2-4 favorite hostel IDs to compare",
    )

    @field_validator("favorite_ids")
    @classmethod
    def validate_favorite_ids(cls, v: List[UUID]) -> List[UUID]:
        """Validate favorite IDs list."""
        if len(v) < 2:
            raise ValueError("At least 2 favorites required for comparison")
        if len(v) > 4:
            raise ValueError("Maximum 4 favorites can be compared at once")

        # Remove duplicates while preserving order
        seen = set()
        unique_ids = []
        for fav_id in v:
            if fav_id not in seen:
                seen.add(fav_id)
                unique_ids.append(fav_id)

        if len(unique_ids) < 2:
            raise ValueError(
                "At least 2 unique favorites required for comparison"
            )

        return unique_ids

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\visitor\visitor_preferences.py ---
# --- File: app/schemas/visitor/visitor_preferences.py ---
"""
Visitor preferences schemas for detailed preference management.

This module defines schemas for comprehensive visitor preferences including
room preferences, budget, location, amenities, dietary preferences,
and saved search criteria.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import (
    DietaryPreference,
    HostelType,
    RoomType,
)

__all__ = [
    "VisitorPreferences",
    "PreferenceUpdate",
    "SearchPreferences",
    "SavedSearch",
]


class VisitorPreferences(BaseSchema):
    """
    Complete visitor preferences schema.
    
    Comprehensive preferences including room type, budget, location,
    amenities, facilities, dietary requirements, move-in details,
    and notification settings.
    """

    # Room Preferences
    preferred_room_type: Optional[RoomType] = Field(
        None,
        description="Preferred room type (single, double, dormitory, etc.)",
    )
    preferred_hostel_type: Optional[HostelType] = Field(
        None,
        description="Preferred hostel type (boys, girls, co-ed)",
    )

    # Budget Constraints
    budget_min: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Minimum monthly budget in local currency",
    )
    budget_max: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Maximum monthly budget in local currency",
    )

    # Location Preferences
    preferred_cities: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="List of preferred cities",
    )
    preferred_areas: List[str] = Field(
        default_factory=list,
        max_length=30,
        description="Preferred areas/localities within cities",
    )
    max_distance_from_work_km: Optional[Decimal] = Field(
        None,
        ge=0,
        le=50,
        description="Maximum acceptable distance from workplace in km",
    )

    # Amenities (must-have vs nice-to-have)
    required_amenities: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Must-have amenities (deal-breakers)",
    )
    preferred_amenities: List[str] = Field(
        default_factory=list,
        max_length=30,
        description="Nice-to-have amenities (preferences)",
    )

    # Facility Requirements
    need_parking: bool = Field(
        False,
        description="Requires parking facility",
    )
    need_gym: bool = Field(
        False,
        description="Requires gym facility",
    )
    need_laundry: bool = Field(
        False,
        description="Requires laundry facility",
    )
    need_mess: bool = Field(
        False,
        description="Requires mess/dining facility",
    )

    # Dietary Preferences
    dietary_preference: Optional[DietaryPreference] = Field(
        None,
        description="Dietary preference (vegetarian, non-vegetarian, vegan, jain)",
    )

    # Move-in Details
    earliest_move_in_date: Optional[date] = Field(
        None,
        description="Earliest date willing to move in",
    )
    preferred_lease_duration_months: Optional[int] = Field(
        None,
        ge=1,
        le=24,
        description="Preferred lease duration in months (1-24)",
    )

    # Notification Preferences
    email_notifications: bool = Field(
        True,
        description="Enable email notifications",
    )
    sms_notifications: bool = Field(
        True,
        description="Enable SMS notifications",
    )
    push_notifications: bool = Field(
        True,
        description="Enable push notifications",
    )

    # Specific Notification Types
    notify_on_price_drop: bool = Field(
        True,
        description="Notify when saved hostel reduces price",
    )
    notify_on_availability: bool = Field(
        True,
        description="Notify when saved hostel has new availability",
    )
    notify_on_new_listings: bool = Field(
        True,
        description="Notify about new hostels matching preferences",
    )

    @field_validator("budget_min", "budget_max")
    @classmethod
    def validate_budget_positive(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Ensure budget values are positive."""
        if v is not None and v < 0:
            raise ValueError("Budget must be a positive value")
        return v

    @model_validator(mode="after")
    def validate_budget_range(self) -> "VisitorPreferences":
        """Validate that budget_max >= budget_min."""
        if (
            self.budget_min is not None
            and self.budget_max is not None
            and self.budget_max < self.budget_min
        ):
            raise ValueError(
                f"Maximum budget ({self.budget_max}) must be greater than or "
                f"equal to minimum budget ({self.budget_min})"
            )
        return self

    @field_validator("earliest_move_in_date")
    @classmethod
    def validate_move_in_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate move-in date is not in the past."""
        if v is not None and v < date.today():
            raise ValueError("Move-in date cannot be in the past")
        return v

    @field_validator("preferred_cities", "preferred_areas")
    @classmethod
    def normalize_location_list(cls, v: List[str]) -> List[str]:
        """Normalize and deduplicate location lists."""
        if not v:
            return v

        seen = set()
        normalized = []
        for item in v:
            item_clean = item.strip().title()
            if item_clean and item_clean not in seen:
                seen.add(item_clean)
                normalized.append(item_clean)

        return normalized

    @field_validator("required_amenities", "preferred_amenities")
    @classmethod
    def normalize_amenities_list(cls, v: List[str]) -> List[str]:
        """Normalize and deduplicate amenity lists."""
        if not v:
            return v

        seen = set()
        normalized = []
        for item in v:
            item_clean = item.strip().lower()
            if item_clean and item_clean not in seen:
                seen.add(item_clean)
                normalized.append(item_clean)

        return normalized

    @model_validator(mode="after")
    def validate_notification_settings(self) -> "VisitorPreferences":
        """Ensure at least one notification channel is enabled if specific alerts are on."""
        specific_alerts_enabled = (
            self.notify_on_price_drop
            or self.notify_on_availability
            or self.notify_on_new_listings
        )

        all_channels_disabled = not (
            self.email_notifications
            or self.sms_notifications
            or self.push_notifications
        )

        if specific_alerts_enabled and all_channels_disabled:
            raise ValueError(
                "At least one notification channel (email/SMS/push) must be "
                "enabled to receive alerts"
            )

        return self


class PreferenceUpdate(BaseUpdateSchema):
    """
    Schema for updating visitor preferences.
    
    All fields are optional, allowing partial updates.
    """

    # Room Preferences
    preferred_room_type: Optional[RoomType] = Field(
        None,
        description="Update preferred room type",
    )
    preferred_hostel_type: Optional[HostelType] = Field(
        None,
        description="Update preferred hostel type",
    )

    # Budget
    budget_min: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Update minimum budget",
    )
    budget_max: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Update maximum budget",
    )

    # Location
    preferred_cities: Optional[List[str]] = Field(
        None,
        description="Update preferred cities",
    )
    preferred_areas: Optional[List[str]] = Field(
        None,
        description="Update preferred areas",
    )

    # Amenities
    required_amenities: Optional[List[str]] = Field(
        None,
        description="Update required amenities",
    )
    preferred_amenities: Optional[List[str]] = Field(
        None,
        description="Update preferred amenities",
    )

    # Dietary
    dietary_preference: Optional[DietaryPreference] = Field(
        None,
        description="Update dietary preference",
    )

    # Notification Toggles
    email_notifications: Optional[bool] = Field(
        None,
        description="Update email notification setting",
    )
    sms_notifications: Optional[bool] = Field(
        None,
        description="Update SMS notification setting",
    )
    push_notifications: Optional[bool] = Field(
        None,
        description="Update push notification setting",
    )
    notify_on_price_drop: Optional[bool] = Field(
        None,
        description="Update price drop alert setting",
    )
    notify_on_availability: Optional[bool] = Field(
        None,
        description="Update availability alert setting",
    )
    notify_on_new_listings: Optional[bool] = Field(
        None,
        description="Update new listings alert setting",
    )

    @field_validator("budget_min", "budget_max")
    @classmethod
    def validate_budget_positive(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Ensure budget values are positive if provided."""
        if v is not None and v < 0:
            raise ValueError("Budget must be a positive value")
        return v

    @model_validator(mode="after")
    def validate_budget_range(self) -> "PreferenceUpdate":
        """Validate budget range if both values provided."""
        if (
            self.budget_min is not None
            and self.budget_max is not None
            and self.budget_max < self.budget_min
        ):
            raise ValueError(
                f"Maximum budget ({self.budget_max}) must be greater than or "
                f"equal to minimum budget ({self.budget_min})"
            )
        return self


class SearchPreferences(BaseSchema):
    """
    Saved search preferences for recurring searches.
    
    Allows visitors to save specific search criteria and receive
    notifications when new matches are found.
    """

    search_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Descriptive name for this saved search",
    )

    # Search Criteria
    cities: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Cities to search in",
    )
    room_types: List[RoomType] = Field(
        default_factory=list,
        max_length=5,
        description="Room types to include",
    )
    min_price: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Minimum price filter",
    )
    max_price: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Maximum price filter",
    )
    amenities: List[str] = Field(
        default_factory=list,
        max_length=15,
        description="Required amenities",
    )

    # Alert Settings
    notify_on_new_matches: bool = Field(
        True,
        description="Send notifications when new hostels match this search",
    )
    notification_frequency: str = Field(
        "daily",
        pattern=r"^(instant|daily|weekly)$",
        description="How often to send notifications: instant, daily, or weekly",
    )

    @field_validator("search_name")
    @classmethod
    def validate_search_name(cls, v: str) -> str:
        """Validate and normalize search name."""
        v = v.strip()
        if len(v) < 3:
            raise ValueError("Search name must be at least 3 characters")
        if len(v) > 100:
            raise ValueError("Search name must not exceed 100 characters")
        return v

    @model_validator(mode="after")
    def validate_price_range(self) -> "SearchPreferences":
        """Validate price range if both values provided."""
        if (
            self.min_price is not None
            and self.max_price is not None
            and self.max_price < self.min_price
        ):
            raise ValueError(
                f"Maximum price ({self.max_price}) must be greater than or "
                f"equal to minimum price ({self.min_price})"
            )
        return self

    @model_validator(mode="after")
    def validate_has_criteria(self) -> "SearchPreferences":
        """Ensure at least one search criterion is specified."""
        has_criteria = (
            len(self.cities) > 0
            or len(self.room_types) > 0
            or self.min_price is not None
            or self.max_price is not None
            or len(self.amenities) > 0
        )

        if not has_criteria:
            raise ValueError(
                "At least one search criterion must be specified "
                "(cities, room types, price range, or amenities)"
            )

        return self


class SavedSearch(BaseSchema):
    """
    Saved search with ID and statistics.
    
    Represents a persisted search preference with tracking
    of matches and last check timestamp.
    """

    id: UUID = Field(
        ...,
        description="Unique identifier for this saved search",
    )
    visitor_id: UUID = Field(
        ...,
        description="Visitor who created this search",
    )
    search_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Name of the saved search",
    )
    criteria: Dict = Field(
        ...,
        description="Search criteria stored as JSON object",
    )
    notify_on_new_matches: bool = Field(
        ...,
        description="Whether to send notifications for new matches",
    )
    notification_frequency: str = Field(
        ...,
        pattern=r"^(instant|daily|weekly)$",
        description="Notification frequency",
    )

    # Statistics
    total_matches: int = Field(
        0,
        ge=0,
        description="Current number of hostels matching this search",
    )
    new_matches_since_last_check: int = Field(
        0,
        ge=0,
        description="Number of new matches since last notification",
    )

    # Timestamps
    created_at: datetime = Field(
        ...,
        description="When this search was saved",
    )
    last_checked: Optional[datetime] = Field(
        None,
        description="When this search was last executed",
    )

    @field_validator("criteria")
    @classmethod
    def validate_criteria(cls, v: Dict) -> Dict:
        """Validate criteria dictionary is not empty."""
        if not v:
            raise ValueError("Search criteria cannot be empty")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\visitor\visitor_response.py ---
# --- File: app/schemas/visitor/visitor_response.py ---
"""
Visitor response schemas for API responses.

This module defines response schemas for visitor data returned by API endpoints,
including profile information, statistics, and detailed visitor information.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import RoomType

__all__ = [
    "VisitorResponse",
    "VisitorProfile",
    "VisitorDetail",
    "VisitorStats",
]


class VisitorResponse(BaseResponseSchema):
    """
    Standard visitor response schema.
    
    Used for basic visitor information in API responses.
    Contains core profile data and preferences.
    """

    user_id: UUID = Field(
        ...,
        description="Associated user account ID",
    )
    full_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Full name of the visitor",
    )
    email: str = Field(
        ...,
        description="Email address",
    )
    phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact phone number",
    )

    # Preferences
    preferred_room_type: Optional[RoomType] = Field(
        None,
        description="Preferred room type",
    )
    budget_min: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Minimum budget per month",
    )
    budget_max: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Maximum budget per month",
    )
    preferred_cities: List[str] = Field(
        default_factory=list,
        description="Preferred cities for hostel search",
    )

    # Statistics
    total_bookings: int = Field(
        0,
        ge=0,
        description="Total number of bookings made by visitor",
    )
    saved_hostels_count: int = Field(
        0,
        ge=0,
        description="Number of hostels saved to favorites",
    )

    # Notification Preferences
    email_notifications: bool = Field(
        ...,
        description="Email notifications enabled",
    )
    sms_notifications: bool = Field(
        ...,
        description="SMS notifications enabled",
    )
    push_notifications: bool = Field(
        ...,
        description="Push notifications enabled",
    )

    @computed_field
    @property
    def has_active_notifications(self) -> bool:
        """Check if visitor has any notification channel enabled."""
        return (
            self.email_notifications
            or self.sms_notifications
            or self.push_notifications
        )

    @computed_field
    @property
    def budget_range_display(self) -> Optional[str]:
        """Get formatted budget range for display."""
        if self.budget_min is not None and self.budget_max is not None:
            return f"{self.budget_min:,.0f} - {self.budget_max:,.0f}"
        elif self.budget_min is not None:
            return f"{self.budget_min:,.0f}+"
        elif self.budget_max is not None:
            return f"Up to {self.budget_max:,.0f}"
        return None


class VisitorProfile(BaseSchema):
    """
    Public visitor profile information.
    
    Contains minimal visitor information suitable for public display
    (e.g., in reviews, comments, etc.).
    """

    id: UUID = Field(
        ...,
        description="Visitor profile ID",
    )
    user_id: UUID = Field(
        ...,
        description="Associated user ID",
    )
    full_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Full name of the visitor",
    )
    profile_image_url: Optional[str] = Field(
        None,
        description="URL to profile image",
    )
    member_since: datetime = Field(
        ...,
        description="Date when visitor joined the platform",
    )

    @computed_field
    @property
    def display_name(self) -> str:
        """Get display name (first name only for privacy)."""
        return self.full_name.split()[0] if self.full_name else "Guest"

    @computed_field
    @property
    def membership_days(self) -> int:
        """Calculate number of days since joining."""
        return (datetime.utcnow() - self.member_since).days


class VisitorDetail(BaseResponseSchema):
    """
    Detailed visitor information.
    
    Complete visitor profile with all preferences, activity statistics,
    and account information. Used for profile pages and detailed views.
    """

    # User Information
    user_id: UUID = Field(
        ...,
        description="Associated user account ID",
    )
    full_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Full name",
    )
    email: str = Field(
        ...,
        description="Email address",
    )
    phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number",
    )
    profile_image_url: Optional[str] = Field(
        None,
        description="Profile image URL",
    )

    # Preferences
    preferred_room_type: Optional[RoomType] = Field(
        None,
        description="Preferred room type",
    )
    budget_min: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Minimum budget",
    )
    budget_max: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Maximum budget",
    )
    preferred_cities: List[str] = Field(
        default_factory=list,
        description="Preferred cities",
    )
    preferred_amenities: List[str] = Field(
        default_factory=list,
        description="Preferred amenities",
    )

    # Saved Hostels
    favorite_hostel_ids: List[UUID] = Field(
        default_factory=list,
        description="List of favorite hostel IDs",
    )
    total_saved_hostels: int = Field(
        0,
        ge=0,
        description="Total number of saved hostels",
    )

    # Activity Statistics
    total_bookings: int = Field(
        0,
        ge=0,
        description="Total bookings made",
    )
    completed_bookings: int = Field(
        0,
        ge=0,
        description="Number of completed bookings",
    )
    cancelled_bookings: int = Field(
        0,
        ge=0,
        description="Number of cancelled bookings",
    )
    total_inquiries: int = Field(
        0,
        ge=0,
        description="Total inquiries made",
    )

    # Review Activity
    total_reviews_written: int = Field(
        0,
        ge=0,
        description="Number of reviews written",
    )
    average_rating_given: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average rating given in reviews",
    )

    # Notification Preferences
    email_notifications: bool = Field(
        ...,
        description="Email notifications enabled",
    )
    sms_notifications: bool = Field(
        ...,
        description="SMS notifications enabled",
    )
    push_notifications: bool = Field(
        ...,
        description="Push notifications enabled",
    )

    # Account Information
    created_at: datetime = Field(
        ...,
        description="Account creation timestamp",
    )
    last_login: Optional[datetime] = Field(
        None,
        description="Last login timestamp",
    )

    @computed_field
    @property
    def active_bookings(self) -> int:
        """Calculate number of active bookings."""
        return self.total_bookings - self.completed_bookings - self.cancelled_bookings

    @computed_field
    @property
    def booking_completion_rate(self) -> Decimal:
        """Calculate booking completion rate as percentage."""
        if self.total_bookings == 0:
            return Decimal("0")
        return Decimal(
            (self.completed_bookings / self.total_bookings) * 100
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_active_user(self) -> bool:
        """Determine if user is active (logged in within last 30 days)."""
        if self.last_login is None:
            return False
        days_since_login = (datetime.utcnow() - self.last_login).days
        return days_since_login <= 30

    @computed_field
    @property
    def engagement_score(self) -> Decimal:
        """
        Calculate engagement score (0-100) based on activity.
        
        Weighted formula:
        - Bookings: 40%
        - Reviews: 30%
        - Saved hostels: 20%
        - Inquiries: 10%
        """
        booking_score = min(self.total_bookings * 10, 40)
        review_score = min(self.total_reviews_written * 6, 30)
        saved_score = min(self.total_saved_hostels * 2, 20)
        inquiry_score = min(self.total_inquiries * 2, 10)

        total_score = booking_score + review_score + saved_score + inquiry_score
        return Decimal(total_score).quantize(Decimal("0.01"))


class VisitorStats(BaseSchema):
    """
    Visitor statistics and analytics.
    
    Comprehensive statistics about visitor search behavior,
    engagement, and conversion metrics.
    """

    visitor_id: UUID = Field(
        ...,
        description="Visitor profile ID",
    )

    # Search Activity
    total_searches: int = Field(
        0,
        ge=0,
        description="Total number of searches performed",
    )
    unique_hostels_viewed: int = Field(
        0,
        ge=0,
        description="Number of unique hostels viewed",
    )
    average_search_filters_used: Decimal = Field(
        Decimal("0"),
        ge=0,
        description="Average number of filters used per search",
    )

    # Engagement Metrics
    total_hostel_views: int = Field(
        0,
        ge=0,
        description="Total hostel detail page views",
    )
    total_comparisons: int = Field(
        0,
        ge=0,
        description="Number of hostel comparisons made",
    )
    total_inquiries: int = Field(
        0,
        ge=0,
        description="Total inquiries sent",
    )

    # Booking Metrics
    total_bookings: int = Field(
        0,
        ge=0,
        description="Total bookings made",
    )
    booking_conversion_rate: Decimal = Field(
        Decimal("0"),
        ge=0,
        le=100,
        description="Percentage of views that resulted in bookings",
    )

    # Preference Insights
    most_searched_city: Optional[str] = Field(
        None,
        description="City searched most frequently",
    )
    most_viewed_room_type: Optional[RoomType] = Field(
        None,
        description="Most frequently viewed room type",
    )
    average_budget: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average budget range from searches",
    )

    @computed_field
    @property
    def inquiry_conversion_rate(self) -> Decimal:
        """Calculate inquiry to booking conversion rate."""
        if self.total_inquiries == 0:
            return Decimal("0")
        return Decimal(
            (self.total_bookings / self.total_inquiries) * 100
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def average_views_per_search(self) -> Decimal:
        """Calculate average hostel views per search."""
        if self.total_searches == 0:
            return Decimal("0")
        return Decimal(self.total_hostel_views / self.total_searches).quantize(
            Decimal("0.01")
        )

    @computed_field
    @property
    def engagement_level(self) -> str:
        """
        Categorize engagement level based on activity.
        
        Returns: "high", "medium", "low", or "inactive"
        """
        if self.total_searches == 0 and self.total_hostel_views == 0:
            return "inactive"
        elif self.total_bookings >= 3 or self.booking_conversion_rate >= 10:
            return "high"
        elif self.total_searches >= 5 or self.total_hostel_views >= 10:
            return "medium"
        else:
            return "low"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\visitor\__init__.py ---
# --- File: app/schemas/visitor/__init__.py ---
"""
Visitor schemas package.

This module exports all visitor-related schemas for easy importing
across the application.
"""

from __future__ import annotations

from app.schemas.visitor.visitor_base import (
    VisitorBase,
    VisitorCreate,
    VisitorUpdate,
)
from app.schemas.visitor.visitor_dashboard import (
    AvailabilityAlert,
    BookingHistory,
    BookingHistoryItem,
    PriceDropAlert,
    RecentSearch,
    RecentlyViewedHostel,
    RecommendedHostel,
    SavedHostelItem,
    SavedHostels,
    VisitorDashboard,
)
from app.schemas.visitor.visitor_favorites import (
    FavoriteComparison,
    FavoriteHostelItem,
    FavoriteRequest,
    FavoritesList,
    FavoriteUpdate,
    FavoritesExport,
)
from app.schemas.visitor.visitor_preferences import (
    PreferenceUpdate,
    SavedSearch,
    SearchPreferences,
    VisitorPreferences,
)
from app.schemas.visitor.visitor_response import (
    VisitorDetail,
    VisitorProfile,
    VisitorResponse,
    VisitorStats,
)

__all__ = [
    # Base Schemas
    "VisitorBase",
    "VisitorCreate",
    "VisitorUpdate",
    # Response Schemas
    "VisitorResponse",
    "VisitorProfile",
    "VisitorDetail",
    "VisitorStats",
    # Preferences
    "VisitorPreferences",
    "PreferenceUpdate",
    "SearchPreferences",
    "SavedSearch",
    # Dashboard
    "VisitorDashboard",
    "SavedHostels",
    "SavedHostelItem",
    "BookingHistory",
    "BookingHistoryItem",
    "RecentSearch",
    "RecentlyViewedHostel",
    "RecommendedHostel",
    "PriceDropAlert",
    "AvailabilityAlert",
    # Favorites
    "FavoriteRequest",
    "FavoritesList",
    "FavoriteHostelItem",
    "FavoriteUpdate",
    "FavoritesExport",
    "FavoriteComparison",
]
