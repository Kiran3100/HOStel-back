### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\subscription ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\subscription =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\subscription\commission.py ---
# --- File: app/schemas/subscription/commission.py ---
"""
Booking commission tracking schemas.

Handles commission configuration, calculation, and tracking for
platform revenue from hostel bookings.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from enum import Enum
from typing import Dict, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseResponseSchema, BaseSchema

__all__ = [
    "CommissionStatus",
    "CommissionConfig",
    "BookingCommissionResponse",
    "CommissionSummary",
]


class CommissionStatus(str, Enum):
    """Commission payment status."""

    PENDING = "pending"
    CALCULATED = "calculated"
    INVOICED = "invoiced"
    PAID = "paid"
    WAIVED = "waived"
    DISPUTED = "disputed"


class CommissionConfig(BaseSchema):
    """
    Global/platform commission configuration.

    Defines default commission rates and per-plan overrides for
    calculating platform fees on bookings.
    """

    default_commission_percentage: Decimal = Field(
        default=Decimal("5.00"),
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Default commission percentage for all plans",
    )
    min_commission_percentage: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Minimum allowed commission percentage",
    )
    max_commission_percentage: Decimal = Field(
        default=Decimal("30.00"),
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Maximum allowed commission percentage",
    )
    commission_by_plan: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Plan type to commission percentage mapping (e.g., {'premium': 3.00})",
    )

    @field_validator("commission_by_plan")
    @classmethod
    def validate_plan_commissions(
        cls, v: Dict[str, Decimal]
    ) -> Dict[str, Decimal]:
        """Validate all plan commission percentages are within valid range."""
        for plan_name, percentage in v.items():
            if not (Decimal("0") <= percentage <= Decimal("100")):
                raise ValueError(
                    f"Commission for plan '{plan_name}' must be between 0 and 100"
                )
        return v

    @model_validator(mode="after")
    def validate_min_max_range(self) -> "CommissionConfig":
        """Ensure min <= default <= max commission percentages."""
        if self.min_commission_percentage > self.max_commission_percentage:
            raise ValueError(
                "min_commission_percentage cannot exceed max_commission_percentage"
            )
        if not (
            self.min_commission_percentage
            <= self.default_commission_percentage
            <= self.max_commission_percentage
        ):
            raise ValueError(
                "default_commission_percentage must be between min and max"
            )
        return self

    def get_commission_for_plan(self, plan_type: str) -> Decimal:
        """
        Get commission percentage for a specific plan.

        Args:
            plan_type: The subscription plan type.

        Returns:
            Commission percentage for the plan, or default if not specified.
        """
        return self.commission_by_plan.get(
            plan_type, self.default_commission_percentage
        )


class BookingCommissionResponse(BaseResponseSchema):
    """
    Commission record for a booking.

    Tracks the commission owed to the platform for a specific booking,
    including calculation details and payment status.
    """

    booking_id: UUID = Field(..., description="Associated booking ID")
    hostel_id: UUID = Field(..., description="Hostel ID")
    subscription_id: UUID = Field(..., description="Active subscription ID")

    booking_amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Total booking amount",
    )
    commission_percentage: Decimal = Field(
        ...,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Applied commission percentage",
    )
    commission_amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Calculated commission amount",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="ISO 4217 currency code",
    )

    status: CommissionStatus = Field(
        default=CommissionStatus.PENDING,
        description="Commission payment status",
    )
    due_date: Optional[date] = Field(
        None, description="Commission payment due date"
    )
    paid_date: Optional[date] = Field(
        None, description="Actual payment date"
    )
    payment_reference: Optional[str] = Field(
        None,
        max_length=100,
        description="Payment transaction reference",
    )

    @model_validator(mode="after")
    def validate_payment_dates(self) -> "BookingCommissionResponse":
        """Validate paid_date is set only when status is PAID."""
        if self.status == CommissionStatus.PAID and self.paid_date is None:
            raise ValueError("paid_date is required when status is PAID")
        if self.status != CommissionStatus.PAID and self.paid_date is not None:
            raise ValueError("paid_date should only be set when status is PAID")
        return self


class CommissionSummary(BaseSchema):
    """
    Commission summary for platform or hostel.

    Aggregates commission data over a specified period for
    reporting and reconciliation purposes.
    """

    scope_type: str = Field(
        ...,
        pattern=r"^(platform|hostel)$",
        description="Summary scope: 'platform' or 'hostel'",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID (required when scope_type is 'hostel')",
    )

    period_start: date = Field(..., description="Summary period start date")
    period_end: date = Field(..., description="Summary period end date")

    total_bookings_count: int = Field(
        ...,
        ge=0,
        description="Total number of bookings in period",
    )
    bookings_with_commission_count: int = Field(
        ...,
        ge=0,
        description="Bookings with commission calculated",
    )

    total_booking_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Total booking value in period",
    )
    total_commission_due: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Total commission amount due",
    )
    total_commission_paid: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Total commission amount paid",
    )
    total_commission_pending: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Outstanding commission amount",
    )

    average_commission_rate: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        le=Decimal("100"),
        decimal_places=2,
        description="Average commission rate applied",
    )

    @model_validator(mode="after")
    def validate_scope_and_dates(self) -> "CommissionSummary":
        """Validate hostel scope and date range."""
        if self.scope_type == "hostel" and self.hostel_id is None:
            raise ValueError("hostel_id is required when scope_type is 'hostel'")
        if self.period_end < self.period_start:
            raise ValueError("period_end must be after or equal to period_start")
        if self.bookings_with_commission_count > self.total_bookings_count:
            raise ValueError(
                "bookings_with_commission_count cannot exceed total_bookings_count"
            )
        return self

    @property
    def commission_collection_rate(self) -> Decimal:
        """Calculate commission collection rate as percentage."""
        if self.total_commission_due == Decimal("0"):
            return Decimal("100.00")
        return (
            self.total_commission_paid / self.total_commission_due * Decimal("100")
        ).quantize(Decimal("0.01"))

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\subscription\subscription_base.py ---
# --- File: app/schemas/subscription/subscription_base.py ---
"""
Hostel subscription base schemas.

Defines the core subscription data structures for creating,
updating, and managing hostel subscriptions.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import BillingCycle, SubscriptionStatus

__all__ = [
    "SubscriptionBase",
    "SubscriptionCreate",
    "SubscriptionUpdate",
]


class SubscriptionBase(BaseSchema):
    """
    Base subscription schema for a hostel.

    Contains all core fields that define a subscription relationship
    between a hostel and a subscription plan.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    plan_id: UUID = Field(..., description="Subscription plan ID")

    subscription_reference: str = Field(
        ...,
        min_length=1,
        max_length=100,
        pattern=r"^[A-Z0-9\-]+$",
        description="Unique subscription reference (e.g., SUB-2024-001)",
    )

    billing_cycle: BillingCycle = Field(
        ..., description="Billing cycle (monthly/yearly)"
    )
    amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Amount per billing period",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="ISO 4217 currency code",
    )

    start_date: date = Field(..., description="Subscription start date")
    end_date: date = Field(..., description="Subscription end date")

    auto_renew: bool = Field(
        default=True, description="Auto-renew subscription on expiry"
    )
    next_billing_date: Optional[date] = Field(
        None, description="Next scheduled billing date"
    )

    status: SubscriptionStatus = Field(
        default=SubscriptionStatus.ACTIVE,
        description="Current subscription status",
    )

    @model_validator(mode="after")
    def validate_dates(self) -> "SubscriptionBase":
        """Validate subscription date relationships."""
        if self.end_date < self.start_date:
            raise ValueError("end_date must be after or equal to start_date")

        if self.next_billing_date is not None:
            if self.next_billing_date < self.start_date:
                raise ValueError(
                    "next_billing_date cannot be before start_date"
                )
            if self.next_billing_date > self.end_date and self.auto_renew:
                # Allow next billing after end_date only if auto_renew is True
                pass
            elif self.next_billing_date > self.end_date:
                raise ValueError(
                    "next_billing_date cannot be after end_date when auto_renew is False"
                )

        return self

    @field_validator("subscription_reference")
    @classmethod
    def normalize_reference(cls, v: str) -> str:
        """Normalize subscription reference to uppercase."""
        return v.upper().strip()


class SubscriptionCreate(BaseCreateSchema):
    """
    Create new hostel subscription.

    Extends base subscription with trial period support.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    plan_id: UUID = Field(..., description="Subscription plan ID")

    subscription_reference: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Unique subscription reference",
    )

    billing_cycle: BillingCycle = Field(
        ..., description="Billing cycle (monthly/yearly)"
    )
    amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Amount per billing period",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="ISO 4217 currency code",
    )

    start_date: date = Field(..., description="Subscription start date")
    end_date: date = Field(..., description="Subscription end date")

    auto_renew: bool = Field(default=True)
    next_billing_date: Optional[date] = Field(None)

    status: SubscriptionStatus = Field(default=SubscriptionStatus.ACTIVE)

    trial_end_date: Optional[date] = Field(
        None,
        description="Trial period end date (if applicable)",
    )

    @model_validator(mode="after")
    def validate_create_dates(self) -> "SubscriptionCreate":
        """Validate all date relationships for creation."""
        if self.end_date < self.start_date:
            raise ValueError("end_date must be after or equal to start_date")

        if self.trial_end_date is not None:
            if self.trial_end_date < self.start_date:
                raise ValueError("trial_end_date cannot be before start_date")
            if self.trial_end_date > self.end_date:
                raise ValueError("trial_end_date cannot be after end_date")

        if self.next_billing_date is not None:
            if self.next_billing_date < self.start_date:
                raise ValueError("next_billing_date cannot be before start_date")

        return self

    @field_validator("subscription_reference")
    @classmethod
    def normalize_reference(cls, v: str) -> str:
        """Normalize subscription reference to uppercase."""
        return v.upper().strip()


class SubscriptionUpdate(BaseUpdateSchema):
    """
    Update subscription.

    Allows partial updates to subscription status, dates, and renewal settings.
    """

    status: Optional[SubscriptionStatus] = Field(
        None, description="New subscription status"
    )
    end_date: Optional[date] = Field(
        None, description="New subscription end date"
    )
    auto_renew: Optional[bool] = Field(
        None, description="Update auto-renewal setting"
    )
    next_billing_date: Optional[date] = Field(
        None, description="Update next billing date"
    )

    # Additional updatable fields
    amount: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Updated billing amount",
    )
    billing_cycle: Optional[BillingCycle] = Field(
        None, description="Updated billing cycle"
    )

    @model_validator(mode="after")
    def validate_update_consistency(self) -> "SubscriptionUpdate":
        """Validate update field consistency."""
        # If setting to cancelled/expired, auto_renew should be False
        if self.status in (
            SubscriptionStatus.CANCELLED,
            SubscriptionStatus.EXPIRED,
        ):
            if self.auto_renew is True:
                raise ValueError(
                    f"auto_renew cannot be True when status is {self.status.value}"
                )
        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\subscription\subscription_billing.py ---
# --- File: app/schemas/subscription/subscription_billing.py ---
"""
Subscription billing schemas.

Handles billing cycle information, invoice generation,
and invoice tracking for subscriptions.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from enum import Enum
from typing import Optional
from uuid import UUID

from pydantic import Field, HttpUrl, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "InvoiceStatus",
    "BillingCycleInfo",
    "GenerateInvoiceRequest",
    "InvoiceInfo",
]


class InvoiceStatus(str, Enum):
    """Invoice status enumeration."""

    DRAFT = "draft"
    ISSUED = "issued"
    SENT = "sent"
    PAID = "paid"
    PARTIALLY_PAID = "partially_paid"
    OVERDUE = "overdue"
    CANCELLED = "cancelled"
    REFUNDED = "refunded"


class BillingCycleInfo(BaseSchema):
    """
    Information about current billing cycle for subscription.

    Provides a comprehensive view of the current billing period,
    including dates, amounts, and renewal information.
    """

    subscription_id: UUID = Field(..., description="Subscription ID")
    hostel_id: UUID = Field(..., description="Hostel ID")
    plan_name: str = Field(..., description="Subscription plan name")
    plan_display_name: str = Field(
        ..., description="Plan display name for UI"
    )

    cycle_start: date = Field(..., description="Current cycle start date")
    cycle_end: date = Field(..., description="Current cycle end date")
    billing_cycle: str = Field(
        ...,
        pattern=r"^(monthly|yearly)$",
        description="Billing cycle type",
    )

    amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Billing amount for this cycle",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="ISO 4217 currency code",
    )

    next_billing_date: date = Field(..., description="Next billing date")
    days_until_billing: int = Field(
        ...,
        description="Days until next billing",
    )
    auto_renew: bool = Field(..., description="Auto-renewal status")

    # Calculated fields
    is_in_trial: bool = Field(
        default=False, description="Whether currently in trial period"
    )
    trial_days_remaining: Optional[int] = Field(
        None, description="Days remaining in trial"
    )

    @model_validator(mode="after")
    def validate_cycle_dates(self) -> "BillingCycleInfo":
        """Validate billing cycle date relationships."""
        if self.cycle_end < self.cycle_start:
            raise ValueError("cycle_end must be after cycle_start")
        return self


class GenerateInvoiceRequest(BaseCreateSchema):
    """
    Request to generate invoice for subscription cycle.

    Allows specifying the billing date and optionally overriding
    the standard billing amount.
    """

    subscription_id: UUID = Field(
        ..., description="Subscription to invoice"
    )
    billing_date: date = Field(
        ..., description="Invoice billing date"
    )

    # Optional overrides
    amount_override: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Override standard billing amount",
    )
    due_date_override: Optional[date] = Field(
        None, description="Override standard due date"
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional invoice notes",
    )

    # Line item adjustments
    discount_amount: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Discount amount to apply",
    )
    discount_reason: Optional[str] = Field(
        None,
        max_length=200,
        description="Reason for discount",
    )

    @model_validator(mode="after")
    def validate_discount(self) -> "GenerateInvoiceRequest":
        """Validate discount fields."""
        if self.discount_amount is not None and self.discount_amount > Decimal("0"):
            if not self.discount_reason:
                raise ValueError(
                    "discount_reason is required when discount_amount is provided"
                )
        return self


class InvoiceInfo(BaseSchema):
    """
    Generated invoice information.

    Contains all details of a generated invoice including
    status, amounts, and access URLs.
    """

    invoice_id: UUID = Field(..., description="Invoice unique ID")
    subscription_id: UUID = Field(..., description="Associated subscription")
    hostel_id: UUID = Field(..., description="Hostel ID")

    invoice_number: str = Field(
        ...,
        min_length=1,
        max_length=50,
        pattern=r"^INV-\d{4}-\d{6,}$",
        description="Invoice number (e.g., INV-2024-000001)",
    )
    invoice_date: date = Field(..., description="Invoice issue date")
    due_date: date = Field(..., description="Payment due date")

    # Amounts
    subtotal: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Subtotal before adjustments",
    )
    discount_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Total discount applied",
    )
    tax_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Tax amount",
    )
    amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Total invoice amount",
    )
    amount_paid: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Amount already paid",
    )
    amount_due: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Remaining amount due",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="ISO 4217 currency code",
    )

    status: InvoiceStatus = Field(
        default=InvoiceStatus.DRAFT,
        description="Invoice status",
    )

    # Access URLs
    invoice_url: Optional[HttpUrl] = Field(
        None, description="URL to view/download invoice"
    )
    payment_url: Optional[HttpUrl] = Field(
        None, description="URL to pay invoice online"
    )

    # Metadata
    notes: Optional[str] = Field(None, description="Invoice notes")

    @model_validator(mode="after")
    def validate_invoice_dates_and_amounts(self) -> "InvoiceInfo":
        """Validate invoice date relationships and amount calculations."""
        if self.due_date < self.invoice_date:
            raise ValueError("due_date cannot be before invoice_date")

        # Validate amount calculation
        expected_amount = self.subtotal - self.discount_amount + self.tax_amount
        if abs(self.amount - expected_amount) > Decimal("0.01"):
            raise ValueError(
                f"amount ({self.amount}) does not match calculated total ({expected_amount})"
            )

        # Validate amount_due
        expected_due = self.amount - self.amount_paid
        if abs(self.amount_due - expected_due) > Decimal("0.01"):
            raise ValueError(
                f"amount_due ({self.amount_due}) does not match outstanding ({expected_due})"
            )

        return self

    @property
    def is_overdue(self) -> bool:
        """Check if invoice is overdue based on current date."""
        from datetime import date as date_type
        return (
            self.status not in (InvoiceStatus.PAID, InvoiceStatus.CANCELLED)
            and date_type.today() > self.due_date
        )

    @property
    def is_fully_paid(self) -> bool:
        """Check if invoice is fully paid."""
        return self.amount_due <= Decimal("0")

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\subscription\subscription_cancellation.py ---
# --- File: app/schemas/subscription/subscription_cancellation.py ---
"""
Subscription cancellation schemas.

Handles subscription cancellation requests, processing,
and response tracking.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Optional
from uuid import UUID

from pydantic import Field, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "CancellationRequest",
    "CancellationResponse",
    "CancellationPreview",
]


class CancellationRequest(BaseCreateSchema):
    """
    Request to cancel a subscription.

    Supports both immediate cancellation and end-of-term cancellation
    with required reason tracking.
    """

    subscription_id: UUID = Field(
        ..., description="Subscription ID to cancel"
    )
    hostel_id: UUID = Field(
        ..., description="Hostel ID for verification"
    )

    cancellation_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for cancellation",
    )
    cancellation_category: Optional[str] = Field(
        None,
        max_length=50,
        description="Cancellation category (e.g., 'pricing', 'features', 'switching')",
    )

    cancel_immediately: bool = Field(
        default=False,
        description="Cancel immediately vs at end of current term",
    )

    # Optional feedback
    feedback: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional feedback for improvement",
    )
    would_recommend: Optional[bool] = Field(
        None, description="Would recommend to others"
    )

    @model_validator(mode="after")
    def validate_cancellation_reason(self) -> "CancellationRequest":
        """Validate cancellation reason is meaningful."""
        reason_words = len(self.cancellation_reason.split())
        if reason_words < 3:
            raise ValueError(
                "cancellation_reason must contain at least 3 words"
            )
        return self


class CancellationPreview(BaseSchema):
    """
    Preview of cancellation impact.

    Shows what will happen if the cancellation proceeds,
    including refund calculations and effective dates.
    """

    subscription_id: UUID = Field(..., description="Subscription ID")
    hostel_id: UUID = Field(..., description="Hostel ID")

    current_plan_name: str = Field(..., description="Current plan name")
    billing_cycle: str = Field(..., description="Current billing cycle")

    # Dates
    cancellation_effective_date: date = Field(
        ..., description="When cancellation takes effect"
    )
    current_period_end: date = Field(
        ..., description="Current billing period end date"
    )
    days_remaining: int = Field(
        ...,
        ge=0,
        description="Days remaining in current period",
    )

    # Financial impact
    refund_eligible: bool = Field(
        ..., description="Whether eligible for refund"
    )
    refund_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Calculated refund amount",
    )
    currency: str = Field(default="INR")

    # Warnings
    warnings: list[str] = Field(
        default_factory=list,
        description="Warnings about cancellation impact",
    )

    # Access impact
    access_ends_at: datetime = Field(
        ..., description="When service access ends"
    )


# Import Decimal for CancellationPreview
from decimal import Decimal


class CancellationResponse(BaseSchema):
    """
    Cancellation confirmation response.

    Confirms the cancellation was processed and provides
    all relevant details about the cancellation.
    """

    subscription_id: UUID = Field(..., description="Cancelled subscription ID")
    hostel_id: UUID = Field(..., description="Hostel ID")

    cancelled: bool = Field(
        ..., description="Whether cancellation was successful"
    )
    cancellation_effective_date: date = Field(
        ..., description="Date when cancellation takes effect"
    )
    cancelled_at: datetime = Field(
        ..., description="Timestamp when cancellation was processed"
    )
    cancelled_by: UUID = Field(
        ..., description="User ID who initiated cancellation"
    )

    # Refund info
    refund_issued: bool = Field(
        default=False, description="Whether refund was issued"
    )
    refund_amount: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Refund amount if applicable",
    )
    refund_reference: Optional[str] = Field(
        None,
        max_length=100,
        description="Refund transaction reference",
    )

    message: str = Field(..., description="Confirmation message")

    # Next steps
    reactivation_eligible: bool = Field(
        default=True,
        description="Whether subscription can be reactivated",
    )
    reactivation_deadline: Optional[date] = Field(
        None, description="Deadline to reactivate subscription"
    )

    @model_validator(mode="after")
    def validate_refund_fields(self) -> "CancellationResponse":
        """Validate refund fields consistency."""
        if self.refund_issued:
            if self.refund_amount is None or self.refund_amount <= Decimal("0"):
                raise ValueError(
                    "refund_amount must be positive when refund_issued is True"
                )
        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\subscription\subscription_plan_base.py ---
# --- File: app/schemas/subscription/subscription_plan_base.py ---
"""
Subscription plan definition schemas.

Defines the structure for subscription plans including pricing,
features, limits, and configuration options.
"""

from __future__ import annotations

from decimal import Decimal
from typing import Any, Dict, List, Optional

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import SubscriptionPlan

__all__ = [
    "SubscriptionPlanBase",
    "PlanCreate",
    "PlanUpdate",
    "PlanFeatureConfig",
]


class PlanFeatureConfig(BaseSchema):
    """
    Configuration for a single plan feature.

    Provides structured feature definition with value,
    display label, and enablement status.
    """

    key: str = Field(..., description="Feature identifier key")
    label: str = Field(..., description="Human-readable feature label")
    value: Any = Field(..., description="Feature value")
    enabled: bool = Field(default=True, description="Feature enabled status")
    description: Optional[str] = Field(
        None, description="Feature description"
    )


class SubscriptionPlanBase(BaseSchema):
    """
    Base subscription plan schema.

    Contains all fields that define a subscription plan including
    identification, pricing, features, and limits.
    """

    plan_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        pattern=r"^[a-z][a-z0-9_]*$",
        description="Plan internal identifier (lowercase, underscores)",
    )
    display_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Plan display name for UI",
    )
    plan_type: SubscriptionPlan = Field(
        ..., description="Plan tier/type"
    )

    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Plan description",
    )
    short_description: Optional[str] = Field(
        None,
        max_length=200,
        description="Short description for cards/listings",
    )

    # Pricing
    price_monthly: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Monthly subscription price",
    )
    price_yearly: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Yearly subscription price",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="ISO 4217 currency code",
    )

    # Features as structured dict
    features: Dict[str, Any] = Field(
        default_factory=dict,
        description="Feature flags and configurations",
    )

    # Usage limits
    max_hostels: Optional[int] = Field(
        None,
        ge=1,
        description="Maximum number of hostels (None = unlimited)",
    )
    max_rooms_per_hostel: Optional[int] = Field(
        None,
        ge=1,
        description="Maximum rooms per hostel (None = unlimited)",
    )
    max_students: Optional[int] = Field(
        None,
        ge=1,
        description="Maximum total students (None = unlimited)",
    )
    max_admins: Optional[int] = Field(
        None,
        ge=1,
        description="Maximum admin users (None = unlimited)",
    )

    # Status and display
    is_active: bool = Field(
        default=True, description="Plan is available for new subscriptions"
    )
    is_public: bool = Field(
        default=True, description="Show on public pricing page"
    )
    is_featured: bool = Field(
        default=False, description="Highlight as featured/recommended plan"
    )
    sort_order: int = Field(
        default=0, description="Display ordering (lower = first)"
    )

    # Trial configuration
    trial_days: int = Field(
        default=0,
        ge=0,
        le=90,
        description="Trial period in days (0 = no trial)",
    )

    @model_validator(mode="after")
    def validate_pricing(self) -> "SubscriptionPlanBase":
        """Validate pricing logic."""
        # Yearly price should typically be discounted vs 12x monthly
        yearly_monthly_equivalent = self.price_monthly * 12
        if self.price_yearly > yearly_monthly_equivalent:
            raise ValueError(
                "price_yearly should not exceed 12x price_monthly"
            )
        return self

    @field_validator("plan_name")
    @classmethod
    def normalize_plan_name(cls, v: str) -> str:
        """Normalize plan name to lowercase."""
        return v.lower().strip()

    @property
    def yearly_savings(self) -> Decimal:
        """Calculate yearly savings compared to monthly billing."""
        monthly_yearly = self.price_monthly * 12
        return (monthly_yearly - self.price_yearly).quantize(Decimal("0.01"))

    @property
    def yearly_discount_percent(self) -> Decimal:
        """Calculate yearly discount percentage."""
        if self.price_monthly == Decimal("0"):
            return Decimal("0")
        monthly_yearly = self.price_monthly * 12
        if monthly_yearly == Decimal("0"):
            return Decimal("0")
        discount = (
            (monthly_yearly - self.price_yearly) / monthly_yearly * 100
        )
        return discount.quantize(Decimal("0.01"))


class PlanCreate(SubscriptionPlanBase, BaseCreateSchema):
    """
    Create new subscription plan.

    Inherits all fields from SubscriptionPlanBase for plan creation.
    """

    # Additional creation-specific fields
    created_by: Optional[str] = Field(
        None, description="Admin user who created the plan"
    )

    @field_validator("features")
    @classmethod
    def validate_features(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        """Validate feature dictionary structure."""
        if not isinstance(v, dict):
            raise ValueError("features must be a dictionary")
        return v


class PlanUpdate(BaseUpdateSchema):
    """
    Update subscription plan.

    All fields are optional to support partial updates.
    """

    display_name: Optional[str] = Field(
        None,
        min_length=3,
        max_length=100,
        description="Updated display name",
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Updated description",
    )
    short_description: Optional[str] = Field(
        None,
        max_length=200,
        description="Updated short description",
    )

    # Pricing updates
    price_monthly: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Updated monthly price",
    )
    price_yearly: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Updated yearly price",
    )
    currency: Optional[str] = Field(
        None,
        min_length=3,
        max_length=3,
        pattern=r"^[A-Z]{3}$",
        description="Updated currency",
    )

    # Feature updates
    features: Optional[Dict[str, Any]] = Field(
        None, description="Updated features"
    )

    # Limit updates
    max_hostels: Optional[int] = Field(None, ge=1)
    max_rooms_per_hostel: Optional[int] = Field(None, ge=1)
    max_students: Optional[int] = Field(None, ge=1)
    max_admins: Optional[int] = Field(None, ge=1)

    # Status updates
    is_active: Optional[bool] = Field(None)
    is_public: Optional[bool] = Field(None)
    is_featured: Optional[bool] = Field(None)
    sort_order: Optional[int] = Field(None)

    # Trial updates
    trial_days: Optional[int] = Field(None, ge=0, le=90)

    @model_validator(mode="after")
    def validate_pricing_update(self) -> "PlanUpdate":
        """Validate pricing updates if both provided."""
        if self.price_monthly is not None and self.price_yearly is not None:
            yearly_monthly_equivalent = self.price_monthly * 12
            if self.price_yearly > yearly_monthly_equivalent:
                raise ValueError(
                    "price_yearly should not exceed 12x price_monthly"
                )
        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\subscription\subscription_plan_response.py ---
# --- File: app/schemas/subscription/subscription_plan_response.py ---
"""
Subscription plan response and comparison schemas.

Provides structured responses for plan details, feature listings,
and plan comparison functionality.
"""

from __future__ import annotations

from decimal import Decimal
from typing import Any, Dict, List, Optional

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import SubscriptionPlan

__all__ = [
    "PlanResponse",
    "PlanFeatures",
    "PlanComparison",
    "PlanSummary",
]


class PlanResponse(BaseResponseSchema):
    """
    Complete subscription plan response.

    Returns all plan details including pricing, features,
    limits, and computed properties.
    """

    plan_name: str = Field(..., description="Plan internal identifier")
    display_name: str = Field(..., description="Plan display name")
    plan_type: SubscriptionPlan = Field(..., description="Plan tier")

    description: Optional[str] = Field(None, description="Full description")
    short_description: Optional[str] = Field(
        None, description="Short description"
    )

    # Pricing
    price_monthly: Decimal = Field(..., description="Monthly price")
    price_yearly: Decimal = Field(..., description="Yearly price")
    currency: str = Field(..., description="Currency code")

    # Features
    features: Dict[str, Any] = Field(
        default_factory=dict, description="Feature configuration"
    )

    # Limits
    max_hostels: Optional[int] = Field(None, description="Max hostels")
    max_rooms_per_hostel: Optional[int] = Field(
        None, description="Max rooms per hostel"
    )
    max_students: Optional[int] = Field(None, description="Max students")
    max_admins: Optional[int] = Field(None, description="Max admin users")

    # Status
    is_active: bool = Field(..., description="Plan is active")
    is_public: bool = Field(..., description="Visible on pricing page")
    is_featured: bool = Field(
        default=False, description="Featured/recommended plan"
    )
    sort_order: int = Field(..., description="Display order")

    # Trial
    trial_days: int = Field(default=0, description="Trial period days")

    @computed_field
    @property
    def price_monthly_formatted(self) -> str:
        """Format monthly price with currency."""
        return f"{self.currency} {self.price_monthly:,.2f}"

    @computed_field
    @property
    def price_yearly_formatted(self) -> str:
        """Format yearly price with currency."""
        return f"{self.currency} {self.price_yearly:,.2f}"

    @computed_field
    @property
    def yearly_savings(self) -> Decimal:
        """Calculate yearly savings vs monthly billing."""
        return (self.price_monthly * 12 - self.price_yearly).quantize(
            Decimal("0.01")
        )

    @computed_field
    @property
    def yearly_discount_percent(self) -> Decimal:
        """Calculate yearly discount percentage."""
        if self.price_monthly == Decimal("0"):
            return Decimal("0")
        monthly_yearly = self.price_monthly * 12
        if monthly_yearly == Decimal("0"):
            return Decimal("0")
        return (
            (monthly_yearly - self.price_yearly) / monthly_yearly * 100
        ).quantize(Decimal("0.01"))

    @computed_field
    @property
    def has_trial(self) -> bool:
        """Check if plan offers trial."""
        return self.trial_days > 0

    @computed_field
    @property
    def limits_display(self) -> Dict[str, str]:
        """Format limits for display."""
        return {
            "hostels": str(self.max_hostels) if self.max_hostels else "Unlimited",
            "rooms_per_hostel": (
                str(self.max_rooms_per_hostel)
                if self.max_rooms_per_hostel
                else "Unlimited"
            ),
            "students": str(self.max_students) if self.max_students else "Unlimited",
            "admins": str(self.max_admins) if self.max_admins else "Unlimited",
        }


class PlanSummary(BaseSchema):
    """
    Condensed plan summary for listings.

    Provides essential plan information for cards and lists.
    """

    id: str = Field(..., description="Plan ID")
    plan_name: str = Field(..., description="Plan identifier")
    display_name: str = Field(..., description="Display name")
    plan_type: SubscriptionPlan = Field(..., description="Plan tier")

    price_monthly: Decimal = Field(..., description="Monthly price")
    price_yearly: Decimal = Field(..., description="Yearly price")
    currency: str = Field(..., description="Currency")

    short_description: Optional[str] = Field(None)
    is_featured: bool = Field(default=False)
    trial_days: int = Field(default=0)


class PlanFeatures(BaseSchema):
    """
    Human-friendly plan feature matrix.

    Formats features for display in comparison tables
    and feature lists.
    """

    plan_name: str = Field(..., description="Plan identifier")
    display_name: str = Field(..., description="Plan display name")
    plan_type: SubscriptionPlan = Field(..., description="Plan tier")

    # Feature categories with human-readable values
    features: Dict[str, str] = Field(
        ...,
        description="Feature key to display value mapping",
    )
    feature_categories: Dict[str, List[str]] = Field(
        default_factory=dict,
        description="Category to feature keys mapping",
    )

    # Highlight features
    highlight_features: List[str] = Field(
        default_factory=list,
        description="Key features to highlight",
    )

    @classmethod
    def from_plan_response(
        cls,
        plan: PlanResponse,
        feature_labels: Dict[str, str],
    ) -> "PlanFeatures":
        """
        Create PlanFeatures from PlanResponse.

        Args:
            plan: The plan response to convert.
            feature_labels: Mapping of feature keys to display labels.

        Returns:
            PlanFeatures instance with formatted features.
        """
        formatted_features = {}
        for key, value in plan.features.items():
            label = feature_labels.get(key, key.replace("_", " ").title())
            if isinstance(value, bool):
                formatted_features[label] = "✓" if value else "✗"
            elif value is None:
                formatted_features[label] = "Unlimited"
            else:
                formatted_features[label] = str(value)

        return cls(
            plan_name=plan.plan_name,
            display_name=plan.display_name,
            plan_type=plan.plan_type,
            features=formatted_features,
        )


class PlanComparison(BaseSchema):
    """
    Compare multiple plans side by side.

    Provides a structured comparison matrix for displaying
    multiple plans with their features.
    """

    plans: List[PlanResponse] = Field(
        ...,
        min_length=2,
        description="Plans to compare",
    )
    feature_matrix: Dict[str, Dict[str, Any]] = Field(
        ...,
        description="Feature key -> plan_name -> value matrix",
    )
    feature_order: List[str] = Field(
        default_factory=list,
        description="Ordered list of feature keys for display",
    )
    category_order: List[str] = Field(
        default_factory=list,
        description="Ordered list of feature categories",
    )

    # Recommendations
    recommended_plan: Optional[str] = Field(
        None, description="Recommended plan name"
    )
    recommendation_reason: Optional[str] = Field(
        None, description="Reason for recommendation"
    )

    @classmethod
    def create(
        cls,
        plans: List[PlanResponse],
        feature_order: Optional[List[str]] = None,
    ) -> "PlanComparison":
        """
        Create comparison from list of plans.

        Args:
            plans: List of plans to compare.
            feature_order: Optional ordered list of features to include.

        Returns:
            PlanComparison instance with feature matrix.
        """
        # Build feature matrix
        all_features: set = set()
        for plan in plans:
            all_features.update(plan.features.keys())

        # Use provided order or alphabetical
        ordered_features = feature_order or sorted(all_features)

        feature_matrix: Dict[str, Dict[str, Any]] = {}
        for feature in ordered_features:
            feature_matrix[feature] = {}
            for plan in plans:
                feature_matrix[feature][plan.plan_name] = plan.features.get(
                    feature
                )

        # Add limit comparisons
        limit_features = ["max_hostels", "max_rooms_per_hostel", "max_students"]
        for limit in limit_features:
            feature_matrix[limit] = {}
            for plan in plans:
                feature_matrix[limit][plan.plan_name] = getattr(plan, limit)

        # Find featured plan as recommended
        recommended = next(
            (p.plan_name for p in plans if p.is_featured), None
        )

        return cls(
            plans=plans,
            feature_matrix=feature_matrix,
            feature_order=ordered_features + limit_features,
            recommended_plan=recommended,
        )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\subscription\subscription_response.py ---
# --- File: app/schemas/subscription/subscription_response.py ---
"""
Subscription response schemas.

Provides comprehensive response structures for subscription
data, billing history, and subscription summaries.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, HttpUrl, computed_field, model_validator

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import (
    BillingCycle,
    SubscriptionPlan,
    SubscriptionStatus,
)

__all__ = [
    "SubscriptionResponse",
    "SubscriptionSummary",
    "BillingHistoryItem",
    "BillingHistory",
]


class SubscriptionResponse(BaseResponseSchema):
    """
    Complete hostel subscription response.

    Returns all subscription details including plan information,
    billing details, and current status.
    """

    # Hostel info
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")

    # Plan info
    plan_id: UUID = Field(..., description="Subscription plan ID")
    plan_name: str = Field(..., description="Plan internal name")
    display_name: str = Field(..., description="Plan display name")
    plan_type: SubscriptionPlan = Field(..., description="Plan tier")

    # Subscription details
    subscription_reference: str = Field(
        ..., description="Unique subscription reference"
    )
    billing_cycle: BillingCycle = Field(..., description="Billing cycle")
    amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Billing amount",
    )
    currency: str = Field(default="INR", description="Currency code")

    # Dates
    start_date: date = Field(..., description="Subscription start date")
    end_date: date = Field(..., description="Subscription end date")
    auto_renew: bool = Field(..., description="Auto-renewal enabled")
    next_billing_date: Optional[date] = Field(
        None, description="Next billing date"
    )
    status: SubscriptionStatus = Field(..., description="Current status")

    # Trial info
    trial_end_date: Optional[date] = Field(
        None, description="Trial period end date"
    )
    is_in_trial: bool = Field(
        default=False, description="Currently in trial period"
    )

    # Payment info
    last_payment_date: Optional[date] = Field(
        None, description="Last payment date"
    )
    last_payment_amount: Optional[Decimal] = Field(
        None,
        ge=Decimal("0"),
        decimal_places=2,
        description="Last payment amount",
    )

    # Cancellation info (if applicable)
    cancelled_at: Optional[datetime] = Field(
        None, description="Cancellation timestamp"
    )
    cancellation_effective_date: Optional[date] = Field(
        None, description="When cancellation takes effect"
    )

    @computed_field
    @property
    def days_until_expiry(self) -> int:
        """Calculate days until subscription expires."""
        today = date.today()
        if self.end_date < today:
            return 0
        return (self.end_date - today).days

    @computed_field
    @property
    def days_until_billing(self) -> Optional[int]:
        """Calculate days until next billing."""
        if self.next_billing_date is None:
            return None
        today = date.today()
        if self.next_billing_date < today:
            return 0
        return (self.next_billing_date - today).days

    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if subscription is currently active."""
        return self.status == SubscriptionStatus.ACTIVE

    @computed_field
    @property
    def is_expiring_soon(self) -> bool:
        """Check if subscription expires within 7 days."""
        return 0 < self.days_until_expiry <= 7

    @computed_field
    @property
    def amount_formatted(self) -> str:
        """Format amount with currency."""
        cycle_label = "mo" if self.billing_cycle == BillingCycle.MONTHLY else "yr"
        return f"{self.currency} {self.amount:,.2f}/{cycle_label}"


class SubscriptionSummary(BaseSchema):
    """
    Condensed subscription summary for listings.

    Provides essential subscription information for dashboards
    and list views.
    """

    id: str = Field(..., description="Subscription ID")
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")

    plan_name: str = Field(..., description="Plan name")
    plan_type: SubscriptionPlan = Field(..., description="Plan tier")
    status: SubscriptionStatus = Field(..., description="Status")

    billing_cycle: BillingCycle = Field(..., description="Billing cycle")
    amount: Decimal = Field(..., description="Billing amount")
    currency: str = Field(default="INR")

    end_date: date = Field(..., description="Expiry date")
    auto_renew: bool = Field(..., description="Auto-renewal status")

    is_in_trial: bool = Field(default=False)
    days_until_expiry: int = Field(..., description="Days until expiry")


class BillingHistoryItem(BaseSchema):
    """
    Single billing event in history.

    Represents one billing transaction with all relevant details.
    """

    id: Optional[UUID] = Field(None, description="Transaction ID")
    billing_date: date = Field(..., description="Billing date")

    # Amounts
    amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Billed amount",
    )
    currency: str = Field(default="INR", description="Currency code")

    # Status and references
    status: str = Field(
        ...,
        description="Payment status (pending, paid, failed, refunded)",
    )
    payment_reference: Optional[str] = Field(
        None,
        max_length=100,
        description="Payment transaction reference",
    )
    payment_method: Optional[str] = Field(
        None, description="Payment method used"
    )

    # Invoice
    invoice_number: Optional[str] = Field(
        None, description="Associated invoice number"
    )
    invoice_url: Optional[HttpUrl] = Field(
        None, description="Invoice download URL"
    )

    # Description
    description: Optional[str] = Field(
        None,
        max_length=255,
        description="Billing description",
    )

    # Period covered
    period_start: Optional[date] = Field(
        None, description="Billing period start"
    )
    period_end: Optional[date] = Field(
        None, description="Billing period end"
    )

    @computed_field
    @property
    def is_paid(self) -> bool:
        """Check if billing item is paid."""
        return self.status.lower() == "paid"


class BillingHistory(BaseSchema):
    """
    Complete subscription billing history.

    Aggregates all billing events with summary statistics.
    """

    subscription_id: UUID = Field(..., description="Subscription ID")
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: Optional[str] = Field(None, description="Hostel name")

    # Billing items
    items: List[BillingHistoryItem] = Field(
        default_factory=list,
        description="List of billing events",
    )

    # Summary totals
    total_billed: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Total amount billed",
    )
    total_paid: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Total amount paid",
    )
    total_outstanding: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Outstanding amount",
    )
    total_refunded: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Total refunded amount",
    )

    currency: str = Field(default="INR", description="Currency code")

    # Pagination info
    total_count: int = Field(
        default=0, ge=0, description="Total billing events"
    )
    page: int = Field(default=1, ge=1, description="Current page")
    page_size: int = Field(default=20, ge=1, description="Page size")

    @model_validator(mode="after")
    def validate_totals(self) -> "BillingHistory":
        """Validate total calculations."""
        expected_outstanding = self.total_billed - self.total_paid - self.total_refunded
        if expected_outstanding < Decimal("0"):
            expected_outstanding = Decimal("0")

        # Allow small floating point differences
        if abs(self.total_outstanding - expected_outstanding) > Decimal("0.01"):
            raise ValueError(
                f"total_outstanding ({self.total_outstanding}) does not match "
                f"calculated value ({expected_outstanding})"
            )
        return self

    @computed_field
    @property
    def has_outstanding(self) -> bool:
        """Check if there's outstanding balance."""
        return self.total_outstanding > Decimal("0")

    @computed_field
    @property
    def payment_rate(self) -> Decimal:
        """Calculate payment collection rate percentage."""
        if self.total_billed == Decimal("0"):
            return Decimal("100.00")
        return (
            (self.total_paid + self.total_refunded) / self.total_billed * 100
        ).quantize(Decimal("0.01"))

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\subscription\subscription_upgrade.py ---
# --- File: app/schemas/subscription/subscription_upgrade.py ---
"""
Subscription upgrade/downgrade schemas.

Handles plan change requests, previews, and confirmations
for subscription modifications.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from enum import Enum
from typing import List, Optional
from uuid import UUID

from pydantic import Field, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import BillingCycle

__all__ = [
    "PlanChangeType",
    "PlanChangeRequest",
    "PlanChangePreview",
    "PlanChangeConfirmation",
]


class PlanChangeType(str, Enum):
    """Type of plan change."""

    UPGRADE = "upgrade"
    DOWNGRADE = "downgrade"
    LATERAL = "lateral"  # Same tier, different billing cycle


class PlanChangeRequest(BaseCreateSchema):
    """
    Request to change subscription plan.

    Supports upgrades, downgrades, and billing cycle changes
    with configurable timing and proration.
    """

    hostel_id: UUID = Field(..., description="Hostel ID")
    current_plan_id: UUID = Field(
        ..., description="Current subscription plan ID"
    )
    new_plan_id: UUID = Field(..., description="Target plan ID")
    billing_cycle: BillingCycle = Field(
        ..., description="Billing cycle for new plan"
    )

    # Timing
    effective_from: date = Field(
        ..., description="When new plan takes effect"
    )
    prorate: bool = Field(
        default=True,
        description="Apply proration for partial periods",
    )

    # Options
    apply_credit: bool = Field(
        default=True,
        description="Apply unused balance as credit",
    )
    preserve_trial: bool = Field(
        default=False,
        description="Preserve remaining trial days if applicable",
    )

    # Reason tracking
    change_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for plan change",
    )

    @model_validator(mode="after")
    def validate_plan_change(self) -> "PlanChangeRequest":
        """Validate plan change request."""
        if self.current_plan_id == self.new_plan_id:
            raise ValueError(
                "new_plan_id must be different from current_plan_id"
            )

        today = date.today()
        if self.effective_from < today:
            raise ValueError("effective_from cannot be in the past")

        return self


class PlanChangePreview(BaseSchema):
    """
    Preview cost impact of plan change.

    Shows detailed financial impact including prorations,
    credits, and final amounts before confirming the change.
    """

    # Plan info
    current_plan_id: UUID = Field(..., description="Current plan ID")
    current_plan_name: str = Field(..., description="Current plan name")
    current_plan_display: str = Field(
        ..., description="Current plan display name"
    )

    new_plan_id: UUID = Field(..., description="New plan ID")
    new_plan_name: str = Field(..., description="New plan name")
    new_plan_display: str = Field(..., description="New plan display name")

    # Change type
    change_type: PlanChangeType = Field(
        ..., description="Type of plan change"
    )

    # Pricing
    current_amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Current plan amount",
    )
    new_amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="New plan amount",
    )
    currency: str = Field(default="INR", description="Currency code")

    # Current period info
    current_period_start: date = Field(
        ..., description="Current billing period start"
    )
    current_period_end: date = Field(
        ..., description="Current billing period end"
    )
    days_remaining: int = Field(
        ...,
        ge=0,
        description="Days remaining in current period",
    )

    # Proration calculations
    prorated_credit: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Credit for unused portion of current plan",
    )
    prorated_charge: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Charge for new plan (prorated if applicable)",
    )

    # Final amounts
    amount_due_now: Decimal = Field(
        ...,
        decimal_places=2,
        description="Net amount due now (can be negative for credit)",
    )
    next_billing_amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="Amount on next regular billing",
    )

    # Dates
    effective_from: date = Field(
        ..., description="When change takes effect"
    )
    next_billing_date: date = Field(
        ..., description="Next billing date after change"
    )

    # Additional info
    message: str = Field(..., description="Summary message")
    warnings: List[str] = Field(
        default_factory=list,
        description="Warnings about the plan change",
    )
    benefits: List[str] = Field(
        default_factory=list,
        description="Benefits of the new plan",
    )

    @computed_field
    @property
    def is_upgrade(self) -> bool:
        """Check if this is an upgrade."""
        return self.change_type == PlanChangeType.UPGRADE

    @computed_field
    @property
    def is_downgrade(self) -> bool:
        """Check if this is a downgrade."""
        return self.change_type == PlanChangeType.DOWNGRADE

    @computed_field
    @property
    def monthly_difference(self) -> Decimal:
        """Calculate monthly price difference."""
        return (self.new_amount - self.current_amount).quantize(
            Decimal("0.01")
        )

    @computed_field
    @property
    def savings_or_increase(self) -> str:
        """Format savings or increase message."""
        diff = self.monthly_difference
        if diff > Decimal("0"):
            return f"+{self.currency} {diff:,.2f}/period"
        elif diff < Decimal("0"):
            return f"-{self.currency} {abs(diff):,.2f}/period"
        return "No change"


# Import computed_field for PlanChangePreview
from pydantic import computed_field


class PlanChangeConfirmation(BaseSchema):
    """
    Confirmation of completed plan change.

    Returned after a plan change is successfully processed.
    """

    subscription_id: UUID = Field(..., description="Updated subscription ID")
    hostel_id: UUID = Field(..., description="Hostel ID")

    # Change details
    previous_plan_id: UUID = Field(..., description="Previous plan ID")
    previous_plan_name: str = Field(..., description="Previous plan name")
    new_plan_id: UUID = Field(..., description="New plan ID")
    new_plan_name: str = Field(..., description="New plan name")
    change_type: PlanChangeType = Field(..., description="Type of change")

    # Financial
    amount_charged: Decimal = Field(
        default=Decimal("0.00"),
        decimal_places=2,
        description="Amount charged for the change",
    )
    credit_applied: Decimal = Field(
        default=Decimal("0.00"),
        ge=Decimal("0"),
        decimal_places=2,
        description="Credit applied from previous plan",
    )
    currency: str = Field(default="INR")

    # Dates
    effective_from: date = Field(
        ..., description="When change took effect"
    )
    next_billing_date: date = Field(..., description="Next billing date")
    new_billing_amount: Decimal = Field(
        ...,
        ge=Decimal("0"),
        decimal_places=2,
        description="New regular billing amount",
    )

    # Confirmation
    processed_at: datetime = Field(
        ..., description="When change was processed"
    )
    confirmation_number: str = Field(
        ..., description="Change confirmation reference"
    )
    message: str = Field(..., description="Confirmation message")


# Import datetime for PlanChangeConfirmation
from datetime import datetime

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\subscription\__init__.py ---
# --- File: app/schemas/subscription/__init__.py ---
"""
Subscription schemas package.

This module provides comprehensive schemas for:
- Subscription plans (definition, pricing, features)
- Hostel subscriptions (lifecycle management)
- Billing and invoicing
- Plan upgrades/downgrades
- Commission tracking
"""

from __future__ import annotations

# Commission schemas
from app.schemas.subscription.commission import (
    BookingCommissionResponse,
    CommissionConfig,
    CommissionStatus,
    CommissionSummary,
)

# Base subscription schemas
from app.schemas.subscription.subscription_base import (
    SubscriptionBase,
    SubscriptionCreate,
    SubscriptionUpdate,
)

# Billing schemas
from app.schemas.subscription.subscription_billing import (
    BillingCycleInfo,
    GenerateInvoiceRequest,
    InvoiceInfo,
    InvoiceStatus,
)

# Cancellation schemas
from app.schemas.subscription.subscription_cancellation import (
    CancellationRequest,
    CancellationResponse,
)

# Plan definition schemas
from app.schemas.subscription.subscription_plan_base import (
    PlanCreate,
    PlanUpdate,
    SubscriptionPlanBase,
)

# Plan response schemas
from app.schemas.subscription.subscription_plan_response import (
    PlanComparison,
    PlanFeatures,
    PlanResponse,
)

# Subscription response schemas
from app.schemas.subscription.subscription_response import (
    BillingHistory,
    BillingHistoryItem,
    SubscriptionResponse,
    SubscriptionSummary,
)

# Upgrade/downgrade schemas
from app.schemas.subscription.subscription_upgrade import (
    PlanChangeRequest,
    PlanChangePreview,
    PlanChangeType,
)

__all__ = [
    # Enums
    "CommissionStatus",
    "InvoiceStatus",
    "PlanChangeType",
    # Commission
    "CommissionConfig",
    "BookingCommissionResponse",
    "CommissionSummary",
    # Subscription base
    "SubscriptionBase",
    "SubscriptionCreate",
    "SubscriptionUpdate",
    # Billing
    "BillingCycleInfo",
    "GenerateInvoiceRequest",
    "InvoiceInfo",
    # Cancellation
    "CancellationRequest",
    "CancellationResponse",
    # Plan base
    "SubscriptionPlanBase",
    "PlanCreate",
    "PlanUpdate",
    # Plan response
    "PlanResponse",
    "PlanFeatures",
    "PlanComparison",
    # Subscription response
    "SubscriptionResponse",
    "SubscriptionSummary",
    "BillingHistoryItem",
    "BillingHistory",
    # Upgrade/downgrade
    "PlanChangeRequest",
    "PlanChangePreview",
]
