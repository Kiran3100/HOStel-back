### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\notification ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\notification =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\notification\email_notification.py ---
# --- File: app/schemas/notification/email_notification.py ---
"""
Email notification schemas.

This module provides schemas for email-specific notifications including
sending, tracking, templates, and bulk operations.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import EmailStr, Field, HttpUrl, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "EmailRequest",
    "EmailConfig",
    "EmailTracking",
    "EmailTemplate",
    "BulkEmailRequest",
    "EmailStats",
    "EmailAttachment",
    "EmailSchedule",
]


class EmailAttachment(BaseSchema):
    """Email attachment details."""

    filename: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Attachment filename",
    )
    url: HttpUrl = Field(
        ...,
        description="URL to attachment file",
    )
    mime_type: Optional[str] = Field(
        None,
        max_length=100,
        description="MIME type of attachment",
    )
    size_bytes: Optional[int] = Field(
        None,
        ge=0,
        le=26214400,  # 25MB max
        description="File size in bytes",
    )


class EmailRequest(BaseCreateSchema):
    """
    Send email notification request.

    Supports both direct content and template-based emails with
    advanced features like CC/BCC, attachments, and tracking.
    """

    # Recipients
    recipient_email: EmailStr = Field(
        ...,
        description="Primary recipient email address",
    )
    cc_emails: List[EmailStr] = Field(
        default_factory=list,
        max_length=10,
        description="CC recipients (max 10)",
    )
    bcc_emails: List[EmailStr] = Field(
        default_factory=list,
        max_length=10,
        description="BCC recipients (max 10)",
    )

    # Content
    subject: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Email subject line",
    )
    body_html: str = Field(
        ...,
        min_length=1,
        max_length=102400,  # 100KB max
        description="HTML email body",
    )
    body_text: Optional[str] = Field(
        None,
        max_length=102400,
        description="Plain text fallback body",
    )

    # Attachments
    attachments: List[EmailAttachment] = Field(
        default_factory=list,
        max_length=10,
        description="Email attachments (max 10)",
    )

    # Template support
    template_code: Optional[str] = Field(
        None,
        min_length=3,
        max_length=100,
        description="Template code (overrides direct content)",
    )
    template_variables: Optional[Dict[str, str]] = Field(
        None,
        description="Variables for template rendering",
    )

    # Sender customization
    reply_to: Optional[EmailStr] = Field(
        None,
        description="Reply-to email address",
    )
    from_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=100,
        description="Sender display name",
    )

    # Tracking settings
    track_opens: bool = Field(
        default=True,
        description="Enable open tracking",
    )
    track_clicks: bool = Field(
        default=True,
        description="Enable click tracking",
    )

    # Priority
    priority: str = Field(
        default="normal",
        pattern="^(low|normal|high)$",
        description="Email priority level",
    )

    # Scheduling
    send_at: Optional[datetime] = Field(
        None,
        description="Schedule email for future delivery",
    )

    # Metadata
    tags: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Tags for categorization and filtering",
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Custom metadata",
    )

    @field_validator("cc_emails", "bcc_emails")
    @classmethod
    def validate_unique_emails(cls, v: List[EmailStr]) -> List[EmailStr]:
        """Ensure email lists don't contain duplicates."""
        if len(v) != len(set(v)):
            raise ValueError("Duplicate email addresses not allowed")
        return v

    @field_validator("send_at")
    @classmethod
    def validate_send_time(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate scheduled send time is in the future."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Scheduled send time must be in the future")
        return v

    @model_validator(mode="after")
    def validate_content_or_template(self) -> "EmailRequest":
        """Ensure either direct content or template is provided."""
        if self.template_code:
            # Template mode - variables should be provided
            if not self.template_variables:
                raise ValueError(
                    "template_variables required when using template_code"
                )
        else:
            # Direct content mode - HTML body is required
            if not self.body_html:
                raise ValueError(
                    "body_html required when not using template_code"
                )
        return self

    @model_validator(mode="after")
    def validate_total_attachments_size(self) -> "EmailRequest":
        """Validate total attachments size doesn't exceed limit."""
        if self.attachments:
            total_size = sum(
                att.size_bytes for att in self.attachments if att.size_bytes
            )
            if total_size > 26214400:  # 25MB total
                raise ValueError("Total attachments size cannot exceed 25MB")
        return self


class EmailConfig(BaseSchema):
    """
    Email service configuration.

    Supports multiple email service providers with unified configuration.
    """

    # Service provider
    service_provider: str = Field(
        ...,
        pattern="^(sendgrid|ses|smtp|mailgun|postmark)$",
        description="Email service provider",
    )

    # SMTP configuration (for SMTP provider)
    smtp_host: Optional[str] = Field(
        None,
        max_length=255,
        description="SMTP server hostname",
    )
    smtp_port: Optional[int] = Field(
        None,
        ge=1,
        le=65535,
        description="SMTP server port",
    )
    smtp_username: Optional[str] = Field(
        None,
        max_length=255,
        description="SMTP authentication username",
    )
    smtp_use_tls: bool = Field(
        default=True,
        description="Use TLS for SMTP connection",
    )

    # API configuration (for API-based providers)
    api_key: Optional[str] = Field(
        None,
        max_length=500,
        description="API key for email service",
    )

    # Sender configuration
    from_email: EmailStr = Field(
        ...,
        description="Default sender email address",
    )
    from_name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Default sender name",
    )
    reply_to_email: Optional[EmailStr] = Field(
        None,
        description="Default reply-to address",
    )

    # Rate limiting
    max_emails_per_hour: int = Field(
        default=100,
        ge=1,
        le=10000,
        description="Maximum emails per hour",
    )
    max_emails_per_day: int = Field(
        default=1000,
        ge=1,
        le=100000,
        description="Maximum emails per day",
    )

    # Tracking defaults
    enable_open_tracking: bool = Field(
        default=True,
        description="Enable open tracking by default",
    )
    enable_click_tracking: bool = Field(
        default=True,
        description="Enable click tracking by default",
    )

    # Bounce handling
    bounce_webhook_url: Optional[HttpUrl] = Field(
        None,
        description="Webhook URL for bounce notifications",
    )

    @model_validator(mode="after")
    def validate_smtp_config(self) -> "EmailConfig":
        """Validate SMTP-specific configuration."""
        if self.service_provider == "smtp":
            if not all([self.smtp_host, self.smtp_port, self.smtp_username]):
                raise ValueError(
                    "SMTP configuration requires host, port, and username"
                )
        return self

    @model_validator(mode="after")
    def validate_api_config(self) -> "EmailConfig":
        """Validate API-based provider configuration."""
        if self.service_provider in ["sendgrid", "ses", "mailgun", "postmark"]:
            if not self.api_key:
                raise ValueError(
                    f"API key required for {self.service_provider}"
                )
        return self


class EmailTracking(BaseSchema):
    """
    Email tracking and delivery information.

    Tracks the complete lifecycle of an email from send to engagement.
    """

    email_id: UUID = Field(
        ...,
        description="Email notification ID",
    )
    recipient_email: EmailStr = Field(
        ...,
        description="Recipient email address",
    )

    # Delivery status
    sent_at: datetime = Field(
        ...,
        description="When email was sent",
    )
    delivered_at: Optional[datetime] = Field(
        None,
        description="When email was delivered",
    )
    bounced_at: Optional[datetime] = Field(
        None,
        description="When email bounced",
    )

    delivery_status: str = Field(
        ...,
        pattern="^(sent|delivered|bounced|failed|spam|rejected)$",
        description="Current delivery status",
    )

    # Engagement tracking
    opened: bool = Field(
        default=False,
        description="Whether email was opened",
    )
    first_opened_at: Optional[datetime] = Field(
        None,
        description="When email was first opened",
    )
    last_opened_at: Optional[datetime] = Field(
        None,
        description="When email was last opened",
    )
    open_count: int = Field(
        default=0,
        ge=0,
        description="Number of times email was opened",
    )

    clicked: bool = Field(
        default=False,
        description="Whether any link was clicked",
    )
    first_clicked_at: Optional[datetime] = Field(
        None,
        description="When first link was clicked",
    )
    last_clicked_at: Optional[datetime] = Field(
        None,
        description="When last link was clicked",
    )
    click_count: int = Field(
        default=0,
        ge=0,
        description="Total number of link clicks",
    )

    # Link-level tracking
    clicked_links: List[str] = Field(
        default_factory=list,
        description="URLs that were clicked",
    )

    # Error information
    bounce_type: Optional[str] = Field(
        None,
        pattern="^(hard|soft|complaint)$",
        description="Type of bounce if bounced",
    )
    error_message: Optional[str] = Field(
        None,
        max_length=1000,
        description="Error or bounce reason",
    )

    # Provider information
    provider_message_id: Optional[str] = Field(
        None,
        max_length=255,
        description="Provider's message ID",
    )

    # Spam reports
    marked_as_spam: bool = Field(
        default=False,
        description="Whether recipient marked as spam",
    )
    spam_reported_at: Optional[datetime] = Field(
        None,
        description="When marked as spam",
    )


class EmailTemplate(BaseSchema):
    """
    Email-specific template configuration.

    Extends base template with email-specific features like
    header images and footer text.
    """

    template_code: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Unique template identifier",
    )

    # Email content
    subject: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Email subject template",
    )
    html_body: str = Field(
        ...,
        min_length=1,
        max_length=102400,
        description="HTML body template",
    )
    text_body: Optional[str] = Field(
        None,
        max_length=102400,
        description="Plain text body template",
    )

    # Styling and branding
    header_image_url: Optional[HttpUrl] = Field(
        None,
        description="Header/logo image URL",
    )
    footer_text: Optional[str] = Field(
        None,
        max_length=1000,
        description="Footer text (company info, unsubscribe link, etc.)",
    )
    primary_color: Optional[str] = Field(
        None,
        pattern="^#[0-9A-Fa-f]{6}$",
        description="Primary brand color (hex code)",
    )

    # Variables
    required_variables: List[str] = Field(
        ...,
        description="Required template variables",
    )
    optional_variables: List[str] = Field(
        default_factory=list,
        description="Optional template variables",
    )

    # Preheader
    preheader_text: Optional[str] = Field(
        None,
        max_length=150,
        description="Email preheader/preview text",
    )


class BulkEmailRequest(BaseCreateSchema):
    """
    Send bulk emails to multiple recipients.

    Optimized for batch sending with per-recipient variable substitution.
    """

    recipients: List[EmailStr] = Field(
        ...,
        min_length=1,
        max_length=1000,
        description="List of recipient email addresses (max 1000)",
    )

    # Content (same for all recipients or use template)
    subject: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Email subject",
    )
    body_html: str = Field(
        ...,
        min_length=1,
        max_length=102400,
        description="HTML email body",
    )

    # Template support
    template_code: Optional[str] = Field(
        None,
        description="Template code for all emails",
    )

    # Per-recipient customization
    recipient_variables: Optional[Dict[EmailStr, Dict[str, str]]] = Field(
        None,
        description="Per-recipient variable mapping (email -> variables)",
    )

    # Batch settings
    batch_size: int = Field(
        default=100,
        ge=10,
        le=1000,
        description="Number of emails per batch",
    )
    delay_between_batches_seconds: int = Field(
        default=5,
        ge=1,
        le=60,
        description="Delay between batches in seconds",
    )

    # Tracking
    track_opens: bool = Field(
        default=True,
        description="Enable open tracking",
    )
    track_clicks: bool = Field(
        default=True,
        description="Enable click tracking",
    )

    # Metadata
    tags: List[str] = Field(
        default_factory=list,
        description="Tags for this bulk send campaign",
    )

    @field_validator("recipients")
    @classmethod
    def validate_unique_recipients(cls, v: List[EmailStr]) -> List[EmailStr]:
        """Ensure recipient list doesn't contain duplicates."""
        if len(v) != len(set(v)):
            raise ValueError("Duplicate email addresses in recipients list")
        return v

    @model_validator(mode="after")
    def validate_recipient_variables(self) -> "BulkEmailRequest":
        """Validate recipient variables match recipients list."""
        if self.recipient_variables:
            # Check all recipients have variables if any are provided
            missing = set(self.recipients) - set(self.recipient_variables.keys())
            if missing:
                raise ValueError(
                    f"Missing variables for recipients: {', '.join(missing)}"
                )
        return self


class EmailStats(BaseSchema):
    """
    Email campaign statistics and metrics.

    Provides comprehensive analytics for email performance.
    """

    # Send statistics
    total_sent: int = Field(
        ...,
        ge=0,
        description="Total emails sent",
    )
    total_delivered: int = Field(
        ...,
        ge=0,
        description="Total emails delivered",
    )
    total_bounced: int = Field(
        ...,
        ge=0,
        description="Total emails bounced",
    )
    total_failed: int = Field(
        ...,
        ge=0,
        description="Total send failures",
    )

    # Delivery rates
    delivery_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Delivery rate percentage",
    )
    bounce_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Bounce rate percentage",
    )

    # Engagement statistics
    total_opened: int = Field(
        ...,
        ge=0,
        description="Total unique opens",
    )
    total_opens: int = Field(
        ...,
        ge=0,
        description="Total opens (including repeats)",
    )
    open_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Open rate percentage",
    )

    total_clicked: int = Field(
        ...,
        ge=0,
        description="Total unique clicks",
    )
    total_clicks: int = Field(
        ...,
        ge=0,
        description="Total clicks (including repeats)",
    )
    click_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Click rate percentage",
    )
    click_to_open_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Click-to-open rate percentage",
    )

    # Spam and complaints
    total_spam_reports: int = Field(
        default=0,
        ge=0,
        description="Number of spam complaints",
    )
    spam_rate: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        le=100,
        description="Spam complaint rate percentage",
    )

    # Unsubscribes
    total_unsubscribed: int = Field(
        default=0,
        ge=0,
        description="Number of unsubscribes",
    )
    unsubscribe_rate: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        le=100,
        description="Unsubscribe rate percentage",
    )

    # Time period
    period_start: date = Field(
        ...,
        description="Statistics period start date",
    )
    period_end: date = Field(
        ...,
        description="Statistics period end date",
    )

    @field_validator("period_end")
    @classmethod
    def validate_period(cls, v: date, info) -> date:
        """Validate period end is after period start."""
        period_start = info.data.get("period_start")
        if period_start and v < period_start:
            raise ValueError("period_end must be after or equal to period_start")
        return v


class EmailSchedule(BaseCreateSchema):
    """
    Schedule an email for future delivery.

    Supports recurring emails and timezone-aware scheduling.
    """

    email_request: EmailRequest = Field(
        ...,
        description="Email to schedule",
    )
    scheduled_for: datetime = Field(
        ...,
        description="When to send the email",
    )
    timezone: str = Field(
        default="UTC",
        description="Timezone for scheduled time",
    )
    is_recurring: bool = Field(
        default=False,
        description="Whether this is a recurring email",
    )
    recurrence_pattern: Optional[str] = Field(
        None,
        pattern="^(daily|weekly|monthly|yearly)$",
        description="Recurrence pattern if recurring",
    )
    recurrence_end_date: Optional[date] = Field(
        None,
        description="When to stop recurring",
    )

    @field_validator("scheduled_for")
    @classmethod
    def validate_scheduled_time(cls, v: datetime) -> datetime:
        """Validate scheduled time is in the future."""
        if v <= datetime.utcnow():
            raise ValueError("Scheduled time must be in the future")
        return v

    @model_validator(mode="after")
    def validate_recurrence(self) -> "EmailSchedule":
        """Validate recurrence configuration."""
        if self.is_recurring:
            if not self.recurrence_pattern:
                raise ValueError(
                    "recurrence_pattern required for recurring emails"
                )
            if not self.recurrence_end_date:
                raise ValueError(
                    "recurrence_end_date required for recurring emails"
                )
            if self.recurrence_end_date <= date.today():
                raise ValueError(
                    "recurrence_end_date must be in the future"
                )
        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\notification\notification_base.py ---
# --- File: app/schemas/notification/notification_base.py ---
"""
Notification base schemas.

This module provides core notification schemas for creating, updating,
and managing notifications across different channels (email, SMS, push).
"""

from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import NotificationType, Priority

__all__ = [
    "NotificationBase",
    "NotificationCreate",
    "NotificationUpdate",
    "MarkAsRead",
    "BulkMarkAsRead",
    "NotificationDelete",
]


class NotificationBase(BaseSchema):
    """
    Base notification schema with common fields.

    Contains recipient information, content, priority, and scheduling options
    for notifications across all channels.
    """

    # Recipient information (at least one must be provided)
    recipient_user_id: Optional[UUID] = Field(
        None,
        description="Recipient user ID for user-based routing",
    )
    recipient_email: Optional[str] = Field(
        None,
        description="Recipient email address for email notifications",
    )
    recipient_phone: Optional[str] = Field(
        None,
        description="Recipient phone number for SMS notifications",
    )

    # Notification channel
    notification_type: NotificationType = Field(
        ...,
        description="Notification delivery channel (email/sms/push)",
    )

    # Template support
    template_code: Optional[str] = Field(
        None,
        min_length=3,
        max_length=100,
        description="Template code for pre-defined notification templates",
    )

    # Content
    subject: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Notification subject/title (required for email and push)",
    )
    message_body: str = Field(
        ...,
        min_length=1,
        max_length=5000,
        description="Notification message content",
    )

    # Priority and scheduling
    priority: Priority = Field(
        default=Priority.MEDIUM,
        description="Notification delivery priority",
    )
    scheduled_at: Optional[datetime] = Field(
        None,
        description="Scheduled delivery time (null for immediate delivery)",
    )

    # Metadata and context
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional context data for the notification",
    )

    # Related entity
    hostel_id: Optional[UUID] = Field(
        None,
        description="Associated hostel ID for hostel-specific notifications",
    )

    @field_validator("recipient_email")
    @classmethod
    def validate_email(cls, v: Optional[str]) -> Optional[str]:
        """Validate email format if provided."""
        if v is not None:
            # Basic email validation
            import re
            email_pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
            if not re.match(email_pattern, v):
                raise ValueError("Invalid email format")
        return v

    @field_validator("recipient_phone")
    @classmethod
    def validate_phone(cls, v: Optional[str]) -> Optional[str]:
        """Validate phone number format if provided."""
        if v is not None:
            import re
            # International phone number pattern
            phone_pattern = r"^\+?[1-9]\d{9,14}$"
            if not re.match(phone_pattern, v):
                raise ValueError(
                    "Invalid phone number format. Must be 10-15 digits, optionally starting with +"
                )
        return v

    @field_validator("scheduled_at")
    @classmethod
    def validate_scheduled_time(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate scheduled time is in the future."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Scheduled time must be in the future")
        return v

    @model_validator(mode="after")
    def validate_recipients(self) -> "NotificationBase":
        """Ensure at least one recipient identifier is provided."""
        if not any([
            self.recipient_user_id,
            self.recipient_email,
            self.recipient_phone,
        ]):
            raise ValueError(
                "At least one recipient identifier (user_id, email, or phone) must be provided"
            )
        return self

    @model_validator(mode="after")
    def validate_subject_requirement(self) -> "NotificationBase":
        """Validate subject is provided for email and push notifications."""
        if self.notification_type in [NotificationType.EMAIL, NotificationType.PUSH]:
            if not self.subject:
                raise ValueError(
                    f"Subject is required for {self.notification_type.value} notifications"
                )
        return self

    @model_validator(mode="after")
    def validate_message_length(self) -> "NotificationBase":
        """Validate message length based on notification type."""
        if self.notification_type == NotificationType.SMS:
            # SMS has stricter length limits
            if len(self.message_body) > 1600:  # 10 segments max
                raise ValueError(
                    "SMS message body cannot exceed 1600 characters (10 segments)"
                )
        return self


class NotificationCreate(NotificationBase, BaseCreateSchema):
    """
    Schema for creating a new notification.

    Inherits all fields from NotificationBase with creation-specific validation.
    """

    @field_validator("metadata")
    @classmethod
    def validate_metadata_size(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        """Ensure metadata doesn't exceed reasonable size."""
        import json
        if len(json.dumps(v)) > 10000:  # 10KB limit
            raise ValueError("Metadata size cannot exceed 10KB")
        return v


class NotificationUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing notification.

    Only allows updating limited fields: scheduling, priority, and status.
    Content updates are not permitted to maintain audit trail.
    """

    scheduled_at: Optional[datetime] = Field(
        None,
        description="Update scheduled delivery time",
    )
    priority: Optional[Priority] = Field(
        None,
        description="Update notification priority",
    )
    status: Optional[str] = Field(
        None,
        pattern="^(queued|processing|sent|delivered|failed|cancelled)$",
        description="Update notification status",
    )

    @field_validator("scheduled_at")
    @classmethod
    def validate_scheduled_time(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate scheduled time is in the future if provided."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Scheduled time must be in the future")
        return v

    @model_validator(mode="after")
    def validate_at_least_one_field(self) -> "NotificationUpdate":
        """Ensure at least one field is being updated."""
        if not any([self.scheduled_at, self.priority, self.status]):
            raise ValueError("At least one field must be provided for update")
        return self


class MarkAsRead(BaseCreateSchema):
    """Schema for marking a notification as read by a user."""

    notification_id: UUID = Field(
        ...,
        description="ID of the notification to mark as read",
    )
    user_id: UUID = Field(
        ...,
        description="ID of the user marking the notification as read",
    )
    read_at: Optional[datetime] = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when the notification was read",
    )


class BulkMarkAsRead(BaseCreateSchema):
    """Schema for marking multiple notifications as read in a single operation."""

    notification_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of notification IDs to mark as read (max 100)",
    )
    user_id: UUID = Field(
        ...,
        description="ID of the user marking notifications as read",
    )
    read_at: Optional[datetime] = Field(
        default_factory=datetime.utcnow,
        description="Timestamp for all read operations",
    )

    @field_validator("notification_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[UUID]) -> List[UUID]:
        """Ensure notification IDs are unique."""
        if len(v) != len(set(v)):
            raise ValueError("Duplicate notification IDs are not allowed")
        return v


class NotificationDelete(BaseCreateSchema):
    """
    Schema for deleting a notification.

    Supports both soft delete (default) and permanent deletion.
    """

    notification_id: UUID = Field(
        ...,
        description="ID of the notification to delete",
    )
    user_id: UUID = Field(
        ...,
        description="ID of the user performing the deletion",
    )
    permanent: bool = Field(
        default=False,
        description="If True, permanently delete; if False, soft delete",
    )
    deletion_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for deletion (optional, for audit purposes)",
    )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\notification\notification_preferences.py ---
# --- File: app/schemas/notification/notification_preferences.py ---
"""
Notification preferences schemas.

This module provides schemas for managing user notification preferences
including channel selection, frequency settings, and quiet hours.
"""

from __future__ import annotations

from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseSchema, BaseUpdateSchema

__all__ = [
    "UserPreferences",
    "ChannelPreferences",
    "EmailPreferences",
    "SMSPreferences",
    "PushPreferences",
    "FrequencySettings",
    "PreferenceUpdate",
    "UnsubscribeRequest",
    "QuietHours",
]


class FrequencySettings(BaseSchema):
    """
    Notification frequency settings.

    Controls how often and when notifications are delivered.
    """

    # Delivery mode
    immediate_notifications: bool = Field(
        default=True,
        description="Send notifications immediately",
    )

    # Batching
    batch_notifications: bool = Field(
        default=False,
        description="Batch notifications instead of immediate delivery",
    )
    batch_interval_hours: int = Field(
        default=4,
        ge=1,
        le=24,
        description="Hours between batched notifications",
    )

    # Digest
    daily_digest_enabled: bool = Field(
        default=False,
        description="Enable daily digest",
    )
    daily_digest_time: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Daily digest time in HH:MM format (24-hour)",
    )

    weekly_digest_enabled: bool = Field(
        default=False,
        description="Enable weekly digest",
    )
    weekly_digest_day: Optional[str] = Field(
        None,
        pattern="^(monday|tuesday|wednesday|thursday|friday|saturday|sunday)$",
        description="Day for weekly digest",
    )
    weekly_digest_time: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Weekly digest time in HH:MM format",
    )

    @model_validator(mode="after")
    def validate_digest_settings(self) -> "FrequencySettings":
        """Validate digest configuration."""
        if self.daily_digest_enabled and not self.daily_digest_time:
            raise ValueError("daily_digest_time required when daily digest is enabled")

        if self.weekly_digest_enabled:
            if not self.weekly_digest_day or not self.weekly_digest_time:
                raise ValueError(
                    "weekly_digest_day and weekly_digest_time required when weekly digest is enabled"
                )

        return self


class QuietHours(BaseSchema):
    """
    Quiet hours configuration.

    Defines time periods when notifications should not be sent.
    """

    enabled: bool = Field(
        default=False,
        description="Enable quiet hours",
    )

    start_time: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Quiet hours start time (HH:MM, 24-hour format)",
    )
    end_time: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Quiet hours end time (HH:MM, 24-hour format)",
    )

    # Days of week
    apply_on_weekdays: bool = Field(
        default=True,
        description="Apply quiet hours on weekdays",
    )
    apply_on_weekends: bool = Field(
        default=True,
        description="Apply quiet hours on weekends",
    )

    # Exceptions
    allow_urgent: bool = Field(
        default=True,
        description="Allow urgent/critical notifications during quiet hours",
    )

    # Timezone
    timezone: str = Field(
        default="UTC",
        max_length=100,
        description="Timezone for quiet hours",
    )

    @model_validator(mode="after")
    def validate_quiet_hours(self) -> "QuietHours":
        """Validate quiet hours configuration."""
        if self.enabled:
            if not self.start_time or not self.end_time:
                raise ValueError(
                    "start_time and end_time required when quiet hours are enabled"
                )
        return self


class EmailPreferences(BaseSchema):
    """
    Email notification preferences.

    Fine-grained control over email notifications.
    """

    enabled: bool = Field(
        default=True,
        description="Enable email notifications",
    )

    # Digest settings
    daily_digest: bool = Field(
        default=False,
        description="Receive daily digest email",
    )
    weekly_digest: bool = Field(
        default=False,
        description="Receive weekly digest email",
    )

    # Category preferences
    receive_payment_emails: bool = Field(
        default=True,
        description="Receive payment-related emails",
    )
    receive_booking_emails: bool = Field(
        default=True,
        description="Receive booking-related emails",
    )
    receive_complaint_emails: bool = Field(
        default=True,
        description="Receive complaint-related emails",
    )
    receive_announcement_emails: bool = Field(
        default=True,
        description="Receive announcement emails",
    )
    receive_maintenance_emails: bool = Field(
        default=True,
        description="Receive maintenance notification emails",
    )
    receive_marketing_emails: bool = Field(
        default=False,
        description="Receive marketing and promotional emails",
    )

    # Format preferences
    html_emails: bool = Field(
        default=True,
        description="Receive HTML formatted emails",
    )
    text_emails_fallback: bool = Field(
        default=True,
        description="Include plain text fallback",
    )


class SMSPreferences(BaseSchema):
    """
    SMS notification preferences.

    Control over SMS delivery with cost considerations.
    """

    enabled: bool = Field(
        default=True,
        description="Enable SMS notifications",
    )

    # Filtering
    urgent_only: bool = Field(
        default=True,
        description="Only receive urgent/high priority SMS",
    )

    # Category preferences
    receive_payment_sms: bool = Field(
        default=True,
        description="Receive payment-related SMS",
    )
    receive_booking_sms: bool = Field(
        default=True,
        description="Receive booking-related SMS",
    )
    receive_emergency_sms: bool = Field(
        default=True,
        description="Receive emergency SMS",
    )
    receive_otp_sms: bool = Field(
        default=True,
        description="Receive OTP and verification SMS",
    )

    # Frequency limits
    max_sms_per_day: int = Field(
        default=10,
        ge=1,
        le=50,
        description="Maximum SMS per day",
    )


class PushPreferences(BaseSchema):
    """
    Push notification preferences.

    Control over mobile and web push notifications.
    """

    enabled: bool = Field(
        default=True,
        description="Enable push notifications",
    )

    # Sound and alerts
    sound_enabled: bool = Field(
        default=True,
        description="Play notification sound",
    )
    vibration_enabled: bool = Field(
        default=True,
        description="Enable vibration",
    )

    # Badge
    badge_enabled: bool = Field(
        default=True,
        description="Show badge count on app icon",
    )

    # Preview
    show_preview: bool = Field(
        default=True,
        description="Show message preview on lock screen",
    )

    # Lock screen
    show_on_lock_screen: bool = Field(
        default=True,
        description="Show notifications on lock screen",
    )

    # Category preferences
    receive_payment_push: bool = Field(
        default=True,
        description="Receive payment push notifications",
    )
    receive_booking_push: bool = Field(
        default=True,
        description="Receive booking push notifications",
    )
    receive_complaint_push: bool = Field(
        default=True,
        description="Receive complaint push notifications",
    )
    receive_announcement_push: bool = Field(
        default=True,
        description="Receive announcement push notifications",
    )


class ChannelPreferences(BaseSchema):
    """
    Channel-specific notification preferences.

    Aggregates preferences for all notification channels.
    """

    user_id: UUID = Field(
        ...,
        description="User ID",
    )

    # Email preferences
    email: EmailPreferences = Field(
        default_factory=EmailPreferences,
        description="Email notification preferences",
    )

    # SMS preferences
    sms: SMSPreferences = Field(
        default_factory=SMSPreferences,
        description="SMS notification preferences",
    )

    # Push preferences
    push: PushPreferences = Field(
        default_factory=PushPreferences,
        description="Push notification preferences",
    )


class UserPreferences(BaseSchema):
    """
    Complete user notification preferences.

    Master preferences including global settings, channel preferences,
    and scheduling options.
    """

    user_id: UUID = Field(
        ...,
        description="User ID",
    )

    # Global settings
    notifications_enabled: bool = Field(
        default=True,
        description="Master notification toggle",
    )

    # Channel toggles
    email_enabled: bool = Field(
        default=True,
        description="Enable email notifications",
    )
    sms_enabled: bool = Field(
        default=True,
        description="Enable SMS notifications",
    )
    push_enabled: bool = Field(
        default=True,
        description="Enable push notifications",
    )

    # Frequency
    frequency_settings: FrequencySettings = Field(
        default_factory=FrequencySettings,
        description="Notification frequency settings",
    )

    # Quiet hours
    quiet_hours: QuietHours = Field(
        default_factory=QuietHours,
        description="Quiet hours configuration",
    )

    # Category preferences (global overrides)
    payment_notifications: bool = Field(
        default=True,
        description="Receive payment notifications",
    )
    booking_notifications: bool = Field(
        default=True,
        description="Receive booking notifications",
    )
    complaint_notifications: bool = Field(
        default=True,
        description="Receive complaint notifications",
    )
    announcement_notifications: bool = Field(
        default=True,
        description="Receive announcement notifications",
    )
    maintenance_notifications: bool = Field(
        default=True,
        description="Receive maintenance notifications",
    )
    attendance_notifications: bool = Field(
        default=True,
        description="Receive attendance notifications",
    )
    marketing_notifications: bool = Field(
        default=False,
        description="Receive marketing notifications",
    )

    # Language
    preferred_language: str = Field(
        default="en",
        min_length=2,
        max_length=5,
        description="Preferred language for notifications",
    )

    # Timezone
    timezone: str = Field(
        default="UTC",
        max_length=100,
        description="User timezone for scheduling",
    )


class PreferenceUpdate(BaseUpdateSchema):
    """
    Update notification preferences.

    Allows partial updates to user preferences.
    """

    # Global toggles
    notifications_enabled: Optional[bool] = Field(
        None,
        description="Update master notification toggle",
    )
    email_enabled: Optional[bool] = Field(
        None,
        description="Update email notifications",
    )
    sms_enabled: Optional[bool] = Field(
        None,
        description="Update SMS notifications",
    )
    push_enabled: Optional[bool] = Field(
        None,
        description="Update push notifications",
    )

    # Quiet hours
    quiet_hours_enabled: Optional[bool] = Field(
        None,
        description="Enable/disable quiet hours",
    )
    quiet_hours_start: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Update quiet hours start time",
    )
    quiet_hours_end: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Update quiet hours end time",
    )

    # Category toggles
    payment_notifications: Optional[bool] = None
    booking_notifications: Optional[bool] = None
    complaint_notifications: Optional[bool] = None
    announcement_notifications: Optional[bool] = None
    maintenance_notifications: Optional[bool] = None
    attendance_notifications: Optional[bool] = None
    marketing_notifications: Optional[bool] = None

    # Frequency
    immediate_notifications: Optional[bool] = None
    batch_notifications: Optional[bool] = None
    daily_digest_enabled: Optional[bool] = None
    weekly_digest_enabled: Optional[bool] = None

    # Language and timezone
    preferred_language: Optional[str] = Field(
        None,
        min_length=2,
        max_length=5,
        description="Update preferred language",
    )
    timezone: Optional[str] = Field(
        None,
        max_length=100,
        description="Update timezone",
    )


class UnsubscribeRequest(BaseSchema):
    """
    Unsubscribe from notifications.

    Allows users to opt-out of specific notification types.
    """

    user_id: UUID = Field(
        ...,
        description="User ID to unsubscribe",
    )
    unsubscribe_token: str = Field(
        ...,
        min_length=32,
        max_length=128,
        description="Secure unsubscribe token",
    )

    # What to unsubscribe from
    unsubscribe_type: str = Field(
        ...,
        pattern="^(all|email|sms|push|marketing|specific_category)$",
        description="Type of unsubscription",
    )

    # Category (if specific_category)
    category: Optional[str] = Field(
        None,
        max_length=100,
        description="Specific category to unsubscribe from",
    )

    # Reason
    reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for unsubscribing (optional)",
    )

    @model_validator(mode="after")
    def validate_category_requirement(self) -> "UnsubscribeRequest":
        """Validate category is provided when needed."""
        if self.unsubscribe_type == "specific_category" and not self.category:
            raise ValueError(
                "category required when unsubscribe_type is 'specific_category'"
            )
        return self

    @field_validator("unsubscribe_token")
    @classmethod
    def validate_token_format(cls, v: str) -> str:
        """Validate token is alphanumeric."""
        if not v.replace("-", "").replace("_", "").isalnum():
            raise ValueError("Invalid unsubscribe token format")
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\notification\notification_queue.py ---
# --- File: app/schemas/notification/notification_queue.py ---
"""
Notification queue schemas.

This module provides schemas for managing notification queues, batch
processing, and monitoring queue performance and health.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import NotificationStatus, NotificationType, Priority

__all__ = [
    "QueueStatus",
    "QueuedNotification",
    "BatchProcessing",
    "QueueStats",
    "QueueHealth",
    "QueuePriority",
]


class QueueStatus(BaseSchema):
    """
    Current notification queue status.

    Provides real-time overview of queue state across all channels
    and priorities.
    """

    # Overall queue counts
    total_queued: int = Field(
        ...,
        ge=0,
        description="Total notifications in queue",
    )
    total_processing: int = Field(
        ...,
        ge=0,
        description="Notifications currently being processed",
    )
    total_failed: int = Field(
        ...,
        ge=0,
        description="Failed notifications awaiting retry",
    )

    # By priority
    urgent_queued: int = Field(
        default=0,
        ge=0,
        description="Urgent/critical priority notifications queued",
    )
    high_queued: int = Field(
        default=0,
        ge=0,
        description="High priority notifications queued",
    )
    medium_queued: int = Field(
        default=0,
        ge=0,
        description="Medium priority notifications queued",
    )
    low_queued: int = Field(
        default=0,
        ge=0,
        description="Low priority notifications queued",
    )

    # By notification type
    email_queued: int = Field(
        default=0,
        ge=0,
        description="Email notifications queued",
    )
    sms_queued: int = Field(
        default=0,
        ge=0,
        description="SMS notifications queued",
    )
    push_queued: int = Field(
        default=0,
        ge=0,
        description="Push notifications queued",
    )

    # Processing performance
    avg_processing_time_seconds: Decimal = Field(
        ...,
        ge=0,
        description="Average processing time per notification",
    )
    throughput_per_minute: Decimal = Field(
        ...,
        ge=0,
        description="Notifications processed per minute",
    )

    # Queue health
    is_healthy: bool = Field(
        ...,
        description="Whether queue is operating normally",
    )
    oldest_queued_age_minutes: Optional[int] = Field(
        None,
        ge=0,
        description="Age of oldest queued notification in minutes",
    )

    # Timestamp
    checked_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When status was checked",
    )

    @computed_field
    @property
    def total_in_system(self) -> int:
        """Calculate total notifications in the system."""
        return self.total_queued + self.total_processing + self.total_failed

    @computed_field
    @property
    def queue_utilization_percent(self) -> float:
        """Calculate queue utilization as a percentage."""
        # Assuming a max queue size (configurable)
        max_queue_size = 10000
        if self.total_queued == 0:
            return 0.0
        return round((self.total_queued / max_queue_size) * 100, 2)


class QueuedNotification(BaseSchema):
    """
    Individual queued notification details.

    Represents a notification waiting in queue for processing.
    """

    notification_id: UUID = Field(
        ...,
        description="Notification ID",
    )

    # Notification details
    notification_type: NotificationType = Field(
        ...,
        description="Notification channel",
    )
    priority: Priority = Field(
        ...,
        description="Delivery priority",
    )
    status: NotificationStatus = Field(
        ...,
        description="Current status",
    )

    # Recipient
    recipient: str = Field(
        ...,
        max_length=255,
        description="Recipient identifier (email/phone/user_id)",
    )

    # Timing
    scheduled_at: Optional[datetime] = Field(
        None,
        description="Scheduled delivery time",
    )
    queued_at: datetime = Field(
        ...,
        description="When notification was queued",
    )
    processing_started_at: Optional[datetime] = Field(
        None,
        description="When processing started",
    )

    # Retry information
    retry_count: int = Field(
        default=0,
        ge=0,
        description="Number of retry attempts",
    )
    max_retries: int = Field(
        default=3,
        ge=0,
        description="Maximum allowed retries",
    )
    next_retry_at: Optional[datetime] = Field(
        None,
        description="When next retry will be attempted",
    )

    # Estimates
    estimated_send_time: Optional[datetime] = Field(
        None,
        description="Estimated send time based on queue position",
    )
    queue_position: Optional[int] = Field(
        None,
        ge=1,
        description="Position in queue (by priority)",
    )

    # Error tracking
    last_error: Optional[str] = Field(
        None,
        max_length=500,
        description="Last error message if failed",
    )

    @computed_field
    @property
    def age_minutes(self) -> int:
        """Calculate how long notification has been in queue."""
        return int((datetime.utcnow() - self.queued_at).total_seconds() / 60)

    @computed_field
    @property
    def can_retry(self) -> bool:
        """Check if notification can be retried."""
        return (
            self.status == NotificationStatus.FAILED
            and self.retry_count < self.max_retries
        )


class BatchProcessing(BaseSchema):
    """
    Batch processing status and progress.

    Tracks bulk notification sends with detailed progress metrics.
    """

    batch_id: UUID = Field(
        ...,
        description="Unique batch identifier",
    )

    # Batch details
    batch_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Batch/campaign name",
    )
    notification_type: NotificationType = Field(
        ...,
        description="Type of notifications in batch",
    )

    # Counts
    total_notifications: int = Field(
        ...,
        ge=1,
        description="Total notifications in batch",
    )
    processed: int = Field(
        ...,
        ge=0,
        description="Notifications processed so far",
    )
    successful: int = Field(
        ...,
        ge=0,
        description="Successfully sent notifications",
    )
    failed: int = Field(
        ...,
        ge=0,
        description="Failed notifications",
    )
    pending: int = Field(
        ...,
        ge=0,
        description="Notifications still pending",
    )

    # Status
    status: str = Field(
        ...,
        pattern="^(queued|processing|paused|completed|failed|cancelled)$",
        description="Batch processing status",
    )

    # Timing
    created_at: datetime = Field(
        ...,
        description="When batch was created",
    )
    started_at: Optional[datetime] = Field(
        None,
        description="When processing started",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="When processing completed",
    )

    # Estimates
    estimated_completion: Optional[datetime] = Field(
        None,
        description="Estimated completion time",
    )
    estimated_duration_seconds: Optional[int] = Field(
        None,
        ge=0,
        description="Estimated total duration",
    )

    # Performance
    current_throughput_per_minute: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        description="Current processing rate",
    )
    average_processing_time_seconds: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        description="Average time per notification",
    )

    # Error summary
    error_summary: Optional[str] = Field(
        None,
        max_length=1000,
        description="Summary of errors encountered",
    )

    @computed_field
    @property
    def progress_percentage(self) -> float:
        """Calculate batch progress percentage."""
        if self.total_notifications == 0:
            return 0.0
        return round((self.processed / self.total_notifications) * 100, 2)

    @computed_field
    @property
    def success_rate(self) -> float:
        """Calculate success rate percentage."""
        if self.processed == 0:
            return 0.0
        return round((self.successful / self.processed) * 100, 2)

    @computed_field
    @property
    def failure_rate(self) -> float:
        """Calculate failure rate percentage."""
        if self.processed == 0:
            return 0.0
        return round((self.failed / self.processed) * 100, 2)

    @computed_field
    @property
    def is_complete(self) -> bool:
        """Check if batch processing is complete."""
        return self.status in ["completed", "failed", "cancelled"]


class QueueStats(BaseSchema):
    """
    Comprehensive queue statistics.

    Provides historical and current performance metrics for the
    notification queue system.
    """

    # Current state
    current_queue_size: int = Field(
        ...,
        ge=0,
        description="Current number of queued notifications",
    )
    oldest_queued_age_minutes: Optional[int] = Field(
        None,
        ge=0,
        description="Age of oldest notification in queue",
    )

    # Today's statistics
    today_processed: int = Field(
        ...,
        ge=0,
        description="Notifications processed today",
    )
    today_successful: int = Field(
        ...,
        ge=0,
        description="Successful notifications today",
    )
    today_failed: int = Field(
        ...,
        ge=0,
        description="Failed notifications today",
    )

    # Success/failure rates
    success_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall success rate percentage",
    )
    failure_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall failure rate percentage",
    )

    # Performance metrics
    average_queue_time_minutes: Decimal = Field(
        ...,
        ge=0,
        description="Average time notifications spend in queue",
    )
    average_processing_time_seconds: Decimal = Field(
        ...,
        ge=0,
        description="Average processing time per notification",
    )
    average_total_time_seconds: Decimal = Field(
        ...,
        ge=0,
        description="Average total time from queue to delivery",
    )

    # Throughput
    current_throughput_per_minute: Decimal = Field(
        ...,
        ge=0,
        description="Current processing throughput",
    )
    peak_throughput_per_minute: Decimal = Field(
        ...,
        ge=0,
        description="Peak throughput achieved today",
    )
    average_throughput_per_minute: Decimal = Field(
        ...,
        ge=0,
        description="Average throughput",
    )

    # By type breakdown
    email_processed_today: int = Field(default=0, ge=0)
    sms_processed_today: int = Field(default=0, ge=0)
    push_processed_today: int = Field(default=0, ge=0)

    # By priority breakdown
    urgent_processed_today: int = Field(default=0, ge=0)
    high_processed_today: int = Field(default=0, ge=0)
    medium_processed_today: int = Field(default=0, ge=0)
    low_processed_today: int = Field(default=0, ge=0)

    # Retry statistics
    total_retries_today: int = Field(
        default=0,
        ge=0,
        description="Total retry attempts today",
    )
    retry_success_rate: Decimal = Field(
        default=Decimal("0"),
        ge=0,
        le=100,
        description="Percentage of retries that succeeded",
    )

    # Worker health
    active_workers: int = Field(
        ...,
        ge=0,
        description="Number of active queue workers",
    )
    idle_workers: int = Field(
        ...,
        ge=0,
        description="Number of idle workers",
    )

    # Timestamp
    stats_generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When statistics were generated",
    )

    @computed_field
    @property
    def total_workers(self) -> int:
        """Calculate total number of workers."""
        return self.active_workers + self.idle_workers

    @computed_field
    @property
    def worker_utilization_percent(self) -> float:
        """Calculate worker utilization percentage."""
        if self.total_workers == 0:
            return 0.0
        return round((self.active_workers / self.total_workers) * 100, 2)


class QueueHealth(BaseSchema):
    """
    Queue health monitoring and diagnostics.

    Provides health status and alerts for queue system monitoring.
    """

    # Overall health
    is_healthy: bool = Field(
        ...,
        description="Overall queue health status",
    )
    health_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Health score (0-100)",
    )

    # Component health
    queue_healthy: bool = Field(
        ...,
        description="Queue is processing normally",
    )
    workers_healthy: bool = Field(
        ...,
        description="Workers are functioning properly",
    )
    database_healthy: bool = Field(
        ...,
        description="Database connection is healthy",
    )
    external_services_healthy: bool = Field(
        ...,
        description="External notification services are reachable",
    )

    # Issues and alerts
    active_issues: List[str] = Field(
        default_factory=list,
        description="List of active issues",
    )
    warnings: List[str] = Field(
        default_factory=list,
        description="List of warnings",
    )

    # Performance indicators
    queue_backlog_minutes: int = Field(
        ...,
        ge=0,
        description="Estimated backlog in minutes",
    )
    is_overloaded: bool = Field(
        ...,
        description="Whether queue is overloaded",
    )
    is_underutilized: bool = Field(
        ...,
        description="Whether queue has excess capacity",
    )

    # Resource usage
    memory_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Memory usage percentage",
    )
    cpu_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="CPU usage percentage",
    )

    # Recommendations
    recommendations: List[str] = Field(
        default_factory=list,
        description="Recommended actions",
    )

    # Timestamp
    checked_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When health check was performed",
    )

    @computed_field
    @property
    def has_critical_issues(self) -> bool:
        """Check if there are any critical issues."""
        return len(self.active_issues) > 0

    @computed_field
    @property
    def needs_attention(self) -> bool:
        """Check if queue needs administrator attention."""
        return not self.is_healthy or self.has_critical_issues


class QueuePriority(BaseSchema):
    """
    Queue priority configuration and status.

    Manages priority-based queue processing rules.
    """

    priority_level: Priority = Field(
        ...,
        description="Priority level",
    )

    # Processing rules
    processing_weight: int = Field(
        ...,
        ge=1,
        le=100,
        description="Relative processing weight (higher = more priority)",
    )
    max_concurrent: int = Field(
        ...,
        ge=1,
        description="Maximum concurrent processing for this priority",
    )

    # Current state
    queued_count: int = Field(
        ...,
        ge=0,
        description="Currently queued notifications",
    )
    processing_count: int = Field(
        ...,
        ge=0,
        description="Currently processing notifications",
    )

    # Performance
    average_wait_time_seconds: Decimal = Field(
        ...,
        ge=0,
        description="Average wait time for this priority",
    )
    throughput_per_minute: Decimal = Field(
        ...,
        ge=0,
        description="Processing throughput for this priority",
    )

    # SLA
    target_processing_time_seconds: int = Field(
        ...,
        ge=1,
        description="Target processing time SLA",
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage meeting SLA",
    )

    @computed_field
    @property
    def is_meeting_sla(self) -> bool:
        """Check if priority level is meeting SLA targets."""
        return self.sla_compliance_rate >= 95.0  # 95% threshold

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\notification\notification_response.py ---
# --- File: app/schemas/notification/notification_response.py ---
"""
Notification response schemas.

This module provides response models for notification queries, lists,
and detailed information returned by the API.
"""

from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import NotificationStatus, NotificationType, Priority

__all__ = [
    "NotificationResponse",
    "NotificationDetail",
    "NotificationList",
    "NotificationListItem",
    "UnreadCount",
    "NotificationSummary",
]


class NotificationResponse(BaseResponseSchema):
    """
    Standard notification response.

    Used for single notification queries and list items.
    """

    # Recipient information
    recipient_user_id: Optional[UUID] = Field(
        None,
        description="Recipient user ID",
    )
    recipient_email: Optional[str] = Field(
        None,
        description="Recipient email address",
    )
    recipient_phone: Optional[str] = Field(
        None,
        description="Recipient phone number",
    )

    # Notification details
    notification_type: NotificationType = Field(
        ...,
        description="Notification delivery channel",
    )
    subject: Optional[str] = Field(
        None,
        description="Notification subject/title",
    )
    message_body: str = Field(
        ...,
        description="Notification message content",
    )

    # Status and priority
    priority: Priority = Field(
        ...,
        description="Notification priority level",
    )
    status: NotificationStatus = Field(
        ...,
        description="Current notification status",
    )

    # Timing
    scheduled_at: Optional[datetime] = Field(
        None,
        description="Scheduled delivery time",
    )
    sent_at: Optional[datetime] = Field(
        None,
        description="Actual send time",
    )
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )

    @computed_field
    @property
    def is_sent(self) -> bool:
        """Check if notification has been sent."""
        return self.status in [
            NotificationStatus.SENT,
            NotificationStatus.COMPLETED,
        ]

    @computed_field
    @property
    def is_pending(self) -> bool:
        """Check if notification is pending delivery."""
        return self.status in [
            NotificationStatus.QUEUED,
            NotificationStatus.PROCESSING,
        ]


class NotificationDetail(BaseResponseSchema):
    """
    Detailed notification information.

    Includes extended fields for comprehensive notification data,
    delivery tracking, and metadata.
    """

    # Recipient information
    recipient_user_id: Optional[UUID] = Field(
        None,
        description="Recipient user ID",
    )
    recipient_email: Optional[str] = Field(
        None,
        description="Recipient email address",
    )
    recipient_phone: Optional[str] = Field(
        None,
        description="Recipient phone number",
    )

    # Template and content
    notification_type: NotificationType = Field(
        ...,
        description="Notification delivery channel",
    )
    template_code: Optional[str] = Field(
        None,
        description="Template code used",
    )
    subject: Optional[str] = Field(
        None,
        description="Notification subject/title",
    )
    message_body: str = Field(
        ...,
        description="Notification message content",
    )

    # Status and priority
    priority: Priority = Field(
        ...,
        description="Notification priority level",
    )
    status: NotificationStatus = Field(
        ...,
        description="Current notification status",
    )

    # Scheduling and delivery
    scheduled_at: Optional[datetime] = Field(
        None,
        description="Scheduled delivery time",
    )
    sent_at: Optional[datetime] = Field(
        None,
        description="Actual send time",
    )
    delivered_at: Optional[datetime] = Field(
        None,
        description="Delivery confirmation time",
    )
    failed_at: Optional[datetime] = Field(
        None,
        description="Failure timestamp",
    )

    # Retry and error handling
    failure_reason: Optional[str] = Field(
        None,
        max_length=1000,
        description="Reason for delivery failure",
    )
    retry_count: int = Field(
        default=0,
        ge=0,
        description="Number of retry attempts",
    )
    max_retries: int = Field(
        default=3,
        ge=0,
        description="Maximum allowed retries",
    )

    # Engagement tracking
    read_at: Optional[datetime] = Field(
        None,
        description="When the notification was read",
    )
    clicked_at: Optional[datetime] = Field(
        None,
        description="When any link in the notification was clicked",
    )

    # Metadata and context
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional notification metadata",
    )

    # Related entities
    hostel_id: Optional[UUID] = Field(
        None,
        description="Associated hostel ID",
    )

    # Audit timestamps
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )
    updated_at: datetime = Field(
        ...,
        description="Last update timestamp",
    )

    @computed_field
    @property
    def is_read(self) -> bool:
        """Check if notification has been read."""
        return self.read_at is not None

    @computed_field
    @property
    def can_retry(self) -> bool:
        """Check if notification can be retried."""
        return (
            self.status == NotificationStatus.FAILED
            and self.retry_count < self.max_retries
        )

    @computed_field
    @property
    def delivery_duration_seconds(self) -> Optional[int]:
        """Calculate delivery duration in seconds."""
        if self.sent_at and self.delivered_at:
            return int((self.delivered_at - self.sent_at).total_seconds())
        return None


class NotificationListItem(BaseSchema):
    """
    Compact notification item for list views.

    Optimized for performance with minimal data for displaying
    notification lists efficiently.
    """

    id: UUID = Field(
        ...,
        description="Notification ID",
    )
    notification_type: NotificationType = Field(
        ...,
        description="Notification channel",
    )

    # Content preview
    subject: Optional[str] = Field(
        None,
        description="Notification subject",
    )
    message_preview: str = Field(
        ...,
        max_length=150,
        description="Message preview (first 150 characters)",
    )

    # Status
    priority: Priority = Field(
        ...,
        description="Priority level",
    )
    status: NotificationStatus = Field(
        ...,
        description="Current status",
    )

    # Read status
    is_read: bool = Field(
        default=False,
        description="Whether notification has been read",
    )
    read_at: Optional[datetime] = Field(
        None,
        description="When notification was read",
    )

    # Timing
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )

    # Actions and UI
    action_url: Optional[str] = Field(
        None,
        max_length=500,
        description="URL to navigate to when notification is clicked",
    )
    icon: Optional[str] = Field(
        None,
        max_length=50,
        description="Icon identifier for UI rendering",
    )
    category: Optional[str] = Field(
        None,
        max_length=50,
        description="Notification category for grouping",
    )

    @computed_field
    @property
    def is_urgent(self) -> bool:
        """Check if notification is urgent."""
        return self.priority in [Priority.URGENT, Priority.CRITICAL]


class NotificationList(BaseSchema):
    """
    Paginated list of notifications for a user.

    Includes summary statistics and list items.
    """

    user_id: UUID = Field(
        ...,
        description="User ID for this notification list",
    )
    total_notifications: int = Field(
        ...,
        ge=0,
        description="Total number of notifications",
    )
    unread_count: int = Field(
        ...,
        ge=0,
        description="Number of unread notifications",
    )
    notifications: List[NotificationListItem] = Field(
        ...,
        description="List of notification items",
    )

    @computed_field
    @property
    def read_count(self) -> int:
        """Calculate number of read notifications."""
        return self.total_notifications - self.unread_count

    @computed_field
    @property
    def has_unread(self) -> bool:
        """Check if there are any unread notifications."""
        return self.unread_count > 0


class UnreadCount(BaseSchema):
    """
    Unread notification count breakdown.

    Provides granular unread counts by type and priority.
    """

    user_id: UUID = Field(
        ...,
        description="User ID",
    )

    # Total unread
    total_unread: int = Field(
        ...,
        ge=0,
        description="Total unread notifications",
    )

    # By notification type
    email_unread: int = Field(
        default=0,
        ge=0,
        description="Unread email notifications",
    )
    sms_unread: int = Field(
        default=0,
        ge=0,
        description="Unread SMS notifications",
    )
    push_unread: int = Field(
        default=0,
        ge=0,
        description="Unread push notifications",
    )
    in_app_unread: int = Field(
        default=0,
        ge=0,
        description="Unread in-app notifications",
    )

    # By priority
    urgent_unread: int = Field(
        default=0,
        ge=0,
        description="Unread urgent/critical notifications",
    )
    high_unread: int = Field(
        default=0,
        ge=0,
        description="Unread high priority notifications",
    )

    # Timestamp
    last_checked_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When counts were last calculated",
    )


class NotificationSummary(BaseSchema):
    """
    Comprehensive notification summary for a user.

    Provides aggregate statistics and insights.
    """

    user_id: UUID = Field(
        ...,
        description="User ID",
    )

    # Overall counts
    total_notifications: int = Field(
        ...,
        ge=0,
        description="Total notifications received",
    )
    unread_notifications: int = Field(
        ...,
        ge=0,
        description="Unread notification count",
    )

    # Recent activity
    last_notification_at: Optional[datetime] = Field(
        None,
        description="Timestamp of most recent notification",
    )
    last_read_at: Optional[datetime] = Field(
        None,
        description="When user last read a notification",
    )

    # Breakdown by type
    notifications_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of notifications by type",
    )

    # Breakdown by status
    notifications_by_status: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of notifications by status",
    )

    # Breakdown by priority
    notifications_by_priority: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of notifications by priority",
    )

    # Summary period
    summary_period_days: int = Field(
        default=30,
        ge=1,
        le=365,
        description="Number of days included in summary",
    )

    @computed_field
    @property
    def read_percentage(self) -> float:
        """Calculate percentage of read notifications."""
        if self.total_notifications == 0:
            return 0.0
        read_count = self.total_notifications - self.unread_notifications
        return round((read_count / self.total_notifications) * 100, 2)

    @computed_field
    @property
    def has_recent_activity(self) -> bool:
        """Check if there's been activity in the last 24 hours."""
        if not self.last_notification_at:
            return False
        time_diff = datetime.utcnow() - self.last_notification_at
        return time_diff.total_seconds() < 86400  # 24 hours

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\notification\notification_routing.py ---
# --- File: app/schemas/notification/notification_routing.py ---
"""
Notification routing schemas.

This module provides schemas for routing notifications to appropriate
recipients with hierarchical escalation and rule-based routing.
"""

from __future__ import annotations

from datetime import datetime
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import Priority, UserRole

__all__ = [
    "RoutingConfig",
    "RoutingRule",
    "HierarchicalRouting",
    "EscalationRouting",
    "EscalationLevel",
    "NotificationRoute",
    "RoutingCondition",
]


class RoutingCondition(BaseSchema):
    """
    Condition for routing rule matching.

    Defines when a routing rule should be applied.
    """

    # Event matching
    event_type: Optional[str] = Field(
        None,
        max_length=100,
        description="Event type to match (e.g., 'complaint', 'payment')",
    )
    event_category: Optional[str] = Field(
        None,
        max_length=100,
        description="Event category",
    )

    # Priority matching
    priority: Optional[Priority] = Field(
        None,
        description="Priority level to match",
    )
    min_priority: Optional[Priority] = Field(
        None,
        description="Minimum priority level",
    )

    # Entity matching
    hostel_id: Optional[UUID] = Field(
        None,
        description="Specific hostel ID",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Specific room ID",
    )

    # Time-based
    time_of_day_start: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Start time for time-based routing (HH:MM)",
    )
    time_of_day_end: Optional[str] = Field(
        None,
        pattern=r"^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="End time for time-based routing (HH:MM)",
    )

    # Custom attributes
    custom_attributes: Dict[str, str] = Field(
        default_factory=dict,
        description="Custom attribute matching",
    )


class RoutingRule(BaseSchema):
    """
    Individual routing rule configuration.

    Defines how notifications should be routed based on conditions.
    """

    rule_id: Optional[UUID] = Field(
        None,
        description="Rule ID (auto-generated if not provided)",
    )
    rule_name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Human-readable rule name",
    )
    description: Optional[str] = Field(
        None,
        max_length=500,
        description="Rule description",
    )

    # Priority (for rule ordering)
    rule_priority: int = Field(
        default=0,
        ge=0,
        le=100,
        description="Rule priority (higher = evaluated first)",
    )

    # Conditions
    conditions: RoutingCondition = Field(
        default_factory=RoutingCondition,
        description="Conditions for this rule",
    )

    # Recipients
    recipient_roles: List[UserRole] = Field(
        default_factory=list,
        description="User roles to notify",
    )
    specific_users: List[UUID] = Field(
        default_factory=list,
        description="Specific user IDs to notify",
    )
    recipient_groups: List[str] = Field(
        default_factory=list,
        description="User groups to notify",
    )

    # Channels
    channels: List[str] = Field(
        ...,
        min_length=1,
        pattern_items="^(email|sms|push)$",
        description="Notification channels to use",
    )

    # Template
    template_code: Optional[str] = Field(
        None,
        description="Template to use for this rule",
    )

    # Settings
    is_active: bool = Field(
        default=True,
        description="Whether rule is active",
    )
    stop_on_match: bool = Field(
        default=False,
        description="Stop processing rules after this one matches",
    )

    @field_validator("channels")
    @classmethod
    def validate_channels(cls, v: List[str]) -> List[str]:
        """Validate and deduplicate channels."""
        valid_channels = ["email", "sms", "push"]
        for channel in v:
            if channel not in valid_channels:
                raise ValueError(f"Invalid channel: {channel}")
        return list(set(v))  # Remove duplicates

    @model_validator(mode="after")
    def validate_recipients(self) -> "RoutingRule":
        """Ensure at least one recipient is specified."""
        if not any([
            self.recipient_roles,
            self.specific_users,
            self.recipient_groups,
        ]):
            raise ValueError(
                "At least one recipient (roles, users, or groups) must be specified"
            )
        return self


class RoutingConfig(BaseSchema):
    """
    Complete routing configuration for a hostel.

    Defines all routing rules and escalation settings.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID for this routing config",
    )

    # Routing rules
    rules: List[RoutingRule] = Field(
        default_factory=list,
        description="List of routing rules (evaluated in order)",
    )

    # Default routing
    default_recipient_roles: List[UserRole] = Field(
        default_factory=lambda: [UserRole.HOSTEL_ADMIN],
        description="Default recipients if no rules match",
    )
    default_channels: List[str] = Field(
        default_factory=lambda: ["email"],
        description="Default notification channels",
    )

    # Escalation settings
    enable_escalation: bool = Field(
        default=True,
        description="Enable automatic escalation",
    )
    escalation_timeout_hours: int = Field(
        default=24,
        ge=1,
        le=168,  # 1 week max
        description="Hours before escalating unhandled notifications",
    )

    # Settings
    is_active: bool = Field(
        default=True,
        description="Whether routing config is active",
    )

    @field_validator("rules")
    @classmethod
    def sort_rules_by_priority(cls, v: List[RoutingRule]) -> List[RoutingRule]:
        """Sort rules by priority (highest first)."""
        return sorted(v, key=lambda r: r.rule_priority, reverse=True)


class EscalationLevel(BaseSchema):
    """
    Single level in an escalation chain.

    Defines recipients and timing for one escalation level.
    """

    level: int = Field(
        ...,
        ge=1,
        le=10,
        description="Escalation level (1 = first, higher = later)",
    )
    level_name: str = Field(
        ...,
        max_length=100,
        description="Level name (e.g., 'Supervisor', 'Admin', 'Manager')",
    )

    # Recipients
    recipients: List[UUID] = Field(
        ...,
        min_length=1,
        description="User IDs to notify at this level",
    )
    recipient_roles: List[UserRole] = Field(
        default_factory=list,
        description="User roles to notify at this level",
    )

    # Timing
    escalate_after_hours: int = Field(
        ...,
        ge=1,
        le=168,
        description="Hours to wait before escalating to this level",
    )

    # Channels
    channels: List[str] = Field(
        ...,
        min_length=1,
        description="Notification channels for this level",
    )

    # Template
    template_code: Optional[str] = Field(
        None,
        description="Template for escalation notification",
    )

    @field_validator("channels")
    @classmethod
    def validate_channels(cls, v: List[str]) -> List[str]:
        """Validate channels."""
        valid_channels = ["email", "sms", "push"]
        for channel in v:
            if channel not in valid_channels:
                raise ValueError(f"Invalid channel: {channel}")
        return list(set(v))


class HierarchicalRouting(BaseSchema):
    """
    Hierarchical notification routing configuration.

    Defines multi-level routing with fallback recipients.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    event_type: str = Field(
        ...,
        max_length=100,
        description="Event type this routing applies to",
    )

    # Routing hierarchy
    primary_recipients: List[UUID] = Field(
        ...,
        min_length=1,
        description="Primary recipients (e.g., supervisors)",
    )
    secondary_recipients: List[UUID] = Field(
        default_factory=list,
        description="Secondary recipients (e.g., admins)",
    )
    tertiary_recipients: List[UUID] = Field(
        default_factory=list,
        description="Tertiary recipients (e.g., super admin)",
    )

    # Escalation timing
    escalate_to_secondary_after_hours: int = Field(
        default=24,
        ge=1,
        le=168,
        description="Hours before escalating to secondary",
    )
    escalate_to_tertiary_after_hours: int = Field(
        default=48,
        ge=1,
        le=336,  # 2 weeks
        description="Hours before escalating to tertiary",
    )

    # Channels by level
    primary_channels: List[str] = Field(
        default_factory=lambda: ["email", "push"],
        description="Channels for primary recipients",
    )
    secondary_channels: List[str] = Field(
        default_factory=lambda: ["email", "sms", "push"],
        description="Channels for secondary recipients",
    )
    tertiary_channels: List[str] = Field(
        default_factory=lambda: ["email", "sms", "push"],
        description="Channels for tertiary recipients",
    )

    # Settings
    is_active: bool = Field(
        default=True,
        description="Whether routing is active",
    )


class EscalationRouting(BaseCreateSchema):
    """
    Escalation routing for a specific notification.

    Defines the escalation path and current state.
    """

    notification_id: UUID = Field(
        ...,
        description="Notification ID",
    )

    # Escalation chain
    escalation_chain: List[EscalationLevel] = Field(
        ...,
        min_length=1,
        description="Escalation levels in order",
    )

    # Current state
    current_level: int = Field(
        default=0,
        ge=0,
        description="Current escalation level (0 = not escalated)",
    )
    last_escalated_at: Optional[datetime] = Field(
        None,
        description="When last escalation occurred",
    )

    # Settings
    auto_escalate: bool = Field(
        default=True,
        description="Automatically escalate based on timing",
    )
    is_resolved: bool = Field(
        default=False,
        description="Whether notification has been resolved",
    )

    @field_validator("escalation_chain")
    @classmethod
    def validate_escalation_levels(
        cls,
        v: List[EscalationLevel],
    ) -> List[EscalationLevel]:
        """Validate escalation levels are sequential and sorted."""
        if not v:
            raise ValueError("At least one escalation level required")

        # Check levels are sequential
        levels = [level.level for level in v]
        if levels != list(range(1, len(levels) + 1)):
            raise ValueError("Escalation levels must be sequential starting from 1")

        # Sort by level
        return sorted(v, key=lambda x: x.level)

    @field_validator("escalation_chain")
    @classmethod
    def validate_escalation_timing(
        cls,
        v: List[EscalationLevel],
    ) -> List[EscalationLevel]:
        """Validate escalation timing is increasing."""
        hours = [level.escalate_after_hours for level in v]
        if hours != sorted(hours):
            raise ValueError(
                "Escalation hours must increase with each level"
            )
        return v


class NotificationRoute(BaseSchema):
    """
    Determined notification route.

    Represents the final routing decision for a notification.
    """

    notification_id: UUID = Field(
        ...,
        description="Notification ID",
    )

    # Matched rule
    matched_rule_id: Optional[UUID] = Field(
        None,
        description="ID of routing rule that matched",
    )
    matched_rule_name: Optional[str] = Field(
        None,
        description="Name of matched routing rule",
    )

    # Recipients
    primary_recipients: List[UUID] = Field(
        ...,
        min_length=1,
        description="Primary notification recipients",
    )
    cc_recipients: List[UUID] = Field(
        default_factory=list,
        description="CC recipients",
    )

    # Channels by recipient
    recipient_channels: Dict[UUID, List[str]] = Field(
        default_factory=dict,
        description="Notification channels for each recipient",
    )

    # Template
    template_code: Optional[str] = Field(
        None,
        description="Template to use",
    )

    # Escalation
    escalation_enabled: bool = Field(
        default=False,
        description="Whether escalation is enabled",
    )
    escalation_path: Optional[List[EscalationLevel]] = Field(
        None,
        description="Escalation levels if enabled",
    )

    # Metadata
    routing_metadata: Dict[str, str] = Field(
        default_factory=dict,
        description="Additional routing metadata",
    )

    # Timing
    routed_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When routing was determined",
    )

    @field_validator("recipient_channels")
    @classmethod
    def validate_recipient_channels(
        cls,
        v: Dict[UUID, List[str]],
    ) -> Dict[UUID, List[str]]:
        """Validate channels for each recipient."""
        valid_channels = {"email", "sms", "push"}
        for user_id, channels in v.items():
            for channel in channels:
                if channel not in valid_channels:
                    raise ValueError(
                        f"Invalid channel '{channel}' for user {user_id}"
                    )
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\notification\notification_template.py ---
# --- File: app/schemas/notification/notification_template.py ---
"""
Notification template schemas.

This module provides schemas for managing reusable notification templates
with variable substitution and template rendering.
"""

from __future__ import annotations

from datetime import datetime
from typing import Dict, List, Optional, Set
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import NotificationType

__all__ = [
    "TemplateCreate",
    "TemplateUpdate",
    "TemplateResponse",
    "VariableMapping",
    "TemplatePreview",
    "TemplatePreviewResponse",
    "TemplateList",
    "TemplateCategory",
    "TemplateCopyRequest",
]


class TemplateCreate(BaseCreateSchema):
    """
    Schema for creating a notification template.

    Templates support variable substitution using {{variable_name}} syntax.
    """

    template_code: str = Field(
        ...,
        min_length=3,
        max_length=100,
        pattern="^[a-z0-9_]+$",
        description="Unique template code (lowercase, numbers, underscores only)",
    )
    template_name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Human-readable template name",
    )

    # Template type
    template_type: NotificationType = Field(
        ...,
        description="Notification channel this template is for",
    )

    # Content with variable support
    subject: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Subject template (required for email/push, supports {{variables}})",
    )
    body_template: str = Field(
        ...,
        min_length=1,
        max_length=10000,
        description="Body template with {{variable}} placeholders",
    )

    # Variables
    variables: List[str] = Field(
        default_factory=list,
        description="List of required template variables",
    )
    optional_variables: List[str] = Field(
        default_factory=list,
        description="List of optional template variables",
    )

    # Metadata
    category: Optional[str] = Field(
        None,
        max_length=100,
        description="Template category for organization",
    )
    tags: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Tags for template discovery",
    )

    # Settings
    is_active: bool = Field(
        default=True,
        description="Whether template is active and available for use",
    )
    description: Optional[str] = Field(
        None,
        max_length=500,
        description="Template description and usage notes",
    )

    # Localization
    language: str = Field(
        default="en",
        min_length=2,
        max_length=5,
        description="Template language code (e.g., 'en', 'hi')",
    )

    @field_validator("template_code")
    @classmethod
    def validate_template_code(cls, v: str) -> str:
        """Ensure template code follows naming conventions."""
        if not v.islower():
            raise ValueError("Template code must be lowercase")
        if "__" in v:
            raise ValueError("Template code cannot contain consecutive underscores")
        if v.startswith("_") or v.endswith("_"):
            raise ValueError("Template code cannot start or end with underscore")
        return v

    @field_validator("variables", "optional_variables")
    @classmethod
    def validate_variable_names(cls, v: List[str]) -> List[str]:
        """Validate variable names are valid identifiers."""
        for var in v:
            if not var.replace("_", "").isalnum():
                raise ValueError(
                    f"Invalid variable name '{var}'. Must contain only letters, numbers, and underscores"
                )
            if var.startswith("_"):
                raise ValueError(f"Variable name '{var}' cannot start with underscore")
        return v

    @field_validator("tags")
    @classmethod
    def validate_tags(cls, v: List[str]) -> List[str]:
        """Validate and normalize tags."""
        # Remove duplicates and normalize
        normalized = list(set(tag.lower().strip() for tag in v if tag.strip()))
        if len(normalized) > 20:
            raise ValueError("Maximum 20 tags allowed")
        return normalized

    @model_validator(mode="after")
    def validate_subject_for_type(self) -> "TemplateCreate":
        """Ensure subject is provided for email and push templates."""
        if self.template_type in [NotificationType.EMAIL, NotificationType.PUSH]:
            if not self.subject:
                raise ValueError(
                    f"Subject is required for {self.template_type.value} templates"
                )
        return self

    @model_validator(mode="after")
    def validate_variables_in_template(self) -> "TemplateCreate":
        """Validate that declared variables exist in templates."""
        import re

        # Extract variables from templates
        variable_pattern = r"\{\{(\w+)\}\}"
        subject_vars = set(re.findall(variable_pattern, self.subject or ""))
        body_vars = set(re.findall(variable_pattern, self.body_template))
        all_template_vars = subject_vars | body_vars

        # Check declared variables
        declared_vars = set(self.variables + self.optional_variables)

        # Undeclared variables
        undeclared = all_template_vars - declared_vars
        if undeclared:
            raise ValueError(
                f"Template contains undeclared variables: {', '.join(undeclared)}"
            )

        # Unused variables (warning-level, but we'll allow it)
        # unused = declared_vars - all_template_vars

        return self


class TemplateUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing template.

    Template code cannot be changed after creation.
    """

    template_name: Optional[str] = Field(
        None,
        min_length=3,
        max_length=255,
        description="Updated template name",
    )
    subject: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Updated subject template",
    )
    body_template: Optional[str] = Field(
        None,
        min_length=1,
        max_length=10000,
        description="Updated body template",
    )
    variables: Optional[List[str]] = Field(
        None,
        description="Updated required variables list",
    )
    optional_variables: Optional[List[str]] = Field(
        None,
        description="Updated optional variables list",
    )
    category: Optional[str] = Field(
        None,
        max_length=100,
        description="Updated category",
    )
    tags: Optional[List[str]] = Field(
        None,
        description="Updated tags",
    )
    is_active: Optional[bool] = Field(
        None,
        description="Updated active status",
    )
    description: Optional[str] = Field(
        None,
        max_length=500,
        description="Updated description",
    )


class TemplateResponse(BaseResponseSchema):
    """
    Template response schema.

    Includes template details and usage statistics.
    """

    template_code: str = Field(
        ...,
        description="Unique template identifier",
    )
    template_name: str = Field(
        ...,
        description="Template name",
    )
    template_type: NotificationType = Field(
        ...,
        description="Notification channel",
    )

    # Content
    subject: Optional[str] = Field(
        None,
        description="Subject template",
    )
    body_template: str = Field(
        ...,
        description="Body template",
    )

    # Variables
    variables: List[str] = Field(
        ...,
        description="Required variables",
    )
    optional_variables: List[str] = Field(
        default_factory=list,
        description="Optional variables",
    )

    # Metadata
    category: Optional[str] = Field(
        None,
        description="Template category",
    )
    tags: List[str] = Field(
        default_factory=list,
        description="Template tags",
    )
    language: str = Field(
        ...,
        description="Template language",
    )

    # Status
    is_active: bool = Field(
        ...,
        description="Active status",
    )
    description: Optional[str] = Field(
        None,
        description="Template description",
    )

    # Usage statistics
    usage_count: int = Field(
        default=0,
        ge=0,
        description="Number of times template has been used",
    )
    last_used_at: Optional[datetime] = Field(
        None,
        description="When template was last used",
    )

    # Audit
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )
    updated_at: datetime = Field(
        ...,
        description="Last update timestamp",
    )
    created_by: Optional[UUID] = Field(
        None,
        description="User who created the template",
    )


class VariableMapping(BaseSchema):
    """
    Variable mapping for template rendering.

    Maps template variable names to their runtime values.
    """

    template_code: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Template code to render",
    )
    variables: Dict[str, str] = Field(
        ...,
        description="Variable name to value mapping",
    )

    @field_validator("variables")
    @classmethod
    def validate_variable_values(cls, v: Dict[str, str]) -> Dict[str, str]:
        """Validate variable values are non-empty strings."""
        for key, value in v.items():
            if not isinstance(value, str):
                raise ValueError(f"Variable '{key}' must be a string value")
            if not value.strip():
                raise ValueError(f"Variable '{key}' cannot be empty")
        return v


class TemplatePreview(BaseCreateSchema):
    """
    Request schema for previewing a rendered template.

    Useful for testing templates before deployment.
    """

    template_code: str = Field(
        ...,
        description="Template code to preview",
    )
    variables: Dict[str, str] = Field(
        ...,
        description="Variable values for rendering",
    )
    use_defaults: bool = Field(
        default=False,
        description="Use default values for missing optional variables",
    )


class TemplatePreviewResponse(BaseSchema):
    """
    Rendered template preview response.

    Shows the final rendered content and validation results.
    """

    template_code: str = Field(
        ...,
        description="Template code",
    )
    subject: Optional[str] = Field(
        None,
        description="Rendered subject",
    )
    rendered_body: str = Field(
        ...,
        description="Rendered message body",
    )

    # Validation results
    all_variables_provided: bool = Field(
        ...,
        description="Whether all required variables were provided",
    )
    missing_variables: List[str] = Field(
        default_factory=list,
        description="List of missing required variables",
    )
    unused_variables: List[str] = Field(
        default_factory=list,
        description="Provided variables not used in template",
    )

    # Character counts (useful for SMS)
    subject_length: Optional[int] = Field(
        None,
        description="Length of rendered subject",
    )
    body_length: int = Field(
        ...,
        description="Length of rendered body",
    )
    estimated_sms_segments: Optional[int] = Field(
        None,
        description="Estimated SMS segments (if applicable)",
    )


class TemplateList(BaseSchema):
    """
    List of templates with summary statistics.
    """

    total_templates: int = Field(
        ...,
        ge=0,
        description="Total number of templates",
    )
    active_templates: int = Field(
        ...,
        ge=0,
        description="Number of active templates",
    )
    templates_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Template count by notification type",
    )
    templates: List[TemplateResponse] = Field(
        ...,
        description="List of templates",
    )


class TemplateCategory(BaseSchema):
    """
    Templates grouped by category.

    Useful for organizing templates in UI.
    """

    category_name: str = Field(
        ...,
        description="Category name",
    )
    category_description: Optional[str] = Field(
        None,
        description="Category description",
    )
    template_count: int = Field(
        ...,
        ge=0,
        description="Number of templates in category",
    )
    templates: List[TemplateResponse] = Field(
        ...,
        description="Templates in this category",
    )


class TemplateCopyRequest(BaseCreateSchema):
    """
    Request to copy an existing template.

    Creates a new template based on an existing one.
    """

    source_template_code: str = Field(
        ...,
        description="Template code to copy from",
    )
    new_template_code: str = Field(
        ...,
        min_length=3,
        max_length=100,
        pattern="^[a-z0-9_]+$",
        description="New template code",
    )
    new_template_name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="New template name",
    )
    copy_metadata: bool = Field(
        default=True,
        description="Copy category, tags, and description",
    )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\notification\push_notification.py ---
# --- File: app/schemas/notification/push_notification.py ---
"""
Push notification schemas.

This module provides schemas for push notification delivery across
mobile platforms (iOS, Android) and web with device management.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import DeviceType

__all__ = [
    "PushRequest",
    "PushConfig",
    "DeviceToken",
    "DeviceRegistration",
    "DeviceUnregistration",
    "PushTemplate",
    "PushDeliveryStatus",
    "PushStats",
    "BulkPushRequest",
]


class PushRequest(BaseCreateSchema):
    """
    Send push notification request.

    Supports targeted delivery to specific users/devices with rich
    content including images, actions, and custom data.
    """

    # Recipients (at least one required)
    user_id: Optional[UUID] = Field(
        None,
        description="Send to all active devices of this user",
    )
    device_token: Optional[str] = Field(
        None,
        min_length=10,
        max_length=500,
        description="Send to specific device token",
    )
    device_tokens: Optional[List[str]] = Field(
        None,
        max_length=1000,
        description="Send to multiple specific devices (max 1000)",
    )
    segment: Optional[str] = Field(
        None,
        max_length=100,
        description="Send to user segment",
    )

    # Content
    title: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Notification title",
    )
    body: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Notification body text",
    )

    # Rich content
    image_url: Optional[str] = Field(
        None,
        max_length=500,
        description="Large image URL for rich notification",
    )
    icon: Optional[str] = Field(
        None,
        max_length=100,
        description="Small icon identifier",
    )

    # Custom data payload
    data: Dict[str, Any] = Field(
        default_factory=dict,
        description="Custom data payload (sent to app)",
    )

    # Actions
    action_url: Optional[str] = Field(
        None,
        max_length=500,
        description="Deep link or URL to open on tap",
    )
    actions: List["PushAction"] = Field(
        default_factory=list,
        max_length=3,
        description="Action buttons (max 3)",
    )

    # Badge (iOS)
    badge_count: Optional[int] = Field(
        None,
        ge=0,
        le=99999,
        description="Badge count for app icon",
    )
    badge_strategy: Optional[str] = Field(
        None,
        pattern="^(set|increment|decrement)$",
        description="How to update badge count",
    )

    # Sound
    sound: str = Field(
        default="default",
        max_length=100,
        description="Notification sound (default or custom)",
    )
    sound_volume: Optional[float] = Field(
        None,
        ge=0.0,
        le=1.0,
        description="Sound volume (0.0 to 1.0)",
    )

    # Priority and delivery
    priority: str = Field(
        default="normal",
        pattern="^(low|normal|high)$",
        description="Notification priority",
    )
    ttl: int = Field(
        default=86400,  # 24 hours
        ge=0,
        le=2419200,  # 28 days max
        description="Time to live in seconds",
    )

    # Collapse/grouping
    collapse_key: Optional[str] = Field(
        None,
        max_length=100,
        description="Collapse key for grouping notifications",
    )
    thread_id: Optional[str] = Field(
        None,
        max_length=100,
        description="Thread ID for notification grouping",
    )

    # Platform-specific
    android_channel_id: Optional[str] = Field(
        None,
        max_length=100,
        description="Android notification channel ID",
    )
    ios_category: Optional[str] = Field(
        None,
        max_length=100,
        description="iOS notification category",
    )

    # Scheduling
    send_at: Optional[datetime] = Field(
        None,
        description="Schedule for future delivery",
    )

    # Metadata
    tags: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Tags for categorization",
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Custom metadata",
    )

    @model_validator(mode="after")
    def validate_recipients(self) -> "PushRequest":
        """Ensure at least one recipient target is provided."""
        if not any([self.user_id, self.device_token, self.device_tokens, self.segment]):
            raise ValueError(
                "At least one recipient (user_id, device_token, device_tokens, or segment) required"
            )
        
        # Ensure only one targeting method is used
        targets = sum([
            bool(self.user_id),
            bool(self.device_token),
            bool(self.device_tokens),
            bool(self.segment),
        ])
        if targets > 1:
            raise ValueError(
                "Only one targeting method allowed (user_id, device_token, device_tokens, or segment)"
            )
        
        return self

    @field_validator("data")
    @classmethod
    def validate_data_size(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        """Validate data payload size."""
        import json
        if len(json.dumps(v)) > 4096:  # 4KB limit
            raise ValueError("Data payload cannot exceed 4KB")
        return v

    @field_validator("send_at")
    @classmethod
    def validate_send_time(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate scheduled send time is in the future."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Scheduled send time must be in the future")
        return v


class PushAction(BaseSchema):
    """
    Push notification action button.

    Allows users to take quick actions from notification.
    """

    action_id: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Unique action identifier",
    )
    title: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Action button text",
    )
    action_url: Optional[str] = Field(
        None,
        max_length=500,
        description="URL to open when action is tapped",
    )
    icon: Optional[str] = Field(
        None,
        max_length=50,
        description="Action icon identifier",
    )


class PushConfig(BaseSchema):
    """
    Push notification service configuration.

    Supports Firebase Cloud Messaging (FCM) and Apple Push Notification
    Service (APNs) with unified configuration.
    """

    # Firebase (Android + Web)
    firebase_project_id: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Firebase project ID",
    )
    firebase_server_key: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Firebase server key / FCM API key",
    )
    firebase_service_account_json: Optional[str] = Field(
        None,
        description="Firebase service account JSON (for v1 API)",
    )

    # APNs (iOS)
    apns_enabled: bool = Field(
        default=False,
        description="Enable APNs for iOS",
    )
    apns_key_id: Optional[str] = Field(
        None,
        max_length=100,
        description="APNs key ID",
    )
    apns_team_id: Optional[str] = Field(
        None,
        max_length=100,
        description="Apple team ID",
    )
    apns_bundle_id: Optional[str] = Field(
        None,
        max_length=255,
        description="iOS app bundle ID",
    )
    apns_key_path: Optional[str] = Field(
        None,
        max_length=500,
        description="Path to APNs .p8 key file",
    )
    apns_production: bool = Field(
        default=False,
        description="Use production APNs (vs sandbox)",
    )

    # Default settings
    default_sound: str = Field(
        default="default",
        description="Default notification sound",
    )
    default_priority: str = Field(
        default="normal",
        pattern="^(low|normal|high)$",
        description="Default priority",
    )
    default_ttl: int = Field(
        default=86400,
        ge=0,
        description="Default TTL in seconds",
    )

    # Collapse key
    collapse_key: Optional[str] = Field(
        None,
        description="Default collapse key for grouping",
    )

    # Badge management
    auto_increment_badge: bool = Field(
        default=True,
        description="Auto-increment badge count",
    )

    # Rate limiting
    max_notifications_per_hour: int = Field(
        default=1000,
        ge=1,
        description="Max push notifications per hour",
    )

    @model_validator(mode="after")
    def validate_apns_config(self) -> "PushConfig":
        """Validate APNs configuration if enabled."""
        if self.apns_enabled:
            required_fields = [
                self.apns_key_id,
                self.apns_team_id,
                self.apns_bundle_id,
                self.apns_key_path,
            ]
            if not all(required_fields):
                raise ValueError(
                    "APNs requires key_id, team_id, bundle_id, and key_path"
                )
        return self


class DeviceToken(BaseResponseSchema):
    """
    Registered device token for push notifications.

    Tracks device information and token lifecycle.
    """

    user_id: UUID = Field(
        ...,
        description="User who owns this device",
    )
    device_token: str = Field(
        ...,
        description="Device push token",
    )
    device_type: DeviceType = Field(
        ...,
        description="Device platform",
    )

    # Device details
    device_name: Optional[str] = Field(
        None,
        max_length=100,
        description="User-set device name",
    )
    device_model: Optional[str] = Field(
        None,
        max_length=100,
        description="Device model",
    )
    os_version: Optional[str] = Field(
        None,
        max_length=50,
        description="OS version",
    )
    app_version: Optional[str] = Field(
        None,
        max_length=50,
        description="App version",
    )

    # Location and timezone
    timezone: Optional[str] = Field(
        None,
        max_length=100,
        description="Device timezone",
    )
    locale: Optional[str] = Field(
        None,
        max_length=10,
        description="Device locale (e.g., en_US)",
    )

    # Status
    is_active: bool = Field(
        ...,
        description="Whether device token is active",
    )
    last_used_at: datetime = Field(
        ...,
        description="When device was last active",
    )
    registered_at: datetime = Field(
        ...,
        description="When device was registered",
    )

    # Badge count
    current_badge_count: int = Field(
        default=0,
        ge=0,
        description="Current badge count for this device",
    )


class DeviceRegistration(BaseCreateSchema):
    """
    Register a device for push notifications.

    Associates a device token with a user account.
    """

    user_id: UUID = Field(
        ...,
        description="User ID to register device for",
    )
    device_token: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Device push notification token",
    )
    device_type: DeviceType = Field(
        ...,
        description="Device platform type",
    )

    # Optional device details
    device_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Device name",
    )
    device_model: Optional[str] = Field(
        None,
        max_length=100,
        description="Device model",
    )
    os_version: Optional[str] = Field(
        None,
        max_length=50,
        description="Operating system version",
    )
    app_version: Optional[str] = Field(
        None,
        max_length=50,
        description="Application version",
    )

    # Timezone
    timezone: Optional[str] = Field(
        None,
        max_length=100,
        description="Device timezone",
    )
    locale: Optional[str] = Field(
        None,
        max_length=10,
        description="Device locale",
    )


class DeviceUnregistration(BaseCreateSchema):
    """
    Unregister a device from push notifications.

    Removes device token to stop receiving notifications.
    """

    device_token: str = Field(
        ...,
        description="Device token to unregister",
    )
    user_id: Optional[UUID] = Field(
        None,
        description="User ID (for verification)",
    )
    reason: Optional[str] = Field(
        None,
        max_length=200,
        description="Reason for unregistration",
    )


class PushTemplate(BaseSchema):
    """
    Push notification template.

    Defines reusable push notification structures with variables.
    """

    template_code: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Unique template identifier",
    )

    # Content templates
    title: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Title template with {{variables}}",
    )
    body: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Body template with {{variables}}",
    )

    # Default settings
    default_icon: Optional[str] = Field(
        None,
        description="Default notification icon",
    )
    default_sound: str = Field(
        default="default",
        description="Default notification sound",
    )
    default_image_url: Optional[str] = Field(
        None,
        description="Default image URL",
    )

    # Variables
    required_variables: List[str] = Field(
        ...,
        description="Required template variables",
    )
    optional_variables: List[str] = Field(
        default_factory=list,
        description="Optional template variables",
    )

    # Actions
    default_action_url: Optional[str] = Field(
        None,
        description="Default deep link/URL",
    )
    default_actions: List[PushAction] = Field(
        default_factory=list,
        description="Default action buttons",
    )

    # Platform-specific
    android_channel_id: Optional[str] = Field(
        None,
        description="Default Android channel ID",
    )
    ios_category: Optional[str] = Field(
        None,
        description="Default iOS category",
    )


class PushDeliveryStatus(BaseSchema):
    """
    Push notification delivery status.

    Tracks delivery and engagement for individual notifications.
    """

    notification_id: UUID = Field(
        ...,
        description="Push notification ID",
    )
    device_token: str = Field(
        ...,
        description="Target device token",
    )

    # Delivery status
    status: str = Field(
        ...,
        pattern="^(queued|sent|delivered|failed|expired|clicked)$",
        description="Current delivery status",
    )

    # Timeline
    sent_at: Optional[datetime] = Field(
        None,
        description="When notification was sent",
    )
    delivered_at: Optional[datetime] = Field(
        None,
        description="When notification was delivered to device",
    )
    clicked_at: Optional[datetime] = Field(
        None,
        description="When notification was clicked",
    )
    failed_at: Optional[datetime] = Field(
        None,
        description="When delivery failed",
    )

    # Error information
    error_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Error code from provider",
    )
    error_message: Optional[str] = Field(
        None,
        max_length=500,
        description="Error message",
    )

    # Provider details
    provider_message_id: Optional[str] = Field(
        None,
        max_length=255,
        description="Provider's message ID",
    )
    provider_response: Optional[Dict[str, Any]] = Field(
        None,
        description="Raw provider response",
    )

    # Engagement
    was_clicked: bool = Field(
        default=False,
        description="Whether notification was clicked",
    )
    action_taken: Optional[str] = Field(
        None,
        description="Which action button was clicked (if any)",
    )


class PushStats(BaseSchema):
    """
    Push notification campaign statistics.

    Provides analytics for push notification performance.
    """

    # Send statistics
    total_sent: int = Field(
        ...,
        ge=0,
        description="Total notifications sent",
    )
    total_delivered: int = Field(
        ...,
        ge=0,
        description="Total notifications delivered",
    )
    total_failed: int = Field(
        ...,
        ge=0,
        description="Total delivery failures",
    )

    # Delivery rate
    delivery_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Delivery rate percentage",
    )

    # Platform breakdown
    ios_sent: int = Field(default=0, ge=0, description="iOS notifications sent")
    android_sent: int = Field(default=0, ge=0, description="Android notifications sent")
    web_sent: int = Field(default=0, ge=0, description="Web notifications sent")

    ios_delivered: int = Field(default=0, ge=0, description="iOS delivered")
    android_delivered: int = Field(default=0, ge=0, description="Android delivered")
    web_delivered: int = Field(default=0, ge=0, description="Web delivered")

    # Engagement statistics
    total_opened: int = Field(
        ...,
        ge=0,
        description="Total notifications clicked/opened",
    )
    open_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Click/open rate percentage",
    )

    # Action engagement
    total_action_clicks: int = Field(
        default=0,
        ge=0,
        description="Total action button clicks",
    )
    actions_breakdown: Dict[str, int] = Field(
        default_factory=dict,
        description="Click count by action ID",
    )

    # Time period
    period_start: date = Field(
        ...,
        description="Statistics period start",
    )
    period_end: date = Field(
        ...,
        description="Statistics period end",
    )

    @field_validator("period_end")
    @classmethod
    def validate_period(cls, v: date, info) -> date:
        """Validate period end is after period start."""
        period_start = info.data.get("period_start")
        if period_start and v < period_start:
            raise ValueError("period_end must be after or equal to period_start")
        return v


class BulkPushRequest(BaseCreateSchema):
    """
    Send push notifications to multiple users/devices in bulk.

    Optimized for mass delivery with batching and rate limiting.
    """

    # Recipients
    user_ids: Optional[List[UUID]] = Field(
        None,
        max_length=100000,
        description="List of user IDs (max 100,000)",
    )
    device_tokens: Optional[List[str]] = Field(
        None,
        max_length=100000,
        description="List of device tokens (max 100,000)",
    )
    segment: Optional[str] = Field(
        None,
        description="User segment to target",
    )

    # Content
    title: str = Field(..., min_length=1, max_length=100)
    body: str = Field(..., min_length=1, max_length=500)

    # Template support
    template_code: Optional[str] = Field(None, description="Template to use")

    # Per-user customization
    user_variables: Optional[Dict[UUID, Dict[str, str]]] = Field(
        None,
        description="Per-user variable mapping",
    )

    # Default settings
    image_url: Optional[str] = None
    icon: Optional[str] = None
    sound: str = Field(default="default")
    priority: str = Field(default="normal", pattern="^(low|normal|high)$")

    # Batch settings
    batch_size: int = Field(
        default=1000,
        ge=100,
        le=10000,
        description="Notifications per batch",
    )
    delay_between_batches_seconds: int = Field(
        default=1,
        ge=0,
        le=10,
        description="Delay between batches",
    )

    # Metadata
    campaign_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Campaign name",
    )
    tags: List[str] = Field(default_factory=list)

    @model_validator(mode="after")
    def validate_recipients(self) -> "BulkPushRequest":
        """Ensure at least one recipient group is provided."""
        if not any([self.user_ids, self.device_tokens, self.segment]):
            raise ValueError(
                "At least one recipient group (user_ids, device_tokens, or segment) required"
            )
        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\notification\sms_notification.py ---
# --- File: app/schemas/notification/sms_notification.py ---
"""
SMS notification schemas.

This module provides schemas for SMS-specific notifications including
sending, delivery tracking, templates, and bulk operations.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "SMSRequest",
    "SMSConfig",
    "DeliveryStatus",
    "SMSTemplate",
    "BulkSMSRequest",
    "SMSStats",
    "SMSQuota",
]


class SMSRequest(BaseCreateSchema):
    """
    Send SMS notification request.

    Supports both direct message and template-based SMS with
    delivery tracking and priority handling.
    """

    # Recipient
    recipient_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Recipient phone number in E.164 format",
    )

    # Message content
    message: str = Field(
        ...,
        min_length=1,
        max_length=1600,  # 10 SMS segments max
        description="SMS message content (max 1600 chars)",
    )

    # Template support
    template_code: Optional[str] = Field(
        None,
        min_length=3,
        max_length=100,
        description="Template code (overrides direct message)",
    )
    template_variables: Optional[Dict[str, str]] = Field(
        None,
        description="Variables for template rendering",
    )

    # Sender configuration
    sender_id: Optional[str] = Field(
        None,
        min_length=3,
        max_length=11,
        pattern="^[a-zA-Z0-9]+$",
        description="Sender ID/Name (alphanumeric, max 11 chars)",
    )

    # Priority
    priority: str = Field(
        default="normal",
        pattern="^(low|normal|high)$",
        description="SMS delivery priority",
    )

    # DLT compliance (India-specific)
    dlt_template_id: Optional[str] = Field(
        None,
        max_length=50,
        description="DLT template ID for regulatory compliance (India)",
    )
    dlt_entity_id: Optional[str] = Field(
        None,
        max_length=50,
        description="DLT entity ID (India)",
    )

    # Scheduling
    send_at: Optional[datetime] = Field(
        None,
        description="Schedule SMS for future delivery",
    )

    # Tracking
    track_delivery: bool = Field(
        default=True,
        description="Enable delivery status tracking",
    )

    # Metadata
    tags: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Tags for categorization",
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Custom metadata",
    )

    @field_validator("message")
    @classmethod
    def validate_message_length(cls, v: str) -> str:
        """Validate message length and estimate segments."""
        # GSM-7 encoding: 160 chars per segment
        # Unicode encoding: 70 chars per segment
        if len(v) > 1600:
            raise ValueError("Message cannot exceed 1600 characters (10 segments)")
        return v

    @field_validator("recipient_phone")
    @classmethod
    def normalize_phone_number(cls, v: str) -> str:
        """Normalize phone number to E.164 format."""
        # Remove any spaces, hyphens, or parentheses
        normalized = v.replace(" ", "").replace("-", "").replace("(", "").replace(")", "")
        
        # Ensure it starts with +
        if not normalized.startswith("+"):
            # Assume +91 for India if no country code
            if len(normalized) == 10:
                normalized = f"+91{normalized}"
            else:
                normalized = f"+{normalized}"
        
        return normalized

    @field_validator("send_at")
    @classmethod
    def validate_send_time(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Validate scheduled send time is in the future."""
        if v is not None and v <= datetime.utcnow():
            raise ValueError("Scheduled send time must be in the future")
        return v

    @model_validator(mode="after")
    def validate_content_or_template(self) -> "SMSRequest":
        """Ensure either direct message or template is provided."""
        if self.template_code:
            if not self.template_variables:
                raise ValueError(
                    "template_variables required when using template_code"
                )
        else:
            if not self.message:
                raise ValueError(
                    "message required when not using template_code"
                )
        return self


class SMSConfig(BaseSchema):
    """
    SMS service configuration.

    Supports multiple SMS gateway providers with unified configuration.
    """

    # Service provider
    service_provider: str = Field(
        ...,
        pattern="^(twilio|aws_sns|msg91|vonage|plivo|custom)$",
        description="SMS service provider",
    )

    # API credentials
    account_sid: Optional[str] = Field(
        None,
        max_length=255,
        description="Account SID/ID",
    )
    auth_token: Optional[str] = Field(
        None,
        max_length=500,
        description="Authentication token/API key",
    )
    api_key: Optional[str] = Field(
        None,
        max_length=500,
        description="API key (alternative to auth_token)",
    )

    # Sender configuration
    default_sender_id: str = Field(
        ...,
        min_length=3,
        max_length=11,
        description="Default sender ID",
    )

    # Rate limiting
    max_sms_per_hour: int = Field(
        default=100,
        ge=1,
        le=10000,
        description="Maximum SMS per hour",
    )
    max_sms_per_day: int = Field(
        default=1000,
        ge=1,
        le=100000,
        description="Maximum SMS per day",
    )
    max_sms_per_recipient_per_day: int = Field(
        default=10,
        ge=1,
        le=100,
        description="Maximum SMS per recipient per day",
    )

    # Country settings
    default_country_code: str = Field(
        default="+91",
        pattern=r"^\+\d{1,3}$",
        description="Default country code",
    )
    allowed_country_codes: List[str] = Field(
        default_factory=lambda: ["+91"],
        description="Allowed destination country codes",
    )

    # DLT settings (India)
    dlt_enabled: bool = Field(
        default=False,
        description="Enable DLT compliance checking",
    )
    dlt_entity_id: Optional[str] = Field(
        None,
        description="Default DLT entity ID",
    )

    # Delivery reports
    delivery_report_webhook_url: Optional[str] = Field(
        None,
        max_length=500,
        description="Webhook URL for delivery reports",
    )

    # Cost settings
    cost_per_sms: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Cost per SMS unit",
    )
    currency: str = Field(
        default="INR",
        min_length=3,
        max_length=3,
        description="Currency code (ISO 4217)",
    )


class DeliveryStatus(BaseSchema):
    """
    SMS delivery status and tracking information.

    Tracks the complete lifecycle of an SMS from queue to delivery.
    """

    sms_id: UUID = Field(
        ...,
        description="SMS notification ID",
    )
    recipient_phone: str = Field(
        ...,
        description="Recipient phone number",
    )

    # Delivery status
    status: str = Field(
        ...,
        pattern="^(queued|sent|delivered|failed|undelivered|expired|rejected)$",
        description="Current delivery status",
    )

    # Timeline
    queued_at: datetime = Field(
        ...,
        description="When SMS was queued",
    )
    sent_at: Optional[datetime] = Field(
        None,
        description="When SMS was sent to provider",
    )
    delivered_at: Optional[datetime] = Field(
        None,
        description="When SMS was delivered to recipient",
    )
    failed_at: Optional[datetime] = Field(
        None,
        description="When delivery failed",
    )

    # Error information
    error_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Error code from provider",
    )
    error_message: Optional[str] = Field(
        None,
        max_length=500,
        description="Human-readable error message",
    )

    # Provider details
    provider_message_id: Optional[str] = Field(
        None,
        max_length=255,
        description="Provider's unique message ID",
    )
    provider_status: Optional[str] = Field(
        None,
        max_length=100,
        description="Raw status from provider",
    )

    # Message details
    segments_count: int = Field(
        default=1,
        ge=1,
        le=10,
        description="Number of SMS segments used",
    )
    character_count: int = Field(
        ...,
        ge=1,
        description="Total character count",
    )
    encoding: str = Field(
        default="GSM-7",
        pattern="^(GSM-7|Unicode)$",
        description="Message encoding used",
    )

    # Cost
    cost: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Cost for this SMS",
    )
    currency: Optional[str] = Field(
        None,
        min_length=3,
        max_length=3,
        description="Currency code",
    )

    # Retry information
    retry_count: int = Field(
        default=0,
        ge=0,
        description="Number of retry attempts",
    )


class SMSTemplate(BaseSchema):
    """
    SMS-specific template configuration.

    Optimized for SMS constraints with character counting and
    DLT compliance support.
    """

    template_code: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Unique template identifier",
    )

    # Message template
    message_template: str = Field(
        ...,
        min_length=1,
        max_length=1600,
        description="SMS message template with {{variables}}",
    )

    # Variables
    required_variables: List[str] = Field(
        ...,
        description="Required template variables",
    )
    optional_variables: List[str] = Field(
        default_factory=list,
        description="Optional template variables",
    )

    # Character analysis
    estimated_length: int = Field(
        ...,
        ge=1,
        description="Estimated character length (without variables)",
    )
    estimated_segments: int = Field(
        ...,
        ge=1,
        le=10,
        description="Estimated SMS segments",
    )

    # DLT compliance (India)
    dlt_template_id: Optional[str] = Field(
        None,
        max_length=50,
        description="DLT approved template ID",
    )
    dlt_approved: bool = Field(
        default=False,
        description="Whether template is DLT approved",
    )
    dlt_approval_date: Optional[date] = Field(
        None,
        description="Date of DLT approval",
    )

    # Category
    category: Optional[str] = Field(
        None,
        max_length=50,
        pattern="^(transactional|promotional|otp|alert)$",
        description="SMS category",
    )


class BulkSMSRequest(BaseCreateSchema):
    """
    Send bulk SMS to multiple recipients.

    Optimized for batch sending with rate limiting and cost estimation.
    """

    recipients: List[str] = Field(
        ...,
        min_length=1,
        max_length=10000,
        description="List of recipient phone numbers (max 10,000)",
    )

    # Message content
    message: str = Field(
        ...,
        min_length=1,
        max_length=1600,
        description="SMS message content",
    )

    # Template support
    template_code: Optional[str] = Field(
        None,
        description="Template code for all SMS",
    )

    # Per-recipient customization
    recipient_variables: Optional[Dict[str, Dict[str, str]]] = Field(
        None,
        description="Per-recipient variable mapping (phone -> variables)",
    )

    # Sender
    sender_id: Optional[str] = Field(
        None,
        max_length=11,
        description="Sender ID for all SMS",
    )

    # Batch settings
    batch_size: int = Field(
        default=100,
        ge=10,
        le=1000,
        description="Number of SMS per batch",
    )
    delay_between_batches_seconds: int = Field(
        default=2,
        ge=1,
        le=10,
        description="Delay between batches in seconds",
    )

    # Scheduling
    send_at: Optional[datetime] = Field(
        None,
        description="Schedule bulk send for future",
    )

    # DLT (India)
    dlt_template_id: Optional[str] = Field(
        None,
        description="DLT template ID for all SMS",
    )

    # Metadata
    campaign_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Campaign name for tracking",
    )
    tags: List[str] = Field(
        default_factory=list,
        description="Tags for this bulk send",
    )

    @field_validator("recipients")
    @classmethod
    def validate_unique_recipients(cls, v: List[str]) -> List[str]:
        """Ensure recipient list doesn't contain duplicates."""
        if len(v) != len(set(v)):
            raise ValueError("Duplicate phone numbers in recipients list")
        return v

    @field_validator("recipients")
    @classmethod
    def validate_phone_numbers(cls, v: List[str]) -> List[str]:
        """Validate all phone numbers are in correct format."""
        import re
        phone_pattern = r"^\+?[1-9]\d{9,14}$"
        for phone in v:
            if not re.match(phone_pattern, phone):
                raise ValueError(f"Invalid phone number format: {phone}")
        return v


class SMSStats(BaseSchema):
    """
    SMS campaign statistics and metrics.

    Provides comprehensive analytics for SMS performance and costs.
    """

    # Send statistics
    total_sent: int = Field(
        ...,
        ge=0,
        description="Total SMS sent",
    )
    total_delivered: int = Field(
        ...,
        ge=0,
        description="Total SMS delivered",
    )
    total_failed: int = Field(
        ...,
        ge=0,
        description="Total SMS failed",
    )
    total_pending: int = Field(
        default=0,
        ge=0,
        description="Total SMS pending delivery",
    )

    # Delivery rates
    delivery_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Delivery rate percentage",
    )
    failure_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Failure rate percentage",
    )

    # Cost analysis
    total_cost: Decimal = Field(
        ...,
        ge=0,
        description="Total cost for period",
    )
    average_cost_per_sms: Decimal = Field(
        ...,
        ge=0,
        description="Average cost per SMS",
    )
    currency: str = Field(
        ...,
        min_length=3,
        max_length=3,
        description="Currency code",
    )

    # Segment analysis
    total_segments: int = Field(
        ...,
        ge=0,
        description="Total SMS segments used",
    )
    average_segments_per_sms: Decimal = Field(
        ...,
        ge=0,
        description="Average segments per SMS",
    )

    # Breakdown by status
    delivered_count: int = Field(..., ge=0)
    failed_count: int = Field(..., ge=0)
    pending_count: int = Field(..., ge=0)
    expired_count: int = Field(default=0, ge=0)
    rejected_count: int = Field(default=0, ge=0)

    # Time period
    period_start: date = Field(
        ...,
        description="Statistics period start date",
    )
    period_end: date = Field(
        ...,
        description="Statistics period end date",
    )

    @field_validator("period_end")
    @classmethod
    def validate_period(cls, v: date, info) -> date:
        """Validate period end is after period start."""
        period_start = info.data.get("period_start")
        if period_start and v < period_start:
            raise ValueError("period_end must be after or equal to period_start")
        return v


class SMSQuota(BaseSchema):
    """
    SMS quota and usage tracking.

    Tracks SMS usage against configured limits.
    """

    # Quotas
    hourly_quota: int = Field(..., ge=0, description="Hourly SMS quota")
    daily_quota: int = Field(..., ge=0, description="Daily SMS quota")
    monthly_quota: int = Field(..., ge=0, description="Monthly SMS quota")

    # Usage
    hourly_usage: int = Field(..., ge=0, description="SMS sent this hour")
    daily_usage: int = Field(..., ge=0, description="SMS sent today")
    monthly_usage: int = Field(..., ge=0, description="SMS sent this month")

    # Remaining
    hourly_remaining: int = Field(..., ge=0, description="Remaining hourly quota")
    daily_remaining: int = Field(..., ge=0, description="Remaining daily quota")
    monthly_remaining: int = Field(..., ge=0, description="Remaining monthly quota")

    # Reset times
    hourly_reset_at: datetime = Field(..., description="When hourly quota resets")
    daily_reset_at: datetime = Field(..., description="When daily quota resets")
    monthly_reset_at: datetime = Field(..., description="When monthly quota resets")

    # Status
    is_quota_exceeded: bool = Field(
        ...,
        description="Whether any quota is exceeded",
    )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\notification\__init__.py ---
# --- File: app/schemas/notification/__init__.py ---
"""
Notification schemas package.

Provides comprehensive schemas for notification management including
email, SMS, push notifications, templates, preferences, routing, and queues.
"""

from __future__ import annotations

# Base notification schemas
from app.schemas.notification.notification_base import (
    BulkMarkAsRead,
    MarkAsRead,
    NotificationBase,
    NotificationCreate,
    NotificationDelete,
    NotificationUpdate,
)

# Response schemas
from app.schemas.notification.notification_response import (
    NotificationDetail,
    NotificationList,
    NotificationListItem,
    NotificationResponse,
    NotificationSummary,
    UnreadCount,
)

# Template schemas
from app.schemas.notification.notification_template import (
    TemplateCategory,
    TemplateCopyRequest,
    TemplateCreate,
    TemplateList,
    TemplatePreview,
    TemplatePreviewResponse,
    TemplateResponse,
    TemplateUpdate,
    VariableMapping,
)

# Email schemas
from app.schemas.notification.email_notification import (
    BulkEmailRequest,
    EmailAttachment,
    EmailConfig,
    EmailRequest,
    EmailSchedule,
    EmailStats,
    EmailTemplate,
    EmailTracking,
)

# SMS schemas
from app.schemas.notification.sms_notification import (
    BulkSMSRequest,
    DeliveryStatus,
    SMSConfig,
    SMSQuota,
    SMSRequest,
    SMSStats,
    SMSTemplate,
)

# Push notification schemas
from app.schemas.notification.push_notification import (
    BulkPushRequest,
    DeviceRegistration,
    DeviceToken,
    DeviceUnregistration,
    PushAction,
    PushConfig,
    PushDeliveryStatus,
    PushRequest,
    PushStats,
    PushTemplate,
)

# Queue schemas
from app.schemas.notification.notification_queue import (
    BatchProcessing,
    QueuedNotification,
    QueueHealth,
    QueuePriority,
    QueueStats,
    QueueStatus,
)

# Preference schemas
from app.schemas.notification.notification_preferences import (
    ChannelPreferences,
    EmailPreferences,
    FrequencySettings,
    PreferenceUpdate,
    PushPreferences,
    QuietHours,
    SMSPreferences,
    UnsubscribeRequest,
    UserPreferences,
)

# Routing schemas
from app.schemas.notification.notification_routing import (
    EscalationLevel,
    EscalationRouting,
    HierarchicalRouting,
    NotificationRoute,
    RoutingCondition,
    RoutingConfig,
    RoutingRule,
)

__all__ = [
    # Base
    "NotificationBase",
    "NotificationCreate",
    "NotificationUpdate",
    "MarkAsRead",
    "BulkMarkAsRead",
    "NotificationDelete",
    # Response
    "NotificationResponse",
    "NotificationDetail",
    "NotificationList",
    "NotificationListItem",
    "UnreadCount",
    "NotificationSummary",
    # Template
    "TemplateCreate",
    "TemplateUpdate",
    "TemplateResponse",
    "VariableMapping",
    "TemplatePreview",
    "TemplatePreviewResponse",
    "TemplateList",
    "TemplateCategory",
    "TemplateCopyRequest",
    # Email
    "EmailRequest",
    "EmailConfig",
    "EmailTracking",
    "EmailTemplate",
    "BulkEmailRequest",
    "EmailStats",
    "EmailAttachment",
    "EmailSchedule",
    # SMS
    "SMSRequest",
    "SMSConfig",
    "DeliveryStatus",
    "SMSTemplate",
    "BulkSMSRequest",
    "SMSStats",
    "SMSQuota",
    # Push
    "PushRequest",
    "PushConfig",
    "DeviceToken",
    "DeviceRegistration",
    "DeviceUnregistration",
    "PushTemplate",
    "PushDeliveryStatus",
    "PushStats",
    "PushAction",
    "BulkPushRequest",
    # Queue
    "QueueStatus",
    "QueuedNotification",
    "BatchProcessing",
    "QueueStats",
    "QueueHealth",
    "QueuePriority",
    # Preferences
    "UserPreferences",
    "ChannelPreferences",
    "EmailPreferences",
    "SMSPreferences",
    "PushPreferences",
    "FrequencySettings",
    "PreferenceUpdate",
    "UnsubscribeRequest",
    "QuietHours",
    # Routing
    "RoutingConfig",
    "RoutingRule",
    "RoutingCondition",
    "HierarchicalRouting",
    "EscalationRouting",
    "EscalationLevel",
    "NotificationRoute",
]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\notification\__pycache__ =====
