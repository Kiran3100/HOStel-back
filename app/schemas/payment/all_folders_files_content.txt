### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\payment ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\payment =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\payment\payment_base.py ---
# --- File: app/schemas/payment/payment_base.py ---
"""
Payment base schemas with comprehensive validation.

This module defines the core payment schemas including creation,
updates, and base validation logic for the payment lifecycle.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import PaymentMethod, PaymentStatus, PaymentType

__all__ = [
    "PaymentBase",
    "PaymentCreate",
    "PaymentUpdate",
]


class PaymentBase(BaseSchema):
    """
    Base payment schema with common fields and validation.
    
    Contains all core payment information including payer details,
    payment type, amount, method, and period information.
    """

    payer_id: UUID = Field(
        ...,
        description="Unique identifier of the user making the payment",
    )
    hostel_id: UUID = Field(
        ...,
        description="Unique identifier of the hostel receiving payment",
    )
    student_id: Optional[UUID] = Field(
        None,
        description="Student profile ID (for recurring fee payments)",
    )
    booking_id: Optional[UUID] = Field(
        None,
        description="Booking ID (for booking-related payments)",
    )

    # Payment Details
    payment_type: PaymentType = Field(
        ...,
        description="Type of payment (rent, deposit, mess, etc.)",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Payment amount (up to 10 digits with 2 decimal places)",
    )
    currency: str = Field(
        "INR",
        min_length=3,
        max_length=3,
        description="Currency code (ISO 4217)",
    )

    # Payment Period (for recurring fees)
    payment_period_start: Optional[date] = Field(
        None,
        description="Start date of the period this payment covers",
    )
    payment_period_end: Optional[date] = Field(
        None,
        description="End date of the period this payment covers",
    )

    # Payment Method Details
    payment_method: PaymentMethod = Field(
        ...,
        description="Method of payment (cash, UPI, card, etc.)",
    )
    payment_gateway: Optional[str] = Field(
        None,
        max_length=50,
        description="Payment gateway used (razorpay, stripe, paytm)",
    )

    # Due Date
    due_date: Optional[date] = Field(
        None,
        description="Payment due date (for scheduled payments)",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate payment amount is positive and reasonable."""
        if v <= 0:
            raise ValueError("Payment amount must be greater than zero")
        
        # Sanity check: Maximum payment amount
        max_amount = Decimal("1000000.00")  # 10 lakhs
        if v > max_amount:
            raise ValueError(
                f"Payment amount (₹{v}) exceeds maximum allowed (₹{max_amount})"
            )
        
        # Ensure exactly 2 decimal places
        if v.as_tuple().exponent < -2:
            raise ValueError("Payment amount can have at most 2 decimal places")
        
        return v.quantize(Decimal("0.01"))

    @field_validator("currency")
    @classmethod
    def validate_currency(cls, v: str) -> str:
        """Validate and normalize currency code."""
        v = v.upper().strip()
        
        # Validate ISO 4217 format (3 uppercase letters)
        if not v.isalpha() or len(v) != 3:
            raise ValueError("Currency must be a valid 3-letter ISO code")
        
        # Currently only support INR
        supported_currencies = ["INR"]
        if v not in supported_currencies:
            raise ValueError(
                f"Currency {v} not supported. Supported: {', '.join(supported_currencies)}"
            )
        
        return v

    @model_validator(mode="after")
    def validate_payment_period(self) -> "PaymentBase":
        """Validate payment period dates if provided."""
        if self.payment_period_start and self.payment_period_end:
            if self.payment_period_end < self.payment_period_start:
                raise ValueError(
                    f"Payment period end ({self.payment_period_end}) must be "
                    f"after or equal to start ({self.payment_period_start})"
                )
            
            # Check period is not too long (max 1 year for single payment)
            days_diff = (self.payment_period_end - self.payment_period_start).days
            if days_diff > 365:
                raise ValueError(
                    f"Payment period cannot exceed 365 days (got {days_diff} days)"
                )
        
        return self

    @model_validator(mode="after")
    def validate_entity_references(self) -> "PaymentBase":
        """Validate entity references are consistent."""
        # At least one of student_id or booking_id should be present for most payment types
        if self.payment_type not in [PaymentType.OTHER]:
            if not self.student_id and not self.booking_id:
                # Warning: Payment should be linked to a student or booking
                # In production, you might want to log this
                pass
        
        return self

    @field_validator("payment_gateway")
    @classmethod
    def validate_payment_gateway(cls, v: Optional[str]) -> Optional[str]:
        """Validate payment gateway if provided."""
        if v is not None:
            v = v.lower().strip()
            
            supported_gateways = ["razorpay", "stripe", "paytm", "phonepe", "googlepay"]
            if v not in supported_gateways:
                raise ValueError(
                    f"Payment gateway '{v}' not supported. "
                    f"Supported: {', '.join(supported_gateways)}"
                )
        
        return v

    @field_validator("due_date")
    @classmethod
    def validate_due_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate due date is reasonable."""
        if v is not None:
            # Warn if due date is too far in the past
            days_ago = (date.today() - v).days
            if days_ago > 365:
                # Log warning - might be data migration
                pass
            
            # Warn if due date is too far in the future
            days_ahead = (v - date.today()).days
            if days_ahead > 365:
                # Log warning
                pass
        
        return v

    @property
    def is_overdue(self) -> bool:
        """Check if payment is overdue."""
        if self.due_date is None:
            return False
        return date.today() > self.due_date

    @property
    def days_overdue(self) -> int:
        """Calculate days overdue (0 if not overdue)."""
        if not self.is_overdue:
            return 0
        return (date.today() - self.due_date).days


class PaymentCreate(PaymentBase, BaseCreateSchema):
    """
    Schema for creating a new payment.
    
    Includes all base fields plus creation-specific fields like
    transaction ID and collection details.
    """

    # Additional Creation Fields
    transaction_id: Optional[str] = Field(
        None,
        max_length=100,
        description="External transaction ID from payment gateway or bank",
    )
    collected_by: Optional[UUID] = Field(
        None,
        description="Staff member who collected the payment (for offline payments)",
    )

    # Additional Notes
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes about the payment",
    )

    @field_validator("transaction_id")
    @classmethod
    def validate_transaction_id(cls, v: Optional[str]) -> Optional[str]:
        """Validate and clean transaction ID."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
            
            # Ensure it doesn't exceed max length
            if len(v) > 100:
                raise ValueError("Transaction ID cannot exceed 100 characters")
        
        return v

    @model_validator(mode="after")
    def validate_offline_payment(self) -> "PaymentCreate":
        """Validate offline payment requires collection details."""
        offline_methods = [
            PaymentMethod.CASH,
            PaymentMethod.CHEQUE,
            PaymentMethod.BANK_TRANSFER,
        ]
        
        if self.payment_method in offline_methods:
            if not self.collected_by:
                raise ValueError(
                    f"collected_by is required for {self.payment_method.value} payments"
                )
        
        return self

    @field_validator("notes")
    @classmethod
    def clean_notes(cls, v: Optional[str]) -> Optional[str]:
        """Clean notes field."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class PaymentUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing payment.
    
    All fields are optional, allowing partial updates.
    Primarily used for status updates and adding receipt information.
    """

    payment_status: Optional[PaymentStatus] = Field(
        None,
        description="Update payment status",
    )
    transaction_id: Optional[str] = Field(
        None,
        max_length=100,
        description="Update transaction ID",
    )
    
    # Status Timestamps
    paid_at: Optional[datetime] = Field(
        None,
        description="Timestamp when payment was completed",
    )
    failed_at: Optional[datetime] = Field(
        None,
        description="Timestamp when payment failed",
    )
    failure_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for payment failure",
    )

    # Receipt Information
    receipt_number: Optional[str] = Field(
        None,
        max_length=50,
        description="Receipt number",
    )
    receipt_url: Optional[str] = Field(
        None,
        description="URL to download receipt",
    )

    # Additional Notes
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Update notes",
    )

    @field_validator("failure_reason")
    @classmethod
    def validate_failure_reason(cls, v: Optional[str]) -> Optional[str]:
        """Validate failure reason is meaningful."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
            
            if len(v) < 5:
                raise ValueError(
                    "Failure reason must be at least 5 characters if provided"
                )
        
        return v

    @model_validator(mode="after")
    def validate_status_consistency(self) -> "PaymentUpdate":
        """Validate status-related fields are consistent."""
        # If status is COMPLETED, paid_at should be set
        if self.payment_status == PaymentStatus.COMPLETED:
            if not self.paid_at:
                # Set to current time if not provided
                self.paid_at = datetime.utcnow()
        
        # If status is FAILED, failed_at and failure_reason should be set
        if self.payment_status == PaymentStatus.FAILED:
            if not self.failed_at:
                self.failed_at = datetime.utcnow()
            
            if not self.failure_reason:
                raise ValueError(
                    "failure_reason is required when payment_status is FAILED"
                )
        
        return self

    @field_validator("transaction_id", "receipt_number", "notes")
    @classmethod
    def clean_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Clean text fields."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\payment\payment_filters.py ---
# --- File: app/schemas/payment/payment_filters.py ---
"""
Payment filter and search schemas.

This module defines schemas for filtering, searching, sorting,
and exporting payment data with comprehensive analytics support.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import PaymentMethod, PaymentStatus, PaymentType

__all__ = [
    "PaymentFilterParams",
    "PaymentSearchRequest",
    "PaymentSortOptions",
    "PaymentReportRequest",
    "PaymentExportRequest",
    "PaymentAnalyticsRequest",
]


class PaymentFilterParams(BaseFilterSchema):
    """
    Comprehensive payment filter parameters.
    
    Supports filtering by various criteria including status, dates,
    amounts, payment methods, and entity relationships.
    """

    # Text Search
    search: Optional[str] = Field(
        None,
        max_length=255,
        description="Search in reference, payer name, transaction ID",
    )

    # Entity Filters
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by specific hostel",
    )
    hostel_ids: Optional[List[UUID]] = Field(
        None,
        max_length=20,
        description="Filter by multiple hostels (max 20)",
    )
    student_id: Optional[UUID] = Field(
        None,
        description="Filter by specific student",
    )
    payer_id: Optional[UUID] = Field(
        None,
        description="Filter by specific payer",
    )

    # Payment Type Filters
    payment_type: Optional[PaymentType] = Field(
        None,
        description="Filter by specific payment type",
    )
    payment_types: Optional[List[PaymentType]] = Field(
        None,
        max_length=10,
        description="Filter by multiple payment types",
    )

    # Payment Method Filters
    payment_method: Optional[PaymentMethod] = Field(
        None,
        description="Filter by specific payment method",
    )
    payment_methods: Optional[List[PaymentMethod]] = Field(
        None,
        max_length=10,
        description="Filter by multiple payment methods",
    )

    # Status Filters
    payment_status: Optional[PaymentStatus] = Field(
        None,
        description="Filter by specific status",
    )
    payment_statuses: Optional[List[PaymentStatus]] = Field(
        None,
        max_length=10,
        description="Filter by multiple statuses",
    )

    # Amount Range Filters
    amount_min: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Minimum payment amount",
    )
    amount_max: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Maximum payment amount",
    )

    # Date Filters
    paid_date_from: Optional[date] = Field(
        None,
        description="Filter payments paid from this date",
    )
    paid_date_to: Optional[date] = Field(
        None,
        description="Filter payments paid until this date",
    )
    due_date_from: Optional[date] = Field(
        None,
        description="Filter by due date from",
    )
    due_date_to: Optional[date] = Field(
        None,
        description="Filter by due date to",
    )
    created_date_from: Optional[date] = Field(
        None,
        description="Filter by creation date from",
    )
    created_date_to: Optional[date] = Field(
        None,
        description="Filter by creation date to",
    )

    # Special Filters
    overdue_only: Optional[bool] = Field(
        None,
        description="Show only overdue payments",
    )
    pending_only: Optional[bool] = Field(
        None,
        description="Show only pending payments",
    )
    refunded_only: Optional[bool] = Field(
        None,
        description="Show only refunded payments",
    )

    # Gateway Filter
    payment_gateway: Optional[str] = Field(
        None,
        max_length=50,
        description="Filter by payment gateway",
    )

    @model_validator(mode="after")
    def validate_amount_range(self) -> "PaymentFilterParams":
        """Validate amount range."""
        if self.amount_min is not None and self.amount_max is not None:
            if self.amount_max < self.amount_min:
                raise ValueError(
                    f"Maximum amount (₹{self.amount_max}) must be greater than "
                    f"or equal to minimum amount (₹{self.amount_min})"
                )
        return self

    @model_validator(mode="after")
    def validate_paid_date_range(self) -> "PaymentFilterParams":
        """Validate paid date range."""
        if self.paid_date_from is not None and self.paid_date_to is not None:
            if self.paid_date_to < self.paid_date_from:
                raise ValueError(
                    "paid_date_to must be after or equal to paid_date_from"
                )
        return self

    @model_validator(mode="after")
    def validate_due_date_range(self) -> "PaymentFilterParams":
        """Validate due date range."""
        if self.due_date_from is not None and self.due_date_to is not None:
            if self.due_date_to < self.due_date_from:
                raise ValueError(
                    "due_date_to must be after or equal to due_date_from"
                )
        return self

    @model_validator(mode="after")
    def validate_created_date_range(self) -> "PaymentFilterParams":
        """Validate created date range."""
        if self.created_date_from is not None and self.created_date_to is not None:
            if self.created_date_to < self.created_date_from:
                raise ValueError(
                    "created_date_to must be after or equal to created_date_from"
                )
        return self


class PaymentSearchRequest(BaseFilterSchema):
    """
    Payment search request with pagination.
    
    Supports full-text search across payment fields.
    """

    query: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Search query string",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Limit search to specific hostel",
    )

    # Search Fields
    search_in_reference: bool = Field(
        True,
        description="Search in payment reference",
    )
    search_in_payer_name: bool = Field(
        True,
        description="Search in payer name",
    )
    search_in_transaction_id: bool = Field(
        True,
        description="Search in transaction ID",
    )

    # Status Filter
    payment_status: Optional[PaymentStatus] = Field(
        None,
        description="Limit search to specific status",
    )

    # Pagination
    page: int = Field(
        1,
        ge=1,
        description="Page number (1-indexed)",
    )
    page_size: int = Field(
        20,
        ge=1,
        le=100,
        description="Items per page (max 100)",
    )

    @field_validator("query")
    @classmethod
    def validate_query(cls, v: str) -> str:
        """Validate and clean search query."""
        v = v.strip()
        if len(v) == 0:
            raise ValueError("Search query cannot be empty")
        return v


class PaymentSortOptions(BaseFilterSchema):
    """
    Payment sorting options.
    
    Defines how to sort payment results.
    """

    sort_by: str = Field(
        "created_at",
        pattern=r"^(created_at|paid_at|due_date|amount|payment_reference|payer_name|status)$",
        description="Field to sort by",
    )
    sort_order: str = Field(
        "desc",
        pattern=r"^(asc|desc)$",
        description="Sort order: ascending or descending",
    )

    @field_validator("sort_by", "sort_order")
    @classmethod
    def normalize_sort_fields(cls, v: str) -> str:
        """Normalize sort field values."""
        return v.lower()


class PaymentReportRequest(BaseFilterSchema):
    """
    Payment report generation request.
    
    Generates comprehensive payment reports with analytics.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Generate report for specific hostel (or all)",
    )

    # Date Range (Required)
    date_from: date = Field(
        ...,
        description="Report start date",
    )
    date_to: date = Field(
        ...,
        description="Report end date",
    )

    # Filters
    payment_types: Optional[List[PaymentType]] = Field(
        None,
        max_length=10,
        description="Include specific payment types",
    )
    payment_methods: Optional[List[PaymentMethod]] = Field(
        None,
        max_length=10,
        description="Include specific payment methods",
    )

    # Grouping
    group_by: str = Field(
        "day",
        pattern=r"^(day|week|month|payment_type|payment_method)$",
        description="How to group report data",
    )

    # Format
    format: str = Field(
        "pdf",
        pattern=r"^(pdf|excel|csv)$",
        description="Report format",
    )

    # Include Details
    include_transaction_details: bool = Field(
        True,
        description="Include detailed transaction list",
    )
    include_student_details: bool = Field(
        True,
        description="Include student information",
    )
    include_charts: bool = Field(
        True,
        description="Include charts and visualizations",
    )

    @field_validator("date_to")
    @classmethod
    def validate_date_range(cls, v: date, info) -> date:
        """Validate date range."""
        date_from = info.data.get("date_from")
        if date_from is not None:
            if v < date_from:
                raise ValueError("date_to must be after or equal to date_from")
            
            # Limit report period to reasonable range
            days_diff = (v - date_from).days
            if days_diff > 365:
                raise ValueError(
                    f"Report period cannot exceed 365 days (got {days_diff} days)"
                )
        
        return v

    @field_validator("format", "group_by")
    @classmethod
    def normalize_enum_fields(cls, v: str) -> str:
        """Normalize enum fields."""
        return v.lower()


class PaymentExportRequest(BaseFilterSchema):
    """
    Export payments data request.
    
    Supports multiple export formats with customizable fields.
    """

    filters: PaymentFilterParams = Field(
        ...,
        description="Filter criteria for export",
    )

    # Format
    format: str = Field(
        "csv",
        pattern=r"^(csv|excel|pdf)$",
        description="Export format",
    )

    # Fields to Include
    include_payer_details: bool = Field(
        True,
        description="Include payer personal details",
    )
    include_gateway_details: bool = Field(
        False,
        description="Include payment gateway response data",
    )
    include_refund_details: bool = Field(
        True,
        description="Include refund information",
    )
    include_receipt_urls: bool = Field(
        True,
        description="Include receipt download URLs",
    )

    # Export Options
    split_by_status: bool = Field(
        False,
        description="Create separate sheets/files for each status",
    )
    include_summary_sheet: bool = Field(
        True,
        description="Include summary/analytics sheet (for Excel)",
    )

    @field_validator("format")
    @classmethod
    def normalize_format(cls, v: str) -> str:
        """Normalize format."""
        return v.lower()


class PaymentAnalyticsRequest(BaseFilterSchema):
    """
    Payment analytics request.
    
    Generates analytics and insights for payments within
    a specified date range.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Generate analytics for specific hostel (or all)",
    )

    # Date Range (Required)
    date_from: date = Field(
        ...,
        description="Analytics start date",
    )
    date_to: date = Field(
        ...,
        description="Analytics end date",
    )

    # Grouping/Aggregation
    group_by: str = Field(
        "day",
        pattern=r"^(day|week|month)$",
        description="Aggregate analytics by: day, week, or month",
    )

    # Metrics to Include
    include_revenue_metrics: bool = Field(
        True,
        description="Include revenue and collection metrics",
    )
    include_method_breakdown: bool = Field(
        True,
        description="Breakdown by payment method",
    )
    include_type_breakdown: bool = Field(
        True,
        description="Breakdown by payment type",
    )
    include_trends: bool = Field(
        True,
        description="Include trend analysis",
    )
    include_comparisons: bool = Field(
        False,
        description="Compare with previous period",
    )

    @field_validator("date_to")
    @classmethod
    def validate_date_range(cls, v: date, info) -> date:
        """Validate analytics date range."""
        date_from = info.data.get("date_from")
        if date_from is not None:
            if v < date_from:
                raise ValueError("date_to must be after or equal to date_from")
            
            # Limit to reasonable range (e.g., max 2 years)
            days_diff = (v - date_from).days
            if days_diff > 730:
                raise ValueError(
                    f"Analytics period cannot exceed 730 days (got {days_diff} days)"
                )
        
        return v

    @field_validator("group_by")
    @classmethod
    def normalize_group_by(cls, v: str) -> str:
        """Normalize group_by value."""
        return v.lower()

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\payment\payment_gateway.py ---
# --- File: app/schemas/payment/payment_gateway.py ---
"""
Payment gateway integration schemas.

This module defines schemas for payment gateway integration including
requests, responses, webhooks, callbacks, and refund operations.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, Optional
from uuid import UUID

from pydantic import Field, HttpUrl, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "GatewayRequest",
    "GatewayResponse",
    "GatewayWebhook",
    "GatewayCallback",
    "GatewayRefundRequest",
    "GatewayRefundResponse",
    "GatewayVerification",
]


class GatewayRequest(BaseSchema):
    """
    Payment gateway request payload.
    
    Contains all information needed to initiate payment
    with a payment gateway.
    """

    payment_id: UUID = Field(
        ...,
        description="Internal payment ID",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Payment amount",
    )
    currency: str = Field(
        ...,
        min_length=3,
        max_length=3,
        description="Currency code (ISO 4217)",
    )

    # Customer Details
    customer_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Customer full name",
    )
    customer_email: str = Field(
        ...,
        description="Customer email",
    )
    customer_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Customer phone",
    )

    # Order Details
    order_id: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Unique order ID",
    )
    description: str = Field(
        ...,
        min_length=5,
        max_length=500,
        description="Payment description",
    )

    # Callback URLs
    callback_url: HttpUrl = Field(
        ...,
        description="Server callback/webhook URL",
    )
    success_url: Optional[HttpUrl] = Field(
        None,
        description="Redirect URL on success",
    )
    failure_url: Optional[HttpUrl] = Field(
        None,
        description="Redirect URL on failure",
    )

    # Additional Metadata
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional gateway-specific metadata",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate amount is positive."""
        if v <= 0:
            raise ValueError("Amount must be greater than zero")
        return v.quantize(Decimal("0.01"))

    @field_validator("currency")
    @classmethod
    def validate_currency(cls, v: str) -> str:
        """Normalize currency code."""
        return v.upper().strip()


class GatewayResponse(BaseSchema):
    """
    Payment gateway response.
    
    Contains gateway response after payment initiation.
    """

    payment_id: UUID = Field(
        ...,
        description="Internal payment ID",
    )
    gateway_order_id: str = Field(
        ...,
        description="Gateway order/transaction ID",
    )
    gateway_payment_id: Optional[str] = Field(
        None,
        description="Gateway payment ID (set after completion)",
    )

    status: str = Field(
        ...,
        pattern=r"^(created|pending|authorized|captured|failed)$",
        description="Payment status from gateway",
    )

    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Payment amount",
    )
    currency: str = Field(
        ...,
        description="Currency code",
    )

    # Gateway-Specific Data
    gateway_response: Dict[str, Any] = Field(
        ...,
        description="Complete gateway response payload",
    )

    # Timestamps
    created_at: datetime = Field(
        ...,
        description="When gateway order was created",
    )
    updated_at: datetime = Field(
        ...,
        description="Last update timestamp",
    )

    # Checkout Details (for client-side integration)
    checkout_url: Optional[HttpUrl] = Field(
        None,
        description="Gateway checkout page URL",
    )
    checkout_token: Optional[str] = Field(
        None,
        description="Checkout session token",
    )


class GatewayWebhook(BaseCreateSchema):
    """
    Payment gateway webhook payload.
    
    Represents webhook/callback received from payment gateway
    for payment status updates.
    """

    event_type: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Event type from gateway (e.g., payment.success)",
    )

    # Gateway Identifiers
    gateway_order_id: str = Field(
        ...,
        description="Gateway order ID",
    )
    gateway_payment_id: Optional[str] = Field(
        None,
        description="Gateway payment ID",
    )

    # Payment Details
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Payment amount",
    )
    currency: str = Field(
        ...,
        description="Currency code",
    )
    status: str = Field(
        ...,
        description="Payment status",
    )

    # Full Webhook Payload
    raw_payload: Dict[str, Any] = Field(
        ...,
        description="Complete webhook payload for auditing",
    )

    # Signature Verification
    signature: str = Field(
        ...,
        description="Webhook signature for verification",
    )

    # Timestamp
    event_timestamp: datetime = Field(
        ...,
        description="When event occurred (from gateway)",
    )

    @field_validator("event_type")
    @classmethod
    def normalize_event_type(cls, v: str) -> str:
        """Normalize event type."""
        return v.lower().strip()


class GatewayCallback(BaseSchema):
    """
    Payment gateway callback processing result.
    
    Represents processed callback data after verification.
    """

    payment_id: UUID = Field(
        ...,
        description="Internal payment ID",
    )
    gateway_payment_id: str = Field(
        ...,
        description="Gateway payment ID",
    )

    success: bool = Field(
        ...,
        description="Whether payment was successful",
    )
    status: str = Field(
        ...,
        description="Payment status",
    )

    amount_paid: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount actually paid",
    )

    # Error Details (if failed)
    error_code: Optional[str] = Field(
        None,
        description="Error code if payment failed",
    )
    error_message: Optional[str] = Field(
        None,
        description="Error message if payment failed",
    )

    # Additional Data
    callback_data: Dict[str, Any] = Field(
        ...,
        description="Processed callback data",
    )

    # Verification
    signature_verified: bool = Field(
        ...,
        description="Whether signature was verified",
    )


class GatewayRefundRequest(BaseCreateSchema):
    """
    Refund request to payment gateway.
    
    Initiates refund through payment gateway.
    """

    payment_id: UUID = Field(
        ...,
        description="Payment ID to refund",
    )
    gateway_payment_id: str = Field(
        ...,
        description="Gateway payment ID",
    )

    refund_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount to refund",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for refund",
    )

    # Refund Speed
    refund_speed: str = Field(
        "normal",
        pattern=r"^(normal|instant)$",
        description="Refund processing speed",
    )

    # Metadata
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional refund metadata",
    )

    @field_validator("refund_amount")
    @classmethod
    def validate_refund_amount(cls, v: Decimal) -> Decimal:
        """Validate refund amount."""
        if v <= 0:
            raise ValueError("Refund amount must be greater than zero")
        return v.quantize(Decimal("0.01"))

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate refund reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Refund reason must be at least 10 characters")
        return v


class GatewayRefundResponse(BaseSchema):
    """
    Refund response from payment gateway.
    
    Contains refund processing details from gateway.
    """

    refund_id: str = Field(
        ...,
        description="Internal refund ID",
    )
    gateway_refund_id: str = Field(
        ...,
        description="Gateway refund transaction ID",
    )

    status: str = Field(
        ...,
        description="Refund status (pending/processed/failed)",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Refund amount",
    )

    # Timeline
    estimated_completion_date: Optional[date] = Field(
        None,
        description="Estimated date when refund will be completed",
    )

    # Gateway Response
    gateway_response: Dict[str, Any] = Field(
        ...,
        description="Complete gateway refund response",
    )

    # Additional Information
    refund_mode: Optional[str] = Field(
        None,
        description="Refund mode (source/bank_transfer/etc)",
    )
    refund_arn: Optional[str] = Field(
        None,
        description="Acquirer Reference Number for refund",
    )


class GatewayVerification(BaseSchema):
    """
    Payment verification request.
    
    Used to verify payment status with gateway.
    """

    payment_id: UUID = Field(
        ...,
        description="Internal payment ID",
    )
    gateway_payment_id: str = Field(
        ...,
        description="Gateway payment ID to verify",
    )

    # Verification Result
    verified: bool = Field(
        ...,
        description="Whether payment is verified",
    )
    status: str = Field(
        ...,
        description="Verified payment status",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Verified amount",
    )

    # Gateway Response
    verification_response: Dict[str, Any] = Field(
        ...,
        description="Gateway verification response",
    )

    # Timestamp
    verified_at: datetime = Field(
        ...,
        description="Verification timestamp",
    )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\payment\payment_ledger.py ---
# --- File: app/schemas/payment/payment_ledger.py ---
"""
Payment ledger and account statement schemas.

This module defines schemas for financial ledger management including
ledger entries, summaries, statements, and adjustments.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema

__all__ = [
    "LedgerEntry",
    "LedgerSummary",
    "AccountStatement",
    "TransactionHistory",
    "TransactionItem",
    "BalanceAdjustment",
    "WriteOff",
]


class LedgerEntry(BaseResponseSchema):
    """
    Individual ledger entry.
    
    Represents a single financial transaction in the student's ledger.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )

    # Entry Details
    entry_date: date = Field(
        ...,
        description="Date of entry",
    )
    entry_type: str = Field(
        ...,
        pattern=r"^(debit|credit)$",
        description="Entry type (debit increases balance, credit decreases)",
    )

    # Transaction Details
    transaction_type: str = Field(
        ...,
        description="Type of transaction (payment, charge, adjustment, etc.)",
    )
    amount: Decimal = Field(
        ...,
        decimal_places=2,
        description="Transaction amount",
    )

    # Running Balance
    balance_before: Decimal = Field(
        ...,
        decimal_places=2,
        description="Balance before this entry",
    )
    balance_after: Decimal = Field(
        ...,
        decimal_places=2,
        description="Balance after this entry",
    )

    # Reference
    payment_id: Optional[UUID] = Field(
        None,
        description="Associated payment ID",
    )
    payment_reference: Optional[str] = Field(
        None,
        description="Payment reference number",
    )

    # Description
    description: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Entry description",
    )

    # Metadata
    created_by: Optional[UUID] = Field(
        None,
        description="User who created this entry",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes",
    )

    @computed_field
    @property
    def is_debit(self) -> bool:
        """Check if entry is a debit."""
        return self.entry_type == "debit"

    @computed_field
    @property
    def is_credit(self) -> bool:
        """Check if entry is a credit."""
        return self.entry_type == "credit"


class LedgerSummary(BaseSchema):
    """
    Ledger summary for a student.
    
    Provides aggregate financial information.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    student_name: str = Field(
        ...,
        description="Student name",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )

    # Current Balance
    current_balance: Decimal = Field(
        ...,
        decimal_places=2,
        description="Current outstanding balance",
    )

    # Breakdown
    total_charges: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total charges (debits)",
    )
    total_payments: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total payments (credits)",
    )
    total_refunds: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total refunds received",
    )

    # Outstanding
    total_due: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total amount currently due",
    )
    overdue_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount that is overdue",
    )

    # Last Transaction
    last_transaction_date: Optional[date] = Field(
        None,
        description="Date of last transaction",
    )
    last_payment_date: Optional[date] = Field(
        None,
        description="Date of last payment",
    )

    @computed_field
    @property
    def net_amount(self) -> Decimal:
        """Calculate net amount (charges - payments)."""
        return (self.total_charges - self.total_payments).quantize(Decimal("0.01"))

    @computed_field
    @property
    def has_overdue_balance(self) -> bool:
        """Check if there's any overdue amount."""
        return self.overdue_amount > Decimal("0")

    @computed_field
    @property
    def account_status(self) -> str:
        """
        Determine account status.
        
        Returns: "current", "due", or "overdue"
        """
        if self.overdue_amount > 0:
            return "overdue"
        elif self.total_due > 0:
            return "due"
        else:
            return "current"


class AccountStatement(BaseSchema):
    """
    Account statement for a period.
    
    Detailed statement of all transactions for a student.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    student_name: str = Field(
        ...,
        description="Student name",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )

    # Statement Period
    statement_period_start: date = Field(
        ...,
        description="Statement period start date",
    )
    statement_period_end: date = Field(
        ...,
        description="Statement period end date",
    )
    generated_at: datetime = Field(
        ...,
        description="When statement was generated",
    )

    # Opening Balance
    opening_balance: Decimal = Field(
        ...,
        decimal_places=2,
        description="Balance at start of period",
    )

    # Transactions
    entries: List[LedgerEntry] = Field(
        default_factory=list,
        description="List of ledger entries for the period",
    )

    # Summary
    total_debits: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total debits in period",
    )
    total_credits: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total credits in period",
    )

    # Closing Balance
    closing_balance: Decimal = Field(
        ...,
        decimal_places=2,
        description="Balance at end of period",
    )

    # Download Link
    pdf_url: Optional[str] = Field(
        None,
        description="URL to download PDF statement",
    )

    @computed_field
    @property
    def net_change(self) -> Decimal:
        """Calculate net change in balance."""
        return (self.closing_balance - self.opening_balance).quantize(Decimal("0.01"))

    @computed_field
    @property
    def transaction_count(self) -> int:
        """Get total number of transactions."""
        return len(self.entries)


class TransactionItem(BaseSchema):
    """
    Individual transaction in history.
    
    Simplified transaction for history views.
    """

    transaction_id: UUID = Field(
        ...,
        description="Transaction ID",
    )
    transaction_date: datetime = Field(
        ...,
        description="Transaction timestamp",
    )
    transaction_type: str = Field(
        ...,
        description="Type of transaction",
    )

    amount: Decimal = Field(
        ...,
        decimal_places=2,
        description="Transaction amount",
    )
    balance_after: Decimal = Field(
        ...,
        decimal_places=2,
        description="Balance after transaction",
    )

    description: str = Field(
        ...,
        description="Transaction description",
    )
    payment_reference: Optional[str] = Field(
        None,
        description="Payment reference if applicable",
    )

    status: str = Field(
        ...,
        description="Transaction status",
    )


class TransactionHistory(BaseSchema):
    """
    Transaction history for a student.
    
    Paginated list of transactions with metadata.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )

    # Transactions
    transactions: List[TransactionItem] = Field(
        default_factory=list,
        description="List of transactions",
    )

    # Pagination
    total_transactions: int = Field(
        ...,
        ge=0,
        description="Total number of transactions",
    )
    page: int = Field(
        ...,
        ge=1,
        description="Current page number",
    )
    page_size: int = Field(
        ...,
        ge=1,
        description="Items per page",
    )

    @computed_field
    @property
    def total_pages(self) -> int:
        """Calculate total pages."""
        if self.page_size == 0:
            return 0
        return (self.total_transactions + self.page_size - 1) // self.page_size


class BalanceAdjustment(BaseSchema):
    """
    Manual balance adjustment (admin only).
    
    Used for corrections, waivers, or special adjustments.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )

    # Adjustment Details
    adjustment_type: str = Field(
        ...,
        pattern=r"^(debit|credit)$",
        description="Type of adjustment",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Adjustment amount",
    )

    # Justification
    reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Detailed reason for adjustment",
    )

    # Authorization
    adjusted_by: UUID = Field(
        ...,
        description="Admin who made the adjustment",
    )
    adjustment_date: date = Field(
        ...,
        description="Date of adjustment",
    )

    # Documentation
    notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional notes",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate amount is positive."""
        if v <= 0:
            raise ValueError("Adjustment amount must be greater than zero")
        return v.quantize(Decimal("0.01"))

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reason is detailed."""
        v = v.strip()
        if len(v) < 20:
            raise ValueError("Adjustment reason must be at least 20 characters")
        return v


class WriteOff(BaseSchema):
    """
    Write off outstanding amount.
    
    Used to formally write off uncollectable debts.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount to write off",
    )

    # Justification
    reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Detailed reason for write-off",
    )

    # Authorization
    approved_by: UUID = Field(
        ...,
        description="Admin who approved write-off",
    )
    approval_date: date = Field(
        ...,
        description="Date of approval",
    )

    # Documentation
    supporting_documents: List[str] = Field(
        default_factory=list,
        description="URLs to supporting documents",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate amount."""
        if v <= 0:
            raise ValueError("Write-off amount must be greater than zero")
        return v.quantize(Decimal("0.01"))

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reason is detailed."""
        v = v.strip()
        if len(v) < 20:
            raise ValueError("Write-off reason must be at least 20 characters")
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\payment\payment_refund.py ---
# --- File: app/schemas/payment/payment_refund.py ---
"""
Payment refund schemas.

This module defines schemas for refund requests, responses,
status tracking, and approval workflows.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "RefundRequest",
    "RefundResponse",
    "RefundStatus",
    "RefundApproval",
    "RefundList",
    "RefundListItem",
]


class RefundRequest(BaseCreateSchema):
    """
    Payment refund request schema.
    
    Used to initiate refund of a completed payment.
    """

    payment_id: UUID = Field(
        ...,
        description="Payment ID to refund",
    )
    refund_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount to refund (must not exceed payment amount)",
    )

    refund_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for refund",
    )

    # Refund Type
    refund_type: str = Field(
        "full",
        pattern=r"^(full|partial)$",
        description="Whether this is a full or partial refund",
    )

    # Refund Method
    refund_method: str = Field(
        "original_source",
        pattern=r"^(original_source|bank_transfer|cash|cheque)$",
        description="How to process the refund",
    )

    # Bank Details (if refund_method is bank_transfer)
    bank_account_number: Optional[str] = Field(
        None,
        max_length=20,
        description="Bank account number for transfer",
    )
    bank_ifsc_code: Optional[str] = Field(
        None,
        pattern=r"^[A-Z]{4}0[A-Z0-9]{6}$",
        description="IFSC code for bank transfer",
    )
    account_holder_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Name of account holder",
    )

    # Additional Details
    admin_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Internal admin notes",
    )

    @field_validator("refund_amount")
    @classmethod
    def validate_refund_amount(cls, v: Decimal) -> Decimal:
        """Validate refund amount is positive."""
        if v <= 0:
            raise ValueError("Refund amount must be greater than zero")
        return v.quantize(Decimal("0.01"))

    @field_validator("refund_reason")
    @classmethod
    def validate_refund_reason(cls, v: str) -> str:
        """Validate refund reason is meaningful."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Refund reason must be at least 10 characters")
        return v

    @model_validator(mode="after")
    def validate_bank_details(self) -> "RefundRequest":
        """Validate bank details if refund method is bank transfer."""
        if self.refund_method == "bank_transfer":
            if not all([
                self.bank_account_number,
                self.bank_ifsc_code,
                self.account_holder_name,
            ]):
                raise ValueError(
                    "Bank account details (account_number, IFSC, account_holder_name) "
                    "are required for bank transfer refunds"
                )
        
        return self

    @field_validator("bank_ifsc_code")
    @classmethod
    def validate_ifsc_code(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize IFSC code."""
        if v is not None:
            v = v.upper().strip()
            # IFSC format: 4 letters, 0, then 6 alphanumeric
            if not v or len(v) != 11:
                raise ValueError("IFSC code must be 11 characters")
        return v


class RefundResponse(BaseResponseSchema):
    """
    Refund response after processing refund request.
    
    Contains refund details and processing information.
    """

    refund_id: UUID = Field(
        ...,
        description="Unique refund identifier",
    )
    payment_id: UUID = Field(
        ...,
        description="Original payment ID",
    )
    payment_reference: str = Field(
        ...,
        description="Original payment reference",
    )

    refund_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Refund amount",
    )
    refund_status: str = Field(
        ...,
        pattern=r"^(pending|processing|completed|failed)$",
        description="Current refund status",
    )

    # Processing Details
    refund_method: str = Field(
        ...,
        description="Refund method",
    )
    refund_reference: Optional[str] = Field(
        None,
        description="Refund transaction reference number",
    )

    # Timeline
    requested_at: datetime = Field(
        ...,
        description="When refund was requested",
    )
    processed_at: Optional[datetime] = Field(
        None,
        description="When refund processing started",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="When refund was completed",
    )
    estimated_completion_date: Optional[date] = Field(
        None,
        description="Estimated completion date",
    )

    # Destination
    refunded_to: str = Field(
        ...,
        description="Where refund was sent (account details/original source)",
    )

    message: str = Field(
        ...,
        description="User-friendly message about refund status",
    )


class RefundStatus(BaseSchema):
    """
    Refund status tracking schema.
    
    Provides detailed status information about a refund.
    """

    refund_id: UUID = Field(
        ...,
        description="Refund ID",
    )
    payment_reference: str = Field(
        ...,
        description="Original payment reference",
    )

    refund_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Refund amount",
    )
    currency: str = Field(
        ...,
        description="Currency code",
    )

    status: str = Field(
        ...,
        pattern=r"^(pending|processing|completed|failed|cancelled)$",
        description="Current refund status",
    )

    # Timeline
    requested_at: datetime = Field(
        ...,
        description="Request timestamp",
    )
    processing_started_at: Optional[datetime] = Field(
        None,
        description="Processing start timestamp",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="Completion timestamp",
    )

    # Progress Tracking
    days_since_request: int = Field(
        ...,
        ge=0,
        description="Number of days since refund was requested",
    )

    # Failure Details
    failure_reason: Optional[str] = Field(
        None,
        description="Reason for refund failure if applicable",
    )

    # Next Steps
    next_action: Optional[str] = Field(
        None,
        description="Next action required (if any)",
    )
    expected_completion_date: Optional[date] = Field(
        None,
        description="Expected completion date",
    )

    @computed_field
    @property
    def is_completed(self) -> bool:
        """Check if refund is completed."""
        return self.status == "completed"

    @computed_field
    @property
    def is_pending_approval(self) -> bool:
        """Check if refund is pending approval."""
        return self.status == "pending"


class RefundApproval(BaseCreateSchema):
    """
    Refund approval/rejection schema (admin only).
    
    Used by admins to approve or reject refund requests.
    """

    refund_id: UUID = Field(
        ...,
        description="Refund ID to approve/reject",
    )
    approved: bool = Field(
        ...,
        description="Whether to approve (True) or reject (False)",
    )

    # If Approved
    processing_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Processing notes (visible to staff)",
    )

    # If Rejected
    rejection_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for rejection (sent to requester)",
    )

    @model_validator(mode="after")
    def validate_approval_fields(self) -> "RefundApproval":
        """Validate approval/rejection fields."""
        if not self.approved and not self.rejection_reason:
            raise ValueError(
                "rejection_reason is required when refund is rejected"
            )
        
        return self

    @field_validator("rejection_reason")
    @classmethod
    def validate_rejection_reason(cls, v: Optional[str]) -> Optional[str]:
        """Validate rejection reason."""
        if v is not None:
            v = v.strip()
            if len(v) < 10:
                raise ValueError(
                    "Rejection reason must be at least 10 characters"
                )
        return v


class RefundListItem(BaseSchema):
    """
    Refund list item for summary views.
    
    Minimal schema for displaying refunds in lists.
    """

    refund_id: UUID = Field(..., description="Refund ID")
    payment_reference: str = Field(..., description="Payment reference")
    student_name: str = Field(..., description="Student/payer name")

    refund_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Refund amount",
    )
    status: str = Field(..., description="Refund status")

    requested_at: datetime = Field(..., description="Request timestamp")
    completed_at: Optional[datetime] = Field(None, description="Completion timestamp")

    @computed_field
    @property
    def processing_days(self) -> int:
        """Calculate days taken to process."""
        if self.completed_at:
            return (self.completed_at - self.requested_at).days
        return (datetime.utcnow() - self.requested_at).days


class RefundList(BaseSchema):
    """
    List of refunds with summary.
    
    Contains collection of refunds with aggregate information.
    """

    total_refunds: int = Field(
        ...,
        ge=0,
        description="Total number of refunds",
    )
    total_amount_refunded: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total amount refunded",
    )

    refunds: List[RefundListItem] = Field(
        default_factory=list,
        description="List of refund items",
    )

    @computed_field
    @property
    def average_refund_amount(self) -> Decimal:
        """Calculate average refund amount."""
        if self.total_refunds == 0:
            return Decimal("0.00")
        return (self.total_amount_refunded / self.total_refunds).quantize(
            Decimal("0.01")
        )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\payment\payment_reminder.py ---
# --- File: app/schemas/payment/payment_reminder.py ---
"""
Payment reminder schemas.

This module defines schemas for payment reminder configuration,
logging, manual sending, and statistics.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator, computed_field

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
)

__all__ = [
    "ReminderConfig",
    "ReminderLog",
    "SendReminderRequest",
    "ReminderBatch",
    "ReminderStats",
]


class ReminderConfig(BaseSchema):
    """
    Payment reminder configuration for a hostel.
    
    Defines when and how payment reminders should be sent.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )

    # Reminder Timing
    days_before_due: List[int] = Field(
        default_factory=lambda: [7, 3, 1],
        min_length=1,
        max_length=10,
        description="Days before due date to send reminders",
    )
    days_after_due: List[int] = Field(
        default_factory=lambda: [1, 3, 7, 15],
        min_length=1,
        max_length=10,
        description="Days after due date for overdue reminders",
    )

    # Communication Channels
    send_email: bool = Field(
        True,
        description="Send email reminders",
    )
    send_sms: bool = Field(
        True,
        description="Send SMS reminders",
    )
    send_push: bool = Field(
        True,
        description="Send push notifications",
    )

    # Escalation
    escalate_after_days: int = Field(
        15,
        ge=1,
        le=90,
        description="Escalate to admin after this many days overdue",
    )

    # Templates
    email_template_id: Optional[UUID] = Field(
        None,
        description="Custom email template ID",
    )
    sms_template_id: Optional[UUID] = Field(
        None,
        description="Custom SMS template ID",
    )

    # Status
    is_active: bool = Field(
        True,
        description="Whether reminder system is active",
    )

    @field_validator("days_before_due", "days_after_due")
    @classmethod
    def validate_days_list(cls, v: List[int]) -> List[int]:
        """Validate days lists."""
        if not v:
            raise ValueError("At least one reminder day must be configured")
        
        # Ensure all values are positive
        if any(day < 0 for day in v):
            raise ValueError("Days must be non-negative")
        
        # Remove duplicates and sort
        return sorted(set(v))

    @model_validator(mode="after")
    def validate_channels(self) -> "ReminderConfig":
        """Ensure at least one channel is enabled."""
        if not any([self.send_email, self.send_sms, self.send_push]):
            raise ValueError(
                "At least one communication channel must be enabled"
            )
        return self


class ReminderLog(BaseResponseSchema):
    """
    Payment reminder log entry.
    
    Records details of a sent reminder.
    """

    payment_id: UUID = Field(
        ...,
        description="Payment ID",
    )
    payment_reference: str = Field(
        ...,
        description="Payment reference",
    )

    # Student Information
    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    student_name: str = Field(
        ...,
        description="Student name",
    )
    student_email: str = Field(
        ...,
        description="Student email",
    )
    student_phone: str = Field(
        ...,
        description="Student phone",
    )

    # Reminder Details
    reminder_type: str = Field(
        ...,
        pattern=r"^(due_soon|overdue|final_notice)$",
        description="Type of reminder",
    )
    reminder_channel: str = Field(
        ...,
        pattern=r"^(email|sms|push)$",
        description="Communication channel used",
    )

    # Delivery Status
    sent_at: datetime = Field(
        ...,
        description="When reminder was sent",
    )
    delivery_status: str = Field(
        ...,
        pattern=r"^(sent|delivered|failed|bounced)$",
        description="Delivery status",
    )

    # Content
    subject: Optional[str] = Field(
        None,
        description="Email subject (if email)",
    )
    message_preview: str = Field(
        ...,
        max_length=200,
        description="First 200 characters of message",
    )

    # Engagement Tracking
    opened: bool = Field(
        False,
        description="Whether email was opened",
    )
    clicked: bool = Field(
        False,
        description="Whether any link was clicked",
    )

    # Error Details (if failed)
    error_message: Optional[str] = Field(
        None,
        description="Error message if delivery failed",
    )

    @computed_field
    @property
    def was_successful(self) -> bool:
        """Check if reminder was successfully delivered."""
        return self.delivery_status in ["sent", "delivered"]


class SendReminderRequest(BaseCreateSchema):
    """
    Request to send payment reminder manually.
    
    Allows manual triggering of reminders for specific payments,
    students, or entire hostel.
    """

    # Target Selection (one of these must be provided)
    payment_id: Optional[UUID] = Field(
        None,
        description="Send reminder for specific payment",
    )
    student_id: Optional[UUID] = Field(
        None,
        description="Send reminders for all due payments of student",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Send reminders for all due payments in hostel",
    )

    # Reminder Settings
    reminder_type: str = Field(
        "overdue",
        pattern=r"^(due_soon|overdue|final_notice)$",
        description="Type of reminder to send",
    )

    # Channel Selection
    channels: List[str] = Field(
        default_factory=lambda: ["email", "sms"],
        description="Channels to use for reminder",
    )

    # Custom Message
    custom_message: Optional[str] = Field(
        None,
        max_length=500,
        description="Custom message to append to reminder",
    )

    @model_validator(mode="after")
    def validate_target_selection(self) -> "SendReminderRequest":
        """Ensure exactly one target is selected."""
        targets = [self.payment_id, self.student_id, self.hostel_id]
        selected = sum(1 for t in targets if t is not None)
        
        if selected == 0:
            raise ValueError(
                "One of payment_id, student_id, or hostel_id must be provided"
            )
        
        if selected > 1:
            raise ValueError(
                "Only one of payment_id, student_id, or hostel_id can be provided"
            )
        
        return self

    @field_validator("channels")
    @classmethod
    def validate_channels(cls, v: List[str]) -> List[str]:
        """Validate channels list."""
        if not v:
            raise ValueError("At least one channel must be specified")
        
        valid_channels = ["email", "sms", "push"]
        invalid = [ch for ch in v if ch not in valid_channels]
        if invalid:
            raise ValueError(
                f"Invalid channels: {', '.join(invalid)}. "
                f"Valid: {', '.join(valid_channels)}"
            )
        
        # Remove duplicates
        return list(dict.fromkeys(v))


class ReminderBatch(BaseSchema):
    """
    Batch reminder sending result.
    
    Contains information about a bulk reminder operation.
    """

    batch_id: UUID = Field(
        ...,
        description="Unique batch identifier",
    )

    # Processing Stats
    total_payments: int = Field(
        ...,
        ge=0,
        description="Total payments processed",
    )
    reminders_sent: int = Field(
        ...,
        ge=0,
        description="Number of reminders successfully sent",
    )
    reminders_failed: int = Field(
        ...,
        ge=0,
        description="Number of failed reminders",
    )

    # Breakdown by Channel
    email_sent: int = Field(
        ...,
        ge=0,
        description="Emails sent",
    )
    sms_sent: int = Field(
        ...,
        ge=0,
        description="SMS sent",
    )
    push_sent: int = Field(
        ...,
        ge=0,
        description="Push notifications sent",
    )

    # Timing
    started_at: datetime = Field(
        ...,
        description="When batch processing started",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="When batch processing completed",
    )

    # Status
    status: str = Field(
        ...,
        pattern=r"^(processing|completed|failed)$",
        description="Batch processing status",
    )

    @computed_field
    @property
    def success_rate(self) -> float:
        """Calculate success rate as percentage."""
        total = self.reminders_sent + self.reminders_failed
        if total == 0:
            return 0.0
        return round((self.reminders_sent / total) * 100, 2)

    @computed_field
    @property
    def total_channels_used(self) -> int:
        """Count total reminder sends across all channels."""
        return self.email_sent + self.sms_sent + self.push_sent


class ReminderStats(BaseSchema):
    """
    Payment reminder statistics.
    
    Provides analytics about reminder effectiveness.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    period_start: date = Field(
        ...,
        description="Statistics period start",
    )
    period_end: date = Field(
        ...,
        description="Statistics period end",
    )

    # Volume
    total_reminders_sent: int = Field(
        ...,
        ge=0,
        description="Total reminders sent in period",
    )

    # By Type
    due_soon_reminders: int = Field(
        ...,
        ge=0,
        description="Due soon reminders",
    )
    overdue_reminders: int = Field(
        ...,
        ge=0,
        description="Overdue reminders",
    )
    final_notices: int = Field(
        ...,
        ge=0,
        description="Final notices",
    )

    # By Channel
    email_reminders: int = Field(
        ...,
        ge=0,
        description="Email reminders",
    )
    sms_reminders: int = Field(
        ...,
        ge=0,
        description="SMS reminders",
    )
    push_reminders: int = Field(
        ...,
        ge=0,
        description="Push notifications",
    )

    # Effectiveness
    payment_rate_after_reminder: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of reminded students who paid",
    )
    average_days_to_payment: Decimal = Field(
        ...,
        ge=0,
        description="Average days from reminder to payment",
    )

    @computed_field
    @property
    def most_effective_channel(self) -> str:
        """Determine most used channel."""
        channels = {
            "email": self.email_reminders,
            "sms": self.sms_reminders,
            "push": self.push_reminders,
        }
        return max(channels, key=channels.get)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\payment\payment_request.py ---
# --- File: app/schemas/payment/payment_request.py ---
"""
Payment request schemas for initiating payments.

This module defines schemas for various types of payment requests
including online payments, manual payments, and bulk operations.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, HttpUrl, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import PaymentMethod, PaymentType

__all__ = [
    "PaymentRequest",
    "PaymentInitiation",
    "ManualPaymentRequest",
    "BulkPaymentRequest",
    "SinglePaymentRecord",
]


class PaymentRequest(BaseCreateSchema):
    """
    Online payment request schema.
    
    Used to initiate online payments through payment gateways.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    student_id: Optional[UUID] = Field(
        None,
        description="Student ID (for recurring fee payments)",
    )
    booking_id: Optional[UUID] = Field(
        None,
        description="Booking ID (for booking-related payments)",
    )

    payment_type: PaymentType = Field(
        ...,
        description="Type of payment",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Amount to pay",
    )

    # Payment Period (for recurring fees)
    payment_period_start: Optional[date] = Field(
        None,
        description="Period start date",
    )
    payment_period_end: Optional[date] = Field(
        None,
        description="Period end date",
    )

    # Payment Gateway Selection
    payment_method: PaymentMethod = Field(
        PaymentMethod.PAYMENT_GATEWAY,
        description="Payment method (must be online for this request type)",
    )
    payment_gateway: str = Field(
        "razorpay",
        pattern=r"^(razorpay|stripe|paytm|phonepe)$",
        description="Preferred payment gateway",
    )

    # Return URLs
    success_url: Optional[HttpUrl] = Field(
        None,
        description="URL to redirect on successful payment",
    )
    failure_url: Optional[HttpUrl] = Field(
        None,
        description="URL to redirect on payment failure",
    )
    cancel_url: Optional[HttpUrl] = Field(
        None,
        description="URL to redirect if payment is cancelled",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate payment amount."""
        if v <= 0:
            raise ValueError("Payment amount must be greater than zero")
        
        # Minimum online payment amount (to avoid gateway fees being higher than payment)
        min_amount = Decimal("1.00")
        if v < min_amount:
            raise ValueError(
                f"Minimum payment amount for online payments is ₹{min_amount}"
            )
        
        return v.quantize(Decimal("0.01"))

    @model_validator(mode="after")
    def validate_payment_method(self) -> "PaymentRequest":
        """Ensure payment method is suitable for online payment."""
        online_methods = [
            PaymentMethod.PAYMENT_GATEWAY,
            PaymentMethod.UPI,
            PaymentMethod.CARD,
            PaymentMethod.NET_BANKING,
        ]
        
        if self.payment_method not in online_methods:
            raise ValueError(
                f"Payment method {self.payment_method} not supported for online payments. "
                f"Use ManualPaymentRequest for offline payments."
            )
        
        return self

    @model_validator(mode="after")
    def validate_entity_reference(self) -> "PaymentRequest":
        """Ensure at least student_id or booking_id is provided."""
        if not self.student_id and not self.booking_id:
            raise ValueError(
                "Either student_id or booking_id must be provided"
            )
        
        return self


class PaymentInitiation(BaseSchema):
    """
    Payment initiation response from gateway.
    
    Contains all information needed to complete payment on client side.
    """

    payment_id: UUID = Field(
        ...,
        description="Internal payment ID",
    )
    payment_reference: str = Field(
        ...,
        description="Human-readable payment reference",
    )

    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Payment amount",
    )
    currency: str = Field(
        ...,
        min_length=3,
        max_length=3,
        description="Currency code",
    )

    # Gateway Details
    gateway: str = Field(
        ...,
        description="Payment gateway being used",
    )
    gateway_order_id: str = Field(
        ...,
        description="Order ID from payment gateway",
    )
    gateway_key: str = Field(
        ...,
        description="Gateway API key for client-side integration",
    )

    # Checkout Information
    checkout_url: Optional[HttpUrl] = Field(
        None,
        description="Direct checkout URL (for redirect-based flows)",
    )
    checkout_token: Optional[str] = Field(
        None,
        description="Checkout session token",
    )

    # Gateway-Specific Options
    gateway_options: dict = Field(
        ...,
        description="Gateway-specific configuration for client SDK",
    )

    # Expiry
    expires_at: Optional[datetime] = Field(
        None,
        description="When this payment initiation expires",
    )


class ManualPaymentRequest(BaseCreateSchema):
    """
    Manual payment recording schema.
    
    Used for recording offline payments (cash, cheque, bank transfer)
    collected by hostel staff.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    student_id: UUID = Field(
        ...,
        description="Student ID",
    )

    payment_type: PaymentType = Field(
        ...,
        description="Type of payment",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Payment amount",
    )

    payment_method: PaymentMethod = Field(
        ...,
        description="Payment method (cash, cheque, bank_transfer)",
    )

    # Cheque Details
    cheque_number: Optional[str] = Field(
        None,
        max_length=50,
        description="Cheque number (if payment_method is cheque)",
    )
    cheque_date: Optional[date] = Field(
        None,
        description="Cheque date",
    )
    bank_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Bank name (for cheque/bank transfer)",
    )

    # Bank Transfer Details
    transaction_reference: Optional[str] = Field(
        None,
        max_length=100,
        description="Bank transaction reference number",
    )
    transfer_date: Optional[date] = Field(
        None,
        description="Date of bank transfer",
    )

    # Payment Period
    payment_period_start: Optional[date] = Field(
        None,
        description="Period start date",
    )
    payment_period_end: Optional[date] = Field(
        None,
        description="Period end date",
    )

    # Collection Details
    collected_by: UUID = Field(
        ...,
        description="Staff member who collected the payment",
    )
    collection_date: date = Field(
        ...,
        description="Date payment was collected",
    )

    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes",
    )

    @field_validator("payment_method")
    @classmethod
    def validate_payment_method(cls, v: PaymentMethod) -> PaymentMethod:
        """Ensure payment method is suitable for manual recording."""
        manual_methods = [
            PaymentMethod.CASH,
            PaymentMethod.CHEQUE,
            PaymentMethod.BANK_TRANSFER,
        ]
        
        if v not in manual_methods:
            raise ValueError(
                f"Payment method {v} not supported for manual recording. "
                f"Supported: {', '.join(m.value for m in manual_methods)}"
            )
        
        return v

    @model_validator(mode="after")
    def validate_cheque_details(self) -> "ManualPaymentRequest":
        """Validate cheque details if payment method is cheque."""
        if self.payment_method == PaymentMethod.CHEQUE:
            if not self.cheque_number:
                raise ValueError("cheque_number is required for cheque payments")
            
            if not self.cheque_date:
                raise ValueError("cheque_date is required for cheque payments")
            
            # Validate cheque date is not in the future
            if self.cheque_date > date.today():
                raise ValueError("Cheque date cannot be in the future")
        
        return self

    @model_validator(mode="after")
    def validate_bank_transfer_details(self) -> "ManualPaymentRequest":
        """Validate bank transfer details if applicable."""
        if self.payment_method == PaymentMethod.BANK_TRANSFER:
            if not self.transaction_reference:
                raise ValueError(
                    "transaction_reference is required for bank transfers"
                )
            
            if not self.transfer_date:
                raise ValueError("transfer_date is required for bank transfers")
        
        return self

    @field_validator("collection_date")
    @classmethod
    def validate_collection_date(cls, v: date) -> date:
        """Validate collection date."""
        if v > date.today():
            raise ValueError("Collection date cannot be in the future")
        
        # Warn if collection date is too old
        days_ago = (date.today() - v).days
        if days_ago > 90:
            # Log warning
            pass
        
        return v


class SinglePaymentRecord(BaseSchema):
    """
    Single payment record in bulk operation.
    
    Minimal schema for individual payment within bulk request.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    payment_type: PaymentType = Field(
        ...,
        description="Payment type",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Payment amount",
    )
    payment_method: PaymentMethod = Field(
        ...,
        description="Payment method",
    )

    # Optional Fields
    transaction_reference: Optional[str] = Field(
        None,
        max_length=100,
        description="Transaction reference",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Payment notes",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate amount."""
        if v <= 0:
            raise ValueError("Amount must be greater than zero")
        return v.quantize(Decimal("0.01"))


class BulkPaymentRequest(BaseCreateSchema):
    """
    Record multiple payments in one operation.
    
    Used for batch recording of offline payments.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID for all payments",
    )
    payments: List[SinglePaymentRecord] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of payments to record (max 100)",
    )

    collected_by: UUID = Field(
        ...,
        description="Staff member who collected all payments",
    )
    collection_date: date = Field(
        ...,
        description="Date all payments were collected",
    )

    @field_validator("payments")
    @classmethod
    def validate_payments(cls, v: List[SinglePaymentRecord]) -> List[SinglePaymentRecord]:
        """Validate payments list."""
        if len(v) == 0:
            raise ValueError("At least one payment is required")
        
        if len(v) > 100:
            raise ValueError("Maximum 100 payments allowed per bulk operation")
        
        # Check for duplicate student IDs
        student_ids = [p.student_id for p in v]
        if len(student_ids) != len(set(student_ids)):
            raise ValueError(
                "Duplicate student IDs found. Each student can only appear once per bulk operation."
            )
        
        return v

    @field_validator("collection_date")
    @classmethod
    def validate_collection_date(cls, v: date) -> date:
        """Validate collection date."""
        if v > date.today():
            raise ValueError("Collection date cannot be in the future")
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\payment\payment_response.py ---
# --- File: app/schemas/payment/payment_response.py ---
"""
Payment response schemas for API responses.

This module defines response schemas for payment data including
basic responses, detailed information, receipts, and summaries.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import PaymentMethod, PaymentStatus, PaymentType

__all__ = [
    "PaymentResponse",
    "PaymentDetail",
    "PaymentReceipt",
    "PaymentListItem",
    "PaymentSummary",
    "PaymentAnalytics",
]


class PaymentResponse(BaseResponseSchema):
    """
    Standard payment response schema.
    
    Contains core payment information for API responses.
    """

    payment_reference: str = Field(
        ...,
        description="Unique payment reference number",
    )
    transaction_id: Optional[str] = Field(
        None,
        description="External transaction ID",
    )

    # Payer Information
    payer_id: UUID = Field(
        ...,
        description="Payer user ID",
    )
    payer_name: str = Field(
        ...,
        description="Payer full name",
    )

    # Hostel Information
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )

    # Payment Details
    payment_type: PaymentType = Field(
        ...,
        description="Type of payment",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Payment amount",
    )
    currency: str = Field(
        ...,
        description="Currency code",
    )

    # Payment Method
    payment_method: PaymentMethod = Field(
        ...,
        description="Payment method used",
    )
    payment_status: PaymentStatus = Field(
        ...,
        description="Current payment status",
    )

    # Timestamps
    paid_at: Optional[datetime] = Field(
        None,
        description="When payment was completed",
    )
    due_date: Optional[date] = Field(
        None,
        description="Payment due date",
    )
    is_overdue: bool = Field(
        ...,
        description="Whether payment is overdue",
    )

    # Receipt
    receipt_number: Optional[str] = Field(
        None,
        description="Receipt number if generated",
    )
    receipt_url: Optional[str] = Field(
        None,
        description="URL to download receipt",
    )

    @computed_field
    @property
    def amount_display(self) -> str:
        """Get formatted amount for display."""
        return f"{self.currency} {self.amount:,.2f}"

    @computed_field
    @property
    def status_badge_color(self) -> str:
        """Get color code for status badge."""
        color_map = {
            PaymentStatus.PENDING: "#FFA500",  # Orange
            PaymentStatus.PROCESSING: "#2196F3",  # Blue
            PaymentStatus.COMPLETED: "#4CAF50",  # Green
            PaymentStatus.FAILED: "#F44336",  # Red
            PaymentStatus.REFUNDED: "#9C27B0",  # Purple
            PaymentStatus.PARTIALLY_REFUNDED: "#FF9800",  # Amber
        }
        return color_map.get(self.payment_status, "#000000")


class PaymentDetail(BaseResponseSchema):
    """
    Detailed payment information schema.
    
    Contains complete payment details including payer info,
    gateway response, refund details, and collection information.
    """

    payment_reference: str = Field(
        ...,
        description="Payment reference",
    )
    transaction_id: Optional[str] = Field(
        None,
        description="Transaction ID",
    )

    # Payer Details
    payer_id: UUID = Field(..., description="Payer ID")
    payer_name: str = Field(..., description="Payer name")
    payer_email: str = Field(..., description="Payer email")
    payer_phone: str = Field(..., description="Payer phone")

    # Hostel Details
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")

    # Related Entities
    student_id: Optional[UUID] = Field(None, description="Student ID")
    student_name: Optional[str] = Field(None, description="Student name")
    booking_id: Optional[UUID] = Field(None, description="Booking ID")
    booking_reference: Optional[str] = Field(None, description="Booking reference")

    # Payment Details
    payment_type: PaymentType = Field(..., description="Payment type")
    amount: Decimal = Field(..., ge=0, decimal_places=2, description="Amount")
    currency: str = Field(..., description="Currency")

    # Payment Period
    payment_period_start: Optional[date] = Field(None, description="Period start")
    payment_period_end: Optional[date] = Field(None, description="Period end")

    # Payment Method
    payment_method: PaymentMethod = Field(..., description="Payment method")
    payment_gateway: Optional[str] = Field(None, description="Gateway used")

    # Status
    payment_status: PaymentStatus = Field(..., description="Payment status")
    paid_at: Optional[datetime] = Field(None, description="Payment completion time")
    failed_at: Optional[datetime] = Field(None, description="Payment failure time")
    failure_reason: Optional[str] = Field(None, description="Failure reason")

    # Gateway Response
    gateway_response: Optional[Dict] = Field(
        None,
        description="Raw gateway response data",
    )

    # Receipt
    receipt_number: Optional[str] = Field(None, description="Receipt number")
    receipt_url: Optional[str] = Field(None, description="Receipt download URL")
    receipt_generated_at: Optional[datetime] = Field(None, description="Receipt generation time")

    # Refund Information
    refund_amount: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Total refunded amount",
    )
    refund_status: str = Field(
        "none",
        description="Refund status",
    )
    refunded_at: Optional[datetime] = Field(None, description="Refund completion time")
    refund_transaction_id: Optional[str] = Field(None, description="Refund transaction ID")
    refund_reason: Optional[str] = Field(None, description="Refund reason")

    # Collection Information (for offline payments)
    collected_by: Optional[UUID] = Field(None, description="Staff who collected")
    collected_by_name: Optional[str] = Field(None, description="Collector name")
    collected_at: Optional[datetime] = Field(None, description="Collection timestamp")

    # Due Date
    due_date: Optional[date] = Field(None, description="Due date")
    is_overdue: bool = Field(..., description="Overdue status")

    # Reminders
    reminder_sent_count: int = Field(
        0,
        ge=0,
        description="Number of reminders sent",
    )
    last_reminder_sent_at: Optional[datetime] = Field(
        None,
        description="Last reminder timestamp",
    )

    # Notes
    notes: Optional[str] = Field(None, description="Additional notes")

    @computed_field
    @property
    def net_amount(self) -> Decimal:
        """Calculate net amount after refunds."""
        return (self.amount - self.refund_amount).quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_fully_refunded(self) -> bool:
        """Check if payment is fully refunded."""
        return self.refund_amount >= self.amount

    @computed_field
    @property
    def is_partially_refunded(self) -> bool:
        """Check if payment is partially refunded."""
        return Decimal("0") < self.refund_amount < self.amount

    @computed_field
    @property
    def days_overdue(self) -> int:
        """Calculate days overdue."""
        if not self.is_overdue or self.due_date is None:
            return 0
        return (date.today() - self.due_date).days

    @computed_field
    @property
    def payment_period_display(self) -> Optional[str]:
        """Get formatted payment period."""
        if self.payment_period_start and self.payment_period_end:
            return (
                f"{self.payment_period_start.strftime('%b %d, %Y')} - "
                f"{self.payment_period_end.strftime('%b %d, %Y')}"
            )
        return None


class PaymentReceipt(BaseSchema):
    """
    Payment receipt schema for printing/download.
    
    Contains all information needed for a formal payment receipt.
    """

    receipt_number: str = Field(
        ...,
        description="Unique receipt number",
    )
    payment_reference: str = Field(
        ...,
        description="Payment reference",
    )

    # Payer Information
    payer_name: str = Field(..., description="Payer name")
    payer_email: str = Field(..., description="Payer email")
    payer_phone: str = Field(..., description="Payer phone")

    # Hostel Information
    hostel_name: str = Field(..., description="Hostel name")
    hostel_address: str = Field(..., description="Hostel full address")
    hostel_phone: str = Field(..., description="Hostel contact phone")
    hostel_email: Optional[str] = Field(None, description="Hostel email")
    hostel_gstin: Optional[str] = Field(None, description="Hostel GST number")

    # Payment Details
    payment_type: str = Field(..., description="Payment type")
    amount: Decimal = Field(..., ge=0, decimal_places=2, description="Payment amount")
    amount_in_words: str = Field(..., description="Amount in words")
    currency: str = Field(..., description="Currency")

    payment_method: str = Field(..., description="Payment method")
    transaction_id: Optional[str] = Field(None, description="Transaction ID")

    # Payment Period
    payment_for_period: Optional[str] = Field(
        None,
        description="Period description (e.g., 'January 2024')",
    )

    # Dates
    payment_date: datetime = Field(..., description="Payment date")
    due_date: Optional[date] = Field(None, description="Due date")

    # Receipt Metadata
    receipt_generated_at: datetime = Field(..., description="Receipt generation time")
    receipt_url: str = Field(..., description="Receipt download URL")

    # Tax/GST Details
    tax_details: Optional[Dict] = Field(
        None,
        description="Tax breakdown if applicable",
    )

    # Additional Information
    remarks: Optional[str] = Field(None, description="Additional remarks")

    @computed_field
    @property
    def receipt_display_id(self) -> str:
        """Get formatted receipt ID for display."""
        return f"RCP-{self.receipt_number}"


class PaymentListItem(BaseSchema):
    """
    Payment list item for summary views.
    
    Optimized schema for displaying multiple payments.
    """

    id: UUID = Field(..., description="Payment ID")
    payment_reference: str = Field(..., description="Payment reference")
    payer_name: str = Field(..., description="Payer name")
    hostel_name: str = Field(..., description="Hostel name")

    payment_type: str = Field(..., description="Payment type")
    amount: Decimal = Field(..., ge=0, decimal_places=2, description="Amount")

    payment_method: str = Field(..., description="Payment method")
    payment_status: PaymentStatus = Field(..., description="Status")

    paid_at: Optional[datetime] = Field(None, description="Payment time")
    due_date: Optional[date] = Field(None, description="Due date")
    is_overdue: bool = Field(..., description="Overdue status")

    created_at: datetime = Field(..., description="Creation time")

    @computed_field
    @property
    def status_display(self) -> str:
        """Get user-friendly status display."""
        status_map = {
            PaymentStatus.PENDING: "Pending",
            PaymentStatus.PROCESSING: "Processing",
            PaymentStatus.COMPLETED: "Completed",
            PaymentStatus.FAILED: "Failed",
            PaymentStatus.REFUNDED: "Refunded",
            PaymentStatus.PARTIALLY_REFUNDED: "Partially Refunded",
        }
        return status_map.get(self.payment_status, "Unknown")


class PaymentSummary(BaseSchema):
    """
    Payment summary for student or hostel.
    
    Provides aggregate payment information and statistics.
    """

    entity_id: UUID = Field(
        ...,
        description="Entity ID (student or hostel)",
    )
    entity_type: str = Field(
        ...,
        pattern=r"^(student|hostel)$",
        description="Entity type",
    )

    # Totals
    total_paid: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total amount paid",
    )
    total_pending: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total pending amount",
    )
    total_overdue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total overdue amount",
    )

    # Last Payment
    last_payment_date: Optional[date] = Field(
        None,
        description="Date of last payment",
    )
    last_payment_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Amount of last payment",
    )

    # Next Payment
    next_payment_due_date: Optional[date] = Field(
        None,
        description="Next payment due date",
    )
    next_payment_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Next payment amount",
    )

    # Counts
    total_payments: int = Field(
        ...,
        ge=0,
        description="Total number of payments",
    )
    completed_payments: int = Field(
        ...,
        ge=0,
        description="Number of completed payments",
    )
    pending_payments: int = Field(
        ...,
        ge=0,
        description="Number of pending payments",
    )

    @computed_field
    @property
    def payment_health_score(self) -> str:
        """
        Calculate payment health status.
        
        Returns: "excellent", "good", "warning", or "critical"
        """
        if self.total_overdue > 0:
            return "critical"
        elif self.total_pending > self.total_paid:
            return "warning"
        elif self.pending_payments == 0:
            return "excellent"
        else:
            return "good"

    @computed_field
    @property
    def completion_rate(self) -> float:
        """Calculate payment completion rate as percentage."""
        if self.total_payments == 0:
            return 0.0
        return round((self.completed_payments / self.total_payments) * 100, 2)


class PaymentAnalytics(BaseSchema):
    """
    Payment analytics and statistics.
    
    Provides comprehensive analytics for reporting and insights.
    """

    # Time Period
    period_start: date = Field(..., description="Analytics period start")
    period_end: date = Field(..., description="Analytics period end")

    # Volume Metrics
    total_transactions: int = Field(..., ge=0, description="Total transactions")
    total_amount: Decimal = Field(..., ge=0, decimal_places=2, description="Total amount")
    
    # Status Breakdown
    completed_transactions: int = Field(..., ge=0)
    completed_amount: Decimal = Field(..., ge=0, decimal_places=2)
    pending_transactions: int = Field(..., ge=0)
    pending_amount: Decimal = Field(..., ge=0, decimal_places=2)
    failed_transactions: int = Field(..., ge=0)
    failed_amount: Decimal = Field(..., ge=0, decimal_places=2)

    # Payment Method Breakdown
    payment_by_method: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Amount by payment method",
    )

    # Payment Type Breakdown
    payment_by_type: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Amount by payment type",
    )

    # Averages
    average_transaction_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average transaction amount",
    )

    # Success Metrics
    success_rate: float = Field(
        ...,
        ge=0,
        le=100,
        description="Transaction success rate (%)",
    )

    # Collection Metrics
    collection_efficiency: float = Field(
        ...,
        ge=0,
        le=100,
        description="Percentage of dues collected on time",
    )

    @computed_field
    @property
    def total_revenue(self) -> Decimal:
        """Calculate total revenue (completed payments only)."""
        return self.completed_amount

    @computed_field
    @property
    def failure_rate(self) -> float:
        """Calculate transaction failure rate."""
        if self.total_transactions == 0:
            return 0.0
        return round((self.failed_transactions / self.total_transactions) * 100, 2)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\payment\payment_schedule.py ---
# --- File: app/schemas/payment/payment_schedule.py ---
"""
Payment schedule schemas for recurring payments.

This module defines schemas for managing payment schedules including
creation, updates, generation, and suspension of scheduled payments.
"""

from __future__ import annotations

from datetime import date, timedelta
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator, computed_field

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import FeeType, PaymentType

__all__ = [
    "PaymentSchedule",
    "ScheduleCreate",
    "ScheduleUpdate",
    "ScheduleGeneration",
    "ScheduledPaymentGenerated",
    "BulkScheduleCreate",
    "ScheduleSuspension",
]


class PaymentSchedule(BaseResponseSchema):
    """
    Payment schedule schema.
    
    Represents a recurring payment schedule for a student.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )

    # Schedule Details
    fee_type: FeeType = Field(
        ...,
        description="Fee type (monthly, quarterly, etc.)",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount per period",
    )

    # Schedule Period
    start_date: date = Field(
        ...,
        description="Schedule start date",
    )
    end_date: Optional[date] = Field(
        None,
        description="Schedule end date (null for indefinite)",
    )
    next_due_date: date = Field(
        ...,
        description="Next payment due date",
    )

    # Settings
    auto_generate_invoice: bool = Field(
        ...,
        description="Automatically generate invoices",
    )
    is_active: bool = Field(
        ...,
        description="Whether schedule is currently active",
    )

    @computed_field
    @property
    def is_indefinite(self) -> bool:
        """Check if schedule has no end date."""
        return self.end_date is None

    @computed_field
    @property
    def days_until_next_payment(self) -> int:
        """Calculate days until next payment."""
        return (self.next_due_date - date.today()).days

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if next payment is overdue."""
        return self.next_due_date < date.today()


class ScheduleCreate(BaseCreateSchema):
    """
    Create payment schedule schema.
    
    Used to set up a new recurring payment schedule for a student.
    """

    student_id: UUID = Field(
        ...,
        description="Student ID",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )

    # Schedule Configuration
    fee_type: FeeType = Field(
        ...,
        description="Fee type (monthly, quarterly, half-yearly, yearly)",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount to charge per period",
    )

    # Schedule Period
    start_date: date = Field(
        ...,
        description="When schedule should start",
    )
    end_date: Optional[date] = Field(
        None,
        description="When schedule should end (null for indefinite)",
    )

    # First Payment
    first_due_date: date = Field(
        ...,
        description="Due date for first payment",
    )

    # Settings
    auto_generate_invoice: bool = Field(
        True,
        description="Automatically generate invoices on due dates",
    )
    send_reminders: bool = Field(
        True,
        description="Send payment reminders",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate amount is positive."""
        if v <= 0:
            raise ValueError("Schedule amount must be greater than zero")
        
        # Sanity check
        max_amount = Decimal("100000.00")
        if v > max_amount:
            raise ValueError(
                f"Schedule amount (₹{v}) exceeds maximum (₹{max_amount})"
            )
        
        return v.quantize(Decimal("0.01"))

    @field_validator("start_date")
    @classmethod
    def validate_start_date(cls, v: date) -> date:
        """Validate start date is reasonable."""
        # Allow past dates for backdated schedules, but warn
        days_ago = (date.today() - v).days
        if days_ago > 365:
            # Log warning - might be data migration
            pass
        
        return v

    @model_validator(mode="after")
    def validate_date_range(self) -> "ScheduleCreate":
        """Validate schedule date range."""
        if self.end_date is not None:
            if self.end_date < self.start_date:
                raise ValueError(
                    f"End date ({self.end_date}) must be after "
                    f"start date ({self.start_date})"
                )
            
            # Check if end date is reasonable
            days_diff = (self.end_date - self.start_date).days
            if days_diff > 1825:  # 5 years
                # Log warning - very long schedule
                pass
        
        return self

    @model_validator(mode="after")
    def validate_first_due_date(self) -> "ScheduleCreate":
        """Validate first due date is within schedule period."""
        if self.first_due_date < self.start_date:
            raise ValueError(
                f"First due date ({self.first_due_date}) cannot be "
                f"before start date ({self.start_date})"
            )
        
        if self.end_date is not None and self.first_due_date > self.end_date:
            raise ValueError(
                f"First due date ({self.first_due_date}) cannot be "
                f"after end date ({self.end_date})"
            )
        
        return self


class ScheduleUpdate(BaseUpdateSchema):
    """
    Update payment schedule schema.
    
    Allows modification of schedule parameters.
    """

    amount: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Update amount per period",
    )
    next_due_date: Optional[date] = Field(
        None,
        description="Update next due date",
    )
    end_date: Optional[date] = Field(
        None,
        description="Update end date",
    )
    auto_generate_invoice: Optional[bool] = Field(
        None,
        description="Update auto-generation setting",
    )
    is_active: Optional[bool] = Field(
        None,
        description="Activate or deactivate schedule",
    )

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Validate amount if provided."""
        if v is not None:
            if v <= 0:
                raise ValueError("Amount must be greater than zero")
            return v.quantize(Decimal("0.01"))
        return v


class ScheduleGeneration(BaseSchema):
    """
    Generate scheduled payments schema.
    
    Used to manually trigger generation of scheduled payments
    for a specific period.
    """

    schedule_id: UUID = Field(
        ...,
        description="Schedule ID",
    )

    # Generation Period
    generate_from_date: date = Field(
        ...,
        description="Start date for payment generation",
    )
    generate_to_date: date = Field(
        ...,
        description="End date for payment generation",
    )

    # Options
    skip_if_already_paid: bool = Field(
        True,
        description="Skip generation if payment already exists and is paid",
    )
    send_notifications: bool = Field(
        True,
        description="Send notifications for generated payments",
    )

    @model_validator(mode="after")
    def validate_generation_period(self) -> "ScheduleGeneration":
        """Validate generation period."""
        if self.generate_to_date < self.generate_from_date:
            raise ValueError(
                f"End date ({self.generate_to_date}) must be after "
                f"start date ({self.generate_from_date})"
            )
        
        # Limit generation period to 1 year
        days_diff = (self.generate_to_date - self.generate_from_date).days
        if days_diff > 365:
            raise ValueError(
                f"Generation period cannot exceed 365 days (got {days_diff} days)"
            )
        
        return self


class ScheduledPaymentGenerated(BaseSchema):
    """
    Result of scheduled payment generation.
    
    Contains information about payments generated from schedule.
    """

    schedule_id: UUID = Field(
        ...,
        description="Schedule ID",
    )

    # Generation Results
    payments_generated: int = Field(
        ...,
        ge=0,
        description="Number of payments generated",
    )
    payments_skipped: int = Field(
        ...,
        ge=0,
        description="Number of payments skipped",
    )

    # Generated Payment IDs
    generated_payment_ids: List[UUID] = Field(
        default_factory=list,
        description="IDs of generated payments",
    )

    # Next Generation
    next_generation_date: date = Field(
        ...,
        description="When next generation should occur",
    )

    @computed_field
    @property
    def total_processed(self) -> int:
        """Calculate total payments processed."""
        return self.payments_generated + self.payments_skipped

    @computed_field
    @property
    def generation_success_rate(self) -> float:
        """Calculate percentage of successful generations."""
        if self.total_processed == 0:
            return 0.0
        return round((self.payments_generated / self.total_processed) * 100, 2)


class BulkScheduleCreate(BaseCreateSchema):
    """
    Create schedules for multiple students.
    
    Used for batch creation of payment schedules.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID for all schedules",
    )
    student_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of student IDs (max 100)",
    )

    # Common Schedule Configuration
    fee_type: FeeType = Field(
        ...,
        description="Fee type for all schedules",
    )
    amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Amount per period for all schedules",
    )

    # Common Schedule Period
    start_date: date = Field(
        ...,
        description="Start date for all schedules",
    )
    first_due_date: date = Field(
        ...,
        description="First due date for all schedules",
    )

    @field_validator("student_ids")
    @classmethod
    def validate_student_ids(cls, v: List[UUID]) -> List[UUID]:
        """Validate student IDs list."""
        if len(v) == 0:
            raise ValueError("At least one student ID is required")
        
        if len(v) > 100:
            raise ValueError("Maximum 100 students allowed per bulk operation")
        
        # Check for duplicates
        if len(v) != len(set(v)):
            raise ValueError("Duplicate student IDs found")
        
        return v

    @field_validator("amount")
    @classmethod
    def validate_amount(cls, v: Decimal) -> Decimal:
        """Validate amount."""
        if v <= 0:
            raise ValueError("Amount must be greater than zero")
        return v.quantize(Decimal("0.01"))

    @model_validator(mode="after")
    def validate_dates(self) -> "BulkScheduleCreate":
        """Validate date consistency."""
        if self.first_due_date < self.start_date:
            raise ValueError(
                f"First due date ({self.first_due_date}) cannot be "
                f"before start date ({self.start_date})"
            )
        return self


class ScheduleSuspension(BaseCreateSchema):
    """
    Suspend payment schedule temporarily.
    
    Used to pause schedule for a specific period (e.g., vacation).
    """

    schedule_id: UUID = Field(
        ...,
        description="Schedule ID to suspend",
    )
    suspension_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for suspension",
    )

    # Suspension Period
    suspend_from_date: date = Field(
        ...,
        description="Suspension start date",
    )
    suspend_to_date: date = Field(
        ...,
        description="Suspension end date",
    )

    # Handling Options
    skip_dues_during_suspension: bool = Field(
        True,
        description="Skip generating payment dues during suspension period",
    )

    @field_validator("suspension_reason")
    @classmethod
    def validate_suspension_reason(cls, v: str) -> str:
        """Validate suspension reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Suspension reason must be at least 10 characters")
        return v

    @model_validator(mode="after")
    def validate_suspension_period(self) -> "ScheduleSuspension":
        """Validate suspension period."""
        if self.suspend_to_date <= self.suspend_from_date:
            raise ValueError(
                f"Suspension end date ({self.suspend_to_date}) must be "
                f"after start date ({self.suspend_from_date})"
            )
        
        # Limit suspension to 1 year
        days_diff = (self.suspend_to_date - self.suspend_from_date).days
        if days_diff > 365:
            raise ValueError(
                f"Suspension period cannot exceed 365 days (got {days_diff} days)"
            )
        
        # Warn if suspension starts in the past
        if self.suspend_from_date < date.today():
            # Log warning
            pass
        
        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\payment\__init__.py ---
# --- File: app/schemas/payment/__init__.py ---
"""
Payment schemas package.

This module exports all payment-related schemas for easy importing
across the application.
"""

from __future__ import annotations

from app.schemas.payment.payment_base import (
    PaymentBase,
    PaymentCreate,
    PaymentUpdate,
)
from app.schemas.payment.payment_filters import (
    PaymentAnalyticsRequest,
    PaymentExportRequest,
    PaymentFilterParams,
    PaymentReportRequest,
    PaymentSearchRequest,
    PaymentSortOptions,
)
from app.schemas.payment.payment_gateway import (
    GatewayCallback,
    GatewayRefundRequest,
    GatewayRefundResponse,
    GatewayRequest,
    GatewayResponse,
    GatewayVerification,
    GatewayWebhook,
)
from app.schemas.payment.payment_ledger import (
    AccountStatement,
    BalanceAdjustment,
    LedgerEntry,
    LedgerSummary,
    TransactionHistory,
    TransactionItem,
    WriteOff,
)
from app.schemas.payment.payment_refund import (
    RefundApproval,
    RefundList,
    RefundListItem,
    RefundRequest,
    RefundResponse,
    RefundStatus,
)
from app.schemas.payment.payment_reminder import (
    ReminderBatch,
    ReminderConfig,
    ReminderLog,
    ReminderStats,
    SendReminderRequest,
)
from app.schemas.payment.payment_request import (
    BulkPaymentRequest,
    ManualPaymentRequest,
    PaymentInitiation,
    PaymentRequest,
    SinglePaymentRecord,
)
from app.schemas.payment.payment_response import (
    PaymentAnalytics,
    PaymentDetail,
    PaymentListItem,
    PaymentReceipt,
    PaymentResponse,
    PaymentSummary,
)
from app.schemas.payment.payment_schedule import (
    BulkScheduleCreate,
    PaymentSchedule,
    ScheduleCreate,
    ScheduleGeneration,
    ScheduleSuspension,
    ScheduleUpdate,
    ScheduledPaymentGenerated,
)

__all__ = [
    # Base
    "PaymentBase",
    "PaymentCreate",
    "PaymentUpdate",
    # Request
    "PaymentRequest",
    "PaymentInitiation",
    "ManualPaymentRequest",
    "BulkPaymentRequest",
    "SinglePaymentRecord",
    # Response
    "PaymentResponse",
    "PaymentDetail",
    "PaymentReceipt",
    "PaymentListItem",
    "PaymentSummary",
    "PaymentAnalytics",
    # Gateway
    "GatewayRequest",
    "GatewayResponse",
    "GatewayWebhook",
    "GatewayCallback",
    "GatewayRefundRequest",
    "GatewayRefundResponse",
    "GatewayVerification",
    # Refund
    "RefundRequest",
    "RefundResponse",
    "RefundStatus",
    "RefundApproval",
    "RefundList",
    "RefundListItem",
    # Schedule
    "PaymentSchedule",
    "ScheduleCreate",
    "ScheduleUpdate",
    "ScheduleGeneration",
    "ScheduledPaymentGenerated",
    "BulkScheduleCreate",
    "ScheduleSuspension",
    # Reminder
    "ReminderConfig",
    "ReminderLog",
    "SendReminderRequest",
    "ReminderBatch",
    "ReminderStats",
    # Ledger
    "LedgerEntry",
    "LedgerSummary",
    "AccountStatement",
    "TransactionHistory",
    "TransactionItem",
    "BalanceAdjustment",
    "WriteOff",
    # Filters
    "PaymentFilterParams",
    "PaymentSearchRequest",
    "PaymentSortOptions",
    "PaymentReportRequest",
    "PaymentExportRequest",
    "PaymentAnalyticsRequest",
]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\payment\__pycache__ =====
