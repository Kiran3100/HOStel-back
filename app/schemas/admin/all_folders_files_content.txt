### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\admin ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\admin =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\admin_hostel_assignment.py ---
"""
Enhanced admin-hostel assignment schemas with comprehensive validation and performance optimizations.

Provides robust assignment management with audit trails, bulk operations,
and detailed permission tracking for multi-hostel administration.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional, Union
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import PermissionLevel

__all__ = [
    "AdminHostelAssignment",
    "AssignmentCreate",
    "AssignmentUpdate",
    "BulkAssignment",
    "RevokeAssignment",
    "AssignmentList",
    "HostelAdminList",
    "HostelAdminItem",
]


class AdminHostelAssignment(BaseResponseSchema):
    """
    Enhanced admin-hostel assignment with comprehensive tracking and analytics.
    
    Provides complete assignment information including permissions, activity tracking,
    and performance metrics for effective multi-hostel management.
    """
    
    # Core assignment identifiers
    assignment_id: UUID = Field(..., description="Unique assignment identifier")
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")
    
    # Hostel information
    hostel_id: UUID = Field(..., description="Assigned hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city location")
    hostel_type: str = Field(..., description="Hostel type (boys/girls/co-ed)")
    
    # Assignment metadata
    assigned_by: Optional[UUID] = Field(None, description="Admin who created this assignment")
    assigned_by_name: Optional[str] = Field(None, description="Name of assigning admin")
    assigned_date: date = Field(..., description="Date assignment was created")
    
    # Permission configuration
    permission_level: PermissionLevel = Field(..., description="Overall permission level")
    permissions: Dict[str, Union[bool, int, str]] = Field(
        default_factory=dict,
        description="Granular permissions for this hostel assignment"
    )
    
    # Assignment status
    is_active: bool = Field(True, description="Assignment is currently active")
    is_primary: bool = Field(False, description="Primary hostel for this admin")
    
    # Revocation tracking
    revoked_date: Optional[date] = Field(None, description="Date assignment was revoked")
    revoked_by: Optional[UUID] = Field(None, description="Admin who revoked assignment")
    revoke_reason: Optional[str] = Field(None, description="Reason for revocation")
    
    # Activity and performance tracking
    last_accessed: Optional[datetime] = Field(None, description="Last access timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    total_session_time_minutes: int = Field(0, ge=0, description="Total time spent in hostel")
    
    # Performance metrics
    decisions_made: int = Field(0, ge=0, description="Total decisions made for this hostel")
    avg_response_time_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average response time for this hostel"
    )
    satisfaction_score: Optional[Decimal] = Field(
        None, ge=0, le=5, description="Admin satisfaction score for this hostel"
    )

    @computed_field
    @property
    def assignment_duration_days(self) -> int:
        """Calculate total assignment duration in days."""
        end_date = self.revoked_date or date.today()
        return max(0, (end_date - self.assigned_date).days)

    @computed_field
    @property
    def is_recently_accessed(self) -> bool:
        """Check if hostel was accessed within last 24 hours."""
        if not self.last_accessed:
            return False
        hours_since_access = (datetime.utcnow() - self.last_accessed).total_seconds() / 3600
        return hours_since_access <= 24

    @computed_field
    @property
    def permission_summary(self) -> str:
        """Generate human-readable permission summary."""
        level_descriptions = {
            PermissionLevel.FULL_ACCESS: "Full Administrative Access",
            PermissionLevel.LIMITED_ACCESS: "Limited Access with Restrictions",
            PermissionLevel.VIEW_ONLY: "Read-Only Access"
        }
        return level_descriptions.get(self.permission_level, "Unknown Access Level")

    @computed_field
    @property
    def activity_level(self) -> str:
        """Categorize admin activity level for this hostel."""
        if self.access_count == 0:
            return "No Activity"
        elif self.access_count < 10:
            return "Low Activity"
        elif self.access_count < 50:
            return "Moderate Activity"
        elif self.access_count < 100:
            return "High Activity"
        else:
            return "Very High Activity"

    @computed_field
    @property
    def avg_session_duration_minutes(self) -> Decimal:
        """Calculate average session duration."""
        if self.access_count == 0:
            return Decimal("0.00")
        return Decimal(self.total_session_time_minutes / self.access_count).quantize(Decimal("0.01"))


class AssignmentCreate(BaseCreateSchema):
    """
    Enhanced assignment creation with comprehensive validation.
    
    Supports flexible permission configuration and proper validation
    for different access levels and assignment scenarios.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID to assign")
    hostel_id: UUID = Field(..., description="Hostel ID for assignment")
    
    permission_level: PermissionLevel = Field(
        PermissionLevel.FULL_ACCESS,
        description="Permission level for this assignment"
    )
    
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None,
        description="Specific permissions (required for LIMITED_ACCESS level)"
    )
    
    is_primary: bool = Field(False, description="Set as primary hostel for admin")
    
    # Assignment metadata
    assignment_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Administrative notes about this assignment"
    )
    effective_date: Optional[date] = Field(
        None,
        description="Effective date for assignment (defaults to today)"
    )
    
    # Notification preferences
    notify_admin: bool = Field(True, description="Send notification to admin about assignment")
    send_welcome_email: bool = Field(True, description="Send welcome email with hostel details")

    @model_validator(mode="after")
    def validate_assignment_requirements(self) -> "AssignmentCreate":
        """Validate assignment-specific business rules."""
        # Require permissions for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS:
            if not self.permissions:
                raise ValueError(
                    "Specific permissions are required when permission_level is LIMITED_ACCESS"
                )
            if not isinstance(self.permissions, dict) or len(self.permissions) == 0:
                raise ValueError("Permissions must be a non-empty dictionary for LIMITED_ACCESS")
        
        # Validate effective date
        if self.effective_date:
            if self.effective_date < date.today():
                # Allow past dates for historical assignments but validate reasonableness
                days_past = (date.today() - self.effective_date).days
                if days_past > 365:  # More than 1 year in past
                    raise ValueError("Effective date cannot be more than 1 year in the past")
            elif self.effective_date > date.today():
                # Allow future dates for scheduled assignments
                days_future = (self.effective_date - date.today()).days
                if days_future > 90:  # More than 3 months in future
                    raise ValueError("Effective date cannot be more than 90 days in the future")
        
        return self

    @field_validator("permissions")
    @classmethod
    def validate_permissions_structure(
        cls, v: Optional[Dict[str, Union[bool, int, str]]]
    ) -> Optional[Dict[str, Union[bool, int, str]]]:
        """Validate permissions dictionary structure and values."""
        if v is None:
            return None
        
        # Define valid permission keys
        valid_permission_keys = {
            "can_manage_rooms", "can_manage_students", "can_approve_bookings",
            "can_manage_fees", "can_view_financials", "can_manage_supervisors",
            "can_override_decisions", "can_export_data", "can_delete_records",
            "can_manage_hostel_settings", "can_view_analytics", "can_manage_announcements"
        }
        
        # Validate each permission
        for key, value in v.items():
            if key not in valid_permission_keys:
                raise ValueError(f"Invalid permission key: {key}")
            
            # Validate value types
            if not isinstance(value, (bool, int, str)):
                raise ValueError(f"Invalid permission value type for {key}: {type(value)}")
            
            # Validate specific permission constraints
            if key.endswith("_threshold") and isinstance(value, (int, float)):
                if value < 0:
                    raise ValueError(f"Threshold values must be non-negative: {key}")
        
        return v

    @field_validator("assignment_notes")
    @classmethod
    def validate_assignment_notes(cls, v: Optional[str]) -> Optional[str]:
        """Validate and clean assignment notes."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Remove excessive whitespace
            v = " ".join(v.split())
        return v


class AssignmentUpdate(BaseUpdateSchema):
    """
    Enhanced assignment update with selective field modifications.
    
    Allows partial updates while maintaining data consistency
    and proper validation for permission changes.
    """
    
    permission_level: Optional[PermissionLevel] = Field(
        None, description="Updated permission level"
    )
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None, description="Updated specific permissions"
    )
    is_primary: Optional[bool] = Field(None, description="Update primary hostel status")
    is_active: Optional[bool] = Field(None, description="Update assignment active status")
    
    assignment_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Updated assignment notes"
    )
    
    # Update metadata
    update_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for this update"
    )

    @model_validator(mode="after")
    def validate_update_consistency(self) -> "AssignmentUpdate":
        """Validate update field consistency and business rules."""
        # Ensure permissions are provided for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS:
            if self.permissions is None:
                raise ValueError(
                    "Permissions must be specified when updating to LIMITED_ACCESS level"
                )
        
        # Validate that at least one field is being updated
        update_fields = [
            self.permission_level, self.permissions, self.is_primary,
            self.is_active, self.assignment_notes
        ]
        if all(field is None for field in update_fields):
            raise ValueError("At least one field must be specified for update")
        
        return self

    # Reuse permission validation from AssignmentCreate
    _validate_permissions = field_validator("permissions")(
        AssignmentCreate.validate_permissions_structure.__func__
    )


class BulkAssignment(BaseCreateSchema):
    """
    Enhanced bulk assignment with comprehensive validation and options.
    
    Supports efficient batch operations while maintaining data integrity
    and providing flexible assignment strategies.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID for all assignments")
    hostel_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of hostel IDs for bulk assignment (max 50)"
    )
    
    permission_level: PermissionLevel = Field(
        PermissionLevel.FULL_ACCESS,
        description="Permission level for all assignments"
    )
    permissions: Optional[Dict[str, Union[bool, int, str]]] = Field(
        None,
        description="Permissions applied to all assignments"
    )
    
    primary_hostel_id: Optional[UUID] = Field(
        None,
        description="Which hostel should be set as primary (must be in hostel_ids)"
    )
    
    # Bulk operation strategies
    skip_existing: bool = Field(
        True,
        description="Skip hostels where admin already has active assignment"
    )
    update_existing: bool = Field(
        False,
        description="Update existing assignments with new permissions"
    )
    force_primary: bool = Field(
        False,
        description="Force primary hostel change even if admin has existing primary"
    )
    
    # Metadata and notifications
    bulk_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Notes applied to all assignments in this bulk operation"
    )
    notify_admin: bool = Field(True, description="Send notification about bulk assignment")
    send_summary_email: bool = Field(True, description="Send summary email after completion")

    @field_validator("hostel_ids")
    @classmethod
    def validate_unique_hostel_ids(cls, v: List[UUID]) -> List[UUID]:
        """Ensure hostel IDs are unique and validate list size."""
        if len(v) != len(set(v)):
            raise ValueError("Hostel IDs must be unique in bulk assignment")
        
        if len(v) > 50:
            raise ValueError("Cannot assign more than 50 hostels in a single bulk operation")
        
        return v

    @model_validator(mode="after")
    def validate_bulk_assignment_logic(self) -> "BulkAssignment":
        """Validate bulk assignment business logic and constraints."""
        # Validate primary hostel selection
        if self.primary_hostel_id and self.primary_hostel_id not in self.hostel_ids:
            raise ValueError("Primary hostel ID must be included in the hostel_ids list")
        
        # Validate operation strategy
        if self.skip_existing and self.update_existing:
            raise ValueError(
                "Cannot both skip_existing and update_existing. Choose one strategy."
            )
        
        # Validate permissions for limited access
        if self.permission_level == PermissionLevel.LIMITED_ACCESS and not self.permissions:
            raise ValueError(
                "Permissions must be specified for LIMITED_ACCESS level in bulk assignment"
            )
        
        return self

    # Reuse permission validation
    _validate_permissions = field_validator("permissions")(
        AssignmentCreate.validate_permissions_structure.__func__
    )


class RevokeAssignment(BaseCreateSchema):
    """
    Enhanced assignment revocation with comprehensive audit trail.
    
    Provides detailed revocation tracking with proper validation
    and support for different revocation scenarios.
    """
    
    assignment_id: UUID = Field(..., description="Assignment ID to revoke")
    revoke_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for assignment revocation"
    )
    
    # Revocation timing and options
    effective_date: Optional[date] = Field(
        None,
        description="Effective revocation date (defaults to today)"
    )
    immediate_revocation: bool = Field(
        True,
        description="Revoke immediately or schedule for effective_date"
    )
    
    # Transition management
    transfer_to_admin_id: Optional[UUID] = Field(
        None,
        description="Transfer responsibilities to another admin"
    )
    handover_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Handover notes for responsibility transfer"
    )
    
    # Notification preferences
    notify_affected_admin: bool = Field(True, description="Notify admin being revoked")
    notify_hostel_supervisors: bool = Field(True, description="Notify hostel supervisors")
    
    # Data retention
    retain_access_logs: bool = Field(True, description="Retain access logs for audit")
    archive_permissions: bool = Field(True, description="Archive permission history")

    @field_validator("revoke_reason")
    @classmethod
    def validate_revoke_reason(cls, v: str) -> str:
        """Validate and normalize revocation reason."""
        reason = v.strip()
        if len(reason) < 10:
            raise ValueError("Revocation reason must be at least 10 characters")
        
        # Remove excessive whitespace
        reason = " ".join(reason.split())
        return reason

    @field_validator("effective_date")
    @classmethod
    def validate_effective_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate revocation effective date."""
        if v is not None:
            today = date.today()
            
            # Allow past dates for historical revocations
            if v < today:
                days_past = (today - v).days
                if days_past > 30:  # More than 30 days in past
                    raise ValueError("Effective date cannot be more than 30 days in the past")
            
            # Allow future dates for scheduled revocations
            elif v > today:
                days_future = (v - today).days
                if days_future > 90:  # More than 90 days in future
                    raise ValueError("Effective date cannot be more than 90 days in the future")
        
        return v

    @model_validator(mode="after")
    def validate_revocation_logic(self) -> "RevokeAssignment":
        """Validate revocation business logic."""
        # Validate transfer requirements
        if self.transfer_to_admin_id:
            if not self.handover_notes:
                raise ValueError(
                    "Handover notes are required when transferring to another admin"
                )
        
        # Validate immediate vs scheduled revocation
        if not self.immediate_revocation and not self.effective_date:
            raise ValueError(
                "Effective date must be specified for non-immediate revocation"
            )
        
        if self.immediate_revocation and self.effective_date and self.effective_date != date.today():
            raise ValueError(
                "Immediate revocation cannot have future effective date"
            )
        
        return self


class AssignmentList(BaseSchema):
    """
    Enhanced assignment list with comprehensive admin overview.
    
    Provides aggregated view of all assignments for an admin
    with summary statistics and quick access information.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")
    
    # Assignment statistics
    total_hostels: int = Field(..., ge=0, description="Total hostels assigned")
    active_hostels: int = Field(..., ge=0, description="Currently active assignments")
    inactive_hostels: int = Field(..., ge=0, description="Inactive assignments")
    
    # Primary hostel information
    primary_hostel_id: Optional[UUID] = Field(None, description="Primary hostel ID")
    primary_hostel_name: Optional[str] = Field(None, description="Primary hostel name")
    
    # Activity summary
    last_activity: Optional[datetime] = Field(None, description="Last activity across all hostels")
    total_access_count: int = Field(0, ge=0, description="Total access count across hostels")
    
    # Assignment details
    assignments: List[AdminHostelAssignment] = Field(
        default_factory=list,
        description="Detailed assignment information"
    )
    
    # Performance metrics
    avg_response_time_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average response time across all hostels"
    )
    total_decisions_made: int = Field(0, ge=0, description="Total decisions across hostels")

    @computed_field
    @property
    def assignment_utilization_rate(self) -> Decimal:
        """Calculate assignment utilization rate."""
        if self.total_hostels == 0:
            return Decimal("0.00")
        return Decimal((self.active_hostels / self.total_hostels * 100)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def most_active_hostel(self) -> Optional[str]:
        """Identify most active hostel by access count."""
        if not self.assignments:
            return None
        
        most_active = max(self.assignments, key=lambda x: x.access_count)
        return most_active.hostel_name if most_active.access_count > 0 else None

    @computed_field
    @property
    def permission_distribution(self) -> Dict[str, int]:
        """Calculate distribution of permission levels."""
        distribution = {level.value: 0 for level in PermissionLevel}
        
        for assignment in self.assignments:
            if assignment.is_active:
                distribution[assignment.permission_level.value] += 1
        
        return distribution


class HostelAdminList(BaseSchema):
    """
    Enhanced hostel admin list with comprehensive hostel overview.
    
    Provides detailed view of all admins assigned to a specific hostel
    with their permissions and activity levels.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")
    
    # Admin statistics
    total_admins: int = Field(..., ge=0, description="Total assigned admins")
    active_admins: int = Field(..., ge=0, description="Currently active admin assignments")
    
    # Primary admin information
    primary_admin_id: Optional[UUID] = Field(None, description="Primary admin ID")
    primary_admin_name: Optional[str] = Field(None, description="Primary admin name")
    
    # Coverage information
    coverage_24x7: bool = Field(False, description="24x7 admin coverage available")
    last_admin_activity: Optional[datetime] = Field(None, description="Last admin activity")
    
    # Admin details
    admins: List["HostelAdminItem"] = Field(
        default_factory=list,
        description="Detailed admin assignment information"
    )

    @computed_field
    @property
    def admin_coverage_score(self) -> Decimal:
        """Calculate admin coverage adequacy score."""
        if self.total_admins == 0:
            return Decimal("0.00")
        
        # Base score from admin count (max 50 points)
        count_score = min(self.total_admins * 25, 50)
        
        # Activity score (max 30 points)
        activity_score = 30 if self.active_admins > 0 else 0
        
        # Coverage score (max 20 points)
        coverage_score = 20 if self.coverage_24x7 else 10
        
        total_score = count_score + activity_score + coverage_score
        return Decimal(str(total_score)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def permission_coverage(self) -> Dict[str, bool]:
        """Check if all critical permissions are covered by at least one admin."""
        critical_permissions = [
            "can_manage_students", "can_approve_bookings", "can_manage_fees",
            "can_override_decisions", "can_manage_supervisors"
        ]
        
        coverage = {}
        for permission in critical_permissions:
            coverage[permission] = any(
                admin.permission_level == PermissionLevel.FULL_ACCESS or
                admin.has_specific_permission(permission)
                for admin in self.admins
                if admin.is_active
            )
        
        return coverage


class HostelAdminItem(BaseSchema):
    """
    Enhanced admin item with detailed assignment information.
    
    Represents individual admin assignment within hostel admin list
    with comprehensive permission and activity tracking.
    """
    
    # Admin identification
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., description="Admin full name")
    admin_email: str = Field(..., description="Admin email address")
    
    # Assignment details
    assignment_id: UUID = Field(..., description="Assignment ID")
    permission_level: PermissionLevel = Field(..., description="Permission level")
    is_primary: bool = Field(False, description="Primary admin for this hostel")
    is_active: bool = Field(True, description="Assignment is active")
    
    # Assignment metadata
    assigned_date: date = Field(..., description="Assignment creation date")
    assigned_by_name: Optional[str] = Field(None, description="Name of assigning admin")
    
    # Activity tracking
    last_active: Optional[datetime] = Field(None, description="Last activity timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    avg_session_duration_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average session duration"
    )
    
    # Performance metrics
    decisions_made: int = Field(0, ge=0, description="Total decisions made")
    response_time_avg_minutes: Optional[Decimal] = Field(
        None, ge=0, description="Average response time"
    )
    
    # Specific permissions (for limited access)
    specific_permissions: Dict[str, Union[bool, int, str]] = Field(
        default_factory=dict,
        description="Specific permissions for limited access admins"
    )

    @computed_field
    @property
    def assignment_duration_days(self) -> int:
        """Calculate assignment duration in days."""
        return (date.today() - self.assigned_date).days

    @computed_field
    @property
    def activity_status(self) -> str:
        """Determine admin activity status."""
        if not self.last_active:
            return "Never Active"
        
        hours_since_activity = (datetime.utcnow() - self.last_active).total_seconds() / 3600
        
        if hours_since_activity <= 1:
            return "Online"
        elif hours_since_activity <= 24:
            return "Recently Active"
        elif hours_since_activity <= 168:  # 1 week
            return "Active This Week"
        else:
            return "Inactive"

    @computed_field
    @property
    def permission_summary(self) -> str:
        """Generate human-readable permission summary."""
        if self.permission_level == PermissionLevel.FULL_ACCESS:
            return "Full Administrative Access"
        elif self.permission_level == PermissionLevel.LIMITED_ACCESS:
            perm_count = len([p for p in self.specific_permissions.values() if p is True])
            return f"Limited Access ({perm_count} permissions)"
        else:
            return "View Only Access"

    def has_specific_permission(self, permission_key: str) -> bool:
        """Check if admin has a specific permission."""
        if self.permission_level == PermissionLevel.FULL_ACCESS:
            return True
        elif self.permission_level == PermissionLevel.LIMITED_ACCESS:
            return self.specific_permissions.get(permission_key, False) is True
        else:
            return False

    @computed_field
    @property
    def performance_score(self) -> Decimal:
        """Calculate overall performance score for this admin-hostel assignment."""
        score = Decimal("0.00")
        
        # Activity score (40 points max)
        if self.access_count > 0:
            activity_score = min(self.access_count * 2, 40)
            score += Decimal(str(activity_score))
        
        # Decision making score (30 points max)
        if self.decisions_made > 0:
            decision_score = min(self.decisions_made * 3, 30)
            score += Decimal(str(decision_score))
        
        # Response time score (30 points max)
        if self.response_time_avg_minutes:
            # Better response time = higher score
            # Assuming 30 minutes or less is excellent (30 points)
            # More than 120 minutes is poor (0 points)
            response_minutes = float(self.response_time_avg_minutes)
            if response_minutes <= 30:
                response_score = 30
            elif response_minutes >= 120:
                response_score = 0
            else:
                # Linear interpolation
                response_score = 30 * (1 - (response_minutes - 30) / 90)
            score += Decimal(str(response_score))
        
        return score.quantize(Decimal("0.01"))

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\admin_override.py ---
# app/schemas/admin/admin_override.py
"""
Admin override schemas (for supervisor decisions).

Provides structured requests and logs for admin overrides of supervisor actions,
with summary and analytics helpers.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "AdminOverrideRequest",
    "OverrideLog",
    "OverrideReason",
    "OverrideSummary",
    "SupervisorOverrideStats",
]


class AdminOverrideRequest(BaseCreateSchema):
    """Request to override supervisor decision."""

    supervisor_id: Optional[UUID] = Field(
        None,
        description="Supervisor whose action is being overridden",
    )
    hostel_id: UUID = Field(..., description="Hostel where override occurs")

    override_type: str = Field(
        ...,
        description="Type of override (complaint_reassignment, maintenance_approval, etc.)",
    )

    entity_type: str = Field(
        ...,
        description="Type of entity (complaint, maintenance_request, etc.)",
    )
    entity_id: UUID = Field(..., description="ID of entity being modified")

    reason: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Detailed reason for override",
    )

    # Original and new values
    original_action: Optional[Dict[str, Any]] = Field(
        None,
        description="Original supervisor action",
    )
    override_action: Dict[str, Any] = Field(
        ...,
        description="Admin's override action",
    )

    # Notification
    notify_supervisor: bool = Field(
        True,
        description="Notify supervisor of override",
    )

    @field_validator("reason")
    @classmethod
    def normalize_reason(cls, v: str) -> str:
        """Normalize and validate reason text."""
        text = " ".join(v.strip().split())
        if len(text) < 20:
            raise ValueError("Reason must be at least 20 characters after normalization")
        return text

    @field_validator("override_type", "entity_type")
    @classmethod
    def normalize_type_fields(cls, v: str) -> str:
        """Normalize override/entity type values."""
        return v.strip().lower()


class OverrideLog(BaseResponseSchema):
    """Override log entry."""

    admin_id: UUID
    admin_name: str
    supervisor_id: Optional[UUID]
    supervisor_name: Optional[str]

    hostel_id: UUID
    hostel_name: str

    override_type: str
    entity_type: str
    entity_id: UUID

    reason: str

    original_action: Optional[Dict[str, Any]]
    override_action: Dict[str, Any]

    created_at: datetime

    @computed_field
    @property
    def short_reason(self) -> str:
        """Shortened reason for list displays."""
        return (self.reason[:77] + "...") if len(self.reason) > 80 else self.reason


class OverrideReason(BaseSchema):
    """Predefined override reasons."""

    reason_code: str
    reason_text: str
    category: str
    requires_detailed_explanation: bool


class OverrideSummary(BaseSchema):
    """Summary of admin overrides."""

    admin_id: UUID
    period_start: date
    period_end: date

    total_overrides: int

    # By type
    overrides_by_type: Dict[str, int]

    # By supervisor
    overrides_by_supervisor: Dict[UUID, int]

    # By hostel
    overrides_by_hostel: Dict[UUID, int]

    # Trend
    override_trend: str = Field(
        ...,
        pattern="^(increasing|decreasing|stable)$",
        description="Override trend",
    )

    @computed_field
    @property
    def average_overrides_per_day(self) -> Decimal:
        """Average overrides per day in the period."""
        days = max(1, (self.period_end - self.period_start).days)
        return Decimal(self.total_overrides / days).quantize(Decimal("0.01"))


class SupervisorOverrideStats(BaseSchema):
    """Override statistics for a supervisor."""

    supervisor_id: UUID
    supervisor_name: str

    total_actions: int
    total_overrides: int
    override_rate: Decimal = Field(
        ...,
        description="% of actions overridden",
    )

    # By type
    overrides_by_type: Dict[str, int]

    # Common reasons
    common_override_reasons: List[str]

    # Trend
    recent_trend: str = Field(
        ...,
        pattern="^(improving|declining|stable)$",
    )

    @computed_field
    @property
    def is_concerning(self) -> bool:
        """Whether override rate is concerning (e.g., > 10%)."""
        return float(self.override_rate) > 10.0

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\admin_permissions.py ---
# app/schemas/admin/admin_permissions.py
"""
Admin permission schemas.

Defines hostel-level admin permissions and role/permission mappings
used for access control and authorization.
"""

from __future__ import annotations

from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import UserRole

__all__ = [
    "AdminPermissions",
    "PermissionMatrix",
    "RolePermissions",
    "PermissionCheck",
]


class AdminPermissions(BaseSchema):
    """
    Admin-specific permissions for a hostel.
    
    Preserves original fields; adds descriptions and can be extended with
    validation logic if needed.
    """

    # Room management
    can_manage_rooms: bool = Field(
        True, description="Can create/edit/delete rooms"
    )
    can_manage_beds: bool = Field(
        True, description="Can manage bed assignments"
    )

    # Student management
    can_manage_students: bool = Field(
        True, description="Can add/edit/remove students"
    )
    can_check_in_students: bool = Field(
        True, description="Can check-in students"
    )
    can_check_out_students: bool = Field(
        True, description="Can check-out students"
    )

    # Booking management
    can_approve_bookings: bool = Field(
        True, description="Can approve/reject bookings"
    )
    can_manage_waitlist: bool = Field(
        True, description="Can manage waitlist"
    )

    # Fee management
    can_manage_fees: bool = Field(
        True, description="Can configure fee structures"
    )
    can_process_payments: bool = Field(
        True, description="Can process manual payments"
    )
    can_issue_refunds: bool = Field(
        True, description="Can issue refunds"
    )

    # Supervisor management
    can_manage_supervisors: bool = Field(
        True, description="Can assign/remove supervisors"
    )
    can_configure_supervisor_permissions: bool = Field(
        True, description="Can modify supervisor permissions"
    )
    can_override_supervisor_actions: bool = Field(
        True, description="Can override supervisor decisions"
    )

    # Financial access
    can_view_financials: bool = Field(
        True, description="Can view financial reports"
    )
    can_export_financial_data: bool = Field(
        True, description="Can export financial data"
    )

    # Hostel configuration
    can_manage_hostel_settings: bool = Field(
        True, description="Can modify hostel settings"
    )
    can_manage_hostel_profile: bool = Field(
        True, description="Can edit public hostel profile"
    )
    can_toggle_public_visibility: bool = Field(
        True, description="Can make hostel public/private"
    )

    # Data management
    can_delete_records: bool = Field(
        False, description="Can permanently delete records"
    )
    can_export_data: bool = Field(
        True, description="Can export data"
    )
    can_import_data: bool = Field(
        True, description="Can bulk import data"
    )


class PermissionMatrix(BaseSchema):
    """Permission matrix showing what each role can do."""

    permissions: Dict[UserRole, List[str]] = Field(
        ...,
        description="Map of role to list of permission keys",
    )


class RolePermissions(BaseSchema):
    """Permissions for a specific role."""

    role: UserRole
    permissions: List[str] = Field(
        ...,
        description="List of permission keys",
    )
    description: str = Field(
        ...,
        description="Role description",
    )


class PermissionCheck(BaseSchema):
    """Check if user has specific permission."""

    user_id: UUID
    hostel_id: UUID
    permission_key: str

    has_permission: bool
    reason: Optional[str] = Field(
        None,
        description="Reason if permission denied",
    )

    @field_validator("permission_key")
    @classmethod
    def validate_permission_key(cls, v: str) -> str:
        """Basic validation for permission key."""
        value = v.strip()
        if not value:
            raise ValueError("permission_key cannot be empty")
        return value

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\hostel_context.py ---
"""
Enhanced hostel context management for multi-hostel admin operations.

Provides robust context switching, session tracking, and history management
for seamless multi-hostel administration with comprehensive audit trails.
"""

from __future__ import annotations

from datetime import datetime, timedelta
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "HostelContext",
    "HostelSwitchRequest",
    "ActiveHostelResponse",
    "ContextHistory",
    "ContextSwitch",
]


class HostelContext(BaseSchema):
    """
    Enhanced current hostel context for multi-hostel admin with real-time metrics.
    
    Maintains active hostel state with comprehensive permission information,
    session tracking, and quick access to relevant statistics.
    """
    
    # Admin and context identifiers
    admin_id: UUID = Field(..., description="Admin user ID")
    context_id: UUID = Field(..., description="Unique context session ID")
    
    # Active hostel information
    active_hostel_id: UUID = Field(..., description="Currently active hostel ID")
    hostel_name: str = Field(..., description="Active hostel name")
    hostel_city: str = Field(..., description="Hostel city location")
    hostel_type: str = Field(..., description="Hostel type classification")
    
    # Permission information for active hostel
    permission_level: str = Field(..., description="Permission level for active hostel")
    permissions: dict = Field(
        default_factory=dict,
        description="Detailed permissions for active hostel"
    )
    
    # Context session tracking
    context_started_at: datetime = Field(..., description="Context session start time")
    last_accessed_at: datetime = Field(..., description="Last activity timestamp")
    session_duration_minutes: int = Field(0, ge=0, description="Current session duration")
    
    # Quick statistics for active hostel
    total_students: int = Field(0, ge=0, description="Total students in active hostel")
    active_students: int = Field(0, ge=0, description="Currently active students")
    occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Current occupancy rate"
    )
    
    # Pending tasks and alerts
    pending_tasks: int = Field(0, ge=0, description="Pending tasks count")
    urgent_alerts: int = Field(0, ge=0, description="Urgent alerts count")
    unread_notifications: int = Field(0, ge=0, description="Unread notifications count")
    
    # Revenue snapshot
    revenue_this_month: Decimal = Field(
        Decimal("0.00"), ge=0, description="Revenue for current month"
    )
    outstanding_payments: Decimal = Field(
        Decimal("0.00"), ge=0, description="Outstanding payment amount"
    )
    
    # Context metadata
    previous_hostel_id: Optional[UUID] = Field(None, description="Previously active hostel")
    switch_count: int = Field(0, ge=0, description="Number of context switches in session")

    @computed_field
    @property
    def session_active_duration(self) -> str:
        """Calculate and format active session duration."""
        duration = datetime.utcnow() - self.context_started_at
        
        hours = int(duration.total_seconds() // 3600)
        minutes = int((duration.total_seconds() % 3600) // 60)
        
        if hours > 0:
            return f"{hours}h {minutes}m"
        else:
            return f"{minutes}m"

    @computed_field
    @property
    def context_health_score(self) -> Decimal:
        """Calculate context health score based on hostel metrics."""
        score = Decimal("0.00")
        
        # Occupancy contribution (40 points)
        score += (self.occupancy_percentage * Decimal("0.4"))
        
        # Task management (30 points)
        if self.pending_tasks == 0:
            score += Decimal("30.00")
        elif self.pending_tasks <= 5:
            score += Decimal("20.00")
        elif self.pending_tasks <= 10:
            score += Decimal("10.00")
        
        # Alert status (30 points)
        if self.urgent_alerts == 0:
            score += Decimal("30.00")
        elif self.urgent_alerts <= 2:
            score += Decimal("15.00")
        
        return score.quantize(Decimal("0.01"))

    @computed_field
    @property
    def requires_attention(self) -> bool:
        """Determine if active hostel requires immediate attention."""
        return (
            self.urgent_alerts > 0 or
            self.pending_tasks > 10 or
            self.occupancy_percentage < Decimal("50.00") or
            self.outstanding_payments > self.revenue_this_month
        )

    @computed_field
    @property
    def is_stale_session(self) -> bool:
        """Check if context session is stale (no activity for 30+ minutes)."""
        inactive_duration = datetime.utcnow() - self.last_accessed_at
        return inactive_duration > timedelta(minutes=30)


class HostelSwitchRequest(BaseCreateSchema):
    """
    Enhanced hostel context switch request with validation and options.
    
    Supports seamless context switching with proper validation,
    session management, and optional data refresh preferences.
    """
    
    hostel_id: UUID = Field(..., description="Target hostel ID to switch to")
    
    # Switch preferences
    save_current_session: bool = Field(
        True,
        description="Save current session state before switching"
    )
    refresh_dashboard: bool = Field(
        True,
        description="Refresh dashboard data after switch"
    )
    load_pending_tasks: bool = Field(
        True,
        description="Load pending tasks for new context"
    )
    
    # Navigation context
    return_url: Optional[str] = Field(
        None,
        max_length=500,
        description="URL to navigate to after switch"
    )
    switch_reason: Optional[str] = Field(
        None,
        max_length=200,
        description="Reason for context switch (for analytics)"
    )

    @field_validator("return_url")
    @classmethod
    def validate_return_url(cls, v: Optional[str]) -> Optional[str]:
        """Validate return URL format."""
        if v is not None:
            v = v.strip()
            if v and not v.startswith(("/", "http://", "https://")):
                raise ValueError("Invalid return URL format")
        return v

    @field_validator("switch_reason")
    @classmethod
    def validate_switch_reason(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize switch reason."""
        if v is not None:
            v = v.strip()
            if v:
                v = " ".join(v.split())  # Normalize whitespace
        return v


class ActiveHostelResponse(BaseSchema):
    """
    Enhanced response after successful hostel context switch.
    
    Provides comprehensive information about the newly active hostel
    with permissions, statistics, and navigation guidance.
    """
    
    # Context identifiers
    admin_id: UUID = Field(..., description="Admin user ID")
    context_id: UUID = Field(..., description="New context session ID")
    
    # Previous and current hostel information
    previous_hostel_id: Optional[UUID] = Field(None, description="Previous active hostel ID")
    previous_hostel_name: Optional[str] = Field(None, description="Previous hostel name")
    
    active_hostel_id: UUID = Field(..., description="Newly active hostel ID")
    hostel_name: str = Field(..., description="Active hostel name")
    hostel_city: str = Field(..., description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")
    
    # Permission configuration for new context
    permission_level: str = Field(..., description="Permission level for new hostel")
    permissions: dict = Field(default_factory=dict, description="Detailed permissions")
    
    # Context timing
    switched_at: datetime = Field(..., description="Context switch timestamp")
    previous_session_duration_minutes: Optional[int] = Field(
        None, ge=0, description="Duration of previous session"
    )
    
    # Quick statistics for new hostel
    total_students: int = Field(0, ge=0, description="Total students")
    occupancy_percentage: Decimal = Field(Decimal("0.00"), ge=0, le=100)
    pending_tasks: int = Field(0, ge=0, description="Pending tasks")
    urgent_alerts: int = Field(0, ge=0, description="Urgent alerts")
    
    # Response metadata
    message: str = Field(..., description="Success message")
    dashboard_url: Optional[str] = Field(None, description="Dashboard URL for new context")
    
    # Navigation suggestions
    suggested_actions: List[str] = Field(
        default_factory=list,
        description="Suggested next actions based on hostel state"
    )

    @computed_field
    @property
    def switch_summary(self) -> str:
        """Generate human-readable switch summary."""
        if self.previous_hostel_name:
            return f"Switched from {self.previous_hostel_name} to {self.hostel_name}"
        else:
            return f"Activated context for {self.hostel_name}"

    @computed_field
    @property
    def requires_immediate_action(self) -> bool:
        """Check if new context requires immediate action."""
        return self.urgent_alerts > 0 or self.pending_tasks > 5

    @computed_field
    @property
    def hostel_health_indicator(self) -> str:
        """Generate health indicator for newly active hostel."""
        if self.urgent_alerts > 0:
            return "critical"
        elif self.pending_tasks > 10:
            return "warning"
        elif self.occupancy_percentage < Decimal("60.00"):
            return "attention"
        else:
            return "healthy"


class ContextSwitch(BaseSchema):
    """
    Enhanced individual context switch record with comprehensive tracking.
    
    Represents a single hostel context switch with timing, reason,
    and session metrics for analytics and audit purposes.
    """
    
    # Switch identification
    switch_id: UUID = Field(..., description="Unique switch record ID")
    admin_id: UUID = Field(..., description="Admin user ID")
    
    # Source and destination hostels
    from_hostel_id: Optional[UUID] = Field(None, description="Source hostel ID")
    from_hostel_name: Optional[str] = Field(None, description="Source hostel name")
    to_hostel_id: UUID = Field(..., description="Destination hostel ID")
    to_hostel_name: str = Field(..., description="Destination hostel name")
    
    # Switch timing
    switched_at: datetime = Field(..., description="Switch timestamp")
    session_duration_minutes: Optional[int] = Field(
        None,
        ge=0,
        description="Duration spent in previous hostel (if applicable)"
    )
    
    # Switch context
    switch_reason: Optional[str] = Field(None, description="Reason for switch")
    triggered_by: str = Field(
        "manual",
        pattern=r"^(manual|automatic|notification|alert|scheduled)$",
        description="What triggered the switch"
    )
    
    # Activity metrics during session
    actions_performed: int = Field(0, ge=0, description="Actions performed in session")
    decisions_made: int = Field(0, ge=0, description="Decisions made in session")
    
    # Navigation context
    source_page: Optional[str] = Field(None, description="Page where switch was initiated")
    destination_page: Optional[str] = Field(None, description="Landing page after switch")

    @computed_field
    @property
    def session_productivity_score(self) -> Decimal:
        """Calculate productivity score for the session."""
        if self.session_duration_minutes is None or self.session_duration_minutes == 0:
            return Decimal("0.00")
        
        # Calculate actions per minute
        actions_per_minute = self.actions_performed / self.session_duration_minutes
        
        # Score based on actions per minute (capped at 100)
        # Assuming 0.5 actions/minute is excellent (100 points)
        score = min(actions_per_minute / 0.5 * 100, 100)
        
        return Decimal(str(score)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def was_productive_session(self) -> bool:
        """Determine if session was productive (made meaningful progress)."""
        if self.session_duration_minutes is None:
            return False
        
        # Consider productive if:
        # - At least 5 minutes AND at least 1 action OR
        # - At least 1 decision made
        return (
            (self.session_duration_minutes >= 5 and self.actions_performed > 0) or
            self.decisions_made > 0
        )

    @computed_field
    @property
    def switch_type_description(self) -> str:
        """Generate human-readable switch type description."""
        type_map = {
            "manual": "User-initiated switch",
            "automatic": "Automatic context switch",
            "notification": "Triggered by notification",
            "alert": "Triggered by alert",
            "scheduled": "Scheduled context switch"
        }
        return type_map.get(self.triggered_by, "Unknown switch type")


class ContextHistory(BaseSchema):
    """
    Enhanced context switch history with analytics and insights.
    
    Provides comprehensive historical view of all context switches
    with usage patterns, productivity metrics, and recommendations.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID")
    admin_name: str = Field(..., description="Admin full name")
    
    # History period
    history_start: datetime = Field(..., description="History period start")
    history_end: datetime = Field(..., description="History period end")
    
    # Switch records
    switches: List[ContextSwitch] = Field(
        default_factory=list,
        description="Chronological list of context switches"
    )
    
    # Aggregate statistics
    total_switches: int = Field(0, ge=0, description="Total number of switches")
    unique_hostels_accessed: int = Field(0, ge=0, description="Unique hostels accessed")
    total_session_time_minutes: int = Field(0, ge=0, description="Total time across all sessions")
    
    # Most accessed hostel
    most_accessed_hostel_id: Optional[UUID] = Field(None, description="Most frequently accessed hostel")
    most_accessed_hostel_name: Optional[str] = Field(None, description="Most accessed hostel name")
    most_accessed_count: int = Field(0, ge=0, description="Access count for most accessed hostel")
    
    # Usage patterns
    avg_session_duration_minutes: Decimal = Field(
        Decimal("0.00"), ge=0, description="Average session duration"
    )
    avg_switches_per_day: Decimal = Field(
        Decimal("0.00"), ge=0, description="Average switches per day"
    )
    
    # Productivity metrics
    total_actions_performed: int = Field(0, ge=0, description="Total actions across all sessions")
    total_decisions_made: int = Field(0, ge=0, description="Total decisions across all sessions")
    productivity_score: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Overall productivity score"
    )

    @computed_field
    @property
    def history_duration_days(self) -> int:
        """Calculate history period duration in days."""
        return max(1, (self.history_end - self.history_start).days)

    @computed_field
    @property
    def switch_frequency_pattern(self) -> str:
        """Determine switch frequency pattern."""
        switches_per_day = float(self.avg_switches_per_day)
        
        if switches_per_day < 2:
            return "Low Frequency"
        elif switches_per_day < 5:
            return "Moderate Frequency"
        elif switches_per_day < 10:
            return "High Frequency"
        else:
            return "Very High Frequency"

    @computed_field
    @property
    def session_efficiency_score(self) -> Decimal:
        """Calculate session efficiency score."""
        if self.total_switches == 0:
            return Decimal("0.00")
        
        # Calculate average actions per switch
        avg_actions = self.total_actions_performed / self.total_switches
        
        # Calculate average decisions per switch
        avg_decisions = self.total_decisions_made / self.total_switches
        
        # Combined efficiency score
        efficiency = (avg_actions * 0.6 + avg_decisions * 0.4) * 10
        
        return Decimal(str(min(efficiency, 100))).quantize(Decimal("0.01"))

    @computed_field
    @property
    def hostel_focus_distribution(self) -> str:
        """Determine hostel focus distribution pattern."""
        if self.unique_hostels_accessed == 0:
            return "No Activity"
        
        # Calculate concentration: how focused admin is on specific hostels
        if self.most_accessed_count > self.total_switches * 0.7:
            return "Highly Focused (70%+ on one hostel)"
        elif self.most_accessed_count > self.total_switches * 0.5:
            return "Moderately Focused (50-70% on one hostel)"
        else:
            return "Distributed (Balanced across hostels)"

    @computed_field
    @property
    def recommendations(self) -> List[str]:
        """Generate context usage recommendations based on patterns."""
        recommendations = []
        
        # High switch frequency recommendation
        if float(self.avg_switches_per_day) > 10:
            recommendations.append(
                "Consider consolidating tasks to reduce frequent context switching"
            )
        
        # Short session duration recommendation
        if float(self.avg_session_duration_minutes) < 10:
            recommendations.append(
                "Average session duration is short; consider focusing on one hostel at a time"
            )
        
        # Low productivity recommendation
        if float(self.productivity_score) < 50:
            recommendations.append(
                "Productivity could be improved by spending more time per hostel session"
            )
        
        # Balanced usage recommendation
        if self.unique_hostels_accessed > 5 and self.most_accessed_count < self.total_switches * 0.3:
            recommendations.append(
                "You're managing many hostels; consider delegating to improve efficiency"
            )
        
        return recommendations if recommendations else ["Usage patterns are healthy"]

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\hostel_selector.py ---
"""
Enhanced hostel selector UI schemas with comprehensive filtering and organization.

Provides optimized schemas for hostel selection dropdown/sidebar with quick stats,
favorites management, and recent access tracking for improved user experience.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, computed_field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "HostelSelectorResponse",
    "HostelSelectorItem",
    "RecentHostels",
    "RecentHostelItem",
    "FavoriteHostels",
    "FavoriteHostelItem",
    "UpdateFavoriteRequest",
]


class HostelSelectorItem(BaseSchema):
    """
    Enhanced individual hostel item in selector with comprehensive quick view.
    
    Provides essential hostel information with visual indicators,
    quick statistics, and status information for efficient selection.
    """
    
    # Hostel identification
    hostel_id: UUID = Field(..., description="Hostel unique identifier")
    hostel_name: str = Field(..., description="Hostel display name")
    hostel_city: str = Field(..., description="Hostel city location")
    hostel_type: str = Field(..., description="Hostel type (boys/girls/co-ed)")
    hostel_address: Optional[str] = Field(None, description="Short address for display")
    
    # Visual indicators and flags
    is_active: bool = Field(True, description="Currently active hostel in context")
    is_primary: bool = Field(False, description="Primary hostel for this admin")
    is_favorite: bool = Field(False, description="Marked as favorite by admin")
    is_recently_accessed: bool = Field(False, description="Accessed in last 24 hours")
    
    # Quick statistics for decision making
    occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Current occupancy rate"
    )
    total_students: int = Field(0, ge=0, description="Total student count")
    available_beds: int = Field(0, ge=0, description="Available beds count")
    
    # Alert indicators
    pending_bookings: int = Field(0, ge=0, description="Pending booking requests")
    pending_complaints: int = Field(0, ge=0, description="Open complaints")
    urgent_tasks: int = Field(0, ge=0, description="Urgent tasks count")
    
    # Permission summary
    permission_level: str = Field(..., description="Admin permission level for this hostel")
    can_manage: bool = Field(True, description="Has management permissions")
    
    # Activity tracking
    last_accessed: Optional[datetime] = Field(None, description="Last access timestamp")
    access_count: int = Field(0, ge=0, description="Total access count")
    
    # Display customization
    display_order: int = Field(0, description="Custom display order")
    custom_label: Optional[str] = Field(None, description="Custom label/nickname for hostel")

    @computed_field
    @property
    def requires_attention(self) -> bool:
        """Determine if hostel requires immediate attention."""
        return (
            self.urgent_tasks > 0 or
            self.pending_complaints > 5 or
            self.occupancy_percentage < Decimal("50.00")
        )

    @computed_field
    @property
    def notification_badge_count(self) -> int:
        """Calculate notification badge count for visual indicator."""
        return self.pending_bookings + self.urgent_tasks

    @computed_field
    @property
    def status_indicator_color(self) -> str:
        """Determine status indicator color for UI."""
        if self.urgent_tasks > 0:
            return "red"  # Critical
        elif self.pending_complaints > 5 or self.occupancy_percentage < Decimal("50.00"):
            return "yellow"  # Warning
        else:
            return "green"  # Good

    @computed_field
    @property
    def display_label(self) -> str:
        """Get display label (custom or default)."""
        return self.custom_label if self.custom_label else self.hostel_name

    @computed_field
    @property
    def quick_summary(self) -> str:
        """Generate quick summary text for tooltip."""
        return (
            f"{int(self.occupancy_percentage)}% occupied  "
            f"{self.total_students} students  "
            f"{self.available_beds} beds available"
        )


class HostelSelectorResponse(BaseSchema):
    """
    Enhanced hostel selector dropdown/sidebar response with organized data.
    
    Provides complete hostel list with categorization, recent access,
    favorites, and intelligent sorting for optimal user experience.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID")
    total_hostels: int = Field(..., ge=0, description="Total hostels managed")
    active_hostels: int = Field(..., ge=0, description="Active hostel assignments")
    
    # Active context
    active_hostel_id: Optional[UUID] = Field(None, description="Currently active hostel ID")
    active_hostel_name: Optional[str] = Field(None, description="Currently active hostel name")
    
    # Organized hostel lists
    hostels: List[HostelSelectorItem] = Field(
        default_factory=list,
        description="All hostels with details"
    )
    
    # Quick access lists (IDs for reference)
    recent_hostel_ids: List[UUID] = Field(
        default_factory=list,
        max_length=10,
        description="Recently accessed hostel IDs (max 10)"
    )
    favorite_hostel_ids: List[UUID] = Field(
        default_factory=list,
        description="Favorite hostel IDs"
    )
    primary_hostel_id: Optional[UUID] = Field(None, description="Primary hostel ID")
    
    # Hostel requiring attention
    attention_required_ids: List[UUID] = Field(
        default_factory=list,
        description="Hostels requiring immediate attention"
    )
    
    # Summary statistics
    total_pending_tasks: int = Field(0, ge=0, description="Total pending tasks across all hostels")
    total_urgent_alerts: int = Field(0, ge=0, description="Total urgent alerts")
    avg_occupancy_percentage: Decimal = Field(
        Decimal("0.00"), ge=0, le=100, description="Average occupancy across hostels"
    )

    @computed_field
    @property
    def has_critical_alerts(self) -> bool:
        """Check if any hostel has critical alerts."""
        return len(self.attention_required_ids) > 0

    @computed_field
    @property
    def hostels_by_category(self) -> dict:
        """Organize hostels by category for UI grouping."""
        return {
            "primary": [h for h in self.hostels if h.is_primary],
            "favorites": [h for h in self.hostels if h.is_favorite],
            "recent": [h for h in self.hostels if h.hostel_id in self.recent_hostel_ids[:5]],
            "attention_required": [h for h in self.hostels if h.requires_attention],
            "others": [
                h for h in self.hostels
                if not (h.is_primary or h.is_favorite or h.hostel_id in self.recent_hostel_ids[:5])
            ]
        }

    @computed_field
    @property
    def selector_summary(self) -> str:
        """Generate summary text for selector header."""
        if self.active_hostel_name:
            return f"Managing {self.total_hostels} hostels  Active: {self.active_hostel_name}"
        else:
            return f"Managing {self.total_hostels} hostels"


class RecentHostelItem(BaseSchema):
    """
    Enhanced recent hostel item with access patterns.
    
    Tracks recent hostel access with frequency and recency metrics
    for intelligent sorting and quick access recommendations.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")
    
    # Access tracking
    last_accessed: datetime = Field(..., description="Last access timestamp")
    access_count: int = Field(..., ge=1, description="Total access count")
    access_count_last_7_days: int = Field(0, ge=0, description="Access count in last 7 days")
    access_count_last_30_days: int = Field(0, ge=0, description="Access count in last 30 days")
    
    # Session metrics
    avg_session_duration_minutes: Decimal = Field(
        Decimal("0.00"), ge=0, description="Average session duration"
    )
    total_session_time_minutes: int = Field(0, ge=0, description="Total session time")
    
    # Quick stats for recent access
    last_occupancy: Decimal = Field(Decimal("0.00"), ge=0, le=100)
    pending_tasks_on_last_visit: int = Field(0, ge=0)

    @computed_field
    @property
    def hours_since_access(self) -> int:
        """Calculate hours since last access."""
        delta = datetime.utcnow() - self.last_accessed
        return int(delta.total_seconds() // 3600)

    @computed_field
    @property
    def access_frequency_score(self) -> Decimal:
        """Calculate access frequency score for ranking."""
        # Recent access gets higher score
        recency_score = max(0, 100 - self.hours_since_access)
        
        # Frequency score based on 7-day access
        frequency_score = min(self.access_count_last_7_days * 10, 100)
        
        # Combined score (60% frequency, 40% recency)
        total_score = (frequency_score * 0.6) + (recency_score * 0.4)
        
        return Decimal(str(total_score)).quantize(Decimal("0.01"))

    @computed_field
    @property
    def is_frequent(self) -> bool:
        """Determine if this is a frequently accessed hostel."""
        return self.access_count_last_7_days >= 5


class RecentHostels(BaseSchema):
    """
    Enhanced recent hostels list with intelligent sorting.
    
    Provides recently accessed hostels sorted by access patterns
    with analytics for usage optimization recommendations.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID")
    
    hostels: List[RecentHostelItem] = Field(
        default_factory=list,
        max_length=20,
        description="Recently accessed hostels (max 20)"
    )
    
    # Summary metrics
    total_recent_hostels: int = Field(0, ge=0, description="Total recent hostels count")
    most_frequent_hostel_id: Optional[UUID] = Field(None, description="Most frequently accessed hostel")
    
    # Time range for recent access
    tracking_period_days: int = Field(30, ge=1, description="Tracking period in days")

    @computed_field
    @property
    def access_pattern_summary(self) -> str:
        """Generate access pattern summary."""
        if not self.hostels:
            return "No recent access"
        
        frequent_count = sum(1 for h in self.hostels if h.is_frequent)
        
        if frequent_count > 0:
            return f"{frequent_count} frequently accessed  {len(self.hostels)} total recent"
        else:
            return f"{len(self.hostels)} hostels accessed recently"


class FavoriteHostelItem(BaseSchema):
    """
    Enhanced favorite hostel item with customization options.
    
    Supports hostel favorites with custom labels, notes,
    and priority ordering for personalized quick access.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID")
    hostel_name: str = Field(..., description="Hostel name")
    hostel_city: str = Field(..., description="Hostel city")
    hostel_type: str = Field(..., description="Hostel type")
    
    # Favorite metadata
    added_to_favorites: datetime = Field(..., description="Timestamp when added to favorites")
    custom_label: Optional[str] = Field(
        None, max_length=100, description="Custom label/nickname for hostel"
    )
    notes: Optional[str] = Field(
        None, max_length=500, description="Personal notes about hostel"
    )
    display_order: int = Field(0, description="Custom display order priority")
    
    # Quick stats
    current_occupancy: Decimal = Field(Decimal("0.00"), ge=0, le=100)
    pending_items: int = Field(0, ge=0, description="Total pending items count")
    
    # Access tracking for favorites
    last_accessed: Optional[datetime] = Field(None, description="Last access timestamp")
    access_count_since_favorited: int = Field(0, ge=0)

    @computed_field
    @property
    def days_in_favorites(self) -> int:
        """Calculate days since added to favorites."""
        delta = datetime.utcnow() - self.added_to_favorites
        return delta.days

    @computed_field
    @property
    def display_name(self) -> str:
        """Get display name (custom label or hostel name)."""
        return self.custom_label if self.custom_label else self.hostel_name

    @computed_field
    @property
    def is_recently_accessed(self) -> bool:
        """Check if accessed in last 24 hours."""
        if not self.last_accessed:
            return False
        hours_since = (datetime.utcnow() - self.last_accessed).total_seconds() / 3600
        return hours_since <= 24


class FavoriteHostels(BaseSchema):
    """
    Enhanced favorites list with organization and management.
    
    Provides organized favorites with custom ordering,
    labels, and quick access to frequently used hostels.
    """
    
    admin_id: UUID = Field(..., description="Admin user ID")
    
    hostels: List[FavoriteHostelItem] = Field(
        default_factory=list,
        description="Favorite hostels sorted by display_order"
    )
    
    total_favorites: int = Field(0, ge=0, description="Total favorite hostels count")
    max_favorites_allowed: int = Field(20, ge=1, description="Maximum favorites allowed")

    @computed_field
    @property
    def can_add_more(self) -> bool:
        """Check if more favorites can be added."""
        return self.total_favorites < self.max_favorites_allowed

    @computed_field
    @property
    def favorites_by_city(self) -> dict:
        """Group favorites by city."""
        grouped = {}
        for hostel in self.hostels:
            city = hostel.hostel_city
            if city not in grouped:
                grouped[city] = []
            grouped[city].append(hostel)
        return grouped


class UpdateFavoriteRequest(BaseCreateSchema):
    """
    Enhanced favorite update request with comprehensive customization.
    
    Supports adding/removing favorites with custom labels,
    notes, and display order preferences.
    """
    
    hostel_id: UUID = Field(..., description="Hostel ID to add/remove from favorites")
    is_favorite: bool = Field(..., description="True to add, False to remove")
    
    # Customization options (only used when is_favorite=True)
    custom_label: Optional[str] = Field(
        None,
        max_length=100,
        description="Custom label/nickname for hostel"
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Personal notes about this hostel"
    )
    display_order: Optional[int] = Field(
        None,
        ge=0,
        description="Custom display order (0 = highest priority)"
    )

    @field_validator("custom_label", "notes")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize text fields."""
        if v is not None:
            v = v.strip()
            if not v:
                return None
            # Normalize whitespace
            v = " ".join(v.split())
        return v

    @model_validator(mode="after")
    def validate_customization_logic(self) -> "UpdateFavoriteRequest":
        """Validate that customization is only provided when adding to favorites."""
        if not self.is_favorite:
            # Clear customization fields when removing from favorites
            if any([self.custom_label, self.notes, self.display_order is not None]):
                # Silently ignore customization when removing
                self.custom_label = None
                self.notes = None
                self.display_order = None
        
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\multi_hostel_dashboard.py ---
# app/schemas/admin/multi_hostel_dashboard.py
"""
Enhanced multi-hostel dashboard schemas with comprehensive analytics and insights.

Provides unified dashboard for multi-hostel administration with aggregated metrics,
cross-hostel comparisons, performance analytics, and actionable insights.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseSchema

__all__ = [
    "MultiHostelDashboard",
    "AggregatedStats",
    "HostelQuickStats",
    "CrossHostelComparison",
    "TopPerformer",
    "BottomPerformer",
    "HostelMetricComparison",
    "HostelTaskSummary",
]


class AggregatedStats(BaseSchema):
    """
    Aggregated statistics across all hostels managed by an admin.
    
    Preserves original fields while adding derived metrics and consistency checks.
    """

    # Occupancy
    total_beds: int = Field(..., ge=0)
    total_occupied: int = Field(..., ge=0)
    total_available: int = Field(..., ge=0)
    average_occupancy_percentage: Decimal = Field(..., ge=0, le=100)

    # Students
    total_students: int = Field(..., ge=0)
    active_students: int = Field(..., ge=0)

    # Revenue
    total_revenue_this_month: Decimal = Field(..., ge=0)
    total_outstanding: Decimal = Field(..., ge=0)
    total_overdue: Decimal = Field(..., ge=0)

    # Bookings
    total_pending_bookings: int = Field(..., ge=0)
    total_confirmed_bookings: int = Field(..., ge=0)
    booking_conversion_rate: Decimal = Field(..., ge=0, le=100)

    # Complaints
    total_open_complaints: int = Field(..., ge=0)
    total_resolved_this_month: int = Field(..., ge=0)
    average_resolution_time_hours: Decimal = Field(..., ge=0)

    # Maintenance
    total_pending_maintenance: int = Field(..., ge=0)
    total_completed_this_month: int = Field(..., ge=0)

    # Performance
    average_rating_across_hostels: Decimal = Field(..., ge=0, le=5)
    total_reviews: int = Field(..., ge=0)

    @computed_field
    @property
    def occupancy_utilization(self) -> Decimal:
        """Overall occupancy utilization based on beds."""
        if self.total_beds == 0:
            return Decimal("0.00")
        return Decimal(self.total_occupied / self.total_beds * 100).quantize(
            Decimal("0.01")
        )

    @computed_field
    @property
    def financial_risk_score(self) -> Decimal:
        """
        Simple financial risk score based on outstanding and overdue amounts.
        Higher values indicate higher risk.
        """
        if self.total_revenue_this_month == 0:
            return Decimal("0.00")

        overdue_ratio = float(self.total_overdue / self.total_revenue_this_month)
        outstanding_ratio = float(self.total_outstanding / self.total_revenue_this_month)

        # Weighted: overdue is more significant than outstanding
        score = (overdue_ratio * 70 + outstanding_ratio * 30) * 100
        return Decimal(str(min(score, 100))).quantize(Decimal("0.01"))


class HostelQuickStats(BaseSchema):
    """
    Quick statistics for individual hostel.
    
    Preserves original fields and adds computed helpers.
    """

    hostel_id: UUID
    hostel_name: str
    hostel_city: str

    # Occupancy
    occupancy_percentage: Decimal
    available_beds: int

    # Revenue
    revenue_this_month: Decimal
    outstanding_amount: Decimal

    # Alerts
    pending_bookings: int
    open_complaints: int
    pending_maintenance: int
    overdue_payments_count: int

    # Status indicators
    status_color: str = Field(..., pattern="^(green|yellow|red)$")

    # Last activity
    last_supervisor_activity: Optional[datetime] = None

    @computed_field
    @property
    def total_alerts(self) -> int:
        """Total alert indicators for this hostel."""
        return (
            self.pending_bookings
            + self.open_complaints
            + self.pending_maintenance
            + self.overdue_payments_count
        )

    @computed_field
    @property
    def needs_attention(self) -> bool:
        """Whether this hostel needs admin attention."""
        return self.status_color != "green" or self.total_alerts > 0


class TopPerformer(BaseSchema):
    """Top performing hostel for a given metric."""

    hostel_id: UUID
    hostel_name: str
    metric_value: Decimal
    metric_name: str


class BottomPerformer(BaseSchema):
    """Bottom performing hostel (needs attention)."""

    hostel_id: UUID
    hostel_name: str
    metric_value: Decimal
    metric_name: str
    issue_severity: str = Field(..., pattern="^(low|medium|high|critical)$")


class HostelMetricComparison(BaseSchema):
    """Individual hostel metric for comparison."""

    hostel_id: UUID
    hostel_name: str
    metric_value: Decimal
    percentage_of_best: Decimal
    trend: str = Field(..., pattern="^(up|down|stable)$")


class HostelTaskSummary(BaseSchema):
    """Task summary for a hostel."""

    hostel_id: UUID
    hostel_name: str
    urgent_tasks: int
    high_priority_tasks: int
    medium_priority_tasks: int
    low_priority_tasks: int
    total_tasks: int

    @computed_field
    @property
    def criticality(self) -> str:
        """Simple criticality assessment based on urgent/high tasks."""
        if self.urgent_tasks > 0:
            return "critical"
        if self.high_priority_tasks > 3:
            return "high"
        if self.total_tasks > 10:
            return "medium"
        return "low"


class CrossHostelComparison(BaseSchema):
    """
    Comparison metrics across hostels.
    
    Preserves original structure and adds helper metrics.
    """

    # Best performers
    highest_occupancy_hostel: TopPerformer
    highest_revenue_hostel: TopPerformer
    highest_rated_hostel: TopPerformer

    # Areas needing attention
    lowest_occupancy_hostel: BottomPerformer
    most_complaints_hostel: BottomPerformer
    most_overdue_payments_hostel: BottomPerformer

    # Comparative metrics
    occupancy_comparison: List[HostelMetricComparison]
    revenue_comparison: List[HostelMetricComparison]
    complaint_rate_comparison: List[HostelMetricComparison]

    @computed_field
    @property
    def hostel_count(self) -> int:
        """Number of hostels included in comparison (approx by occupancy list)."""
        return len(self.occupancy_comparison)


class MultiHostelDashboard(BaseSchema):
    """
    Unified dashboard for multi-hostel admin.
    
    Preserves original fields and adds high-level computed indicators.
    """

    admin_id: UUID
    admin_name: str
    total_hostels_managed: int

    # Aggregated statistics
    aggregated_stats: AggregatedStats

    # Individual hostel quick stats
    hostel_stats: List[HostelQuickStats]

    # Cross-hostel comparisons
    comparisons: CrossHostelComparison

    # Consolidated notifications
    total_notifications: int
    notifications_by_hostel: Dict[UUID, int]

    # Consolidated pending tasks
    total_pending_tasks: int
    tasks_by_hostel: Dict[UUID, HostelTaskSummary]

    @computed_field
    @property
    def has_critical_hostels(self) -> bool:
        """Whether any hostel is in a critical state."""
        return any(h.status_color == "red" for h in self.hostel_stats)

    @computed_field
    @property
    def average_alerts_per_hostel(self) -> Decimal:
        """Average number of notifications per hostel."""
        if self.total_hostels_managed == 0:
            return Decimal("0.00")
        return Decimal(self.total_notifications / self.total_hostels_managed).quantize(
            Decimal("0.01")
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\admin\__init__.py ---
from __future__ import annotations

from app.schemas.admin.admin_hostel_assignment import (
    AdminHostelAssignment,
    AssignmentCreate,
    AssignmentList,
    AssignmentUpdate,
    BulkAssignment,
    HostelAdminItem,
    HostelAdminList,
    RevokeAssignment,
)
from app.schemas.admin.admin_override import (
    AdminOverrideRequest,
    OverrideLog,
    OverrideReason,
    OverrideSummary,
    SupervisorOverrideStats,
)
from app.schemas.admin.admin_permissions import (
    AdminPermissions,
    PermissionCheck,
    PermissionMatrix,
    RolePermissions,
)
from app.schemas.admin.hostel_context import (
    ActiveHostelResponse,
    ContextHistory,
    ContextSwitch,
    HostelContext,
    HostelSwitchRequest,
)
from app.schemas.admin.hostel_selector import (
    FavoriteHostelItem,
    FavoriteHostels,
    HostelSelectorItem,
    HostelSelectorResponse,
    RecentHostelItem,
    RecentHostels,
    UpdateFavoriteRequest,
)
from app.schemas.admin.multi_hostel_dashboard import (
    AggregatedStats,
    BottomPerformer,
    CrossHostelComparison,
    HostelMetricComparison,
    HostelQuickStats,
    HostelTaskSummary,
    MultiHostelDashboard,
    TopPerformer,
)

__all__ = [
    # Hostel Assignment Management
    "AdminHostelAssignment",
    "AssignmentCreate",
    "AssignmentUpdate",
    "BulkAssignment",
    "RevokeAssignment",
    "AssignmentList",
    "HostelAdminList",
    "HostelAdminItem",
    
    # Hostel Context Management
    "HostelContext",
    "HostelSwitchRequest",
    "ActiveHostelResponse",
    "ContextHistory",
    "ContextSwitch",
    
    # Hostel Selector UI
    "HostelSelectorResponse",
    "HostelSelectorItem",
    "RecentHostels",
    "RecentHostelItem",
    "FavoriteHostels",
    "FavoriteHostelItem",
    "UpdateFavoriteRequest",
    
    # Multi-Hostel Dashboard
    "MultiHostelDashboard",
    "AggregatedStats",
    "HostelQuickStats",
    "CrossHostelComparison",
    "TopPerformer",
    "BottomPerformer",
    "HostelMetricComparison",
    "HostelTaskSummary",
    
    # Admin Override System
    "AdminOverrideRequest",
    "OverrideLog",
    "OverrideReason",
    "OverrideSummary",
    "SupervisorOverrideStats",
    
    # Admin Permissions
    "AdminPermissions",
    "PermissionMatrix",
    "RolePermissions",
    "PermissionCheck",
]


# Package metadata
__author__ = "Hostel Management System Team"
__description__ = "Admin management schemas for multi-hostel operations"
