### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\attendance ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\attendance =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\attendance\attendance_alert.py ---
# --- File: app/schemas/attendance/attendance_alert.py ---
"""
Attendance alert schemas for proactive monitoring.

Provides alert generation, configuration, and management schemas
for identifying and responding to attendance issues.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema

__all__ = [
    "AttendanceAlert",
    "AlertConfig",
    "AlertTrigger",
    "AlertAcknowledgment",
    "AlertList",
    "AlertSummary",
]


class AttendanceAlert(BaseResponseSchema):
    """
    Attendance alert record with tracking and resolution.
    
    Represents an automatically or manually triggered alert
    for attendance-related issues.
    """

    alert_id: UUID = Field(
        ...,
        description="Alert unique identifier",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Student room number",
    )

    # Alert classification
    alert_type: str = Field(
        ...,
        pattern=r"^(low_attendance|consecutive_absences|late_entry|irregular_pattern|policy_violation)$",
        description="Type of alert",
    )
    severity: str = Field(
        ...,
        pattern=r"^(low|medium|high|critical)$",
        description="Alert severity level",
    )
    category: str = Field(
        default="attendance",
        pattern=r"^(attendance|behavior|policy|system)$",
        description="Alert category",
    )

    # Alert content
    message: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Alert message for display",
    )
    details: Dict[str, any] = Field(
        ...,
        description="Alert-specific details (JSON)",
    )
    recommendation: Optional[str] = Field(
        None,
        max_length=500,
        description="Recommended action to resolve alert",
    )

    # Trigger information
    triggered_at: datetime = Field(
        ...,
        description="Alert trigger timestamp",
    )
    triggered_by_rule: Optional[str] = Field(
        None,
        description="Name of rule that triggered alert",
    )
    auto_generated: bool = Field(
        default=True,
        description="Whether alert was auto-generated",
    )
    manual_trigger_by: Optional[UUID] = Field(
        None,
        description="User ID if manually triggered",
    )

    # Acknowledgment
    acknowledged: bool = Field(
        False,
        description="Whether alert has been acknowledged",
    )
    acknowledged_by: Optional[UUID] = Field(
        None,
        description="User ID who acknowledged",
    )
    acknowledged_by_name: Optional[str] = Field(
        None,
        description="Name of user who acknowledged",
    )
    acknowledged_at: Optional[datetime] = Field(
        None,
        description="Acknowledgment timestamp",
    )
    acknowledgment_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Notes added during acknowledgment",
    )

    # Actions and resolution
    actions_taken: List[str] = Field(
        default_factory=list,
        description="List of actions taken in response",
    )
    assigned_to: Optional[UUID] = Field(
        None,
        description="User ID assigned to handle alert",
    )
    assigned_to_name: Optional[str] = Field(
        None,
        description="Name of assigned user",
    )
    resolved: bool = Field(
        False,
        description="Whether alert has been resolved",
    )
    resolved_at: Optional[datetime] = Field(
        None,
        description="Resolution timestamp",
    )
    resolved_by: Optional[UUID] = Field(
        None,
        description="User ID who resolved",
    )
    resolution_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Resolution details",
    )

    # Escalation
    escalated: bool = Field(
        default=False,
        description="Whether alert has been escalated",
    )
    escalated_at: Optional[datetime] = Field(
        None,
        description="Escalation timestamp",
    )
    escalation_level: int = Field(
        default=0,
        ge=0,
        le=5,
        description="Current escalation level",
    )

    # Notification tracking
    notifications_sent: List[Dict[str, any]] = Field(
        default_factory=list,
        description="Record of notifications sent",
    )

    @field_validator("message", "recommendation", "acknowledgment_notes", "resolution_notes")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_alert_status(self) -> "AttendanceAlert":
        """
        Validate alert status consistency.
        
        Ensures timestamps and user IDs are provided when status flags are set.
        """
        if self.acknowledged:
            if self.acknowledged_by is None:
                raise ValueError(
                    "acknowledged_by is required when alert is acknowledged"
                )
            if self.acknowledged_at is None:
                raise ValueError(
                    "acknowledged_at is required when alert is acknowledged"
                )

        if self.resolved:
            if self.resolved_at is None:
                raise ValueError(
                    "resolved_at is required when alert is resolved"
                )
            # Resolved alerts should be acknowledged first
            if not self.acknowledged:
                raise ValueError(
                    "Alert must be acknowledged before being resolved"
                )

        if self.escalated and self.escalated_at is None:
            raise ValueError(
                "escalated_at is required when alert is escalated"
            )

        if not self.auto_generated and self.manual_trigger_by is None:
            raise ValueError(
                "manual_trigger_by is required for manually triggered alerts"
            )

        return self


class AlertConfig(BaseSchema):
    """
    Alert configuration for attendance monitoring.
    
    Defines rules and thresholds for automatic alert generation
    and notification preferences.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )

    # Low attendance alerts
    enable_low_attendance_alerts: bool = Field(
        True,
        description="Enable low attendance alerts",
    )
    low_attendance_threshold: Decimal = Field(
        Decimal("75.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Attendance percentage threshold for alerts",
    )
    low_attendance_check_period: str = Field(
        "monthly",
        pattern=r"^(weekly|monthly|semester)$",
        description="Period for low attendance calculation",
    )

    # Consecutive absence alerts
    enable_consecutive_absence_alerts: bool = Field(
        True,
        description="Enable consecutive absence alerts",
    )
    consecutive_absence_threshold: int = Field(
        3,
        ge=1,
        le=30,
        description="Alert after N consecutive absences",
    )

    # Late entry alerts
    enable_late_entry_alerts: bool = Field(
        True,
        description="Enable late entry alerts",
    )
    late_entry_count_threshold: int = Field(
        5,
        ge=1,
        le=31,
        description="Alert after N late entries in evaluation period",
    )
    late_entry_evaluation_period: str = Field(
        "monthly",
        pattern=r"^(weekly|monthly)$",
        description="Period for late entry counting",
    )

    # Pattern detection
    enable_pattern_detection: bool = Field(
        False,
        description="Enable irregular pattern detection (AI/ML based)",
    )
    pattern_sensitivity: str = Field(
        "medium",
        pattern=r"^(low|medium|high)$",
        description="Sensitivity for pattern detection",
    )

    # Absence spike detection
    enable_absence_spike_alerts: bool = Field(
        default=True,
        description="Alert on sudden increase in absences",
    )
    absence_spike_threshold: int = Field(
        default=3,
        ge=2,
        description="Alert when absences increase by N in short period",
    )

    # Notification preferences
    notify_supervisor: bool = Field(
        True,
        description="Send alerts to supervisor",
    )
    notify_admin: bool = Field(
        True,
        description="Send alerts to admin",
    )
    notify_guardian: bool = Field(
        True,
        description="Send alerts to guardian",
    )
    notify_student: bool = Field(
        True,
        description="Send alerts to student",
    )

    # Notification channels
    notification_channels: List[str] = Field(
        default_factory=lambda: ["email", "push"],
        description="Notification delivery channels",
    )

    # Escalation settings
    auto_escalate_enabled: bool = Field(
        default=True,
        description="Enable automatic alert escalation",
    )
    auto_escalate_after_days: int = Field(
        7,
        ge=1,
        le=30,
        description="Auto-escalate unacknowledged alerts after N days",
    )
    max_escalation_level: int = Field(
        default=3,
        ge=1,
        le=5,
        description="Maximum escalation level",
    )

    # Alert suppression
    suppress_duplicate_alerts: bool = Field(
        default=True,
        description="Suppress duplicate alerts within time window",
    )
    duplicate_suppression_hours: int = Field(
        default=24,
        ge=1,
        le=168,
        description="Hours to suppress duplicate alerts",
    )

    # Working hours
    alert_only_during_hours: bool = Field(
        default=False,
        description="Only send alerts during specified hours",
    )
    alert_start_time: Optional[time] = Field(
        None,
        description="Start time for alert notifications",
    )
    alert_end_time: Optional[time] = Field(
        None,
        description="End time for alert notifications",
    )

    @field_validator("notification_channels")
    @classmethod
    def validate_channels(cls, v: List[str]) -> List[str]:
        """Validate notification channels are supported."""
        valid_channels = {"email", "sms", "push", "whatsapp"}
        for channel in v:
            if channel not in valid_channels:
                raise ValueError(f"Invalid notification channel: {channel}")
        return v

    @model_validator(mode="after")
    def validate_config_consistency(self) -> "AlertConfig":
        """Validate configuration consistency."""
        # Validate alert hours if enabled
        if self.alert_only_during_hours:
            if self.alert_start_time is None or self.alert_end_time is None:
                raise ValueError(
                    "alert_start_time and alert_end_time are required when alert_only_during_hours is True"
                )

        # At least one notification recipient should be enabled
        if not any([
            self.notify_supervisor,
            self.notify_admin,
            self.notify_guardian,
            self.notify_student,
        ]):
            raise ValueError(
                "At least one notification recipient must be enabled"
            )

        return self


class AlertTrigger(BaseCreateSchema):
    """
    Manual alert trigger request.
    
    Allows authorized users to manually create alerts for
    specific attendance concerns.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    alert_type: str = Field(
        ...,
        pattern=r"^(low_attendance|consecutive_absences|late_entry|irregular_pattern|custom)$",
        description="Type of alert to trigger",
    )
    severity: str = Field(
        "medium",
        pattern=r"^(low|medium|high|critical)$",
        description="Alert severity level",
    )
    custom_message: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Custom alert message",
    )
    details: Optional[Dict[str, any]] = Field(
        None,
        description="Additional alert details",
    )
    assign_to: Optional[UUID] = Field(
        None,
        description="User ID to assign alert to",
    )
    notify_immediately: bool = Field(
        default=True,
        description="Send notifications immediately",
    )
    triggered_by: UUID = Field(
        ...,
        description="User ID triggering the alert",
    )

    @field_validator("custom_message")
    @classmethod
    def validate_message(cls, v: str) -> str:
        """Validate and normalize message."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Message must be at least 10 characters")
        return v


class AlertAcknowledgment(BaseCreateSchema):
    """
    Acknowledge attendance alert.
    
    Records acknowledgment of an alert with action details.
    """

    alert_id: UUID = Field(
        ...,
        description="Alert unique identifier",
    )
    acknowledged_by: UUID = Field(
        ...,
        description="User ID acknowledging the alert",
    )
    action_taken: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Description of action taken",
    )
    assign_to: Optional[UUID] = Field(
        None,
        description="User ID to assign for follow-up",
    )
    mark_resolved: bool = Field(
        default=False,
        description="Mark alert as resolved",
    )
    additional_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional notes",
    )

    @field_validator("action_taken", "additional_notes")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            if isinstance(v, str) and len(v) < 10 and v == cls.model_fields.get("action_taken"):
                raise ValueError("action_taken must be at least 10 characters")
            return v if v else None
        return None


class AlertList(BaseSchema):
    """
    List of alerts with summary statistics.
    
    Provides paginated alert list with aggregate metrics.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel filter (if applicable)",
    )
    student_id: Optional[UUID] = Field(
        None,
        description="Student filter (if applicable)",
    )
    date_from: Optional[date] = Field(
        None,
        description="Filter alerts from this date",
    )
    date_to: Optional[date] = Field(
        None,
        description="Filter alerts to this date",
    )

    # Summary statistics
    total_alerts: int = Field(
        ...,
        ge=0,
        description="Total number of alerts",
    )
    unacknowledged_alerts: int = Field(
        ...,
        ge=0,
        description="Number of unacknowledged alerts",
    )
    unresolved_alerts: int = Field(
        ...,
        ge=0,
        description="Number of unresolved alerts",
    )
    critical_alerts: int = Field(
        ...,
        ge=0,
        description="Number of critical severity alerts",
    )
    escalated_alerts: int = Field(
        default=0,
        ge=0,
        description="Number of escalated alerts",
    )

    # Alert breakdown by type
    alerts_by_type: Dict[str, int] = Field(
        default_factory=dict,
        description="Alert counts by type",
    )

    # Alert breakdown by severity
    alerts_by_severity: Dict[str, int] = Field(
        default_factory=dict,
        description="Alert counts by severity",
    )

    # Alert list
    alerts: List[AttendanceAlert] = Field(
        ...,
        description="List of alert records",
    )


class AlertSummary(BaseSchema):
    """
    Alert summary for dashboard display.
    
    Provides high-level overview of alerts for monitoring dashboards.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    period_start: date = Field(
        ...,
        description="Summary period start date",
    )
    period_end: date = Field(
        ...,
        description="Summary period end date",
    )

    # Overall counts
    total_alerts: int = Field(
        ...,
        ge=0,
        description="Total alerts in period",
    )
    new_alerts_today: int = Field(
        default=0,
        ge=0,
        description="Alerts triggered today",
    )

    # By type
    low_attendance_alerts: int = Field(
        ...,
        ge=0,
        description="Low attendance alerts",
    )
    consecutive_absence_alerts: int = Field(
        ...,
        ge=0,
        description="Consecutive absence alerts",
    )
    late_entry_alerts: int = Field(
        ...,
        ge=0,
        description="Late entry alerts",
    )
    pattern_alerts: int = Field(
        ...,
        ge=0,
        description="Irregular pattern alerts",
    )
    policy_violation_alerts: int = Field(
        default=0,
        ge=0,
        description="Policy violation alerts",
    )

    # By severity
    critical_count: int = Field(
        ...,
        ge=0,
        description="Critical alerts",
    )
    high_count: int = Field(
        ...,
        ge=0,
        description="High severity alerts",
    )
    medium_count: int = Field(
        ...,
        ge=0,
        description="Medium severity alerts",
    )
    low_count: int = Field(
        ...,
        ge=0,
        description="Low severity alerts",
    )

    # Status breakdown
    acknowledged_count: int = Field(
        ...,
        ge=0,
        description="Acknowledged alerts",
    )
    resolved_count: int = Field(
        ...,
        ge=0,
        description="Resolved alerts",
    )
    pending_count: int = Field(
        ...,
        ge=0,
        description="Pending/unacknowledged alerts",
    )
    escalated_count: int = Field(
        default=0,
        ge=0,
        description="Escalated alerts",
    )

    # Performance metrics
    average_resolution_time_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average time to resolve alerts (hours)",
    )
    average_acknowledgment_time_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average time to acknowledge alerts (hours)",
    )

    # Student impact
    students_with_alerts: int = Field(
        default=0,
        ge=0,
        description="Number of students with active alerts",
    )
    students_with_critical_alerts: int = Field(
        default=0,
        ge=0,
        description="Students with critical alerts",
    )

    # Trend indicator
    alert_trend: str = Field(
        default="stable",
        pattern=r"^(increasing|decreasing|stable)$",
        description="Alert volume trend",
    )

    @field_validator("period_end")
    @classmethod
    def validate_period(cls, v: date, info) -> date:
        """Validate period dates."""
        if "period_start" in info.data:
            if v < info.data["period_start"]:
                raise ValueError("period_end must be after period_start")
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\attendance\attendance_base.py ---
# --- File: app/schemas/attendance/attendance_base.py ---
"""
Base attendance schemas with comprehensive validation and type safety.

This module provides foundational schemas for attendance tracking including
single and bulk operations with enhanced validation logic.
"""

from __future__ import annotations

from datetime import date, time
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import AttendanceMode, AttendanceStatus

__all__ = [
    "AttendanceBase",
    "AttendanceCreate",
    "AttendanceUpdate",
    "BulkAttendanceCreate",
    "SingleAttendanceRecord",
]


class AttendanceBase(BaseSchema):
    """
    Base attendance schema with core fields.
    
    Provides common attendance attributes used across create/update operations.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    attendance_date: date = Field(
        ...,
        description="Date of attendance record",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Student check-in time",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Student check-out time",
    )
    status: AttendanceStatus = Field(
        AttendanceStatus.PRESENT,
        description="Attendance status",
    )
    is_late: bool = Field(
        False,
        description="Whether student arrived late",
    )
    late_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,  # Max 24 hours
        description="Minutes late (if applicable)",
    )
    attendance_mode: AttendanceMode = Field(
        AttendanceMode.MANUAL,
        description="Method used to record attendance",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked the attendance",
    )
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Supervisor ID who verified/marked attendance",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes or comments",
    )

    @field_validator("attendance_date")
    @classmethod
    def validate_attendance_date(cls, v: date) -> date:
        """
        Validate attendance date is not in future.
        
        Attendance should only be marked for current or past dates.
        """
        if v > date.today():
            raise ValueError("Attendance cannot be marked for future dates")
        return v

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize notes by stripping whitespace."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_check_times(self) -> "AttendanceBase":
        """
        Validate check-in and check-out time consistency.
        
        Ensures:
        - Check-out time is after check-in time (if both provided)
        - Late status is consistent with late_minutes
        - Absent students don't have check-in times
        """
        # Validate check-out is after check-in
        if self.check_in_time and self.check_out_time:
            if self.check_out_time <= self.check_in_time:
                raise ValueError(
                    "Check-out time must be after check-in time"
                )

        # Validate late status consistency
        if self.is_late and self.late_minutes is None:
            raise ValueError(
                "late_minutes must be provided when is_late is True"
            )

        if not self.is_late and self.late_minutes is not None:
            if self.late_minutes > 0:
                raise ValueError(
                    "is_late must be True when late_minutes is provided"
                )

        # Absent students shouldn't have check-in times
        if self.status == AttendanceStatus.ABSENT:
            if self.check_in_time or self.check_out_time:
                raise ValueError(
                    "Absent students cannot have check-in or check-out times"
                )
            if self.is_late or self.late_minutes:
                raise ValueError(
                    "Absent students cannot be marked as late"
                )

        return self


class AttendanceCreate(AttendanceBase, BaseCreateSchema):
    """
    Create attendance record with location and device tracking.
    
    Extends base schema with mobile app specific fields for geo-location
    and device information tracking.
    """

    location_lat: Optional[Decimal] = Field(
        None,
        ge=-90,
        le=90,
        description="Latitude coordinate for mobile check-in",
    )
    location_lng: Optional[Decimal] = Field(
        None,
        ge=-180,
        le=180,
        description="Longitude coordinate for mobile check-in",
    )
    device_info: Optional[dict] = Field(
        None,
        description="Device information for mobile app check-ins",
    )

    @model_validator(mode="after")
    def validate_location_completeness(self) -> "AttendanceCreate":
        """
        Validate location coordinates are provided together.
        
        Both latitude and longitude must be provided or both must be None.
        """
        has_lat = self.location_lat is not None
        has_lng = self.location_lng is not None

        if has_lat != has_lng:
            raise ValueError(
                "Both latitude and longitude must be provided together"
            )

        return self


class AttendanceUpdate(BaseUpdateSchema):
    """
    Update attendance record with partial field updates.
    
    All fields are optional for flexible partial updates.
    """

    check_in_time: Optional[time] = Field(
        None,
        description="Updated check-in time",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Updated check-out time",
    )
    status: Optional[AttendanceStatus] = Field(
        None,
        description="Updated attendance status",
    )
    is_late: Optional[bool] = Field(
        None,
        description="Updated late status",
    )
    late_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Updated late minutes",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Updated notes",
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize notes by stripping whitespace."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_update_consistency(self) -> "AttendanceUpdate":
        """
        Validate consistency of update fields.
        
        Ensures late status and minutes are consistent when both are updated.
        """
        if self.is_late is not None and self.late_minutes is not None:
            if self.is_late and self.late_minutes == 0:
                raise ValueError(
                    "late_minutes must be greater than 0 when is_late is True"
                )
            if not self.is_late and self.late_minutes > 0:
                raise ValueError(
                    "is_late must be True when late_minutes is greater than 0"
                )

        return self


class SingleAttendanceRecord(BaseSchema):
    """
    Single attendance record for bulk operations.
    
    Lightweight schema used within bulk attendance creation.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    status: AttendanceStatus = Field(
        AttendanceStatus.PRESENT,
        description="Attendance status",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time",
    )
    is_late: bool = Field(
        False,
        description="Late arrival flag",
    )
    late_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Minutes late",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes",
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize notes by stripping whitespace."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_late_consistency(self) -> "SingleAttendanceRecord":
        """Validate late status and minutes consistency."""
        if self.is_late and self.late_minutes is None:
            raise ValueError(
                "late_minutes must be provided when is_late is True"
            )

        if not self.is_late and self.late_minutes is not None and self.late_minutes > 0:
            raise ValueError(
                "is_late must be True when late_minutes is provided"
            )

        # Absent students shouldn't be late
        if self.status == AttendanceStatus.ABSENT:
            if self.is_late or self.late_minutes:
                raise ValueError(
                    "Absent students cannot be marked as late"
                )

        return self


class BulkAttendanceCreate(BaseCreateSchema):
    """
    Bulk create multiple attendance records efficiently.
    
    Allows marking attendance for multiple students in a single operation
    with validation to prevent duplicate entries.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    attendance_date: date = Field(
        ...,
        description="Date for all attendance records",
    )
    records: List[SingleAttendanceRecord] = Field(
        ...,
        min_length=1,
        max_length=500,
        description="List of student attendance records",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked attendance",
    )
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Supervisor ID who verified attendance",
    )

    @field_validator("attendance_date")
    @classmethod
    def validate_attendance_date(cls, v: date) -> date:
        """Validate attendance date is not in future."""
        if v > date.today():
            raise ValueError("Attendance cannot be marked for future dates")
        return v

    @model_validator(mode="after")
    def validate_unique_students(self) -> "BulkAttendanceCreate":
        """
        Ensure no duplicate student IDs in bulk operation.
        
        Prevents multiple attendance records for same student on same date.
        """
        student_ids = [record.student_id for record in self.records]
        unique_ids = set(student_ids)

        if len(student_ids) != len(unique_ids):
            # Find duplicates
            seen = set()
            duplicates = []
            for student_id in student_ids:
                if student_id in seen:
                    duplicates.append(str(student_id))
                seen.add(student_id)

            raise ValueError(
                f"Duplicate student IDs found in bulk operation: {', '.join(duplicates)}"
            )

        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\attendance\attendance_filters.py ---
# --- File: app/schemas/attendance/attendance_filters.py ---
"""
Attendance filter schemas for querying and exporting.

Provides comprehensive filtering capabilities with validation
for date ranges, status filters, and export configurations.
"""

from __future__ import annotations

from datetime import date
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import AttendanceMode, AttendanceStatus
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "AttendanceFilterParams",
    "DateRangeRequest",
    "AttendanceExportRequest",
]


class AttendanceFilterParams(BaseFilterSchema):
    """
    Comprehensive attendance filter parameters.
    
    Supports multi-dimensional filtering by hostel, student, date,
    status, and marking metadata.
    """

    # Hostel filters
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by specific hostel",
    )
    hostel_ids: Optional[List[UUID]] = Field(
        None,
        min_length=1,
        max_length=100,
        description="Filter by multiple hostels",
    )

    # Student filters
    student_id: Optional[UUID] = Field(
        None,
        description="Filter by specific student",
    )
    student_ids: Optional[List[UUID]] = Field(
        None,
        min_length=1,
        max_length=500,
        description="Filter by multiple students",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Filter by room",
    )
    room_ids: Optional[List[UUID]] = Field(
        None,
        min_length=1,
        max_length=100,
        description="Filter by multiple rooms",
    )

    # Date range filters
    date_from: Optional[date] = Field(
        None,
        description="Start date (inclusive)",
    )
    date_to: Optional[date] = Field(
        None,
        description="End date (inclusive)",
    )
    specific_date: Optional[date] = Field(
        None,
        description="Filter by specific date",
    )

    # Status filters
    status: Optional[AttendanceStatus] = Field(
        None,
        description="Filter by specific status",
    )
    statuses: Optional[List[AttendanceStatus]] = Field(
        None,
        min_length=1,
        description="Filter by multiple statuses",
    )
    exclude_statuses: Optional[List[AttendanceStatus]] = Field(
        None,
        min_length=1,
        description="Exclude specific statuses",
    )

    # Late filter
    late_only: Optional[bool] = Field(
        None,
        description="Filter only late arrivals (True) or exclude late (False)",
    )

    # Marking metadata
    marked_by: Optional[UUID] = Field(
        None,
        description="Filter by user who marked attendance",
    )
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Filter by supervisor",
    )
    attendance_mode: Optional[AttendanceMode] = Field(
        None,
        description="Filter by marking method",
    )

    # Advanced filters
    has_notes: Optional[bool] = Field(
        None,
        description="Filter records with/without notes",
    )
    has_location: Optional[bool] = Field(
        None,
        description="Filter records with/without location data",
    )

    @field_validator("date_to")
    @classmethod
    def validate_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate end date is after or equal to start date."""
        if v is not None and "date_from" in info.data:
            date_from = info.data["date_from"]
            if date_from is not None and v < date_from:
                raise ValueError("date_to must be after or equal to date_from")
        return v

    @model_validator(mode="after")
    def validate_filter_consistency(self) -> "AttendanceFilterParams":
        """
        Validate filter parameter consistency.
        
        Ensures:
        - Date filters are logically consistent
        - List filters are not empty
        - Conflicting filters are not used together
        """
        # Validate specific_date doesn't conflict with range
        if self.specific_date is not None:
            if self.date_from is not None or self.date_to is not None:
                raise ValueError(
                    "Cannot use specific_date with date_from/date_to"
                )

        # Validate status filters
        if self.status is not None and self.statuses is not None:
            raise ValueError(
                "Cannot use both status and statuses filters"
            )

        if self.statuses is not None and self.exclude_statuses is not None:
            overlap = set(self.statuses) & set(self.exclude_statuses)
            if overlap:
                raise ValueError(
                    "Cannot include and exclude the same statuses"
                )

        # Validate student filters
        if self.student_id is not None and self.student_ids is not None:
            raise ValueError(
                "Cannot use both student_id and student_ids filters"
            )

        # Validate hostel filters
        if self.hostel_id is not None and self.hostel_ids is not None:
            raise ValueError(
                "Cannot use both hostel_id and hostel_ids filters"
            )

        return self


class DateRangeRequest(BaseFilterSchema):
    """
    Simple date range request with validation.
    
    Used for reports and queries requiring date range specification.
    """

    start_date: date = Field(
        ...,
        description="Start date (inclusive)",
    )
    end_date: date = Field(
        ...,
        description="End date (inclusive)",
    )

    @field_validator("start_date")
    @classmethod
    def validate_start_date(cls, v: date) -> date:
        """Ensure start date is not too far in the past."""
        # Allow up to 5 years of historical data
        max_past_days = 365 * 5
        days_diff = (date.today() - v).days
        
        if days_diff > max_past_days:
            raise ValueError(
                f"start_date cannot be more than {max_past_days} days in the past"
            )
        
        return v

    @field_validator("end_date")
    @classmethod
    def validate_end_date(cls, v: date, info) -> date:
        """
        Validate end date constraints.
        
        Ensures:
        - End date is after or equal to start date
        - End date is not in future
        - Date range is reasonable (not too large)
        """
        # Validate not in future
        if v > date.today():
            raise ValueError("end_date cannot be in the future")

        # Validate against start date
        if "start_date" in info.data:
            start_date = info.data["start_date"]
            if v < start_date:
                raise ValueError("end_date must be after or equal to start_date")

            # Validate range is not too large (max 1 year)
            days_diff = (v - start_date).days
            if days_diff > 365:
                raise ValueError(
                    "Date range cannot exceed 365 days"
                )

        return v


class AttendanceExportRequest(BaseFilterSchema):
    """
    Export attendance data with format and options.
    
    Supports multiple export formats with customizable content
    and grouping options.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel to export data for",
    )
    date_range: DateRangeFilter = Field(
        ...,
        description="Date range for export",
    )

    # Student filters
    student_ids: Optional[List[UUID]] = Field(
        None,
        max_length=500,
        description="Export specific students only",
    )
    room_ids: Optional[List[UUID]] = Field(
        None,
        max_length=100,
        description="Export specific rooms only",
    )

    # Status filters
    statuses: Optional[List[AttendanceStatus]] = Field(
        None,
        description="Filter by attendance statuses",
    )
    include_late_only: bool = Field(
        False,
        description="Include only late arrivals",
    )

    # Format
    format: str = Field(
        "csv",
        pattern=r"^(csv|excel|pdf)$",
        description="Export format: csv, excel, or pdf",
    )

    # Content options
    include_summary: bool = Field(
        True,
        description="Include summary statistics",
    )
    include_percentage: bool = Field(
        True,
        description="Include attendance percentage calculations",
    )
    include_notes: bool = Field(
        False,
        description="Include notes column",
    )
    include_location: bool = Field(
        False,
        description="Include location data (if available)",
    )
    include_device_info: bool = Field(
        False,
        description="Include device information",
    )

    # Grouping and sorting
    group_by: str = Field(
        "student",
        pattern=r"^(student|date|room|status)$",
        description="Group records by: student, date, room, or status",
    )
    sort_by: str = Field(
        "date",
        pattern=r"^(date|student_name|room|status)$",
        description="Sort records by field",
    )
    sort_order: str = Field(
        "asc",
        pattern=r"^(asc|desc)$",
        description="Sort order: ascending or descending",
    )

    # Output options
    file_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Custom filename for export (without extension)",
    )
    include_timestamp: bool = Field(
        True,
        description="Include timestamp in filename",
    )

    @field_validator("file_name")
    @classmethod
    def validate_filename(cls, v: Optional[str]) -> Optional[str]:
        """Validate and sanitize filename."""
        if v is not None:
            # Remove invalid characters
            import re
            v = re.sub(r'[<>:"/\\|?*]', '', v)
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_export_config(self) -> "AttendanceExportRequest":
        """
        Validate export configuration consistency.
        
        Ensures compatible options are selected based on format.
        """
        # PDF-specific validations
        if self.format == "pdf":
            if self.group_by not in ["student", "date"]:
                raise ValueError(
                    "PDF format supports only 'student' or 'date' grouping"
                )

        # Validate date range
        if self.date_range.start_date and self.date_range.end_date:
            days_diff = (
                self.date_range.end_date - self.date_range.start_date
            ).days
            
            # Large exports might cause performance issues
            if days_diff > 365:
                raise ValueError(
                    "Export date range cannot exceed 365 days"
                )

        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\attendance\attendance_policy.py ---
# --- File: app/schemas/attendance/attendance_policy.py ---
"""
Attendance policy configuration schemas.

Defines policy rules, thresholds, and violation tracking for
attendance management with comprehensive validation.
"""

from __future__ import annotations

from datetime import date, time
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema, BaseUpdateSchema

__all__ = [
    "AttendancePolicy",
    "PolicyConfig",
    "PolicyUpdate",
    "PolicyViolation",
]


class AttendancePolicy(BaseResponseSchema):
    """
    Attendance policy configuration for a hostel.
    
    Defines rules, thresholds, and automated behaviors for
    attendance tracking and enforcement.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )

    # Minimum requirements
    minimum_attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Minimum required attendance percentage",
    )

    # Late entry configuration
    late_entry_threshold_minutes: int = Field(
        ...,
        ge=0,
        le=240,
        description="Minutes after expected time to mark as late",
    )
    grace_period_minutes: int = Field(
        default=5,
        ge=0,
        le=30,
        description="Grace period before marking late",
    )
    grace_days_per_month: int = Field(
        ...,
        ge=0,
        le=31,
        description="Allowed late entries per month without penalty",
    )

    # Absence alerts
    consecutive_absence_alert_days: int = Field(
        ...,
        ge=1,
        le=30,
        description="Alert after N consecutive absences",
    )
    total_absence_alert_threshold: int = Field(
        default=10,
        ge=1,
        description="Alert after N total absences in period",
    )

    # Notification settings
    notify_guardian_on_absence: bool = Field(
        True,
        description="Send guardian notification on absence",
    )
    notify_admin_on_low_attendance: bool = Field(
        True,
        description="Send admin notification for low attendance",
    )
    notify_student_on_low_attendance: bool = Field(
        default=True,
        description="Send student notification for low attendance",
    )
    low_attendance_threshold: Decimal = Field(
        Decimal("75.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Threshold for low attendance notifications",
    )

    # Auto-marking configuration
    auto_mark_absent_enabled: bool = Field(
        default=False,
        description="Enable automatic absent marking",
    )
    auto_mark_absent_after_time: Optional[time] = Field(
        None,
        description="Auto mark absent if not checked in by this time",
    )

    # Weekend and holiday handling
    track_weekend_attendance: bool = Field(
        default=False,
        description="Track attendance on weekends",
    )
    track_holiday_attendance: bool = Field(
        default=False,
        description="Track attendance on holidays",
    )

    # Policy status
    is_active: bool = Field(
        True,
        description="Whether policy is currently active",
    )
    effective_from: Optional[date] = Field(
        None,
        description="Date from which policy is effective",
    )
    effective_until: Optional[date] = Field(
        None,
        description="Date until which policy is effective",
    )

    @field_validator("minimum_attendance_percentage", "low_attendance_threshold")
    @classmethod
    def round_percentage(cls, v: Decimal) -> Decimal:
        """Round percentage to 2 decimal places."""
        return round(v, 2)

    @model_validator(mode="after")
    def validate_policy_consistency(self) -> "AttendancePolicy":
        """
        Validate policy configuration consistency.
        
        Ensures:
        - Low attendance threshold is below minimum requirement
        - Effective dates are logical
        - Auto-mark time is set if enabled
        """
        # Low attendance threshold should be less than minimum
        if self.low_attendance_threshold > self.minimum_attendance_percentage:
            raise ValueError(
                "low_attendance_threshold should be less than minimum_attendance_percentage"
            )

        # Validate effective dates
        if self.effective_from and self.effective_until:
            if self.effective_until < self.effective_from:
                raise ValueError(
                    "effective_until must be after effective_from"
                )

        # Auto-mark validation
        if self.auto_mark_absent_enabled and self.auto_mark_absent_after_time is None:
            raise ValueError(
                "auto_mark_absent_after_time is required when auto_mark_absent_enabled is True"
            )

        return self


class PolicyConfig(BaseSchema):
    """
    Extended policy configuration with calculation rules.
    
    Defines how attendance is calculated and what factors are
    considered in the calculation.
    """

    # Calculation settings
    calculation_period: str = Field(
        "monthly",
        pattern=r"^(weekly|monthly|semester|yearly|custom)$",
        description="Period for attendance calculation",
    )
    custom_period_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Custom period length in days (if calculation_period is 'custom')",
    )

    # Leave handling
    count_leave_as_absent: bool = Field(
        False,
        description="Whether to count approved leaves as absent",
    )
    count_leave_as_present: bool = Field(
        True,
        description="Whether to count approved leaves as present",
    )
    max_leaves_per_month: int = Field(
        3,
        ge=0,
        le=31,
        description="Maximum allowed leaves per month",
    )
    max_leaves_per_semester: Optional[int] = Field(
        None,
        ge=0,
        description="Maximum allowed leaves per semester",
    )

    # Weekend configuration
    include_weekends: bool = Field(
        False,
        description="Include weekends in attendance tracking",
    )
    weekend_days: List[str] = Field(
        default_factory=lambda: ["Saturday", "Sunday"],
        description="Days considered as weekends",
    )

    # Holiday configuration
    exclude_holidays: bool = Field(
        True,
        description="Exclude holidays from attendance calculation",
    )
    auto_import_holidays: bool = Field(
        default=True,
        description="Automatically import regional holidays",
    )

    # Half-day handling
    half_day_weight: Decimal = Field(
        Decimal("0.5"),
        ge=0,
        le=1,
        description="Weight for half-day attendance (0.5 = half, 1.0 = full)",
    )

    # Late entry penalties
    apply_late_penalty: bool = Field(
        default=False,
        description="Apply penalty for late entries",
    )
    late_penalty_after_count: int = Field(
        default=5,
        ge=1,
        description="Apply penalty after N late entries in month",
    )
    late_penalty_type: str = Field(
        default="warning",
        pattern=r"^(warning|deduction|fine)$",
        description="Type of penalty for excessive late entries",
    )
    late_penalty_deduction_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Percentage to deduct for late penalty",
    )

    # Rounding rules
    round_percentage_to: int = Field(
        2,
        ge=0,
        le=4,
        description="Decimal places for percentage rounding",
    )
    rounding_mode: str = Field(
        "standard",
        pattern=r"^(up|down|standard)$",
        description="Rounding mode for attendance percentage",
    )

    @field_validator("weekend_days")
    @classmethod
    def validate_weekend_days(cls, v: List[str]) -> List[str]:
        """Validate weekend days are valid day names."""
        valid_days = {
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
            "Sunday",
        }
        for day in v:
            if day not in valid_days:
                raise ValueError(f"Invalid day name: {day}")
        return v

    @model_validator(mode="after")
    def validate_config_consistency(self) -> "PolicyConfig":
        """Validate configuration consistency."""
        # Can't count leave as both absent and present
        if self.count_leave_as_absent and self.count_leave_as_present:
            raise ValueError(
                "Leave cannot be counted as both absent and present"
            )

        # Custom period validation
        if self.calculation_period == "custom" and self.custom_period_days is None:
            raise ValueError(
                "custom_period_days is required when calculation_period is 'custom'"
            )

        # Late penalty validation
        if self.apply_late_penalty:
            if self.late_penalty_type == "deduction":
                if self.late_penalty_deduction_percentage is None:
                    raise ValueError(
                        "late_penalty_deduction_percentage is required for 'deduction' penalty type"
                    )

        return self


class PolicyUpdate(BaseUpdateSchema):
    """
    Update attendance policy with partial fields.
    
    All fields are optional for flexible policy updates.
    """

    minimum_attendance_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Updated minimum attendance percentage",
    )
    late_entry_threshold_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=240,
        description="Updated late entry threshold",
    )
    grace_period_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=30,
        description="Updated grace period",
    )
    grace_days_per_month: Optional[int] = Field(
        None,
        ge=0,
        le=31,
        description="Updated grace days per month",
    )
    consecutive_absence_alert_days: Optional[int] = Field(
        None,
        ge=1,
        le=30,
        description="Updated consecutive absence alert threshold",
    )
    notify_guardian_on_absence: Optional[bool] = None
    notify_admin_on_low_attendance: Optional[bool] = None
    notify_student_on_low_attendance: Optional[bool] = None
    low_attendance_threshold: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Updated low attendance threshold",
    )
    auto_mark_absent_enabled: Optional[bool] = None
    auto_mark_absent_after_time: Optional[time] = None
    track_weekend_attendance: Optional[bool] = None
    track_holiday_attendance: Optional[bool] = None
    is_active: Optional[bool] = None
    effective_from: Optional[date] = None
    effective_until: Optional[date] = None

    @field_validator(
        "minimum_attendance_percentage",
        "low_attendance_threshold",
    )
    @classmethod
    def round_percentage(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round percentage to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_update_consistency(self) -> "PolicyUpdate":
        """Validate update consistency when related fields are both provided."""
        # Validate thresholds if both are provided
        if (
            self.low_attendance_threshold is not None
            and self.minimum_attendance_percentage is not None
        ):
            if self.low_attendance_threshold > self.minimum_attendance_percentage:
                raise ValueError(
                    "low_attendance_threshold should be less than minimum_attendance_percentage"
                )

        # Validate effective dates if both provided
        if self.effective_from and self.effective_until:
            if self.effective_until < self.effective_from:
                raise ValueError(
                    "effective_until must be after effective_from"
                )

        return self


class PolicyViolation(BaseSchema):
    """
    Attendance policy violation record.
    
    Tracks instances where students violate attendance policies
    with details for corrective action.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Student room number",
    )

    # Violation details
    violation_type: str = Field(
        ...,
        pattern=r"^(low_attendance|consecutive_absences|excessive_late_entries|unauthorized_absence)$",
        description="Type of policy violation",
    )
    severity: str = Field(
        ...,
        pattern=r"^(low|medium|high|critical)$",
        description="Violation severity level",
    )

    # Metrics
    current_attendance_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Current attendance percentage",
    )
    required_attendance_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Required attendance percentage",
    )
    consecutive_absences: Optional[int] = Field(
        None,
        ge=0,
        description="Number of consecutive absences",
    )
    late_entries_this_month: Optional[int] = Field(
        None,
        ge=0,
        description="Late entries in current month",
    )
    total_absences_this_month: Optional[int] = Field(
        None,
        ge=0,
        description="Total absences in current month",
    )

    # Violation tracking
    violation_date: date = Field(
        ...,
        description="Date when violation was detected",
    )
    first_violation_date: Optional[date] = Field(
        None,
        description="Date of first related violation",
    )

    # Actions taken
    guardian_notified: bool = Field(
        ...,
        description="Guardian notification sent",
    )
    guardian_notified_at: Optional[datetime] = Field(
        None,
        description="Guardian notification timestamp",
    )
    admin_notified: bool = Field(
        ...,
        description="Admin notification sent",
    )
    admin_notified_at: Optional[datetime] = Field(
        None,
        description="Admin notification timestamp",
    )
    student_notified: bool = Field(
        default=False,
        description="Student notification sent",
    )
    warning_issued: bool = Field(
        ...,
        description="Formal warning issued",
    )
    warning_issued_at: Optional[datetime] = Field(
        None,
        description="Warning issue timestamp",
    )

    # Resolution
    resolved: bool = Field(
        default=False,
        description="Whether violation has been resolved",
    )
    resolved_at: Optional[datetime] = Field(
        None,
        description="Resolution timestamp",
    )
    resolution_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Notes about how violation was resolved",
    )

    # Additional context
    notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional notes about violation",
    )
    action_plan: Optional[str] = Field(
        None,
        max_length=1000,
        description="Planned corrective actions",
    )

    @field_validator("resolution_notes", "notes", "action_plan")
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_violation_data(self) -> "PolicyViolation":
        """
        Validate violation data consistency.
        
        Ensures violation-specific metrics are provided based on type.
        """
        # Validate violation-specific requirements
        if self.violation_type == "low_attendance":
            if self.current_attendance_percentage is None:
                raise ValueError(
                    "current_attendance_percentage is required for low_attendance violation"
                )
            if self.required_attendance_percentage is None:
                raise ValueError(
                    "required_attendance_percentage is required for low_attendance violation"
                )

        if self.violation_type == "consecutive_absences":
            if self.consecutive_absences is None:
                raise ValueError(
                    "consecutive_absences is required for consecutive_absences violation"
                )

        if self.violation_type == "excessive_late_entries":
            if self.late_entries_this_month is None:
                raise ValueError(
                    "late_entries_this_month is required for excessive_late_entries violation"
                )

        # Resolution validation
        if self.resolved and self.resolved_at is None:
            raise ValueError(
                "resolved_at timestamp is required when violation is resolved"
            )

        # Notification timestamps
        if self.guardian_notified and self.guardian_notified_at is None:
            raise ValueError(
                "guardian_notified_at is required when guardian_notified is True"
            )

        if self.warning_issued and self.warning_issued_at is None:
            raise ValueError(
                "warning_issued_at is required when warning_issued is True"
            )

        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\attendance\attendance_record.py ---
# --- File: app/schemas/attendance/attendance_record.py ---
"""
Attendance recording schemas with validation for various marking methods.

Provides schemas for single, bulk, correction, and quick attendance marking
operations with comprehensive validation logic.
"""

from __future__ import annotations

from datetime import date, time
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import AttendanceStatus, AttendanceMode

__all__ = [
    "AttendanceRecordRequest",
    "BulkAttendanceRequest",
    "StudentAttendanceRecord",
    "AttendanceCorrection",
    "QuickAttendanceMarkAll",
]


class AttendanceRecordRequest(BaseCreateSchema):
    """
    Record attendance for single student with validation.
    
    Used for individual attendance marking with comprehensive validation.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    attendance_date: date = Field(
        ...,
        description="Date of attendance",
    )
    status: AttendanceStatus = Field(
        AttendanceStatus.PRESENT,
        description="Attendance status",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time (required for PRESENT status)",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Check-out time",
    )
    is_late: bool = Field(
        False,
        description="Late arrival indicator",
    )
    late_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Minutes late (if applicable)",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes or remarks",
    )

    @field_validator("attendance_date")
    @classmethod
    def validate_date(cls, v: date) -> date:
        """Ensure attendance date is not in future."""
        if v > date.today():
            raise ValueError("Attendance date cannot be in the future")
        return v

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize and validate notes."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_attendance_logic(self) -> "AttendanceRecordRequest":
        """
        Validate attendance record consistency.
        
        Ensures:
        - Present students have check-in time
        - Absent students don't have check-in/out times
        - Late status matches late_minutes
        - Check-out is after check-in
        """
        # Present students should have check-in time
        if self.status == AttendanceStatus.PRESENT:
            if self.check_in_time is None:
                raise ValueError(
                    "check_in_time is required for PRESENT status"
                )

        # Absent students shouldn't have times
        if self.status == AttendanceStatus.ABSENT:
            if self.check_in_time or self.check_out_time:
                raise ValueError(
                    "Absent students cannot have check-in or check-out times"
                )
            if self.is_late or self.late_minutes:
                raise ValueError(
                    "Absent students cannot be marked as late"
                )

        # Validate check-out time
        if self.check_in_time and self.check_out_time:
            if self.check_out_time <= self.check_in_time:
                raise ValueError(
                    "check_out_time must be after check_in_time"
                )

        # Validate late status
        if self.is_late and self.late_minutes is None:
            raise ValueError(
                "late_minutes is required when is_late is True"
            )

        if not self.is_late and self.late_minutes is not None and self.late_minutes > 0:
            raise ValueError(
                "is_late must be True when late_minutes is greater than 0"
            )

        return self


class StudentAttendanceRecord(BaseSchema):
    """
    Individual student attendance record for bulk operations.
    
    Lightweight schema optimized for bulk processing with optional
    field overrides.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    status: Optional[AttendanceStatus] = Field(
        None,
        description="Attendance status (uses default_status if None)",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Check-out time",
    )
    is_late: Optional[bool] = Field(
        None,
        description="Late arrival indicator",
    )
    late_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Minutes late",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes",
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize notes."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_consistency(self) -> "StudentAttendanceRecord":
        """Validate consistency of provided fields."""
        # Validate check times
        if self.check_in_time and self.check_out_time:
            if self.check_out_time <= self.check_in_time:
                raise ValueError(
                    "check_out_time must be after check_in_time"
                )

        # Validate late status
        if self.is_late is not None and self.late_minutes is not None:
            if self.is_late and self.late_minutes == 0:
                raise ValueError(
                    "late_minutes must be greater than 0 when is_late is True"
                )

        # Absent students validation
        if self.status == AttendanceStatus.ABSENT:
            if self.check_in_time or self.check_out_time:
                raise ValueError(
                    "Absent students cannot have check-in or check-out times"
                )

        return self


class BulkAttendanceRequest(BaseCreateSchema):
    """
    Mark attendance for multiple students efficiently.
    
    Supports default status for all students with per-student overrides
    and duplicate prevention.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    attendance_date: date = Field(
        ...,
        description="Date for all attendance records",
    )
    default_status: AttendanceStatus = Field(
        AttendanceStatus.PRESENT,
        description="Default status applied to all students unless overridden",
    )
    student_records: List[StudentAttendanceRecord] = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Individual student attendance records",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked the attendance",
    )
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Supervisor ID who verified the attendance",
    )
    marking_mode: AttendanceMode = Field(
        AttendanceMode.MANUAL,
        description="Method used to record attendance",
    )

    @field_validator("attendance_date")
    @classmethod
    def validate_date(cls, v: date) -> date:
        """Validate attendance date is not in future."""
        if v > date.today():
            raise ValueError("Attendance date cannot be in the future")
        return v

    @model_validator(mode="after")
    def validate_unique_students(self) -> "BulkAttendanceRequest":
        """
        Ensure no duplicate student IDs in the request.
        
        Prevents multiple records for same student on same date.
        """
        student_ids = [record.student_id for record in self.student_records]
        unique_ids = set(student_ids)

        if len(student_ids) != len(unique_ids):
            # Identify duplicates for error message
            seen = set()
            duplicates = set()
            for student_id in student_ids:
                if student_id in seen:
                    duplicates.add(str(student_id))
                seen.add(student_id)

            raise ValueError(
                f"Duplicate student IDs not allowed: {', '.join(duplicates)}"
            )

        return self


class AttendanceCorrection(BaseCreateSchema):
    """
    Correct previously marked attendance with audit trail.
    
    Allows authorized users to correct attendance errors with
    mandatory reason documentation.
    """

    attendance_id: UUID = Field(
        ...,
        description="Attendance record ID to correct",
    )
    corrected_status: AttendanceStatus = Field(
        ...,
        description="Corrected attendance status",
    )
    corrected_check_in_time: Optional[time] = Field(
        None,
        description="Corrected check-in time",
    )
    corrected_check_out_time: Optional[time] = Field(
        None,
        description="Corrected check-out time",
    )
    corrected_is_late: Optional[bool] = Field(
        None,
        description="Corrected late status",
    )
    corrected_late_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Corrected late minutes",
    )
    correction_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for correction (mandatory for audit)",
    )
    corrected_by: UUID = Field(
        ...,
        description="User ID who made the correction",
    )

    @field_validator("correction_reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate correction reason is meaningful."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError(
                "Correction reason must be at least 10 characters"
            )
        return v

    @model_validator(mode="after")
    def validate_corrections(self) -> "AttendanceCorrection":
        """
        Validate corrected values consistency.
        
        Ensures corrected times and late status are logically consistent.
        """
        # Validate check times
        if self.corrected_check_in_time and self.corrected_check_out_time:
            if self.corrected_check_out_time <= self.corrected_check_in_time:
                raise ValueError(
                    "Corrected check-out time must be after check-in time"
                )

        # Validate late status
        if self.corrected_is_late is not None and self.corrected_late_minutes is not None:
            if self.corrected_is_late and self.corrected_late_minutes == 0:
                raise ValueError(
                    "Corrected late_minutes must be greater than 0 when is_late is True"
                )

        # Absent students shouldn't have times
        if self.corrected_status == AttendanceStatus.ABSENT:
            if self.corrected_check_in_time or self.corrected_check_out_time:
                raise ValueError(
                    "Absent students cannot have check-in or check-out times"
                )
            if self.corrected_is_late or self.corrected_late_minutes:
                raise ValueError(
                    "Absent students cannot be marked as late"
                )

        return self


class QuickAttendanceMarkAll(BaseCreateSchema):
    """
    Quick mark all students with exception handling.
    
    Efficiently marks all students as present with ability to specify
    exceptions (absent, on leave) for streamlined daily attendance.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    attendance_date: date = Field(
        ...,
        description="Date for attendance marking",
    )
    default_check_in_time: Optional[time] = Field(
        None,
        description="Default check-in time for all present students",
    )
    absent_student_ids: List[UUID] = Field(
        default_factory=list,
        max_length=500,
        description="Student IDs to mark as absent",
    )
    on_leave_student_ids: List[UUID] = Field(
        default_factory=list,
        max_length=500,
        description="Student IDs to mark as on leave",
    )
    late_student_ids: List[UUID] = Field(
        default_factory=list,
        max_length=500,
        description="Student IDs to mark as late",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked the attendance",
    )
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Supervisor ID who verified attendance",
    )

    @field_validator("attendance_date")
    @classmethod
    def validate_date(cls, v: date) -> date:
        """Validate attendance date is not in future."""
        if v > date.today():
            raise ValueError("Attendance date cannot be in the future")
        return v

    @model_validator(mode="after")
    def validate_no_overlapping_exceptions(self) -> "QuickAttendanceMarkAll":
        """
        Ensure students aren't in multiple exception lists.
        
        A student can only be in one exception category.
        """
        absent_set = set(self.absent_student_ids)
        leave_set = set(self.on_leave_student_ids)
        late_set = set(self.late_student_ids)

        # Check for overlaps
        overlap_absent_leave = absent_set & leave_set
        overlap_absent_late = absent_set & late_set
        overlap_leave_late = leave_set & late_set

        errors = []
        if overlap_absent_leave:
            errors.append(
                f"Students in both absent and leave lists: {', '.join(str(id) for id in overlap_absent_leave)}"
            )
        if overlap_absent_late:
            errors.append(
                f"Students in both absent and late lists: {', '.join(str(id) for id in overlap_absent_late)}"
            )
        if overlap_leave_late:
            errors.append(
                f"Students in both leave and late lists: {', '.join(str(id) for id in overlap_leave_late)}"
            )

        if errors:
            raise ValueError("; ".join(errors))

        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\attendance\attendance_report.py ---
# --- File: app/schemas/attendance/attendance_report.py ---
"""
Attendance reporting schemas with analytics and trends.

Provides comprehensive reporting capabilities including summaries,
trends, comparisons, and multi-level aggregations.
"""

from __future__ import annotations

from datetime import date, datetime, time
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, computed_field, field_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import AttendanceStatus
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "AttendanceReport",
    "AttendanceSummary",
    "DailyAttendanceRecord",
    "TrendAnalysis",
    "WeeklyAttendance",
    "MonthlyComparison",
    "MonthlyReport",
    "StudentMonthlySummary",
    "AttendanceComparison",
    "ComparisonItem",
]


class AttendanceSummary(BaseSchema):
    """
    Comprehensive attendance summary statistics.
    
    Provides aggregated metrics, percentages, streaks, and status
    assessment for a given period.
    """

    total_days: int = Field(
        ...,
        ge=0,
        description="Total number of days in period",
    )
    total_present: int = Field(
        ...,
        ge=0,
        description="Total present days",
    )
    total_absent: int = Field(
        ...,
        ge=0,
        description="Total absent days",
    )
    total_late: int = Field(
        ...,
        ge=0,
        description="Total late arrivals",
    )
    total_on_leave: int = Field(
        ...,
        ge=0,
        description="Total days on leave",
    )
    total_half_day: int = Field(
        default=0,
        ge=0,
        description="Total half-day attendances",
    )
    attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall attendance percentage",
    )
    late_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of late arrivals",
    )

    # Streak tracking
    current_present_streak: int = Field(
        ...,
        ge=0,
        description="Current consecutive present days",
    )
    longest_present_streak: int = Field(
        ...,
        ge=0,
        description="Longest consecutive present streak in period",
    )
    current_absent_streak: int = Field(
        ...,
        ge=0,
        description="Current consecutive absent days",
    )
    longest_absent_streak: int = Field(
        default=0,
        ge=0,
        description="Longest consecutive absent streak in period",
    )

    # Status assessment
    attendance_status: str = Field(
        ...,
        pattern=r"^(excellent|good|warning|critical)$",
        description="Qualitative attendance assessment",
    )
    meets_minimum_requirement: bool = Field(
        ...,
        description="Whether attendance meets minimum policy requirement",
    )
    minimum_requirement_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Minimum required attendance percentage",
    )

    @field_validator("attendance_percentage", "late_percentage")
    @classmethod
    def round_percentage(cls, v: Decimal) -> Decimal:
        """Round percentages to 2 decimal places."""
        return round(v, 2)

    @computed_field
    @property
    def total_accounted_days(self) -> int:
        """Calculate total days with attendance recorded."""
        return (
            self.total_present
            + self.total_absent
            + self.total_late
            + self.total_on_leave
            + self.total_half_day
        )

    @computed_field
    @property
    def unrecorded_days(self) -> int:
        """Calculate days without attendance record."""
        return max(0, self.total_days - self.total_accounted_days)


class DailyAttendanceRecord(BaseSchema):
    """
    Individual daily attendance record for reports.
    
    Represents a single day's attendance with complete details
    for timeline views and detailed reports.
    """

    date: date = Field(
        ...,
        description="Attendance date",
    )
    day_of_week: str = Field(
        ...,
        description="Day name (Monday, Tuesday, etc.)",
    )
    status: AttendanceStatus = Field(
        ...,
        description="Attendance status",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Check-out time",
    )
    is_late: bool = Field(
        ...,
        description="Late arrival indicator",
    )
    late_minutes: Optional[int] = Field(
        None,
        ge=0,
        description="Minutes late",
    )
    notes: Optional[str] = Field(
        None,
        description="Additional notes or remarks",
    )
    is_holiday: bool = Field(
        default=False,
        description="Whether day was a holiday",
    )
    is_weekend: bool = Field(
        default=False,
        description="Whether day was a weekend",
    )

    @computed_field
    @property
    def status_display(self) -> str:
        """Human-readable status display."""
        return self.status.value.replace("_", " ").title()


class WeeklyAttendance(BaseSchema):
    """
    Weekly attendance aggregation.
    
    Provides week-level summary for trend analysis and reporting.
    """

    week_number: int = Field(
        ...,
        ge=1,
        le=53,
        description="Week number in year (ISO week)",
    )
    year: int = Field(
        ...,
        ge=2000,
        description="Year for the week",
    )
    week_start_date: date = Field(
        ...,
        description="Monday of the week",
    )
    week_end_date: date = Field(
        ...,
        description="Sunday of the week",
    )
    total_days: int = Field(
        ...,
        ge=0,
        le=7,
        description="Total working days in week",
    )
    present_days: int = Field(
        ...,
        ge=0,
        description="Days present",
    )
    absent_days: int = Field(
        ...,
        ge=0,
        description="Days absent",
    )
    late_days: int = Field(
        default=0,
        ge=0,
        description="Days marked late",
    )
    attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Weekly attendance percentage",
    )

    @field_validator("week_end_date")
    @classmethod
    def validate_week_dates(cls, v: date, info) -> date:
        """Validate week end date is after start date."""
        if "week_start_date" in info.data:
            if v < info.data["week_start_date"]:
                raise ValueError("week_end_date must be after week_start_date")
        return v


class MonthlyComparison(BaseSchema):
    """
    Monthly attendance comparison data.
    
    Used for month-over-month trend analysis and visualizations.
    """

    month: str = Field(
        ...,
        pattern=r"^\d{4}-(0[1-9]|1[0-2])$",
        description="Month in YYYY-MM format",
    )
    month_name: str = Field(
        ...,
        description="Month name (January, February, etc.)",
    )
    year: int = Field(
        ...,
        ge=2000,
        description="Year",
    )
    attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Monthly attendance percentage",
    )
    total_present: int = Field(
        ...,
        ge=0,
        description="Total present days",
    )
    total_absent: int = Field(
        ...,
        ge=0,
        description="Total absent days",
    )
    total_late: int = Field(
        default=0,
        ge=0,
        description="Total late days",
    )
    working_days: int = Field(
        ...,
        ge=0,
        description="Total working days in month",
    )

    @computed_field
    @property
    def trend_indicator(self) -> str:
        """Get trend indicator (up, down, stable) - requires comparison context."""
        # This would typically compare with previous month
        # Placeholder for illustration
        return "stable"


class TrendAnalysis(BaseSchema):
    """
    Attendance trend analysis over time.
    
    Provides insights into attendance patterns, improvements,
    and concerning trends.
    """

    period_start: date = Field(
        ...,
        description="Analysis period start date",
    )
    period_end: date = Field(
        ...,
        description="Analysis period end date",
    )
    
    # Weekly breakdown
    weekly_attendance: List[WeeklyAttendance] = Field(
        default_factory=list,
        description="Week-by-week attendance data",
    )
    
    # Monthly comparison
    monthly_comparison: Optional[List[MonthlyComparison]] = Field(
        None,
        description="Month-by-month comparison data",
    )
    
    # Pattern insights
    most_absent_day: Optional[str] = Field(
        None,
        description="Day of week with most absences",
    )
    most_present_day: Optional[str] = Field(
        None,
        description="Day of week with best attendance",
    )
    average_late_minutes: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average minutes late across period",
    )
    
    # Trend indicators
    attendance_improving: bool = Field(
        ...,
        description="Whether attendance is trending upward",
    )
    improvement_rate: Optional[Decimal] = Field(
        None,
        description="Rate of improvement (percentage points per month)",
    )
    trend_direction: str = Field(
        ...,
        pattern=r"^(improving|declining|stable)$",
        description="Overall trend direction",
    )
    
    # Predictive metrics
    projected_end_of_month_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Projected attendance percentage at month end",
    )

    @field_validator("period_end")
    @classmethod
    def validate_period(cls, v: date, info) -> date:
        """Validate period dates are logical."""
        if "period_start" in info.data:
            if v < info.data["period_start"]:
                raise ValueError("period_end must be after period_start")
        return v


class AttendanceReport(BaseSchema):
    """
    Comprehensive attendance report.
    
    Main report schema combining summary statistics, detailed records,
    and trend analysis.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID (if hostel-specific report)",
    )
    hostel_name: Optional[str] = Field(
        None,
        description="Hostel name",
    )
    student_id: Optional[UUID] = Field(
        None,
        description="Student ID (if student-specific report)",
    )
    student_name: Optional[str] = Field(
        None,
        description="Student name",
    )
    report_period: DateRangeFilter = Field(
        ...,
        description="Report date range",
    )
    generated_at: datetime = Field(
        ...,
        description="Report generation timestamp",
    )
    generated_by: Optional[UUID] = Field(
        None,
        description="User who generated the report",
    )
    
    # Core data
    summary: AttendanceSummary = Field(
        ...,
        description="Aggregated summary statistics",
    )
    daily_records: List[DailyAttendanceRecord] = Field(
        default_factory=list,
        description="Day-by-day attendance records",
    )
    
    # Analysis
    trend_analysis: Optional[TrendAnalysis] = Field(
        None,
        description="Trend analysis and insights",
    )
    
    # Metadata
    report_type: str = Field(
        default="standard",
        pattern=r"^(standard|detailed|summary|comparison)$",
        description="Type of report",
    )
    includes_weekends: bool = Field(
        default=False,
        description="Whether weekends are included",
    )
    includes_holidays: bool = Field(
        default=False,
        description="Whether holidays are included",
    )

    @computed_field
    @property
    def total_days_analyzed(self) -> int:
        """Total days included in analysis."""
        return len(self.daily_records)


class StudentMonthlySummary(BaseSchema):
    """
    Monthly attendance summary for individual student.
    
    Used in monthly reports to show per-student statistics.
    """

    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Room number",
    )
    email: Optional[str] = Field(
        None,
        description="Student email",
    )
    phone: Optional[str] = Field(
        None,
        description="Student phone",
    )
    total_days: int = Field(
        ...,
        ge=0,
        description="Total working days in month",
    )
    present_days: int = Field(
        ...,
        ge=0,
        description="Days present",
    )
    absent_days: int = Field(
        ...,
        ge=0,
        description="Days absent",
    )
    late_days: int = Field(
        ...,
        ge=0,
        description="Days marked late",
    )
    on_leave_days: int = Field(
        ...,
        ge=0,
        description="Days on leave",
    )
    half_days: int = Field(
        default=0,
        ge=0,
        description="Half-day attendances",
    )
    attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Monthly attendance percentage",
    )
    meets_requirement: bool = Field(
        ...,
        description="Meets minimum attendance requirement",
    )
    
    # Action flags
    requires_attention: bool = Field(
        ...,
        description="Requires supervisor/admin attention",
    )
    action_required: Optional[str] = Field(
        None,
        description="Specific action needed (if any)",
    )
    
    # Additional metrics
    consecutive_absences: int = Field(
        default=0,
        ge=0,
        description="Current consecutive absent days",
    )
    improvement_from_last_month: Optional[Decimal] = Field(
        None,
        description="Percentage point change from last month",
    )

    @computed_field
    @property
    def status_indicator(self) -> str:
        """
        Get status indicator based on attendance.
        
        Returns: excellent, good, warning, or critical
        """
        percentage = float(self.attendance_percentage)
        if percentage >= 95:
            return "excellent"
        elif percentage >= 85:
            return "good"
        elif percentage >= 75:
            return "warning"
        else:
            return "critical"


class MonthlyReport(BaseSchema):
    """
    Comprehensive monthly attendance report for hostel.
    
    Aggregates all students' attendance for a given month with
    hostel-wide statistics.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    month: str = Field(
        ...,
        pattern=r"^\d{4}-(0[1-9]|1[0-2])$",
        description="Month in YYYY-MM format",
    )
    month_name: str = Field(
        ...,
        description="Month name",
    )
    year: int = Field(
        ...,
        ge=2000,
        description="Year",
    )
    working_days: int = Field(
        ...,
        ge=0,
        description="Total working days in month",
    )
    
    # Student summaries
    student_summaries: List[StudentMonthlySummary] = Field(
        ...,
        description="Per-student monthly summaries",
    )
    
    # Hostel-wide statistics
    hostel_average_attendance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average attendance across all students",
    )
    total_students: int = Field(
        ...,
        ge=0,
        description="Total number of students",
    )
    students_meeting_requirement: int = Field(
        ...,
        ge=0,
        description="Students meeting minimum requirement",
    )
    students_below_requirement: int = Field(
        ...,
        ge=0,
        description="Students below minimum requirement",
    )
    students_needing_attention: int = Field(
        default=0,
        ge=0,
        description="Students requiring attention",
    )
    
    # Additional metrics
    total_late_instances: int = Field(
        default=0,
        ge=0,
        description="Total late arrivals across all students",
    )
    average_late_percentage: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Average late percentage",
    )
    
    # Report metadata
    generated_at: datetime = Field(
        ...,
        description="Report generation timestamp",
    )
    generated_by: Optional[UUID] = Field(
        None,
        description="User who generated report",
    )

    @computed_field
    @property
    def compliance_rate(self) -> Decimal:
        """Calculate percentage of students meeting requirements."""
        if self.total_students == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.students_meeting_requirement) / Decimal(self.total_students) * 100,
            2,
        )


class ComparisonItem(BaseSchema):
    """
    Individual item in attendance comparison.
    
    Represents a single entity (student/hostel/room) in comparative analysis.
    """

    entity_id: UUID = Field(
        ...,
        description="Entity unique identifier",
    )
    entity_name: str = Field(
        ...,
        description="Entity name (student/hostel/room name)",
    )
    entity_type: str = Field(
        ...,
        pattern=r"^(student|hostel|room)$",
        description="Type of entity being compared",
    )
    attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Attendance percentage",
    )
    total_present: int = Field(
        ...,
        ge=0,
        description="Total present count",
    )
    total_absent: int = Field(
        ...,
        ge=0,
        description="Total absent count",
    )
    total_days: int = Field(
        ...,
        ge=0,
        description="Total days in comparison period",
    )
    rank: int = Field(
        ...,
        ge=1,
        description="Rank in comparison (1 = best)",
    )
    percentile: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentile ranking",
    )

    @computed_field
    @property
    def performance_indicator(self) -> str:
        """Get performance indicator based on percentile."""
        percentile_float = float(self.percentile)
        if percentile_float >= 90:
            return "top_performer"
        elif percentile_float >= 75:
            return "above_average"
        elif percentile_float >= 50:
            return "average"
        elif percentile_float >= 25:
            return "below_average"
        else:
            return "needs_improvement"


class AttendanceComparison(BaseSchema):
    """
    Comparative attendance analysis across entities.
    
    Enables benchmarking and performance comparison across
    students, hostels, or rooms.
    """

    comparison_type: str = Field(
        ...,
        pattern=r"^(student|hostel|room)$",
        description="Type of entities being compared",
    )
    period: DateRangeFilter = Field(
        ...,
        description="Comparison period",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID (for student/room comparisons)",
    )
    comparisons: List[ComparisonItem] = Field(
        ...,
        min_length=1,
        description="Comparison items sorted by rank",
    )
    
    # Statistical metrics
    average_attendance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Average attendance across all entities",
    )
    median_attendance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Median attendance",
    )
    highest_attendance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Highest attendance percentage",
    )
    lowest_attendance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Lowest attendance percentage",
    )
    standard_deviation: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Standard deviation of attendance",
    )
    
    # Report metadata
    generated_at: datetime = Field(
        ...,
        description="Comparison generation timestamp",
    )

    @field_validator("comparisons")
    @classmethod
    def validate_rankings(cls, v: List[ComparisonItem]) -> List[ComparisonItem]:
        """Validate rankings are sequential."""
        if v:
            ranks = sorted([item.rank for item in v])
            expected_ranks = list(range(1, len(v) + 1))
            if ranks != expected_ranks:
                raise ValueError("Comparison rankings must be sequential from 1")
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\attendance\attendance_response.py ---
# --- File: app/schemas/attendance/attendance_response.py ---
"""
Attendance response schemas optimized for API responses.

Provides various response formats for attendance data including
detailed, summary, and list views with computed fields.
"""

from __future__ import annotations

from datetime import date, datetime, time
from decimal import Decimal
from typing import Optional

from pydantic import Field, computed_field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import AttendanceMode, AttendanceStatus

__all__ = [
    "AttendanceResponse",
    "AttendanceDetail",
    "AttendanceListItem",
    "DailyAttendanceSummary",
]


class AttendanceResponse(BaseResponseSchema):
    """
    Standard attendance response with essential information.
    
    Lightweight response schema for list views and basic queries.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Student room number",
    )
    attendance_date: date = Field(
        ...,
        description="Date of attendance",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Check-out time",
    )
    status: AttendanceStatus = Field(
        ...,
        description="Attendance status",
    )
    is_late: bool = Field(
        ...,
        description="Late arrival indicator",
    )
    late_minutes: Optional[int] = Field(
        None,
        description="Minutes late (if applicable)",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked attendance",
    )
    marked_by_name: str = Field(
        ...,
        description="Name of user who marked attendance",
    )

    @computed_field
    @property
    def status_display(self) -> str:
        """Human-readable status display."""
        status_map = {
            AttendanceStatus.PRESENT: "Present",
            AttendanceStatus.ABSENT: "Absent",
            AttendanceStatus.LATE: "Late",
            AttendanceStatus.ON_LEAVE: "On Leave",
            AttendanceStatus.HALF_DAY: "Half Day",
        }
        return status_map.get(self.status, self.status.value)


class AttendanceDetail(BaseResponseSchema):
    """
    Detailed attendance information with complete metadata.
    
    Comprehensive response including location data, device info,
    and audit trail for detailed views.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student full name",
    )
    student_email: str = Field(
        ...,
        description="Student email address",
    )
    student_phone: str = Field(
        ...,
        description="Student phone number",
    )
    room_number: Optional[str] = Field(
        None,
        description="Student room number",
    )
    attendance_date: date = Field(
        ...,
        description="Date of attendance",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time",
    )
    check_out_time: Optional[time] = Field(
        None,
        description="Check-out time",
    )
    status: AttendanceStatus = Field(
        ...,
        description="Attendance status",
    )
    is_late: bool = Field(
        ...,
        description="Late arrival indicator",
    )
    late_minutes: Optional[int] = Field(
        None,
        description="Minutes late",
    )
    attendance_mode: AttendanceMode = Field(
        ...,
        description="Method of attendance recording",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked attendance",
    )
    marked_by_name: str = Field(
        ...,
        description="Name of user who marked attendance",
    )
    supervisor_id: Optional[UUID] = Field(
        None,
        description="Supervisor ID who verified",
    )
    supervisor_name: Optional[str] = Field(
        None,
        description="Supervisor name",
    )
    notes: Optional[str] = Field(
        None,
        description="Additional notes",
    )
    location_lat: Optional[Decimal] = Field(
        None,
        description="Latitude (for mobile check-in)",
    )
    location_lng: Optional[Decimal] = Field(
        None,
        description="Longitude (for mobile check-in)",
    )
    device_info: Optional[dict] = Field(
        None,
        description="Device information (for mobile check-in)",
    )
    created_at: datetime = Field(
        ...,
        description="Record creation timestamp",
    )
    updated_at: datetime = Field(
        ...,
        description="Last update timestamp",
    )

    @computed_field
    @property
    def has_location_data(self) -> bool:
        """Check if location data is available."""
        return self.location_lat is not None and self.location_lng is not None

    @computed_field
    @property
    def marking_method(self) -> str:
        """Human-readable marking method."""
        method_map = {
            AttendanceMode.MANUAL: "Manual Entry",
            AttendanceMode.BIOMETRIC: "Biometric System",
            AttendanceMode.QR_CODE: "QR Code Scan",
            AttendanceMode.MOBILE_APP: "Mobile App",
        }
        return method_map.get(self.attendance_mode, self.attendance_mode.value)


class AttendanceListItem(BaseSchema):
    """
    Minimal attendance list item for efficient list rendering.
    
    Optimized for pagination and list views with minimal data transfer.
    """

    id: UUID = Field(
        ...,
        description="Attendance record unique identifier",
    )
    student_id: UUID = Field(
        ...,
        description="Student unique identifier",
    )
    student_name: str = Field(
        ...,
        description="Student name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Room number",
    )
    attendance_date: date = Field(
        ...,
        description="Attendance date",
    )
    status: AttendanceStatus = Field(
        ...,
        description="Attendance status",
    )
    check_in_time: Optional[time] = Field(
        None,
        description="Check-in time",
    )
    is_late: bool = Field(
        ...,
        description="Late indicator",
    )
    marked_by_name: str = Field(
        ...,
        description="Marked by user name",
    )

    @computed_field
    @property
    def status_badge_color(self) -> str:
        """
        Get color code for status badge (for UI rendering).
        
        Returns color name/code for frontend styling.
        """
        color_map = {
            AttendanceStatus.PRESENT: "green",
            AttendanceStatus.ABSENT: "red",
            AttendanceStatus.LATE: "orange",
            AttendanceStatus.ON_LEAVE: "blue",
            AttendanceStatus.HALF_DAY: "yellow",
        }
        return color_map.get(self.status, "gray")


class DailyAttendanceSummary(BaseSchema):
    """
    Daily attendance summary with statistics.
    
    Provides aggregated view of daily attendance for a hostel
    with percentage calculations.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    date: date = Field(
        ...,
        description="Attendance date",
    )
    total_students: int = Field(
        ...,
        ge=0,
        description="Total number of students",
    )
    total_present: int = Field(
        ...,
        ge=0,
        description="Number of present students",
    )
    total_absent: int = Field(
        ...,
        ge=0,
        description="Number of absent students",
    )
    total_late: int = Field(
        ...,
        ge=0,
        description="Number of late students",
    )
    total_on_leave: int = Field(
        ...,
        ge=0,
        description="Number of students on leave",
    )
    total_half_day: int = Field(
        default=0,
        ge=0,
        description="Number of half-day attendances",
    )
    attendance_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        description="Overall attendance percentage",
    )
    marked_by: UUID = Field(
        ...,
        description="User ID who marked attendance",
    )
    marked_by_name: str = Field(
        ...,
        description="Name of user who marked attendance",
    )
    marking_completed: bool = Field(
        ...,
        description="Whether attendance marking is complete",
    )
    marked_at: Optional[datetime] = Field(
        None,
        description="Timestamp when marking was completed",
    )

    @computed_field
    @property
    def pending_students(self) -> int:
        """Calculate number of students with pending attendance."""
        marked = (
            self.total_present
            + self.total_absent
            + self.total_late
            + self.total_on_leave
            + self.total_half_day
        )
        return max(0, self.total_students - marked)

    @computed_field
    @property
    def attendance_status(self) -> str:
        """
        Get attendance quality status based on percentage.
        
        Returns status: excellent, good, average, poor, critical
        """
        percentage = float(self.attendance_percentage)
        if percentage >= 95:
            return "excellent"
        elif percentage >= 85:
            return "good"
        elif percentage >= 75:
            return "average"
        elif percentage >= 60:
            return "poor"
        else:
            return "critical"

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\attendance\__init__.py ---
# --- File: app/schemas/attendance/__init__.py ---
"""
Attendance schemas package.

Comprehensive attendance tracking, reporting, and alerting schemas
for hostel management system with enhanced validation and type safety.
"""

from __future__ import annotations

from app.schemas.attendance.attendance_alert import (
    AlertAcknowledgment,
    AlertConfig,
    AlertList,
    AlertSummary,
    AlertTrigger,
    AttendanceAlert,
)
from app.schemas.attendance.attendance_base import (
    AttendanceBase,
    AttendanceCreate,
    AttendanceUpdate,
    BulkAttendanceCreate,
    SingleAttendanceRecord,
)
from app.schemas.attendance.attendance_filters import (
    AttendanceExportRequest,
    AttendanceFilterParams,
    DateRangeRequest,
)
from app.schemas.attendance.attendance_policy import (
    AttendancePolicy,
    PolicyConfig,
    PolicyUpdate,
    PolicyViolation,
)
from app.schemas.attendance.attendance_record import (
    AttendanceCorrection,
    AttendanceRecordRequest,
    BulkAttendanceRequest,
    QuickAttendanceMarkAll,
    StudentAttendanceRecord,
)
from app.schemas.attendance.attendance_report import (
    AttendanceComparison,
    AttendanceReport,
    AttendanceSummary,
    ComparisonItem,
    DailyAttendanceRecord,
    MonthlyComparison,
    MonthlyReport,
    StudentMonthlySummary,
    TrendAnalysis,
    WeeklyAttendance,
)
from app.schemas.attendance.attendance_response import (
    AttendanceDetail,
    AttendanceListItem,
    AttendanceResponse,
    DailyAttendanceSummary,
)

__all__ = [
    # Base schemas
    "AttendanceBase",
    "AttendanceCreate",
    "AttendanceUpdate",
    "BulkAttendanceCreate",
    "SingleAttendanceRecord",
    # Response schemas
    "AttendanceResponse",
    "AttendanceDetail",
    "AttendanceListItem",
    "DailyAttendanceSummary",
    # Recording schemas
    "AttendanceRecordRequest",
    "BulkAttendanceRequest",
    "StudentAttendanceRecord",
    "AttendanceCorrection",
    "QuickAttendanceMarkAll",
    # Report schemas
    "AttendanceReport",
    "AttendanceSummary",
    "DailyAttendanceRecord",
    "TrendAnalysis",
    "WeeklyAttendance",
    "MonthlyComparison",
    "MonthlyReport",
    "StudentMonthlySummary",
    "AttendanceComparison",
    "ComparisonItem",
    # Policy schemas
    "AttendancePolicy",
    "PolicyConfig",
    "PolicyUpdate",
    "PolicyViolation",
    # Alert schemas
    "AttendanceAlert",
    "AlertConfig",
    "AlertTrigger",
    "AlertAcknowledgment",
    "AlertList",
    "AlertSummary",
    # Filter schemas
    "AttendanceFilterParams",
    "DateRangeRequest",
    "AttendanceExportRequest",
]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\attendance\__pycache__ =====
