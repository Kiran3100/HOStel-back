### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance\maintenance_analytics.py ---
# --- File: app/schemas/maintenance/maintenance_analytics.py ---
"""
Maintenance analytics schemas for insights and reporting.

Provides comprehensive analytics with trends, performance metrics,
and vendor analysis for data-driven decision making.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, computed_field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "MaintenanceAnalytics",
    "TrendPoint",
    "CostTrendPoint",
    "CategoryBreakdown",
    "VendorPerformance",
    "PerformanceMetrics",
    "ProductivityMetrics",
]


class TrendPoint(BaseSchema):
    """
    Single data point in trend analysis.
    
    Represents metrics for a specific time period.
    """

    period: str = Field(
        ...,
        description="Period identifier (date, week, month, etc.)",
    )
    period_start: date = Field(
        ...,
        description="Period start date",
    )
    period_end: date = Field(
        ...,
        description="Period end date",
    )
    request_count: int = Field(
        ...,
        ge=0,
        description="Total requests in period",
    )
    completed_count: int = Field(
        ...,
        ge=0,
        description="Completed requests",
    )
    pending_count: int = Field(
        default=0,
        ge=0,
        description="Pending requests",
    )
    average_completion_days: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average days to complete",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate for period."""
        if self.request_count == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.completed_count) / Decimal(self.request_count) * 100,
            2,
        )


class CostTrendPoint(BaseSchema):
    """
    Cost trend data point.
    
    Tracks cost metrics over time periods.
    """

    period: str = Field(
        ...,
        description="Period identifier",
    )
    period_start: date = Field(
        ...,
        description="Period start date",
    )
    period_end: date = Field(
        ...,
        description="Period end date",
    )
    total_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total cost in period",
    )
    request_count: int = Field(
        ...,
        ge=0,
        description="Number of requests",
    )
    average_cost: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )
    budget_allocated: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Budget allocated for period",
    )
    variance_from_budget: Optional[Decimal] = Field(
        None,
        description="Variance from budget",
    )

    @computed_field
    @property
    def budget_utilization(self) -> Optional[Decimal]:
        """Calculate budget utilization percentage."""
        if self.budget_allocated is None or self.budget_allocated == 0:
            return None
        return round(
            self.total_cost / self.budget_allocated * 100,
            2,
        )


class CategoryBreakdown(BaseSchema):
    """
    Detailed breakdown by maintenance category.
    
    Provides comprehensive metrics for a specific category.
    """

    category: str = Field(
        ...,
        description="Maintenance category name",
    )
    category_code: Optional[str] = Field(
        None,
        description="Category code",
    )
    total_requests: int = Field(
        ...,
        ge=0,
        description="Total requests in category",
    )
    completed_requests: int = Field(
        ...,
        ge=0,
        description="Completed requests",
    )
    pending_requests: int = Field(
        default=0,
        ge=0,
        description="Pending requests",
    )
    cancelled_requests: int = Field(
        default=0,
        ge=0,
        description="Cancelled requests",
    )
    total_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total cost for category",
    )
    average_cost: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )
    median_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Median cost",
    )
    average_completion_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average completion time in hours",
    )
    average_completion_time_days: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average completion time in days",
    )
    on_time_completion_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage completed on time",
    )
    
    # Priority distribution
    high_priority_count: int = Field(
        default=0,
        ge=0,
        description="High priority requests",
    )
    urgent_priority_count: int = Field(
        default=0,
        ge=0,
        description="Urgent priority requests",
    )
    
    # Quality metrics
    quality_check_pass_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Quality check pass rate",
    )
    average_quality_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average quality rating",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate."""
        if self.total_requests == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.completed_requests) / Decimal(self.total_requests) * 100,
            2,
        )

    @computed_field
    @property
    def cost_per_completed(self) -> Decimal:
        """Calculate cost per completed request."""
        if self.completed_requests == 0:
            return Decimal("0.00")
        return round(
            self.total_cost / Decimal(self.completed_requests),
            2,
        )


class VendorPerformance(BaseSchema):
    """
    Vendor performance metrics and analysis.
    
    Tracks vendor efficiency, cost, quality, and reliability.
    """

    vendor_id: Optional[UUID] = Field(
        None,
        description="Vendor unique identifier",
    )
    vendor_name: str = Field(
        ...,
        description="Vendor company name",
    )
    vendor_category: Optional[str] = Field(
        None,
        description="Vendor specialization category",
    )
    
    # Job statistics
    total_jobs: int = Field(
        ...,
        ge=0,
        description="Total jobs assigned",
    )
    completed_jobs: int = Field(
        ...,
        ge=0,
        description="Jobs completed",
    )
    in_progress_jobs: int = Field(
        default=0,
        ge=0,
        description="Jobs currently in progress",
    )
    cancelled_jobs: int = Field(
        default=0,
        ge=0,
        description="Jobs cancelled",
    )
    
    # Timeliness metrics
    on_time_completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage completed on time",
    )
    average_delay_days: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average delay in days (for delayed jobs)",
    )
    
    # Cost metrics
    total_spent: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total amount paid to vendor",
    )
    average_cost: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per job",
    )
    cost_competitiveness: str = Field(
        ...,
        pattern=r"^(low|medium|high)$",
        description="Cost competitiveness rating",
    )
    cost_variance_percentage: Optional[Decimal] = Field(
        None,
        description="Average cost variance from estimates",
    )
    
    # Quality metrics
    quality_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average quality rating (1-5 stars)",
    )
    quality_check_pass_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Quality check pass rate",
    )
    rework_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Percentage requiring rework",
    )
    
    # Customer satisfaction
    customer_satisfaction_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Customer satisfaction score",
    )
    complaint_count: int = Field(
        default=0,
        ge=0,
        description="Number of complaints received",
    )
    
    # Reliability
    response_time_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average response time in hours",
    )
    availability_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Vendor availability score",
    )
    
    # Engagement period
    first_job_date: Optional[date] = Field(
        None,
        description="Date of first job",
    )
    last_job_date: Optional[date] = Field(
        None,
        description="Date of most recent job",
    )
    
    # Recommendations
    recommended: bool = Field(
        default=True,
        description="Whether vendor is recommended",
    )
    performance_tier: str = Field(
        ...,
        pattern=r"^(platinum|gold|silver|bronze|needs_improvement)$",
        description="Performance tier classification",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate job completion rate."""
        if self.total_jobs == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.completed_jobs) / Decimal(self.total_jobs) * 100,
            2,
        )

    @computed_field
    @property
    def overall_performance_score(self) -> Decimal:
        """
        Calculate overall performance score.
        
        Weighted average of completion rate, quality, and timeliness.
        """
        weights = {
            "completion": 0.3,
            "quality": 0.3,
            "timeliness": 0.4,
        }
        
        completion_score = float(self.completion_rate)
        quality_score = float(self.quality_rating or 3.0) * 20  # Convert 1-5 to 0-100
        timeliness_score = float(self.on_time_completion_rate)
        
        overall = (
            completion_score * weights["completion"]
            + quality_score * weights["quality"]
            + timeliness_score * weights["timeliness"]
        )
        
        return round(Decimal(str(overall)), 2)


class PerformanceMetrics(BaseSchema):
    """
    Overall maintenance performance metrics.
    
    Provides key performance indicators for maintenance operations.
    """

    period: DateRangeFilter = Field(
        ...,
        description="Analysis period",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID (if hostel-specific)",
    )
    
    # Request metrics
    total_requests: int = Field(
        ...,
        ge=0,
        description="Total maintenance requests",
    )
    completed_requests: int = Field(
        ...,
        ge=0,
        description="Completed requests",
    )
    pending_requests: int = Field(
        ...,
        ge=0,
        description="Pending requests",
    )
    cancelled_requests: int = Field(
        default=0,
        ge=0,
        description="Cancelled requests",
    )
    
    # Completion metrics
    completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall completion rate",
    )
    average_completion_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average time to complete (hours)",
    )
    average_completion_time_days: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average time to complete (days)",
    )
    median_completion_time_days: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Median completion time (days)",
    )
    on_time_completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage completed on time",
    )
    
    # Cost metrics
    total_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total maintenance cost",
    )
    average_cost_per_request: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )
    cost_variance_percentage: Decimal = Field(
        ...,
        decimal_places=2,
        description="Average cost variance from estimates",
    )
    within_budget_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage completed within budget",
    )
    
    # Quality metrics
    quality_check_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Percentage of requests quality checked",
    )
    quality_pass_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Quality check pass rate",
    )
    average_quality_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average quality rating",
    )
    rework_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Percentage requiring rework",
    )
    
    # Response metrics
    average_response_time_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average time to assign/respond (hours)",
    )
    average_assignment_time_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average time to assign (hours)",
    )
    
    # Priority distribution
    critical_requests: int = Field(
        default=0,
        ge=0,
        description="Critical priority requests",
    )
    urgent_requests: int = Field(
        default=0,
        ge=0,
        description="Urgent priority requests",
    )
    high_requests: int = Field(
        default=0,
        ge=0,
        description="High priority requests",
    )

    @computed_field
    @property
    def efficiency_score(self) -> Decimal:
        """
        Calculate overall efficiency score (0-100).
        
        Composite metric based on completion rate, timeliness, and quality.
        """
        weights = {
            "completion": 0.4,
            "timeliness": 0.3,
            "quality": 0.3,
        }
        
        completion_score = float(self.completion_rate)
        timeliness_score = float(self.on_time_completion_rate)
        quality_score = float(self.quality_pass_rate)
        
        efficiency = (
            completion_score * weights["completion"]
            + timeliness_score * weights["timeliness"]
            + quality_score * weights["quality"]
        )
        
        return round(Decimal(str(efficiency)), 2)


class ProductivityMetrics(BaseSchema):
    """
    Staff and team productivity metrics.
    
    Tracks productivity of maintenance teams and individuals.
    """

    period: DateRangeFilter = Field(
        ...,
        description="Analysis period",
    )
    team_id: Optional[UUID] = Field(
        None,
        description="Team ID (if team-specific)",
    )
    staff_member_id: Optional[UUID] = Field(
        None,
        description="Staff member ID (if individual)",
    )
    
    # Workload metrics
    total_assignments: int = Field(
        ...,
        ge=0,
        description="Total assignments",
    )
    completed_assignments: int = Field(
        ...,
        ge=0,
        description="Completed assignments",
    )
    active_assignments: int = Field(
        default=0,
        ge=0,
        description="Currently active assignments",
    )
    
    # Productivity metrics
    average_jobs_per_day: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average jobs completed per day",
    )
    average_hours_per_job: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average hours spent per job",
    )
    utilization_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Staff utilization rate",
    )
    
    # Quality and timeliness
    on_time_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="On-time completion rate",
    )
    quality_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Average quality score",
    )
    
    # Specialization
    top_categories: List[str] = Field(
        default_factory=list,
        max_length=5,
        description="Top maintenance categories handled",
    )
    specialization_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Specialization/expertise score",
    )

    @computed_field
    @property
    def productivity_score(self) -> Decimal:
        """Calculate overall productivity score."""
        completion_rate = (
            Decimal(self.completed_assignments) / Decimal(self.total_assignments) * 100
            if self.total_assignments > 0
            else Decimal("0.00")
        )
        
        # Weighted average
        weights = {
            "completion": 0.4,
            "timeliness": 0.3,
            "quality": 0.3,
        }
        
        quality_component = float(self.quality_score or 70.0)
        
        score = (
            float(completion_rate) * weights["completion"]
            + float(self.on_time_rate) * weights["timeliness"]
            + quality_component * weights["quality"]
        )
        
        return round(Decimal(str(score)), 2)


class MaintenanceAnalytics(BaseSchema):
    """
    Comprehensive maintenance analytics dashboard.
    
    Aggregates all analytics components for complete insights.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID (None for system-wide)",
    )
    hostel_name: Optional[str] = Field(
        None,
        description="Hostel name",
    )
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period",
    )
    generated_at: datetime = Field(
        ...,
        description="Analytics generation timestamp",
    )
    
    # Summary metrics
    total_requests: int = Field(
        ...,
        ge=0,
        description="Total maintenance requests",
    )
    completed_requests: int = Field(
        ...,
        ge=0,
        description="Completed requests",
    )
    pending_requests: int = Field(
        ...,
        ge=0,
        description="Pending requests",
    )
    
    # Cost summary
    total_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total maintenance cost",
    )
    average_cost: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )
    budget_utilization: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Budget utilization percentage",
    )
    
    # Performance summary
    average_completion_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average completion time",
    )
    completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Completion rate",
    )
    on_time_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="On-time completion rate",
    )
    
    # Breakdowns
    requests_by_category: Dict[str, int] = Field(
        ...,
        description="Request count by category",
    )
    cost_by_category: Dict[str, Decimal] = Field(
        ...,
        description="Cost breakdown by category",
    )
    requests_by_priority: Dict[str, int] = Field(
        default_factory=dict,
        description="Request count by priority",
    )
    
    # Trends
    request_trend: List[TrendPoint] = Field(
        ...,
        description="Request volume trends over time",
    )
    cost_trend: List[CostTrendPoint] = Field(
        ...,
        description="Cost trends over time",
    )
    
    # Detailed breakdowns
    category_breakdown: Optional[List[CategoryBreakdown]] = Field(
        None,
        description="Detailed category analysis",
    )
    vendor_performance: Optional[List[VendorPerformance]] = Field(
        None,
        description="Vendor performance metrics",
    )
    
    # Insights and recommendations
    top_cost_drivers: Optional[List[str]] = Field(
        None,
        max_length=5,
        description="Top cost drivers",
    )
    efficiency_opportunities: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Identified efficiency opportunities",
    )
    risk_areas: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Identified risk areas",
    )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance\maintenance_approval.py ---
# --- File: app/schemas/maintenance/maintenance_approval.py ---
"""
Maintenance approval workflow schemas.

Provides schemas for approval requests, responses, threshold configuration,
and rejection handling with comprehensive validation.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Dict, Optional, Any, List

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "ApprovalRequest",
    "ApprovalResponse",
    "ThresholdConfig",
    "ApprovalWorkflow",
    "RejectionRequest",
]


class ApprovalRequest(BaseCreateSchema):
    """
    Request approval for maintenance work.
    
    Submitted by supervisor to admin when cost exceeds threshold
    or approval is required for other reasons.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Maintenance request number",
    )
    
    # Cost details
    estimated_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Estimated total cost",
    )
    cost_breakdown: Optional[Dict[str, Decimal]] = Field(
        None,
        description="Detailed cost breakdown by category",
    )
    cost_justification: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Detailed justification for cost estimate",
    )
    
    # Approval justification
    approval_reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Reason why approval is needed",
    )
    business_impact: Optional[str] = Field(
        None,
        max_length=500,
        description="Impact on business/operations if not approved",
    )
    
    # Urgency
    urgent: bool = Field(
        False,
        description="Whether approval is urgent",
    )
    urgency_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for urgency (if urgent)",
    )
    
    # Vendor information
    preferred_vendor: Optional[str] = Field(
        None,
        max_length=255,
        description="Preferred vendor/contractor",
    )
    vendor_quote: Optional[str] = Field(
        None,
        description="Vendor quote reference or URL",
    )
    alternative_quotes: Optional[int] = Field(
        None,
        ge=0,
        le=10,
        description="Number of alternative quotes obtained",
    )
    
    # Timeline
    requested_completion_date: Optional[date] = Field(
        None,
        description="Requested completion date",
    )
    
    # Requester
    requested_by: UUID = Field(
        ...,
        description="Supervisor requesting approval",
    )

    @field_validator("estimated_cost")
    @classmethod
    def round_cost(cls, v: Decimal) -> Decimal:
        """Round cost to 2 decimal places."""
        return round(v, 2)

    @field_validator("cost_breakdown")
    @classmethod
    def validate_cost_breakdown(
        cls,
        v: Optional[Dict[str, Decimal]],
    ) -> Optional[Dict[str, Decimal]]:
        """
        Validate cost breakdown values.
        
        Ensures all breakdown amounts are positive and reasonable.
        """
        if v is not None:
            for category, amount in v.items():
                if amount < 0:
                    raise ValueError(
                        f"Cost breakdown amount for '{category}' cannot be negative"
                    )
                
                # Round to 2 decimal places
                v[category] = round(amount, 2)
        
        return v

    @field_validator(
        "cost_justification",
        "approval_reason",
        "business_impact",
        "urgency_reason",
    )
    @classmethod
    def validate_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize text fields."""
        if v is not None:
            v = v.strip()
            
            # For required fields (cost_justification, approval_reason)
            if isinstance(v, str) and len(v) > 0:
                return v
            
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_urgency_requirements(self) -> "ApprovalRequest":
        """
        Validate urgency flag consistency.
        
        Urgent requests should have urgency reason.
        """
        if self.urgent and not self.urgency_reason:
            raise ValueError(
                "Urgency reason is required when approval is marked urgent"
            )
        
        return self

    @model_validator(mode="after")
    def validate_cost_breakdown_total(self) -> "ApprovalRequest":
        """
        Validate cost breakdown matches estimated cost.
        
        Sum of breakdown should match total estimate.
        """
        if self.cost_breakdown:
            breakdown_total = sum(self.cost_breakdown.values())
            
            # Allow 1% variance for rounding
            variance = abs(breakdown_total - self.estimated_cost)
            max_variance = self.estimated_cost * Decimal("0.01")
            
            if variance > max_variance and variance > Decimal("10.00"):
                raise ValueError(
                    f"Cost breakdown total ({breakdown_total}) doesn't match "
                    f"estimated cost ({self.estimated_cost})"
                )
        
        return self


class ApprovalResponse(BaseSchema):
    """
    Approval decision response.
    
    Provides complete information about approval or rejection
    with justification and conditions.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    
    # Decision
    approved: bool = Field(
        ...,
        description="Whether request was approved",
    )
    decision_maker: UUID = Field(
        ...,
        description="User ID who made decision",
    )
    decision_maker_name: str = Field(
        ...,
        description="Name of decision maker",
    )
    decision_maker_role: str = Field(
        ...,
        description="Role of decision maker",
    )
    decided_at: datetime = Field(
        ...,
        description="Decision timestamp",
    )
    
    # Approved details (if approved)
    approved_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Approved amount (may differ from requested)",
    )
    approval_conditions: Optional[str] = Field(
        None,
        max_length=1000,
        description="Conditions or requirements for approval",
    )
    approval_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional approval notes",
    )
    
    # Rejection details (if rejected)
    rejection_reason: Optional[str] = Field(
        None,
        max_length=1000,
        description="Detailed rejection reason",
    )
    suggested_alternative: Optional[str] = Field(
        None,
        max_length=500,
        description="Suggested alternative approach",
    )
    resubmission_allowed: bool = Field(
        default=True,
        description="Whether request can be resubmitted",
    )
    
    # Response message
    message: str = Field(
        ...,
        description="Human-readable response message",
    )
    
    # Notification tracking
    notifications_sent: bool = Field(
        default=False,
        description="Whether notifications were sent",
    )

    @field_validator("approved_amount")
    @classmethod
    def round_amount(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round approved amount to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_response_consistency(self) -> "ApprovalResponse":
        """
        Validate approval response consistency.
        
        Ensures approval/rejection fields are consistent with decision.
        """
        if self.approved:
            # Approved requests should have approved amount
            if self.approved_amount is None:
                raise ValueError(
                    "Approved amount is required for approved requests"
                )
            
            # Shouldn't have rejection details
            if self.rejection_reason:
                raise ValueError(
                    "Rejection reason should not be present for approved requests"
                )
        else:
            # Rejected requests must have rejection reason
            if not self.rejection_reason:
                raise ValueError(
                    "Rejection reason is required for rejected requests"
                )
            
            if len(self.rejection_reason.strip()) < 20:
                raise ValueError(
                    "Rejection reason must be at least 20 characters"
                )
            
            # Shouldn't have approval details
            if self.approval_conditions or self.approved_amount:
                raise ValueError(
                    "Approval details should not be present for rejected requests"
                )
        
        return self


class ThresholdConfig(BaseSchema):
    """
    Approval threshold configuration for hostel.
    
    Defines cost limits and approval requirements for
    different authorization levels.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    
    # Supervisor approval threshold
    supervisor_approval_limit: Decimal = Field(
        Decimal("5000.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Maximum amount supervisor can approve independently",
    )
    
    # Admin approval required above
    admin_approval_required_above: Decimal = Field(
        Decimal("5000.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Amount above which admin approval is required",
    )
    
    # Auto-approve threshold
    auto_approve_below: Decimal = Field(
        Decimal("1000.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Amount below which requests are auto-approved",
    )
    auto_approve_enabled: bool = Field(
        default=True,
        description="Whether auto-approval is enabled",
    )
    
    # Senior management threshold
    senior_management_required_above: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Amount requiring senior management approval",
    )
    
    # Emergency handling
    emergency_bypass_threshold: bool = Field(
        True,
        description="Allow emergency requests to bypass normal thresholds",
    )
    emergency_approval_limit: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Special limit for emergency approvals",
    )
    
    # Category-specific thresholds
    category_specific_limits: Optional[Dict[str, Decimal]] = Field(
        None,
        description="Custom limits per maintenance category",
    )
    
    # Approval workflow
    require_multiple_quotes_above: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Amount above which multiple quotes required",
    )
    minimum_quotes_required: int = Field(
        default=3,
        ge=1,
        le=5,
        description="Minimum number of quotes for high-value work",
    )
    
    # Configuration metadata
    last_updated: datetime = Field(
        ...,
        description="Last configuration update",
    )
    updated_by: UUID = Field(
        ...,
        description="User who last updated configuration",
    )

    @field_validator(
        "supervisor_approval_limit",
        "admin_approval_required_above",
        "auto_approve_below",
        "senior_management_required_above",
        "emergency_approval_limit",
        "require_multiple_quotes_above",
    )
    @classmethod
    def round_amounts(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round threshold amounts to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_threshold_hierarchy(self) -> "ThresholdConfig":
        """
        Validate threshold amounts are in logical hierarchy.
        
        Auto-approve < Supervisor < Admin < Senior Management
        """
        # Auto-approve should be less than supervisor limit
        if self.auto_approve_below > self.supervisor_approval_limit:
            raise ValueError(
                "Auto-approve limit must be less than supervisor approval limit"
            )
        
        # Supervisor limit should equal admin threshold
        if self.supervisor_approval_limit != self.admin_approval_required_above:
            raise ValueError(
                "Supervisor approval limit should match admin required threshold"
            )
        
        # Senior management should be higher than admin
        if self.senior_management_required_above:
            if self.senior_management_required_above <= self.admin_approval_required_above:
                raise ValueError(
                    "Senior management threshold must be higher than admin threshold"
                )
        
        return self


class ApprovalWorkflow(BaseSchema):
    """
    Current approval workflow status.
    
    Tracks approval process state and pending actions.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    
    # Cost information
    estimated_cost: Decimal = Field(
        ...,
        ge=0,
        description="Estimated cost",
    )
    threshold_exceeded: bool = Field(
        ...,
        description="Whether cost exceeds threshold",
    )
    exceeded_threshold_type: Optional[str] = Field(
        None,
        pattern=r"^(supervisor|admin|senior_management)$",
        description="Which threshold was exceeded",
    )
    
    # Approval status
    requires_approval: bool = Field(
        ...,
        description="Whether approval is required",
    )
    approval_pending: bool = Field(
        ...,
        description="Whether approval is currently pending",
    )
    approval_level_required: Optional[str] = Field(
        None,
        pattern=r"^(supervisor|admin|senior_management)$",
        description="Required approval level",
    )
    
    # Current approver
    pending_with: Optional[UUID] = Field(
        None,
        description="User ID of current pending approver",
    )
    pending_with_name: Optional[str] = Field(
        None,
        description="Name of current pending approver",
    )
    pending_with_role: Optional[str] = Field(
        None,
        description="Role of pending approver",
    )
    
    # Timeline
    submitted_for_approval_at: Optional[datetime] = Field(
        None,
        description="When request was submitted for approval",
    )
    approval_deadline: Optional[datetime] = Field(
        None,
        description="Deadline for approval decision",
    )
    is_overdue: bool = Field(
        default=False,
        description="Whether approval is overdue",
    )
    
    # Previous approvals (for multi-level)
    previous_approvals: Optional[List[Dict[str, Any]]] = Field(
        None,
        description="Previous approval steps (for multi-level workflows)",
    )
    
    # Escalation
    escalation_count: int = Field(
        default=0,
        ge=0,
        description="Number of times escalated",
    )
    last_escalated_at: Optional[datetime] = Field(
        None,
        description="Last escalation timestamp",
    )

    @field_validator("estimated_cost")
    @classmethod
    def round_cost(cls, v: Decimal) -> Decimal:
        """Round cost to 2 decimal places."""
        return round(v, 2)


class RejectionRequest(BaseCreateSchema):
    """
    Reject maintenance approval request.
    
    Provides detailed rejection with alternatives and guidance.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    rejected_by: UUID = Field(
        ...,
        description="User ID rejecting the request",
    )
    rejection_reason: str = Field(
        ...,
        min_length=20,
        max_length=1000,
        description="Detailed rejection reason",
    )
    rejection_category: Optional[str] = Field(
        None,
        pattern=r"^(cost_too_high|insufficient_justification|alternative_available|budget_constraints|not_urgent|other)$",
        description="Rejection category",
    )
    
    # Alternatives and suggestions
    suggested_alternative: Optional[str] = Field(
        None,
        max_length=500,
        description="Suggested alternative approach",
    )
    suggested_cost_reduction: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Suggested reduced cost amount",
    )
    suggested_vendor: Optional[str] = Field(
        None,
        max_length=255,
        description="Suggested alternative vendor",
    )
    
    # Resubmission guidance
    resubmission_allowed: bool = Field(
        default=True,
        description="Whether request can be resubmitted",
    )
    resubmission_requirements: Optional[str] = Field(
        None,
        max_length=1000,
        description="Requirements for resubmission",
    )
    
    # Notification
    notify_requester: bool = Field(
        default=True,
        description="Send rejection notification",
    )
    notify_supervisor: bool = Field(
        default=True,
        description="Notify supervisor",
    )

    @field_validator("rejection_reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate rejection reason is comprehensive."""
        v = v.strip()
        
        if len(v) < 20:
            raise ValueError(
                "Rejection reason must be at least 20 characters"
            )
        
        # Check for meaningful content
        if len(set(v.lower().replace(" ", ""))) < 10:
            raise ValueError(
                "Please provide a detailed and specific rejection reason"
            )
        
        return v

    @field_validator("suggested_cost_reduction")
    @classmethod
    def round_cost(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round suggested cost to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_resubmission_guidance(self) -> "RejectionRequest":
        """
        Validate resubmission guidance.
        
        If resubmission allowed, provide requirements.
        """
        if self.resubmission_allowed:
            # Should provide guidance on what needs to change
            if not any([
                self.suggested_alternative,
                self.suggested_cost_reduction,
                self.resubmission_requirements,
            ]):
                raise ValueError(
                    "Please provide guidance for resubmission (suggested alternative, "
                    "cost reduction, or specific requirements)"
                )
        
        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance\maintenance_assignment.py ---
# --- File: app/schemas/maintenance/maintenance_assignment.py ---
"""
Maintenance assignment schemas for task allocation.

Provides schemas for assigning maintenance tasks to staff, vendors,
and contractors with tracking and history management.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import EmailStr, Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "TaskAssignment",
    "VendorAssignment",
    "AssignmentUpdate",
    "BulkAssignment",
    "AssignmentHistory",
    "AssignmentEntry",
]


class TaskAssignment(BaseSchema):
    """
    Maintenance task assignment to internal staff.
    
    Tracks assignment of maintenance tasks to hostel staff
    with deadlines and instructions.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Human-readable request number",
    )
    assigned_to: UUID = Field(
        ...,
        description="Staff member user ID",
    )
    assigned_to_name: str = Field(
        ...,
        description="Staff member full name",
    )
    assigned_to_role: Optional[str] = Field(
        None,
        description="Staff member role/designation",
    )
    assigned_by: UUID = Field(
        ...,
        description="Supervisor/admin who assigned the task",
    )
    assigned_by_name: str = Field(
        ...,
        description="Assignor full name",
    )
    assigned_at: datetime = Field(
        ...,
        description="Assignment timestamp",
    )
    deadline: Optional[date] = Field(
        None,
        description="Task completion deadline",
    )
    priority_level: Optional[str] = Field(
        None,
        pattern=r"^(low|medium|high|urgent|critical)$",
        description="Assignment priority",
    )
    instructions: Optional[str] = Field(
        None,
        max_length=1000,
        description="Specific instructions for assigned staff",
    )
    estimated_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        decimal_places=2,
        description="Estimated hours to complete",
    )
    required_skills: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Skills required for the task",
    )
    tools_required: Optional[List[str]] = Field(
        None,
        max_length=20,
        description="Tools/equipment required",
    )

    @field_validator("deadline")
    @classmethod
    def validate_deadline(cls, v: Optional[date]) -> Optional[date]:
        """
        Validate deadline is in the future.
        
        Deadlines should be reasonable and not too far out.
        """
        if v is not None:
            today = date.today()
            
            if v < today:
                raise ValueError("Deadline cannot be in the past")
            
            # Max 6 months out for regular tasks
            days_ahead = (v - today).days
            if days_ahead > 180:
                raise ValueError(
                    "Deadline cannot be more than 6 months in the future"
                )
        
        return v

    @field_validator("instructions")
    @classmethod
    def normalize_instructions(cls, v: Optional[str]) -> Optional[str]:
        """Normalize instructions text."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None


class VendorAssignment(BaseCreateSchema):
    """
    Assignment to external vendor/contractor.
    
    Manages outsourced maintenance work with contract terms,
    quotes, and payment details.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    vendor_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Vendor/contractor company name",
    )
    vendor_contact_person: Optional[str] = Field(
        None,
        max_length=255,
        description="Vendor contact person name",
    )
    vendor_contact: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Vendor primary contact number",
    )
    vendor_email: Optional[EmailStr] = Field(
        None,
        description="Vendor email address",
    )
    vendor_address: Optional[str] = Field(
        None,
        max_length=500,
        description="Vendor business address",
    )

    # Quote and contract
    quoted_amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Vendor quoted amount",
    )
    quote_reference: Optional[str] = Field(
        None,
        max_length=100,
        description="Quote reference number",
    )
    quote_valid_until: Optional[date] = Field(
        None,
        description="Quote validity date",
    )
    payment_terms: Optional[str] = Field(
        None,
        max_length=500,
        description="Payment terms and conditions",
    )
    advance_payment_percentage: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Advance payment percentage",
    )
    advance_payment_amount: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Advance payment amount",
    )

    # Timeline
    estimated_start_date: Optional[date] = Field(
        None,
        description="Estimated work start date",
    )
    estimated_completion_date: date = Field(
        ...,
        description="Estimated completion date",
    )
    
    # Contract details
    work_order_number: Optional[str] = Field(
        None,
        max_length=100,
        description="Work order reference number",
    )
    contract_details: Optional[str] = Field(
        None,
        max_length=2000,
        description="Contract terms and scope of work",
    )
    warranty_period_months: Optional[int] = Field(
        None,
        ge=0,
        le=120,
        description="Warranty period in months",
    )
    warranty_terms: Optional[str] = Field(
        None,
        max_length=1000,
        description="Warranty terms and conditions",
    )

    # Insurance and compliance
    vendor_insured: bool = Field(
        default=False,
        description="Whether vendor has liability insurance",
    )
    insurance_details: Optional[str] = Field(
        None,
        max_length=500,
        description="Insurance policy details",
    )
    compliance_certificates: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Required compliance certificates",
    )

    @field_validator("vendor_contact")
    @classmethod
    def normalize_phone(cls, v: str) -> str:
        """Normalize vendor phone number."""
        return v.replace(" ", "").replace("-", "").strip()

    @field_validator("quoted_amount", "advance_payment_amount")
    @classmethod
    def round_amounts(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round monetary amounts to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @field_validator(
        "vendor_address",
        "payment_terms",
        "contract_details",
        "warranty_terms",
        "insurance_details",
    )
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_dates_consistency(self) -> "VendorAssignment":
        """
        Validate date consistency.
        
        Ensures start date is before completion date and dates are reasonable.
        """
        # Completion date should be in future
        if self.estimated_completion_date < date.today():
            raise ValueError(
                "Estimated completion date cannot be in the past"
            )
        
        # Start date should be before completion
        if self.estimated_start_date:
            if self.estimated_start_date > self.estimated_completion_date:
                raise ValueError(
                    "Start date must be before completion date"
                )
        
        # Quote validity
        if self.quote_valid_until:
            if self.quote_valid_until < date.today():
                raise ValueError(
                    "Quote validity date cannot be in the past"
                )
        
        return self

    @model_validator(mode="after")
    def validate_advance_payment(self) -> "VendorAssignment":
        """
        Validate advance payment calculation.
        
        Ensures advance amount matches percentage if both provided.
        """
        if self.advance_payment_percentage and self.advance_payment_amount:
            expected_advance = (
                self.quoted_amount * self.advance_payment_percentage / 100
            )
            
            # Allow small rounding differences
            if abs(expected_advance - self.advance_payment_amount) > Decimal("1.00"):
                raise ValueError(
                    f"Advance payment amount ({self.advance_payment_amount}) "
                    f"doesn't match percentage ({self.advance_payment_percentage}%) "
                    f"of quoted amount ({self.quoted_amount})"
                )
        
        # If only percentage given, calculate amount
        if self.advance_payment_percentage and not self.advance_payment_amount:
            self.advance_payment_amount = round(
                self.quoted_amount * self.advance_payment_percentage / 100,
                2,
            )
        
        return self

    @model_validator(mode="after")
    def validate_warranty_requirements(self) -> "VendorAssignment":
        """
        Validate warranty information.
        
        If warranty period is specified, terms should be provided.
        """
        if self.warranty_period_months and self.warranty_period_months > 0:
            if not self.warranty_terms:
                raise ValueError(
                    "Warranty terms are required when warranty period is specified"
                )
        
        return self


class AssignmentUpdate(BaseCreateSchema):
    """
    Update existing maintenance assignment.
    
    Allows reassignment, deadline changes, and additional instructions.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )

    # Reassignment
    new_assigned_to: Optional[UUID] = Field(
        None,
        description="New assignee user ID (for reassignment)",
    )
    reassignment_reason: Optional[str] = Field(
        None,
        min_length=10,
        max_length=500,
        description="Reason for reassignment",
    )

    # Deadline modification
    new_deadline: Optional[date] = Field(
        None,
        description="Updated deadline",
    )
    deadline_change_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for deadline change",
    )

    # Additional information
    additional_instructions: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional instructions to append",
    )
    priority_change: Optional[str] = Field(
        None,
        pattern=r"^(low|medium|high|urgent|critical)$",
        description="Updated priority level",
    )

    # Update context
    updated_by: UUID = Field(
        ...,
        description="User making the update",
    )
    update_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Notes about the update",
    )

    @field_validator("reassignment_reason")
    @classmethod
    def validate_reassignment_reason(cls, v: Optional[str]) -> Optional[str]:
        """Validate reassignment reason if provided."""
        if v is not None:
            v = v.strip()
            if len(v) < 10:
                raise ValueError(
                    "Reassignment reason must be at least 10 characters"
                )
            return v
        return None

    @field_validator("new_deadline")
    @classmethod
    def validate_new_deadline(cls, v: Optional[date]) -> Optional[date]:
        """Validate new deadline is in future."""
        if v is not None and v < date.today():
            raise ValueError("New deadline cannot be in the past")
        return v

    @field_validator(
        "deadline_change_reason",
        "additional_instructions",
        "update_notes",
    )
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_update_requirements(self) -> "AssignmentUpdate":
        """
        Validate update field requirements.
        
        Ensures proper justification for changes.
        """
        # Reassignment requires reason
        if self.new_assigned_to and not self.reassignment_reason:
            raise ValueError(
                "Reassignment reason is required when changing assignee"
            )
        
        # Deadline extension should have reason
        if self.new_deadline and self.deadline_change_reason:
            # This is good practice
            pass
        
        return self


class BulkAssignment(BaseCreateSchema):
    """
    Assign multiple maintenance requests to same person.
    
    Efficient bulk assignment for batch processing of similar issues.
    """

    maintenance_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of maintenance request IDs",
    )
    assigned_to: UUID = Field(
        ...,
        description="User ID to assign all requests to",
    )
    assigned_by: UUID = Field(
        ...,
        description="User ID making the assignments",
    )
    common_deadline: Optional[date] = Field(
        None,
        description="Common deadline for all requests",
    )
    instructions: Optional[str] = Field(
        None,
        max_length=1000,
        description="Common instructions for all assignments",
    )
    priority_level: Optional[str] = Field(
        None,
        pattern=r"^(low|medium|high|urgent|critical)$",
        description="Common priority for all assignments",
    )
    send_notification: bool = Field(
        default=True,
        description="Send notification to assignee",
    )
    bulk_assignment_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Notes about bulk assignment",
    )

    @field_validator("maintenance_ids")
    @classmethod
    def validate_unique_ids(cls, v: List[UUID]) -> List[UUID]:
        """
        Ensure no duplicate maintenance IDs.
        
        Prevents double-assignment errors.
        """
        if len(v) != len(set(v)):
            # Find duplicates
            seen = set()
            duplicates = set()
            for maintenance_id in v:
                if maintenance_id in seen:
                    duplicates.add(str(maintenance_id))
                seen.add(maintenance_id)
            
            raise ValueError(
                f"Duplicate maintenance IDs not allowed: {', '.join(duplicates)}"
            )
        
        return v

    @field_validator("common_deadline")
    @classmethod
    def validate_deadline(cls, v: Optional[date]) -> Optional[date]:
        """Validate deadline is in future."""
        if v is not None and v < date.today():
            raise ValueError("Deadline cannot be in the past")
        return v

    @field_validator("instructions", "bulk_assignment_notes")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None


class AssignmentEntry(BaseSchema):
    """
    Individual assignment history entry.
    
    Represents a single assignment in the history timeline.
    """

    assignment_id: UUID = Field(
        ...,
        description="Assignment unique identifier",
    )
    assigned_to: UUID = Field(
        ...,
        description="Assignee user ID",
    )
    assigned_to_name: str = Field(
        ...,
        description="Assignee full name",
    )
    assigned_to_role: Optional[str] = Field(
        None,
        description="Assignee role/designation",
    )
    assigned_by: UUID = Field(
        ...,
        description="Assignor user ID",
    )
    assigned_by_name: str = Field(
        ...,
        description="Assignor full name",
    )
    assigned_at: datetime = Field(
        ...,
        description="Assignment timestamp",
    )
    deadline: Optional[date] = Field(
        None,
        description="Task deadline",
    )
    instructions: Optional[str] = Field(
        None,
        description="Assignment instructions",
    )

    # Completion tracking
    completed: bool = Field(
        False,
        description="Whether task was completed by this assignee",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="Completion timestamp",
    )
    completion_notes: Optional[str] = Field(
        None,
        description="Completion notes",
    )

    # Reassignment tracking
    reassigned: bool = Field(
        False,
        description="Whether task was reassigned to someone else",
    )
    reassigned_at: Optional[datetime] = Field(
        None,
        description="Reassignment timestamp",
    )
    reassignment_reason: Optional[str] = Field(
        None,
        description="Reason for reassignment",
    )

    # Performance metrics
    time_to_complete_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Hours taken to complete (if completed)",
    )
    met_deadline: Optional[bool] = Field(
        None,
        description="Whether deadline was met (if completed)",
    )

    @model_validator(mode="after")
    def validate_completion_consistency(self) -> "AssignmentEntry":
        """
        Validate completion data consistency.
        
        Ensures completion timestamps and flags are consistent.
        """
        if self.completed:
            if not self.completed_at:
                raise ValueError(
                    "Completion timestamp required when task is completed"
                )
            
            # Can't be both completed and reassigned
            if self.reassigned:
                raise ValueError(
                    "Task cannot be both completed and reassigned"
                )
        
        if self.reassigned and not self.reassigned_at:
            raise ValueError(
                "Reassignment timestamp required when task is reassigned"
            )
        
        return self


class AssignmentHistory(BaseSchema):
    """
    Complete assignment history for maintenance request.
    
    Tracks all assignments, reassignments, and completions
    for audit trail and performance analysis.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    total_assignments: int = Field(
        ...,
        ge=0,
        description="Total number of times task was assigned",
    )
    current_assignee: Optional[str] = Field(
        None,
        description="Current assignee name (if still assigned)",
    )
    current_assignee_id: Optional[UUID] = Field(
        None,
        description="Current assignee user ID",
    )
    assignments: List[AssignmentEntry] = Field(
        ...,
        description="Chronological list of all assignments",
    )
    
    # Summary metrics
    average_assignment_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average time per assignment",
    )
    total_reassignments: int = Field(
        default=0,
        ge=0,
        description="Number of reassignments",
    )

    @field_validator("assignments")
    @classmethod
    def validate_assignments_order(cls, v: List[AssignmentEntry]) -> List[AssignmentEntry]:
        """
        Validate assignments are in chronological order.
        
        Ensures history timeline is logical.
        """
        if len(v) > 1:
            for i in range(len(v) - 1):
                if v[i].assigned_at > v[i + 1].assigned_at:
                    raise ValueError(
                        "Assignment history must be in chronological order"
                    )
        
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance\maintenance_base.py ---
# --- File: app/schemas/maintenance/maintenance_base.py ---
"""
Base maintenance schemas with comprehensive validation and type safety.

This module provides foundational schemas for maintenance request management
including creation, updates, and core validation logic.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import (
    MaintenanceCategory,
    MaintenanceIssueType,
    MaintenanceStatus,
    Priority,
)

__all__ = [
    "MaintenanceBase",
    "MaintenanceCreate",
    "MaintenanceUpdate",
    "MaintenanceStatusUpdate",
]


class MaintenanceBase(BaseSchema):
    """
    Base maintenance request schema with core fields.
    
    Provides common maintenance attributes and validation logic
    used across create/update operations.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    requested_by: UUID = Field(
        ...,
        description="User ID who requested maintenance",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Room where issue exists (if applicable)",
    )

    # Request details
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Brief issue summary",
    )
    description: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed issue description",
    )

    # Classification
    category: MaintenanceCategory = Field(
        ...,
        description="Maintenance category",
    )
    priority: Priority = Field(
        Priority.MEDIUM,
        description="Issue priority level",
    )
    issue_type: MaintenanceIssueType = Field(
        MaintenanceIssueType.ROUTINE,
        description="Type of maintenance issue",
    )

    # Location details
    location: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional location details",
    )
    floor: Optional[int] = Field(
        None,
        ge=0,
        le=50,
        description="Floor number (if applicable)",
    )
    specific_area: Optional[str] = Field(
        None,
        max_length=255,
        description="Specific area within location (e.g., bathroom, kitchen)",
    )

    # Attachments
    issue_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="URLs to issue photographs",
    )

    @field_validator("title")
    @classmethod
    def validate_title(cls, v: str) -> str:
        """
        Validate and normalize title.
        
        Ensures title is meaningful and properly formatted.
        """
        v = v.strip()
        
        if len(v) < 5:
            raise ValueError("Title must be at least 5 characters")
        
        # Basic meaningfulness check
        if len(set(v.lower().replace(" ", ""))) < 3:
            raise ValueError("Title must be meaningful and descriptive")
        
        return v

    @field_validator("description")
    @classmethod
    def validate_description(cls, v: str) -> str:
        """
        Validate and normalize description.
        
        Ensures description provides adequate detail.
        """
        v = v.strip()
        
        if len(v) < 20:
            raise ValueError("Description must be at least 20 characters")
        
        # Check for meaningful content
        if len(set(v.lower().replace(" ", ""))) < 10:
            raise ValueError("Description must provide detailed information")
        
        return v

    @field_validator("location", "specific_area")
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields by stripping whitespace."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @field_validator("issue_photos")
    @classmethod
    def validate_photos(cls, v: List[HttpUrl]) -> List[HttpUrl]:
        """Validate photo URLs list."""
        if len(v) > 10:
            raise ValueError("Maximum 10 photos allowed per request")
        return v

    @model_validator(mode="after")
    def validate_priority_consistency(self) -> "MaintenanceBase":
        """
        Validate priority consistency with issue type.
        
        Emergency issues should have high/urgent priority.
        """
        if self.issue_type == MaintenanceIssueType.EMERGENCY:
            if self.priority not in [Priority.HIGH, Priority.URGENT, Priority.CRITICAL]:
                raise ValueError(
                    "Emergency issues must have HIGH, URGENT, or CRITICAL priority"
                )
        
        return self


class MaintenanceCreate(MaintenanceBase, BaseCreateSchema):
    """
    Create maintenance request with additional context.
    
    Extends base schema with creation-specific fields and validation.
    """

    # Additional creation context
    preferred_completion_date: Optional[date] = Field(
        None,
        description="Preferred completion date (if any)",
    )
    notify_on_completion: bool = Field(
        default=True,
        description="Send notification when completed",
    )
    allow_cost_estimation: bool = Field(
        default=True,
        description="Allow supervisor to estimate costs",
    )

    @field_validator("preferred_completion_date")
    @classmethod
    def validate_completion_date(cls, v: Optional[date]) -> Optional[date]:
        """
        Validate preferred completion date.
        
        Ensures date is in the future and within reasonable range.
        """
        if v is not None:
            today = date.today()
            
            # Can't be in the past
            if v < today:
                raise ValueError(
                    "Preferred completion date cannot be in the past"
                )
            
            # Should be within reasonable timeframe (1 year)
            days_ahead = (v - today).days
            if days_ahead > 365:
                raise ValueError(
                    "Preferred completion date cannot be more than 1 year ahead"
                )
        
        return v

    @model_validator(mode="after")
    def validate_emergency_urgency(self) -> "MaintenanceCreate":
        """
        Validate emergency requests have appropriate urgency.
        
        Emergency issues should have immediate preferred completion.
        """
        if self.issue_type == MaintenanceIssueType.EMERGENCY:
            if self.preferred_completion_date:
                days_ahead = (
                    self.preferred_completion_date - date.today()
                ).days
                
                if days_ahead > 3:
                    raise ValueError(
                        "Emergency requests should have completion date within 3 days"
                    )
        
        return self


class MaintenanceUpdate(BaseUpdateSchema):
    """
    Update maintenance request with partial fields.
    
    All fields are optional for flexible updates. Typically used
    to modify pending requests or add information during processing.
    """

    title: Optional[str] = Field(
        None,
        min_length=5,
        max_length=255,
        description="Updated title",
    )
    description: Optional[str] = Field(
        None,
        min_length=20,
        max_length=2000,
        description="Updated description",
    )
    category: Optional[MaintenanceCategory] = Field(
        None,
        description="Updated category",
    )
    priority: Optional[Priority] = Field(
        None,
        description="Updated priority",
    )
    location: Optional[str] = Field(
        None,
        max_length=500,
        description="Updated location",
    )
    floor: Optional[int] = Field(
        None,
        ge=0,
        le=50,
        description="Updated floor",
    )
    specific_area: Optional[str] = Field(
        None,
        max_length=255,
        description="Updated specific area",
    )

    # Status
    status: Optional[MaintenanceStatus] = Field(
        None,
        description="Updated status (restricted to certain roles)",
    )

    # Cost information
    estimated_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Estimated repair cost",
    )
    actual_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Actual cost incurred",
    )

    # Timeline
    estimated_completion_date: Optional[date] = Field(
        None,
        description="Estimated completion date",
    )

    @field_validator("title", "description", "location", "specific_area")
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            if isinstance(v, str):
                # Different validation for different fields
                return v if v else None
        return None

    @field_validator("estimated_cost", "actual_cost")
    @classmethod
    def round_costs(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round costs to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_cost_consistency(self) -> "MaintenanceUpdate":
        """
        Validate cost fields consistency.
        
        Actual cost should not exceed estimated cost by too much.
        """
        if self.estimated_cost is not None and self.actual_cost is not None:
            # Allow 50% variance
            max_allowed = self.estimated_cost * Decimal("1.5")
            
            if self.actual_cost > max_allowed:
                raise ValueError(
                    f"Actual cost ({self.actual_cost}) exceeds estimated cost "
                    f"({self.estimated_cost}) by more than 50%"
                )
        
        return self


class MaintenanceStatusUpdate(BaseUpdateSchema):
    """
    Update maintenance status with tracking notes.
    
    Simplified schema for status transitions with audit trail.
    """

    status: MaintenanceStatus = Field(
        ...,
        description="New maintenance status",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Status change notes/reason",
    )
    notify_requester: bool = Field(
        default=True,
        description="Send notification to requester",
    )
    updated_by: UUID = Field(
        ...,
        description="User ID making the status change",
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: Optional[str]) -> Optional[str]:
        """Normalize status notes."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_status_notes_requirement(self) -> "MaintenanceStatusUpdate":
        """
        Validate notes requirement for certain status changes.
        
        Rejection, cancellation require mandatory notes.
        """
        statuses_requiring_notes = {
            MaintenanceStatus.REJECTED,
            MaintenanceStatus.CANCELLED,
            MaintenanceStatus.ON_HOLD,
        }
        
        if self.status in statuses_requiring_notes:
            if not self.notes:
                raise ValueError(
                    f"Notes are required when changing status to {self.status.value}"
                )
            
            if len(self.notes.strip()) < 10:
                raise ValueError(
                    "Notes must be at least 10 characters for this status change"
                )
        
        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance\maintenance_completion.py ---
# --- File: app/schemas/maintenance/maintenance_completion.py ---
"""
Maintenance completion schemas with quality tracking.

Provides schemas for marking maintenance as completed, quality checks,
material tracking, and completion certificates.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "CompletionRequest",
    "MaterialItem",
    "QualityCheck",
    "ChecklistItem",
    "CompletionResponse",
    "CompletionCertificate",
]


class MaterialItem(BaseSchema):
    """
    Material used in maintenance work.
    
    Tracks individual materials with quantities and costs
    for accurate billing and inventory management.
    """

    material_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Material/item name",
    )
    material_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Material code/SKU",
    )
    category: Optional[str] = Field(
        None,
        max_length=100,
        description="Material category",
    )
    quantity: Decimal = Field(
        ...,
        gt=0,
        max_digits=10,
        decimal_places=3,
        description="Quantity used",
    )
    unit: str = Field(
        ...,
        min_length=1,
        max_length=20,
        description="Unit of measurement (pcs, kg, liters, meters, etc.)",
    )
    unit_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Cost per unit",
    )
    total_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Total cost for this material",
    )
    supplier: Optional[str] = Field(
        None,
        max_length=255,
        description="Material supplier name",
    )
    supplier_invoice: Optional[str] = Field(
        None,
        max_length=100,
        description="Supplier invoice number",
    )
    warranty_months: Optional[int] = Field(
        None,
        ge=0,
        le=120,
        description="Material warranty period in months",
    )

    @field_validator("quantity", "unit_cost", "total_cost")
    @classmethod
    def round_decimals(cls, v: Decimal) -> Decimal:
        """Round decimal values appropriately."""
        # Quantity can have 3 decimals, costs have 2
        return v

    @field_validator("material_name", "category", "unit", "supplier")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_cost_calculation(self) -> "MaterialItem":
        """
        Validate total cost calculation.
        
        Ensures total_cost = quantity  unit_cost (with rounding tolerance).
        """
        calculated_total = self.quantity * self.unit_cost
        
        # Allow small rounding differences (0.01)
        if abs(calculated_total - self.total_cost) > Decimal("0.01"):
            raise ValueError(
                f"Total cost ({self.total_cost}) doesn't match "
                f"quantity ({self.quantity})  unit cost ({self.unit_cost}) "
                f"= {calculated_total}"
            )
        
        return self


class CompletionRequest(BaseCreateSchema):
    """
    Mark maintenance work as completed.
    
    Comprehensive completion with work notes, materials,
    labor tracking, and cost documentation.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    completed_by: UUID = Field(
        ...,
        description="User ID who completed the work",
    )
    
    # Completion details
    work_notes: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed notes about work performed",
    )
    work_summary: Optional[str] = Field(
        None,
        max_length=500,
        description="Brief work summary",
    )
    
    # Materials used
    materials_used: List[MaterialItem] = Field(
        default_factory=list,
        max_length=100,
        description="List of materials used",
    )
    
    # Labor tracking
    labor_hours: Decimal = Field(
        ...,
        ge=0,
        le=1000,
        decimal_places=2,
        description="Total labor hours spent",
    )
    labor_rate_per_hour: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Labor rate per hour",
    )
    number_of_workers: int = Field(
        default=1,
        ge=1,
        le=50,
        description="Number of workers involved",
    )
    
    # Cost breakdown
    materials_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Total materials cost",
    )
    labor_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Total labor cost",
    )
    vendor_charges: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="External vendor charges",
    )
    other_costs: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Other miscellaneous costs",
    )
    actual_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Total actual cost",
    )
    cost_breakdown: Optional[dict] = Field(
        None,
        description="Detailed cost breakdown",
    )
    
    # Photos
    completion_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=15,
        description="After-completion photographs",
    )
    before_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=15,
        description="Before work photographs (if available)",
    )
    
    # Timeline
    actual_start_date: Optional[date] = Field(
        None,
        description="Actual work start date",
    )
    actual_completion_date: date = Field(
        ...,
        description="Actual completion date",
    )
    total_working_days: Optional[int] = Field(
        None,
        ge=0,
        description="Total working days taken",
    )
    
    # Follow-up
    follow_up_required: bool = Field(
        False,
        description="Whether follow-up inspection needed",
    )
    follow_up_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Follow-up requirements",
    )
    follow_up_date: Optional[date] = Field(
        None,
        description="Scheduled follow-up date",
    )
    
    # Warranty
    warranty_applicable: bool = Field(
        default=False,
        description="Whether warranty applies to this work",
    )
    warranty_period_months: Optional[int] = Field(
        None,
        ge=0,
        le=120,
        description="Warranty period in months",
    )
    warranty_terms: Optional[str] = Field(
        None,
        max_length=1000,
        description="Warranty terms and conditions",
    )

    @field_validator(
        "labor_hours",
        "materials_cost",
        "labor_cost",
        "vendor_charges",
        "other_costs",
        "actual_cost",
        "labor_rate_per_hour",
    )
    @classmethod
    def round_decimals(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round decimal values to 2 places."""
        return round(v, 2) if v is not None else None

    @field_validator("work_notes", "work_summary", "follow_up_notes", "warranty_terms")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_completion_dates(self) -> "CompletionRequest":
        """
        Validate completion date consistency.
        
        Ensures dates are logical and in proper sequence.
        """
        # Completion date can't be in future
        if self.actual_completion_date > date.today():
            raise ValueError("Completion date cannot be in the future")
        
        # Start date should be before completion
        if self.actual_start_date:
            if self.actual_start_date > self.actual_completion_date:
                raise ValueError(
                    "Start date must be before or equal to completion date"
                )
            
            # Calculate working days if not provided
            if self.total_working_days is None:
                self.total_working_days = (
                    self.actual_completion_date - self.actual_start_date
                ).days + 1
        
        return self

    @model_validator(mode="after")
    def validate_cost_breakdown(self) -> "CompletionRequest":
        """
        Validate cost breakdown matches total.
        
        Sum of components should equal actual cost.
        """
        total_components = (
            self.materials_cost
            + self.labor_cost
            + self.vendor_charges
            + self.other_costs
        )
        
        # Allow small rounding differences
        if abs(total_components - self.actual_cost) > Decimal("1.00"):
            raise ValueError(
                f"Cost breakdown ({total_components}) doesn't match "
                f"actual cost ({self.actual_cost})"
            )
        
        return self

    @model_validator(mode="after")
    def validate_materials_cost(self) -> "CompletionRequest":
        """
        Validate materials cost matches materials list.
        
        Sum of material items should match materials_cost.
        """
        if self.materials_used:
            calculated_materials_cost = sum(
                item.total_cost for item in self.materials_used
            )
            
            # Allow small variance
            if abs(calculated_materials_cost - self.materials_cost) > Decimal("1.00"):
                raise ValueError(
                    f"Materials cost ({self.materials_cost}) doesn't match "
                    f"sum of material items ({calculated_materials_cost})"
                )
        
        return self

    @model_validator(mode="after")
    def validate_labor_cost(self) -> "CompletionRequest":
        """
        Validate labor cost calculation.
        
        If labor rate provided, cost should match hours  rate.
        """
        if self.labor_rate_per_hour is not None:
            calculated_labor_cost = self.labor_hours * self.labor_rate_per_hour
            
            if abs(calculated_labor_cost - self.labor_cost) > Decimal("1.00"):
                raise ValueError(
                    f"Labor cost ({self.labor_cost}) doesn't match "
                    f"hours ({self.labor_hours})  rate ({self.labor_rate_per_hour})"
                )
        
        return self

    @model_validator(mode="after")
    def validate_follow_up_requirements(self) -> "CompletionRequest":
        """
        Validate follow-up information.
        
        If follow-up required, notes and date should be provided.
        """
        if self.follow_up_required:
            if not self.follow_up_notes:
                raise ValueError(
                    "Follow-up notes are required when follow-up is needed"
                )
            
            if not self.follow_up_date:
                raise ValueError(
                    "Follow-up date is required when follow-up is needed"
                )
            
            # Follow-up date should be in future
            if self.follow_up_date <= self.actual_completion_date:
                raise ValueError(
                    "Follow-up date must be after completion date"
                )
        
        return self

    @model_validator(mode="after")
    def validate_warranty_requirements(self) -> "CompletionRequest":
        """
        Validate warranty information.
        
        If warranty applicable, period and terms should be provided.
        """
        if self.warranty_applicable:
            if not self.warranty_period_months:
                raise ValueError(
                    "Warranty period is required when warranty is applicable"
                )
            
            if not self.warranty_terms:
                raise ValueError(
                    "Warranty terms are required when warranty is applicable"
                )
        
        return self


class ChecklistItem(BaseSchema):
    """
    Quality check checklist item.
    
    Individual item in quality inspection checklist.
    """

    item_id: Optional[str] = Field(
        None,
        max_length=50,
        description="Checklist item unique ID",
    )
    item_description: str = Field(
        ...,
        min_length=5,
        max_length=500,
        description="What to check/verify",
    )
    category: Optional[str] = Field(
        None,
        max_length=100,
        description="Check category",
    )
    status: str = Field(
        ...,
        pattern=r"^(pass|fail|na|partial)$",
        description="Check result status",
    )
    is_critical: bool = Field(
        default=False,
        description="Whether this is a critical check",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes or observations",
    )
    checked_by: Optional[str] = Field(
        None,
        max_length=255,
        description="Person who performed this check",
    )
    photo_evidence: Optional[HttpUrl] = Field(
        None,
        description="Photo evidence URL",
    )

    @field_validator("item_description", "notes")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None


class QualityCheck(BaseCreateSchema):
    """
    Quality check for completed maintenance work.
    
    Inspection and verification of work quality with
    detailed checklist and approval/rejection.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    
    # Overall result
    quality_check_passed: bool = Field(
        ...,
        description="Overall quality check result",
    )
    overall_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Overall quality rating (1-5 stars)",
    )
    
    # Detailed checklist
    checklist_items: List[ChecklistItem] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Quality check checklist items",
    )
    
    # Inspection details
    quality_check_notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Detailed quality check notes",
    )
    defects_found: Optional[str] = Field(
        None,
        max_length=1000,
        description="Any defects or issues found",
    )
    
    # Inspector
    checked_by: UUID = Field(
        ...,
        description="User ID who performed quality check",
    )
    inspection_date: date = Field(
        ...,
        description="Inspection date",
    )
    inspection_time: Optional[time] = Field(
        None,
        description="Inspection time",
    )
    
    # Rework requirements
    rework_required: bool = Field(
        False,
        description="Whether rework is needed",
    )
    rework_details: Optional[str] = Field(
        None,
        max_length=1000,
        description="Details of required rework",
    )
    rework_deadline: Optional[date] = Field(
        None,
        description="Deadline for completing rework",
    )
    
    # Sign-off
    customer_acceptance: Optional[bool] = Field(
        None,
        description="Customer/requester acceptance",
    )
    customer_feedback: Optional[str] = Field(
        None,
        max_length=1000,
        description="Customer feedback",
    )
    
    # Photos
    inspection_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=20,
        description="Quality inspection photographs",
    )

    @field_validator("inspection_date")
    @classmethod
    def validate_inspection_date(cls, v: date) -> date:
        """Validate inspection date is not in future."""
        if v > date.today():
            raise ValueError("Inspection date cannot be in the future")
        return v

    @field_validator(
        "quality_check_notes",
        "defects_found",
        "rework_details",
        "customer_feedback",
    )
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_rework_requirements(self) -> "QualityCheck":
        """
        Validate rework information consistency.
        
        If rework required, details and deadline should be provided.
        """
        if self.rework_required:
            if not self.rework_details:
                raise ValueError(
                    "Rework details are required when rework is needed"
                )
            
            if not self.rework_deadline:
                raise ValueError(
                    "Rework deadline is required when rework is needed"
                )
            
            # Rework deadline should be in future
            if self.rework_deadline < date.today():
                raise ValueError("Rework deadline cannot be in the past")
            
            # Quality check should fail if rework needed
            if self.quality_check_passed:
                raise ValueError(
                    "Quality check cannot pass if rework is required"
                )
        
        return self

    @model_validator(mode="after")
    def validate_critical_failures(self) -> "QualityCheck":
        """
        Validate critical checklist items.
        
        Quality check should fail if any critical item fails.
        """
        critical_failures = [
            item for item in self.checklist_items
            if item.is_critical and item.status == "fail"
        ]
        
        if critical_failures and self.quality_check_passed:
            raise ValueError(
                f"Quality check cannot pass with {len(critical_failures)} critical failures"
            )
        
        return self


class CompletionResponse(BaseSchema):
    """
    Maintenance completion response.
    
    Provides summary of completion with cost variance
    and quality status.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    
    # Completion status
    completed: bool = Field(
        ...,
        description="Whether work is marked as completed",
    )
    completed_at: datetime = Field(
        ...,
        description="Completion timestamp",
    )
    completed_by: UUID = Field(
        ...,
        description="User ID who completed",
    )
    completed_by_name: str = Field(
        ...,
        description="Name of person who completed",
    )
    
    # Cost summary
    estimated_cost: Decimal = Field(
        ...,
        ge=0,
        description="Original estimated cost",
    )
    actual_cost: Decimal = Field(
        ...,
        ge=0,
        description="Actual cost incurred",
    )
    cost_variance: Decimal = Field(
        ...,
        description="Cost variance (actual - estimated)",
    )
    cost_variance_percentage: Decimal = Field(
        ...,
        description="Cost variance as percentage",
    )
    within_budget: bool = Field(
        ...,
        description="Whether work was completed within budget",
    )
    
    # Quality status
    quality_checked: bool = Field(
        ...,
        description="Whether quality check was performed",
    )
    quality_check_passed: Optional[bool] = Field(
        None,
        description="Quality check result (if performed)",
    )
    quality_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Quality rating (1-5 stars)",
    )
    
    # Timeline
    actual_completion_date: date = Field(
        ...,
        description="Actual completion date",
    )
    total_days_taken: Optional[int] = Field(
        None,
        ge=0,
        description="Total days from request to completion",
    )
    
    # Response message
    message: str = Field(
        ...,
        description="Human-readable response message",
    )
    
    # Next steps
    follow_up_required: bool = Field(
        default=False,
        description="Whether follow-up is needed",
    )
    warranty_applicable: bool = Field(
        default=False,
        description="Whether warranty applies",
    )

    @field_validator(
        "estimated_cost",
        "actual_cost",
        "cost_variance",
        "cost_variance_percentage",
    )
    @classmethod
    def round_decimals(cls, v: Decimal) -> Decimal:
        """Round decimal values to 2 places."""
        return round(v, 2)


class CompletionCertificate(BaseSchema):
    """
    Work completion certificate.
    
    Formal certificate documenting completed maintenance work
    with all details, parties, and warranties.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    certificate_number: str = Field(
        ...,
        description="Unique certificate number",
    )
    
    # Work details
    work_title: str = Field(
        ...,
        description="Work title/description",
    )
    work_description: str = Field(
        ...,
        description="Detailed work description",
    )
    work_category: str = Field(
        ...,
        description="Work category",
    )
    materials_used: List[MaterialItem] = Field(
        default_factory=list,
        description="Materials used in work",
    )
    labor_hours: Decimal = Field(
        ...,
        ge=0,
        description="Total labor hours",
    )
    
    # Cost summary
    total_cost: Decimal = Field(
        ...,
        ge=0,
        description="Total work cost",
    )
    cost_breakdown: Optional[dict] = Field(
        None,
        description="Detailed cost breakdown",
    )
    
    # Parties involved
    completed_by: str = Field(
        ...,
        description="Person/team who completed work",
    )
    completed_by_designation: Optional[str] = Field(
        None,
        description="Designation of person who completed",
    )
    verified_by: str = Field(
        ...,
        description="Person who verified completion",
    )
    verified_by_designation: Optional[str] = Field(
        None,
        description="Designation of verifier",
    )
    approved_by: str = Field(
        ...,
        description="Person who approved completion",
    )
    approved_by_designation: Optional[str] = Field(
        None,
        description="Designation of approver",
    )
    
    # Dates
    work_start_date: date = Field(
        ...,
        description="Work start date",
    )
    completion_date: date = Field(
        ...,
        description="Work completion date",
    )
    verification_date: date = Field(
        ...,
        description="Verification date",
    )
    certificate_issue_date: date = Field(
        ...,
        description="Certificate issue date",
    )
    
    # Warranty
    warranty_applicable: bool = Field(
        default=False,
        description="Whether warranty applies",
    )
    warranty_period_months: Optional[int] = Field(
        None,
        ge=0,
        le=120,
        description="Warranty period in months",
    )
    warranty_terms: Optional[str] = Field(
        None,
        description="Warranty terms and conditions",
    )
    warranty_valid_until: Optional[date] = Field(
        None,
        description="Warranty expiry date",
    )
    
    # Quality assurance
    quality_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Quality rating",
    )
    quality_remarks: Optional[str] = Field(
        None,
        description="Quality remarks",
    )
    
    # Digital signatures (placeholders)
    completed_by_signature: Optional[str] = Field(
        None,
        description="Completed by signature data",
    )
    verified_by_signature: Optional[str] = Field(
        None,
        description="Verified by signature data",
    )
    approved_by_signature: Optional[str] = Field(
        None,
        description="Approved by signature data",
    )

    @field_validator("total_cost", "labor_hours")
    @classmethod
    def round_decimals(cls, v: Decimal) -> Decimal:
        """Round decimal values."""
        return round(v, 2)

    @model_validator(mode="after")
    def validate_dates_sequence(self) -> "CompletionCertificate":
        """
        Validate dates are in logical sequence.
        
        Start < Completion <= Verification <= Certificate Issue
        """
        if self.work_start_date > self.completion_date:
            raise ValueError("Start date must be before completion date")
        
        if self.completion_date > self.verification_date:
            raise ValueError("Completion date must be before verification date")
        
        if self.verification_date > self.certificate_issue_date:
            raise ValueError("Verification date must be before certificate issue date")
        
        return self

    @model_validator(mode="after")
    def validate_warranty_details(self) -> "CompletionCertificate":
        """
        Validate warranty information.
        
        If warranty applicable, all warranty details should be provided.
        """
        if self.warranty_applicable:
            if not self.warranty_period_months:
                raise ValueError(
                    "Warranty period is required when warranty is applicable"
                )
            
            if not self.warranty_terms:
                raise ValueError(
                    "Warranty terms are required when warranty is applicable"
                )
            
            if not self.warranty_valid_until:
                raise ValueError(
                    "Warranty expiry date is required when warranty is applicable"
                )
        
        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance\maintenance_cost.py ---
# --- File: app/schemas/maintenance/maintenance_cost.py ---
"""
Maintenance cost tracking and budget management schemas.

Provides comprehensive cost tracking, budget allocation, expense reporting,
and vendor invoice management with detailed analytics.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional, Any

from pydantic import Field, field_validator, model_validator,computed_field
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "CostTracking",
    "BudgetAllocation",
    "CategoryBudget",
    "ExpenseReport",
    "MonthlyExpense",
    "ExpenseItem",
    "VendorInvoice",
    "InvoiceLineItem",
    "CostAnalysis",
]


class CostTracking(BaseSchema):
    """
    Cost tracking for maintenance request.
    
    Tracks estimated vs actual costs with variance analysis.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    estimated_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Original estimated cost",
    )
    approved_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Approved budget amount",
    )
    actual_cost: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Actual cost incurred",
    )
    variance: Decimal = Field(
        ...,
        max_digits=10,
        decimal_places=2,
        description="Cost variance (actual - approved)",
    )
    variance_percentage: Decimal = Field(
        ...,
        decimal_places=2,
        description="Variance as percentage of approved",
    )
    within_budget: bool = Field(
        ...,
        description="Whether actual cost is within approved budget",
    )
    materials_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Materials cost component",
    )
    labor_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Labor cost component",
    )
    vendor_charges: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="External vendor charges",
    )
    other_costs: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Other miscellaneous costs",
    )
    tax_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Tax component",
    )

    @field_validator(
        "estimated_cost",
        "approved_cost",
        "actual_cost",
        "variance",
        "variance_percentage",
        "materials_cost",
        "labor_cost",
        "vendor_charges",
        "other_costs",
        "tax_amount",
    )
    @classmethod
    def round_amounts(cls, v: Decimal) -> Decimal:
        """Round monetary amounts to 2 decimal places."""
        return round(v, 2)

    @computed_field
    @property
    def cost_breakdown_total(self) -> Decimal:
        """Calculate total from breakdown components."""
        return round(
            self.materials_cost
            + self.labor_cost
            + self.vendor_charges
            + self.other_costs
            + self.tax_amount,
            2,
        )


class CategoryBudget(BaseSchema):
    """
    Budget allocation for specific maintenance category.
    
    Tracks allocation, spending, and utilization per category.
    """

    category: str = Field(
        ...,
        description="Maintenance category name",
    )
    category_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Category code",
    )
    allocated: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Allocated budget amount",
    )
    spent: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Amount spent",
    )
    committed: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Amount committed (approved but not paid)",
    )
    remaining: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Remaining budget",
    )
    utilization_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Budget utilization percentage",
    )
    request_count: int = Field(
        default=0,
        ge=0,
        description="Number of maintenance requests",
    )
    average_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )

    @field_validator(
        "allocated",
        "spent",
        "committed",
        "remaining",
        "utilization_percentage",
        "average_cost",
    )
    @classmethod
    def round_amounts(cls, v: Decimal) -> Decimal:
        """Round amounts to 2 decimal places."""
        return round(v, 2)

    @computed_field
    @property
    def is_over_budget(self) -> bool:
        """Check if category is over budget."""
        return self.spent > self.allocated

    @computed_field
    @property
    def available_for_commitment(self) -> Decimal:
        """Calculate amount available for new commitments."""
        return round(
            max(Decimal("0.00"), self.allocated - self.spent - self.committed),
            2,
        )


class BudgetAllocation(BaseSchema):
    """
    Overall budget allocation for hostel maintenance.
    
    Tracks fiscal year budget with category-wise breakdown
    and utilization metrics.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    fiscal_year: str = Field(
        ...,
        pattern=r"^\d{4}$",
        description="Fiscal year (YYYY format)",
    )
    fiscal_year_start: date = Field(
        ...,
        description="Fiscal year start date",
    )
    fiscal_year_end: date = Field(
        ...,
        description="Fiscal year end date",
    )
    total_budget: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total allocated budget",
    )
    allocated_budget: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Budget allocated to categories",
    )
    spent_amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total amount spent",
    )
    committed_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Committed but not yet spent",
    )
    remaining_budget: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Remaining unallocated budget",
    )
    utilization_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall budget utilization",
    )
    budget_by_category: Dict[str, CategoryBudget] = Field(
        ...,
        description="Budget breakdown by category",
    )
    reserve_fund: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Emergency reserve fund",
    )
    
    # Forecasting
    projected_annual_spend: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Projected annual spending",
    )
    burn_rate_monthly: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average monthly spending rate",
    )

    @field_validator("fiscal_year_end")
    @classmethod
    def validate_fiscal_year(cls, v: date, info) -> date:
        """Validate fiscal year dates."""
        if "fiscal_year_start" in info.data:
            if v <= info.data["fiscal_year_start"]:
                raise ValueError("Fiscal year end must be after start")
        return v

    @computed_field
    @property
    def is_over_budget(self) -> bool:
        """Check if overall budget is exceeded."""
        return self.spent_amount > self.total_budget

    @computed_field
    @property
    def months_remaining(self) -> int:
        """Calculate months remaining in fiscal year."""
        today = date.today()
        if today > self.fiscal_year_end:
            return 0
        
        months = (
            (self.fiscal_year_end.year - today.year) * 12
            + (self.fiscal_year_end.month - today.month)
        )
        return max(0, months)


class MonthlyExpense(BaseSchema):
    """
    Monthly expense summary.
    
    Aggregates maintenance expenses for a specific month.
    """

    month: str = Field(
        ...,
        pattern=r"^\d{4}-(0[1-9]|1[0-2])$",
        description="Month in YYYY-MM format",
    )
    month_name: str = Field(
        ...,
        description="Month name (January, February, etc.)",
    )
    year: int = Field(
        ...,
        ge=2000,
        le=2100,
        description="Year",
    )
    total_expenses: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total expenses for the month",
    )
    request_count: int = Field(
        ...,
        ge=0,
        description="Number of maintenance requests",
    )
    completed_count: int = Field(
        default=0,
        ge=0,
        description="Number of completed requests",
    )
    average_cost: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )
    budget_allocated: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Budget allocated for the month",
    )
    variance_from_budget: Optional[Decimal] = Field(
        None,
        description="Variance from monthly budget",
    )

    @computed_field
    @property
    def within_budget(self) -> Optional[bool]:
        """Check if monthly expenses are within budget."""
        if self.budget_allocated is None:
            return None
        return self.total_expenses <= self.budget_allocated


class ExpenseItem(BaseSchema):
    """
    Individual expense item in reports.
    
    Represents single maintenance request in expense listings.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    title: str = Field(
        ...,
        description="Request title",
    )
    category: str = Field(
        ...,
        description="Maintenance category",
    )
    priority: str = Field(
        ...,
        description="Priority level",
    )
    estimated_cost: Decimal = Field(
        ...,
        ge=0,
        description="Estimated cost",
    )
    actual_cost: Decimal = Field(
        ...,
        ge=0,
        description="Actual cost incurred",
    )
    cost_variance: Decimal = Field(
        ...,
        description="Cost variance amount",
    )
    completion_date: date = Field(
        ...,
        description="Completion date",
    )
    vendor_name: Optional[str] = Field(
        None,
        description="Vendor name (if applicable)",
    )

    @computed_field
    @property
    def over_budget(self) -> bool:
        """Check if expense was over estimated cost."""
        return self.actual_cost > self.estimated_cost


class ExpenseReport(BaseSchema):
    """
    Comprehensive maintenance expense report.
    
    Provides detailed expense analysis with multiple dimensions
    and top expense listings.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID (if hostel-specific)",
    )
    hostel_name: Optional[str] = Field(
        None,
        description="Hostel name",
    )
    report_period: DateRangeFilter = Field(
        ...,
        description="Report period",
    )
    generated_at: datetime = Field(
        ...,
        description="Report generation timestamp",
    )
    generated_by: Optional[UUID] = Field(
        None,
        description="User who generated report",
    )
    
    # Summary statistics
    total_expenses: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total expenses in period",
    )
    total_requests: int = Field(
        ...,
        ge=0,
        description="Total maintenance requests",
    )
    completed_requests: int = Field(
        ...,
        ge=0,
        description="Completed requests",
    )
    average_cost_per_request: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average cost per request",
    )
    
    # Budget comparison
    total_budget: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Total budget for period",
    )
    budget_utilization: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        description="Budget utilization percentage",
    )
    
    # Breakdown by category
    expenses_by_category: Dict[str, Decimal] = Field(
        ...,
        description="Expenses grouped by category",
    )
    requests_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Request count by category",
    )
    
    # Monthly breakdown
    monthly_expenses: List[MonthlyExpense] = Field(
        ...,
        description="Month-by-month expenses",
    )
    
    # Priority-based breakdown
    expenses_by_priority: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Expenses grouped by priority",
    )
    
    # Top expenses
    top_expensive_requests: List[ExpenseItem] = Field(
        default_factory=list,
        max_length=50,
        description="Highest cost maintenance requests",
    )
    
    # Vendor analysis
    top_vendors_by_spending: Optional[List[Dict[str, Any]]] = Field(
        None,
        max_length=20,
        description="Top vendors by total spending",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate percentage."""
        if self.total_requests == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.completed_requests) / Decimal(self.total_requests) * 100,
            2,
        )


class InvoiceLineItem(BaseSchema):
    """
    Line item in vendor invoice.
    
    Represents individual item/service in invoice.
    """

    line_number: int = Field(
        ...,
        ge=1,
        description="Line item number",
    )
    description: str = Field(
        ...,
        min_length=3,
        max_length=500,
        description="Item/service description",
    )
    item_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Item code/SKU",
    )
    quantity: Decimal = Field(
        ...,
        gt=0,
        max_digits=10,
        decimal_places=3,
        description="Quantity",
    )
    unit: str = Field(
        ...,
        max_length=20,
        description="Unit of measurement",
    )
    unit_price: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Price per unit",
    )
    total_price: Decimal = Field(
        ...,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Total line price",
    )
    tax_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Tax rate percentage",
    )
    tax_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Tax amount",
    )

    @model_validator(mode="after")
    def validate_pricing(self) -> "InvoiceLineItem":
        """
        Validate pricing calculations.
        
        Ensures total_price = quantity  unit_price (pre-tax).
        """
        calculated_total = self.quantity * self.unit_price
        
        # Allow small rounding differences
        if abs(calculated_total - self.total_price) > Decimal("0.01"):
            raise ValueError(
                f"Total price ({self.total_price}) doesn't match "
                f"quantity ({self.quantity})  unit price ({self.unit_price})"
            )
        
        # Validate tax calculation if tax_rate > 0
        if self.tax_rate > 0:
            calculated_tax = self.total_price * self.tax_rate / 100
            if abs(calculated_tax - self.tax_amount) > Decimal("0.01"):
                raise ValueError(
                    f"Tax amount ({self.tax_amount}) doesn't match "
                    f"total price ({self.total_price})  tax rate ({self.tax_rate}%)"
                )
        
        return self


class VendorInvoice(BaseCreateSchema):
    """
    Vendor invoice for maintenance work.
    
    Comprehensive invoice tracking with line items, taxes,
    and payment terms.
    """

    maintenance_id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    vendor_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Vendor company name",
    )
    vendor_id: Optional[UUID] = Field(
        None,
        description="Vendor ID in system (if registered)",
    )
    vendor_address: Optional[str] = Field(
        None,
        max_length=500,
        description="Vendor billing address",
    )
    vendor_tax_id: Optional[str] = Field(
        None,
        max_length=50,
        description="Vendor tax ID/GST number",
    )
    invoice_number: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Vendor invoice number",
    )
    invoice_date: date = Field(
        ...,
        description="Invoice issue date",
    )
    purchase_order_number: Optional[str] = Field(
        None,
        max_length=100,
        description="Our purchase order number",
    )
    line_items: List[InvoiceLineItem] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Invoice line items",
    )
    subtotal: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Subtotal (before tax)",
    )
    tax_amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total tax amount",
    )
    discount_amount: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Discount amount",
    )
    total_amount: Decimal = Field(
        ...,
        ge=0,
        max_digits=12,
        decimal_places=2,
        description="Total invoice amount",
    )
    payment_terms: str = Field(
        ...,
        max_length=200,
        description="Payment terms (e.g., Net 30, Due on receipt)",
    )
    due_date: date = Field(
        ...,
        description="Payment due date",
    )
    currency: str = Field(
        default="INR",
        max_length=3,
        description="Currency code (ISO 4217)",
    )
    invoice_document_url: Optional[str] = Field(
        None,
        description="URL to invoice document/PDF",
    )
    notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional notes",
    )

    @field_validator("invoice_date", "due_date")
    @classmethod
    def validate_dates(cls, v: date) -> date:
        """Validate invoice dates are reasonable."""
        # Invoice date shouldn't be too far in past or future
        days_diff = abs((date.today() - v).days)
        if days_diff > 365:
            raise ValueError(
                "Invoice date cannot be more than 1 year from today"
            )
        return v

    @model_validator(mode="after")
    def validate_invoice_totals(self) -> "VendorInvoice":
        """
        Validate invoice calculations.
        
        Ensures subtotal matches line items and total is calculated correctly.
        """
        # Validate subtotal matches line items
        line_items_total = sum(item.total_price for item in self.line_items)
        
        if abs(line_items_total - self.subtotal) > Decimal("0.01"):
            raise ValueError(
                f"Subtotal ({self.subtotal}) doesn't match sum of line items ({line_items_total})"
            )
        
        # Validate total calculation
        calculated_total = self.subtotal + self.tax_amount - self.discount_amount
        
        if abs(calculated_total - self.total_amount) > Decimal("0.01"):
            raise ValueError(
                f"Total amount ({self.total_amount}) doesn't match "
                f"subtotal ({self.subtotal}) + tax ({self.tax_amount}) - discount ({self.discount_amount})"
            )
        
        # Due date should be on or after invoice date
        if self.due_date < self.invoice_date:
            raise ValueError("Due date cannot be before invoice date")
        
        return self


class CostAnalysis(BaseSchema):
    """
    Cost analysis and trends.
    
    Provides insights into cost patterns, trends, and efficiency metrics.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    analysis_period: DateRangeFilter = Field(
        ...,
        description="Analysis period",
    )
    previous_period: Optional[DateRangeFilter] = Field(
        None,
        description="Previous period for comparison",
    )
    
    # Cost trends
    cost_trend: str = Field(
        ...,
        pattern=r"^(increasing|decreasing|stable)$",
        description="Overall cost trend direction",
    )
    trend_percentage: Decimal = Field(
        ...,
        decimal_places=2,
        description="Trend change percentage",
    )
    
    # Cost drivers
    highest_cost_category: str = Field(
        ...,
        description="Category with highest total cost",
    )
    highest_cost_category_amount: Decimal = Field(
        ...,
        ge=0,
        description="Amount spent in highest cost category",
    )
    most_frequent_category: str = Field(
        ...,
        description="Most frequently occurring category",
    )
    most_frequent_category_count: int = Field(
        ...,
        ge=0,
        description="Request count for most frequent category",
    )
    
    # Efficiency metrics
    cost_per_student: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average maintenance cost per student",
    )
    cost_per_room: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average maintenance cost per room",
    )
    cost_per_sqft: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Cost per square foot",
    )
    
    # Performance benchmarks
    comparison_to_previous_period: Decimal = Field(
        ...,
        decimal_places=2,
        description="Percentage change from previous period",
    )
    comparison_to_budget: Optional[Decimal] = Field(
        None,
        decimal_places=2,
        description="Percentage variance from budget",
    )
    
    # Predictive insights
    projected_annual_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Projected annual cost based on trends",
    )
    seasonal_variation: Optional[Decimal] = Field(
        None,
        description="Seasonal variation coefficient",
    )
    
    # Recommendations
    cost_saving_opportunities: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Identified cost-saving opportunities",
    )
    risk_areas: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Areas of cost risk",
    )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance\maintenance_filters.py ---
# --- File: app/schemas/maintenance/maintenance_filters.py ---
"""
Maintenance filter schemas for querying and exporting.

Provides comprehensive filtering capabilities with validation
for searches, exports, and advanced queries.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import (
    MaintenanceCategory,
    MaintenanceIssueType,
    MaintenanceStatus,
    Priority,
)

__all__ = [
    "MaintenanceFilterParams",
    "SearchRequest",
    "MaintenanceExportRequest",
    "AdvancedFilterParams",
]


class MaintenanceFilterParams(BaseFilterSchema):
    """
    Comprehensive maintenance filter parameters.
    
    Supports multi-dimensional filtering for maintenance requests
    with text search, date ranges, and status filters.
    """

    # Text search
    search: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Search in title, description, request number",
    )
    search_fields: Optional[List[str]] = Field(
        None,
        description="Fields to search in (title, description, notes, etc.)",
    )
    
    # Hostel filters
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by specific hostel",
    )
    hostel_ids: Optional[List[UUID]] = Field(
        None,
        min_length=1,
        max_length=100,
        description="Filter by multiple hostels",
    )
    
    # User filters
    requested_by: Optional[UUID] = Field(
        None,
        description="Filter by requester",
    )
    requested_by_role: Optional[str] = Field(
        None,
        pattern=r"^(student|supervisor|admin)$",
        description="Filter by requester role",
    )
    
    # Assignment filters
    assigned_to: Optional[UUID] = Field(
        None,
        description="Filter by assignee",
    )
    assigned_to_role: Optional[str] = Field(
        None,
        pattern=r"^(staff|vendor|contractor)$",
        description="Filter by assignee role",
    )
    unassigned_only: Optional[bool] = Field(
        None,
        description="Show only unassigned requests",
    )
    
    # Room filters
    room_id: Optional[UUID] = Field(
        None,
        description="Filter by specific room",
    )
    room_ids: Optional[List[UUID]] = Field(
        None,
        min_length=1,
        max_length=100,
        description="Filter by multiple rooms",
    )
    floor: Optional[int] = Field(
        None,
        ge=0,
        le=50,
        description="Filter by floor number",
    )
    
    # Category filters
    category: Optional[MaintenanceCategory] = Field(
        None,
        description="Filter by specific category",
    )
    categories: Optional[List[MaintenanceCategory]] = Field(
        None,
        min_length=1,
        description="Filter by multiple categories",
    )
    exclude_categories: Optional[List[MaintenanceCategory]] = Field(
        None,
        description="Exclude specific categories",
    )
    
    # Priority filters
    priority: Optional[Priority] = Field(
        None,
        description="Filter by specific priority",
    )
    priorities: Optional[List[Priority]] = Field(
        None,
        min_length=1,
        description="Filter by multiple priorities",
    )
    min_priority: Optional[Priority] = Field(
        None,
        description="Minimum priority level (inclusive)",
    )
    
    # Status filters
    status: Optional[MaintenanceStatus] = Field(
        None,
        description="Filter by specific status",
    )
    statuses: Optional[List[MaintenanceStatus]] = Field(
        None,
        min_length=1,
        description="Filter by multiple statuses",
    )
    exclude_statuses: Optional[List[MaintenanceStatus]] = Field(
        None,
        description="Exclude specific statuses",
    )
    
    # Issue type filter
    issue_type: Optional[MaintenanceIssueType] = Field(
        None,
        description="Filter by issue type",
    )
    
    # Date filters
    created_date_from: Optional[date] = Field(
        None,
        description="Filter requests created from this date",
    )
    created_date_to: Optional[date] = Field(
        None,
        description="Filter requests created until this date",
    )
    completion_date_from: Optional[date] = Field(
        None,
        description="Filter by completion date from",
    )
    completion_date_to: Optional[date] = Field(
        None,
        description="Filter by completion date to",
    )
    due_date_from: Optional[date] = Field(
        None,
        description="Filter by due date from",
    )
    due_date_to: Optional[date] = Field(
        None,
        description="Filter by due date to",
    )
    
    # Cost filters
    estimated_cost_min: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Minimum estimated cost",
    )
    estimated_cost_max: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Maximum estimated cost",
    )
    actual_cost_min: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Minimum actual cost",
    )
    actual_cost_max: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Maximum actual cost",
    )
    
    # Special filters
    approval_pending: Optional[bool] = Field(
        None,
        description="Filter requests pending approval",
    )
    overdue_only: Optional[bool] = Field(
        None,
        description="Show only overdue requests",
    )
    is_preventive: Optional[bool] = Field(
        None,
        description="Filter preventive maintenance",
    )
    has_vendor: Optional[bool] = Field(
        None,
        description="Filter requests with vendor assignment",
    )
    quality_checked: Optional[bool] = Field(
        None,
        description="Filter by quality check status",
    )
    within_budget: Optional[bool] = Field(
        None,
        description="Filter requests within approved budget",
    )

    @field_validator("search")
    @classmethod
    def normalize_search(cls, v: Optional[str]) -> Optional[str]:
        """Normalize search query."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @field_validator(
        "estimated_cost_min",
        "estimated_cost_max",
        "actual_cost_min",
        "actual_cost_max",
    )
    @classmethod
    def round_costs(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round cost values to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_filter_consistency(self) -> "MaintenanceFilterParams":
        """
        Validate filter parameter consistency.
        
        Ensures compatible filters are used together and
        no conflicting options are specified.
        """
        # Validate date ranges
        if self.created_date_from and self.created_date_to:
            if self.created_date_to < self.created_date_from:
                raise ValueError(
                    "created_date_to must be after or equal to created_date_from"
                )
        
        if self.completion_date_from and self.completion_date_to:
            if self.completion_date_to < self.completion_date_from:
                raise ValueError(
                    "completion_date_to must be after or equal to completion_date_from"
                )
        
        # Validate cost ranges
        if self.estimated_cost_min and self.estimated_cost_max:
            if self.estimated_cost_max < self.estimated_cost_min:
                raise ValueError(
                    "estimated_cost_max must be greater than or equal to estimated_cost_min"
                )
        
        if self.actual_cost_min and self.actual_cost_max:
            if self.actual_cost_max < self.actual_cost_min:
                raise ValueError(
                    "actual_cost_max must be greater than or equal to actual_cost_min"
                )
        
        # Validate status filters
        if self.status and self.statuses:
            raise ValueError(
                "Cannot use both 'status' and 'statuses' filters"
            )
        
        if self.statuses and self.exclude_statuses:
            overlap = set(self.statuses) & set(self.exclude_statuses)
            if overlap:
                raise ValueError(
                    "Cannot include and exclude the same statuses"
                )
        
        # Validate category filters
        if self.category and self.categories:
            raise ValueError(
                "Cannot use both 'category' and 'categories' filters"
            )
        
        if self.categories and self.exclude_categories:
            overlap = set(self.categories) & set(self.exclude_categories)
            if overlap:
                raise ValueError(
                    "Cannot include and exclude the same categories"
                )
        
        # Validate priority filters
        if self.priority and self.priorities:
            raise ValueError(
                "Cannot use both 'priority' and 'priorities' filters"
            )
        
        # Validate hostel/room filters
        if self.hostel_id and self.hostel_ids:
            raise ValueError(
                "Cannot use both 'hostel_id' and 'hostel_ids' filters"
            )
        
        return self


class SearchRequest(BaseFilterSchema):
    """
    Maintenance search request with full-text capabilities.
    
    Optimized for text-based searches with field-specific targeting.
    """

    query: str = Field(
        ...,
        min_length=1,
        max_length=500,
        description="Search query string",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Limit search to specific hostel",
    )
    search_in_title: bool = Field(
        True,
        description="Search in title field",
    )
    search_in_description: bool = Field(
        True,
        description="Search in description field",
    )
    search_in_number: bool = Field(
        True,
        description="Search in request number",
    )
    search_in_notes: bool = Field(
        False,
        description="Search in notes/comments",
    )
    status: Optional[MaintenanceStatus] = Field(
        None,
        description="Filter by status",
    )
    category: Optional[MaintenanceCategory] = Field(
        None,
        description="Filter by category",
    )
    priority: Optional[Priority] = Field(
        None,
        description="Filter by priority",
    )
    date_from: Optional[date] = Field(
        None,
        description="Search from this date",
    )
    date_to: Optional[date] = Field(
        None,
        description="Search until this date",
    )
    fuzzy_search: bool = Field(
        False,
        description="Enable fuzzy/approximate matching",
    )
    page: int = Field(
        1,
        ge=1,
        description="Page number",
    )
    page_size: int = Field(
        20,
        ge=1,
        le=100,
        description="Results per page",
    )

    @field_validator("query")
    @classmethod
    def normalize_query(cls, v: str) -> str:
        """Normalize search query."""
        v = v.strip()
        
        if len(v) < 1:
            raise ValueError("Search query cannot be empty")
        
        return v

    @model_validator(mode="after")
    def validate_search_fields(self) -> "SearchRequest":
        """
        Validate at least one search field is selected.
        
        Ensures meaningful search configuration.
        """
        if not any([
            self.search_in_title,
            self.search_in_description,
            self.search_in_number,
            self.search_in_notes,
        ]):
            raise ValueError(
                "At least one search field must be enabled"
            )
        
        return self


class AdvancedFilterParams(MaintenanceFilterParams):
    """
    Advanced filter parameters with additional criteria.
    
    Extends basic filters with complex queries and analytics filters.
    """

    # Time-based filters
    created_in_last_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Created in last N days",
    )
    completed_in_last_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Completed in last N days",
    )
    pending_for_days: Optional[int] = Field(
        None,
        ge=1,
        description="Pending for more than N days",
    )
    
    # Performance filters
    completion_time_min_days: Optional[int] = Field(
        None,
        ge=0,
        description="Minimum completion time in days",
    )
    completion_time_max_days: Optional[int] = Field(
        None,
        ge=0,
        description="Maximum completion time in days",
    )
    
    # Quality filters
    quality_rating_min: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Minimum quality rating",
    )
    quality_check_failed: Optional[bool] = Field(
        None,
        description="Filter failed quality checks",
    )
    rework_required: Optional[bool] = Field(
        None,
        description="Filter requests requiring rework",
    )
    
    # Cost variance filters
    over_budget: Optional[bool] = Field(
        None,
        description="Filter requests over budget",
    )
    cost_variance_min_percentage: Optional[Decimal] = Field(
        None,
        description="Minimum cost variance percentage",
    )
    cost_variance_max_percentage: Optional[Decimal] = Field(
        None,
        description="Maximum cost variance percentage",
    )
    
    # Vendor filters
    vendor_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Filter by vendor name (partial match)",
    )
    vendor_id: Optional[UUID] = Field(
        None,
        description="Filter by vendor ID",
    )
    
    # Warranty filters
    has_warranty: Optional[bool] = Field(
        None,
        description="Filter by warranty applicability",
    )
    warranty_active: Optional[bool] = Field(
        None,
        description="Filter by active warranty status",
    )
    
    # Grouping for analytics
    group_by: Optional[str] = Field(
        None,
        pattern=r"^(category|priority|status|month|assignee|vendor)$",
        description="Group results by field",
    )
    
    # Sorting
    sort_by: str = Field(
        "created_at",
        pattern=r"^(created_at|priority|estimated_cost|actual_cost|completion_date|status)$",
        description="Sort results by field",
    )
    sort_order: str = Field(
        "desc",
        pattern=r"^(asc|desc)$",
        description="Sort order",
    )

    @field_validator("vendor_name")
    @classmethod
    def normalize_vendor_name(cls, v: Optional[str]) -> Optional[str]:
        """Normalize vendor name."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_advanced_filters(self) -> "AdvancedFilterParams":
        """Validate advanced filter combinations."""
        # Validate completion time range
        if self.completion_time_min_days and self.completion_time_max_days:
            if self.completion_time_max_days < self.completion_time_min_days:
                raise ValueError(
                    "completion_time_max_days must be >= completion_time_min_days"
                )
        
        return self


class MaintenanceExportRequest(BaseFilterSchema):
    """
    Export maintenance data with format and options.
    
    Supports multiple export formats with customizable content
    and field selection.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Export data for specific hostel",
    )
    filters: Optional[MaintenanceFilterParams] = Field(
        None,
        description="Apply filters to export",
    )
    format: str = Field(
        "csv",
        pattern=r"^(csv|excel|pdf|json)$",
        description="Export format",
    )
    
    # Content options
    include_cost_details: bool = Field(
        True,
        description="Include cost breakdown",
    )
    include_assignment_details: bool = Field(
        True,
        description="Include assignment information",
    )
    include_completion_details: bool = Field(
        True,
        description="Include completion details",
    )
    include_quality_check: bool = Field(
        False,
        description="Include quality check results",
    )
    include_materials: bool = Field(
        False,
        description="Include materials used",
    )
    include_photos: bool = Field(
        False,
        description="Include photo URLs",
    )
    include_vendor_details: bool = Field(
        False,
        description="Include vendor information",
    )
    include_notes: bool = Field(
        False,
        description="Include notes and comments",
    )
    
    # Field selection
    selected_fields: Optional[List[str]] = Field(
        None,
        max_length=50,
        description="Specific fields to include (overrides include_* options)",
    )
    
    # Grouping and summary
    include_summary: bool = Field(
        True,
        description="Include summary statistics",
    )
    include_charts: bool = Field(
        False,
        description="Include charts/graphs (PDF only)",
    )
    group_by: Optional[str] = Field(
        None,
        pattern=r"^(category|priority|status|month|assignee)$",
        description="Group export by field",
    )
    
    # Sorting
    sort_by: str = Field(
        "created_at",
        description="Sort export by field",
    )
    sort_order: str = Field(
        "desc",
        pattern=r"^(asc|desc)$",
        description="Sort order",
    )
    
    # Output options
    file_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Custom filename (without extension)",
    )
    include_timestamp: bool = Field(
        True,
        description="Include timestamp in filename",
    )
    compress: bool = Field(
        False,
        description="Compress export file (zip)",
    )
    
    # Date range for export
    date_from: Optional[date] = Field(
        None,
        description="Export data from this date",
    )
    date_to: Optional[date] = Field(
        None,
        description="Export data until this date",
    )
    
    # Limits
    max_records: int = Field(
        10000,
        ge=1,
        le=100000,
        description="Maximum records to export",
    )

    @field_validator("file_name")
    @classmethod
    def validate_filename(cls, v: Optional[str]) -> Optional[str]:
        """Validate and sanitize filename."""
        if v is not None:
            import re
            # Remove invalid characters
            v = re.sub(r'[<>:"/\\|?*]', '', v)
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_export_config(self) -> "MaintenanceExportRequest":
        """
        Validate export configuration.
        
        Ensures valid combinations and format-specific requirements.
        """
        # PDF-specific validations
        if self.format == "pdf":
            if self.max_records > 5000:
                raise ValueError(
                    "PDF exports are limited to 5000 records"
                )
            
            if self.include_charts and not self.include_summary:
                raise ValueError(
                    "Charts require summary to be included"
                )
        
        # JSON format validations
        if self.format == "json":
            if self.include_charts:
                raise ValueError(
                    "Charts are not supported in JSON format"
                )
        
        # Validate date range
        if self.date_from and self.date_to:
            if self.date_to < self.date_from:
                raise ValueError(
                    "date_to must be after or equal to date_from"
                )
            
            # Warn for large date ranges
            days_diff = (self.date_to - self.date_from).days
            if days_diff > 365 and self.format == "pdf":
                raise ValueError(
                    "PDF exports cannot exceed 365 days of data"
                )
        
        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance\maintenance_request.py ---
# --- File: app/schemas/maintenance/maintenance_request.py ---
"""
Maintenance request submission schemas.

Provides schemas for different types of maintenance requests including
standard, detailed supervisor submissions, and emergency requests.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, HttpUrl, field_validator, model_validator
from uuid import UUID

from app.schemas.common.base import BaseCreateSchema
from app.schemas.common.enums import MaintenanceCategory, Priority

__all__ = [
    "MaintenanceRequest",
    "RequestSubmission",
    "EmergencyRequest",
]


class MaintenanceRequest(BaseCreateSchema):
    """
    Standard maintenance request submission.
    
    Simplified schema for students/residents to submit maintenance
    issues with essential information.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Room where issue exists",
    )
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Brief issue summary",
    )
    description: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed issue description",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Issue category",
    )
    priority: Priority = Field(
        Priority.MEDIUM,
        description="Requested priority (may be adjusted by supervisor)",
    )
    location: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional location details",
    )
    issue_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="Issue photographs",
    )
    preferred_time_slot: Optional[str] = Field(
        None,
        pattern=r"^(morning|afternoon|evening|any)$",
        description="Preferred time for repair work",
    )
    contact_number: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact number for follow-up",
    )

    @field_validator("title", "description")
    @classmethod
    def validate_text_fields(cls, v: str) -> str:
        """Validate text fields are meaningful."""
        v = v.strip()
        
        field_name = cls.model_fields.get("title") or cls.model_fields.get("description")
        min_length = 5 if field_name == "title" else 20
        
        if len(v) < min_length:
            raise ValueError(f"Field must be at least {min_length} characters")
        
        # Check for meaningful content
        min_unique_chars = 3 if min_length == 5 else 10
        if len(set(v.lower().replace(" ", ""))) < min_unique_chars:
            raise ValueError("Please provide meaningful and descriptive text")
        
        return v

    @field_validator("contact_number")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone number."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return None

    @field_validator("location")
    @classmethod
    def normalize_location(cls, v: Optional[str]) -> Optional[str]:
        """Normalize location field."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None


class RequestSubmission(BaseCreateSchema):
    """
    Detailed maintenance request submission by supervisor.
    
    Enhanced schema with cost estimation, vendor preferences,
    and timeline planning capabilities.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Room where issue exists",
    )
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Issue title",
    )
    description: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed description",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Maintenance category",
    )
    priority: Priority = Field(
        ...,
        description="Issue priority",
    )
    location: Optional[str] = Field(
        None,
        max_length=500,
        description="Location details",
    )
    issue_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=10,
        description="Issue photographs",
    )

    # Supervisor-specific fields
    estimated_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Estimated repair cost",
    )
    cost_justification: Optional[str] = Field(
        None,
        max_length=500,
        description="Justification for estimated cost",
    )
    preferred_vendor: Optional[str] = Field(
        None,
        max_length=255,
        description="Preferred vendor/contractor name",
    )
    vendor_contact: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Vendor contact number",
    )
    estimated_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Estimated days to complete work",
    )
    requires_immediate_attention: bool = Field(
        False,
        description="Flag for urgent/emergency issues",
    )
    approval_required: bool = Field(
        False,
        description="Whether admin approval is required",
    )
    materials_needed: Optional[str] = Field(
        None,
        max_length=1000,
        description="List of materials/parts needed",
    )

    @field_validator("estimated_cost")
    @classmethod
    def round_cost(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round cost to 2 decimal places."""
        return round(v, 2) if v is not None else None

    @field_validator("vendor_contact")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize vendor phone number."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return None

    @field_validator("cost_justification", "materials_needed")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_vendor_information(self) -> "RequestSubmission":
        """
        Validate vendor information completeness.
        
        If vendor is specified, contact should be provided.
        """
        if self.preferred_vendor and not self.vendor_contact:
            raise ValueError(
                "Vendor contact is required when preferred vendor is specified"
            )
        
        return self

    @model_validator(mode="after")
    def validate_cost_information(self) -> "RequestSubmission":
        """
        Validate cost estimation requirements.
        
        High-cost estimates should have justification.
        """
        if self.estimated_cost is not None:
            # Cost above threshold requires justification
            if self.estimated_cost > Decimal("5000.00"):
                if not self.cost_justification:
                    raise ValueError(
                        "Cost justification required for estimates above 5000"
                    )
                
                if len(self.cost_justification.strip()) < 20:
                    raise ValueError(
                        "Cost justification must be at least 20 characters"
                    )
        
        return self

    @model_validator(mode="after")
    def validate_urgency_consistency(self) -> "RequestSubmission":
        """
        Validate urgency and priority consistency.
        
        Immediate attention requests should have high priority.
        """
        if self.requires_immediate_attention:
            if self.priority not in [Priority.HIGH, Priority.URGENT, Priority.CRITICAL]:
                raise ValueError(
                    "Requests requiring immediate attention must have HIGH, "
                    "URGENT, or CRITICAL priority"
                )
        
        return self


class EmergencyRequest(BaseCreateSchema):
    """
    Emergency maintenance request with safety protocols.
    
    Handles critical situations requiring immediate response
    with safety tracking and authority notification.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    emergency_type: str = Field(
        ...,
        pattern=r"^(fire|flood|electrical_hazard|gas_leak|structural_damage|lift_malfunction|other)$",
        description="Type of emergency",
    )
    description: str = Field(
        ...,
        min_length=20,
        max_length=2000,
        description="Detailed emergency description",
    )
    location: str = Field(
        ...,
        min_length=5,
        max_length=500,
        description="Exact emergency location",
    )
    affected_area: Optional[str] = Field(
        None,
        max_length=500,
        description="Area/rooms affected by emergency",
    )

    # Safety information
    immediate_actions_taken: Optional[str] = Field(
        None,
        max_length=1000,
        description="Immediate actions already taken",
    )
    evacuated: bool = Field(
        False,
        description="Whether area has been evacuated",
    )
    evacuation_details: Optional[str] = Field(
        None,
        max_length=500,
        description="Evacuation details if applicable",
    )
    authorities_notified: bool = Field(
        False,
        description="Whether emergency services have been notified",
    )
    authority_details: Optional[str] = Field(
        None,
        max_length=500,
        description="Details of authorities notified",
    )

    # Contact information
    contact_person: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="On-site contact person name",
    )
    contact_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact person phone number",
    )
    alternate_contact: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Alternate contact number",
    )

    # Severity assessment
    injuries_reported: bool = Field(
        default=False,
        description="Whether there are any injuries",
    )
    injury_details: Optional[str] = Field(
        None,
        max_length=500,
        description="Details of injuries if any",
    )
    property_damage_estimated: Optional[str] = Field(
        None,
        pattern=r"^(minor|moderate|major|severe|catastrophic)$",
        description="Estimated property damage level",
    )

    # Supporting evidence
    emergency_photos: List[HttpUrl] = Field(
        default_factory=list,
        max_length=15,
        description="Emergency situation photographs",
    )

    @field_validator("description", "location")
    @classmethod
    def validate_required_text(cls, v: str) -> str:
        """Validate required text fields."""
        v = v.strip()
        
        if len(v) < 20:
            raise ValueError("Emergency details must be comprehensive (min 20 chars)")
        
        return v

    @field_validator("contact_phone", "alternate_contact")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone numbers."""
        if v is not None:
            return v.replace(" ", "").replace("-", "").strip()
        return None

    @field_validator(
        "immediate_actions_taken",
        "evacuation_details",
        "authority_details",
        "injury_details",
    )
    @classmethod
    def normalize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Normalize optional text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_evacuation_consistency(self) -> "EmergencyRequest":
        """
        Validate evacuation information consistency.
        
        If evacuated, details should be provided.
        """
        if self.evacuated and not self.evacuation_details:
            raise ValueError(
                "Evacuation details are required when area has been evacuated"
            )
        
        return self

    @model_validator(mode="after")
    def validate_injury_reporting(self) -> "EmergencyRequest":
        """
        Validate injury reporting requirements.
        
        If injuries reported, details must be provided.
        """
        if self.injuries_reported and not self.injury_details:
            raise ValueError(
                "Injury details are required when injuries are reported"
            )
        
        return self

    @model_validator(mode="after")
    def validate_authority_notification(self) -> "EmergencyRequest":
        """
        Validate authority notification for serious emergencies.
        
        Certain emergency types should have authorities notified.
        """
        serious_emergencies = {"fire", "gas_leak", "structural_damage"}
        
        if self.emergency_type in serious_emergencies:
            if not self.authorities_notified:
                raise ValueError(
                    f"{self.emergency_type} emergencies should have authorities notified. "
                    "If not yet notified, please notify immediately."
                )
            
            if not self.authority_details:
                raise ValueError(
                    "Authority notification details are required for serious emergencies"
                )
        
        return self

    @model_validator(mode="after")
    def validate_safety_actions(self) -> "EmergencyRequest":
        """
        Validate safety action documentation.
        
        Emergency requests should document immediate actions.
        """
        dangerous_types = {"fire", "gas_leak", "electrical_hazard"}
        
        if self.emergency_type in dangerous_types:
            if not self.immediate_actions_taken:
                raise ValueError(
                    f"Immediate actions taken must be documented for {self.emergency_type}"
                )
        
        return self

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance\maintenance_response.py ---
# --- File: app/schemas/maintenance/maintenance_response.py ---
"""
Maintenance response schemas for API responses.

Provides various response formats for maintenance data including
detailed, summary, and list views with computed fields.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, computed_field
from uuid import UUID

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import (
    MaintenanceCategory,
    MaintenanceIssueType,
    MaintenanceStatus,
    Priority,
)

__all__ = [
    "MaintenanceResponse",
    "MaintenanceDetail",
    "RequestListItem",
    "MaintenanceSummary",
]


class MaintenanceResponse(BaseResponseSchema):
    """
    Standard maintenance response with essential information.
    
    Lightweight response schema for list views and basic queries.
    """

    request_number: str = Field(
        ...,
        description="Human-readable request number",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    requested_by: UUID = Field(
        ...,
        description="Requester user ID",
    )
    requested_by_name: str = Field(
        ...,
        description="Requester full name",
    )
    title: str = Field(
        ...,
        description="Issue title",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Maintenance category",
    )
    priority: Priority = Field(
        ...,
        description="Issue priority",
    )
    status: MaintenanceStatus = Field(
        ...,
        description="Current status",
    )
    assigned_to: Optional[UUID] = Field(
        None,
        description="Assignee user ID",
    )
    assigned_to_name: Optional[str] = Field(
        None,
        description="Assignee name",
    )
    estimated_cost: Optional[Decimal] = Field(
        None,
        description="Estimated cost",
    )
    actual_cost: Optional[Decimal] = Field(
        None,
        description="Actual cost",
    )
    created_at: datetime = Field(
        ...,
        description="Request creation timestamp",
    )
    estimated_completion_date: Optional[date] = Field(
        None,
        description="Estimated completion date",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="Completion timestamp",
    )

    @computed_field
    @property
    def status_display(self) -> str:
        """Human-readable status display."""
        status_map = {
            MaintenanceStatus.PENDING: "Pending",
            MaintenanceStatus.APPROVED: "Approved",
            MaintenanceStatus.ASSIGNED: "Assigned",
            MaintenanceStatus.IN_PROGRESS: "In Progress",
            MaintenanceStatus.ON_HOLD: "On Hold",
            MaintenanceStatus.COMPLETED: "Completed",
            MaintenanceStatus.REJECTED: "Rejected",
            MaintenanceStatus.CANCELLED: "Cancelled",
        }
        return status_map.get(self.status, self.status.value)

    @computed_field
    @property
    def priority_display(self) -> str:
        """Human-readable priority display."""
        priority_map = {
            Priority.LOW: "Low",
            Priority.MEDIUM: "Medium",
            Priority.HIGH: "High",
            Priority.URGENT: "Urgent",
            Priority.CRITICAL: "Critical",
        }
        return priority_map.get(self.priority, self.priority.value)

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if request is overdue."""
        if not self.estimated_completion_date:
            return False
        
        if self.status == MaintenanceStatus.COMPLETED:
            return False
        
        return self.estimated_completion_date < date.today()

    @computed_field
    @property
    def days_since_creation(self) -> int:
        """Calculate days since request was created."""
        return (datetime.now() - self.created_at).days


class MaintenanceDetail(BaseResponseSchema):
    """
    Detailed maintenance information with complete metadata.
    
    Comprehensive response including all maintenance details, workflow,
    and supporting information.
    """

    request_number: str = Field(
        ...,
        description="Request number",
    )
    
    # Hostel information
    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    
    # Requester information
    requested_by: UUID = Field(
        ...,
        description="Requester user ID",
    )
    requested_by_name: str = Field(
        ...,
        description="Requester full name",
    )
    requested_by_email: Optional[str] = Field(
        None,
        description="Requester email",
    )
    requested_by_phone: Optional[str] = Field(
        None,
        description="Requester phone",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Room ID",
    )
    room_number: Optional[str] = Field(
        None,
        description="Room number",
    )
    
    # Request details
    title: str = Field(
        ...,
        description="Issue title",
    )
    description: str = Field(
        ...,
        description="Detailed description",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Maintenance category",
    )
    priority: Priority = Field(
        ...,
        description="Priority level",
    )
    issue_type: MaintenanceIssueType = Field(
        ...,
        description="Issue type",
    )
    
    # Location details
    location: Optional[str] = Field(
        None,
        description="Location details",
    )
    floor: Optional[int] = Field(
        None,
        description="Floor number",
    )
    specific_area: Optional[str] = Field(
        None,
        description="Specific area",
    )
    
    # Photos and documents
    issue_photos: List[str] = Field(
        default_factory=list,
        description="Issue photographs",
    )
    completion_photos: List[str] = Field(
        default_factory=list,
        description="Completion photographs",
    )
    
    # Assignment information
    assigned_to: Optional[UUID] = Field(
        None,
        description="Assignee user ID",
    )
    assigned_to_name: Optional[str] = Field(
        None,
        description="Assignee name",
    )
    assigned_to_role: Optional[str] = Field(
        None,
        description="Assignee role",
    )
    assigned_by: Optional[UUID] = Field(
        None,
        description="Assignor user ID",
    )
    assigned_by_name: Optional[str] = Field(
        None,
        description="Assignor name",
    )
    assigned_at: Optional[datetime] = Field(
        None,
        description="Assignment timestamp",
    )
    
    # Vendor information (if applicable)
    vendor_name: Optional[str] = Field(
        None,
        description="Vendor company name",
    )
    vendor_contact: Optional[str] = Field(
        None,
        description="Vendor contact number",
    )
    vendor_email: Optional[str] = Field(
        None,
        description="Vendor email",
    )
    
    # Status workflow
    status: MaintenanceStatus = Field(
        ...,
        description="Current status",
    )
    status_history: Optional[List[dict]] = Field(
        None,
        description="Status change history",
    )
    
    # Approval workflow
    requires_approval: bool = Field(
        default=False,
        description="Whether approval is required",
    )
    approval_pending: bool = Field(
        default=False,
        description="Whether approval is pending",
    )
    approved_by: Optional[UUID] = Field(
        None,
        description="Approver user ID",
    )
    approved_by_name: Optional[str] = Field(
        None,
        description="Approver name",
    )
    approved_at: Optional[datetime] = Field(
        None,
        description="Approval timestamp",
    )
    rejected_by: Optional[UUID] = Field(
        None,
        description="Rejector user ID",
    )
    rejected_at: Optional[datetime] = Field(
        None,
        description="Rejection timestamp",
    )
    rejection_reason: Optional[str] = Field(
        None,
        description="Rejection reason",
    )
    
    # Timeline
    started_at: Optional[datetime] = Field(
        None,
        description="Work start timestamp",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="Completion timestamp",
    )
    
    # Cost tracking
    estimated_cost: Optional[Decimal] = Field(
        None,
        description="Estimated cost",
    )
    actual_cost: Optional[Decimal] = Field(
        None,
        description="Actual cost incurred",
    )
    cost_approved: bool = Field(
        default=False,
        description="Whether cost was approved",
    )
    approval_threshold_exceeded: bool = Field(
        default=False,
        description="Whether cost exceeded approval threshold",
    )
    
    # Timeline estimates
    estimated_completion_date: Optional[date] = Field(
        None,
        description="Estimated completion date",
    )
    actual_completion_date: Optional[date] = Field(
        None,
        description="Actual completion date",
    )
    deadline: Optional[date] = Field(
        None,
        description="Completion deadline",
    )
    
    # Work details
    work_notes: Optional[str] = Field(
        None,
        description="Work performed notes",
    )
    materials_used: List[dict] = Field(
        default_factory=list,
        description="Materials used in work",
    )
    labor_hours: Optional[Decimal] = Field(
        None,
        description="Labor hours spent",
    )
    
    # Quality check
    quality_checked: bool = Field(
        default=False,
        description="Whether quality check was performed",
    )
    quality_checked_by: Optional[UUID] = Field(
        None,
        description="Quality checker user ID",
    )
    quality_check_passed: Optional[bool] = Field(
        None,
        description="Quality check result",
    )
    quality_check_notes: Optional[str] = Field(
        None,
        description="Quality check notes",
    )
    quality_checked_at: Optional[datetime] = Field(
        None,
        description="Quality check timestamp",
    )
    quality_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Quality rating (1-5 stars)",
    )
    
    # Preventive maintenance
    is_preventive: bool = Field(
        default=False,
        description="Whether this is preventive maintenance",
    )
    preventive_schedule_id: Optional[UUID] = Field(
        None,
        description="Related preventive schedule ID",
    )
    next_scheduled_date: Optional[date] = Field(
        None,
        description="Next scheduled maintenance date",
    )
    recurrence: Optional[str] = Field(
        None,
        description="Recurrence pattern",
    )
    
    # Warranty
    warranty_applicable: bool = Field(
        default=False,
        description="Whether warranty applies",
    )
    warranty_period_months: Optional[int] = Field(
        None,
        description="Warranty period in months",
    )
    warranty_expiry_date: Optional[date] = Field(
        None,
        description="Warranty expiry date",
    )

    @computed_field
    @property
    def is_completed(self) -> bool:
        """Check if maintenance is completed."""
        return self.status == MaintenanceStatus.COMPLETED

    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if maintenance is currently active/in-progress."""
        active_statuses = {
            MaintenanceStatus.ASSIGNED,
            MaintenanceStatus.IN_PROGRESS,
        }
        return self.status in active_statuses

    @computed_field
    @property
    def cost_variance(self) -> Optional[Decimal]:
        """Calculate cost variance if both costs available."""
        if self.estimated_cost and self.actual_cost:
            return round(self.actual_cost - self.estimated_cost, 2)
        return None

    @computed_field
    @property
    def cost_variance_percentage(self) -> Optional[Decimal]:
        """Calculate cost variance percentage."""
        if self.estimated_cost and self.actual_cost and self.estimated_cost > 0:
            variance_pct = (
                (self.actual_cost - self.estimated_cost) / self.estimated_cost * 100
            )
            return round(variance_pct, 2)
        return None

    @computed_field
    @property
    def time_to_complete_days(self) -> Optional[int]:
        """Calculate total days from creation to completion."""
        if self.completed_at:
            return (self.completed_at - self.created_at).days
        return None


class RequestListItem(BaseSchema):
    """
    Minimal maintenance list item for efficient list rendering.
    
    Optimized for pagination and list views with minimal data transfer.
    """

    id: UUID = Field(
        ...,
        description="Maintenance request unique identifier",
    )
    request_number: str = Field(
        ...,
        description="Request number",
    )
    title: str = Field(
        ...,
        description="Issue title",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Category",
    )
    priority: Priority = Field(
        ...,
        description="Priority",
    )
    status: MaintenanceStatus = Field(
        ...,
        description="Status",
    )
    room_number: Optional[str] = Field(
        None,
        description="Room number",
    )
    estimated_cost: Optional[Decimal] = Field(
        None,
        description="Estimated cost",
    )
    assigned_to_name: Optional[str] = Field(
        None,
        description="Assignee name",
    )
    created_at: datetime = Field(
        ...,
        description="Creation timestamp",
    )
    estimated_completion_date: Optional[date] = Field(
        None,
        description="Estimated completion",
    )

    @computed_field
    @property
    def status_badge_color(self) -> str:
        """Get color code for status badge (for UI rendering)."""
        color_map = {
            MaintenanceStatus.PENDING: "yellow",
            MaintenanceStatus.APPROVED: "blue",
            MaintenanceStatus.ASSIGNED: "cyan",
            MaintenanceStatus.IN_PROGRESS: "orange",
            MaintenanceStatus.ON_HOLD: "gray",
            MaintenanceStatus.COMPLETED: "green",
            MaintenanceStatus.REJECTED: "red",
            MaintenanceStatus.CANCELLED: "gray",
        }
        return color_map.get(self.status, "gray")

    @computed_field
    @property
    def priority_badge_color(self) -> str:
        """Get color code for priority badge."""
        color_map = {
            Priority.LOW: "green",
            Priority.MEDIUM: "yellow",
            Priority.HIGH: "orange",
            Priority.URGENT: "red",
            Priority.CRITICAL: "purple",
        }
        return color_map.get(self.priority, "gray")

    @computed_field
    @property
    def is_urgent(self) -> bool:
        """Check if request is urgent or critical."""
        return self.priority in [Priority.URGENT, Priority.CRITICAL]


class MaintenanceSummary(BaseSchema):
    """
    Maintenance summary statistics for hostel dashboard.
    
    Provides aggregated metrics for monitoring and reporting.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    period_start: Optional[date] = Field(
        None,
        description="Summary period start",
    )
    period_end: Optional[date] = Field(
        None,
        description="Summary period end",
    )
    
    # Request counts by status
    total_requests: int = Field(
        ...,
        ge=0,
        description="Total maintenance requests",
    )
    pending_requests: int = Field(
        ...,
        ge=0,
        description="Pending requests",
    )
    in_progress_requests: int = Field(
        ...,
        ge=0,
        description="In-progress requests",
    )
    completed_requests: int = Field(
        ...,
        ge=0,
        description="Completed requests",
    )
    on_hold_requests: int = Field(
        default=0,
        ge=0,
        description="On-hold requests",
    )
    cancelled_requests: int = Field(
        default=0,
        ge=0,
        description="Cancelled requests",
    )
    
    # Priority breakdown
    high_priority_count: int = Field(
        ...,
        ge=0,
        description="High priority requests",
    )
    urgent_priority_count: int = Field(
        ...,
        ge=0,
        description="Urgent priority requests",
    )
    critical_priority_count: int = Field(
        default=0,
        ge=0,
        description="Critical priority requests",
    )
    
    # Cost summary
    total_estimated_cost: Decimal = Field(
        ...,
        ge=0,
        description="Total estimated costs",
    )
    total_actual_cost: Decimal = Field(
        ...,
        ge=0,
        description="Total actual costs",
    )
    average_cost_per_request: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average cost per request",
    )
    
    # Performance metrics
    average_completion_time_hours: Decimal = Field(
        ...,
        ge=0,
        description="Average completion time in hours",
    )
    average_completion_time_days: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average completion time in days",
    )
    on_time_completion_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Percentage completed on time",
    )
    
    # Quality metrics
    quality_check_pass_rate: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        le=100,
        description="Quality check pass rate",
    )
    average_quality_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average quality rating",
    )
    
    # Category breakdown
    requests_by_category: Optional[dict] = Field(
        None,
        description="Request count by category",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate percentage."""
        if self.total_requests == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.completed_requests) / Decimal(self.total_requests) * 100,
            2,
        )

    @computed_field
    @property
    def cost_variance_total(self) -> Decimal:
        """Calculate total cost variance."""
        return round(self.total_actual_cost - self.total_estimated_cost, 2)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance\maintenance_schedule.py ---
# --- File: app/schemas/maintenance/maintenance_schedule.py ---
"""
Preventive maintenance schedule schemas.

Provides schemas for scheduled preventive maintenance with recurrence,
execution tracking, and checklist management.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import Field, field_validator, model_validator,computed_field
from uuid import UUID

from app.schemas.common.base import (
    BaseCreateSchema,
    BaseResponseSchema,
    BaseSchema,
    BaseUpdateSchema,
)
from app.schemas.common.enums import MaintenanceCategory, MaintenanceRecurrence

__all__ = [
    "PreventiveSchedule",
    "ScheduleCreate",
    "ScheduleChecklistItem",
    "RecurrenceConfig",
    "ScheduleExecution",
    "ChecklistResult",
    "ScheduleUpdate",
    "ScheduleHistory",
    "ExecutionHistoryItem",
]


class ScheduleChecklistItem(BaseSchema):
    """
    Checklist item for scheduled maintenance task.
    
    Defines specific checks to be performed during maintenance.
    """

    item_id: Optional[str] = Field(
        None,
        max_length=50,
        description="Unique item identifier",
    )
    item_description: str = Field(
        ...,
        min_length=5,
        max_length=500,
        description="Description of check/task to perform",
    )
    category: Optional[str] = Field(
        None,
        max_length=100,
        description="Item category",
    )
    is_required: bool = Field(
        True,
        description="Whether this item is mandatory",
    )
    is_critical: bool = Field(
        default=False,
        description="Whether this is a critical safety check",
    )
    item_order: int = Field(
        ...,
        ge=1,
        le=1000,
        description="Display order in checklist",
    )
    estimated_time_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Estimated time for this item in minutes",
    )
    instructions: Optional[str] = Field(
        None,
        max_length=1000,
        description="Detailed instructions for this check",
    )

    @field_validator("item_description", "instructions")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None


class PreventiveSchedule(BaseResponseSchema):
    """
    Preventive maintenance schedule.
    
    Defines recurring maintenance tasks with scheduling
    and assignment information.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    schedule_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Schedule code/reference",
    )
    title: str = Field(
        ...,
        description="Schedule title",
    )
    description: Optional[str] = Field(
        None,
        description="Schedule description",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Maintenance category",
    )
    recurrence: MaintenanceRecurrence = Field(
        ...,
        description="Recurrence pattern",
    )
    next_due_date: date = Field(
        ...,
        description="Next scheduled execution date",
    )
    last_execution_date: Optional[date] = Field(
        None,
        description="Last execution date",
    )
    assigned_to: Optional[UUID] = Field(
        None,
        description="Default assignee user ID",
    )
    assigned_to_name: Optional[str] = Field(
        None,
        description="Default assignee name",
    )
    estimated_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Estimated cost per execution",
    )
    estimated_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Estimated duration in hours",
    )
    is_active: bool = Field(
        True,
        description="Whether schedule is active",
    )
    total_executions: int = Field(
        default=0,
        ge=0,
        description="Total times executed",
    )
    last_completed_date: Optional[date] = Field(
        None,
        description="Last successful completion date",
    )
    priority_level: Optional[str] = Field(
        None,
        pattern=r"^(low|medium|high)$",
        description="Default priority level",
    )

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if schedule is overdue."""
        return self.next_due_date < date.today()

    @computed_field
    @property
    def days_until_due(self) -> int:
        """Calculate days until next due date."""
        return (self.next_due_date - date.today()).days


class ScheduleCreate(BaseCreateSchema):
    """
    Create preventive maintenance schedule.
    
    Defines new recurring maintenance with checklist and recurrence rules.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel unique identifier",
    )
    schedule_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Schedule code/reference",
    )
    title: str = Field(
        ...,
        min_length=5,
        max_length=255,
        description="Schedule title",
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Detailed description",
    )
    category: MaintenanceCategory = Field(
        ...,
        description="Maintenance category",
    )
    recurrence: MaintenanceRecurrence = Field(
        ...,
        description="Recurrence pattern",
    )
    start_date: date = Field(
        ...,
        description="First scheduled date",
    )
    end_date: Optional[date] = Field(
        None,
        description="Last scheduled date (optional)",
    )
    assigned_to: Optional[UUID] = Field(
        None,
        description="Default assignee",
    )
    estimated_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Estimated cost per execution",
    )
    estimated_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        decimal_places=2,
        description="Estimated duration in hours",
    )
    checklist: List[ScheduleChecklistItem] = Field(
        default_factory=list,
        max_length=100,
        description="Maintenance checklist items",
    )
    auto_create_requests: bool = Field(
        default=True,
        description="Auto-create maintenance requests on due date",
    )
    notification_days_before: int = Field(
        default=3,
        ge=0,
        le=30,
        description="Days before due date to send notification",
    )
    priority_level: Optional[str] = Field(
        None,
        pattern=r"^(low|medium|high)$",
        description="Default priority level",
    )

    @field_validator("start_date")
    @classmethod
    def validate_start_date(cls, v: date) -> date:
        """Validate start date is reasonable."""
        # Can't be too far in past
        days_past = (date.today() - v).days
        if days_past > 365:
            raise ValueError(
                "Start date cannot be more than 1 year in the past"
            )
        
        return v

    @field_validator("title", "description")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @field_validator("estimated_cost", "estimated_duration_hours")
    @classmethod
    def round_decimals(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round decimal values."""
        return round(v, 2) if v is not None else None

    @model_validator(mode="after")
    def validate_date_range(self) -> "ScheduleCreate":
        """
        Validate schedule date range.
        
        End date should be after start date if provided.
        """
        if self.end_date:
            if self.end_date <= self.start_date:
                raise ValueError("End date must be after start date")
            
            # Reasonable maximum duration
            duration_years = (self.end_date - self.start_date).days / 365
            if duration_years > 10:
                raise ValueError(
                    "Schedule duration cannot exceed 10 years"
                )
        
        return self

    @model_validator(mode="after")
    def validate_checklist_order(self) -> "ScheduleCreate":
        """
        Validate checklist item ordering.
        
        Ensures no duplicate order numbers.
        """
        if self.checklist:
            orders = [item.item_order for item in self.checklist]
            if len(orders) != len(set(orders)):
                raise ValueError(
                    "Checklist items must have unique order numbers"
                )
        
        return self


class RecurrenceConfig(BaseSchema):
    """
    Advanced recurrence configuration.
    
    Defines detailed recurrence rules for complex scheduling patterns.
    """

    recurrence_type: MaintenanceRecurrence = Field(
        ...,
        description="Recurrence type",
    )
    interval_days: Optional[int] = Field(
        None,
        ge=1,
        le=365,
        description="Interval for custom recurrence (in days)",
    )
    day_of_week: Optional[int] = Field(
        None,
        ge=0,
        le=6,
        description="Day of week (0=Monday, 6=Sunday) for weekly recurrence",
    )
    day_of_month: Optional[int] = Field(
        None,
        ge=1,
        le=31,
        description="Day of month for monthly recurrence",
    )
    month_of_year: Optional[int] = Field(
        None,
        ge=1,
        le=12,
        description="Month for yearly recurrence",
    )
    end_date: Optional[date] = Field(
        None,
        description="Stop recurring after this date",
    )
    max_occurrences: Optional[int] = Field(
        None,
        ge=1,
        le=1000,
        description="Maximum number of occurrences",
    )
    skip_weekends: bool = Field(
        default=False,
        description="Skip weekends when scheduling",
    )
    skip_holidays: bool = Field(
        default=False,
        description="Skip holidays when scheduling",
    )

    @model_validator(mode="after")
    def validate_recurrence_rules(self) -> "RecurrenceConfig":
        """
        Validate recurrence configuration consistency.
        
        Ensures appropriate fields are set for recurrence type.
        """
        # Weekly should have day_of_week
        if self.recurrence_type == MaintenanceRecurrence.WEEKLY:
            if self.day_of_week is None:
                raise ValueError(
                    "day_of_week is required for weekly recurrence"
                )
        
        # Monthly should have day_of_month
        if self.recurrence_type == MaintenanceRecurrence.MONTHLY:
            if self.day_of_month is None:
                raise ValueError(
                    "day_of_month is required for monthly recurrence"
                )
        
        # Yearly should have month
        if self.recurrence_type == MaintenanceRecurrence.YEARLY:
            if self.month_of_year is None:
                raise ValueError(
                    "month_of_year is required for yearly recurrence"
                )
        
        # End condition validation
        if self.end_date and self.max_occurrences:
            # Both provided is okay, will use whichever comes first
            pass
        
        return self


class ChecklistResult(BaseSchema):
    """
    Result of individual checklist item execution.
    
    Records completion status and findings for checklist item.
    """

    item_id: Optional[str] = Field(
        None,
        description="Checklist item ID",
    )
    item_description: str = Field(
        ...,
        description="Item description",
    )
    completed: bool = Field(
        ...,
        description="Whether item was completed",
    )
    status: str = Field(
        ...,
        pattern=r"^(pass|fail|na|skipped)$",
        description="Item completion status",
    )
    notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Notes or observations",
    )
    issues_found: Optional[str] = Field(
        None,
        max_length=500,
        description="Issues found during check",
    )
    action_taken: Optional[str] = Field(
        None,
        max_length=500,
        description="Action taken to resolve issues",
    )
    time_taken_minutes: Optional[int] = Field(
        None,
        ge=0,
        le=1440,
        description="Time taken for this item",
    )

    @field_validator("notes", "issues_found", "action_taken")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None


class ScheduleExecution(BaseCreateSchema):
    """
    Execute scheduled preventive maintenance.
    
    Records execution of scheduled maintenance with results
    and next occurrence scheduling.
    """

    schedule_id: UUID = Field(
        ...,
        description="Schedule unique identifier",
    )
    execution_date: date = Field(
        ...,
        description="Execution date",
    )
    executed_by: UUID = Field(
        ...,
        description="User who executed the maintenance",
    )
    completed: bool = Field(
        ...,
        description="Whether execution was completed successfully",
    )
    completion_notes: Optional[str] = Field(
        None,
        max_length=2000,
        description="Detailed completion notes",
    )
    actual_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Actual cost incurred",
    )
    actual_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        decimal_places=2,
        description="Actual time taken in hours",
    )
    checklist_results: List[ChecklistResult] = Field(
        default_factory=list,
        max_length=100,
        description="Results for each checklist item",
    )
    materials_used: Optional[List[dict]] = Field(
        None,
        max_length=100,
        description="Materials used in execution",
    )
    issues_found: Optional[str] = Field(
        None,
        max_length=1000,
        description="Issues or concerns identified",
    )
    recommendations: Optional[str] = Field(
        None,
        max_length=1000,
        description="Recommendations for future maintenance",
    )
    skip_next_occurrence: bool = Field(
        False,
        description="Skip the next scheduled occurrence",
    )
    reschedule_next_to: Optional[date] = Field(
        None,
        description="Reschedule next occurrence to specific date",
    )
    execution_photos: Optional[List[str]] = Field(
        None,
        max_length=20,
        description="Execution photographs",
    )

    @field_validator("execution_date")
    @classmethod
    def validate_execution_date(cls, v: date) -> date:
        """Validate execution date is not in future."""
        if v > date.today():
            raise ValueError("Execution date cannot be in the future")
        return v

    @field_validator("actual_cost", "actual_duration_hours")
    @classmethod
    def round_decimals(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round decimal values."""
        return round(v, 2) if v is not None else None

    @field_validator(
        "completion_notes",
        "issues_found",
        "recommendations",
    )
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @model_validator(mode="after")
    def validate_completion_requirements(self) -> "ScheduleExecution":
        """
        Validate completion information.
        
        Completed executions should have notes.
        """
        if self.completed and not self.completion_notes:
            raise ValueError(
                "Completion notes are required for completed executions"
            )
        
        return self

    @model_validator(mode="after")
    def validate_rescheduling(self) -> "ScheduleExecution":
        """
        Validate rescheduling logic.
        
        Can't both skip and reschedule next occurrence.
        """
        if self.skip_next_occurrence and self.reschedule_next_to:
            raise ValueError(
                "Cannot both skip and reschedule next occurrence"
            )
        
        if self.reschedule_next_to:
            # Rescheduled date should be in future
            if self.reschedule_next_to <= date.today():
                raise ValueError(
                    "Rescheduled date must be in the future"
                )
        
        return self


class ScheduleUpdate(BaseUpdateSchema):
    """
    Update preventive maintenance schedule.
    
    Allows modification of schedule parameters and status.
    """

    title: Optional[str] = Field(
        None,
        min_length=5,
        max_length=255,
        description="Updated title",
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Updated description",
    )
    recurrence: Optional[MaintenanceRecurrence] = Field(
        None,
        description="Updated recurrence pattern",
    )
    next_due_date: Optional[date] = Field(
        None,
        description="Updated next due date",
    )
    assigned_to: Optional[UUID] = Field(
        None,
        description="Updated default assignee",
    )
    estimated_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        max_digits=10,
        decimal_places=2,
        description="Updated estimated cost",
    )
    estimated_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        le=1000,
        decimal_places=2,
        description="Updated estimated duration",
    )
    is_active: Optional[bool] = Field(
        None,
        description="Active status",
    )
    auto_create_requests: Optional[bool] = Field(
        None,
        description="Auto-create maintenance requests",
    )
    notification_days_before: Optional[int] = Field(
        None,
        ge=0,
        le=30,
        description="Notification days before due date",
    )
    priority_level: Optional[str] = Field(
        None,
        pattern=r"^(low|medium|high)$",
        description="Updated priority level",
    )

    @field_validator("title", "description")
    @classmethod
    def normalize_text(cls, v: Optional[str]) -> Optional[str]:
        """Normalize text fields."""
        if v is not None:
            v = v.strip()
            return v if v else None
        return None

    @field_validator("estimated_cost", "estimated_duration_hours")
    @classmethod
    def round_decimals(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round decimal values."""
        return round(v, 2) if v is not None else None

    @field_validator("next_due_date")
    @classmethod
    def validate_due_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate next due date is reasonable."""
        if v is not None:
            # Should not be too far in past
            days_past = (date.today() - v).days
            if days_past > 30:
                raise ValueError(
                    "Next due date cannot be more than 30 days in the past"
                )
        return v


class ExecutionHistoryItem(BaseSchema):
    """
    Individual execution history record.
    
    Represents single execution in schedule history.
    """

    execution_id: UUID = Field(
        ...,
        description="Execution unique identifier",
    )
    execution_date: date = Field(
        ...,
        description="Execution date",
    )
    scheduled_date: date = Field(
        ...,
        description="Originally scheduled date",
    )
    executed_by: UUID = Field(
        ...,
        description="User who executed",
    )
    executed_by_name: str = Field(
        ...,
        description="Executor name",
    )
    completed: bool = Field(
        ...,
        description="Whether completed successfully",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="Completion timestamp",
    )
    actual_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Actual cost",
    )
    actual_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Actual duration",
    )
    completion_notes: Optional[str] = Field(
        None,
        description="Completion notes",
    )
    issues_found: Optional[str] = Field(
        None,
        description="Issues found",
    )
    was_on_time: bool = Field(
        ...,
        description="Whether executed on scheduled date",
    )
    days_delay: int = Field(
        default=0,
        description="Days delayed from scheduled date",
    )
    quality_rating: Optional[int] = Field(
        None,
        ge=1,
        le=5,
        description="Quality rating for execution",
    )

    @computed_field
    @property
    def execution_status(self) -> str:
        """Get execution status summary."""
        if not self.completed:
            return "incomplete"
        elif self.was_on_time:
            return "on_time"
        else:
            return "delayed"


class ScheduleHistory(BaseSchema):
    """
    Complete execution history for schedule.
    
    Tracks all executions with statistics and trends.
    """

    schedule_id: UUID = Field(
        ...,
        description="Schedule unique identifier",
    )
    schedule_title: str = Field(
        ...,
        description="Schedule title",
    )
    schedule_code: Optional[str] = Field(
        None,
        description="Schedule code",
    )
    total_executions: int = Field(
        ...,
        ge=0,
        description="Total number of executions",
    )
    completed_executions: int = Field(
        ...,
        ge=0,
        description="Successfully completed executions",
    )
    skipped_executions: int = Field(
        ...,
        ge=0,
        description="Skipped executions",
    )
    delayed_executions: int = Field(
        default=0,
        ge=0,
        description="Delayed executions",
    )
    on_time_executions: int = Field(
        default=0,
        ge=0,
        description="On-time executions",
    )
    executions: List[ExecutionHistoryItem] = Field(
        ...,
        description="Chronological execution history",
    )
    total_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Total cost across all executions",
    )
    average_cost: Decimal = Field(
        default=Decimal("0.00"),
        ge=0,
        description="Average cost per execution",
    )
    average_duration_hours: Optional[Decimal] = Field(
        None,
        ge=0,
        description="Average execution duration",
    )
    average_quality_rating: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        description="Average quality rating",
    )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate percentage."""
        if self.total_executions == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.completed_executions) / Decimal(self.total_executions) * 100,
            2,
        )

    @computed_field
    @property
    def on_time_rate(self) -> Decimal:
        """Calculate on-time execution rate."""
        if self.completed_executions == 0:
            return Decimal("0.00")
        return round(
            Decimal(self.on_time_executions) / Decimal(self.completed_executions) * 100,
            2,
        )

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance\__init__.py ---
# --- File: app/schemas/maintenance/__init__.py ---
"""
Maintenance management schemas package.

Comprehensive maintenance request, scheduling, cost tracking, and analytics
schemas for hostel management system with enhanced validation and type safety.
"""

from __future__ import annotations

from app.schemas.maintenance.maintenance_analytics import (
    CategoryBreakdown,
    CostTrendPoint,
    MaintenanceAnalytics,
    PerformanceMetrics,
    ProductivityMetrics,
    TrendPoint,
    VendorPerformance,
)
from app.schemas.maintenance.maintenance_approval import (
    ApprovalRequest,
    ApprovalResponse,
    ApprovalWorkflow,
    RejectionRequest,
    ThresholdConfig,
)
from app.schemas.maintenance.maintenance_assignment import (
    AssignmentEntry,
    AssignmentHistory,
    AssignmentUpdate,
    BulkAssignment,
    TaskAssignment,
    VendorAssignment,
)
from app.schemas.maintenance.maintenance_base import (
    MaintenanceBase,
    MaintenanceCreate,
    MaintenanceStatusUpdate,
    MaintenanceUpdate,
)
from app.schemas.maintenance.maintenance_completion import (
    ChecklistItem,
    CompletionCertificate,
    CompletionRequest,
    CompletionResponse,
    MaterialItem,
    QualityCheck,
)
from app.schemas.maintenance.maintenance_cost import (
    BudgetAllocation,
    CategoryBudget,
    CostAnalysis,
    CostTracking,
    ExpenseItem,
    ExpenseReport,
    InvoiceLineItem,
    MonthlyExpense,
    VendorInvoice,
)
from app.schemas.maintenance.maintenance_filters import (
    AdvancedFilterParams,
    MaintenanceExportRequest,
    MaintenanceFilterParams,
    SearchRequest,
)
from app.schemas.maintenance.maintenance_request import (
    EmergencyRequest,
    MaintenanceRequest,
    RequestSubmission,
)
from app.schemas.maintenance.maintenance_response import (
    MaintenanceDetail,
    MaintenanceResponse,
    MaintenanceSummary,
    RequestListItem,
)
from app.schemas.maintenance.maintenance_schedule import (
    ChecklistResult,
    ExecutionHistoryItem,
    PreventiveSchedule,
    RecurrenceConfig,
    ScheduleChecklistItem,
    ScheduleCreate,
    ScheduleExecution,
    ScheduleHistory,
    ScheduleUpdate,
)

__all__ = [
    # Base schemas
    "MaintenanceBase",
    "MaintenanceCreate",
    "MaintenanceUpdate",
    "MaintenanceStatusUpdate",
    # Request schemas
    "MaintenanceRequest",
    "RequestSubmission",
    "EmergencyRequest",
    # Response schemas
    "MaintenanceResponse",
    "MaintenanceDetail",
    "RequestListItem",
    "MaintenanceSummary",
    # Assignment schemas
    "TaskAssignment",
    "VendorAssignment",
    "AssignmentUpdate",
    "BulkAssignment",
    "AssignmentEntry",
    "AssignmentHistory",
    # Approval schemas
    "ApprovalRequest",
    "ApprovalResponse",
    "ApprovalWorkflow",
    "RejectionRequest",
    "ThresholdConfig",
    # Completion schemas
    "CompletionRequest",
    "CompletionResponse",
    "CompletionCertificate",
    "MaterialItem",
    "QualityCheck",
    "ChecklistItem",
    # Schedule schemas
    "PreventiveSchedule",
    "ScheduleCreate",
    "ScheduleUpdate",
    "ScheduleChecklistItem",
    "RecurrenceConfig",
    "ScheduleExecution",
    "ChecklistResult",
    "ScheduleHistory",
    "ExecutionHistoryItem",
    # Cost schemas
    "CostTracking",
    "BudgetAllocation",
    "CategoryBudget",
    "ExpenseReport",
    "MonthlyExpense",
    "ExpenseItem",
    "VendorInvoice",
    "InvoiceLineItem",
    "CostAnalysis",
    # Filter schemas
    "MaintenanceFilterParams",
    "AdvancedFilterParams",
    "SearchRequest",
    "MaintenanceExportRequest",
    # Analytics schemas
    "MaintenanceAnalytics",
    "TrendPoint",
    "CostTrendPoint",
    "CategoryBreakdown",
    "VendorPerformance",
    "PerformanceMetrics",
    "ProductivityMetrics",
]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\maintenance\__pycache__ =====
