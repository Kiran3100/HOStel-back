### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\booking_analytics.py ---
# --- File: app/schemas/analytics/booking_analytics.py ---
"""
Booking analytics schemas with enhanced validation and type safety.

This module provides comprehensive analytics for booking operations including:
- Key Performance Indicators (KPIs)
- Trend analysis
- Conversion funnels
- Cancellation analytics
- Source-based metrics
"""

from datetime import datetime
from datetime import date as Date
from decimal import Decimal
from typing import Dict, List, Optional, Any

from pydantic import Field, field_validator, computed_field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import BookingStatus, BookingSource
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "BookingKPI",
    "BookingTrendPoint",
    "BookingFunnel",
    "CancellationAnalytics",
    "BookingAnalyticsSummary",
    "BookingSourceMetrics",
]


class BookingKPI(BaseSchema):
    """
    Key Performance Indicators for booking operations.
    
    Provides essential metrics including total bookings, conversion rates,
    and cancellation statistics for a specific hostel or platform-wide.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel identifier. None indicates platform-wide metrics"
    )
    hostel_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Hostel name for display purposes"
    )
    
    # Booking counts
    total_bookings: int = Field(
        ...,
        ge=0,
        description="Total number of bookings in the period"
    )
    confirmed_bookings: int = Field(
        ...,
        ge=0,
        description="Number of confirmed bookings"
    )
    cancelled_bookings: int = Field(
        ...,
        ge=0,
        description="Number of cancelled bookings"
    )
    rejected_bookings: int = Field(
        ...,
        ge=0,
        description="Number of rejected bookings"
    )
    pending_bookings: int = Field(
        0,
        ge=0,
        description="Number of pending bookings awaiting approval"
    )
    
    # Performance metrics
    booking_conversion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of bookings that were confirmed"
    )
    cancellation_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of bookings that were cancelled"
    )
    average_lead_time_days: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average days between booking creation and check-in date"
    )
    
    @field_validator("confirmed_bookings", "cancelled_bookings", "rejected_bookings", "pending_bookings")
    @classmethod
    def validate_booking_counts(cls, v: int, info) -> int:
        """Validate that individual booking counts don't exceed total."""
        if "total_bookings" in info.data:
            total = info.data["total_bookings"]
            if v > total:
                raise ValueError(
                    f"{info.field_name} ({v}) cannot exceed total_bookings ({total})"
                )
        return v
    
    @field_validator("booking_conversion_rate", "cancellation_rate")
    @classmethod
    def validate_percentage(cls, v: Decimal) -> Decimal:
        """Ensure percentages are within valid range."""
        if not (0 <= v <= 100):
            raise ValueError("Percentage must be between 0 and 100")
        return round(v, 2)
    
    @computed_field
    @property
    def approval_rate(self) -> Decimal:
        """Calculate approval rate (confirmed / (confirmed + rejected))."""
        denominator = self.confirmed_bookings + self.rejected_bookings
        if denominator == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.confirmed_bookings) / Decimal(denominator)) * 100,
            2
        )
    
    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate completion rate (non-pending / total)."""
        if self.total_bookings == 0:
            return Decimal("0.00")
        completed = self.total_bookings - self.pending_bookings
        return round(
            (Decimal(completed) / Decimal(self.total_bookings)) * 100,
            2
        )


class BookingTrendPoint(BaseSchema):
    """
    Single data point in booking trend analysis.
    
    Represents booking metrics for a specific date, enabling
    time-series visualization and trend analysis.
    """
    
    trend_date: Date = Field(
        ...,
        description="Date of the data point"
    )
    total_bookings: int = Field(
        ...,
        ge=0,
        description="Total bookings on this date"
    )
    confirmed: int = Field(
        ...,
        ge=0,
        description="Confirmed bookings on this date"
    )
    cancelled: int = Field(
        ...,
        ge=0,
        description="Cancelled bookings on this date"
    )
    rejected: int = Field(
        ...,
        ge=0,
        description="Rejected bookings on this date"
    )
    pending: int = Field(
        0,
        ge=0,
        description="Pending bookings on this date"
    )
    revenue_for_day: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total revenue generated on this date"
    )
    
    @field_validator("confirmed", "cancelled", "rejected", "pending")
    @classmethod
    def validate_counts(cls, v: int, info) -> int:
        """Validate that status counts don't exceed total."""
        if "total_bookings" in info.data:
            total = info.data["total_bookings"]
            if v > total:
                raise ValueError(
                    f"{info.field_name} ({v}) cannot exceed total_bookings ({total})"
                )
        return v
    
    @computed_field
    @property
    def conversion_rate(self) -> Decimal:
        """Calculate conversion rate for this date."""
        if self.total_bookings == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.confirmed) / Decimal(self.total_bookings)) * 100,
            2
        )


class BookingFunnel(BaseSchema):
    """
    Booking conversion funnel analytics.
    
    Tracks user journey from hostel page views through to confirmed bookings,
    providing insights into conversion bottlenecks.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Time period for funnel analysis"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when this report was generated"
    )
    
    # Funnel stages
    hostel_page_views: int = Field(
        ...,
        ge=0,
        description="Total hostel detail page views"
    )
    booking_form_starts: int = Field(
        ...,
        ge=0,
        description="Users who started the booking form"
    )
    booking_submissions: int = Field(
        ...,
        ge=0,
        description="Completed booking form submissions"
    )
    bookings_confirmed: int = Field(
        ...,
        ge=0,
        description="Final confirmed bookings"
    )
    
    # Conversion rates
    view_to_start_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Conversion rate from page view to form start (%)"
    )
    start_to_submit_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Conversion rate from form start to submission (%)"
    )
    submit_to_confirm_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Conversion rate from submission to confirmation (%)"
    )
    view_to_confirm_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall conversion rate from view to confirmation (%)"
    )
    
    @field_validator(
        "booking_form_starts",
        "booking_submissions",
        "bookings_confirmed"
    )
    @classmethod
    def validate_funnel_progression(cls, v: int, info) -> int:
        """Validate that funnel stages progress logically."""
        field_name = info.field_name
        
        if field_name == "booking_form_starts" and "hostel_page_views" in info.data:
            if v > info.data["hostel_page_views"]:
                raise ValueError(
                    "booking_form_starts cannot exceed hostel_page_views"
                )
        elif field_name == "booking_submissions" and "booking_form_starts" in info.data:
            if v > info.data["booking_form_starts"]:
                raise ValueError(
                    "booking_submissions cannot exceed booking_form_starts"
                )
        elif field_name == "bookings_confirmed" and "booking_submissions" in info.data:
            if v > info.data["booking_submissions"]:
                raise ValueError(
                    "bookings_confirmed cannot exceed booking_submissions"
                )
        
        return v
    
    @computed_field
    @property
    def total_drop_offs(self) -> int:
        """Calculate total number of users who dropped off."""
        return self.hostel_page_views - self.bookings_confirmed
    
    @computed_field
    @property
    def largest_drop_off_stage(self) -> str:
        """Identify the stage with largest drop-off."""
        drop_offs = {
            "view_to_start": self.hostel_page_views - self.booking_form_starts,
            "start_to_submit": self.booking_form_starts - self.booking_submissions,
            "submit_to_confirm": self.booking_submissions - self.bookings_confirmed,
        }
        return max(drop_offs, key=drop_offs.get)


class CancellationAnalytics(BaseSchema):
    """
    Detailed analytics for booking cancellations.
    
    Provides insights into cancellation patterns, reasons,
    and timing to help reduce cancellation rates.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    total_cancellations: int = Field(
        ...,
        ge=0,
        description="Total number of cancellations in period"
    )
    cancellation_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Cancellation rate as percentage of total bookings"
    )
    
    # Breakdown by reason
    cancellations_by_reason: Dict[str, int] = Field(
        default_factory=dict,
        description="Cancellation count grouped by reason"
    )
    cancellations_by_status: Dict[str, int] = Field(
        default_factory=dict,
        description="Cancellation count grouped by original booking status"
    )
    
    # Timing analysis
    average_time_before_check_in_cancelled_days: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average days before check-in when cancellations occur"
    )
    cancellations_within_24h: int = Field(
        0,
        ge=0,
        description="Cancellations made within 24 hours of check-in"
    )
    cancellations_within_week: int = Field(
        0,
        ge=0,
        description="Cancellations made within 1 week of check-in"
    )
    
    @field_validator("cancellations_by_reason", "cancellations_by_status")
    @classmethod
    def validate_breakdown_totals(cls, v: Dict[str, int], info) -> Dict[str, int]:
        """Ensure breakdown totals match overall total."""
        if v and "total_cancellations" in info.data:
            breakdown_total = sum(v.values())
            total_cancellations = info.data["total_cancellations"]
            # Allow some tolerance for rounding or filtering
            if breakdown_total > total_cancellations:
                raise ValueError(
                    f"Breakdown total ({breakdown_total}) exceeds "
                    f"total_cancellations ({total_cancellations})"
                )
        return v
    
    @computed_field
    @property
    def top_cancellation_reason(self) -> Optional[str]:
        """Identify the most common cancellation reason."""
        if not self.cancellations_by_reason:
            return None
        return max(
            self.cancellations_by_reason,
            key=self.cancellations_by_reason.get
        )
    
    @computed_field
    @property
    def early_cancellation_rate(self) -> Decimal:
        """Calculate percentage of cancellations made >7 days before check-in."""
        if self.total_cancellations == 0:
            return Decimal("0.00")
        early = self.total_cancellations - self.cancellations_within_week
        return round(
            (Decimal(early) / Decimal(self.total_cancellations)) * 100,
            2
        )


class BookingSourceMetrics(BaseSchema):
    """
    Metrics for a specific booking source.
    
    Tracks performance of individual booking channels
    to optimize marketing and acquisition strategies.
    """
    
    source: BookingSource = Field(
        ...,
        description="Booking source"
    )
    total_bookings: int = Field(
        ...,
        ge=0,
        description="Total bookings from this source"
    )
    confirmed_bookings: int = Field(
        ...,
        ge=0,
        description="Confirmed bookings from this source"
    )
    conversion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Conversion rate for this source (%)"
    )
    total_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total revenue generated from this source"
    )
    average_booking_value: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average revenue per booking from this source"
    )
    
    @computed_field
    @property
    def revenue_per_confirmed_booking(self) -> Decimal:
        """Calculate average revenue per confirmed booking."""
        if self.confirmed_bookings == 0:
            return Decimal("0.00")
        return round(
            self.total_revenue / Decimal(self.confirmed_bookings),
            2
        )


class BookingAnalyticsSummary(BaseSchema):
    """
    Comprehensive booking analytics summary.
    
    Consolidates all booking metrics, trends, and analytics
    into a single comprehensive report.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel identifier. None for platform-wide analytics"
    )
    hostel_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Core metrics
    kpi: BookingKPI = Field(
        ...,
        description="Key performance indicators"
    )
    trend: List[BookingTrendPoint] = Field(
        default_factory=list,
        description="Daily trend data points"
    )
    
    # Funnel and cancellations
    funnel: BookingFunnel = Field(
        ...,
        description="Booking conversion funnel analysis"
    )
    cancellations: CancellationAnalytics = Field(
        ...,
        description="Cancellation analytics"
    )
    
    # Source analysis
    bookings_by_source: Dict[str, int] = Field(
        default_factory=dict,
        description="Booking count by source"
    )
    source_metrics: List[BookingSourceMetrics] = Field(
        default_factory=list,
        description="Detailed metrics for each booking source"
    )
    
    # Legacy field for backward compatibility
    conversion_rate_by_source: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Conversion rate by source (deprecated: use source_metrics)"
    )
    
    @field_validator("trend")
    @classmethod
    def validate_trend_chronological(
        cls,
        v: List[BookingTrendPoint]
    ) -> List[BookingTrendPoint]:
        """Ensure trend points are in chronological order."""
        if len(v) > 1:
            dates = [point.Date for point in v]
            if dates != sorted(dates):
                raise ValueError("Trend points must be in chronological order")
        return v
    
    @computed_field
    @property
    def best_performing_source(self) -> Optional[BookingSource]:
        """Identify the booking source with highest conversion rate."""
        if not self.source_metrics:
            return None
        best = max(
            self.source_metrics,
            key=lambda x: x.conversion_rate
        )
        return best.source
    
    @computed_field
    @property
    def highest_revenue_source(self) -> Optional[BookingSource]:
        """Identify the booking source with highest total revenue."""
        if not self.source_metrics:
            return None
        best = max(
            self.source_metrics,
            key=lambda x: x.total_revenue
        )
        return best.source
    
    def get_trend_summary(self) -> Dict[str, Any]:
        """
        Generate a summary of booking trends.
        
        Returns:
            Dictionary containing trend insights like growth rate,
            peak booking date, etc.
        """
        if not self.trend:
            return {}
        
        total_bookings = [point.total_bookings for point in self.trend]
        revenues = [float(point.revenue_for_day) for point in self.trend]
        
        peak_date = max(self.trend, key=lambda x: x.total_bookings).Date
        best_revenue_date = max(self.trend, key=lambda x: x.revenue_for_day).Date
        
        return {
            "peak_booking_date": peak_date,
            "peak_bookings": max(total_bookings),
            "best_revenue_date": best_revenue_date,
            "best_revenue": max(revenues),
            "average_daily_bookings": round(
                sum(total_bookings) / len(total_bookings), 2
            ),
            "average_daily_revenue": round(
                sum(revenues) / len(revenues), 2
            ),
        }

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\complaint_analytics.py ---
# --- File: app/schemas/analytics/complaint_analytics.py ---
"""
Complaint analytics schemas with enhanced metrics and validation.

Provides comprehensive analytics for complaint management including:
- Service level metrics (SLA compliance, resolution time)
- Trend analysis and forecasting
- Category and priority breakdowns
- Performance benchmarking
"""

from datetime import date as Date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, computed_field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import ComplaintStatus, ComplaintCategory, Priority
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "ComplaintKPI",
    "ComplaintTrendPoint",
    "ComplaintTrend",
    "CategoryBreakdown",
    "PriorityBreakdown",
    "ComplaintDashboard",
    "SLAMetrics",
]


class SLAMetrics(BaseSchema):
    """
    Service Level Agreement metrics for complaint handling.
    
    Tracks compliance with defined service level targets
    and identifies areas needing improvement.
    """
    
    total_with_sla: int = Field(
        ...,
        ge=0,
        description="Total complaints with defined SLA"
    )
    met_sla: int = Field(
        ...,
        ge=0,
        description="Complaints resolved within SLA"
    )
    breached_sla: int = Field(
        ...,
        ge=0,
        description="Complaints that breached SLA"
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of complaints meeting SLA"
    )
    average_sla_buffer_hours: Decimal = Field(
        ...,
        decimal_places=2,
        description="Average time buffer (positive) or breach (negative) in hours"
    )
    
    @field_validator("met_sla", "breached_sla")
    @classmethod
    def validate_sla_counts(cls, v: int, info) -> int:
        """Validate SLA counts don't exceed total."""
        if "total_with_sla" in info.data and v > info.data["total_with_sla"]:
            raise ValueError(f"{info.field_name} cannot exceed total_with_sla")
        return v
    
    @computed_field
    @property
    def at_risk_count(self) -> int:
        """Complaints currently at risk of SLA breach (estimated as 20% of total)."""
        return max(0, int(self.total_with_sla * 0.2))


class ComplaintKPI(BaseSchema):
    """
    Key Performance Indicators for complaint management.
    
    Provides comprehensive metrics on complaint volumes, resolution efficiency,
    and service quality for a specific hostel or platform-wide.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel identifier. None indicates platform-wide metrics"
    )
    hostel_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Hostel name for display"
    )
    
    # Volume metrics
    total_complaints: int = Field(
        ...,
        ge=0,
        description="Total complaints in the period"
    )
    open_complaints: int = Field(
        ...,
        ge=0,
        description="Currently open complaints"
    )
    in_progress_complaints: int = Field(
        0,
        ge=0,
        description="Complaints currently being worked on"
    )
    resolved_complaints: int = Field(
        ...,
        ge=0,
        description="Resolved complaints in the period"
    )
    closed_complaints: int = Field(
        ...,
        ge=0,
        description="Closed complaints in the period"
    )
    
    # Performance metrics
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average time to resolve complaints in hours"
    )
    median_resolution_time_hours: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Median resolution time in hours"
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of complaints resolved within SLA"
    )
    escalation_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of complaints escalated"
    )
    reopen_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of resolved complaints that were reopened"
    )
    
    # First response time
    average_first_response_time_hours: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Average time to first response in hours"
    )
    
    # Customer satisfaction
    average_satisfaction_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average customer satisfaction score (1-5)"
    )
    
    @field_validator(
        "open_complaints",
        "in_progress_complaints",
        "resolved_complaints",
        "closed_complaints"
    )
    @classmethod
    def validate_complaint_counts(cls, v: int, info) -> int:
        """Validate individual counts are reasonable."""
        if "total_complaints" in info.data:
            total = info.data["total_complaints"]
            if v > total and info.field_name != "open_complaints":
                # open_complaints can exceed total as it includes historical
                raise ValueError(
                    f"{info.field_name} ({v}) should not exceed total_complaints ({total})"
                )
        return v
    
    @computed_field
    @property
    def resolution_rate(self) -> Decimal:
        """Calculate percentage of total complaints that have been resolved."""
        if self.total_complaints == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.resolved_complaints) / Decimal(self.total_complaints)) * 100,
            2
        )
    
    @computed_field
    @property
    def backlog(self) -> int:
        """Calculate current complaint backlog."""
        return self.open_complaints + self.in_progress_complaints
    
    @computed_field
    @property
    def efficiency_score(self) -> Decimal:
        """
        Calculate overall efficiency score (0-100).
        
        Combines resolution rate, SLA compliance, and low reopen rate.
        """
        weights = {
            "resolution": 0.4,
            "sla": 0.4,
            "reopen": 0.2
        }
        
        resolution_score = self.resolution_rate
        sla_score = self.sla_compliance_rate
        reopen_score = 100 - self.reopen_rate  # Lower is better
        
        score = (
            resolution_score * Decimal(str(weights["resolution"])) +
            sla_score * Decimal(str(weights["sla"])) +
            reopen_score * Decimal(str(weights["reopen"]))
        )
        
        return round(score, 2)


class ComplaintTrendPoint(BaseSchema):
    """
    Single data point in complaint trend analysis.
    
    Represents complaint metrics for a specific date,
    enabling time-series visualization.
    """
    
    trend_date: Date = Field(
        ...,
        description="Date of the data point"
    )
    total_complaints: int = Field(
        ...,
        ge=0,
        description="Total complaints on this date"
    )
    open_complaints: int = Field(
        ...,
        ge=0,
        description="Open complaints on this date"
    )
    resolved_complaints: int = Field(
        ...,
        ge=0,
        description="Resolved complaints on this date"
    )
    escalated: int = Field(
        ...,
        ge=0,
        description="Escalated complaints on this date"
    )
    sla_breached: int = Field(
        ...,
        ge=0,
        description="SLA breaches on this date"
    )
    
    @field_validator("escalated", "sla_breached")
    @classmethod
    def validate_subset_counts(cls, v: int, info) -> int:
        """Validate that subset counts don't exceed total."""
        if "total_complaints" in info.data and v > info.data["total_complaints"]:
            raise ValueError(
                f"{info.field_name} ({v}) cannot exceed total_complaints"
            )
        return v
    
    @computed_field
    @property
    def resolution_rate(self) -> Decimal:
        """Calculate resolution rate for this date."""
        if self.total_complaints == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.resolved_complaints) / Decimal(self.total_complaints)) * 100,
            2
        )


class ComplaintTrend(BaseSchema):
    """
    Time-series trend analysis for complaints.
    
    Provides historical data points and trend indicators
    for complaint volume and resolution patterns.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    points: List[ComplaintTrendPoint] = Field(
        default_factory=list,
        description="Chronological data points"
    )
    
    @field_validator("points")
    @classmethod
    def validate_chronological_order(
        cls,
        v: List[ComplaintTrendPoint]
    ) -> List[ComplaintTrendPoint]:
        """Ensure trend points are in chronological order."""
        if len(v) > 1:
            dates = [point.Date for point in v]
            if dates != sorted(dates):
                raise ValueError("Trend points must be in chronological order")
        return v
    
    @computed_field
    @property
    def trend_direction(self) -> str:
        """
        Determine overall trend direction.
        
        Returns:
            'increasing', 'decreasing', or 'stable'
        """
        if len(self.points) < 2:
            return "stable"
        
        first_half = self.points[:len(self.points)//2]
        second_half = self.points[len(self.points)//2:]
        
        first_avg = sum(p.total_complaints for p in first_half) / len(first_half)
        second_avg = sum(p.total_complaints for p in second_half) / len(second_half)
        
        change_percent = ((second_avg - first_avg) / first_avg * 100) if first_avg > 0 else 0
        
        if change_percent > 10:
            return "increasing"
        elif change_percent < -10:
            return "decreasing"
        return "stable"
    
    @computed_field
    @property
    def peak_complaint_date(self) -> Optional[Date]:
        """Identify date with highest complaint volume."""
        if not self.points:
            return None
        return max(self.points, key=lambda x: x.total_complaints).Date


class CategoryBreakdown(BaseSchema):
    """
    Complaint breakdown by category.
    
    Provides insights into complaint distribution and
    resolution efficiency by category.
    """
    
    category: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Complaint category"
    )
    count: int = Field(
        ...,
        ge=0,
        description="Number of complaints in this category"
    )
    percentage_of_total: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of total complaints"
    )
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average resolution time for this category in hours"
    )
    resolved_count: int = Field(
        0,
        ge=0,
        description="Number of resolved complaints in this category"
    )
    open_count: int = Field(
        0,
        ge=0,
        description="Number of open complaints in this category"
    )
    
    @field_validator("resolved_count", "open_count")
    @classmethod
    def validate_status_counts(cls, v: int, info) -> int:
        """Validate status counts don't exceed category total."""
        if "count" in info.data and v > info.data["count"]:
            raise ValueError(f"{info.field_name} cannot exceed count")
        return v
    
    @computed_field
    @property
    def resolution_rate(self) -> Decimal:
        """Calculate resolution rate for this category."""
        if self.count == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.resolved_count) / Decimal(self.count)) * 100,
            2
        )


class PriorityBreakdown(BaseSchema):
    """
    Complaint breakdown by priority level.
    
    Helps identify resource allocation needs based on
    complaint urgency distribution.
    """
    
    priority: Priority = Field(
        ...,
        description="Priority level"
    )
    count: int = Field(
        ...,
        ge=0,
        description="Number of complaints at this priority"
    )
    percentage_of_total: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of total complaints"
    )
    average_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average resolution time for this priority"
    )
    sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="SLA compliance rate for this priority level"
    )
    
    @computed_field
    @property
    def priority_score(self) -> int:
        """Get numeric priority score for sorting (higher = more urgent)."""
        priority_scores = {
            Priority.LOW: 1,
            Priority.MEDIUM: 2,
            Priority.HIGH: 3,
            Priority.URGENT: 4,
            Priority.CRITICAL: 5,
        }
        return priority_scores.get(self.priority, 0)


class ComplaintDashboard(BaseSchema):
    """
    Comprehensive complaint dashboard analytics.
    
    Consolidates all complaint metrics, trends, and breakdowns
    into a single actionable dashboard view.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel identifier. None for platform-wide analytics"
    )
    hostel_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Core metrics
    kpi: ComplaintKPI = Field(
        ...,
        description="Key performance indicators"
    )
    sla_metrics: SLAMetrics = Field(
        ...,
        description="Service level agreement metrics"
    )
    trend: ComplaintTrend = Field(
        ...,
        description="Time-series trend analysis"
    )
    
    # Breakdowns
    by_category: List[CategoryBreakdown] = Field(
        default_factory=list,
        description="Breakdown by complaint category"
    )
    by_priority: List[PriorityBreakdown] = Field(
        default_factory=list,
        description="Breakdown by priority level"
    )
    
    # Legacy support
    by_priority_dict: Dict[str, int] = Field(
        default_factory=dict,
        description="Priority counts as dict (deprecated: use by_priority)"
    )
    
    @field_validator("by_category")
    @classmethod
    def validate_category_percentages(
        cls,
        v: List[CategoryBreakdown]
    ) -> List[CategoryBreakdown]:
        """Validate that category percentages sum to ~100%."""
        if v:
            total_percentage = sum(cat.percentage_of_total for cat in v)
            # Allow 1% tolerance for rounding
            if not (99 <= total_percentage <= 101):
                raise ValueError(
                    f"Category percentages should sum to 100%, got {total_percentage}%"
                )
        return v
    
    @computed_field
    @property
    def most_common_category(self) -> Optional[str]:
        """Identify the most common complaint category."""
        if not self.by_category:
            return None
        return max(self.by_category, key=lambda x: x.count).category
    
    @computed_field
    @property
    def slowest_category(self) -> Optional[str]:
        """Identify category with slowest average resolution time."""
        if not self.by_category:
            return None
        return max(
            self.by_category,
            key=lambda x: x.average_resolution_time_hours
        ).category
    
    @computed_field
    @property
    def high_priority_percentage(self) -> Decimal:
        """Calculate percentage of high/urgent/critical priority complaints."""
        if not self.by_priority:
            return Decimal("0.00")
        
        high_priorities = [
            Priority.HIGH,
            Priority.URGENT,
            Priority.CRITICAL
        ]
        high_count = sum(
            p.count for p in self.by_priority
            if p.priority in high_priorities
        )
        total = sum(p.count for p in self.by_priority)
        
        if total == 0:
            return Decimal("0.00")
        
        return round((Decimal(high_count) / Decimal(total)) * 100, 2)
    
    def get_actionable_insights(self) -> List[str]:
        """
        Generate actionable insights based on analytics.
        
        Returns:
            List of insight strings highlighting areas needing attention.
        """
        insights = []
        
        # SLA compliance check
        if self.sla_metrics.sla_compliance_rate < 80:
            insights.append(
                f"SLA compliance at {self.sla_metrics.sla_compliance_rate}% "
                "- consider resource allocation"
            )
        
        # Backlog check
        if self.kpi.backlog > 50:
            insights.append(
                f"High backlog of {self.kpi.backlog} complaints - "
                "prioritize resolution efforts"
            )
        
        # Reopen rate check
        if self.kpi.reopen_rate > 15:
            insights.append(
                f"High reopen rate of {self.kpi.reopen_rate}% - "
                "review resolution quality"
            )
        
        # Trend check
        if self.trend.trend_direction == "increasing":
            insights.append(
                "Complaint volume trending upward - "
                "investigate root causes"
            )
        
        # Category focus
        if self.most_common_category:
            insights.append(
                f"Most complaints in '{self.most_common_category}' category - "
                "consider preventive measures"
            )
        
        return insights

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\custom_reports.py ---
# --- File: app/schemas/analytics/custom_reports.py ---
"""
Custom report builder schemas with advanced filtering and aggregation.

Provides flexible report generation capabilities allowing users to:
- Define custom fields and aggregations
- Apply complex filters
- Group and sort data
- Generate reports in multiple formats
- Share and save report definitions
"""

from datetime import datetime
from typing import Any, Dict, List, Optional, Union
from enum import Enum

from pydantic import Field, field_validator, model_validator, computed_field
from uuid import UUID

from app.schemas.common.base import BaseSchema, BaseCreateSchema, BaseResponseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "FilterOperator",
    "AggregationType",
    "ReportFormat",
    "ReportModule",
    "CustomReportFilter",
    "CustomReportField",
    "CustomReportRequest",
    "CustomReportDefinition",
    "CustomReportResult",
    "ReportExportRequest",
    "ReportSchedule",
]


class FilterOperator(str, Enum):
    """Supported filter operators for custom reports."""
    
    # Comparison
    EQUALS = "eq"
    NOT_EQUALS = "ne"
    GREATER_THAN = "gt"
    GREATER_THAN_OR_EQUAL = "gte"
    LESS_THAN = "lt"
    LESS_THAN_OR_EQUAL = "lte"
    
    # Set operations
    IN = "in"
    NOT_IN = "not_in"
    
    # String operations
    CONTAINS = "contains"
    NOT_CONTAINS = "not_contains"
    STARTS_WITH = "starts_with"
    ENDS_WITH = "ends_with"
    
    # Range operations
    BETWEEN = "between"
    
    # Null checks
    IS_NULL = "is_null"
    IS_NOT_NULL = "is_not_null"
    
    # Date operations
    DATE_EQUALS = "date_eq"
    DATE_BEFORE = "date_before"
    DATE_AFTER = "date_after"


class AggregationType(str, Enum):
    """Supported aggregation types."""
    
    SUM = "sum"
    AVERAGE = "avg"
    MINIMUM = "min"
    MAXIMUM = "max"
    COUNT = "count"
    COUNT_DISTINCT = "count_distinct"
    NONE = "none"  # No aggregation


class ReportFormat(str, Enum):
    """Output format for reports."""
    
    TABLE = "table"
    CSV = "csv"
    EXCEL = "excel"
    JSON = "json"
    PDF = "pdf"


class ReportModule(str, Enum):
    """Available modules for custom reports."""
    
    BOOKINGS = "bookings"
    PAYMENTS = "payments"
    COMPLAINTS = "complaints"
    MAINTENANCE = "maintenance"
    ATTENDANCE = "attendance"
    STUDENTS = "students"
    HOSTELS = "hostels"
    ROOMS = "rooms"
    USERS = "users"
    ANNOUNCEMENTS = "announcements"
    REVIEWS = "reviews"


class CustomReportFilter(BaseSchema):
    """
    Filter definition for custom reports.
    
    Defines a single filter condition that can be applied
    to narrow down report data.
    """
    
    field_name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Field name to filter on"
    )
    operator: FilterOperator = Field(
        ...,
        description="Filter operator"
    )
    value: Union[str, int, float, bool, List[Any], None] = Field(
        ...,
        description="Filter value"
    )
    value_to: Optional[Union[str, int, float, None]] = Field(
        None,
        description="Second value for BETWEEN operator"
    )
    case_sensitive: bool = Field(
        False,
        description="Whether string comparison is case-sensitive"
    )
    
    @model_validator(mode="after")
    def validate_operator_value_compatibility(self) -> "CustomReportFilter":
        """Validate that operator and value are compatible."""
        
        # BETWEEN requires value_to
        if self.operator == FilterOperator.BETWEEN and self.value_to is None:
            raise ValueError("BETWEEN operator requires value_to")
        
        # IN/NOT_IN require list values
        if self.operator in [FilterOperator.IN, FilterOperator.NOT_IN]:
            if not isinstance(self.value, list):
                raise ValueError(f"{self.operator} requires a list value")
        
        # NULL checks don't need values
        if self.operator in [FilterOperator.IS_NULL, FilterOperator.IS_NOT_NULL]:
            if self.value is not None:
                raise ValueError(f"{self.operator} should not have a value")
        
        return self
    
    @computed_field
    @property
    def filter_display(self) -> str:
        """Generate human-readable filter description."""
        if self.operator == FilterOperator.BETWEEN:
            return f"{self.field_name} between {self.value} and {self.value_to}"
        elif self.operator in [FilterOperator.IN, FilterOperator.NOT_IN]:
            return f"{self.field_name} {self.operator.value} ({len(self.value)} items)"
        elif self.operator in [FilterOperator.IS_NULL, FilterOperator.IS_NOT_NULL]:
            return f"{self.field_name} {self.operator.value}"
        else:
            return f"{self.field_name} {self.operator.value} {self.value}"


class CustomReportField(BaseSchema):
    """
    Field definition for custom reports.
    
    Defines a field to include in the report with optional
    aggregation and custom display label.
    """
    
    field_name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Database field name"
    )
    display_label: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Custom display label for the field"
    )
    aggregation: AggregationType = Field(
        AggregationType.NONE,
        description="Aggregation function to apply"
    )
    format_string: Optional[str] = Field(
        None,
        max_length=50,
        description="Format string for display (e.g., '%.2f' for decimals)"
    )
    
    @field_validator("display_label")
    @classmethod
    def set_default_label(cls, v: Optional[str], info) -> str:
        """Set default display label from field name if not provided."""
        if v is None and "field_name" in info.data:
            # Convert snake_case to Title Case
            return info.data["field_name"].replace("_", " ").title()
        return v
    
    @computed_field
    @property
    def effective_label(self) -> str:
        """Get the effective display label."""
        if self.display_label:
            return self.display_label
        return self.field_name.replace("_", " ").title()


class CustomReportRequest(BaseCreateSchema):
    """
    Request schema for generating a custom report.
    
    Defines all parameters needed to generate a custom report
    including fields, filters, grouping, and output format.
    """
    
    report_name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Descriptive name for the report"
    )
    module: ReportModule = Field(
        ...,
        description="Module/entity to report on"
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Optional report description"
    )
    
    # Time period
    period: Optional[DateRangeFilter] = Field(
        None,
        description="Optional date range filter"
    )
    
    # Fields to include
    fields: List[CustomReportField] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Fields to include in the report"
    )
    
    # Filters
    filters: List[CustomReportFilter] = Field(
        default_factory=list,
        max_length=20,
        description="Filter conditions to apply"
    )
    
    # Grouping and aggregation
    group_by: Optional[List[str]] = Field(
        None,
        max_length=10,
        description="Field names to group by"
    )
    
    # Sorting
    sort_by: Optional[str] = Field(
        None,
        max_length=100,
        description="Field name to sort by"
    )
    sort_order: str = Field(
        "asc",
        pattern="^(asc|desc)$",
        description="Sort order: asc or desc"
    )
    
    # Pagination
    limit: Optional[int] = Field(
        None,
        ge=1,
        le=10000,
        description="Maximum number of rows to return"
    )
    offset: int = Field(
        0,
        ge=0,
        description="Number of rows to skip"
    )
    
    # Output options
    format: ReportFormat = Field(
        ReportFormat.TABLE,
        description="Output format"
    )
    include_summary: bool = Field(
        True,
        description="Include summary statistics"
    )
    include_charts: bool = Field(
        False,
        description="Include chart data/recommendations"
    )
    include_totals: bool = Field(
        True,
        description="Include column totals where applicable"
    )
    
    @field_validator("sort_order")
    @classmethod
    def normalize_sort_order(cls, v: str) -> str:
        """Normalize sort order to lowercase."""
        return v.lower()
    
    @model_validator(mode="after")
    def validate_grouping_and_aggregation(self) -> "CustomReportRequest":
        """Validate that grouping is compatible with aggregations."""
        
        if self.group_by:
            # When grouping, at least one field should have aggregation
            has_aggregation = any(
                field.aggregation != AggregationType.NONE
                for field in self.fields
            )
            
            # All non-aggregated fields should be in group_by
            for field in self.fields:
                if field.aggregation == AggregationType.NONE:
                    if field.field_name not in self.group_by:
                        raise ValueError(
                            f"Field '{field.field_name}' must be in group_by "
                            "or have an aggregation when grouping is used"
                        )
        
        return self
    
    @model_validator(mode="after")
    def validate_sort_field(self) -> "CustomReportRequest":
        """Validate sort field exists in selected fields."""
        
        if self.sort_by:
            field_names = [f.field_name for f in self.fields]
            if self.sort_by not in field_names:
                raise ValueError(
                    f"sort_by field '{self.sort_by}' must be included in fields"
                )
        
        return self
    
    def to_sql_hint(self) -> str:
        """
        Generate a SQL-like representation for debugging.
        
        Returns:
            SQL-like string representation of the report query.
        """
        field_str = ", ".join(
            f"{f.aggregation.value}({f.field_name})" if f.aggregation != AggregationType.NONE
            else f.field_name
            for f in self.fields
        )
        
        sql = f"SELECT {field_str} FROM {self.module.value}"
        
        if self.filters:
            filter_str = " AND ".join(f.filter_display for f in self.filters)
            sql += f" WHERE {filter_str}"
        
        if self.group_by:
            sql += f" GROUP BY {', '.join(self.group_by)}"
        
        if self.sort_by:
            sql += f" ORDER BY {self.sort_by} {self.sort_order.upper()}"
        
        if self.limit:
            sql += f" LIMIT {self.limit}"
        
        if self.offset:
            sql += f" OFFSET {self.offset}"
        
        return sql


class CustomReportDefinition(BaseResponseSchema):
    """
    Saved custom report definition.
    
    Represents a stored report configuration that can be
    reused and shared among users.
    """
    
    id: UUID = Field(
        ...,
        description="Report definition unique identifier"
    )
    owner_id: UUID = Field(
        ...,
        description="User who created the report"
    )
    report_name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Report name"
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="Report description"
    )
    module: ReportModule = Field(
        ...,
        description="Report module"
    )
    
    # Report configuration
    period: Optional[DateRangeFilter] = None
    fields: List[CustomReportField] = Field(..., min_length=1)
    filters: List[CustomReportFilter] = Field(default_factory=list)
    group_by: Optional[List[str]] = None
    sort_by: Optional[str] = None
    sort_order: str = Field("asc", pattern="^(asc|desc)$")
    
    # Sharing and permissions
    is_public: bool = Field(
        False,
        description="Whether report is publicly accessible"
    )
    is_template: bool = Field(
        False,
        description="Whether this is a system template"
    )
    shared_with_user_ids: List[UUID] = Field(
        default_factory=list,
        description="User IDs with access to this report"
    )
    shared_with_role: Optional[str] = Field(
        None,
        description="Role with access to this report"
    )
    
    # Usage tracking
    run_count: int = Field(
        0,
        ge=0,
        description="Number of times this report has been run"
    )
    last_run_at: Optional[datetime] = Field(
        None,
        description="Timestamp of last execution"
    )
    
    # Timestamps
    created_at: datetime = Field(
        ...,
        description="Creation timestamp"
    )
    updated_at: datetime = Field(
        ...,
        description="Last update timestamp"
    )
    
    @computed_field
    @property
    def is_shared(self) -> bool:
        """Check if report is shared with anyone."""
        return (
            self.is_public or
            bool(self.shared_with_user_ids) or
            self.shared_with_role is not None
        )
    
    @computed_field
    @property
    def complexity_score(self) -> int:
        """
        Calculate report complexity score (0-100).
        
        Based on number of fields, filters, grouping, etc.
        """
        score = 0
        score += min(len(self.fields) * 5, 25)  # Fields: max 25
        score += min(len(self.filters) * 10, 30)  # Filters: max 30
        score += 20 if self.group_by else 0  # Grouping: 20
        score += min(len(self.group_by or []) * 5, 15)  # Group fields: max 15
        score += 10 if any(f.aggregation != AggregationType.NONE for f in self.fields) else 0
        
        return min(score, 100)


class CustomReportResult(BaseSchema):
    """
    Result of executing a custom report.
    
    Contains the generated data, summary statistics,
    and optional chart data.
    """
    
    report_id: Optional[UUID] = Field(
        None,
        description="Report definition ID if using saved report"
    )
    report_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Report name"
    )
    module: ReportModule = Field(
        ...,
        description="Report module"
    )
    
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    execution_time_ms: Optional[int] = Field(
        None,
        ge=0,
        description="Query execution time in milliseconds"
    )
    
    # Result data
    rows: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Report data rows"
    )
    total_rows: int = Field(
        ...,
        ge=0,
        description="Total number of rows (may exceed returned rows if paginated)"
    )
    returned_rows: int = Field(
        ...,
        ge=0,
        description="Number of rows actually returned"
    )
    
    # Column metadata
    columns: List[CustomReportField] = Field(
        default_factory=list,
        description="Column definitions"
    )
    
    # Summary statistics
    summary: Optional[Dict[str, Any]] = Field(
        None,
        description="Aggregated summary statistics"
    )
    column_totals: Optional[Dict[str, Any]] = Field(
        None,
        description="Column-wise totals"
    )
    
    # Chart data
    charts: Optional[Dict[str, Any]] = Field(
        None,
        description="Suggested chart configurations and data"
    )
    
    # Metadata
    filters_applied: List[CustomReportFilter] = Field(
        default_factory=list,
        description="Filters that were applied"
    )
    grouping_applied: Optional[List[str]] = Field(
        None,
        description="Grouping fields that were applied"
    )
    
    @field_validator("returned_rows")
    @classmethod
    def validate_returned_rows(cls, v: int, info) -> int:
        """Validate returned_rows matches actual row count."""
        if "rows" in info.data and v != len(info.data["rows"]):
            raise ValueError(
                f"returned_rows ({v}) must match length of rows ({len(info.data['rows'])})"
            )
        return v
    
    @computed_field
    @property
    def is_paginated(self) -> bool:
        """Check if results are paginated."""
        return self.total_rows > self.returned_rows
    
    @computed_field
    @property
    def has_data(self) -> bool:
        """Check if report returned any data."""
        return self.returned_rows > 0
    
    def get_export_filename(self, format: ReportFormat) -> str:
        """
        Generate appropriate filename for export.
        
        Args:
            format: Export format
            
        Returns:
            Suggested filename with appropriate extension
        """
        # Sanitize report name
        safe_name = "".join(
            c if c.isalnum() or c in ('-', '_') else '_'
            for c in self.report_name
        )
        
        timestamp = self.generated_at.strftime("%Y%m%d_%H%M%S")
        extension = format.value
        
        return f"{safe_name}_{timestamp}.{extension}"


class ReportExportRequest(BaseSchema):
    """Request to export a report in specific format."""
    
    report_result_id: Optional[UUID] = Field(
        None,
        description="ID of cached report result to export"
    )
    format: ReportFormat = Field(
        ...,
        description="Export format"
    )
    include_metadata: bool = Field(
        True,
        description="Include report metadata in export"
    )
    include_filters: bool = Field(
        True,
        description="Include applied filters in export"
    )
    include_summary: bool = Field(
        True,
        description="Include summary in export"
    )


class ReportSchedule(BaseSchema):
    """Schedule configuration for recurring report generation."""
    
    report_id: UUID = Field(
        ...,
        description="Report definition to run"
    )
    schedule_name: str = Field(
        ...,
        min_length=3,
        max_length=255,
        description="Schedule name"
    )
    
    # Schedule configuration
    frequency: str = Field(
        ...,
        pattern="^(daily|weekly|monthly|quarterly)$",
        description="Report frequency"
    )
    time_of_day: str = Field(
        ...,
        pattern="^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
        description="Time to run (HH:MM format, 24-hour)"
    )
    day_of_week: Optional[int] = Field(
        None,
        ge=0,
        le=6,
        description="Day of week for weekly reports (0=Monday)"
    )
    day_of_month: Optional[int] = Field(
        None,
        ge=1,
        le=31,
        description="Day of month for monthly reports"
    )
    
    # Delivery configuration
    recipients: List[str] = Field(
        ...,
        min_length=1,
        description="Email addresses to send report to"
    )
    format: ReportFormat = Field(
        ReportFormat.PDF,
        description="Report format for delivery"
    )
    
    # Status
    is_active: bool = Field(
        True,
        description="Whether schedule is active"
    )
    last_run_at: Optional[datetime] = Field(
        None,
        description="Last execution timestamp"
    )
    next_run_at: Optional[datetime] = Field(
        None,
        description="Next scheduled execution"
    )
    
    @field_validator("recipients")
    @classmethod
    def validate_email_format(cls, v: List[str]) -> List[str]:
        """Basic email format validation."""
        import re
        email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
        
        for email in v:
            if not email_pattern.match(email):
                raise ValueError(f"Invalid email format: {email}")
        
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\dashboard_analytics.py ---
# --- File: app/schemas/analytics/dashboard_analytics.py ---
"""
Dashboard-level analytics schemas with role-based views.

Provides comprehensive dashboard metrics including:
- Key Performance Indicators (KPIs)
- Quick statistics for dashboard cards
- Time-series data for charts
- Role-specific dashboard configurations
"""

from datetime import date as Date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional, Union

from pydantic import Field, field_validator, computed_field
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import UserRole
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "KPIResponse",
    "QuickStats",
    "TimeseriesPoint",
    "DashboardMetrics",
    "RoleSpecificDashboard",
    "AlertNotification",
    "DashboardWidget",
]


class KPIResponse(BaseSchema):
    """
    Single Key Performance Indicator for dashboard display.
    
    Represents a measurable metric with trend information,
    targets, and interpretation guidelines.
    """
    
    name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="KPI display name"
    )
    key: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Unique identifier key for the KPI"
    )
    value: Union[Decimal, int, float] = Field(
        ...,
        description="Current KPI value"
    )
    unit: Optional[str] = Field(
        None,
        max_length=20,
        description="Unit of measurement (e.g., 'INR', '%', 'students')"
    )
    
    # Trend analysis
    trend_direction: Optional[str] = Field(
        None,
        pattern="^(up|down|stable)$",
        description="Trend indicator vs previous period"
    )
    trend_percentage: Optional[Decimal] = Field(
        None,
        description="Percentage change vs previous period"
    )
    previous_value: Optional[Union[Decimal, int, float]] = Field(
        None,
        description="Value from previous period for comparison"
    )
    
    # Target and context
    target_value: Optional[Decimal] = Field(
        None,
        description="Target/goal value for this KPI"
    )
    good_when: Optional[str] = Field(
        None,
        pattern="^(higher_is_better|lower_is_better|closer_to_target)$",
        description="Interpretation rule for the KPI"
    )
    
    # Display hints
    format_pattern: Optional[str] = Field(
        None,
        max_length=50,
        description="Format pattern for display (e.g., '%.2f')"
    )
    icon: Optional[str] = Field(
        None,
        max_length=50,
        description="Icon identifier for UI"
    )
    color: Optional[str] = Field(
        None,
        pattern="^#[0-9A-Fa-f]{6}$",
        description="Hex color code for UI theming"
    )
    
    @field_validator("trend_percentage")
    @classmethod
    def validate_trend_percentage(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Round trend percentage to 2 decimal places."""
        if v is not None:
            return round(v, 2)
        return v
    
    @computed_field
    @property
    def is_on_target(self) -> Optional[bool]:
        """Check if current value meets target."""
        if self.target_value is None:
            return None
        
        if self.good_when == "higher_is_better":
            return float(self.value) >= float(self.target_value)
        elif self.good_when == "lower_is_better":
            return float(self.value) <= float(self.target_value)
        elif self.good_when == "closer_to_target":
            # Within 5% of target is considered on-target
            tolerance = float(self.target_value) * 0.05
            return abs(float(self.value) - float(self.target_value)) <= tolerance
        
        return None
    
    @computed_field
    @property
    def performance_status(self) -> str:
        """
        Get performance status: 'excellent', 'good', 'warning', 'critical'.
        """
        if self.target_value is None or self.good_when is None:
            return "unknown"
        
        value_float = float(self.value)
        target_float = float(self.target_value)
        
        if self.good_when == "higher_is_better":
            ratio = value_float / target_float if target_float > 0 else 0
            if ratio >= 1.1:
                return "excellent"
            elif ratio >= 1.0:
                return "good"
            elif ratio >= 0.9:
                return "warning"
            else:
                return "critical"
        
        elif self.good_when == "lower_is_better":
            ratio = target_float / value_float if value_float > 0 else float('inf')
            if ratio >= 1.1:
                return "excellent"
            elif ratio >= 1.0:
                return "good"
            elif ratio >= 0.9:
                return "warning"
            else:
                return "critical"
        
        elif self.good_when == "closer_to_target":
            deviation = abs(value_float - target_float) / target_float if target_float > 0 else 0
            if deviation <= 0.05:
                return "excellent"
            elif deviation <= 0.10:
                return "good"
            elif deviation <= 0.20:
                return "warning"
            else:
                return "critical"
        
        return "unknown"
    
    def format_value(self) -> str:
        """Format value for display using format_pattern."""
        if self.format_pattern:
            try:
                return self.format_pattern % float(self.value)
            except (ValueError, TypeError):
                pass
        
        # Default formatting
        if self.unit == "%":
            return f"{float(self.value):.2f}%"
        elif self.unit == "INR":
            return f"{float(self.value):,.2f}"
        else:
            return f"{self.value}"


class QuickStats(BaseSchema):
    """
    Quick statistics for dashboard cards.
    
    Provides snapshot metrics for immediate visibility
    into system state and operations.
    """
    
    # Hostel metrics
    total_hostels: int = Field(
        ...,
        ge=0,
        description="Total number of hostels in system"
    )
    active_hostels: int = Field(
        ...,
        ge=0,
        description="Number of active hostels"
    )
    
    # Student metrics
    total_students: int = Field(
        ...,
        ge=0,
        description="Total registered students"
    )
    active_students: int = Field(
        ...,
        ge=0,
        description="Currently active students"
    )
    
    # Visitor metrics
    total_visitors: int = Field(
        0,
        ge=0,
        description="Total registered visitors"
    )
    active_visitors: int = Field(
        0,
        ge=0,
        description="Currently active visitors"
    )
    
    # Daily operations
    todays_check_ins: int = Field(
        ...,
        ge=0,
        description="Check-ins scheduled for today"
    )
    todays_check_outs: int = Field(
        ...,
        ge=0,
        description="Check-outs scheduled for today"
    )
    
    # Issues and maintenance
    open_complaints: int = Field(
        ...,
        ge=0,
        description="Currently open complaints"
    )
    urgent_complaints: int = Field(
        0,
        ge=0,
        description="Urgent/critical complaints"
    )
    pending_maintenance: int = Field(
        ...,
        ge=0,
        description="Pending maintenance requests"
    )
    overdue_maintenance: int = Field(
        0,
        ge=0,
        description="Overdue maintenance requests"
    )
    
    # Financial metrics
    todays_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Revenue collected today"
    )
    monthly_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Revenue for current month"
    )
    outstanding_payments: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total outstanding payment amount"
    )
    overdue_payments: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Overdue payment amount"
    )
    
    @field_validator(
        "active_hostels",
        "active_students",
        "active_visitors"
    )
    @classmethod
    def validate_active_counts(cls, v: int, info) -> int:
        """Validate active counts don't exceed totals."""
        field_name = info.field_name
        
        if field_name == "active_hostels" and "total_hostels" in info.data:
            if v > info.data["total_hostels"]:
                raise ValueError("active_hostels cannot exceed total_hostels")
        elif field_name == "active_students" and "total_students" in info.data:
            if v > info.data["total_students"]:
                raise ValueError("active_students cannot exceed total_students")
        elif field_name == "active_visitors" and "total_visitors" in info.data:
            if v > info.data["total_visitors"]:
                raise ValueError("active_visitors cannot exceed total_visitors")
        
        return v
    
    @computed_field
    @property
    def occupancy_rate(self) -> Decimal:
        """Calculate approximate occupancy rate."""
        if self.total_students == 0:
            return Decimal("0.00")
        # Simplified calculation - would need total bed count for accuracy
        return round(
            (Decimal(self.active_students) / Decimal(self.total_students)) * 100,
            2
        )
    
    @computed_field
    @property
    def complaint_urgency_rate(self) -> Decimal:
        """Calculate percentage of urgent complaints."""
        if self.open_complaints == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.urgent_complaints) / Decimal(self.open_complaints)) * 100,
            2
        )
    
    @computed_field
    @property
    def payment_collection_health(self) -> str:
        """Assess payment collection health."""
        if self.outstanding_payments == 0:
            return "excellent"
        
        overdue_ratio = (
            self.overdue_payments / self.outstanding_payments
            if self.outstanding_payments > 0
            else 0
        )
        
        if overdue_ratio <= 0.1:
            return "good"
        elif overdue_ratio <= 0.25:
            return "warning"
        else:
            return "critical"


class TimeseriesPoint(BaseSchema):
    """
    Single data point in a time series.
    """

    date_: Date = Field(
        ...,
        description="Date of the data point"
    )
    value: Union[Decimal, int, float] = Field(
        ...,
        description="Metric value"
    )
    label: Optional[str] = Field(
        None,
        max_length=100,
        description="Optional label for this point"
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description="Additional metadata for this point"
    )

    @computed_field
    @property
    def formatted_date(self) -> str:
        """Get formatted date string."""
        return self.date_.strftime("%Y-%m-%d")



class AlertNotification(BaseSchema):
    """Dashboard alert notification."""
    
    id: UUID = Field(
        ...,
        description="Alert identifier"
    )
    severity: str = Field(
        ...,
        pattern="^(info|warning|error|critical)$",
        description="Alert severity level"
    )
    title: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Alert title"
    )
    message: str = Field(
        ...,
        min_length=1,
        max_length=1000,
        description="Alert message"
    )
    action_url: Optional[str] = Field(
        None,
        max_length=500,
        description="URL for alert action"
    )
    action_label: Optional[str] = Field(
        None,
        max_length=100,
        description="Label for action button"
    )
    created_at: datetime = Field(
        ...,
        description="Alert creation time"
    )
    expires_at: Optional[datetime] = Field(
        None,
        description="Alert expiration time"
    )
    is_dismissed: bool = Field(
        False,
        description="Whether alert has been dismissed"
    )
    
    @computed_field
    @property
    def is_active(self) -> bool:
        """Check if alert is still active."""
        if self.is_dismissed:
            return False
        if self.expires_at and datetime.utcnow() > self.expires_at:
            return False
        return True


class DashboardWidget(BaseSchema):
    """Configuration for a dashboard widget."""
    
    widget_id: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Unique widget identifier"
    )
    widget_type: str = Field(
        ...,
        pattern="^(kpi|chart|table|list|stat)$",
        description="Widget type"
    )
    title: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Widget title"
    )
    position: int = Field(
        ...,
        ge=0,
        description="Display position/order"
    )
    size: str = Field(
        "medium",
        pattern="^(small|medium|large|full)$",
        description="Widget size"
    )
    data_source: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Data source identifier"
    )
    refresh_interval_seconds: Optional[int] = Field(
        None,
        ge=10,
        description="Auto-refresh interval in seconds"
    )
    is_visible: bool = Field(
        True,
        description="Whether widget is visible"
    )


class DashboardMetrics(BaseSchema):
    """
    Aggregated dashboard metrics for a given scope.
    
    Provides comprehensive analytics tailored to specific
    scope (hostel, platform, or admin).
    """
    
    scope_type: str = Field(
        ...,
        pattern="^(hostel|platform|admin)$",
        description="Scope of the dashboard"
    )
    scope_id: Optional[UUID] = Field(
        None,
        description="Hostel ID or admin ID if applicable"
    )
    scope_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Display name for the scope"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Dashboard generation timestamp"
    )
    
    # Core metrics
    kpis: List[KPIResponse] = Field(
        default_factory=list,
        description="Key performance indicators"
    )
    quick_stats: QuickStats = Field(
        ...,
        description="Quick statistics for dashboard cards"
    )
    
    # Time series data for charts
    revenue_timeseries: List[TimeseriesPoint] = Field(
        default_factory=list,
        description="Revenue over time"
    )
    occupancy_timeseries: List[TimeseriesPoint] = Field(
        default_factory=list,
        description="Occupancy rate over time"
    )
    booking_timeseries: List[TimeseriesPoint] = Field(
        default_factory=list,
        description="Bookings over time"
    )
    complaint_timeseries: List[TimeseriesPoint] = Field(
        default_factory=list,
        description="Complaints over time"
    )
    
    # Alerts and notifications
    alerts: List[AlertNotification] = Field(
        default_factory=list,
        description="Active alerts for this dashboard"
    )
    
    # Custom widgets
    widgets: List[DashboardWidget] = Field(
        default_factory=list,
        description="Custom dashboard widgets"
    )
    
    @field_validator(
        "revenue_timeseries",
        "occupancy_timeseries",
        "booking_timeseries",
        "complaint_timeseries"
    )
    @classmethod
    def validate_timeseries_chronological(
        cls,
        v: List[TimeseriesPoint]
    ) -> List[TimeseriesPoint]:
        """Ensure timeseries data is in chronological order."""
        if len(v) > 1:
            dates = [point.Date for point in v]
            if dates != sorted(dates):
                raise ValueError("Timeseries points must be in chronological order")
        return v
    
    @computed_field
    @property
    def active_alert_count(self) -> int:
        """Count of active alerts."""
        return sum(1 for alert in self.alerts if alert.is_active)
    
    @computed_field
    @property
    def critical_alert_count(self) -> int:
        """Count of critical active alerts."""
        return sum(
            1 for alert in self.alerts
            if alert.is_active and alert.severity == "critical"
        )
    
    def get_kpi_by_key(self, key: str) -> Optional[KPIResponse]:
        """Retrieve a specific KPI by its key."""
        for kpi in self.kpis:
            if kpi.key == key:
                return kpi
        return None
    
    def get_trending_kpis(self) -> List[KPIResponse]:
        """Get KPIs that are trending (up or down)."""
        return [
            kpi for kpi in self.kpis
            if kpi.trend_direction and kpi.trend_direction != "stable"
        ]
    
    def get_off_target_kpis(self) -> List[KPIResponse]:
        """Get KPIs that are not meeting targets."""
        return [
            kpi for kpi in self.kpis
            if kpi.is_on_target is False
        ]


class RoleSpecificDashboard(BaseSchema):
    """
    Role-specific dashboard configuration and data.
    
    Provides customized dashboard views based on user role,
    showing only relevant metrics and actions.
    """
    
    role: UserRole = Field(
        ...,
        description="User role for this dashboard"
    )
    user_id: UUID = Field(
        ...,
        description="User identifier"
    )
    user_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="User display name"
    )
    
    # Section-based organization
    sections: List[str] = Field(
        default_factory=list,
        description="Dashboard section identifiers"
    )
    
    # Metrics organized by section
    metrics_by_section: Dict[str, DashboardMetrics] = Field(
        default_factory=dict,
        description="Section name -> Dashboard metrics"
    )
    
    # Quick stats organized by section
    stats_by_section: Dict[str, QuickStats] = Field(
        default_factory=dict,
        description="Section name -> Quick stats"
    )
    
    # KPIs organized by section
    kpis_by_section: Dict[str, List[KPIResponse]] = Field(
        default_factory=dict,
        description="Section name -> KPI list"
    )
    
    # Permissions
    accessible_features: List[str] = Field(
        default_factory=list,
        description="List of features accessible to this role"
    )
    
    # Preferences
    default_section: Optional[str] = Field(
        None,
        description="Default section to display"
    )
    layout_preferences: Optional[Dict[str, Any]] = Field(
        None,
        description="User's layout preferences"
    )
    
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Dashboard generation timestamp"
    )
    
    @computed_field
    @property
    def total_kpi_count(self) -> int:
        """Total number of KPIs across all sections."""
        return sum(len(kpis) for kpis in self.kpis_by_section.values())
    
    @computed_field
    @property
    def has_critical_alerts(self) -> bool:
        """Check if any section has critical alerts."""
        for metrics in self.metrics_by_section.values():
            if metrics.critical_alert_count > 0:
                return True
        return False
    
    def get_section_metrics(self, section_name: str) -> Optional[DashboardMetrics]:
        """Get metrics for a specific section."""
        return self.metrics_by_section.get(section_name)
    
    def get_all_alerts(self) -> List[AlertNotification]:
        """Get all alerts from all sections."""
        all_alerts = []
        for metrics in self.metrics_by_section.values():
            all_alerts.extend(metrics.alerts)
        
        # Sort by severity and creation time
        severity_order = {"critical": 0, "error": 1, "warning": 2, "info": 3}
        return sorted(
            all_alerts,
            key=lambda x: (severity_order.get(x.severity, 999), x.created_at),
            reverse=True
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\financial_analytics.py ---
# --- File: app/schemas/analytics/financial_analytics.py ---
"""
Financial analytics schemas with comprehensive P&L and cashflow tracking.

Provides detailed financial analytics including:
- Revenue and expense breakdowns
- Profit & Loss statements
- Cashflow analysis and forecasting
- Financial ratios and metrics
- Budget vs. actual comparisons
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional, Any
from enum import Enum

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import PaymentType
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "RevenueCategory",
    "ExpenseCategory",
    "RevenueBreakdown",
    "ExpenseBreakdown",
    "ProfitAndLossReport",
    "CashflowPoint",
    "CashflowSummary",
    "FinancialRatios",
    "BudgetComparison",
    "FinancialReport",
    "TaxSummary",
]


class RevenueCategory(str, Enum):
    """Revenue categories for financial reporting."""
    
    BOOKING = "booking"
    RENT = "rent"
    MESS = "mess"
    UTILITIES = "utilities"
    LATE_FEES = "late_fees"
    SECURITY_DEPOSIT = "security_deposit"
    OTHER = "other"


class ExpenseCategory(str, Enum):
    """Expense categories for financial reporting."""
    
    MAINTENANCE = "maintenance"
    STAFF_SALARIES = "staff_salaries"
    UTILITIES = "utilities"
    SUPPLIES = "supplies"
    MARKETING = "marketing"
    ADMINISTRATIVE = "administrative"
    DEPRECIATION = "depreciation"
    INSURANCE = "insurance"
    TAXES = "taxes"
    OTHER = "other"


class RevenueBreakdown(BaseSchema):
    """
    Detailed breakdown of revenue by source and type.
    
    Provides granular visibility into revenue streams
    for financial analysis and planning.
    """
    
    # Total revenue
    total_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total revenue for the period"
    )
    
    # Revenue by type
    booking_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Revenue from new bookings"
    )
    rent_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly/periodic rent revenue"
    )
    mess_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Mess/food service revenue"
    )
    utility_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Utility charges collected"
    )
    late_fee_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Late payment fees"
    )
    other_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Other miscellaneous revenue"
    )
    
    # Breakdown by hostel
    revenue_by_hostel: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Revenue mapped by hostel ID"
    )
    
    # Breakdown by payment type
    revenue_by_payment_type: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Revenue by PaymentType category"
    )
    
    # Collection metrics
    billed_amount: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Total amount billed in period"
    )
    collected_amount: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Amount actually collected"
    )
    pending_amount: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Amount pending collection"
    )
    
    @model_validator(mode="after")
    def validate_revenue_totals(self) -> "RevenueBreakdown":
        """Validate that component revenues sum to total."""
        component_sum = (
            self.booking_revenue +
            self.rent_revenue +
            self.mess_revenue +
            self.utility_revenue +
            self.late_fee_revenue +
            self.other_revenue
        )
        
        # Allow 0.01 tolerance for rounding
        if abs(component_sum - self.total_revenue) > Decimal("0.01"):
            raise ValueError(
                f"Component revenues ({component_sum}) must sum to "
                f"total_revenue ({self.total_revenue})"
            )
        
        return self
    
    @computed_field
    @property
    def collection_rate(self) -> Decimal:
        """Calculate collection rate percentage."""
        if self.billed_amount == 0:
            return Decimal("100.00")
        return round(
            (self.collected_amount / self.billed_amount) * 100,
            2
        )
    
    @computed_field
    @property
    def primary_revenue_source(self) -> str:
        """Identify the largest revenue source."""
        sources = {
            "booking": self.booking_revenue,
            "rent": self.rent_revenue,
            "mess": self.mess_revenue,
            "utilities": self.utility_revenue,
            "late_fees": self.late_fee_revenue,
            "other": self.other_revenue,
        }
        return max(sources, key=sources.get)
    
    @computed_field
    @property
    def revenue_concentration_risk(self) -> str:
        """
        Assess revenue concentration risk.
        
        Returns:
            'low', 'medium', or 'high' based on revenue diversification
        """
        if self.total_revenue == 0:
            return "unknown"
        
        # Calculate percentage from largest source
        largest_source_pct = (
            float(max(
                self.booking_revenue,
                self.rent_revenue,
                self.mess_revenue
            )) / float(self.total_revenue) * 100
        )
        
        if largest_source_pct >= 70:
            return "high"
        elif largest_source_pct >= 50:
            return "medium"
        else:
            return "low"


class ExpenseBreakdown(BaseSchema):
    """
    Detailed breakdown of expenses by category.
    
    Provides granular visibility into cost structure
    for financial control and optimization.
    """
    
    # Total expenses
    total_expenses: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total expenses for the period"
    )
    
    # Expense by category
    maintenance_expenses: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Maintenance and repair expenses"
    )
    staff_expenses: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Staff salaries and benefits"
    )
    utility_expenses: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Utility expenses (electricity, water, etc.)"
    )
    supply_expenses: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Supplies and consumables"
    )
    marketing_expenses: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Marketing and advertising expenses"
    )
    administrative_expenses: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Administrative and overhead expenses"
    )
    other_expenses: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Other miscellaneous expenses"
    )
    
    # Breakdown by hostel
    expenses_by_hostel: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Expenses mapped by hostel ID"
    )
    
    # Breakdown by category (detailed)
    expenses_by_category: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Expenses by ExpenseCategory"
    )
    
    # Fixed vs. Variable
    fixed_expenses: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Fixed expenses (rent, salaries, etc.)"
    )
    variable_expenses: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Variable expenses (utilities, supplies, etc.)"
    )
    
    @model_validator(mode="after")
    def validate_expense_totals(self) -> "ExpenseBreakdown":
        """Validate that component expenses sum to total."""
        component_sum = (
            self.maintenance_expenses +
            self.staff_expenses +
            self.utility_expenses +
            self.supply_expenses +
            self.marketing_expenses +
            self.administrative_expenses +
            self.other_expenses
        )
        
        # Allow 0.01 tolerance for rounding
        if abs(component_sum - self.total_expenses) > Decimal("0.01"):
            raise ValueError(
                f"Component expenses ({component_sum}) must sum to "
                f"total_expenses ({self.total_expenses})"
            )
        
        return self
    
    @computed_field
    @property
    def largest_expense_category(self) -> str:
        """Identify the largest expense category."""
        categories = {
            "maintenance": self.maintenance_expenses,
            "staff": self.staff_expenses,
            "utilities": self.utility_expenses,
            "supplies": self.supply_expenses,
            "marketing": self.marketing_expenses,
            "administrative": self.administrative_expenses,
            "other": self.other_expenses,
        }
        return max(categories, key=categories.get)
    
    @computed_field
    @property
    def expense_ratio_staff(self) -> Decimal:
        """Calculate staff expense as percentage of total."""
        if self.total_expenses == 0:
            return Decimal("0.00")
        return round(
            (self.staff_expenses / self.total_expenses) * 100,
            2
        )


class FinancialRatios(BaseSchema):
    """
    Key financial ratios and metrics.
    
    Provides analytical ratios for financial health assessment
    and performance benchmarking.
    """
    
    # Profitability ratios
    gross_profit_margin: Decimal = Field(
        ...,
        decimal_places=2,
        description="Gross profit margin percentage"
    )
    net_profit_margin: Decimal = Field(
        ...,
        decimal_places=2,
        description="Net profit margin percentage"
    )
    return_on_revenue: Decimal = Field(
        ...,
        decimal_places=2,
        description="Return on revenue percentage"
    )
    
    # Efficiency ratios
    operating_expense_ratio: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Operating expenses as % of revenue"
    )
    revenue_per_bed: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average revenue per bed"
    )
    revenue_per_student: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average revenue per student"
    )
    
    # Collection ratios
    collection_efficiency: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Collection efficiency percentage"
    )
    days_sales_outstanding: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Average days to collect payment"
    )
    
    # Cost control
    variable_cost_ratio: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Variable costs as % of revenue"
    )
    fixed_cost_ratio: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Fixed costs as % of revenue"
    )
    
    @computed_field
    @property
    def profitability_status(self) -> str:
        """Assess overall profitability status."""
        if self.net_profit_margin >= 20:
            return "excellent"
        elif self.net_profit_margin >= 10:
            return "good"
        elif self.net_profit_margin >= 0:
            return "moderate"
        else:
            return "loss"


class BudgetComparison(BaseSchema):
    """
    Budget vs. actual comparison.
    
    Compares actual financial performance against
    budgeted targets for variance analysis.
    """
    
    category: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Budget category (revenue/expense type)"
    )
    budgeted_amount: Decimal = Field(
        ...,
        decimal_places=2,
        description="Budgeted amount for the period"
    )
    actual_amount: Decimal = Field(
        ...,
        decimal_places=2,
        description="Actual amount for the period"
    )
    variance_amount: Decimal = Field(
        ...,
        decimal_places=2,
        description="Variance (actual - budgeted)"
    )
    variance_percentage: Decimal = Field(
        ...,
        decimal_places=2,
        description="Variance as percentage of budget"
    )
    
    @computed_field
    @property
    def is_favorable(self) -> bool:
        """
        Determine if variance is favorable.
        
        For revenue: actual > budgeted is favorable
        For expenses: actual < budgeted is favorable
        """
        # Assume revenue categories have positive variance when favorable
        # This should be contextualized by the caller
        return self.variance_amount >= 0
    
    @computed_field
    @property
    def variance_severity(self) -> str:
        """Assess severity of budget variance."""
        abs_variance_pct = abs(float(self.variance_percentage))
        
        if abs_variance_pct <= 5:
            return "minor"
        elif abs_variance_pct <= 15:
            return "moderate"
        elif abs_variance_pct <= 30:
            return "significant"
        else:
            return "critical"


class TaxSummary(BaseSchema):
    """
    Tax-related summary for financial reporting.
    
    Provides tax liability and compliance information.
    """
    
    taxable_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Revenue subject to taxation"
    )
    tax_exempt_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Tax-exempt revenue"
    )
    
    # Tax liabilities
    gst_collected: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="GST collected from customers"
    )
    gst_paid: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="GST paid on expenses"
    )
    gst_payable: Decimal = Field(
        0,
        decimal_places=2,
        description="Net GST payable (collected - paid)"
    )
    
    tds_deducted: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="TDS deducted at source"
    )
    
    estimated_income_tax: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Estimated income tax liability"
    )
    
    @computed_field
    @property
    def effective_tax_rate(self) -> Decimal:
        """Calculate effective tax rate."""
        if self.taxable_revenue == 0:
            return Decimal("0.00")
        
        total_tax = self.gst_payable + self.estimated_income_tax
        return round(
            (total_tax / self.taxable_revenue) * 100,
            2
        )


class ProfitAndLossReport(BaseSchema):
    """
    Profit & Loss (P&L) statement.
    
    Comprehensive income statement showing revenue,
    expenses, and profitability for a period.
    """
    
    scope_type: str = Field(
        ...,
        pattern="^(hostel|platform)$",
        description="Scope of the P&L report"
    )
    scope_id: Optional[UUID] = Field(
        None,
        description="Hostel ID if scope is hostel"
    )
    scope_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Display name for the scope"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Reporting period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Revenue and expenses
    revenue: RevenueBreakdown = Field(
        ...,
        description="Revenue breakdown"
    )
    expenses: ExpenseBreakdown = Field(
        ...,
        description="Expense breakdown"
    )
    
    # Calculated values
    gross_profit: Decimal = Field(
        ...,
        decimal_places=2,
        description="Gross profit (revenue - direct costs)"
    )
    operating_profit: Decimal = Field(
        ...,
        decimal_places=2,
        description="Operating profit (gross profit - operating expenses)"
    )
    net_profit: Decimal = Field(
        ...,
        decimal_places=2,
        description="Net profit after all expenses"
    )
    
    # Margins
    gross_profit_margin: Decimal = Field(
        ...,
        decimal_places=2,
        description="Gross profit margin percentage"
    )
    operating_profit_margin: Decimal = Field(
        ...,
        decimal_places=2,
        description="Operating profit margin percentage"
    )
    net_profit_margin: Decimal = Field(
        ...,
        decimal_places=2,
        description="Net profit margin percentage"
    )
    
    # Legacy field
    profit_margin_percentage: Decimal = Field(
        ...,
        decimal_places=2,
        description="Profit margin percentage (deprecated: use net_profit_margin)"
    )
    
    # Financial ratios
    ratios: Optional[FinancialRatios] = Field(
        None,
        description="Key financial ratios"
    )
    
    # Tax information
    tax_summary: Optional[TaxSummary] = Field(
        None,
        description="Tax-related summary"
    )
    
    # Budget comparison
    budget_comparisons: List[BudgetComparison] = Field(
        default_factory=list,
        description="Budget vs. actual comparisons"
    )
    
    @model_validator(mode="after")
    def validate_profit_calculations(self) -> "ProfitAndLossReport":
        """Validate profit calculations are consistent."""
        
        # Gross profit should be revenue - cost of goods sold
        # For simplicity, assuming gross profit equals revenue - variable costs
        expected_gross = self.revenue.total_revenue - self.expenses.variable_expenses
        if abs(self.gross_profit - expected_gross) > Decimal("0.01"):
            # Log warning but don't fail - calculations may vary by implementation
            pass
        
        # Net profit should be revenue - total expenses
        expected_net = self.revenue.total_revenue - self.expenses.total_expenses
        if abs(self.net_profit - expected_net) > Decimal("0.01"):
            raise ValueError(
                f"Net profit ({self.net_profit}) should equal "
                f"revenue ({self.revenue.total_revenue}) - "
                f"expenses ({self.expenses.total_expenses})"
            )
        
        return self
    
    @computed_field
    @property
    def is_profitable(self) -> bool:
        """Check if the period was profitable."""
        return self.net_profit > 0
    
    @computed_field
    @property
    def break_even_revenue(self) -> Decimal:
        """
        Calculate break-even revenue.
        
        Revenue needed to cover all expenses.
        """
        return self.expenses.total_expenses
    
    @computed_field
    @property
    def revenue_above_break_even(self) -> Decimal:
        """Calculate revenue above break-even point."""
        return max(
            Decimal("0.00"),
            self.revenue.total_revenue - self.break_even_revenue
        )
    
    def get_performance_summary(self) -> Dict[str, Any]:
        """
        Generate performance summary.
        
        Returns:
            Dictionary with key performance insights
        """
        return {
            "is_profitable": self.is_profitable,
            "profitability_status": self.ratios.profitability_status if self.ratios else "unknown",
            "net_profit": float(self.net_profit),
            "net_profit_margin": float(self.net_profit_margin),
            "revenue_growth_needed": (
                0 if self.is_profitable
                else float(self.break_even_revenue - self.revenue.total_revenue)
            ),
            "largest_revenue_source": self.revenue.primary_revenue_source,
            "largest_expense_category": self.expenses.largest_expense_category,
            "collection_rate": float(self.revenue.collection_rate),
        }


class CashflowPoint(BaseSchema):
    """
    Single data point in cashflow time series.
    
    Represents cash movements for a specific date.
    """
    
    cashflow_date: date = Field(
        ...,
        description="Date of cashflow point"
    )
    inflow: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Cash inflow for the day"
    )
    outflow: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Cash outflow for the day"
    )
    net_flow: Decimal = Field(
        ...,
        decimal_places=2,
        description="Net cashflow (inflow - outflow)"
    )
    balance: Decimal = Field(
        ...,
        decimal_places=2,
        description="Cumulative balance after this transaction"
    )
    
    @model_validator(mode="after")
    def validate_net_flow(self) -> "CashflowPoint":
        """Validate net flow calculation."""
        expected_net = self.inflow - self.outflow
        if abs(self.net_flow - expected_net) > Decimal("0.01"):
            raise ValueError(
                f"Net flow ({self.net_flow}) should equal "
                f"inflow ({self.inflow}) - outflow ({self.outflow})"
            )
        return self
    
    @computed_field
    @property
    def is_positive_flow(self) -> bool:
        """Check if net flow is positive."""
        return self.net_flow > 0


class CashflowSummary(BaseSchema):
    """
    Cashflow summary and analysis.
    
    Provides comprehensive view of cash movements,
    working capital, and liquidity position.
    """
    
    scope_type: str = Field(
        ...,
        pattern="^(hostel|platform)$",
        description="Scope of cashflow analysis"
    )
    scope_id: Optional[UUID] = Field(
        None,
        description="Hostel ID if scope is hostel"
    )
    scope_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Display name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Balances
    opening_balance: Decimal = Field(
        ...,
        decimal_places=2,
        description="Cash balance at start of period"
    )
    closing_balance: Decimal = Field(
        ...,
        decimal_places=2,
        description="Cash balance at end of period"
    )
    
    # Totals
    total_inflows: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total cash inflows during period"
    )
    total_outflows: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total cash outflows during period"
    )
    net_cashflow: Decimal = Field(
        ...,
        decimal_places=2,
        description="Net cashflow for the period"
    )
    
    # Legacy fields
    inflows: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total inflows (deprecated: use total_inflows)"
    )
    outflows: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total outflows (deprecated: use total_outflows)"
    )
    
    # Breakdowns
    inflow_breakdown: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Inflows by category"
    )
    outflow_breakdown: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Outflows by category"
    )
    
    # Time series
    cashflow_timeseries: List[CashflowPoint] = Field(
        default_factory=list,
        description="Daily cashflow data points"
    )
    
    # Liquidity metrics
    average_daily_balance: Decimal = Field(
        0,
        decimal_places=2,
        description="Average daily cash balance"
    )
    minimum_balance: Decimal = Field(
        0,
        decimal_places=2,
        description="Minimum balance during period"
    )
    maximum_balance: Decimal = Field(
        0,
        decimal_places=2,
        description="Maximum balance during period"
    )
    
    @model_validator(mode="after")
    def validate_cashflow_consistency(self) -> "CashflowSummary":
        """Validate cashflow calculations are consistent."""
        
        # Net cashflow should equal closing - opening
        expected_net = self.closing_balance - self.opening_balance
        if abs(self.net_cashflow - expected_net) > Decimal("0.01"):
            raise ValueError(
                f"Net cashflow ({self.net_cashflow}) should equal "
                f"closing ({self.closing_balance}) - opening ({self.opening_balance})"
            )
        
        # Net cashflow should also equal inflows - outflows
        expected_net_2 = self.total_inflows - self.total_outflows
        if abs(self.net_cashflow - expected_net_2) > Decimal("0.01"):
            raise ValueError(
                f"Net cashflow ({self.net_cashflow}) should equal "
                f"inflows ({self.total_inflows}) - outflows ({self.total_outflows})"
            )
        
        return self
    
    @field_validator("cashflow_timeseries")
    @classmethod
    def validate_chronological_order(
        cls,
        v: List[CashflowPoint]
    ) -> List[CashflowPoint]:
        """Ensure cashflow points are chronological."""
        if len(v) > 1:
            dates = [point.date for point in v]
            if dates != sorted(dates):
                raise ValueError("Cashflow points must be in chronological order")
        return v
    
    @computed_field
    @property
    def cashflow_health(self) -> str:
        """Assess overall cashflow health."""
        if self.closing_balance < 0:
            return "critical"
        elif self.net_cashflow < 0:
            return "warning"
        elif self.net_cashflow > self.total_outflows * Decimal("0.2"):
            return "excellent"
        else:
            return "good"
    
    @computed_field
    @property
    def burn_rate_days(self) -> Optional[int]:
        """
        Calculate runway in days based on current burn rate.
        
        Returns:
            Number of days until cash runs out at current rate,
            or None if cashflow is positive
        """
        if self.net_cashflow >= 0:
            return None
        
        if len(self.cashflow_timeseries) == 0:
            return None
        
        # Calculate average daily burn
        days = len(self.cashflow_timeseries)
        daily_burn = abs(self.net_cashflow / Decimal(days))
        
        if daily_burn == 0:
            return None
        
        return int(self.closing_balance / daily_burn)
    
    @computed_field
    @property
    def operating_cash_ratio(self) -> Decimal:
        """Calculate operating cash flow ratio."""
        if self.total_outflows == 0:
            return Decimal("0.00")
        return round(
            (self.total_inflows / self.total_outflows) * 100,
            2
        )


class FinancialReport(BaseSchema):
    """
    Comprehensive financial report.
    
    Consolidates P&L, cashflow, and key financial metrics
    into a single comprehensive financial statement.
    """
    
    scope_type: str = Field(
        ...,
        pattern="^(hostel|platform)$",
        description="Report scope"
    )
    scope_id: Optional[UUID] = Field(
        None,
        description="Hostel ID if applicable"
    )
    scope_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Display name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Reporting period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Core financial statements
    pnl_report: ProfitAndLossReport = Field(
        ...,
        description="Profit & Loss statement"
    )
    cashflow: CashflowSummary = Field(
        ...,
        description="Cashflow analysis"
    )
    
    # Key metrics
    collection_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of billed amount collected"
    )
    overdue_ratio: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of amount that is overdue"
    )
    avg_revenue_per_student: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average revenue per student"
    )
    avg_revenue_per_bed: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average revenue per bed"
    )
    
    # Operational metrics
    occupancy_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average occupancy rate during period"
    )
    average_daily_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Average daily rate (ADR) charged"
    )
    
    # Year-over-year comparison
    revenue_growth_yoy: Optional[Decimal] = Field(
        None,
        decimal_places=2,
        description="Year-over-year revenue growth percentage"
    )
    profit_growth_yoy: Optional[Decimal] = Field(
        None,
        decimal_places=2,
        description="Year-over-year profit growth percentage"
    )
    
    @computed_field
    @property
    def financial_health_score(self) -> Decimal:
        """
        Calculate overall financial health score (0-100).
        
        Based on profitability, cashflow, and collection metrics.
        """
        score = Decimal("0.00")
        
        # Profitability (40 points)
        if self.pnl_report.is_profitable:
            profit_margin = self.pnl_report.net_profit_margin
            if profit_margin >= 20:
                score += Decimal("40")
            elif profit_margin >= 10:
                score += Decimal("30")
            elif profit_margin >= 5:
                score += Decimal("20")
            else:
                score += Decimal("10")
        
        # Cashflow (30 points)
        if self.cashflow.cashflow_health == "excellent":
            score += Decimal("30")
        elif self.cashflow.cashflow_health == "good":
            score += Decimal("20")
        elif self.cashflow.cashflow_health == "warning":
            score += Decimal("10")
        
        # Collections (30 points)
        if self.collection_rate >= 95:
            score += Decimal("30")
        elif self.collection_rate >= 85:
            score += Decimal("20")
        elif self.collection_rate >= 75:
            score += Decimal("10")
        
        return round(score, 2)
    
    @computed_field
    @property
    def performance_grade(self) -> str:
        """Get letter grade for financial performance."""
        score = float(self.financial_health_score)
        
        if score >= 90:
            return "A+"
        elif score >= 80:
            return "A"
        elif score >= 70:
            return "B"
        elif score >= 60:
            return "C"
        elif score >= 50:
            return "D"
        else:
            return "F"
    
    def get_executive_summary(self) -> Dict[str, Any]:
        """
        Generate executive summary of financial performance.
        
        Returns:
            Dictionary with key insights for executive review
        """
        return {
            "period": {
                "start": self.period.start_date,
                "end": self.period.end_date,
            },
            "revenue": {
                "total": float(self.pnl_report.revenue.total_revenue),
                "growth_yoy": float(self.revenue_growth_yoy) if self.revenue_growth_yoy else None,
                "per_student": float(self.avg_revenue_per_student),
                "collection_rate": float(self.collection_rate),
            },
            "profitability": {
                "net_profit": float(self.pnl_report.net_profit),
                "margin": float(self.pnl_report.net_profit_margin),
                "status": self.pnl_report.ratios.profitability_status if self.pnl_report.ratios else "unknown",
            },
            "cashflow": {
                "closing_balance": float(self.cashflow.closing_balance),
                "net_flow": float(self.cashflow.net_cashflow),
                "health": self.cashflow.cashflow_health,
            },
            "overall": {
                "health_score": float(self.financial_health_score),
                "grade": self.performance_grade,
            },
        }

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\occupancy_analytics.py ---
# --- File: app/schemas/analytics/occupancy_analytics.py ---
"""
Occupancy analytics schemas with forecasting capabilities.

Provides detailed occupancy metrics including:
- Current and historical occupancy rates
- Room type and floor-wise breakdowns
- Occupancy trends and patterns
- Predictive forecasting
- Capacity utilization analysis
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from enum import Enum

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import RoomType
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "ForecastModel",
    "OccupancyKPI",
    "OccupancyTrendPoint",
    "OccupancyByRoomType",
    "OccupancyByFloor",
    "ForecastPoint",
    "ForecastData",
    "SeasonalPattern",
    "OccupancyReport",
]


class ForecastModel(str, Enum):
    """Forecasting model types."""
    
    MOVING_AVERAGE = "moving_average"
    EXPONENTIAL_SMOOTHING = "exponential_smoothing"
    ARIMA = "arima"
    LINEAR_REGRESSION = "linear_regression"
    SIMPLE_EXTRAPOLATION = "simple_extrapolation"
    ML_BASED = "ml_based"


class OccupancyKPI(BaseSchema):
    """
    Key occupancy metrics and performance indicators.
    
    Provides comprehensive occupancy statistics for capacity
    planning and performance monitoring.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel identifier. None for platform-wide metrics"
    )
    hostel_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    # Current state
    current_occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Current occupancy rate"
    )
    
    # Period averages
    average_occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average occupancy rate over the period"
    )
    peak_occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Peak occupancy rate in the period"
    )
    low_occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Lowest occupancy rate in the period"
    )
    
    # Capacity metrics
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total bed capacity"
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Currently occupied beds"
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Currently available beds"
    )
    reserved_beds: int = Field(
        0,
        ge=0,
        description="Beds reserved but not yet occupied"
    )
    maintenance_beds: int = Field(
        0,
        ge=0,
        description="Beds under maintenance"
    )
    
    # Utilization metrics
    utilization_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Actual utilization rate (occupied / available)"
    )
    turnover_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Bed turnover rate (check-ins + check-outs)"
    )
    
    @field_validator("occupied_beds", "available_beds", "reserved_beds", "maintenance_beds")
    @classmethod
    def validate_bed_counts(cls, v: int, info) -> int:
        """Validate bed counts are consistent with total."""
        if "total_beds" in info.data:
            total = info.data["total_beds"]
            if v > total:
                raise ValueError(f"{info.field_name} cannot exceed total_beds")
        return v
    
    @model_validator(mode="after")
    def validate_bed_allocation(self) -> "OccupancyKPI":
        """Validate that bed allocation is consistent."""
        allocated = (
            self.occupied_beds +
            self.available_beds +
            self.maintenance_beds
        )
        
        # Allow some flexibility for concurrent updates
        if allocated > self.total_beds + 1:
            raise ValueError(
                f"Allocated beds ({allocated}) exceeds total_beds ({self.total_beds})"
            )
        
        return self
    
    @computed_field
    @property
    def occupancy_status(self) -> str:
        """
        Classify occupancy status.
        
        Returns:
            'high', 'optimal', 'low', or 'critical'
        """
        rate = float(self.current_occupancy_percentage)
        
        if rate >= 90:
            return "high"
        elif rate >= 70:
            return "optimal"
        elif rate >= 50:
            return "moderate"
        elif rate >= 30:
            return "low"
        else:
            return "critical"
    
    @computed_field
    @property
    def capacity_pressure(self) -> Decimal:
        """
        Calculate capacity pressure score (0-100).
        
        Higher score indicates higher pressure on capacity.
        """
        if self.total_beds == 0:
            return Decimal("0.00")
        
        # Consider both current occupancy and reserved beds
        pressure_beds = self.occupied_beds + self.reserved_beds
        pressure_rate = (Decimal(pressure_beds) / Decimal(self.total_beds)) * 100
        
        return round(min(pressure_rate, Decimal("100.00")), 2)
    
    @computed_field
    @property
    def vacancy_rate(self) -> Decimal:
        """Calculate vacancy rate."""
        return round(Decimal("100.00") - self.current_occupancy_percentage, 2)


class OccupancyTrendPoint(BaseSchema):
    """
    Single data point in occupancy trend analysis.
    
    Represents occupancy metrics for a specific date.
    """
    
    trend_date: date = Field(
        ...,
        description="Date of the data point"
    )
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Occupancy rate for this date"
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Number of occupied beds"
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds available"
    )
    check_ins: int = Field(
        0,
        ge=0,
        description="Number of check-ins on this date"
    )
    check_outs: int = Field(
        0,
        ge=0,
        description="Number of check-outs on this date"
    )
    
    @field_validator("occupied_beds")
    @classmethod
    def validate_occupied_beds(cls, v: int, info) -> int:
        """Validate occupied beds don't exceed total."""
        if "total_beds" in info.data and v > info.data["total_beds"]:
            raise ValueError("occupied_beds cannot exceed total_beds")
        return v
    
    @computed_field
    @property
    def net_change(self) -> int:
        """Calculate net change in occupancy for the day."""
        return self.check_ins - self.check_outs


class OccupancyByRoomType(BaseSchema):
    """
    Occupancy breakdown by room type.
    
    Provides granular occupancy metrics for each room type
    to identify optimization opportunities.
    """
    
    room_type: RoomType = Field(
        ...,
        description="Room type category"
    )
    room_type_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Human-readable room type name"
    )
    
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total rooms of this type"
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds in this room type"
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Occupied beds in this room type"
    )
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Occupancy rate for this room type"
    )
    
    # Revenue metrics
    average_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Average rate charged for this room type"
    )
    revenue_generated: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Total revenue from this room type"
    )
    
    @field_validator("occupied_beds")
    @classmethod
    def validate_occupied_beds(cls, v: int, info) -> int:
        """Validate occupied beds don't exceed total."""
        if "total_beds" in info.data and v > info.data["total_beds"]:
            raise ValueError("occupied_beds cannot exceed total_beds")
        return v
    
    @computed_field
    @property
    def available_beds(self) -> int:
        """Calculate available beds."""
        return self.total_beds - self.occupied_beds
    
    @computed_field
    @property
    def revenue_per_bed(self) -> Optional[Decimal]:
        """Calculate revenue per bed."""
        if self.revenue_generated is None or self.total_beds == 0:
            return None
        return round(self.revenue_generated / Decimal(self.total_beds), 2)


class OccupancyByFloor(BaseSchema):
    """
    Occupancy breakdown by floor.
    
    Provides floor-wise occupancy metrics for facility management.
    """
    
    floor_number: int = Field(
        ...,
        description="Floor number"
    )
    floor_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Floor name/identifier"
    )
    
    total_rooms: int = Field(
        ...,
        ge=0,
        description="Total rooms on this floor"
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total beds on this floor"
    )
    occupied_beds: int = Field(
        ...,
        ge=0,
        description="Occupied beds on this floor"
    )
    occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Occupancy rate for this floor"
    )
    
    @field_validator("occupied_beds")
    @classmethod
    def validate_occupied_beds(cls, v: int, info) -> int:
        """Validate occupied beds don't exceed total."""
        if "total_beds" in info.data and v > info.data["total_beds"]:
            raise ValueError("occupied_beds cannot exceed total_beds")
        return v


class ForecastPoint(BaseSchema):
    """
    Single forecast data point.
    
    Represents predicted occupancy for a future date.
    """
    
    forecast_date: date = Field(
        ...,
        description="Forecast date"
    )
    forecasted_occupancy_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Predicted occupancy rate"
    )
    forecasted_occupied_beds: int = Field(
        ...,
        ge=0,
        description="Predicted number of occupied beds"
    )
    
    # Confidence intervals
    lower_bound: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Lower confidence bound"
    )
    upper_bound: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Upper confidence bound"
    )
    confidence_level: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Confidence level (e.g., 95%)"
    )
    
    @model_validator(mode="after")
    def validate_bounds(self) -> "ForecastPoint":
        """Validate confidence bounds are reasonable."""
        if self.lower_bound is not None and self.upper_bound is not None:
            if self.lower_bound > self.forecasted_occupancy_percentage:
                raise ValueError("lower_bound cannot exceed forecasted value")
            if self.upper_bound < self.forecasted_occupancy_percentage:
                raise ValueError("upper_bound cannot be less than forecasted value")
            if self.lower_bound > self.upper_bound:
                raise ValueError("lower_bound cannot exceed upper_bound")
        
        return self


class SeasonalPattern(BaseSchema):
    """
    Identified seasonal occupancy pattern.
    
    Describes recurring occupancy patterns for planning.
    """
    
    pattern_name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Pattern identifier (e.g., 'Summer Peak', 'Winter Low')"
    )
    start_month: int = Field(
        ...,
        ge=1,
        le=12,
        description="Starting month of the pattern"
    )
    end_month: int = Field(
        ...,
        ge=1,
        le=12,
        description="Ending month of the pattern"
    )
    average_occupancy: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average occupancy during this pattern"
    )
    occupancy_variance: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Variance in occupancy during this pattern"
    )
    confidence: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Confidence in pattern identification"
    )
    
    @computed_field
    @property
    def is_high_season(self) -> bool:
        """Check if this is a high-occupancy season."""
        return self.average_occupancy >= 80


class ForecastData(BaseSchema):
    """
    Occupancy forecast data with model information.
    
    Provides predicted occupancy with metadata about
    the forecasting methodology and confidence.
    """
    
    forecast_horizon_days: int = Field(
        ...,
        ge=1,
        le=365,
        description="Number of days forecasted into the future"
    )
    forecast_points: List[ForecastPoint] = Field(
        ...,
        min_length=1,
        description="Forecast data points"
    )
    
    # Model information
    model_used: ForecastModel = Field(
        ...,
        description="Forecasting model used"
    )
    model_accuracy: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Historical model accuracy percentage"
    )
    confidence_interval: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Confidence interval for forecasts (e.g., 95%)"
    )
    
    # Training data info
    training_data_start: Optional[date] = Field(
        None,
        description="Start date of training data"
    )
    training_data_end: Optional[date] = Field(
        None,
        description="End date of training data"
    )
    training_samples: Optional[int] = Field(
        None,
        ge=0,
        description="Number of data points used for training"
    )
    
    # Seasonality
    seasonal_patterns: List[SeasonalPattern] = Field(
        default_factory=list,
        description="Identified seasonal patterns"
    )
    
    # Metadata
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Forecast generation timestamp"
    )
    last_updated: Optional[datetime] = Field(
        None,
        description="Last update timestamp"
    )
    
    @field_validator("forecast_points")
    @classmethod
    def validate_forecast_chronological(
        cls,
        v: List[ForecastPoint]
    ) -> List[ForecastPoint]:
        """Ensure forecast points are in chronological order."""
        if len(v) > 1:
            dates = [point.date for point in v]
            if dates != sorted(dates):
                raise ValueError("Forecast points must be in chronological order")
        return v
    
    @model_validator(mode="after")
    def validate_horizon_matches_points(self) -> "ForecastData":
        """Validate forecast horizon matches number of points."""
        if self.forecast_points:
            # Allow some tolerance
            if abs(len(self.forecast_points) - self.forecast_horizon_days) > 1:
                raise ValueError(
                    f"Number of forecast points ({len(self.forecast_points)}) "
                    f"should match horizon ({self.forecast_horizon_days})"
                )
        return self
    
    @computed_field
    @property
    def average_forecasted_occupancy(self) -> Decimal:
        """Calculate average forecasted occupancy."""
        if not self.forecast_points:
            return Decimal("0.00")
        
        total = sum(p.forecasted_occupancy_percentage for p in self.forecast_points)
        return round(total / len(self.forecast_points), 2)
    
    @computed_field
    @property
    def peak_forecasted_date(self) -> Optional[date]:
        """Identify date with highest forecasted occupancy."""
        if not self.forecast_points:
            return None
        return max(
            self.forecast_points,
            key=lambda x: x.forecasted_occupancy_percentage
        ).date
    
    @computed_field
    @property
    def low_forecasted_date(self) -> Optional[date]:
        """Identify date with lowest forecasted occupancy."""
        if not self.forecast_points:
            return None
        return min(
            self.forecast_points,
            key=lambda x: x.forecasted_occupancy_percentage
        ).date


class OccupancyReport(BaseSchema):
    """
    Comprehensive occupancy analytics report.
    
    Consolidates current metrics, historical trends,
    breakdowns, and forecasts into a complete occupancy view.
    """
    
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel identifier. None for platform-wide report"
    )
    hostel_name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Core metrics
    kpi: OccupancyKPI = Field(
        ...,
        description="Key performance indicators"
    )
    
    # Trends
    daily_trend: List[OccupancyTrendPoint] = Field(
        default_factory=list,
        description="Daily occupancy trend data"
    )
    
    # Breakdowns
    by_room_type: List[OccupancyByRoomType] = Field(
        default_factory=list,
        description="Occupancy by room type"
    )
    by_floor: List[OccupancyByFloor] = Field(
        default_factory=list,
        description="Occupancy by floor"
    )
    
    # Legacy support
    by_floor_dict: Dict[int, OccupancyKPI] = Field(
        default_factory=dict,
        description="Floor occupancy dict (deprecated: use by_floor)"
    )
    
    # Forecast
    forecast: Optional[ForecastData] = Field(
        None,
        description="Occupancy forecast"
    )
    
    # Seasonal patterns
    seasonal_patterns: List[SeasonalPattern] = Field(
        default_factory=list,
        description="Identified seasonal patterns"
    )
    
    @field_validator("daily_trend")
    @classmethod
    def validate_trend_chronological(
        cls,
        v: List[OccupancyTrendPoint]
    ) -> List[OccupancyTrendPoint]:
        """Ensure trend points are chronological."""
        if len(v) > 1:
            dates = [point.date for point in v]
            if dates != sorted(dates):
                raise ValueError("Trend points must be in chronological order")
        return v
    
    @computed_field
    @property
    def best_performing_room_type(self) -> Optional[RoomType]:
        """Identify room type with highest occupancy."""
        if not self.by_room_type:
            return None
        return max(
            self.by_room_type,
            key=lambda x: x.occupancy_percentage
        ).room_type
    
    @computed_field
    @property
    def worst_performing_room_type(self) -> Optional[RoomType]:
        """Identify room type with lowest occupancy."""
        if not self.by_room_type:
            return None
        return min(
            self.by_room_type,
            key=lambda x: x.occupancy_percentage
        ).room_type
    
    @computed_field
    @property
    def occupancy_trend_direction(self) -> str:
        """
        Determine overall trend direction.
        
        Returns:
            'increasing', 'decreasing', or 'stable'
        """
        if len(self.daily_trend) < 2:
            return "stable"
        
        first_half = self.daily_trend[:len(self.daily_trend)//2]
        second_half = self.daily_trend[len(self.daily_trend)//2:]
        
        first_avg = sum(
            p.occupancy_percentage for p in first_half
        ) / len(first_half)
        second_avg = sum(
            p.occupancy_percentage for p in second_half
        ) / len(second_half)
        
        change = float(second_avg - first_avg)
        
        if change > 5:
            return "increasing"
        elif change < -5:
            return "decreasing"
        return "stable"
    
    def get_optimization_insights(self) -> List[str]:
        """
        Generate actionable optimization insights.
        
        Returns:
            List of insight strings for improving occupancy
        """
        insights = []
        
        # Overall occupancy check
        if self.kpi.current_occupancy_percentage < 60:
            insights.append(
                f"Current occupancy at {self.kpi.current_occupancy_percentage}% - "
                "consider targeted marketing campaigns"
            )
        
        # Room type performance
        if self.worst_performing_room_type:
            worst = next(
                (rt for rt in self.by_room_type
                 if rt.room_type == self.worst_performing_room_type),
                None
            )
            if worst and worst.occupancy_percentage < 50:
                insights.append(
                    f"{worst.room_type.value} rooms at {worst.occupancy_percentage}% - "
                    "consider pricing adjustments or promotions"
                )
        
        # Capacity pressure
        if self.kpi.capacity_pressure > 85:
            insights.append(
                f"Capacity pressure at {self.kpi.capacity_pressure}% - "
                "consider expansion or waitlist management"
            )
        
        # Trend analysis
        if self.occupancy_trend_direction == "decreasing":
            insights.append(
                "Occupancy trending downward - investigate causes and take corrective action"
            )
        
        # Forecast insights
        if self.forecast and self.forecast.average_forecasted_occupancy < 60:
            insights.append(
                f"Forecasted occupancy at {self.forecast.average_forecasted_occupancy}% - "
                "plan ahead for low season"
            )
        
        return insights

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\platform_analytics.py ---
# --- File: app/schemas/analytics/platform_analytics.py ---
"""
Platform-wide analytics schemas for super admin oversight.

Provides comprehensive platform metrics including:
- Multi-tenant statistics
- Growth metrics and trends
- Platform usage analytics
- System performance metrics
- Revenue aggregation across tenants
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional, Union
from enum import Enum

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import SubscriptionPlan, SubscriptionStatus
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "TenantStatus",
    "PlatformMetrics",
    "MonthlyMetric",
    "GrowthMetrics",
    "TenantMetrics",
    "PlatformUsageAnalytics",
    "SystemHealthMetrics",
    "RevenueMetrics",
    "ChurnAnalysis",
]


class TenantStatus(str, Enum):
    """Tenant (hostel) status categories."""
    
    TRIAL = "trial"
    ACTIVE = "active"
    SUSPENDED = "suspended"
    CHURNED = "churned"
    INACTIVE = "inactive"


class TenantMetrics(BaseSchema):
    """
    Metrics for a single tenant (hostel).
    
    Provides individual tenant performance data for
    platform-level aggregation and analysis.
    """
    
    tenant_id: UUID = Field(
        ...,
        description="Hostel/tenant unique identifier"
    )
    tenant_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Tenant display name"
    )
    
    # Subscription info
    subscription_plan: SubscriptionPlan = Field(
        ...,
        description="Current subscription plan"
    )
    subscription_status: SubscriptionStatus = Field(
        ...,
        description="Subscription status"
    )
    subscription_start_date: date = Field(
        ...,
        description="Subscription start date"
    )
    subscription_mrr: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly recurring revenue from this tenant"
    )
    
    # Usage metrics
    total_students: int = Field(
        ...,
        ge=0,
        description="Total students in this hostel"
    )
    active_students: int = Field(
        ...,
        ge=0,
        description="Active students"
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total bed capacity"
    )
    occupancy_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Current occupancy rate"
    )
    
    # Activity metrics
    last_login: Optional[datetime] = Field(
        None,
        description="Last admin login timestamp"
    )
    daily_active_users: int = Field(
        0,
        ge=0,
        description="Daily active users (last 24h)"
    )
    monthly_active_users: int = Field(
        0,
        ge=0,
        description="Monthly active users (last 30 days)"
    )
    
    # Health indicators
    payment_status: str = Field(
        ...,
        pattern="^(current|overdue|suspended)$",
        description="Payment status"
    )
    health_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall tenant health score"
    )
    churn_risk_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Churn risk score (higher = higher risk)"
    )
    
    @field_validator("active_students")
    @classmethod
    def validate_active_students(cls, v: int, info) -> int:
        """Validate active students don't exceed total."""
        if "total_students" in info.data and v > info.data["total_students"]:
            raise ValueError("active_students cannot exceed total_students")
        return v
    
    @computed_field
    @property
    def is_at_risk(self) -> bool:
        """Check if tenant is at risk of churning."""
        return self.churn_risk_score >= 70
    
    @computed_field
    @property
    def revenue_per_bed(self) -> Decimal:
        """Calculate revenue per bed."""
        if self.total_beds == 0:
            return Decimal("0.00")
        return round(self.subscription_mrr / Decimal(self.total_beds), 2)
    
    @computed_field
    @property
    def engagement_status(self) -> str:
        """Assess tenant engagement level."""
        if self.last_login is None:
            return "inactive"
        
        days_since_login = (datetime.utcnow() - self.last_login).days
        
        if days_since_login <= 1:
            return "highly_active"
        elif days_since_login <= 7:
            return "active"
        elif days_since_login <= 30:
            return "moderate"
        else:
            return "low"


class PlatformMetrics(BaseSchema):
    """
    High-level platform metrics across all tenants.
    
    Provides aggregate statistics for platform monitoring
    and strategic decision-making.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Reporting period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Tenant metrics
    total_hostels: int = Field(
        ...,
        ge=0,
        description="Total registered hostels"
    )
    active_hostels: int = Field(
        ...,
        ge=0,
        description="Currently active hostels"
    )
    hostels_on_trial: int = Field(
        ...,
        ge=0,
        description="Hostels on trial period"
    )
    suspended_hostels: int = Field(
        0,
        ge=0,
        description="Suspended hostels"
    )
    churned_hostels: int = Field(
        0,
        ge=0,
        description="Churned hostels in period"
    )
    
    # User metrics
    total_users: int = Field(
        ...,
        ge=0,
        description="Total registered users across platform"
    )
    total_students: int = Field(
        ...,
        ge=0,
        description="Total students"
    )
    total_supervisors: int = Field(
        ...,
        ge=0,
        description="Total supervisors"
    )
    total_admins: int = Field(
        ...,
        ge=0,
        description="Total hostel admins"
    )
    total_visitors: int = Field(
        0,
        ge=0,
        description="Total visitors/prospects"
    )
    
    # Engagement metrics
    avg_daily_active_users: int = Field(
        ...,
        ge=0,
        description="Average daily active users"
    )
    avg_monthly_active_users: int = Field(
        0,
        ge=0,
        description="Average monthly active users"
    )
    peak_concurrent_sessions: int = Field(
        0,
        ge=0,
        description="Peak concurrent sessions in period"
    )
    
    # Capacity metrics
    total_beds_platform: int = Field(
        0,
        ge=0,
        description="Total bed capacity across all hostels"
    )
    total_occupied_beds: int = Field(
        0,
        ge=0,
        description="Total occupied beds platform-wide"
    )
    platform_occupancy_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Platform-wide occupancy rate"
    )
    
    @field_validator(
        "active_hostels",
        "hostels_on_trial",
        "suspended_hostels"
    )
    @classmethod
    def validate_hostel_counts(cls, v: int, info) -> int:
        """Validate hostel segment counts."""
        if "total_hostels" in info.data:
            total = info.data["total_hostels"]
            # Allow some flexibility as counts may overlap during transitions
            if v > total:
                raise ValueError(f"{info.field_name} cannot exceed total_hostels")
        return v
    
    @computed_field
    @property
    def activation_rate(self) -> Decimal:
        """Calculate percentage of hostels that are active."""
        if self.total_hostels == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.active_hostels) / Decimal(self.total_hostels)) * 100,
            2
        )
    
    @computed_field
    @property
    def trial_conversion_potential(self) -> int:
        """Estimate potential conversions from trial hostels."""
        # Assume 60% trial conversion rate
        return int(self.hostels_on_trial * 0.6)
    
    @computed_field
    @property
    def user_growth_rate(self) -> Optional[Decimal]:
        """Calculate user growth rate if previous period data available."""
        # This would need previous period data - placeholder
        return None


class MonthlyMetric(BaseSchema):
    """
    Monthly metric data point for trend analysis.
    
    Represents a single metric value for a specific month.
    """
    
    month: str = Field(
        ...,
        pattern=r"^\d{4}-(0[1-9]|1[0-2])$",
        description="Month in YYYY-MM format"
    )
    value: Union[Decimal, int, float] = Field(
        ...,
        description="Metric value for the month"
    )
    label: Optional[str] = Field(
        None,
        max_length=100,
        description="Optional display label"
    )
    
    @computed_field
    @property
    def month_name(self) -> str:
        """Get human-readable month name."""
        try:
            year, month = self.month.split("-")
            dt = datetime(int(year), int(month), 1)
            return dt.strftime("%B %Y")
        except (ValueError, AttributeError):
            return self.month


class GrowthMetrics(BaseSchema):
    """
    Growth metrics and trends over time.
    
    Provides detailed growth analysis across key dimensions
    for strategic planning and investor reporting.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    
    # Hostel growth
    new_hostels: int = Field(
        ...,
        ge=0,
        description="New hostels added in period"
    )
    churned_hostels: int = Field(
        ...,
        ge=0,
        description="Hostels churned in period"
    )
    net_hostel_growth: int = Field(
        ...,
        description="Net change in hostel count"
    )
    hostel_growth_rate: Decimal = Field(
        ...,
        decimal_places=2,
        description="Hostel growth rate percentage"
    )
    
    # Revenue growth
    total_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total revenue for period"
    )
    previous_period_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Revenue from previous period"
    )
    revenue_growth_amount: Decimal = Field(
        ...,
        decimal_places=2,
        description="Absolute revenue growth"
    )
    revenue_growth_rate: Decimal = Field(
        ...,
        decimal_places=2,
        description="Revenue growth rate percentage"
    )
    
    # User growth
    new_users: int = Field(
        ...,
        ge=0,
        description="New users registered in period"
    )
    churned_users: int = Field(
        0,
        ge=0,
        description="Users churned in period"
    )
    net_user_growth: int = Field(
        ...,
        description="Net change in user count"
    )
    user_growth_rate: Decimal = Field(
        ...,
        decimal_places=2,
        description="User growth rate percentage"
    )
    
    # MRR (Monthly Recurring Revenue) growth
    current_mrr: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Current monthly recurring revenue"
    )
    previous_mrr: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Previous period MRR"
    )
    mrr_growth_rate: Decimal = Field(
        ...,
        decimal_places=2,
        description="MRR growth rate percentage"
    )
    
    # Time series data
    monthly_revenue: List[MonthlyMetric] = Field(
        default_factory=list,
        description="Monthly revenue trend"
    )
    monthly_new_hostels: List[MonthlyMetric] = Field(
        default_factory=list,
        description="Monthly new hostel acquisitions"
    )
    monthly_new_users: List[MonthlyMetric] = Field(
        default_factory=list,
        description="Monthly new user registrations"
    )
    monthly_mrr: List[MonthlyMetric] = Field(
        default_factory=list,
        description="Monthly MRR trend"
    )
    
    @model_validator(mode="after")
    def validate_growth_calculations(self) -> "GrowthMetrics":
        """Validate growth calculations are consistent."""
        
        # Net hostel growth
        expected_net = self.new_hostels - self.churned_hostels
        if self.net_hostel_growth != expected_net:
            raise ValueError(
                f"net_hostel_growth ({self.net_hostel_growth}) should equal "
                f"new_hostels ({self.new_hostels}) - churned_hostels ({self.churned_hostels})"
            )
        
        # Revenue growth
        expected_revenue_growth = self.total_revenue - self.previous_period_revenue
        if abs(self.revenue_growth_amount - expected_revenue_growth) > Decimal("0.01"):
            raise ValueError(
                "revenue_growth_amount should equal total_revenue - previous_period_revenue"
            )
        
        return self
    
    @computed_field
    @property
    def is_growing(self) -> bool:
        """Check if platform is growing across key metrics."""
        return (
            self.net_hostel_growth > 0 and
            self.revenue_growth_rate > 0 and
            self.user_growth_rate > 0
        )
    
    @computed_field
    @property
    def growth_health_score(self) -> Decimal:
        """
        Calculate overall growth health score (0-100).
        
        Weighted combination of hostel, revenue, and user growth.
        """
        weights = {
            "hostel": Decimal("0.3"),
            "revenue": Decimal("0.5"),
            "user": Decimal("0.2"),
        }
        
        # Normalize growth rates to 0-100 scale
        hostel_score = min(max(self.hostel_growth_rate, Decimal("0")), Decimal("100"))
        revenue_score = min(max(self.revenue_growth_rate, Decimal("0")), Decimal("100"))
        user_score = min(max(self.user_growth_rate, Decimal("0")), Decimal("100"))
        
        score = (
            hostel_score * weights["hostel"] +
            revenue_score * weights["revenue"] +
            user_score * weights["user"]
        )
        
        return round(score, 2)
    
    @computed_field
    @property
    def compound_annual_growth_rate(self) -> Optional[Decimal]:
        """
        Calculate CAGR if sufficient historical data available.
        
        Requires at least 12 months of revenue data.
        """
        if len(self.monthly_revenue) < 12:
            return None
        
        beginning_value = float(self.monthly_revenue[0].value)
        ending_value = float(self.monthly_revenue[-1].value)
        periods = len(self.monthly_revenue) / 12  # Convert to years
        
        if beginning_value <= 0 or periods <= 0:
            return None
        
        cagr = ((ending_value / beginning_value) ** (1 / periods) - 1) * 100
        return round(Decimal(str(cagr)), 2)


class ChurnAnalysis(BaseSchema):
    """
    Customer churn analysis and prediction.
    
    Provides insights into churn patterns and at-risk tenants.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    
    # Churn metrics
    churned_count: int = Field(
        ...,
        ge=0,
        description="Number of churned tenants in period"
    )
    churn_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Churn rate percentage"
    )
    revenue_churned: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="MRR lost to churn"
    )
    
    # Churn reasons
    churn_reasons: Dict[str, int] = Field(
        default_factory=dict,
        description="Churn count by reason"
    )
    
    # At-risk analysis
    at_risk_count: int = Field(
        ...,
        ge=0,
        description="Number of tenants at risk of churning"
    )
    at_risk_tenants: List[TenantMetrics] = Field(
        default_factory=list,
        description="Details of at-risk tenants"
    )
    
    # Retention metrics
    retention_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Retention rate percentage"
    )
    
    @computed_field
    @property
    def top_churn_reason(self) -> Optional[str]:
        """Identify most common churn reason."""
        if not self.churn_reasons:
            return None
        return max(self.churn_reasons, key=self.churn_reasons.get)
    
    @computed_field
    @property
    def churn_risk_status(self) -> str:
        """Assess overall churn risk status."""
        if self.churn_rate <= 3:
            return "low"
        elif self.churn_rate <= 7:
            return "moderate"
        elif self.churn_rate <= 12:
            return "high"
        else:
            return "critical"


class SystemHealthMetrics(BaseSchema):
    """
    Platform system health and performance metrics.
    
    Tracks technical performance, reliability, and capacity.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Monitoring period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Availability
    uptime_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=4,
        description="System uptime percentage"
    )
    downtime_minutes: int = Field(
        ...,
        ge=0,
        description="Total downtime in minutes"
    )
    incident_count: int = Field(
        0,
        ge=0,
        description="Number of incidents in period"
    )
    
    # Performance
    average_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average API response time in milliseconds"
    )
    p50_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="50th percentile response time"
    )
    p95_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="95th percentile response time"
    )
    p99_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="99th percentile response time"
    )
    
    # Error rates
    error_rate_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=4,
        description="Overall error rate percentage"
    )
    server_error_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=4,
        description="5xx error rate percentage"
    )
    client_error_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=4,
        description="4xx error rate percentage"
    )
    
    # Resource utilization
    avg_cpu_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average CPU usage percentage"
    )
    peak_cpu_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Peak CPU usage"
    )
    avg_memory_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average memory usage percentage"
    )
    peak_memory_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Peak memory usage"
    )
    
    # Database performance
    avg_db_query_time_ms: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Average database query time"
    )
    slow_query_count: Optional[int] = Field(
        None,
        ge=0,
        description="Number of slow queries (>1s)"
    )
    
    @computed_field
    @property
    def health_status(self) -> str:
        """Overall system health status."""
        if self.uptime_percentage >= 99.9 and self.error_rate_percentage <= 0.1:
            return "excellent"
        elif self.uptime_percentage >= 99.5 and self.error_rate_percentage <= 0.5:
            return "good"
        elif self.uptime_percentage >= 99.0 and self.error_rate_percentage <= 1.0:
            return "fair"
        else:
            return "poor"
    
    @computed_field
    @property
    def performance_grade(self) -> str:
        """Performance grade based on response times."""
        avg_time = float(self.average_response_time_ms)
        
        if avg_time <= 100:
            return "A"
        elif avg_time <= 200:
            return "B"
        elif avg_time <= 500:
            return "C"
        elif avg_time <= 1000:
            return "D"
        else:
            return "F"


class RevenueMetrics(BaseSchema):
    """
    Platform-wide revenue metrics and analysis.
    
    Aggregates revenue data across all tenants for
    financial planning and reporting.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Revenue period"
    )
    
    # Total revenue
    total_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total platform revenue"
    )
    subscription_revenue: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Revenue from subscriptions"
    )
    transaction_fees: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Revenue from transaction fees"
    )
    other_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Other revenue sources"
    )
    
    # MRR metrics
    mrr: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly Recurring Revenue"
    )
    arr: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Annual Recurring Revenue"
    )
    
    # Revenue by plan
    revenue_by_plan: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Revenue breakdown by subscription plan"
    )
    
    # Customer metrics
    arpu: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average Revenue Per User (monthly)"
    )
    ltv: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Lifetime Value estimate"
    )
    
    # Cohort analysis
    new_customer_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Revenue from new customers"
    )
    expansion_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Revenue from upgrades/expansion"
    )
    churned_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Revenue lost to churn"
    )
    
    @computed_field
    @property
    def revenue_diversity_score(self) -> Decimal:
        """
        Calculate revenue diversification score (0-100).
        
        Higher score indicates better diversification across plans.
        """
        if not self.revenue_by_plan or self.total_revenue == 0:
            return Decimal("0.00")
        
        # Calculate Herfindahl index (lower = more diverse)
        total = float(self.total_revenue)
        herfindahl = sum(
            (float(rev) / total) ** 2
            for rev in self.revenue_by_plan.values()
        )
        
        # Convert to 0-100 scale (invert so higher is better)
        diversity = (1 - herfindahl) * 100
        return round(Decimal(str(diversity)), 2)
    
    @computed_field
    @property
    def net_new_mrr(self) -> Decimal:
        """Calculate net new MRR."""
        return (
            self.new_customer_revenue +
            self.expansion_revenue -
            self.churned_revenue
        )


class PlatformUsageAnalytics(BaseSchema):
    """
    Platform usage and engagement analytics.
    
    Tracks how tenants and users interact with the platform
    for product optimization and support planning.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Traffic metrics
    total_requests: int = Field(
        ...,
        ge=0,
        description="Total API requests in period"
    )
    unique_sessions: int = Field(
        ...,
        ge=0,
        description="Unique user sessions"
    )
    avg_requests_per_minute: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average requests per minute"
    )
    peak_requests_per_minute: int = Field(
        0,
        ge=0,
        description="Peak requests per minute"
    )
    
    # Error tracking
    api_error_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=4,
        description="API error rate percentage"
    )
    total_errors: int = Field(
        0,
        ge=0,
        description="Total error count"
    )
    
    # Module usage
    requests_by_module: Dict[str, int] = Field(
        default_factory=dict,
        description="Request count by module/feature"
    )
    
    # Feature adoption
    feature_adoption_rates: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Adoption rate by feature (%)"
    )
    
    # Performance
    avg_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average response time"
    )
    p95_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="95th percentile response time"
    )
    p99_response_time_ms: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="99th percentile response time"
    )
    
    # Resource usage
    avg_cpu_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average CPU usage"
    )
    avg_memory_usage_percent: Optional[Decimal] = Field(
        None,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average memory usage"
    )
    
    # Storage
    total_storage_used_gb: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Total storage used in GB"
    )
    avg_storage_per_tenant_gb: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Average storage per tenant"
    )
    
    @computed_field
    @property
    def most_used_module(self) -> Optional[str]:
        """Identify most frequently used module."""
        if not self.requests_by_module:
            return None
        return max(self.requests_by_module, key=self.requests_by_module.get)
    
    @computed_field
    @property
    def least_adopted_features(self) -> List[str]:
        """Identify features with low adoption (< 20%)."""
        return [
            feature for feature, rate in self.feature_adoption_rates.items()
            if rate < 20
        ]
    
    @computed_field
    @property
    def platform_health_indicator(self) -> str:
        """Overall platform health indicator."""
        if (
            self.api_error_rate <= 0.1 and
            float(self.avg_response_time_ms) <= 200
        ):
            return "healthy"
        elif (
            self.api_error_rate <= 0.5 and
            float(self.avg_response_time_ms) <= 500
        ):
            return "stable"
        elif (
            self.api_error_rate <= 1.0 and
            float(self.avg_response_time_ms) <= 1000
        ):
            return "degraded"
        else:
            return "critical"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\supervisor_analytics.py ---
# --- File: app/schemas/analytics/supervisor_analytics.py ---
"""
Supervisor analytics schemas for performance tracking.

Provides comprehensive supervisor metrics including:
- Individual performance KPIs
- Workload distribution
- Resolution efficiency
- Comparative benchmarking
- Student feedback integration
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "SupervisorKPI",
    "SupervisorTrendPoint",
    "SupervisorDashboardAnalytics",
    "SupervisorComparison",
    "SupervisorWorkload",
    "SupervisorPerformanceRating",
    "TeamAnalytics",
]


class SupervisorWorkload(BaseSchema):
    """
    Supervisor workload metrics.
    
    Tracks task distribution and capacity utilization
    for resource planning and balancing.
    """
    
    # Current workload
    active_complaints: int = Field(
        ...,
        ge=0,
        description="Currently assigned complaints"
    )
    active_maintenance: int = Field(
        ...,
        ge=0,
        description="Currently assigned maintenance tasks"
    )
    pending_tasks: int = Field(
        ...,
        ge=0,
        description="Total pending tasks"
    )
    
    # Capacity
    max_capacity: int = Field(
        ...,
        ge=1,
        description="Maximum concurrent task capacity"
    )
    current_utilization: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Current capacity utilization percentage"
    )
    
    # Task types
    urgent_tasks: int = Field(
        0,
        ge=0,
        description="Number of urgent/critical tasks"
    )
    overdue_tasks: int = Field(
        0,
        ge=0,
        description="Number of overdue tasks"
    )
    
    @computed_field
    @property
    def available_capacity(self) -> int:
        """Calculate available capacity."""
        return max(0, self.max_capacity - self.pending_tasks)
    
    @computed_field
    @property
    def workload_status(self) -> str:
        """Assess workload status."""
        if self.current_utilization >= 100:
            return "overloaded"
        elif self.current_utilization >= 80:
            return "high"
        elif self.current_utilization >= 50:
            return "moderate"
        else:
            return "low"


class SupervisorPerformanceRating(BaseSchema):
    """
    Performance rating breakdown.
    
    Provides detailed scoring across multiple performance dimensions.
    """
    
    # Individual ratings
    efficiency_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Task completion efficiency (0-100)"
    )
    quality_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Work quality score (0-100)"
    )
    responsiveness_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Response time score (0-100)"
    )
    student_satisfaction_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Student feedback score (0-100)"
    )
    reliability_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Reliability and consistency score (0-100)"
    )
    
    # Overall rating
    overall_rating: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Weighted overall performance rating"
    )
    
    @computed_field
    @property
    def performance_grade(self) -> str:
        """Get letter grade for overall performance."""
        rating = float(self.overall_rating)
        
        if rating >= 90:
            return "A"
        elif rating >= 80:
            return "B"
        elif rating >= 70:
            return "C"
        elif rating >= 60:
            return "D"
        else:
            return "F"
    
    @computed_field
    @property
    def strengths(self) -> List[str]:
        """Identify performance strengths (scores >= 85)."""
        scores = {
            "efficiency": self.efficiency_score,
            "quality": self.quality_score,
            "responsiveness": self.responsiveness_score,
            "student_satisfaction": self.student_satisfaction_score,
            "reliability": self.reliability_score,
        }
        return [name for name, score in scores.items() if score >= 85]
    
    @computed_field
    @property
    def improvement_areas(self) -> List[str]:
        """Identify areas needing improvement (scores < 70)."""
        scores = {
            "efficiency": self.efficiency_score,
            "quality": self.quality_score,
            "responsiveness": self.responsiveness_score,
            "student_satisfaction": self.student_satisfaction_score,
            "reliability": self.reliability_score,
        }
        return [name for name, score in scores.items() if score < 70]


class SupervisorKPI(BaseSchema):
    """
    Key Performance Indicators for supervisor.
    
    Comprehensive performance metrics for individual supervisor
    assessment and development planning.
    """
    
    supervisor_id: UUID = Field(
        ...,
        description="Supervisor unique identifier"
    )
    supervisor_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Supervisor name"
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier"
    )
    hostel_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Performance period"
    )
    
    # Workload metrics
    complaints_assigned: int = Field(
        ...,
        ge=0,
        description="Total complaints assigned in period"
    )
    complaints_resolved: int = Field(
        ...,
        ge=0,
        description="Complaints successfully resolved"
    )
    complaints_pending: int = Field(
        0,
        ge=0,
        description="Currently pending complaints"
    )
    
    maintenance_requests_created: int = Field(
        ...,
        ge=0,
        description="Maintenance requests created"
    )
    maintenance_requests_completed: int = Field(
        ...,
        ge=0,
        description="Maintenance requests completed"
    )
    maintenance_pending: int = Field(
        0,
        ge=0,
        description="Currently pending maintenance"
    )
    
    attendance_records_marked: int = Field(
        ...,
        ge=0,
        description="Attendance records marked"
    )
    
    # Performance metrics
    avg_complaint_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average time to resolve complaints (hours)"
    )
    avg_first_response_time_hours: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Average time to first response (hours)"
    )
    avg_maintenance_completion_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average maintenance completion time (hours)"
    )
    
    # SLA compliance
    complaint_sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Complaint SLA compliance percentage"
    )
    maintenance_sla_compliance_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Maintenance SLA compliance percentage"
    )
    
    # Quality metrics
    reopened_complaints: int = Field(
        0,
        ge=0,
        description="Number of complaints reopened"
    )
    escalated_complaints: int = Field(
        0,
        ge=0,
        description="Number of complaints escalated"
    )
    
    # Feedback
    student_feedback_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Average student rating (1-5 scale)"
    )
    feedback_count: int = Field(
        0,
        ge=0,
        description="Number of feedback responses received"
    )
    
    # Overall performance
    overall_performance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Composite performance score (0-100)"
    )
    
    # Workload
    workload: Optional[SupervisorWorkload] = Field(
        None,
        description="Current workload metrics"
    )
    
    # Performance ratings
    performance_rating: Optional[SupervisorPerformanceRating] = Field(
        None,
        description="Detailed performance ratings"
    )
    
    @field_validator("complaints_resolved")
    @classmethod
    def validate_resolved_complaints(cls, v: int, info) -> int:
        """Validate resolved count doesn't exceed assigned."""
        if "complaints_assigned" in info.data and v > info.data["complaints_assigned"]:
            # Allow slight excess for complaints from previous periods
            if v > info.data["complaints_assigned"] * 1.2:
                raise ValueError(
                    "complaints_resolved significantly exceeds complaints_assigned"
                )
        return v
    
    @computed_field
    @property
    def complaint_resolution_rate(self) -> Decimal:
        """Calculate complaint resolution rate percentage."""
        if self.complaints_assigned == 0:
            return Decimal("100.00")
        return round(
            (Decimal(self.complaints_resolved) / Decimal(self.complaints_assigned)) * 100,
            2
        )
    
    @computed_field
    @property
    def maintenance_completion_rate(self) -> Decimal:
        """Calculate maintenance completion rate percentage."""
        if self.maintenance_requests_created == 0:
            return Decimal("100.00")
        return round(
            (Decimal(self.maintenance_requests_completed) / 
             Decimal(self.maintenance_requests_created)) * 100,
            2
        )
    
    @computed_field
    @property
    def reopen_rate(self) -> Decimal:
        """Calculate complaint reopen rate."""
        if self.complaints_resolved == 0:
            return Decimal("0.00")
        return round(
            (Decimal(self.reopened_complaints) / Decimal(self.complaints_resolved)) * 100,
            2
        )
    
    @computed_field
    @property
    def performance_status(self) -> str:
        """Overall performance status classification."""
        score = float(self.overall_performance_score)
        
        if score >= 85:
            return "excellent"
        elif score >= 70:
            return "good"
        elif score >= 60:
            return "satisfactory"
        elif score >= 50:
            return "needs_improvement"
        else:
            return "unsatisfactory"


class SupervisorTrendPoint(BaseSchema):
    """
    Performance trend data point.
    
    Tracks supervisor performance metrics over time
    for trend analysis and progress monitoring.
    """
    
    period_label: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Period identifier (e.g., 'Week 1', '2024-01')"
    )
    period_start: date = Field(
        ...,
        description="Period start date"
    )
    period_end: date = Field(
        ...,
        description="Period end date"
    )
    
    complaints_resolved: int = Field(
        ...,
        ge=0,
        description="Complaints resolved in period"
    )
    maintenance_completed: int = Field(
        ...,
        ge=0,
        description="Maintenance completed in period"
    )
    performance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Performance score for period"
    )
    student_feedback_score: Optional[Decimal] = Field(
        None,
        ge=0,
        le=5,
        decimal_places=2,
        description="Student feedback score"
    )
    
    @computed_field
    @property
    def total_tasks_completed(self) -> int:
        """Total tasks completed in period."""
        return self.complaints_resolved + self.maintenance_completed


class SupervisorDashboardAnalytics(BaseSchema):
    """
    Supervisor dashboard analytics.
    
    Personalized dashboard view for supervisor performance
    monitoring and self-assessment.
    """
    
    supervisor_id: UUID = Field(
        ...,
        description="Supervisor identifier"
    )
    supervisor_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Supervisor name"
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier"
    )
    hostel_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Dashboard period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Dashboard generation timestamp"
    )
    
    # Core metrics
    kpi: SupervisorKPI = Field(
        ...,
        description="Key performance indicators"
    )
    
    # Trend analysis
    trend: List[SupervisorTrendPoint] = Field(
        default_factory=list,
        description="Performance trend over time"
    )
    
    # Breakdowns
    complaints_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Complaint count by category"
    )
    maintenance_by_category: Dict[str, int] = Field(
        default_factory=dict,
        description="Maintenance count by category"
    )
    
    # Goals and targets
    monthly_target_tasks: Optional[int] = Field(
        None,
        ge=0,
        description="Monthly task completion target"
    )
    target_achievement_rate: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Percentage of target achieved"
    )
    
    @field_validator("trend")
    @classmethod
    def validate_trend_chronological(
        cls,
        v: List[SupervisorTrendPoint]
    ) -> List[SupervisorTrendPoint]:
        """Ensure trend points are chronological."""
        if len(v) > 1:
            dates = [point.period_start for point in v]
            if dates != sorted(dates):
                raise ValueError("Trend points must be in chronological order")
        return v
    
    @computed_field
    @property
    def most_common_complaint_category(self) -> Optional[str]:
        """Identify most frequent complaint category."""
        if not self.complaints_by_category:
            return None
        return max(self.complaints_by_category, key=self.complaints_by_category.get)
    
    @computed_field
    @property
    def improvement_trend(self) -> str:
        """Analyze performance improvement trend."""
        if len(self.trend) < 2:
            return "insufficient_data"
        
        scores = [float(point.performance_score) for point in self.trend]
        first_half_avg = sum(scores[:len(scores)//2]) / (len(scores)//2)
        second_half_avg = sum(scores[len(scores)//2:]) / (len(scores) - len(scores)//2)
        
        change = second_half_avg - first_half_avg
        
        if change > 5:
            return "improving"
        elif change < -5:
            return "declining"
        else:
            return "stable"


class SupervisorComparison(BaseSchema):
    """
    Comparative analysis of supervisors.
    
    Enables benchmarking and identification of top performers
    within a hostel or across the platform.
    """
    
    scope_type: str = Field(
        ...,
        pattern="^(hostel|platform)$",
        description="Comparison scope"
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Hostel ID if scope is hostel"
    )
    hostel_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Comparison period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Supervisor metrics
    supervisors: List[SupervisorKPI] = Field(
        ...,
        min_length=1,
        description="List of supervisor KPIs"
    )
    
    # Rankings
    ranked_by_performance: List[UUID] = Field(
        ...,
        description="Supervisor IDs ranked by overall performance"
    )
    ranked_by_resolution_speed: List[UUID] = Field(
        ...,
        description="Supervisor IDs ranked by resolution speed"
    )
    ranked_by_feedback_score: List[UUID] = Field(
        ...,
        description="Supervisor IDs ranked by student feedback"
    )
    ranked_by_sla_compliance: List[UUID] = Field(
        default_factory=list,
        description="Supervisor IDs ranked by SLA compliance"
    )
    
    # Statistics
    avg_performance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average performance score across all supervisors"
    )
    avg_resolution_time_hours: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average resolution time across all supervisors"
    )
    avg_sla_compliance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average SLA compliance rate"
    )
    
    @field_validator(
        "ranked_by_performance",
        "ranked_by_resolution_speed",
        "ranked_by_feedback_score",
        "ranked_by_sla_compliance"
    )
    @classmethod
    def validate_ranking_completeness(cls, v: List[UUID], info) -> List[UUID]:
        """Validate rankings include all supervisors."""
        if "supervisors" in info.data:
            supervisor_ids = {s.supervisor_id for s in info.data["supervisors"]}
            ranking_ids = set(v)
            
            # Allow for some supervisors to be excluded from certain rankings
            # (e.g., no feedback score available)
            if info.field_name != "ranked_by_feedback_score":
                if ranking_ids != supervisor_ids:
                    # Only warn, don't fail
                    pass
        
        return v
    
    @computed_field
    @property
    def top_performer(self) -> Optional[UUID]:
        """Get ID of top performing supervisor."""
        if not self.ranked_by_performance:
            return None
        return self.ranked_by_performance[0]
    
    @computed_field
    @property
    def performance_variance(self) -> Decimal:
        """Calculate variance in performance scores."""
        if not self.supervisors:
            return Decimal("0.00")
        
        scores = [float(s.overall_performance_score) for s in self.supervisors]
        mean = sum(scores) / len(scores)
        variance = sum((x - mean) ** 2 for x in scores) / len(scores)
        
        return round(Decimal(str(variance)), 2)
    
    def get_supervisor_rank(self, supervisor_id: UUID, metric: str = "performance") -> Optional[int]:
        """
        Get rank of specific supervisor for a metric.
        
        Args:
            supervisor_id: Supervisor to rank
            metric: Metric to rank by ('performance', 'resolution_speed', 'feedback', 'sla')
            
        Returns:
            Rank (1-indexed) or None if not found
        """
        ranking_map = {
            "performance": self.ranked_by_performance,
            "resolution_speed": self.ranked_by_resolution_speed,
            "feedback": self.ranked_by_feedback_score,
            "sla": self.ranked_by_sla_compliance,
        }
        
        ranking = ranking_map.get(metric)
        if not ranking:
            return None
        
        try:
            return ranking.index(supervisor_id) + 1
        except ValueError:
            return None


class TeamAnalytics(BaseSchema):
    """
    Team-level analytics for supervisor groups.
    
    Aggregates supervisor metrics at team/hostel level
    for management oversight.
    """
    
    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier"
    )
    hostel_name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Hostel name"
    )
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Team composition
    total_supervisors: int = Field(
        ...,
        ge=0,
        description="Total number of supervisors"
    )
    active_supervisors: int = Field(
        ...,
        ge=0,
        description="Currently active supervisors"
    )
    
    # Aggregate metrics
    total_tasks_assigned: int = Field(
        ...,
        ge=0,
        description="Total tasks assigned to team"
    )
    total_tasks_completed: int = Field(
        ...,
        ge=0,
        description="Total tasks completed by team"
    )
    team_completion_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Team completion rate percentage"
    )
    
    # Performance
    avg_team_performance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average team performance score"
    )
    avg_team_sla_compliance: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Average team SLA compliance"
    )
    
    # Workload distribution
    workload_balance_score: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Workload distribution balance score (100 = perfectly balanced)"
    )
    
    # Individual contributions
    top_performers: List[UUID] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 performing supervisor IDs"
    )
    
    @computed_field
    @property
    def team_efficiency(self) -> str:
        """Assess overall team efficiency."""
        if self.avg_team_performance_score >= 85:
            return "high"
        elif self.avg_team_performance_score >= 70:
            return "moderate"
        else:
            return "low"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\visitor_analytics.py ---
# --- File: app/schemas/analytics/visitor_analytics.py ---
"""
Visitor and funnel analytics schemas for marketing optimization.

Provides comprehensive visitor behavior analysis including:
- Acquisition funnel tracking
- Traffic source analysis
- Visitor behavior patterns
- Conversion optimization insights
- Search and engagement metrics
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from enum import Enum

from pydantic import Field, field_validator, computed_field, model_validator
from uuid import UUID

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import SearchSource
from app.schemas.common.filters import DateRangeFilter

__all__ = [
    "FunnelStage",
    "VisitorFunnel",
    "TrafficSourceMetrics",
    "TrafficSourceAnalytics",
    "SearchBehavior",
    "EngagementMetrics",
    "VisitorBehaviorAnalytics",
    "ConversionPathAnalysis",
]


class FunnelStage(str, Enum):
    """Visitor journey funnel stages."""
    
    VISIT = "visit"
    SEARCH = "search"
    VIEW_HOSTEL = "view_hostel"
    COMPARE = "compare"
    REGISTER = "register"
    BOOK = "book"
    CONFIRM = "confirm"


class TrafficSourceMetrics(BaseSchema):
    """
    Metrics for a specific traffic source.
    
    Provides detailed performance data for individual
    acquisition channels to optimize marketing spend.
    """
    
    source: SearchSource = Field(
        ...,
        description="Traffic source"
    )
    source_name: Optional[str] = Field(
        None,
        max_length=100,
        description="Human-readable source name"
    )
    
    # Volume metrics
    visits: int = Field(
        ...,
        ge=0,
        description="Total visits from this source"
    )
    unique_visitors: int = Field(
        ...,
        ge=0,
        description="Unique visitors from this source"
    )
    page_views: int = Field(
        ...,
        ge=0,
        description="Total page views from this source"
    )
    
    # Engagement metrics
    avg_session_duration_seconds: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average session duration"
    )
    avg_pages_per_session: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average pages viewed per session"
    )
    bounce_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Bounce rate percentage"
    )
    
    # Conversion metrics
    registrations: int = Field(
        ...,
        ge=0,
        description="User registrations from this source"
    )
    bookings: int = Field(
        ...,
        ge=0,
        description="Bookings from this source"
    )
    confirmed_bookings: int = Field(
        ...,
        ge=0,
        description="Confirmed bookings from this source"
    )
    
    # Conversion rates
    visit_to_registration_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Visit to registration conversion rate"
    )
    visit_to_booking_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Visit to booking conversion rate"
    )
    registration_to_booking_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Registration to booking conversion rate"
    )
    
    # Revenue metrics
    total_revenue: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Total revenue from this source"
    )
    revenue_per_visit: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Average revenue per visit"
    )
    
    # Cost metrics (if available)
    marketing_cost: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Marketing cost for this source"
    )
    cost_per_acquisition: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Cost per booking acquisition"
    )
    roi: Optional[Decimal] = Field(
        None,
        decimal_places=2,
        description="Return on investment percentage"
    )
    
    @field_validator("unique_visitors")
    @classmethod
    def validate_unique_visitors(cls, v: int, info) -> int:
        """Validate unique visitors don't exceed total visits."""
        if "visits" in info.data and v > info.data["visits"]:
            raise ValueError("unique_visitors cannot exceed visits")
        return v
    
    @field_validator("registrations", "bookings", "confirmed_bookings")
    @classmethod
    def validate_conversion_counts(cls, v: int, info) -> int:
        """Validate conversion counts are reasonable."""
        if "visits" in info.data and v > info.data["visits"]:
            # Allow slight excess for cross-session conversions
            if v > info.data["visits"] * 1.1:
                raise ValueError(f"{info.field_name} significantly exceeds visits")
        return v
    
    @computed_field
    @property
    def engagement_score(self) -> Decimal:
        """
        Calculate engagement score (0-100).
        
        Based on session duration, pages per session, and bounce rate.
        """
        # Normalize metrics to 0-100 scale
        duration_score = min(float(self.avg_session_duration_seconds) / 300 * 100, 100)
        pages_score = min(float(self.avg_pages_per_session) / 10 * 100, 100)
        bounce_score = 100 - float(self.bounce_rate)
        
        # Weighted average
        score = (duration_score * 0.4 + pages_score * 0.3 + bounce_score * 0.3)
        return round(Decimal(str(score)), 2)
    
    @computed_field
    @property
    def quality_score(self) -> Decimal:
        """
        Calculate source quality score (0-100).
        
        Combines engagement and conversion metrics.
        """
        engagement = float(self.engagement_score)
        conversion = float(self.visit_to_booking_rate) * 10  # Scale to 0-100
        
        score = (engagement * 0.4 + conversion * 0.6)
        return round(Decimal(str(min(score, 100))), 2)


class VisitorFunnel(BaseSchema):
    """
    Visitor acquisition and conversion funnel.
    
    Tracks visitor journey from initial visit through
    to confirmed booking with drop-off analysis.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Funnel analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Funnel stages
    total_visits: int = Field(
        ...,
        ge=0,
        description="Total website visits"
    )
    unique_visitors: int = Field(
        ...,
        ge=0,
        description="Unique visitors"
    )
    searches_performed: int = Field(
        ...,
        ge=0,
        description="Number of searches performed"
    )
    hostel_views: int = Field(
        ...,
        ge=0,
        description="Hostel detail page views"
    )
    comparisons_made: int = Field(
        0,
        ge=0,
        description="Comparison tool uses"
    )
    registrations: int = Field(
        ...,
        ge=0,
        description="User registrations"
    )
    booking_starts: int = Field(
        ...,
        ge=0,
        description="Booking form starts"
    )
    bookings: int = Field(
        ...,
        ge=0,
        description="Booking submissions"
    )
    confirmed_bookings: int = Field(
        0,
        ge=0,
        description="Confirmed bookings"
    )
    
    # Conversion rates
    visit_to_search_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Visit to search conversion rate"
    )
    search_to_view_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Search to hostel view conversion rate"
    )
    view_to_registration_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Hostel view to registration rate"
    )
    registration_to_booking_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Registration to booking rate"
    )
    booking_to_confirm_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Booking to confirmation rate"
    )
    visit_to_booking_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall visit to booking conversion rate"
    )
    
    # Drop-off analysis
    dropped_after_search: int = Field(
        ...,
        ge=0,
        description="Visitors who left after searching"
    )
    dropped_after_hostel_view: int = Field(
        ...,
        ge=0,
        description="Visitors who left after viewing hostel"
    )
    dropped_after_booking_start: int = Field(
        ...,
        ge=0,
        description="Visitors who abandoned booking form"
    )
    
    @field_validator(
        "unique_visitors",
        "searches_performed",
        "hostel_views",
        "registrations",
        "bookings"
    )
    @classmethod
    def validate_funnel_progression(cls, v: int, info) -> int:
        """Validate funnel stages progress logically."""
        # Note: We allow some flexibility as users may skip stages
        # or stages may be tracked across multiple sessions
        return v
    
    @computed_field
    @property
    def total_drop_offs(self) -> int:
        """Calculate total visitors who dropped off."""
        return self.total_visits - self.confirmed_bookings
    
    @computed_field
    @property
    def largest_drop_off_stage(self) -> str:
        """Identify stage with largest drop-off."""
        drop_offs = {
            "after_search": self.dropped_after_search,
            "after_view": self.dropped_after_hostel_view,
            "after_booking_start": self.dropped_after_booking_start,
        }
        
        if not any(drop_offs.values()):
            return "none"
        
        return max(drop_offs, key=drop_offs.get)
    
    @computed_field
    @property
    def funnel_efficiency_score(self) -> Decimal:
        """
        Calculate overall funnel efficiency (0-100).
        
        Based on conversion rates at each stage.
        """
        rates = [
            float(self.visit_to_search_rate),
            float(self.search_to_view_rate),
            float(self.view_to_registration_rate),
            float(self.registration_to_booking_rate),
            float(self.booking_to_confirm_rate),
        ]
        
        # Geometric mean for compound conversion
        if any(r == 0 for r in rates):
            return Decimal("0.00")
        
        product = 1
        for rate in rates:
            product *= (rate / 100)
        
        efficiency = (product ** (1/len(rates))) * 100
        return round(Decimal(str(efficiency)), 2)


class TrafficSourceAnalytics(BaseSchema):
    """
    Comprehensive traffic source analysis.
    
    Aggregates and compares performance across all
    traffic acquisition channels.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    total_visits: int = Field(
        ...,
        ge=0,
        description="Total visits across all sources"
    )
    
    # Source breakdowns
    visits_by_source: Dict[str, int] = Field(
        default_factory=dict,
        description="Visit count by source"
    )
    registrations_by_source: Dict[str, int] = Field(
        default_factory=dict,
        description="Registration count by source"
    )
    bookings_by_source: Dict[str, int] = Field(
        default_factory=dict,
        description="Booking count by source"
    )
    
    # Conversion rates
    visit_to_booking_rate_by_source: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Visit to booking conversion rate by source"
    )
    
    # Detailed metrics per source
    source_metrics: List[TrafficSourceMetrics] = Field(
        default_factory=list,
        description="Detailed metrics for each source"
    )
    
    @computed_field
    @property
    def best_converting_source(self) -> Optional[SearchSource]:
        """Identify source with highest conversion rate."""
        if not self.source_metrics:
            return None
        return max(
            self.source_metrics,
            key=lambda x: x.visit_to_booking_rate
        ).source
    
    @computed_field
    @property
    def highest_volume_source(self) -> Optional[SearchSource]:
        """Identify source with highest visit volume."""
        if not self.source_metrics:
            return None
        return max(
            self.source_metrics,
            key=lambda x: x.visits
        ).source
    
    @computed_field
    @property
    def best_roi_source(self) -> Optional[SearchSource]:
        """Identify source with best ROI."""
        sources_with_roi = [
            s for s in self.source_metrics
            if s.roi is not None
        ]
        
        if not sources_with_roi:
            return None
        
        return max(sources_with_roi, key=lambda x: x.roi).source


class SearchBehavior(BaseSchema):
    """
    Search behavior analytics.
    
    Analyzes how visitors search for hostels to improve
    search experience and SEO.
    """
    
    # Search volume
    total_searches: int = Field(
        ...,
        ge=0,
        description="Total number of searches"
    )
    unique_searchers: int = Field(
        ...,
        ge=0,
        description="Unique users who searched"
    )
    avg_searches_per_session: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average searches per session"
    )
    
    # Search patterns
    most_searched_cities: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Top 10 most searched cities"
    )
    most_searched_keywords: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Top 20 search keywords"
    )
    
    # Filter usage
    avg_filters_used: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average number of filters applied"
    )
    most_filtered_amenities: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Top 10 filtered amenities"
    )
    most_common_price_range: Optional[str] = Field(
        None,
        max_length=50,
        description="Most common price range filter"
    )
    
    # Search quality
    avg_results_per_search: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average results returned per search"
    )
    zero_result_searches: int = Field(
        0,
        ge=0,
        description="Number of searches with zero results"
    )
    zero_result_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of searches with no results"
    )
    
    @computed_field
    @property
    def search_effectiveness_score(self) -> Decimal:
        """
        Calculate search effectiveness score (0-100).
        
        Based on result relevance and zero-result rate.
        """
        # Lower zero-result rate is better
        result_score = 100 - float(self.zero_result_rate)
        
        # More results indicate better coverage
        coverage_score = min(float(self.avg_results_per_search) / 10 * 100, 100)
        
        score = (result_score * 0.7 + coverage_score * 0.3)
        return round(Decimal(str(score)), 2)


class EngagementMetrics(BaseSchema):
    """
    Visitor engagement metrics.
    
    Measures depth and quality of visitor interaction
    with the platform.
    """
    
    # Page engagement
    avg_hostels_viewed_per_session: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average hostel pages viewed per session"
    )
    avg_time_on_hostel_page_seconds: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average time spent on hostel detail page"
    )
    avg_pages_per_session: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average pages viewed per session"
    )
    
    # Feature usage
    comparison_tool_usage_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of sessions using comparison tool"
    )
    review_read_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of visitors who read reviews"
    )
    photo_gallery_usage_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage using photo gallery"
    )
    
    # Interaction depth
    avg_review_pages_viewed: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Average review pages viewed"
    )
    avg_photos_viewed: Decimal = Field(
        0,
        ge=0,
        decimal_places=2,
        description="Average photos viewed per hostel"
    )
    
    # Call-to-action engagement
    inquiry_form_views: int = Field(
        0,
        ge=0,
        description="Number of inquiry form views"
    )
    inquiry_submissions: int = Field(
        0,
        ge=0,
        description="Number of inquiry submissions"
    )
    inquiry_conversion_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Inquiry form conversion rate"
    )
    
    @computed_field
    @property
    def engagement_level(self) -> str:
        """Classify overall engagement level."""
        score = (
            min(float(self.avg_hostels_viewed_per_session) / 5, 1) * 30 +
            min(float(self.avg_time_on_hostel_page_seconds) / 180, 1) * 30 +
            float(self.comparison_tool_usage_rate) * 0.2 +
            float(self.review_read_rate) * 0.2
        )
        
        if score >= 70:
            return "high"
        elif score >= 40:
            return "moderate"
        else:
            return "low"


class VisitorBehaviorAnalytics(BaseSchema):
    """
    Comprehensive visitor behavior analytics.
    
    Consolidates search, engagement, and exit behavior
    for complete visitor insight.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    generated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Report generation timestamp"
    )
    
    # Search behavior
    search_behavior: SearchBehavior = Field(
        ...,
        description="Search behavior metrics"
    )
    
    # Engagement
    engagement: EngagementMetrics = Field(
        ...,
        description="Engagement metrics"
    )
    
    # Exit behavior
    common_exit_pages: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Top 10 exit pages"
    )
    common_exit_reasons: List[str] = Field(
        default_factory=list,
        max_length=10,
        description="Common reasons for exit (from surveys/feedback)"
    )
    bounce_rate: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Overall bounce rate"
    )
    
    # Session metrics
    avg_session_duration_seconds: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average session duration"
    )
    return_visitor_rate: Decimal = Field(
        0,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of return visitors"
    )
    
    @computed_field
    @property
    def visitor_quality_score(self) -> Decimal:
        """
        Calculate overall visitor quality score (0-100).
        
        Combines engagement, search effectiveness, and retention.
        """
        engagement_level_scores = {
            "high": 100,
            "moderate": 60,
            "low": 30,
        }
        
        engagement_score = engagement_level_scores.get(
            self.engagement.engagement_level,
            50
        )
        search_score = float(self.search_behavior.search_effectiveness_score)
        retention_score = float(self.return_visitor_rate)
        
        score = (
            engagement_score * 0.5 +
            search_score * 0.3 +
            retention_score * 0.2
        )
        
        return round(Decimal(str(score)), 2)
    
    def get_optimization_recommendations(self) -> List[str]:
        """
        Generate actionable optimization recommendations.
        
        Returns:
            List of recommendation strings
        """
        recommendations = []
        
        # Search optimization
        if self.search_behavior.zero_result_rate > 10:
            recommendations.append(
                f"High zero-result search rate ({self.search_behavior.zero_result_rate}%) - "
                "improve search coverage or query handling"
            )
        
        # Engagement optimization
        if self.engagement.engagement_level == "low":
            recommendations.append(
                "Low visitor engagement - consider improving content quality "
                "and visual appeal"
            )
        
        # Exit optimization
        if self.bounce_rate > 60:
            recommendations.append(
                f"High bounce rate ({self.bounce_rate}%) - "
                "optimize landing pages and initial user experience"
            )
        
        # Feature adoption
        if self.engagement.comparison_tool_usage_rate < 20:
            recommendations.append(
                "Low comparison tool usage - make feature more prominent"
            )
        
        # Session duration
        if float(self.avg_session_duration_seconds) < 60:
            recommendations.append(
                "Short session duration - improve content engagement "
                "and reduce friction"
            )
        
        return recommendations


class ConversionPathAnalysis(BaseSchema):
    """
    Conversion path and attribution analysis.
    
    Tracks multi-touch visitor journeys to understand
    conversion attribution.
    """
    
    period: DateRangeFilter = Field(
        ...,
        description="Analysis period"
    )
    
    # Path metrics
    avg_touches_before_conversion: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average touchpoints before booking"
    )
    avg_days_to_conversion: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Average days from first visit to booking"
    )
    
    # Common paths
    top_conversion_paths: List[List[str]] = Field(
        default_factory=list,
        max_length=5,
        description="Top 5 conversion paths (sequences of pages/actions)"
    )
    
    # Attribution
    first_touch_attribution: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Revenue attributed to first touch by source"
    )
    last_touch_attribution: Dict[str, Decimal] = Field(
        default_factory=dict,
        description="Revenue attributed to last touch by source"
    )
    
    @computed_field
    @property
    def conversion_complexity(self) -> str:
        """Assess conversion path complexity."""
        touches = float(self.avg_touches_before_conversion)
        
        if touches <= 2:
            return "simple"
        elif touches <= 5:
            return "moderate"
        else:
            return "complex"

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\__init__.py ---
# --- File: app/schemas/analytics/__init__.py ---
"""
Analytics schemas package.

Comprehensive analytics module providing schemas for:
- Dashboard and KPI metrics
- Financial reporting (P&L, cashflow)
- Occupancy forecasting
- Complaint tracking
- Visitor funnel analysis
- Booking analytics
- Supervisor performance
- Platform-wide metrics
- Custom report generation
"""

# Dashboard analytics
from app.schemas.analytics.dashboard_analytics import (
    DashboardMetrics,
    KPIResponse,
    QuickStats,
    TimeseriesPoint,
    RoleSpecificDashboard,
    AlertNotification,
    DashboardWidget,
)

# Financial analytics
from app.schemas.analytics.financial_analytics import (
    FinancialReport,
    RevenueBreakdown,
    ExpenseBreakdown,
    ProfitAndLossReport,
    CashflowSummary,
    CashflowPoint,
    FinancialRatios,
    BudgetComparison,
    TaxSummary,
)

# Occupancy analytics
from app.schemas.analytics.occupancy_analytics import (
    OccupancyReport,
    OccupancyKPI,
    OccupancyTrendPoint,
    OccupancyByRoomType,
    OccupancyByFloor,
    ForecastData,
    ForecastPoint,
    SeasonalPattern,
)

# Complaint analytics
from app.schemas.analytics.complaint_analytics import (
    ComplaintKPI,
    ComplaintDashboard,
    ComplaintTrend,
    ComplaintTrendPoint,
    CategoryBreakdown,
    PriorityBreakdown,
    SLAMetrics,
)

# Visitor analytics
from app.schemas.analytics.visitor_analytics import (
    VisitorFunnel,
    TrafficSourceAnalytics,
    TrafficSourceMetrics,
    VisitorBehaviorAnalytics,
    SearchBehavior,
    EngagementMetrics,
    ConversionPathAnalysis,
)

# Booking analytics
from app.schemas.analytics.booking_analytics import (
    BookingFunnel,
    BookingKPI,
    BookingTrendPoint,
    CancellationAnalytics,
    BookingAnalyticsSummary,
    BookingSourceMetrics,
)

# Supervisor analytics
from app.schemas.analytics.supervisor_analytics import (
    SupervisorKPI,
    SupervisorDashboardAnalytics,
    SupervisorComparison,
    SupervisorTrendPoint,
    SupervisorWorkload,
    SupervisorPerformanceRating,
    TeamAnalytics,
)

# Platform analytics
from app.schemas.analytics.platform_analytics import (
    PlatformMetrics,
    GrowthMetrics,
    PlatformUsageAnalytics,
    MonthlyMetric,
    TenantMetrics,
    ChurnAnalysis,
    SystemHealthMetrics,
    RevenueMetrics,
)

# Custom reports
from app.schemas.analytics.custom_reports import (
    CustomReportRequest,
    CustomReportDefinition,
    CustomReportResult,
    CustomReportFilter,
    CustomReportField,
    ReportExportRequest,
    ReportSchedule,
    FilterOperator,
    AggregationType,
    ReportFormat,
    ReportModule,
)

__all__ = [
    # Dashboard
    "DashboardMetrics",
    "KPIResponse",
    "QuickStats",
    "TimeseriesPoint",
    "RoleSpecificDashboard",
    "AlertNotification",
    "DashboardWidget",
    
    # Financial
    "FinancialReport",
    "RevenueBreakdown",
    "ExpenseBreakdown",
    "ProfitAndLossReport",
    "CashflowSummary",
    "CashflowPoint",
    "FinancialRatios",
    "BudgetComparison",
    "TaxSummary",
    
    # Occupancy
    "OccupancyReport",
    "OccupancyKPI",
    "OccupancyTrendPoint",
    "OccupancyByRoomType",
    "OccupancyByFloor",
    "ForecastData",
    "ForecastPoint",
    "SeasonalPattern",
    
    # Complaints
    "ComplaintKPI",
    "ComplaintDashboard",
    "ComplaintTrend",
    "ComplaintTrendPoint",
    "CategoryBreakdown",
    "PriorityBreakdown",
    "SLAMetrics",
    
    # Visitor
    "VisitorFunnel",
    "TrafficSourceAnalytics",
    "TrafficSourceMetrics",
    "VisitorBehaviorAnalytics",
    "SearchBehavior",
    "EngagementMetrics",
    "ConversionPathAnalysis",
    
    # Booking
    "BookingFunnel",
    "BookingKPI",
    "BookingTrendPoint",
    "CancellationAnalytics",
    "BookingAnalyticsSummary",
    "BookingSourceMetrics",
    
    # Supervisor
    "SupervisorKPI",
    "SupervisorDashboardAnalytics",
    "SupervisorComparison",
    "SupervisorTrendPoint",
    "SupervisorWorkload",
    "SupervisorPerformanceRating",
    "TeamAnalytics",
    
    # Platform
    "PlatformMetrics",
    "GrowthMetrics",
    "PlatformUsageAnalytics",
    "MonthlyMetric",
    "TenantMetrics",
    "ChurnAnalysis",
    "SystemHealthMetrics",
    "RevenueMetrics",
    
    # Custom reports
    "CustomReportRequest",
    "CustomReportDefinition",
    "CustomReportResult",
    "CustomReportFilter",
    "CustomReportField",
    "ReportExportRequest",
    "ReportSchedule",
    "FilterOperator",
    "AggregationType",
    "ReportFormat",
    "ReportModule",
]


# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\analytics\__pycache__ =====
