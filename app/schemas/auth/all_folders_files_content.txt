### Combined Content from Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\auth ###



# ===== Folder: D:\Last Github Push\Last\HOStel-back\app\schemas\auth =====

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\login.py ---
# --- File: app/schemas/auth/login.py ---
"""
Login schemas with enhanced validation and type safety.
"""

from __future__ import annotations

from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import UserRole

__all__ = [
    "LoginRequest",
    "PhoneLoginRequest",
    "TokenData",
    "UserLoginInfo",
    "LoginResponse",
]


class LoginRequest(BaseCreateSchema):
    """
    Email/password-based login request.
    
    Validates email format and password length constraints.
    """

    email: EmailStr = Field(
        ...,
        description="User email address",
        examples=["user@example.com"],
    )
    password: str = Field(
        ...,
        min_length=8,
        max_length=128,
        description="User password",
    )
    remember_me: bool = Field(
        default=False,
        description="Remember user session for extended period",
    )

    @field_validator("password")
    @classmethod
    def validate_password_not_empty(cls, v: str) -> str:
        """Ensure password is not just whitespace."""
        if not v or not v.strip():
            raise ValueError("Password cannot be empty or whitespace")
        return v


class PhoneLoginRequest(BaseCreateSchema):
    """
    Phone-based login request.
    
    Supports international phone numbers in E.164 format.
    """

    phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number (E.164 format recommended)",
        examples=["+919876543210", "9876543210"],
    )
    password: str = Field(
        ...,
        min_length=8,
        max_length=128,
        description="User password",
    )
    remember_me: bool = Field(
        default=False,
        description="Remember user session for extended period",
    )

    @field_validator("phone")
    @classmethod
    def normalize_phone(cls, v: str) -> str:
        """Normalize phone number by removing spaces and dashes."""
        return v.replace(" ", "").replace("-", "")

    @field_validator("password")
    @classmethod
    def validate_password_not_empty(cls, v: str) -> str:
        """Ensure password is not just whitespace."""
        if not v or not v.strip():
            raise ValueError("Password cannot be empty or whitespace")
        return v


class TokenData(BaseSchema):
    """
    Token data embedded in JWT payload.
    
    Contains minimal user identification and context information.
    """

    user_id: UUID = Field(
        ...,
        description="User unique identifier",
    )
    email: str = Field(
        ...,
        description="User email address",
        examples=["user@example.com"],
    )
    role: UserRole = Field(
        ...,
        description="User role for authorization",
    )
    hostel_id: Optional[UUID] = Field(
        default=None,
        description="Active hostel context for multi-hostel admins",
    )


class UserLoginInfo(BaseSchema):
    """
    User information included in login response.
    
    Provides essential user profile data without sensitive information.
    """

    id: UUID = Field(
        ...,
        description="User unique identifier",
    )
    email: str = Field(
        ...,
        description="User email address",
    )
    full_name: str = Field(
        ...,
        description="User full name",
        examples=["John Doe"],
    )
    role: UserRole = Field(
        ...,
        description="User role",
    )
    is_email_verified: bool = Field(
        ...,
        description="Email verification status",
    )
    is_phone_verified: bool = Field(
        ...,
        description="Phone verification status",
    )
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL",
        examples=["https://example.com/images/profile.jpg"],
    )


class LoginResponse(BaseSchema):
    """
    Login response with JWT tokens and user information.
    
    Follows OAuth 2.0 token response format.
    """

    access_token: str = Field(
        ...,
        description="JWT access token for API authentication",
    )
    refresh_token: str = Field(
        ...,
        description="JWT refresh token for obtaining new access tokens",
    )
    token_type: str = Field(
        default="bearer",
        description="Token type (always 'bearer')",
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="Access token expiration time in seconds",
        examples=[3600],
    )
    user: UserLoginInfo = Field(
        ...,
        description="Authenticated user information",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\otp.py ---
# --- File: app/schemas/auth/otp.py ---
"""
OTP (One-Time Password) schemas with enhanced validation.
"""

from __future__ import annotations

from datetime import datetime
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import OTPType

__all__ = [
    "OTPGenerateRequest",
    "OTPVerifyRequest",
    "OTPResponse",
    "OTPVerifyResponse",
    "ResendOTPRequest",
]


class OTPGenerateRequest(BaseCreateSchema):
    """
    Generate OTP request.
    
    Requires at least one contact method (email or phone).
    """

    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID if authenticated context",
    )
    email: Optional[EmailStr] = Field(
        default=None,
        description="Email address for OTP delivery",
    )
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number for OTP delivery",
    )
    otp_type: OTPType = Field(
        ...,
        description="OTP purpose/type",
    )

    @model_validator(mode="after")
    def validate_contact_method(self) -> "OTPGenerateRequest":
        """
        Ensure at least one contact method is provided.
        
        Raises:
            ValueError: If neither email nor phone is provided.
        """
        if not self.email and not self.phone:
            raise ValueError(
                "At least one contact method (email or phone) must be provided"
            )
        return self

    @field_validator("phone")
    @classmethod
    def normalize_phone(cls, v: Optional[str]) -> Optional[str]:
        """Normalize phone number by removing spaces and dashes."""
        if v:
            return v.replace(" ", "").replace("-", "")
        return v


class OTPVerifyRequest(BaseCreateSchema):
    """
    Verify OTP request.
    
    Validates OTP code format and ensures contact method is provided.
    """

    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID for verification",
    )
    email: Optional[EmailStr] = Field(
        default=None,
        description="Email address used for OTP generation",
    )
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number used for OTP generation",
    )
    otp_code: str = Field(
        ...,
        min_length=6,
        max_length=6,
        pattern=r"^\d{6}$",
        description="6-digit OTP code",
        examples=["123456"],
    )
    otp_type: OTPType = Field(
        ...,
        description="OTP purpose/type",
    )

    @model_validator(mode="after")
    def validate_contact_method(self) -> "OTPVerifyRequest":
        """Ensure at least one contact method is provided."""
        if not self.email and not self.phone:
            raise ValueError(
                "At least one contact method (email or phone) must be provided"
            )
        return self

    @field_validator("otp_code")
    @classmethod
    def validate_otp_format(cls, v: str) -> str:
        """Ensure OTP is exactly 6 digits."""
        if not v.isdigit():
            raise ValueError("OTP must contain only digits")
        if len(v) != 6:
            raise ValueError("OTP must be exactly 6 digits")
        return v


class OTPResponse(BaseSchema):
    """
    OTP generation response.
    
    Provides masked delivery information and expiration details.
    """

    message: str = Field(
        ...,
        description="Response message",
        examples=["OTP sent successfully"],
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="OTP expiration time in seconds",
        examples=[300],
    )
    sent_to: str = Field(
        ...,
        description="Masked email/phone where OTP was sent",
        examples=["u***@example.com", "+91******3210"],
    )
    otp_type: OTPType = Field(
        ...,
        description="OTP type/purpose",
    )
    max_attempts: int = Field(
        default=3,
        ge=1,
        description="Maximum verification attempts allowed",
    )


class OTPVerifyResponse(BaseSchema):
    """
    OTP verification response.
    
    Indicates verification status and provides related information.
    """

    is_valid: bool = Field(
        ...,
        description="Whether OTP verification was successful",
    )
    message: str = Field(
        ...,
        description="Verification result message",
        examples=["OTP verified successfully", "Invalid or expired OTP"],
    )
    verified_at: Optional[datetime] = Field(
        default=None,
        description="Verification timestamp (UTC)",
    )
    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID associated with verified OTP",
    )
    remaining_attempts: Optional[int] = Field(
        default=None,
        ge=0,
        description="Remaining verification attempts (if failed)",
    )


class ResendOTPRequest(BaseCreateSchema):
    """
    Resend OTP request.
    
    Used when user didn't receive the original OTP.
    """

    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID for OTP resend",
    )
    email: Optional[EmailStr] = Field(
        default=None,
        description="Email address for OTP delivery",
    )
    phone: Optional[str] = Field(
        default=None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number for OTP delivery",
    )
    otp_type: OTPType = Field(
        ...,
        description="OTP purpose/type",
    )

    @model_validator(mode="after")
    def validate_contact_method(self) -> "ResendOTPRequest":
        """Ensure at least one contact method is provided."""
        if not self.email and not self.phone:
            raise ValueError(
                "At least one contact method (email or phone) must be provided"
            )
        return self

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\password.py ---
# --- File: app/schemas/auth/password.py ---
"""
Password management schemas with robust validation.
"""

from __future__ import annotations

import re
from typing import List
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "PasswordResetRequest",
    "PasswordResetConfirm",
    "PasswordChangeRequest",
    "PasswordChangeResponse",
    "PasswordStrengthCheck",
    "PasswordStrengthResponse",
]


class PasswordValidator:
    """
    Centralized password validation logic.
    
    Provides reusable validation methods for password strength.
    """

    SPECIAL_CHARS = r"!@#$%^&*()_+\-=\[\]{}|;:,.<>?"
    MIN_LENGTH = 8
    MAX_LENGTH = 128

    @classmethod
    def validate_strength(cls, password: str) -> tuple[bool, List[str]]:
        """
        Validate password strength and return issues.
        
        Args:
            password: Password to validate
            
        Returns:
            Tuple of (is_valid, list_of_issues)
        """
        issues = []

        if len(password) < cls.MIN_LENGTH:
            issues.append(f"Password must be at least {cls.MIN_LENGTH} characters long")

        if not any(char.isdigit() for char in password):
            issues.append("Password must contain at least one digit")

        if not any(char.isupper() for char in password):
            issues.append("Password must contain at least one uppercase letter")

        if not any(char.islower() for char in password):
            issues.append("Password must contain at least one lowercase letter")

        if not re.search(f"[{re.escape(cls.SPECIAL_CHARS)}]", password):
            issues.append(
                "Password must contain at least one special character "
                f"({cls.SPECIAL_CHARS})"
            )

        return len(issues) == 0, issues

    @classmethod
    def calculate_strength_score(cls, password: str) -> int:
        """
        Calculate password strength score (0-5).
        
        Args:
            password: Password to evaluate
            
        Returns:
            Strength score from 0 (very weak) to 5 (very strong)
        """
        score = 0

        # Length score
        if len(password) >= 8:
            score += 1
        if len(password) >= 12:
            score += 1

        # Character diversity
        if any(char.islower() for char in password):
            score += 1
        if any(char.isupper() for char in password):
            score += 1
        if any(char.isdigit() for char in password):
            score += 1
        if re.search(f"[{re.escape(cls.SPECIAL_CHARS)}]", password):
            score += 1

        # Cap at 5
        return min(score, 5)


class PasswordResetRequest(BaseCreateSchema):
    """
    Password reset request (forgot password flow).
    
    Initiates password reset process via email.
    """

    email: str = Field(
        ...,
        description="User email address",
        examples=["user@example.com"],
    )

    @field_validator("email")
    @classmethod
    def validate_email_format(cls, v: str) -> str:
        """Validate email format and normalize."""
        v = v.strip().lower()
        if not v:
            raise ValueError("Email cannot be empty")
        # Basic email validation
        if "@" not in v or "." not in v.split("@")[-1]:
            raise ValueError("Invalid email format")
        return v


class PasswordResetConfirm(BaseCreateSchema):
    """
    Confirm password reset with token and new password.
    
    Completes the password reset process.
    """

    token: str = Field(
        ...,
        min_length=1,
        description="Password reset token from email",
    )
    new_password: str = Field(
        ...,
        min_length=PasswordValidator.MIN_LENGTH,
        max_length=PasswordValidator.MAX_LENGTH,
        description="New password",
    )
    confirm_password: str = Field(
        ...,
        description="Confirm new password",
    )

    @field_validator("new_password")
    @classmethod
    def validate_password_strength(cls, v: str) -> str:
        """Validate password strength requirements."""
        is_valid, issues = PasswordValidator.validate_strength(v)
        if not is_valid:
            raise ValueError("; ".join(issues))
        return v

    @model_validator(mode="after")
    def validate_passwords_match(self) -> "PasswordResetConfirm":
        """Ensure new_password and confirm_password match."""
        if self.new_password != self.confirm_password:
            raise ValueError("Passwords do not match")
        return self


class PasswordChangeRequest(BaseCreateSchema):
    """
    Change password for authenticated user.
    
    Requires current password for security verification.
    """

    current_password: str = Field(
        ...,
        description="Current password for verification",
    )
    new_password: str = Field(
        ...,
        min_length=PasswordValidator.MIN_LENGTH,
        max_length=PasswordValidator.MAX_LENGTH,
        description="New password",
    )
    confirm_password: str = Field(
        ...,
        description="Confirm new password",
    )

    @field_validator("new_password")
    @classmethod
    def validate_password_strength(cls, v: str) -> str:
        """Validate password strength requirements."""
        is_valid, issues = PasswordValidator.validate_strength(v)
        if not is_valid:
            raise ValueError("; ".join(issues))
        return v

    @model_validator(mode="after")
    def validate_password_requirements(self) -> "PasswordChangeRequest":
        """
        Validate password change requirements.
        
        Ensures:
        - New password matches confirmation
        - New password differs from current password
        """
        if self.new_password != self.confirm_password:
            raise ValueError("New password and confirmation do not match")

        if self.new_password == self.current_password:
            raise ValueError(
                "New password must be different from current password"
            )

        return self


class PasswordChangeResponse(BaseSchema):
    """Password change success response."""

    message: str = Field(
        ...,
        description="Success message",
        examples=["Password changed successfully"],
    )
    user_id: UUID = Field(
        ...,
        description="User ID",
    )


class PasswordStrengthCheck(BaseCreateSchema):
    """
    Check password strength without saving.
    
    Useful for real-time password strength indicators.
    """

    password: str = Field(
        ...,
        min_length=1,
        max_length=PasswordValidator.MAX_LENGTH,
        description="Password to evaluate",
    )


class PasswordStrengthResponse(BaseSchema):
    """
    Password strength evaluation response.
    
    Provides detailed strength analysis and suggestions.
    """

    score: int = Field(
        ...,
        ge=0,
        le=5,
        description="Strength score: 0 (very weak) to 5 (very strong)",
    )
    strength: str = Field(
        ...,
        description="Strength label",
        examples=["weak", "medium", "strong", "very_strong"],
    )
    has_minimum_length: bool = Field(
        ...,
        description=f"Has minimum {PasswordValidator.MIN_LENGTH} characters",
    )
    has_uppercase: bool = Field(
        ...,
        description="Contains uppercase letter",
    )
    has_lowercase: bool = Field(
        ...,
        description="Contains lowercase letter",
    )
    has_digit: bool = Field(
        ...,
        description="Contains digit",
    )
    has_special_char: bool = Field(
        ...,
        description="Contains special character",
    )
    suggestions: List[str] = Field(
        default_factory=list,
        description="Suggestions for improvement",
    )

    @staticmethod
    def from_password(password: str) -> "PasswordStrengthResponse":
        """
        Create response from password analysis.
        
        Args:
            password: Password to analyze
            
        Returns:
            PasswordStrengthResponse with complete analysis
        """
        score = PasswordValidator.calculate_strength_score(password)
        is_valid, issues = PasswordValidator.validate_strength(password)

        # Determine strength label
        if score <= 1:
            strength = "very_weak"
        elif score == 2:
            strength = "weak"
        elif score == 3:
            strength = "medium"
        elif score == 4:
            strength = "strong"
        else:
            strength = "very_strong"

        return PasswordStrengthResponse(
            score=score,
            strength=strength,
            has_minimum_length=len(password) >= PasswordValidator.MIN_LENGTH,
            has_uppercase=any(c.isupper() for c in password),
            has_lowercase=any(c.islower() for c in password),
            has_digit=any(c.isdigit() for c in password),
            has_special_char=bool(
                re.search(
                    f"[{re.escape(PasswordValidator.SPECIAL_CHARS)}]",
                    password,
                )
            ),
            suggestions=issues if not is_valid else [],
        )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\register.py ---
# --- File: app/schemas/auth/register.py ---
"""
Registration schemas with comprehensive validation.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import Gender, UserRole

__all__ = [
    "RegisterRequest",
    "RegisterResponse",
    "VerifyEmailRequest",
    "VerifyPhoneRequest",
    "ResendVerificationRequest",
]


class RegisterRequest(BaseCreateSchema):
    """
    User registration request with comprehensive validation.
    
    Validates email, phone, password strength, and personal information.
    """

    email: EmailStr = Field(
        ...,
        description="Email address (must be unique)",
        examples=["user@example.com"],
    )
    phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number (E.164 format recommended)",
        examples=["+919876543210"],
    )
    password: str = Field(
        ...,
        min_length=8,
        max_length=128,
        description="Password (min 8 chars, must include uppercase, lowercase, digit)",
    )
    confirm_password: str = Field(
        ...,
        description="Password confirmation (must match password)",
    )
    full_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Full name",
        examples=["John Doe"],
    )
    role: UserRole = Field(
        default=UserRole.VISITOR,
        description="User role (defaults to visitor for security)",
    )
    gender: Optional[Gender] = Field(
        default=None,
        description="Gender (optional)",
    )
    date_of_birth: Optional[date] = Field(
        default=None,
        description="Date of birth (optional)",
    )

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: EmailStr) -> str:
        """Normalize email to lowercase."""
        return v.lower().strip()

    @field_validator("phone")
    @classmethod
    def normalize_phone(cls, v: str) -> str:
        """Normalize phone number by removing spaces and dashes."""
        return v.replace(" ", "").replace("-", "").strip()

    @field_validator("full_name")
    @classmethod
    def validate_full_name(cls, v: str) -> str:
        """
        Validate and normalize full name.
        
        Ensures name contains at least 2 characters and is not just numbers.
        """
        v = v.strip()
        if len(v) < 2:
            raise ValueError("Full name must be at least 2 characters")
        if v.isdigit():
            raise ValueError("Full name cannot be only numbers")
        return v

    @field_validator("date_of_birth")
    @classmethod
    def validate_age(cls, v: Optional[date]) -> Optional[date]:
        """
        Validate date of birth for reasonable age constraints.
        
        Ensures user is at least 13 years old and not born in the future.
        """
        if v is None:
            return v

        today = date.today()
        if v >= today:
            raise ValueError("Date of birth cannot be in the future")

        age = today.year - v.year - ((today.month, today.day) < (v.month, v.day))
        if age < 13:
            raise ValueError("User must be at least 13 years old")
        if age > 120:
            raise ValueError("Invalid date of birth")

        return v

    @field_validator("password")
    @classmethod
    def validate_password_strength(cls, v: str) -> str:
        """Validate password meets strength requirements."""
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters long")
        if not any(char.isdigit() for char in v):
            raise ValueError("Password must contain at least one digit")
        if not any(char.isupper() for char in v):
            raise ValueError("Password must contain at least one uppercase letter")
        if not any(char.islower() for char in v):
            raise ValueError("Password must contain at least one lowercase letter")
        return v

    @model_validator(mode="after")
    def validate_passwords_match(self) -> "RegisterRequest":
        """Ensure password and confirm_password match."""
        if self.password != self.confirm_password:
            raise ValueError("Passwords do not match")
        return self

    @field_validator("role")
    @classmethod
    def validate_role_restriction(cls, v: UserRole) -> UserRole:
        """
        Restrict self-registration to certain roles.
        
        Prevents users from self-registering as admin roles.
        """
        allowed_roles = {UserRole.VISITOR, UserRole.STUDENT}
        if v not in allowed_roles:
            raise ValueError(
                f"Cannot self-register with role '{v}'. "
                f"Allowed roles: {', '.join(r.value for r in allowed_roles)}"
            )
        return v


class RegisterResponse(BaseSchema):
    """
    Registration success response.
    
    Provides user details and verification requirements.
    """

    user_id: UUID = Field(
        ...,
        description="Created user ID",
    )
    email: str = Field(
        ...,
        description="Registered email address",
    )
    full_name: str = Field(
        ...,
        description="User full name",
    )
    role: UserRole = Field(
        ...,
        description="Assigned user role",
    )
    message: str = Field(
        ...,
        description="Success message",
        examples=["Registration successful. Please verify your email."],
    )
    verification_required: bool = Field(
        default=True,
        description="Whether email/phone verification is required",
    )


class VerifyEmailRequest(BaseCreateSchema):
    """
    Email verification request.
    
    Used to verify email address with code sent via email.
    """

    user_id: UUID = Field(
        ...,
        description="User ID to verify",
    )
    verification_code: str = Field(
        ...,
        min_length=6,
        max_length=6,
        pattern=r"^\d{6}$",
        description="6-digit verification code from email",
        examples=["123456"],
    )

    @field_validator("verification_code")
    @classmethod
    def validate_code_format(cls, v: str) -> str:
        """Ensure verification code is exactly 6 digits."""
        if not v.isdigit():
            raise ValueError("Verification code must contain only digits")
        if len(v) != 6:
            raise ValueError("Verification code must be exactly 6 digits")
        return v


class VerifyPhoneRequest(BaseCreateSchema):
    """
    Phone verification request.
    
    Used to verify phone number with code sent via SMS.
    """

    user_id: UUID = Field(
        ...,
        description="User ID to verify",
    )
    verification_code: str = Field(
        ...,
        min_length=6,
        max_length=6,
        pattern=r"^\d{6}$",
        description="6-digit verification code from SMS",
        examples=["123456"],
    )

    @field_validator("verification_code")
    @classmethod
    def validate_code_format(cls, v: str) -> str:
        """Ensure verification code is exactly 6 digits."""
        if not v.isdigit():
            raise ValueError("Verification code must contain only digits")
        if len(v) != 6:
            raise ValueError("Verification code must be exactly 6 digits")
        return v


class ResendVerificationRequest(BaseCreateSchema):
    """
    Resend verification code request.
    
    Used when user didn't receive the original verification code.
    """

    user_id: UUID = Field(
        ...,
        description="User ID for verification code resend",
    )
    verification_type: str = Field(
        ...,
        pattern=r"^(email|phone)$",
        description="Type of verification (email or phone)",
        examples=["email", "phone"],
    )

    @field_validator("verification_type")
    @classmethod
    def normalize_verification_type(cls, v: str) -> str:
        """Normalize verification type to lowercase."""
        return v.lower().strip()

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\social_auth.py ---
# --- File: app/schemas/auth/social_auth.py ---
"""
Social authentication schemas with provider-specific validation.
"""

from __future__ import annotations

from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, HttpUrl, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import Gender, UserRole

__all__ = [
    "SocialAuthRequest",
    "GoogleAuthRequest",
    "FacebookAuthRequest",
    "SocialUserInfo",
    "SocialProfileData",
    "SocialAuthResponse",
]


class SocialAuthRequest(BaseCreateSchema):
    """
    Base social authentication request.
    
    Generic schema for OAuth providers.
    """

    access_token: str = Field(
        ...,
        min_length=1,
        description="OAuth access token from provider",
    )
    provider: str = Field(
        ...,
        pattern=r"^(google|facebook|apple)$",
        description="OAuth provider name",
        examples=["google", "facebook"],
    )

    @field_validator("provider")
    @classmethod
    def normalize_provider(cls, v: str) -> str:
        """Normalize provider name to lowercase."""
        return v.lower().strip()

    @field_validator("access_token")
    @classmethod
    def validate_token_not_empty(cls, v: str) -> str:
        """Ensure access token is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Access token cannot be empty")
        return v


class GoogleAuthRequest(BaseCreateSchema):
    """
    Google OAuth authentication request.
    
    Uses Google ID token for secure authentication.
    """

    id_token: str = Field(
        ...,
        min_length=1,
        description="Google ID token (JWT) from OAuth flow",
    )
    access_token: Optional[str] = Field(
        default=None,
        description="Google access token (optional, for additional API access)",
    )

    @field_validator("id_token", "access_token")
    @classmethod
    def validate_token_format(cls, v: Optional[str]) -> Optional[str]:
        """Validate token format and strip whitespace."""
        if v is not None:
            v = v.strip()
            if not v:
                raise ValueError("Token cannot be empty or whitespace")
        return v


class FacebookAuthRequest(BaseCreateSchema):
    """
    Facebook OAuth authentication request.
    
    Uses Facebook access token and user ID for authentication.
    """

    access_token: str = Field(
        ...,
        min_length=1,
        description="Facebook access token from OAuth flow",
    )
    user_id: str = Field(
        ...,
        min_length=1,
        description="Facebook user ID",
    )

    @field_validator("access_token", "user_id")
    @classmethod
    def validate_not_empty(cls, v: str) -> str:
        """Ensure field is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Field cannot be empty or whitespace")
        return v


class SocialUserInfo(BaseSchema):
    """
    User information from social authentication.
    
    Minimal user profile data returned after social auth.
    """

    id: UUID = Field(
        ...,
        description="User ID in our system",
    )
    email: str = Field(
        ...,
        description="User email address",
    )
    full_name: str = Field(
        ...,
        description="User full name",
    )
    role: UserRole = Field(
        ...,
        description="User role",
    )
    profile_image_url: Optional[str] = Field(
        default=None,
        description="Profile image URL from social provider",
    )
    is_email_verified: bool = Field(
        default=True,
        description="Email verification status (auto-verified via social auth)",
    )


class SocialProfileData(BaseSchema):
    """
    Profile data extracted from social provider.
    
    Comprehensive user information from OAuth provider.
    """

    provider_user_id: str = Field(
        ...,
        description="Unique user ID from OAuth provider",
    )
    email: EmailStr = Field(
        ...,
        description="Email address from provider",
    )
    full_name: str = Field(
        ...,
        description="Full name from provider",
    )
    first_name: Optional[str] = Field(
        default=None,
        description="First name",
    )
    last_name: Optional[str] = Field(
        default=None,
        description="Last name",
    )
    profile_picture_url: Optional[HttpUrl] = Field(
        default=None,
        description="Profile picture URL from provider",
    )
    gender: Optional[Gender] = Field(
        default=None,
        description="Gender (if provided by provider)",
    )
    locale: Optional[str] = Field(
        default=None,
        description="User locale/language preference",
        examples=["en_US", "hi_IN"],
    )

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: EmailStr) -> str:
        """Normalize email to lowercase."""
        return v.lower().strip()


class SocialAuthResponse(BaseSchema):
    """
    Social authentication response.
    
    Follows OAuth 2.0 token response format with user information.
    """

    access_token: str = Field(
        ...,
        description="JWT access token for API authentication",
    )
    refresh_token: str = Field(
        ...,
        description="JWT refresh token",
    )
    token_type: str = Field(
        default="bearer",
        description="Token type (always 'bearer')",
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="Access token expiration in seconds",
        examples=[3600],
    )
    user: SocialUserInfo = Field(
        ...,
        description="Authenticated user information",
    )
    is_new_user: bool = Field(
        ...,
        description="Whether this is a new user (first-time registration)",
    )

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\token.py ---
# --- File: app/schemas/auth/token.py ---
"""
Token management schemas with enhanced security features.
"""

from __future__ import annotations

from datetime import datetime
from typing import Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import UserRole

__all__ = [
    "Token",
    "TokenPayload",
    "RefreshTokenRequest",
    "RefreshTokenResponse",
    "TokenValidationRequest",
    "TokenValidationResponse",
    "RevokeTokenRequest",
    "LogoutRequest",
]


class Token(BaseSchema):
    """
    JWT token schema.
    
    Standard OAuth 2.0 token response format.
    """

    access_token: str = Field(
        ...,
        description="JWT access token",
    )
    refresh_token: str = Field(
        ...,
        description="JWT refresh token",
    )
    token_type: str = Field(
        default="bearer",
        description="Token type (always 'bearer')",
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="Access token expiration time in seconds",
        examples=[3600],
    )


class TokenPayload(BaseSchema):
    """
    JWT token payload structure.
    
    Standard JWT claims plus custom application claims.
    """

    sub: str = Field(
        ...,
        description="Subject (user_id as string)",
    )
    user_id: UUID = Field(
        ...,
        description="User unique identifier",
    )
    email: str = Field(
        ...,
        description="User email address",
    )
    role: UserRole = Field(
        ...,
        description="User role for authorization",
    )
    hostel_id: Optional[UUID] = Field(
        default=None,
        description="Active hostel context (for multi-hostel scenarios)",
    )
    exp: int = Field(
        ...,
        gt=0,
        description="Expiration timestamp (Unix epoch)",
    )
    iat: int = Field(
        ...,
        gt=0,
        description="Issued at timestamp (Unix epoch)",
    )
    jti: str = Field(
        ...,
        description="JWT ID (unique token identifier for revocation)",
    )

    @field_validator("exp", "iat")
    @classmethod
    def validate_timestamp(cls, v: int) -> int:
        """Validate timestamp is reasonable (not negative, not too far in future)."""
        if v < 0:
            raise ValueError("Timestamp cannot be negative")
        # Check if timestamp is not more than 100 years in the future
        max_future = int(datetime.now().timestamp()) + (100 * 365 * 24 * 3600)
        if v > max_future:
            raise ValueError("Timestamp is too far in the future")
        return v


class RefreshTokenRequest(BaseCreateSchema):
    """
    Refresh token request.
    
    Used to obtain a new access token using a refresh token.
    """

    refresh_token: str = Field(
        ...,
        min_length=1,
        description="Refresh token",
    )

    @field_validator("refresh_token")
    @classmethod
    def validate_token_not_empty(cls, v: str) -> str:
        """Ensure refresh token is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Refresh token cannot be empty")
        return v


class RefreshTokenResponse(BaseSchema):
    """
    Refresh token response.
    
    Returns new access and refresh tokens.
    """

    access_token: str = Field(
        ...,
        description="New JWT access token",
    )
    refresh_token: str = Field(
        ...,
        description="New refresh token (token rotation)",
    )
    token_type: str = Field(
        default="bearer",
        description="Token type (always 'bearer')",
    )
    expires_in: int = Field(
        ...,
        gt=0,
        description="New access token expiration time in seconds",
        examples=[3600],
    )


class TokenValidationRequest(BaseCreateSchema):
    """
    Token validation request.
    
    Used to validate token without making an authenticated request.
    """

    token: str = Field(
        ...,
        min_length=1,
        description="Token to validate (access or refresh)",
    )

    @field_validator("token")
    @classmethod
    def validate_token_not_empty(cls, v: str) -> str:
        """Ensure token is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Token cannot be empty")
        return v


class TokenValidationResponse(BaseSchema):
    """
    Token validation response.
    
    Indicates token validity and provides decoded information.
    """

    is_valid: bool = Field(
        ...,
        description="Whether token is valid and not expired",
    )
    user_id: Optional[UUID] = Field(
        default=None,
        description="User ID if token is valid",
    )
    role: Optional[UserRole] = Field(
        default=None,
        description="User role if token is valid",
    )
    expires_at: Optional[datetime] = Field(
        default=None,
        description="Token expiration datetime (UTC)",
    )
    error: Optional[str] = Field(
        default=None,
        description="Error message if token is invalid",
        examples=["Token expired", "Invalid signature"],
    )


class RevokeTokenRequest(BaseCreateSchema):
    """
    Revoke token request.
    
    Used to invalidate specific token or all user tokens.
    """

    token: str = Field(
        ...,
        min_length=1,
        description="Token to revoke",
    )
    revoke_all: bool = Field(
        default=False,
        description="Revoke all tokens for this user",
    )

    @field_validator("token")
    @classmethod
    def validate_token_not_empty(cls, v: str) -> str:
        """Ensure token is not empty or whitespace."""
        v = v.strip()
        if not v:
            raise ValueError("Token cannot be empty")
        return v


class LogoutRequest(BaseCreateSchema):
    """
    Logout request.
    
    Used to terminate user session(s).
    """

    refresh_token: Optional[str] = Field(
        default=None,
        description="Refresh token to revoke (optional if using access token)",
    )
    logout_all_devices: bool = Field(
        default=False,
        description="Logout from all devices (revoke all user tokens)",
    )

    @field_validator("refresh_token")
    @classmethod
    def validate_token_format(cls, v: Optional[str]) -> Optional[str]:
        """Validate refresh token format if provided."""
        if v is not None:
            v = v.strip()
            if not v:
                raise ValueError("Refresh token cannot be empty if provided")
        return v

# --- File: D:\Last Github Push\Last\HOStel-back\app\schemas\auth\__init__.py ---
# --- File: app/schemas/auth/__init__.py ---
"""
Authentication schemas package.

Re-exports commonly used auth-related schemas for convenient imports.

Example:
    from app.schemas.auth import LoginRequest, RegisterRequest, Token
"""

from __future__ import annotations

from app.schemas.auth.login import (
    LoginRequest,
    LoginResponse,
    PhoneLoginRequest,
    TokenData,
    UserLoginInfo,
)
from app.schemas.auth.otp import (
    OTPGenerateRequest,
    OTPResponse,
    OTPVerifyRequest,
    OTPVerifyResponse,
    ResendOTPRequest,
)
from app.schemas.auth.password import (
    PasswordChangeRequest,
    PasswordChangeResponse,
    PasswordResetConfirm,
    PasswordResetRequest,
    PasswordStrengthCheck,
    PasswordStrengthResponse,
    PasswordValidator,
)
from app.schemas.auth.register import (
    RegisterRequest,
    RegisterResponse,
    ResendVerificationRequest,
    VerifyEmailRequest,
    VerifyPhoneRequest,
)
from app.schemas.auth.social_auth import (
    FacebookAuthRequest,
    GoogleAuthRequest,
    SocialAuthRequest,
    SocialAuthResponse,
    SocialProfileData,
    SocialUserInfo,
)
from app.schemas.auth.token import (
    LogoutRequest,
    RefreshTokenRequest,
    RefreshTokenResponse,
    RevokeTokenRequest,
    Token,
    TokenPayload,
    TokenValidationRequest,
    TokenValidationResponse,
)

__all__ = [
    # Login
    "LoginRequest",
    "LoginResponse",
    "PhoneLoginRequest",
    "TokenData",
    "UserLoginInfo",
    # Register
    "RegisterRequest",
    "RegisterResponse",
    "VerifyEmailRequest",
    "VerifyPhoneRequest",
    "ResendVerificationRequest",
    # Token
    "Token",
    "TokenPayload",
    "RefreshTokenRequest",
    "RefreshTokenResponse",
    "TokenValidationRequest",
    "TokenValidationResponse",
    "RevokeTokenRequest",
    "LogoutRequest",
    # Password
    "PasswordResetRequest",
    "PasswordResetConfirm",
    "PasswordChangeRequest",
    "PasswordChangeResponse",
    "PasswordStrengthCheck",
    "PasswordStrengthResponse",
    "PasswordValidator",
    # OTP
    "OTPGenerateRequest",
    "OTPVerifyRequest",
    "OTPResponse",
    "OTPVerifyResponse",
    "ResendOTPRequest",
    # Social Auth
    "SocialAuthRequest",
    "SocialAuthResponse",
    "GoogleAuthRequest",
    "FacebookAuthRequest",
    "SocialUserInfo",
    "SocialProfileData",
]
