### Combined Content from Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking ###



# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking =====

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking\booking_approval.py ---
# --- File: app/schemas/booking/booking_approval.py ---
"""
Booking approval schemas for admin approval workflow.

This module defines schemas for approving, rejecting, and managing
booking approval workflows including bulk operations and settings.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "BookingApprovalRequest",
    "ApprovalResponse",
    "RejectionRequest",
    "BulkApprovalRequest",
    "ApprovalSettings",
]


class BookingApprovalRequest(BaseCreateSchema):
    """
    Request to approve a pending booking.
    
    Contains all information needed to approve a booking including
    room assignment, pricing confirmation, and payment requirements.
    """

    booking_id: UUID = Field(
        ...,
        description="Unique identifier of the booking to approve",
    )

    # Room Assignment
    room_id: UUID = Field(
        ...,
        description="ID of the room to assign to this booking",
    )
    bed_id: UUID = Field(
        ...,
        description="ID of the specific bed to assign",
    )

    # Date Confirmation/Adjustment
    approved_check_in_date: date = Field(
        ...,
        description="Confirmed or adjusted check-in date",
    )

    # Pricing Confirmation/Adjustment
    final_rent_monthly: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Final confirmed monthly rent amount",
    )
    final_security_deposit: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Final confirmed security deposit amount",
    )

    # Additional Charges
    processing_fee: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="One-time processing or booking fee",
    )

    # Notes and Communication
    admin_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Internal notes visible only to admins",
    )
    message_to_guest: Optional[str] = Field(
        None,
        max_length=1000,
        description="Message to be sent to guest with approval",
    )

    # Payment Requirements
    advance_payment_required: bool = Field(
        True,
        description="Whether advance payment is required before check-in",
    )
    advance_payment_percentage: Decimal = Field(
        Decimal("20.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of total amount required as advance (0-100)",
    )

    @field_validator("approved_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate approved check-in date is not in the past."""
        if v < date.today():
            raise ValueError(
                f"Approved check-in date ({v.strftime('%Y-%m-%d')}) "
                "cannot be in the past"
            )
        return v

    @field_validator("final_rent_monthly")
    @classmethod
    def validate_rent_amount(cls, v: Decimal) -> Decimal:
        """Validate rent amount is reasonable."""
        if v <= 0:
            raise ValueError("Monthly rent must be greater than zero")
        
        # Sanity check
        min_rent = Decimal("500.00")
        max_rent = Decimal("100000.00")
        
        if v < min_rent:
            raise ValueError(f"Monthly rent (₹{v}) is below minimum (₹{min_rent})")
        if v > max_rent:
            raise ValueError(f"Monthly rent (₹{v}) exceeds maximum (₹{max_rent})")
        
        return v

    @model_validator(mode="after")
    def validate_advance_payment(self) -> "BookingApprovalRequest":
        """Validate advance payment settings."""
        if self.advance_payment_required:
            if self.advance_payment_percentage <= 0:
                raise ValueError(
                    "Advance payment percentage must be greater than 0 when required"
                )
            if self.advance_payment_percentage > 100:
                raise ValueError(
                    "Advance payment percentage cannot exceed 100"
                )
        
        return self

    @field_validator("admin_notes", "message_to_guest")
    @classmethod
    def clean_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Clean optional text fields."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class ApprovalResponse(BaseSchema):
    """
    Response after booking approval.
    
    Contains approval confirmation and next steps for guest.
    """

    booking_id: UUID = Field(
        ...,
        description="Approved booking ID",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference number",
    )

    status: str = Field(
        "approved",
        description="New booking status after approval",
    )

    # Assignment Details
    room_number: str = Field(
        ...,
        description="Assigned room number",
    )
    bed_number: str = Field(
        ...,
        description="Assigned bed number",
    )

    # Financial Details
    monthly_rent: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Confirmed monthly rent",
    )
    security_deposit: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Security deposit amount",
    )
    advance_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Advance payment amount required",
    )
    total_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total booking amount",
    )

    # Dates
    approved_at: datetime = Field(
        ...,
        description="Approval timestamp",
    )
    check_in_date: date = Field(
        ...,
        description="Confirmed check-in date",
    )

    # Next Steps
    payment_pending: bool = Field(
        ...,
        description="Whether payment is still pending",
    )
    payment_deadline: Optional[datetime] = Field(
        None,
        description="Deadline for advance payment",
    )

    message: str = Field(
        ...,
        description="Confirmation message for guest",
    )


class RejectionRequest(BaseCreateSchema):
    """
    Request to reject a booking.
    
    Contains rejection reason and optional alternative suggestions.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID to reject",
    )
    rejection_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for rejection",
    )

    # Alternative Suggestions
    suggest_alternative_dates: bool = Field(
        False,
        description="Whether to suggest alternative check-in dates",
    )
    alternative_check_in_dates: Optional[List[date]] = Field(
        None,
        max_length=3,
        description="Up to 3 alternative check-in dates",
    )

    suggest_alternative_room_types: bool = Field(
        False,
        description="Whether to suggest alternative room types",
    )
    alternative_room_types: Optional[List[str]] = Field(
        None,
        max_length=3,
        description="Alternative room types available",
    )

    # Communication
    message_to_guest: Optional[str] = Field(
        None,
        max_length=1000,
        description="Personalized message to guest explaining rejection",
    )

    @field_validator("rejection_reason")
    @classmethod
    def validate_rejection_reason(cls, v: str) -> str:
        """Validate rejection reason is meaningful."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError(
                "Rejection reason must be at least 10 characters to be meaningful"
            )
        return v

    @model_validator(mode="after")
    def validate_alternative_dates(self) -> "RejectionRequest":
        """Validate alternative dates if provided."""
        if self.suggest_alternative_dates:
            if not self.alternative_check_in_dates:
                raise ValueError(
                    "Alternative check-in dates must be provided when "
                    "suggest_alternative_dates is True"
                )
            
            # Validate all dates are in future
            for alt_date in self.alternative_check_in_dates:
                if alt_date < date.today():
                    raise ValueError(
                        f"Alternative date {alt_date} cannot be in the past"
                    )
        
        return self

    @model_validator(mode="after")
    def validate_alternative_room_types(self) -> "RejectionRequest":
        """Validate alternative room types if provided."""
        if self.suggest_alternative_room_types:
            if not self.alternative_room_types:
                raise ValueError(
                    "Alternative room types must be provided when "
                    "suggest_alternative_room_types is True"
                )
        
        return self


class BulkApprovalRequest(BaseCreateSchema):
    """
    Approve multiple bookings in one operation.
    
    Used for batch processing of pending bookings.
    """

    booking_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of booking IDs to approve (max 50)",
    )

    # Common Settings
    auto_assign_rooms: bool = Field(
        True,
        description="Automatically assign available rooms based on preferences",
    )
    send_notifications: bool = Field(
        True,
        description="Send approval notifications to all guests",
    )

    # Common admin note for all approvals
    admin_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Common admin notes for all approvals",
    )

    @field_validator("booking_ids")
    @classmethod
    def validate_booking_ids(cls, v: List[UUID]) -> List[UUID]:
        """Validate booking IDs list."""
        if len(v) == 0:
            raise ValueError("At least one booking ID is required")
        
        if len(v) > 50:
            raise ValueError("Maximum 50 bookings can be approved at once")
        
        # Remove duplicates while preserving order
        seen = set()
        unique_ids = []
        for booking_id in v:
            if booking_id not in seen:
                seen.add(booking_id)
                unique_ids.append(booking_id)
        
        return unique_ids


class ApprovalSettings(BaseSchema):
    """
    Hostel-specific booking approval settings.
    
    Configures auto-approval rules and policies for a hostel.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )

    # Auto-Approval
    auto_approve_enabled: bool = Field(
        False,
        description="Enable automatic approval of bookings",
    )
    auto_approve_conditions: Dict = Field(
        default_factory=dict,
        description="Conditions that must be met for auto-approval (JSON)",
    )

    # Timing
    approval_expiry_hours: int = Field(
        48,
        ge=1,
        le=168,
        description="Hours to respond to booking before it expires (1-168)",
    )

    # Payment Settings
    require_advance_payment: bool = Field(
        True,
        description="Require advance payment after approval",
    )
    advance_payment_percentage: Decimal = Field(
        Decimal("20.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Default advance payment percentage (0-100)",
    )

    @field_validator("approval_expiry_hours")
    @classmethod
    def validate_expiry_hours(cls, v: int) -> int:
        """Validate approval expiry hours."""
        if v < 1:
            raise ValueError("Approval expiry must be at least 1 hour")
        if v > 168:  # 1 week
            raise ValueError("Approval expiry cannot exceed 168 hours (1 week)")
        return v

    @field_validator("auto_approve_conditions")
    @classmethod
    def validate_auto_approve_conditions(cls, v: Dict) -> Dict:
        """Validate auto-approve conditions structure."""
        # Could add validation for expected keys/structure
        # For now, just ensure it's a dict
        if not isinstance(v, dict):
            raise ValueError("Auto-approve conditions must be a dictionary")
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking\booking_assignment.py ---
# --- File: app/schemas/booking/booking_assignment.py ---
"""
Booking room and bed assignment schemas.

This module defines schemas for assigning rooms and beds to bookings,
including bulk operations and reassignment workflows.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "RoomAssignment",
    "BedAssignment",
    "AssignmentRequest",
    "BulkAssignmentRequest",
    "SingleAssignment",
    "AssignmentResponse",
    "ReassignmentRequest",
]


class RoomAssignment(BaseSchema):
    """
    Room assignment record for a booking.
    
    Represents the assignment of a specific room to a booking.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking identifier",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference number",
    )

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    room_id: UUID = Field(
        ...,
        description="Assigned room identifier",
    )
    room_number: str = Field(
        ...,
        description="Assigned room number",
    )
    room_type: str = Field(
        ...,
        description="Room type",
    )

    assigned_by: UUID = Field(
        ...,
        description="Admin who made the assignment",
    )
    assigned_by_name: str = Field(
        ...,
        description="Name of admin who assigned",
    )
    assigned_at: datetime = Field(
        ...,
        description="Assignment timestamp",
    )

    check_in_date: date = Field(
        ...,
        description="Scheduled check-in date",
    )


class BedAssignment(BaseSchema):
    """
    Bed assignment record for a booking.
    
    Represents the assignment of a specific bed within a room.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking identifier",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference number",
    )

    room_id: UUID = Field(
        ...,
        description="Room identifier",
    )
    room_number: str = Field(
        ...,
        description="Room number",
    )
    bed_id: UUID = Field(
        ...,
        description="Assigned bed identifier",
    )
    bed_number: str = Field(
        ...,
        description="Assigned bed number",
    )

    assigned_by: UUID = Field(
        ...,
        description="Admin who made the assignment",
    )
    assigned_by_name: str = Field(
        ...,
        description="Name of admin who assigned",
    )
    assigned_at: datetime = Field(
        ...,
        description="Assignment timestamp",
    )


class AssignmentRequest(BaseCreateSchema):
    """
    Request to assign room and bed to a booking.
    
    Used by admins to manually assign specific room and bed
    to an approved booking.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID to assign room/bed to",
    )
    room_id: UUID = Field(
        ...,
        description="Room ID to assign",
    )
    bed_id: UUID = Field(
        ...,
        description="Bed ID to assign within the room",
    )

    # Optional Override
    override_check_in_date: Optional[date] = Field(
        None,
        description="Override the preferred check-in date if needed",
    )

    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Assignment notes for internal reference",
    )

    @field_validator("override_check_in_date")
    @classmethod
    def validate_override_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate override check-in date."""
        if v is not None and v < date.today():
            raise ValueError(
                f"Override check-in date ({v}) cannot be in the past"
            )
        return v

    @field_validator("notes")
    @classmethod
    def clean_notes(cls, v: Optional[str]) -> Optional[str]:
        """Clean notes field."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class SingleAssignment(BaseSchema):
    """
    Single assignment in bulk operation.
    
    Minimal schema for individual assignment within bulk request.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID",
    )
    room_id: UUID = Field(
        ...,
        description="Room ID to assign",
    )
    bed_id: UUID = Field(
        ...,
        description="Bed ID to assign",
    )


class BulkAssignmentRequest(BaseCreateSchema):
    """
    Bulk assign rooms to multiple bookings.
    
    Used for batch assignment operations.
    """

    assignments: List[SingleAssignment] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of room/bed assignments (max 100)",
    )

    auto_approve: bool = Field(
        False,
        description="Automatically approve bookings after assignment",
    )

    @field_validator("assignments")
    @classmethod
    def validate_assignments(cls, v: List[SingleAssignment]) -> List[SingleAssignment]:
        """Validate assignments list."""
        if len(v) == 0:
            raise ValueError("At least one assignment is required")
        
        if len(v) > 100:
            raise ValueError("Maximum 100 assignments allowed per bulk operation")
        
        # Check for duplicate booking IDs
        booking_ids = [a.booking_id for a in v]
        if len(booking_ids) != len(set(booking_ids)):
            raise ValueError("Duplicate booking IDs found in assignments list")
        
        return v


class AssignmentResponse(BaseSchema):
    """
    Response after assignment operation.
    
    Provides feedback on assignment success and next steps.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking identifier",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference",
    )

    room_assigned: bool = Field(
        ...,
        description="Whether room was successfully assigned",
    )
    room_number: Optional[str] = Field(
        None,
        description="Assigned room number if successful",
    )
    bed_number: Optional[str] = Field(
        None,
        description="Assigned bed number if successful",
    )

    message: str = Field(
        ...,
        description="Result message",
    )
    next_steps: List[str] = Field(
        default_factory=list,
        description="List of next steps required",
    )


class ReassignmentRequest(BaseCreateSchema):
    """
    Request to reassign booking to different room/bed.
    
    Used when guest needs to be moved to a different room
    or bed after initial assignment.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID to reassign",
    )
    current_room_id: UUID = Field(
        ...,
        description="Current room assignment",
    )
    new_room_id: UUID = Field(
        ...,
        description="New room to assign",
    )
    new_bed_id: UUID = Field(
        ...,
        description="New bed to assign",
    )

    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for reassignment",
    )
    notify_guest: bool = Field(
        True,
        description="Send notification to guest about reassignment",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reassignment reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError(
                "Reassignment reason must be at least 10 characters"
            )
        return v

    @field_validator("new_room_id")
    @classmethod
    def validate_different_room(cls, v: UUID, info) -> UUID:
        """Ensure new room is different from current."""
        current_room_id = info.data.get("current_room_id")
        if current_room_id and v == current_room_id:
            raise ValueError(
                "New room must be different from current room"
            )
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking\booking_base.py ---
# --- File: app/schemas/booking/booking_base.py ---
"""
Booking base schemas with comprehensive validation.

This module defines the core booking schemas including creation,
updates, and base validation logic for the booking lifecycle.
"""

from __future__ import annotations

from datetime import date, timedelta
from decimal import Decimal
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema, BaseUpdateSchema
from app.schemas.common.enums import BookingSource, BookingStatus, RoomType

__all__ = [
    "BookingBase",
    "BookingCreate",
    "BookingUpdate",
]


class BookingBase(BaseSchema):
    """
    Base booking schema with common fields and validation.
    
    Contains all core booking information including visitor details,
    hostel selection, room preferences, pricing, and special requirements.
    """

    visitor_id: UUID = Field(
        ...,
        description="Unique identifier of the visitor/guest making the booking",
    )
    hostel_id: UUID = Field(
        ...,
        description="Unique identifier of the hostel being booked",
    )

    # Booking Details
    room_type_requested: RoomType = Field(
        ...,
        description="Type of room requested (single, double, dormitory, etc.)",
    )
    preferred_check_in_date: date = Field(
        ...,
        description="Preferred check-in date",
    )
    stay_duration_months: int = Field(
        ...,
        ge=1,
        le=24,
        description="Duration of stay in months (1-24)",
    )

    # Pricing Information
    quoted_rent_monthly: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly rent amount quoted at time of booking",
    )
    total_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total amount for entire stay (monthly rent × duration)",
    )
    security_deposit: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Refundable security deposit amount",
    )
    advance_amount: Decimal = Field(
        Decimal("0.00"),
        ge=0,
        decimal_places=2,
        description="Advance payment amount required",
    )

    # Special Requirements
    special_requests: Optional[str] = Field(
        None,
        max_length=1000,
        description="Any special requests or requirements from the guest",
    )
    dietary_preferences: Optional[str] = Field(
        None,
        max_length=255,
        description="Dietary preferences (vegetarian, vegan, etc.)",
    )
    has_vehicle: bool = Field(
        False,
        description="Whether guest has a vehicle requiring parking",
    )
    vehicle_details: Optional[str] = Field(
        None,
        max_length=255,
        description="Vehicle details (type, registration number)",
    )

    # Booking Source
    source: BookingSource = Field(
        BookingSource.WEBSITE,
        description="Source of the booking (website, app, referral, etc.)",
    )
    referral_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Referral code used during booking",
    )

    @field_validator("preferred_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date is not in the past."""
        if v < date.today():
            raise ValueError(
                f"Check-in date ({v}) cannot be in the past. "
                f"Please select today or a future date."
            )
        
        # Warn if check-in is too far in the future (e.g., > 6 months)
        max_advance_days = 180  # 6 months
        if (v - date.today()).days > max_advance_days:
            # Note: This is a warning, not an error
            # Could be logged or handled differently in production
            pass
        
        return v

    @field_validator("quoted_rent_monthly")
    @classmethod
    def validate_rent_amount(cls, v: Decimal) -> Decimal:
        """Validate rent amount is reasonable."""
        if v <= 0:
            raise ValueError("Monthly rent must be greater than zero")
        
        # Sanity check: Rent should typically be between ₹1,000 and ₹1,00,000
        min_rent = Decimal("1000.00")
        max_rent = Decimal("100000.00")
        
        if v < min_rent:
            raise ValueError(
                f"Monthly rent (₹{v}) seems too low. Minimum is ₹{min_rent}"
            )
        if v > max_rent:
            raise ValueError(
                f"Monthly rent (₹{v}) seems too high. Maximum is ₹{max_rent}"
            )
        
        return v

    @model_validator(mode="after")
    def validate_total_amount(self) -> "BookingBase":
        """Validate total amount calculation."""
        expected_total = self.quoted_rent_monthly * self.stay_duration_months
        
        # Allow small floating-point differences (up to ₹1)
        tolerance = Decimal("1.00")
        difference = abs(self.total_amount - expected_total)
        
        if difference > tolerance:
            raise ValueError(
                f"Total amount (₹{self.total_amount}) does not match "
                f"expected calculation (₹{expected_total:.2f} = "
                f"₹{self.quoted_rent_monthly} × {self.stay_duration_months} months). "
                f"Difference: ₹{difference:.2f}"
            )
        
        return self

    @model_validator(mode="after")
    def validate_advance_amount(self) -> "BookingBase":
        """Validate advance amount is reasonable."""
        if self.advance_amount > self.total_amount:
            raise ValueError(
                f"Advance amount (₹{self.advance_amount}) cannot exceed "
                f"total amount (₹{self.total_amount})"
            )
        
        # Typically, advance is 10-50% of total
        min_advance_percent = Decimal("0.10")  # 10%
        max_advance_percent = Decimal("0.50")  # 50%
        
        if self.advance_amount > 0:
            advance_percent = self.advance_amount / self.total_amount
            
            if advance_percent < min_advance_percent:
                # Warning: Less than typical advance
                pass
            elif advance_percent > max_advance_percent:
                raise ValueError(
                    f"Advance amount (₹{self.advance_amount}) is "
                    f"{advance_percent * 100:.1f}% of total, which exceeds "
                    f"the maximum allowed ({max_advance_percent * 100}%)"
                )
        
        return self

    @model_validator(mode="after")
    def validate_vehicle_details(self) -> "BookingBase":
        """Validate vehicle details are provided if has_vehicle is True."""
        if self.has_vehicle and not self.vehicle_details:
            raise ValueError(
                "Vehicle details must be provided when has_vehicle is True"
            )
        
        return self

    @field_validator("special_requests", "dietary_preferences")
    @classmethod
    def clean_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Clean and validate text fields."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v

    @property
    def expected_check_out_date(self) -> date:
        """Calculate expected check-out date based on duration."""
        # Approximate: 1 month = 30 days
        return self.preferred_check_in_date + timedelta(
            days=self.stay_duration_months * 30
        )

    @property
    def days_until_check_in(self) -> int:
        """Calculate days remaining until check-in."""
        return (self.preferred_check_in_date - date.today()).days

    @property
    def is_long_term_booking(self) -> bool:
        """Check if this is a long-term booking (>= 6 months)."""
        return self.stay_duration_months >= 6


class BookingCreate(BookingBase, BaseCreateSchema):
    """
    Schema for creating a new booking.
    
    Includes all base booking fields plus guest information
    that must be provided at booking time.
    """

    # Guest Information (embedded for convenience)
    guest_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Full name of the guest",
    )
    guest_email: EmailStr = Field(
        ...,
        description="Guest email address for communication",
    )
    guest_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Guest contact phone number (international format supported)",
    )

    # Optional ID Proof (can be provided later)
    guest_id_proof_type: Optional[str] = Field(
        None,
        pattern=r"^(aadhaar|passport|driving_license|voter_id|pan_card)$",
        description="Type of ID proof",
    )
    guest_id_proof_number: Optional[str] = Field(
        None,
        max_length=50,
        description="ID proof number",
    )

    # Emergency Contact Information
    emergency_contact_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Emergency contact person name",
    )
    emergency_contact_phone: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone number",
    )
    emergency_contact_relation: Optional[str] = Field(
        None,
        max_length=50,
        description="Relation to emergency contact",
    )

    # Institutional/Employment Details
    institution_or_company: Optional[str] = Field(
        None,
        max_length=255,
        description="Name of institution or company",
    )
    designation_or_course: Optional[str] = Field(
        None,
        max_length=255,
        description="Designation (if employed) or course (if student)",
    )

    @field_validator("guest_name")
    @classmethod
    def validate_guest_name(cls, v: str) -> str:
        """Validate and normalize guest name."""
        v = v.strip()
        
        if len(v) < 2:
            raise ValueError("Guest name must be at least 2 characters")
        
        # Check for minimum name parts (at least first name)
        name_parts = v.split()
        if len(name_parts) < 1:
            raise ValueError("Please provide at least a first name")
        
        # Check for invalid characters
        if any(char.isdigit() for char in v):
            raise ValueError("Guest name should not contain numbers")
        
        return v

    @field_validator("guest_phone")
    @classmethod
    def validate_guest_phone(cls, v: str) -> str:
        """Validate and normalize phone number."""
        # Remove spaces and dashes
        v = v.replace(" ", "").replace("-", "")
        
        # Ensure it's not too short
        if len(v) < 10:
            raise ValueError("Phone number must be at least 10 digits")
        
        return v

    @model_validator(mode="after")
    def validate_emergency_contact(self) -> "BookingCreate":
        """Validate emergency contact consistency."""
        has_emergency_name = self.emergency_contact_name is not None
        has_emergency_phone = self.emergency_contact_phone is not None
        
        # If one is provided, encourage both
        if has_emergency_name and not has_emergency_phone:
            raise ValueError(
                "Emergency contact phone is required when name is provided"
            )
        if has_emergency_phone and not has_emergency_name:
            raise ValueError(
                "Emergency contact name is required when phone is provided"
            )
        
        return self

    @model_validator(mode="after")
    def validate_id_proof(self) -> "BookingCreate":
        """Validate ID proof consistency."""
        has_id_type = self.guest_id_proof_type is not None
        has_id_number = self.guest_id_proof_number is not None
        
        if has_id_type and not has_id_number:
            raise ValueError("ID proof number is required when type is provided")
        if has_id_number and not has_id_type:
            raise ValueError("ID proof type is required when number is provided")
        
        return self


class BookingUpdate(BaseUpdateSchema):
    """
    Schema for updating an existing booking.
    
    All fields are optional, allowing partial updates.
    Only admin-modifiable fields are included.
    """

    # Booking Details (modifiable)
    room_type_requested: Optional[RoomType] = Field(
        None,
        description="Update requested room type",
    )
    preferred_check_in_date: Optional[date] = Field(
        None,
        description="Update preferred check-in date",
    )
    stay_duration_months: Optional[int] = Field(
        None,
        ge=1,
        le=24,
        description="Update stay duration",
    )

    # Special Requirements
    special_requests: Optional[str] = Field(
        None,
        max_length=1000,
        description="Update special requests",
    )
    dietary_preferences: Optional[str] = Field(
        None,
        max_length=255,
        description="Update dietary preferences",
    )
    has_vehicle: Optional[bool] = Field(
        None,
        description="Update vehicle status",
    )
    vehicle_details: Optional[str] = Field(
        None,
        max_length=255,
        description="Update vehicle details",
    )

    # Status Updates (admin only)
    booking_status: Optional[BookingStatus] = Field(
        None,
        description="Update booking status (admin only)",
    )

    @field_validator("preferred_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate updated check-in date."""
        if v is not None and v < date.today():
            raise ValueError(
                f"Check-in date ({v}) cannot be in the past"
            )
        return v

    @field_validator("special_requests", "dietary_preferences")
    @classmethod
    def clean_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Clean text fields."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking\booking_calendar.py ---
# --- File: app/schemas/booking/booking_calendar.py ---
"""
Booking calendar schemas for calendar views and availability tracking.

This module defines schemas for calendar views, booking events,
and availability tracking across dates.
"""

from __future__ import annotations

import datetime as dt
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator, computed_field

from app.schemas.common.base import BaseSchema
from app.schemas.common.enums import BookingStatus

__all__ = [
    "CalendarView",
    "DayBookings",
    "BookingEvent",
    "CalendarEvent",
    "AvailabilityCalendar",
    "DayAvailability",
]


class BookingEvent(BaseSchema):
    """
    Individual booking event for calendar display.
    
    Represents a booking-related event (check-in, check-out, etc.)
    for calendar visualization.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking identifier",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference number",
    )
    guest_name: str = Field(
        ...,
        description="Guest name",
    )
    room_number: Optional[str] = Field(
        None,
        description="Assigned room number if available",
    )
    room_type: str = Field(
        ...,
        description="Room type",
    )
    status: BookingStatus = Field(
        ...,
        description="Current booking status",
    )

    # Event Type Flags
    is_check_in: bool = Field(
        False,
        description="Whether this is a check-in event",
    )
    is_check_out: bool = Field(
        False,
        description="Whether this is a check-out event",
    )

    @computed_field
    @property
    def event_type_display(self) -> str:
        """Get display-friendly event type."""
        if self.is_check_in:
            return "Check-in"
        elif self.is_check_out:
            return "Check-out"
        else:
            return "Booking Request"

    @computed_field
    @property
    def status_color(self) -> str:
        """Get color code for status display."""
        color_map = {
            BookingStatus.PENDING: "#FFA500",  # Orange
            BookingStatus.APPROVED: "#4CAF50",  # Green
            BookingStatus.CONFIRMED: "#2196F3",  # Blue
            BookingStatus.CHECKED_IN: "#9C27B0",  # Purple
            BookingStatus.COMPLETED: "#607D8B",  # Gray
            BookingStatus.REJECTED: "#F44336",  # Red
            BookingStatus.CANCELLED: "#9E9E9E",  # Light Gray
            BookingStatus.EXPIRED: "#757575",  # Dark Gray
        }
        return color_map.get(self.status, "#000000")


class DayBookings(BaseSchema):
    """
    All bookings and events for a specific day.
    
    Aggregates check-ins, check-outs, and pending bookings
    for a single calendar day.
    """

    day_date: dt.date = Field(
        ...,
        description="Date for this day's bookings",
    )

    # Events by Type
    check_ins: List[BookingEvent] = Field(
        default_factory=list,
        description="Check-in events for this day",
    )
    check_outs: List[BookingEvent] = Field(
        default_factory=list,
        description="Check-out events for this day",
    )
    pending_bookings: List[BookingEvent] = Field(
        default_factory=list,
        description="Pending booking requests for this day",
    )

    # Availability
    available_beds: int = Field(
        ...,
        ge=0,
        description="Number of beds available on this day",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total number of beds in hostel",
    )

    @computed_field
    @property
    def total_events(self) -> int:
        """Total number of events for this day."""
        return (
            len(self.check_ins)
            + len(self.check_outs)
            + len(self.pending_bookings)
        )

    @computed_field
    @property
    def occupancy_rate(self) -> float:
        """Calculate occupancy rate for this day."""
        if self.total_beds == 0:
            return 0.0
        occupied = self.total_beds - self.available_beds
        return round((occupied / self.total_beds) * 100, 2)

    @computed_field
    @property
    def is_fully_booked(self) -> bool:
        """Check if hostel is fully booked on this day."""
        return self.available_beds == 0

    @computed_field
    @property
    def is_high_activity_day(self) -> bool:
        """Check if this is a high-activity day (many events)."""
        return self.total_events >= 5


class CalendarView(BaseSchema):
    """
    Monthly calendar view of bookings.
    
    Provides a complete calendar view for a specific month
    showing all booking events and availability.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    month: str = Field(
        ...,
        pattern=r"^\d{4}-\d{2}$",
        description="Month in YYYY-MM format",
    )

    # Calendar Data (keyed by date string YYYY-MM-DD)
    days: Dict[str, DayBookings] = Field(
        ...,
        description="Bookings organized by date (YYYY-MM-DD as key)",
    )

    # Summary Statistics
    total_check_ins: int = Field(
        ...,
        ge=0,
        description="Total check-ins scheduled this month",
    )
    total_check_outs: int = Field(
        ...,
        ge=0,
        description="Total check-outs scheduled this month",
    )
    peak_occupancy_date: Optional[dt.date] = Field(
        None,
        description="Date with highest occupancy this month",
    )

    # Room Availability by Date
    available_rooms_by_date: Dict[str, int] = Field(
        ...,
        description="Available rooms count by date (YYYY-MM-DD as key)",
    )

    @field_validator("month")
    @classmethod
    def validate_month_format(cls, v: str) -> str:
        """Validate month format."""
        try:
            year, month_num = v.split("-")
            year_int = int(year)
            month_int = int(month_num)
            
            if year_int < 2020 or year_int > 2100:
                raise ValueError("Year must be between 2020 and 2100")
            
            if month_int < 1 or month_int > 12:
                raise ValueError("Month must be between 01 and 12")
            
            # Normalize to ensure zero-padding
            return f"{year_int:04d}-{month_int:02d}"
            
        except ValueError as e:
            raise ValueError(f"Invalid month format: {e}")

    @computed_field
    @property
    def total_events(self) -> int:
        """Calculate total events for the month."""
        return self.total_check_ins + self.total_check_outs

    @computed_field
    @property
    def busiest_week_start(self) -> Optional[date]:
        """Find the start date of the busiest week."""
        if not self.days:
            return None
        
        # This is a simplified calculation
        # In production, you'd calculate this based on actual weekly totals
        return self.peak_occupancy_date


class CalendarEvent(BaseSchema):
    """
    Generic calendar event for various event types.
    
    Supports booking-related events as well as maintenance,
    announcements, and other calendar items.
    """

    event_id: UUID = Field(
        ...,
        description="Unique event identifier",
    )
    event_type: str = Field(
        ...,
        pattern=r"^(check_in|check_out|booking_request|maintenance|announcement|blocked)$",
        description="Type of event",
    )
    title: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Event title",
    )
    start_date: dt.date = Field(
        ...,
        description="Event start date",
    )
    end_date: Optional[dt.date] = Field(
        None,
        description="Event end date (for multi-day events)",
    )

    # Related Entities
    booking_id: Optional[UUID] = Field(
        None,
        description="Related booking ID if applicable",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Related room ID if applicable",
    )

    # Display Properties
    color: str = Field(
        ...,
        pattern=r"^#[0-9A-Fa-f]{6}$",
        description="Hex color code for event display",
    )
    is_all_day: bool = Field(
        True,
        description="Whether this is an all-day event",
    )

    @field_validator("end_date")
    @classmethod
    def validate_end_date(cls, v: Optional[date], info) -> Optional[date]:
        """Validate end date is after or equal to start date."""
        start_date = info.data.get("start_date")
        if v is not None and start_date is not None:
            if v < start_date:
                raise ValueError(
                    f"End date ({v}) cannot be before start date ({start_date})"
                )
        return v

    @computed_field
    @property
    def duration_days(self) -> int:
        """Calculate event duration in days."""
        if self.end_date is None:
            return 1
        return (self.end_date - self.start_date).days + 1

    @computed_field
    @property
    def is_past_event(self) -> bool:
        """Check if event is in the past."""
        event_end = self.end_date or self.start_date
        return event_end < dt.date.today()


class DayAvailability(BaseSchema):
    """
    Bed availability for a specific day.
    
    Tracks available and booked beds for capacity planning.
    """

    day_date: dt.date = Field(
        ...,
        description="Date for this availability snapshot",
    )
    total_beds: int = Field(
        ...,
        ge=0,
        description="Total number of beds in hostel/room",
    )
    available_beds: int = Field(
        ...,
        ge=0,
        description="Number of beds currently available",
    )
    booked_beds: int = Field(
        ...,
        ge=0,
        description="Number of beds currently booked",
    )
    is_fully_booked: bool = Field(
        ...,
        description="Whether all beds are booked",
    )

    # Active Bookings
    active_bookings: List[UUID] = Field(
        default_factory=list,
        description="List of active booking IDs for this day",
    )

    @field_validator("booked_beds")
    @classmethod
    def validate_booked_beds(cls, v: int, info) -> int:
        """Validate booked beds doesn't exceed total."""
        total_beds = info.data.get("total_beds")
        if total_beds is not None and v > total_beds:
            raise ValueError(
                f"Booked beds ({v}) cannot exceed total beds ({total_beds})"
            )
        return v

    @field_validator("available_beds")
    @classmethod
    def validate_available_beds(cls, v: int, info) -> int:
        """Validate available beds calculation."""
        total_beds = info.data.get("total_beds")
        booked_beds = info.data.get("booked_beds")
        
        if total_beds is not None and booked_beds is not None:
            expected_available = total_beds - booked_beds
            if v != expected_available:
                raise ValueError(
                    f"Available beds ({v}) should equal "
                    f"total ({total_beds}) - booked ({booked_beds}) = {expected_available}"
                )
        
        return v

    @computed_field
    @property
    def occupancy_rate(self) -> float:
        """Calculate occupancy rate as percentage."""
        if self.total_beds == 0:
            return 0.0
        return round((self.booked_beds / self.total_beds) * 100, 2)

    @computed_field
    @property
    def availability_level(self) -> str:
        """
        Categorize availability level.
        
        Returns: "high", "medium", "low", or "full"
        """
        if self.is_fully_booked:
            return "full"
        
        availability_percentage = (self.available_beds / self.total_beds) * 100
        
        if availability_percentage >= 50:
            return "high"
        elif availability_percentage >= 20:
            return "medium"
        else:
            return "low"


class AvailabilityCalendar(BaseSchema):
    """
    Room availability calendar for a month.
    
    Provides daily availability tracking for capacity planning
    and booking management.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    room_id: Optional[UUID] = Field(
        None,
        description="Specific room ID, or None for all rooms",
    )
    month: str = Field(
        ...,
        pattern=r"^\d{4}-\d{2}$",
        description="Month in YYYY-MM format",
    )

    # Availability by Date
    availability: Dict[str, DayAvailability] = Field(
        ...,
        description="Daily availability keyed by date (YYYY-MM-DD)",
    )

    @field_validator("month")
    @classmethod
    def validate_month_format(cls, v: str) -> str:
        """Validate and normalize month format."""
        try:
            year, month_num = v.split("-")
            year_int = int(year)
            month_int = int(month_num)
            
            if year_int < 2020 or year_int > 2100:
                raise ValueError("Year must be between 2020 and 2100")
            
            if month_int < 1 or month_int > 12:
                raise ValueError("Month must be between 01 and 12")
            
            return f"{year_int:04d}-{month_int:02d}"
            
        except ValueError as e:
            raise ValueError(f"Invalid month format: {e}")

    @computed_field
    @property
    def average_occupancy_rate(self) -> float:
        """Calculate average occupancy rate for the month."""
        if not self.availability:
            return 0.0
        
        total_rate = sum(day.occupancy_rate for day in self.availability.values())
        return round(total_rate / len(self.availability), 2)

    @computed_field
    @property
    def days_fully_booked(self) -> int:
        """Count number of days that are fully booked."""
        return sum(1 for day in self.availability.values() if day.is_fully_booked)

    @computed_field
    @property
    def peak_occupancy_date(self) -> Optional[str]:
        """Find date with highest occupancy."""
        if not self.availability:
            return None
        
        peak_day = max(
            self.availability.items(),
            key=lambda x: x[1].occupancy_rate
        )
        return peak_day[0]
    
class BookingInfo(BaseSchema):
    """Basic booking information for availability calendar."""
    
    booking_id: UUID = Field(..., description="Booking identifier")
    student_name: str = Field(..., description="Student/guest name")
    check_in_date: dt.date = Field(..., description="Check-in date")
    check_out_date: dt.date = Field(..., description="Check-out date")

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking\booking_cancellation.py ---
# --- File: app/schemas/booking/booking_cancellation.py ---
"""
Booking cancellation schemas.

This module defines schemas for cancelling bookings, calculating refunds,
and managing cancellation policies.
"""

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "CancellationRequest",
    "CancellationResponse",
    "RefundCalculation",
    "CancellationPolicy",
    "CancellationCharge",
    "BulkCancellation",
]


class CancellationRequest(BaseCreateSchema):
    """
    Request to cancel a booking.
    
    Contains cancellation details including who is cancelling,
    reason, and refund preferences.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID to cancel",
    )
    cancelled_by_role: str = Field(
        ...,
        pattern=r"^(visitor|admin|system)$",
        description="Role of person/system cancelling: visitor, admin, or system",
    )

    cancellation_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Detailed reason for cancellation",
    )

    # Refund Preference
    request_refund: bool = Field(
        True,
        description="Whether to request refund of advance payment",
    )

    # Additional Details
    additional_comments: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional comments or context",
    )

    @field_validator("cancellation_reason")
    @classmethod
    def validate_cancellation_reason(cls, v: str) -> str:
        """Validate cancellation reason is meaningful."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError(
                "Cancellation reason must be at least 10 characters"
            )
        return v

    @field_validator("cancelled_by_role")
    @classmethod
    def normalize_role(cls, v: str) -> str:
        """Normalize role value."""
        return v.lower()

    @field_validator("additional_comments")
    @classmethod
    def clean_comments(cls, v: Optional[str]) -> Optional[str]:
        """Clean additional comments."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class RefundCalculation(BaseSchema):
    """
    Refund calculation details.
    
    Provides transparent breakdown of refund amount calculation
    based on cancellation policy.
    """

    advance_paid: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total advance amount paid",
    )
    cancellation_charge: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Cancellation charge amount",
    )
    cancellation_charge_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Cancellation charge as percentage of advance",
    )

    refundable_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Final amount to be refunded",
    )
    refund_processing_time_days: int = Field(
        ...,
        ge=0,
        description="Expected number of days to process refund",
    )

    # Refund Method
    refund_method: str = Field(
        ...,
        description="Method of refund (bank transfer, original payment method, etc.)",
    )

    # Detailed Breakdown
    breakdown: Dict = Field(
        ...,
        description="Detailed refund calculation breakdown",
    )

    @field_validator("refundable_amount")
    @classmethod
    def validate_refundable_amount(cls, v: Decimal, info) -> Decimal:
        """Validate refundable amount calculation."""
        advance_paid = info.data.get("advance_paid")
        cancellation_charge = info.data.get("cancellation_charge")
        
        if advance_paid is not None and cancellation_charge is not None:
            expected = advance_paid - cancellation_charge
            if expected < 0:
                expected = Decimal("0.00")
            
            # Allow small floating point differences
            if abs(v - expected) > Decimal("0.01"):
                raise ValueError(
                    f"Refundable amount (₹{v}) does not match calculation "
                    f"(₹{expected} = ₹{advance_paid} - ₹{cancellation_charge})"
                )
        
        return v


class CancellationResponse(BaseSchema):
    """
    Response after cancellation request.
    
    Confirms cancellation and provides refund details.
    """

    booking_id: UUID = Field(
        ...,
        description="Cancelled booking ID",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference number",
    )

    cancelled: bool = Field(
        ...,
        description="Whether cancellation was successful",
    )
    cancelled_at: datetime = Field(
        ...,
        description="Cancellation timestamp",
    )

    # Refund Information
    refund: RefundCalculation = Field(
        ...,
        description="Refund calculation details",
    )

    message: str = Field(
        ...,
        description="Cancellation confirmation message",
    )
    confirmation_sent: bool = Field(
        ...,
        description="Whether confirmation email/SMS was sent",
    )


class CancellationCharge(BaseSchema):
    """
    Cancellation charge tier based on timing.
    
    Defines cancellation charges based on how many days
    before check-in the cancellation occurs.
    """

    days_before_checkin: int = Field(
        ...,
        ge=0,
        description="Minimum days before check-in for this tier",
    )
    charge_percentage: Decimal = Field(
        ...,
        ge=0,
        le=100,
        decimal_places=2,
        description="Percentage of advance to charge as cancellation fee",
    )

    description: str = Field(
        ...,
        description="Human-readable description of this tier",
    )


class CancellationPolicy(BaseSchema):
    """
    Hostel cancellation policy configuration.
    
    Defines cancellation charges and refund policies for a hostel.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )

    # Tiered Cancellation Charges
    cancellation_before_days: List[CancellationCharge] = Field(
        ...,
        description="List of cancellation charge tiers based on timing",
    )

    # Special Conditions
    no_show_charge_percentage: Decimal = Field(
        Decimal("100.00"),
        ge=0,
        le=100,
        decimal_places=2,
        description="Charge if guest doesn't show up (typically 100%)",
    )

    # Processing
    refund_processing_days: int = Field(
        7,
        ge=1,
        le=30,
        description="Number of business days to process refund",
    )

    # Policy Documentation
    policy_text: str = Field(
        ...,
        description="Full cancellation policy text for display to users",
    )

    @field_validator("cancellation_before_days")
    @classmethod
    def validate_cancellation_tiers(
        cls,
        v: List[CancellationCharge],
    ) -> List[CancellationCharge]:
        """Validate cancellation charge tiers are properly ordered."""
        if not v:
            raise ValueError("At least one cancellation tier is required")
        
        # Sort by days_before_checkin descending
        sorted_tiers = sorted(v, key=lambda x: x.days_before_checkin, reverse=True)
        
        # Validate charges increase as check-in approaches
        for i in range(len(sorted_tiers) - 1):
            current = sorted_tiers[i]
            next_tier = sorted_tiers[i + 1]
            
            if current.charge_percentage > next_tier.charge_percentage:
                raise ValueError(
                    f"Cancellation charges must increase as check-in approaches. "
                    f"Tier at {current.days_before_checkin} days ({current.charge_percentage}%) "
                    f"has higher charge than tier at {next_tier.days_before_checkin} days "
                    f"({next_tier.charge_percentage}%)"
                )
        
        return sorted_tiers


class BulkCancellation(BaseCreateSchema):
    """
    Cancel multiple bookings in one operation.
    
    Used for batch cancellation (e.g., event cancellation,
    hostel closure, etc.).
    """

    booking_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of booking IDs to cancel (max 100)",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Common cancellation reason for all bookings",
    )
    process_refunds: bool = Field(
        True,
        description="Whether to process refunds for all cancellations",
    )

    @field_validator("booking_ids")
    @classmethod
    def validate_booking_ids(cls, v: List[UUID]) -> List[UUID]:
        """Validate booking IDs list."""
        if len(v) == 0:
            raise ValueError("At least one booking ID is required")
        
        if len(v) > 100:
            raise ValueError("Maximum 100 bookings can be cancelled at once")
        
        # Remove duplicates
        unique_ids = list(dict.fromkeys(v))
        
        return unique_ids

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate cancellation reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Cancellation reason must be at least 10 characters")
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking\booking_conversion.py ---
# --- File: app/schemas/booking/booking_conversion.py ---
"""
Booking to student conversion schemas.

This module defines schemas for converting confirmed bookings
into active student profiles after check-in.
"""

from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema

__all__ = [
    "ConvertToStudentRequest",
    "ConversionResponse",
    "ConversionChecklist",
    "ChecklistItem",
    "BulkConversion",
    "ConversionRollback",
]


class ConvertToStudentRequest(BaseCreateSchema):
    """
    Request to convert confirmed booking to student profile.
    
    Used after guest checks in to convert booking into
    active student residence.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID to convert",
    )

    # Check-in Confirmation
    actual_check_in_date: date = Field(
        ...,
        description="Actual check-in date (may differ from preferred)",
    )

    # Financial Confirmation
    security_deposit_paid: bool = Field(
        ...,
        description="Confirm security deposit has been paid",
    )
    first_month_rent_paid: bool = Field(
        ...,
        description="Confirm first month's rent has been paid",
    )

    # Additional Student Details (if not already in booking)
    student_id_number: Optional[str] = Field(
        None,
        max_length=50,
        description="Student ID or enrollment number",
    )
    guardian_address: Optional[str] = Field(
        None,
        max_length=500,
        description="Guardian's address",
    )

    # Document Verification
    id_proof_uploaded: bool = Field(
        False,
        description="ID proof document has been uploaded",
    )
    photo_uploaded: bool = Field(
        False,
        description="Student photo has been uploaded",
    )

    # Notes
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Conversion notes for internal reference",
    )

    @field_validator("actual_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date is not in the future."""
        if v > date.today():
            raise ValueError(
                f"Actual check-in date ({v.strftime('%Y-%m-%d')}) "
                "cannot be in the future"
            )
        
        # Warn if check-in is too far in the past (> 30 days)
        days_ago = (date.today() - v).days
        if days_ago > 30:
            # Log warning - might be data entry error
            pass
        
        return v

    @model_validator(mode="after")
    def validate_payments(self) -> "ConvertToStudentRequest":
        """Validate required payments are confirmed."""
        if not self.security_deposit_paid:
            raise ValueError(
                "Security deposit must be paid before conversion to student"
            )
        
        if not self.first_month_rent_paid:
            raise ValueError(
                "First month's rent must be paid before conversion to student"
            )
        
        return self

    @field_validator("notes")
    @classmethod
    def clean_notes(cls, v: Optional[str]) -> Optional[str]:
        """Clean notes field."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class ConversionResponse(BaseSchema):
    """
    Response after successful conversion to student.
    
    Provides confirmation and next steps for student onboarding.
    """

    booking_id: UUID = Field(
        ...,
        description="Original booking ID",
    )
    student_profile_id: UUID = Field(
        ...,
        description="Newly created student profile ID",
    )

    converted: bool = Field(
        ...,
        description="Whether conversion was successful",
    )
    conversion_date: date = Field(
        ...,
        description="Date of conversion",
    )

    # Assignment Details
    room_number: str = Field(
        ...,
        description="Assigned room number",
    )
    bed_number: str = Field(
        ...,
        description="Assigned bed number",
    )

    # Financial Setup
    monthly_rent: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly rent amount",
    )
    security_deposit: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Security deposit amount",
    )
    next_payment_due_date: date = Field(
        ...,
        description="Next rent payment due date",
    )

    message: str = Field(
        ...,
        description="Conversion confirmation message",
    )
    next_steps: List[str] = Field(
        ...,
        description="List of next steps for student/admin",
    )


class ChecklistItem(BaseSchema):
    """
    Individual checklist item for conversion validation.
    
    Represents a single requirement that must be met
    before conversion can proceed.
    """

    item_name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Name of checklist item",
    )
    description: str = Field(
        ...,
        description="Detailed description of requirement",
    )
    is_completed: bool = Field(
        ...,
        description="Whether this item is completed",
    )
    is_required: bool = Field(
        ...,
        description="Whether this item is mandatory for conversion",
    )
    completed_at: Optional[datetime] = Field(
        None,
        description="When this item was completed",
    )
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes about this item",
    )


class ConversionChecklist(BaseSchema):
    """
    Pre-conversion checklist validation.
    
    Checks all requirements before allowing conversion
    to student profile.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID being checked",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference",
    )

    # Checklist Items
    checks: List[ChecklistItem] = Field(
        ...,
        description="List of checklist items",
    )

    # Summary
    all_checks_passed: bool = Field(
        ...,
        description="Whether all required checks are completed",
    )
    can_convert: bool = Field(
        ...,
        description="Whether conversion can proceed",
    )

    missing_items: List[str] = Field(
        default_factory=list,
        description="List of missing/incomplete required items",
    )

    @field_validator("checks")
    @classmethod
    def validate_checks(cls, v: List[ChecklistItem]) -> List[ChecklistItem]:
        """Validate checklist has items."""
        if not v:
            raise ValueError("Checklist must have at least one item")
        return v


class BulkConversion(BaseCreateSchema):
    """
    Convert multiple bookings to students in bulk.
    
    Used for batch processing of check-ins.
    """

    booking_ids: List[UUID] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="List of booking IDs to convert (max 50)",
    )
    conversion_date: date = Field(
        ...,
        description="Common check-in/conversion date for all",
    )

    # Common Financial Confirmation
    all_deposits_paid: bool = Field(
        ...,
        description="Confirm all security deposits are paid",
    )
    all_first_rents_paid: bool = Field(
        ...,
        description="Confirm all first month rents are paid",
    )

    @field_validator("booking_ids")
    @classmethod
    def validate_booking_ids(cls, v: List[UUID]) -> List[UUID]:
        """Validate booking IDs list."""
        if len(v) == 0:
            raise ValueError("At least one booking ID is required")
        
        if len(v) > 50:
            raise ValueError("Maximum 50 bookings can be converted at once")
        
        # Remove duplicates
        unique_ids = list(dict.fromkeys(v))
        
        return unique_ids

    @field_validator("conversion_date")
    @classmethod
    def validate_conversion_date(cls, v: date) -> date:
        """Validate conversion date."""
        if v > date.today():
            raise ValueError("Conversion date cannot be in the future")
        
        # Warn if too old
        days_ago = (date.today() - v).days
        if days_ago > 7:
            # Log warning
            pass
        
        return v

    @model_validator(mode="after")
    def validate_financial_confirmation(self) -> "BulkConversion":
        """Validate financial confirmations."""
        if not self.all_deposits_paid:
            raise ValueError(
                "All security deposits must be confirmed paid for bulk conversion"
            )
        
        if not self.all_first_rents_paid:
            raise ValueError(
                "All first month rents must be confirmed paid for bulk conversion"
            )
        
        return self


class ConversionRollback(BaseCreateSchema):
    """
    Rollback a student conversion (emergency only).
    
    Used in cases where conversion was done in error
    or needs to be reversed.
    """

    student_profile_id: UUID = Field(
        ...,
        description="Student profile ID to rollback",
    )
    reason: str = Field(
        ...,
        min_length=20,
        max_length=500,
        description="Detailed reason for rollback (must be substantial)",
    )

    # Rollback Options
    delete_student_profile: bool = Field(
        False,
        description="Whether to delete the student profile",
    )
    restore_booking: bool = Field(
        True,
        description="Whether to restore original booking",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate rollback reason is substantial."""
        v = v.strip()
        if len(v) < 20:
            raise ValueError(
                "Rollback reason must be at least 20 characters "
                "and provide detailed justification"
            )
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking\booking_filters.py ---
# --- File: app/schemas/booking/booking_filters.py ---
"""
Booking filter and search schemas.

This module defines schemas for filtering, searching, sorting,
and exporting booking data.
"""

from __future__ import annotations

from datetime import date
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator

from app.schemas.common.base import BaseFilterSchema
from app.schemas.common.enums import BookingSource, BookingStatus, RoomType

__all__ = [
    "BookingFilterParams",
    "BookingSearchRequest",
    "BookingSortOptions",
    "BookingExportRequest",
    "BookingAnalyticsRequest",
]


class BookingFilterParams(BaseFilterSchema):
    """
    Comprehensive booking filter parameters.
    
    Supports filtering by various criteria including status,
    dates, hostel, room type, and more.
    """

    # Text Search
    search: Optional[str] = Field(
        None,
        max_length=255,
        description="Search in booking reference, guest name, email, or phone",
    )

    # Hostel Filters
    hostel_id: Optional[UUID] = Field(
        None,
        description="Filter by specific hostel",
    )
    hostel_ids: Optional[List[UUID]] = Field(
        None,
        max_length=20,
        description="Filter by multiple hostels (max 20)",
    )

    # Status Filters
    status: Optional[BookingStatus] = Field(
        None,
        description="Filter by specific status",
    )
    statuses: Optional[List[BookingStatus]] = Field(
        None,
        max_length=10,
        description="Filter by multiple statuses",
    )

    # Date Filters
    booking_date_from: Optional[date] = Field(
        None,
        description="Filter bookings created from this date",
    )
    booking_date_to: Optional[date] = Field(
        None,
        description="Filter bookings created until this date",
    )
    check_in_date_from: Optional[date] = Field(
        None,
        description="Filter by check-in date from",
    )
    check_in_date_to: Optional[date] = Field(
        None,
        description="Filter by check-in date until",
    )

    # Room Type Filter
    room_type: Optional[RoomType] = Field(
        None,
        description="Filter by room type",
    )

    # Source Filter
    source: Optional[BookingSource] = Field(
        None,
        description="Filter by booking source",
    )

    # Payment Status
    advance_paid: Optional[bool] = Field(
        None,
        description="Filter by advance payment status",
    )

    # Conversion Status
    converted_to_student: Optional[bool] = Field(
        None,
        description="Filter by student conversion status",
    )

    # Urgency Filters
    expiring_soon: Optional[bool] = Field(
        None,
        description="Show only bookings expiring in next 24 hours",
    )
    expired: Optional[bool] = Field(
        None,
        description="Show only expired bookings",
    )

    @field_validator("booking_date_to")
    @classmethod
    def validate_booking_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate booking date range."""
        booking_date_from = info.data.get("booking_date_from")
        if v is not None and booking_date_from is not None:
            if v < booking_date_from:
                raise ValueError(
                    "booking_date_to must be after or equal to booking_date_from"
                )
        return v

    @field_validator("check_in_date_to")
    @classmethod
    def validate_check_in_date_range(cls, v: Optional[date], info) -> Optional[date]:
        """Validate check-in date range."""
        check_in_date_from = info.data.get("check_in_date_from")
        if v is not None and check_in_date_from is not None:
            if v < check_in_date_from:
                raise ValueError(
                    "check_in_date_to must be after or equal to check_in_date_from"
                )
        return v


class BookingSearchRequest(BaseFilterSchema):
    """
    Booking search request with pagination.
    
    Supports full-text search across booking fields.
    """

    query: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Search query string",
    )
    hostel_id: Optional[UUID] = Field(
        None,
        description="Limit search to specific hostel",
    )

    # Search Fields (which fields to search in)
    search_in_reference: bool = Field(
        True,
        description="Search in booking reference",
    )
    search_in_guest_name: bool = Field(
        True,
        description="Search in guest name",
    )
    search_in_email: bool = Field(
        True,
        description="Search in email address",
    )
    search_in_phone: bool = Field(
        True,
        description="Search in phone number",
    )

    # Status Filter
    status: Optional[BookingStatus] = Field(
        None,
        description="Limit search to specific status",
    )

    # Pagination
    page: int = Field(
        1,
        ge=1,
        description="Page number (1-indexed)",
    )
    page_size: int = Field(
        20,
        ge=1,
        le=100,
        description="Items per page (max 100)",
    )

    @field_validator("query")
    @classmethod
    def validate_query(cls, v: str) -> str:
        """Validate and clean search query."""
        v = v.strip()
        if len(v) == 0:
            raise ValueError("Search query cannot be empty")
        return v


class BookingSortOptions(BaseFilterSchema):
    """
    Booking sorting options.
    
    Defines how to sort booking results.
    """

    sort_by: str = Field(
        "booking_date",
        pattern=r"^(booking_date|check_in_date|guest_name|status|total_amount)$",
        description="Field to sort by",
    )
    sort_order: str = Field(
        "desc",
        pattern=r"^(asc|desc)$",
        description="Sort order: ascending or descending",
    )

    @field_validator("sort_by", "sort_order")
    @classmethod
    def normalize_sort_fields(cls, v: str) -> str:
        """Normalize sort field values."""
        return v.lower()


class BookingExportRequest(BaseFilterSchema):
    """
    Request to export bookings data.
    
    Supports multiple export formats with customizable fields.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Export bookings for specific hostel",
    )
    filters: Optional[BookingFilterParams] = Field(
        None,
        description="Apply filters to export",
    )

    # Export Format
    format: str = Field(
        "csv",
        pattern=r"^(csv|excel|pdf)$",
        description="Export format: csv, excel, or pdf",
    )

    # Fields to Include
    include_guest_details: bool = Field(
        True,
        description="Include guest personal details",
    )
    include_payment_details: bool = Field(
        True,
        description="Include payment information",
    )
    include_assignment_details: bool = Field(
        True,
        description="Include room/bed assignment details",
    )

    @field_validator("format")
    @classmethod
    def normalize_format(cls, v: str) -> str:
        """Normalize export format."""
        return v.lower()


class BookingAnalyticsRequest(BaseFilterSchema):
    """
    Request for booking analytics data.
    
    Generate analytics and reports for bookings within
    a specified date range.
    """

    hostel_id: Optional[UUID] = Field(
        None,
        description="Generate analytics for specific hostel (or all)",
    )
    date_from: date = Field(
        ...,
        description="Analytics start date",
    )
    date_to: date = Field(
        ...,
        description="Analytics end date",
    )

    # Grouping
    group_by: str = Field(
        "day",
        pattern=r"^(day|week|month)$",
        description="Group analytics by: day, week, or month",
    )

    @field_validator("date_to")
    @classmethod
    def validate_date_range(cls, v: date, info) -> date:
        """Validate date range."""
        date_from = info.data.get("date_from")
        if date_from is not None:
            if v < date_from:
                raise ValueError("date_to must be after or equal to date_from")
            
            # Limit to reasonable range (e.g., max 1 year)
            days_diff = (v - date_from).days
            if days_diff > 365:
                raise ValueError(
                    "Date range cannot exceed 365 days for analytics"
                )
        
        return v

    @field_validator("group_by")
    @classmethod
    def normalize_group_by(cls, v: str) -> str:
        """Normalize group_by value."""
        return v.lower()

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking\booking_modification.py ---
# --- File: app/schemas/booking/booking_modification.py ---
"""
Booking modification schemas.

This module defines schemas for modifying existing bookings including
date changes, duration changes, and room type changes.
"""

from __future__ import annotations

from datetime import date
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import RoomType

__all__ = [
    "ModificationRequest",
    "ModificationResponse",
    "DateChangeRequest",
    "DurationChangeRequest",
    "RoomTypeChangeRequest",
    "ModificationApproval",
]


class ModificationRequest(BaseCreateSchema):
    """
    General booking modification request.
    
    Allows modification of multiple aspects of a booking
    in a single request.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID to modify",
    )

    # Check-in Date Modification
    modify_check_in_date: bool = Field(
        False,
        description="Whether to modify check-in date",
    )
    new_check_in_date: Optional[date] = Field(
        None,
        description="New check-in date if modifying",
    )

    # Duration Modification
    modify_duration: bool = Field(
        False,
        description="Whether to modify stay duration",
    )
    new_duration_months: Optional[int] = Field(
        None,
        ge=1,
        le=24,
        description="New duration in months if modifying",
    )

    # Room Type Modification
    modify_room_type: bool = Field(
        False,
        description="Whether to modify room type",
    )
    new_room_type: Optional[RoomType] = Field(
        None,
        description="New room type if modifying",
    )

    # Justification
    modification_reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for modification request",
    )

    # Acknowledgment
    accept_price_change: bool = Field(
        False,
        description="Acknowledge and accept if modification results in price change",
    )

    @model_validator(mode="after")
    def validate_at_least_one_modification(self) -> "ModificationRequest":
        """Ensure at least one modification is requested."""
        if not (
            self.modify_check_in_date
            or self.modify_duration
            or self.modify_room_type
        ):
            raise ValueError(
                "At least one modification type must be selected "
                "(check-in date, duration, or room type)"
            )
        return self

    @model_validator(mode="after")
    def validate_modification_values(self) -> "ModificationRequest":
        """Validate that required values are provided for selected modifications."""
        if self.modify_check_in_date and self.new_check_in_date is None:
            raise ValueError(
                "new_check_in_date is required when modify_check_in_date is True"
            )
        
        if self.modify_duration and self.new_duration_months is None:
            raise ValueError(
                "new_duration_months is required when modify_duration is True"
            )
        
        if self.modify_room_type and self.new_room_type is None:
            raise ValueError(
                "new_room_type is required when modify_room_type is True"
            )
        
        return self

    @field_validator("new_check_in_date")
    @classmethod
    def validate_new_check_in_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate new check-in date."""
        if v is not None and v < date.today():
            raise ValueError(
                f"New check-in date ({v}) cannot be in the past"
            )
        return v

    @field_validator("modification_reason")
    @classmethod
    def validate_modification_reason(cls, v: str) -> str:
        """Validate modification reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError(
                "Modification reason must be at least 10 characters"
            )
        return v


class ModificationResponse(BaseSchema):
    """
    Response to modification request.
    
    Provides details about what was changed and pricing impact.
    """

    booking_id: UUID = Field(
        ...,
        description="Modified booking ID",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference",
    )

    # Modifications Applied
    modifications_applied: List[str] = Field(
        ...,
        description="List of modifications that were applied",
    )

    # Pricing Impact
    original_total: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Original total amount",
    )
    new_total: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="New total amount after modifications",
    )
    price_difference: Decimal = Field(
        ...,
        decimal_places=2,
        description="Price difference (positive = increase, negative = decrease)",
    )
    additional_payment_required: bool = Field(
        ...,
        description="Whether additional payment is required",
    )
    additional_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Additional amount to be paid if increased",
    )

    # Approval Status
    requires_admin_approval: bool = Field(
        ...,
        description="Whether modification requires admin approval",
    )
    auto_approved: bool = Field(
        ...,
        description="Whether modification was automatically approved",
    )

    message: str = Field(
        ...,
        description="Result message",
    )


class DateChangeRequest(BaseCreateSchema):
    """
    Specific request to change check-in date.
    
    Simplified schema for date-only modifications.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID",
    )
    new_check_in_date: date = Field(
        ...,
        description="New desired check-in date",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for date change",
    )

    @field_validator("new_check_in_date")
    @classmethod
    def validate_new_date(cls, v: date) -> date:
        """Validate new check-in date."""
        if v < date.today():
            raise ValueError(
                f"New check-in date ({v.strftime('%Y-%m-%d')}) cannot be in the past"
            )
        return v

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Reason must be at least 10 characters")
        return v


class DurationChangeRequest(BaseCreateSchema):
    """
    Specific request to change stay duration.
    
    Simplified schema for duration-only modifications.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID",
    )
    new_duration_months: int = Field(
        ...,
        ge=1,
        le=24,
        description="New stay duration in months (1-24)",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for duration change",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Reason must be at least 10 characters")
        return v


class RoomTypeChangeRequest(BaseCreateSchema):
    """
    Specific request to change room type.
    
    Simplified schema for room type-only modifications.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking ID",
    )
    new_room_type: RoomType = Field(
        ...,
        description="New desired room type",
    )
    reason: str = Field(
        ...,
        min_length=10,
        max_length=500,
        description="Reason for room type change",
    )
    accept_price_difference: bool = Field(
        False,
        description="Accept price difference if room type has different pricing",
    )

    @field_validator("reason")
    @classmethod
    def validate_reason(cls, v: str) -> str:
        """Validate reason."""
        v = v.strip()
        if len(v) < 10:
            raise ValueError("Reason must be at least 10 characters")
        return v


class ModificationApproval(BaseCreateSchema):
    """
    Admin approval/rejection of modification request.
    
    Used when modification requires manual admin review.
    """

    modification_request_id: UUID = Field(
        ...,
        description="Modification request ID",
    )
    approved: bool = Field(
        ...,
        description="Whether to approve (True) or reject (False) the modification",
    )

    # If Approved
    adjusted_price: Optional[Decimal] = Field(
        None,
        ge=0,
        decimal_places=2,
        description="Adjusted price if admin wants to override calculated price",
    )

    # If Rejected
    rejection_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for rejection if not approved",
    )

    # Admin Notes
    admin_notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Internal admin notes about the decision",
    )

    @model_validator(mode="after")
    def validate_approval_fields(self) -> "ModificationApproval":
        """Validate approval-specific fields."""
        if not self.approved and not self.rejection_reason:
            raise ValueError(
                "rejection_reason is required when modification is rejected"
            )
        
        return self

    @field_validator("rejection_reason")
    @classmethod
    def validate_rejection_reason(cls, v: Optional[str]) -> Optional[str]:
        """Validate rejection reason if provided."""
        if v is not None:
            v = v.strip()
            if len(v) < 10:
                raise ValueError(
                    "Rejection reason must be at least 10 characters if provided"
                )
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking\booking_request.py ---
# --- File: app/schemas/booking/booking_request.py ---
"""
Booking request schemas for initiating bookings.

This module defines schemas for various types of booking requests
including full bookings, inquiries, and quick bookings.
"""

from __future__ import annotations

from datetime import date
from typing import Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator, model_validator

from app.schemas.common.base import BaseCreateSchema, BaseSchema
from app.schemas.common.enums import RoomType

__all__ = [
    "GuestInformation",
    "BookingRequest",
    "BookingInquiry",
    "QuickBookingRequest",
]


class GuestInformation(BaseSchema):
    """
    Guest information schema for bookings.
    
    Contains all personal, contact, and background information
    about the guest making the booking.
    """

    # Basic Information
    guest_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Full name of the guest",
    )
    guest_email: EmailStr = Field(
        ...,
        description="Email address for communication and booking confirmations",
    )
    guest_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact phone number (with optional country code)",
    )

    # ID Proof (optional at booking, required at check-in)
    guest_id_proof_type: Optional[str] = Field(
        None,
        pattern=r"^(aadhaar|passport|driving_license|voter_id|pan_card)$",
        description="Type of government-issued ID proof",
    )
    guest_id_proof_number: Optional[str] = Field(
        None,
        max_length=50,
        description="ID proof number/reference",
    )

    # Emergency Contact
    emergency_contact_name: Optional[str] = Field(
        None,
        max_length=255,
        description="Name of emergency contact person",
    )
    emergency_contact_phone: Optional[str] = Field(
        None,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Emergency contact phone number",
    )
    emergency_contact_relation: Optional[str] = Field(
        None,
        max_length=50,
        description="Relationship to emergency contact (parent, spouse, friend, etc.)",
    )

    # Institutional/Employment Details
    institution_or_company: Optional[str] = Field(
        None,
        max_length=255,
        description="Name of educational institution or employer",
    )
    designation_or_course: Optional[str] = Field(
        None,
        max_length=255,
        description="Job designation or course/program of study",
    )

    @field_validator("guest_name")
    @classmethod
    def validate_guest_name(cls, v: str) -> str:
        """Validate and clean guest name."""
        v = v.strip()
        
        if len(v) < 2:
            raise ValueError("Guest name must be at least 2 characters long")
        
        # Ensure at least one word
        if not v.split():
            raise ValueError("Guest name cannot be empty or only whitespace")
        
        # Check for numbers (names shouldn't contain digits)
        if any(char.isdigit() for char in v):
            raise ValueError("Guest name should not contain numbers")
        
        return v

    @field_validator("guest_phone", "emergency_contact_phone")
    @classmethod
    def validate_phone_number(cls, v: Optional[str]) -> Optional[str]:
        """Validate and normalize phone number."""
        if v is None:
            return v
        
        # Remove common formatting characters
        v = v.replace(" ", "").replace("-", "").replace("(", "").replace(")", "")
        
        # Check minimum length
        if len(v) < 10:
            raise ValueError("Phone number must be at least 10 digits")
        
        return v

    @model_validator(mode="after")
    def validate_id_proof_consistency(self) -> "GuestInformation":
        """Ensure ID proof type and number are provided together."""
        has_type = self.guest_id_proof_type is not None
        has_number = self.guest_id_proof_number is not None
        
        if has_type != has_number:
            raise ValueError(
                "Both ID proof type and number must be provided together, or both omitted"
            )
        
        return self

    @model_validator(mode="after")
    def validate_emergency_contact_consistency(self) -> "GuestInformation":
        """Ensure emergency contact fields are provided together."""
        has_name = self.emergency_contact_name is not None
        has_phone = self.emergency_contact_phone is not None
        
        # If either is provided, both should be provided
        if has_name or has_phone:
            if not (has_name and has_phone):
                raise ValueError(
                    "Both emergency contact name and phone must be provided together"
                )
        
        return self


class BookingRequest(BaseCreateSchema):
    """
    Complete booking request schema.
    
    Contains all information needed to create a booking including
    hostel selection, room preferences, guest details, and special requirements.
    """

    hostel_id: UUID = Field(
        ...,
        description="Unique identifier of the hostel to book",
    )

    # Booking Preferences
    room_type_requested: RoomType = Field(
        ...,
        description="Desired type of room (single, double, dormitory, etc.)",
    )
    preferred_check_in_date: date = Field(
        ...,
        description="Desired check-in date",
    )
    stay_duration_months: int = Field(
        ...,
        ge=1,
        le=24,
        description="Intended stay duration in months (1-24)",
    )

    # Guest Information
    guest_info: GuestInformation = Field(
        ...,
        description="Detailed guest information",
    )

    # Special Requirements
    special_requests: Optional[str] = Field(
        None,
        max_length=1000,
        description="Any special requests or requirements (quiet room, ground floor, etc.)",
    )
    dietary_preferences: Optional[str] = Field(
        None,
        max_length=255,
        description="Dietary preferences or restrictions (vegetarian, vegan, allergies, etc.)",
    )
    has_vehicle: bool = Field(
        False,
        description="Whether guest has a vehicle and needs parking",
    )
    vehicle_details: Optional[str] = Field(
        None,
        max_length=255,
        description="Vehicle details if applicable (type, registration, etc.)",
    )

    # Referral
    referral_code: Optional[str] = Field(
        None,
        max_length=50,
        description="Referral or promo code if applicable",
    )

    @field_validator("preferred_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date is in the future."""
        if v < date.today():
            raise ValueError(
                f"Check-in date ({v.strftime('%Y-%m-%d')}) cannot be in the past. "
                "Please select today or a future date."
            )
        
        # Warn about very far future dates (> 6 months)
        days_ahead = (v - date.today()).days
        if days_ahead > 180:
            # Log warning but don't reject
            # In production, this could trigger a notification
            pass
        
        return v

    @model_validator(mode="after")
    def validate_vehicle_consistency(self) -> "BookingRequest":
        """Ensure vehicle details are provided if has_vehicle is True."""
        if self.has_vehicle and not self.vehicle_details:
            raise ValueError(
                "Vehicle details must be provided when has_vehicle is True"
            )
        
        return self

    @field_validator("special_requests", "dietary_preferences", "vehicle_details")
    @classmethod
    def clean_optional_text(cls, v: Optional[str]) -> Optional[str]:
        """Clean optional text fields."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class BookingInquiry(BaseCreateSchema):
    """
    Simple inquiry schema for potential bookings.
    
    Used when a visitor wants to express interest without
    making a full booking commitment.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel of interest",
    )

    # Basic Contact Information
    visitor_name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Name of the person inquiring",
    )
    visitor_email: EmailStr = Field(
        ...,
        description="Email address for follow-up",
    )
    visitor_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Contact phone number",
    )

    # Interest Details (all optional)
    room_type_interest: Optional[RoomType] = Field(
        None,
        description="Room type of interest",
    )
    preferred_check_in_date: Optional[date] = Field(
        None,
        description="Approximate check-in date if known",
    )
    message: Optional[str] = Field(
        None,
        max_length=1000,
        description="Additional message or questions",
    )

    @field_validator("visitor_name")
    @classmethod
    def validate_visitor_name(cls, v: str) -> str:
        """Validate visitor name."""
        v = v.strip()
        if len(v) < 2:
            raise ValueError("Name must be at least 2 characters")
        return v

    @field_validator("visitor_phone")
    @classmethod
    def validate_phone(cls, v: str) -> str:
        """Normalize phone number."""
        return v.replace(" ", "").replace("-", "")

    @field_validator("preferred_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: Optional[date]) -> Optional[date]:
        """Validate check-in date if provided."""
        if v is not None and v < date.today():
            raise ValueError("Check-in date cannot be in the past")
        return v


class QuickBookingRequest(BaseCreateSchema):
    """
    Quick booking schema with minimal required information.
    
    Used for fast-track bookings where detailed information
    can be collected later.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel to book",
    )
    room_type_requested: RoomType = Field(
        ...,
        description="Desired room type",
    )
    check_in_date: date = Field(
        ...,
        description="Check-in date",
    )
    duration_months: int = Field(
        ...,
        ge=1,
        le=24,
        description="Stay duration in months",
    )

    # Minimal Guest Information
    name: str = Field(
        ...,
        min_length=2,
        max_length=255,
        description="Guest name",
    )
    email: EmailStr = Field(
        ...,
        description="Guest email",
    )
    phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Guest phone",
    )

    @field_validator("check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date."""
        if v < date.today():
            raise ValueError(
                f"Check-in date ({v.strftime('%Y-%m-%d')}) must be today or in the future"
            )
        return v

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        """Validate and clean name."""
        v = v.strip()
        if len(v) < 2:
            raise ValueError("Name must be at least 2 characters")
        if any(char.isdigit() for char in v):
            raise ValueError("Name should not contain numbers")
        return v

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking\booking_response.py ---
# --- File: app/schemas/booking/booking_response.py ---
"""
Booking response schemas for API responses.

This module defines response schemas for booking data including
basic responses, detailed information, list items, and confirmations.
"""

from __future__ import annotations

from datetime import date, datetime, timedelta
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from pydantic import Field, computed_field

from app.schemas.common.base import BaseResponseSchema, BaseSchema
from app.schemas.common.enums import BookingSource, BookingStatus, RoomType

__all__ = [
    "BookingResponse",
    "BookingDetail",
    "BookingListItem",
    "BookingConfirmation",
]


class BookingResponse(BaseResponseSchema):
    """
    Standard booking response schema.
    
    Contains core booking information for API responses.
    """

    booking_reference: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Unique human-readable booking reference",
    )
    visitor_id: UUID = Field(
        ...,
        description="Visitor/guest identifier",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Name of the hostel",
    )

    # Booking Details
    room_type_requested: RoomType = Field(
        ...,
        description="Type of room requested",
    )
    preferred_check_in_date: date = Field(
        ...,
        description="Preferred check-in date",
    )
    stay_duration_months: int = Field(
        ...,
        ge=1,
        description="Stay duration in months",
    )
    expected_check_out_date: date = Field(
        ...,
        description="Calculated expected check-out date",
    )

    # Guest Information
    guest_name: str = Field(
        ...,
        description="Guest full name",
    )
    guest_email: str = Field(
        ...,
        description="Guest email address",
    )
    guest_phone: str = Field(
        ...,
        description="Guest contact phone",
    )

    # Pricing
    quoted_rent_monthly: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Monthly rent amount",
    )
    total_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Total booking amount",
    )
    security_deposit: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Security deposit amount",
    )
    advance_amount: Decimal = Field(
        ...,
        ge=0,
        decimal_places=2,
        description="Advance payment amount",
    )
    advance_paid: bool = Field(
        ...,
        description="Whether advance payment has been made",
    )

    # Status
    booking_status: BookingStatus = Field(
        ...,
        description="Current booking status",
    )

    # Timestamps
    booking_date: datetime = Field(
        ...,
        description="When booking was created",
    )
    expires_at: Optional[datetime] = Field(
        None,
        description="When booking expires if not confirmed",
    )

    @computed_field
    @property
    def days_until_check_in(self) -> int:
        """Calculate days until check-in."""
        return (self.preferred_check_in_date - date.today()).days

    @computed_field
    @property
    def is_expiring_soon(self) -> bool:
        """Check if booking is expiring within 24 hours."""
        if self.expires_at is None:
            return False
        return (self.expires_at - datetime.utcnow()).total_seconds() < 86400

    @computed_field
    @property
    def balance_amount(self) -> Decimal:
        """Calculate remaining balance after advance."""
        if self.advance_paid:
            return (self.total_amount - self.advance_amount).quantize(Decimal("0.01"))
        return self.total_amount


class BookingDetail(BaseResponseSchema):
    """
    Detailed booking information schema.
    
    Contains complete booking information including guest details,
    assignments, workflow status, and all related metadata.
    """

    booking_reference: str = Field(
        ...,
        description="Unique booking reference",
    )
    visitor_id: UUID = Field(
        ...,
        description="Visitor identifier",
    )
    visitor_name: str = Field(
        ...,
        description="Visitor/user name",
    )

    # Hostel Information
    hostel_id: UUID = Field(
        ...,
        description="Hostel identifier",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    hostel_city: str = Field(
        ...,
        description="Hostel city",
    )
    hostel_address: str = Field(
        ...,
        description="Hostel full address",
    )
    hostel_phone: str = Field(
        ...,
        description="Hostel contact phone",
    )

    # Booking Details
    room_type_requested: RoomType = Field(
        ...,
        description="Requested room type",
    )
    preferred_check_in_date: date = Field(
        ...,
        description="Preferred check-in date",
    )
    stay_duration_months: int = Field(
        ...,
        ge=1,
        description="Stay duration in months",
    )
    expected_check_out_date: date = Field(
        ...,
        description="Expected check-out date",
    )

    # Room Assignment (if approved)
    room_id: Optional[UUID] = Field(
        None,
        description="Assigned room ID (if approved)",
    )
    room_number: Optional[str] = Field(
        None,
        description="Assigned room number",
    )
    bed_id: Optional[UUID] = Field(
        None,
        description="Assigned bed ID (if approved)",
    )
    bed_number: Optional[str] = Field(
        None,
        description="Assigned bed number",
    )

    # Guest Information
    guest_name: str = Field(
        ...,
        description="Guest full name",
    )
    guest_email: str = Field(
        ...,
        description="Guest email",
    )
    guest_phone: str = Field(
        ...,
        description="Guest phone",
    )
    guest_id_proof_type: Optional[str] = Field(
        None,
        description="ID proof type",
    )
    guest_id_proof_number: Optional[str] = Field(
        None,
        description="ID proof number",
    )

    # Emergency Contact
    emergency_contact_name: Optional[str] = Field(
        None,
        description="Emergency contact name",
    )
    emergency_contact_phone: Optional[str] = Field(
        None,
        description="Emergency contact phone",
    )
    emergency_contact_relation: Optional[str] = Field(
        None,
        description="Relation to emergency contact",
    )

    # Institutional/Employment
    institution_or_company: Optional[str] = Field(
        None,
        description="Institution or company name",
    )
    designation_or_course: Optional[str] = Field(
        None,
        description="Designation or course",
    )

    # Special Requirements
    special_requests: Optional[str] = Field(
        None,
        description="Special requests",
    )
    dietary_preferences: Optional[str] = Field(
        None,
        description="Dietary preferences",
    )
    has_vehicle: bool = Field(
        ...,
        description="Has vehicle",
    )
    vehicle_details: Optional[str] = Field(
        None,
        description="Vehicle details",
    )

    # Pricing
    quoted_rent_monthly: Decimal = Field(
        ...,
        ge=0,
        description="Monthly rent quoted",
    )
    total_amount: Decimal = Field(
        ...,
        ge=0,
        description="Total amount",
    )
    security_deposit: Decimal = Field(
        ...,
        ge=0,
        description="Security deposit",
    )
    advance_amount: Decimal = Field(
        ...,
        ge=0,
        description="Advance amount",
    )
    advance_paid: bool = Field(
        ...,
        description="Advance payment status",
    )
    advance_payment_id: Optional[UUID] = Field(
        None,
        description="Advance payment transaction ID",
    )

    # Status Workflow
    booking_status: BookingStatus = Field(
        ...,
        description="Current booking status",
    )

    # Approval Details
    approved_by: Optional[UUID] = Field(
        None,
        description="Admin who approved booking",
    )
    approved_by_name: Optional[str] = Field(
        None,
        description="Approver name",
    )
    approved_at: Optional[datetime] = Field(
        None,
        description="Approval timestamp",
    )

    # Rejection Details
    rejected_by: Optional[UUID] = Field(
        None,
        description="Admin who rejected booking",
    )
    rejected_at: Optional[datetime] = Field(
        None,
        description="Rejection timestamp",
    )
    rejection_reason: Optional[str] = Field(
        None,
        description="Reason for rejection",
    )

    # Cancellation Details
    cancelled_by: Optional[UUID] = Field(
        None,
        description="Who cancelled the booking",
    )
    cancelled_at: Optional[datetime] = Field(
        None,
        description="Cancellation timestamp",
    )
    cancellation_reason: Optional[str] = Field(
        None,
        description="Reason for cancellation",
    )

    # Conversion to Student
    converted_to_student: bool = Field(
        ...,
        description="Whether booking was converted to student profile",
    )
    student_profile_id: Optional[UUID] = Field(
        None,
        description="Student profile ID if converted",
    )
    conversion_date: Optional[date] = Field(
        None,
        description="Date of conversion to student",
    )

    # Source
    source: BookingSource = Field(
        ...,
        description="Booking source",
    )
    referral_code: Optional[str] = Field(
        None,
        description="Referral code used",
    )

    # Timestamps
    booking_date: datetime = Field(
        ...,
        description="Booking creation timestamp",
    )
    expires_at: Optional[datetime] = Field(
        None,
        description="Booking expiry timestamp",
    )

    @computed_field
    @property
    def is_assigned(self) -> bool:
        """Check if room and bed are assigned."""
        return self.room_id is not None and self.bed_id is not None

    @computed_field
    @property
    def days_until_check_in(self) -> int:
        """Days remaining until check-in."""
        return (self.preferred_check_in_date - date.today()).days

    @computed_field
    @property
    def balance_amount(self) -> Decimal:
        """Calculate balance amount."""
        if self.advance_paid:
            return (self.total_amount - self.advance_amount).quantize(Decimal("0.01"))
        return self.total_amount


class BookingListItem(BaseSchema):
    """
    Booking list item for summary views.
    
    Optimized schema for listing multiple bookings with
    essential information only.
    """

    id: UUID = Field(
        ...,
        description="Booking ID",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference",
    )
    guest_name: str = Field(
        ...,
        description="Guest name",
    )
    guest_phone: str = Field(
        ...,
        description="Guest phone",
    )

    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    room_type_requested: str = Field(
        ...,
        description="Requested room type",
    )

    preferred_check_in_date: date = Field(
        ...,
        description="Check-in date",
    )
    stay_duration_months: int = Field(
        ...,
        ge=1,
        description="Duration in months",
    )

    total_amount: Decimal = Field(
        ...,
        ge=0,
        description="Total amount",
    )
    advance_paid: bool = Field(
        ...,
        description="Advance payment status",
    )

    booking_status: BookingStatus = Field(
        ...,
        description="Booking status",
    )
    booking_date: datetime = Field(
        ...,
        description="Booking date",
    )

    # Quick Indicators
    is_urgent: bool = Field(
        ...,
        description="Whether booking is expiring soon or requires urgent attention",
    )
    days_until_checkin: Optional[int] = Field(
        None,
        description="Days until check-in (if applicable)",
    )

    @computed_field
    @property
    def status_badge_color(self) -> str:
        """Get color code for status badge."""
        status_colors = {
            BookingStatus.PENDING: "warning",
            BookingStatus.APPROVED: "success",
            BookingStatus.CONFIRMED: "info",
            BookingStatus.CHECKED_IN: "primary",
            BookingStatus.COMPLETED: "secondary",
            BookingStatus.REJECTED: "danger",
            BookingStatus.CANCELLED: "dark",
            BookingStatus.EXPIRED: "muted",
        }
        return status_colors.get(self.booking_status, "secondary")


class BookingConfirmation(BaseSchema):
    """
    Booking confirmation response.
    
    Sent to guest after successful booking creation or approval.
    """

    booking_id: UUID = Field(
        ...,
        description="Booking identifier",
    )
    booking_reference: str = Field(
        ...,
        description="Booking reference number",
    )

    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    room_type: str = Field(
        ...,
        description="Room type",
    )
    check_in_date: date = Field(
        ...,
        description="Check-in date",
    )

    total_amount: Decimal = Field(
        ...,
        ge=0,
        description="Total booking amount",
    )
    advance_amount: Decimal = Field(
        ...,
        ge=0,
        description="Advance payment required",
    )
    balance_amount: Decimal = Field(
        ...,
        ge=0,
        description="Balance amount to be paid",
    )

    confirmation_message: str = Field(
        ...,
        description="Confirmation message for guest",
    )
    next_steps: List[str] = Field(
        ...,
        description="List of next steps for guest",
    )

    # Contact Information
    hostel_contact_phone: str = Field(
        ...,
        description="Hostel contact phone",
    )
    hostel_contact_email: Optional[str] = Field(
        None,
        description="Hostel contact email",
    )

    @computed_field
    @property
    def payment_pending(self) -> bool:
        """Check if payment is still pending."""
        return self.balance_amount > Decimal("0")

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking\booking_waitlist.py ---
# --- File: app/schemas/booking/booking_waitlist.py ---
"""
Booking waitlist schemas for managing waiting lists.

This module defines schemas for waitlist management when hostels
are fully booked, including notifications and conversions.
"""

from __future__ import annotations

from datetime import date, datetime
from typing import List, Optional
from uuid import UUID

from pydantic import EmailStr, Field, field_validator, computed_field

from app.schemas.common.base import BaseCreateSchema, BaseResponseSchema, BaseSchema
from app.schemas.common.enums import RoomType, WaitlistStatus

__all__ = [
    "WaitlistRequest",
    "WaitlistResponse",
    "WaitlistStatusInfo",
    "WaitlistNotification",
    "WaitlistConversion",
    "WaitlistCancellation",
    "WaitlistManagement",
    "WaitlistEntry",
]


class WaitlistRequest(BaseCreateSchema):
    """
    Request to add visitor to waitlist.
    
    Used when desired room type/date is not available
    and visitor wants to be notified when it becomes available.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID for waitlist",
    )
    visitor_id: UUID = Field(
        ...,
        description="Visitor ID requesting waitlist",
    )

    # Preferences
    room_type: RoomType = Field(
        ...,
        description="Desired room type",
    )
    preferred_check_in_date: date = Field(
        ...,
        description="Desired check-in date",
    )

    # Contact Information
    contact_email: EmailStr = Field(
        ...,
        description="Email address for waitlist notifications",
    )
    contact_phone: str = Field(
        ...,
        pattern=r"^\+?[1-9]\d{9,14}$",
        description="Phone number for notifications",
    )

    # Additional Information
    notes: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional notes or preferences",
    )

    @field_validator("preferred_check_in_date")
    @classmethod
    def validate_check_in_date(cls, v: date) -> date:
        """Validate check-in date is in the future."""
        if v < date.today():
            raise ValueError(
                f"Preferred check-in date ({v.strftime('%Y-%m-%d')}) "
                "cannot be in the past"
            )
        return v

    @field_validator("contact_phone")
    @classmethod
    def normalize_phone(cls, v: str) -> str:
        """Normalize phone number."""
        return v.replace(" ", "").replace("-", "")

    @field_validator("notes")
    @classmethod
    def clean_notes(cls, v: Optional[str]) -> Optional[str]:
        """Clean notes field."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class WaitlistResponse(BaseResponseSchema):
    """
    Response after adding to waitlist.
    
    Confirms waitlist entry with position and estimated timeline.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    visitor_id: UUID = Field(
        ...,
        description="Visitor ID",
    )

    # Waitlist Details
    room_type: RoomType = Field(
        ...,
        description="Room type on waitlist",
    )
    preferred_check_in_date: date = Field(
        ...,
        description="Preferred check-in date",
    )

    # Contact
    contact_email: str = Field(
        ...,
        description="Contact email",
    )
    contact_phone: str = Field(
        ...,
        description="Contact phone",
    )

    # Position and Status
    priority: int = Field(
        ...,
        ge=1,
        description="Position in waitlist (1 = first in line)",
    )
    status: WaitlistStatus = Field(
        ...,
        description="Current waitlist status",
    )

    # Estimated Timeline
    estimated_availability_date: Optional[date] = Field(
        None,
        description="Estimated date when room might become available",
    )

    created_at: datetime = Field(
        ...,
        description="When added to waitlist",
    )

    @computed_field
    @property
    def days_on_waitlist(self) -> int:
        """Calculate days on waitlist."""
        return (datetime.utcnow() - self.created_at).days

    @computed_field
    @property
    def is_top_priority(self) -> bool:
        """Check if this is the top priority entry."""
        return self.priority == 1


class WaitlistStatusInfo(BaseSchema):
    """
    Current waitlist status for a visitor.
    
    Provides detailed status information about waitlist position
    and notifications.
    """

    waitlist_id: UUID = Field(
        ...,
        description="Waitlist entry ID",
    )
    hostel_name: str = Field(
        ...,
        description="Hostel name",
    )
    room_type: str = Field(
        ...,
        description="Room type",
    )

    # Position Information
    position: int = Field(
        ...,
        ge=1,
        description="Current position in queue (1 = next in line)",
    )
    total_in_queue: int = Field(
        ...,
        ge=1,
        description="Total number of people in this waitlist",
    )

    # Status
    status: str = Field(
        ...,
        pattern=r"^(waiting|notified|converted|expired|cancelled)$",
        description="Current waitlist status",
    )

    # Notification Tracking
    last_notification_sent: Optional[datetime] = Field(
        None,
        description="When last notification was sent",
    )
    notification_count: int = Field(
        0,
        ge=0,
        description="Number of notifications sent",
    )

    # Wait Estimation
    estimated_wait_days: Optional[int] = Field(
        None,
        ge=0,
        description="Estimated days until availability",
    )

    @computed_field
    @property
    def position_percentage(self) -> float:
        """Calculate position as percentage of queue."""
        if self.total_in_queue == 0:
            return 0.0
        return round((self.position / self.total_in_queue) * 100, 2)

    @computed_field
    @property
    def is_next_in_line(self) -> bool:
        """Check if visitor is next in line."""
        return self.position == 1


class WaitlistNotification(BaseSchema):
    """
    Notification when room becomes available.
    
    Sent to waitlisted visitor when their desired room/bed
    becomes available.
    """

    waitlist_id: UUID = Field(
        ...,
        description="Waitlist entry ID",
    )
    visitor_id: UUID = Field(
        ...,
        description="Visitor ID to notify",
    )
    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )

    # Availability Details
    message: str = Field(
        ...,
        description="Notification message",
    )
    available_room_id: UUID = Field(
        ...,
        description="ID of available room",
    )
    available_bed_id: UUID = Field(
        ...,
        description="ID of available bed",
    )

    # Action Required
    response_deadline: datetime = Field(
        ...,
        description="Deadline to respond to this notification",
    )

    # Booking Link
    booking_link: str = Field(
        ...,
        description="Direct link to proceed with booking",
    )

    @computed_field
    @property
    def hours_until_deadline(self) -> float:
        """Calculate hours remaining until response deadline."""
        delta = self.response_deadline - datetime.utcnow()
        return round(delta.total_seconds() / 3600, 1)

    @computed_field
    @property
    def is_expiring_soon(self) -> bool:
        """Check if notification is expiring within 6 hours."""
        return self.hours_until_deadline <= 6


class WaitlistConversion(BaseCreateSchema):
    """
    Convert waitlist entry to booking.
    
    Visitor's response to availability notification.
    """

    waitlist_id: UUID = Field(
        ...,
        description="Waitlist entry ID",
    )
    accept: bool = Field(
        ...,
        description="Whether to accept the available room (True/False)",
    )

    # If Accepting
    proceed_with_booking: bool = Field(
        True,
        description="Whether to proceed with creating booking",
    )


class WaitlistCancellation(BaseCreateSchema):
    """
    Remove entry from waitlist.
    
    Visitor can cancel their waitlist entry at any time.
    """

    waitlist_id: UUID = Field(
        ...,
        description="Waitlist entry ID to cancel",
    )
    cancellation_reason: Optional[str] = Field(
        None,
        max_length=500,
        description="Reason for cancelling waitlist entry",
    )

    @field_validator("cancellation_reason")
    @classmethod
    def clean_reason(cls, v: Optional[str]) -> Optional[str]:
        """Clean cancellation reason."""
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v


class WaitlistEntry(BaseSchema):
    """
    Individual waitlist entry for admin view.
    
    Detailed information about a single waitlist entry
    for management purposes.
    """

    waitlist_id: UUID = Field(
        ...,
        description="Waitlist entry ID",
    )
    visitor_name: str = Field(
        ...,
        description="Visitor name",
    )
    contact_email: str = Field(
        ...,
        description="Contact email",
    )
    contact_phone: str = Field(
        ...,
        description="Contact phone",
    )

    # Preferences
    preferred_check_in_date: date = Field(
        ...,
        description="Preferred check-in date",
    )
    priority: int = Field(
        ...,
        ge=1,
        description="Position in waitlist",
    )
    status: WaitlistStatus = Field(
        ...,
        description="Current status",
    )

    # Tracking
    days_waiting: int = Field(
        ...,
        ge=0,
        description="Number of days on waitlist",
    )
    created_at: datetime = Field(
        ...,
        description="When added to waitlist",
    )

    @computed_field
    @property
    def is_long_wait(self) -> bool:
        """Check if entry has been waiting a long time (>30 days)."""
        return self.days_waiting > 30


class WaitlistManagement(BaseSchema):
    """
    Waitlist management view for admins.
    
    Provides overview of all waitlist entries for a specific
    hostel and room type.
    """

    hostel_id: UUID = Field(
        ...,
        description="Hostel ID",
    )
    room_type: RoomType = Field(
        ...,
        description="Room type for this waitlist",
    )

    # Summary
    total_in_waitlist: int = Field(
        ...,
        ge=0,
        description="Total number of entries in waitlist",
    )

    # Entries
    entries: List[WaitlistEntry] = Field(
        default_factory=list,
        description="List of waitlist entries ordered by priority",
    )

    @computed_field
    @property
    def average_wait_days(self) -> float:
        """Calculate average wait time in days."""
        if not self.entries:
            return 0.0
        
        total_days = sum(entry.days_waiting for entry in self.entries)
        return round(total_days / len(self.entries), 1)

    @computed_field
    @property
    def longest_wait_days(self) -> int:
        """Find longest wait time in days."""
        if not self.entries:
            return 0
        
        return max(entry.days_waiting for entry in self.entries)

# --- File: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking\__init__.py ---
# --- File: app/schemas/booking/__init__.py ---
"""
Booking schemas package.

This module exports all booking-related schemas for easy importing
across the application.
"""

from __future__ import annotations

from app.schemas.booking.booking_approval import (
    ApprovalResponse,
    ApprovalSettings,
    BookingApprovalRequest,
    BulkApprovalRequest,
    RejectionRequest,
)
from app.schemas.booking.booking_assignment import (
    AssignmentRequest,
    AssignmentResponse,
    BedAssignment,
    BulkAssignmentRequest,
    ReassignmentRequest,
    RoomAssignment,
    SingleAssignment,
)
from app.schemas.booking.booking_base import (
    BookingBase,
    BookingCreate,
    BookingUpdate,
)
from app.schemas.booking.booking_calendar import (
    AvailabilityCalendar,
    BookingEvent,
    CalendarEvent,
    CalendarView,
    BookingInfo,
    DayAvailability,
    DayBookings,
)
from app.schemas.booking.booking_cancellation import (
    BulkCancellation,
    CancellationCharge,
    CancellationPolicy,
    CancellationRequest,
    CancellationResponse,
    RefundCalculation,
)
from app.schemas.booking.booking_conversion import (
    BulkConversion,
    ChecklistItem,
    ConversionChecklist,
    ConversionResponse,
    ConversionRollback,
    ConvertToStudentRequest,
)
from app.schemas.booking.booking_filters import (
    BookingAnalyticsRequest,
    BookingExportRequest,
    BookingFilterParams,
    BookingSearchRequest,
    BookingSortOptions,
)
from app.schemas.booking.booking_modification import (
    DateChangeRequest,
    DurationChangeRequest,
    ModificationApproval,
    ModificationRequest,
    ModificationResponse,
    RoomTypeChangeRequest,
)
from app.schemas.booking.booking_request import (
    BookingInquiry,
    BookingRequest,
    GuestInformation,
    QuickBookingRequest,
)
from app.schemas.booking.booking_response import (
    BookingConfirmation,
    BookingDetail,
    BookingListItem,
    BookingResponse,
)
from app.schemas.booking.booking_waitlist import (
    WaitlistCancellation,
    WaitlistConversion,
    WaitlistEntry,
    WaitlistManagement,
    WaitlistNotification,
    WaitlistRequest,
    WaitlistResponse,
    WaitlistStatusInfo,
)

__all__ = [
    # Base
    "BookingBase",
    "BookingCreate",
    "BookingUpdate",
    # Request
    "BookingRequest",
    "GuestInformation",
    "BookingInquiry",
    "QuickBookingRequest",
    # Response
    "BookingResponse",
    "BookingDetail",
    "BookingListItem",
    "BookingConfirmation",
    # Approval
    "BookingApprovalRequest",
    "ApprovalResponse",
    "RejectionRequest",
    "BulkApprovalRequest",
    "ApprovalSettings",
    # Assignment
    "RoomAssignment",
    "BedAssignment",
    "AssignmentRequest",
    "AssignmentResponse",
    "BulkAssignmentRequest",
    "SingleAssignment",
    "ReassignmentRequest",
    # Cancellation
    "CancellationRequest",
    "CancellationResponse",
    "RefundCalculation",
    "CancellationPolicy",
    "CancellationCharge",
    "BulkCancellation",
    # Modification
    "ModificationRequest",
    "ModificationResponse",
    "DateChangeRequest",
    "DurationChangeRequest",
    "RoomTypeChangeRequest",
    "ModificationApproval",
    # Calendar
    "CalendarView",
    "DayBookings",
    "BookingEvent",
    "CalendarEvent",
    "AvailabilityCalendar",
    "DayAvailability",
    # Waitlist
    "WaitlistRequest",
    "WaitlistResponse",
    "WaitlistStatusInfo",
    "WaitlistNotification",
    "WaitlistConversion",
    "WaitlistCancellation",
    "WaitlistManagement",
    "WaitlistEntry",
    # Conversion
    "ConvertToStudentRequest",
    "ConversionResponse",
    "ConversionChecklist",
    "ChecklistItem",
    "BulkConversion",
    "ConversionRollback",
    # Filters
    "BookingFilterParams",
    "BookingSearchRequest",
    "BookingSortOptions",
    "BookingExportRequest",
    "BookingAnalyticsRequest",
]


# ===== Folder: C:\Users\HP\OneDrive\Documents\GitHub\HOStel-back\app\schemas\booking\__pycache__ =====
